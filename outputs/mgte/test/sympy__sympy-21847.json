{
  "instance_id": "sympy__sympy-21847",
  "query": "itermonomials returns incorrect monomials when using min_degrees argument\n`itermonomials` returns incorrect monomials when using optional `min_degrees` argument\r\n\r\nFor example, the following code introduces three symbolic variables and generates monomials with max and min degree of 3:\r\n\r\n\r\n```\r\nimport sympy as sp\r\nfrom sympy.polys.orderings import monomial_key\r\n\r\nx1, x2, x3 = sp.symbols('x1, x2, x3')\r\nstates = [x1, x2, x3]\r\nmax_degrees = 3\r\nmin_degrees = 3\r\nmonomials = sorted(sp.itermonomials(states, max_degrees, min_degrees=min_degrees), \r\n                   key=monomial_key('grlex', states))\r\nprint(monomials)\r\n```\r\nThe code returns `[x3**3, x2**3, x1**3]`, when it _should_ also return monomials such as `x1*x2**2, x2*x3**2, etc...` that also have total degree of 3. This behaviour is inconsistent with the documentation that states that \r\n\r\n> A generator of all monomials `monom` is returned, such that either `min_degree <= total_degree(monom) <= max_degree`...\r\n\r\nThe monomials are also missing when `max_degrees` is increased above `min_degrees`.\n",
  "ground_truth": {
    "files": [
      "sympy/polys/monomials.py"
    ],
    "locations": [
      "sympy/polys/monomials.py::itermonomials"
    ]
  },
  "predictions": [
    "sympy/polys/tests/test_monomials.py::test_monomials",
    "sympy/polys/monomials.py::itermonomials",
    "sympy/polys/monomials.py::monomial_min",
    "sympy/polys/orderings.py::monomial_key",
    "sympy/polys/monomials.py::monomial_max",
    "sympy/polys/monomials.py::monomial_deg",
    "sympy/polys/tests/test_orderings.py::test_monomial_key",
    "sympy/polys/orderings.py::GradedLexOrder.__call__",
    "sympy/polys/orderings.py::MonomialOrder.__call__",
    "sympy/polys/orderings.py::ReversedGradedLexOrder.__call__"
  ],
  "metadata": {
    "repo": "sympy/sympy",
    "commit": "d9b18c518d64d0ebe8e35a98c2fb519938b9b151",
    "total_functions_indexed": 36916,
    "retrieval_time_seconds": 0.011003971099853516
  },
  "raw_output": "[{\"doc_id\": \"sympy/polys/tests/test_monomials.py::test_monomials\", \"score\": 0.7714000940322876}, {\"doc_id\": \"sympy/polys/monomials.py::itermonomials\", \"score\": 0.7666906714439392}, {\"doc_id\": \"sympy/polys/monomials.py::monomial_min\", \"score\": 0.7602725625038147}, {\"doc_id\": \"sympy/polys/orderings.py::monomial_key\", \"score\": 0.7423515915870667}, {\"doc_id\": \"sympy/polys/monomials.py::monomial_max\", \"score\": 0.7354692220687866}, {\"doc_id\": \"sympy/polys/monomials.py::monomial_deg\", \"score\": 0.7186840772628784}, {\"doc_id\": \"sympy/polys/tests/test_orderings.py::test_monomial_key\", \"score\": 0.7173135280609131}, {\"doc_id\": \"sympy/polys/orderings.py::GradedLexOrder.__call__\", \"score\": 0.7100463509559631}, {\"doc_id\": \"sympy/polys/orderings.py::MonomialOrder.__call__\", \"score\": 0.7067939639091492}, {\"doc_id\": \"sympy/polys/orderings.py::ReversedGradedLexOrder.__call__\", \"score\": 0.7064749002456665}]"
}