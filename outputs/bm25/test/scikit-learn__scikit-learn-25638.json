{
  "instance_id": "scikit-learn__scikit-learn-25638",
  "query": "Support nullable pandas dtypes in `unique_labels`\n### Describe the workflow you want to enable\n\nI would like to be able to pass the nullable pandas dtypes (\"Int64\", \"Float64\", \"boolean\") into sklearn's `unique_labels` function. Because the dtypes become `object` dtype when converted to numpy arrays we get `ValueError: Mix type of y not allowed, got types {'binary', 'unknown'}`:\r\n\r\nRepro with sklearn 1.2.1\r\n```py \r\n    import pandas as pd\r\n    import pytest\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"Int64\", \"Float64\", \"boolean\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        with pytest.raises(ValueError, match=\"Mix type of y not allowed, got types\"):\r\n            unique_labels(y_true, y_predicted)\r\n```\n\n### Describe your proposed solution\n\nWe should get the same behavior as when `int64`, `float64`, and `bool` dtypes are used, which is no error:  \r\n\r\n```python\r\n    import pandas as pd\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"int64\", \"float64\", \"bool\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        unique_labels(y_true, y_predicted)\r\n```\n\n### Describe alternatives you've considered, if relevant\n\nOur current workaround is to convert the data to numpy arrays with the corresponding dtype that works prior to passing it into `unique_labels`.\n\n### Additional context\n\n_No response_\n",
  "ground_truth": {
    "files": [
      "sklearn/utils/multiclass.py"
    ],
    "locations": [
      "sklearn/utils/multiclass.py::is_multilabel",
      "sklearn/utils/multiclass.py::type_of_target"
    ]
  },
  "predictions": [
    "sklearn/impute/tests/test_impute.py::test_simple_impute_pd_na",
    "sklearn/utils/tests/test_testing.py::test_convert_container",
    "sklearn/feature_selection/tests/test_base.py::test_output_dataframe",
    "sklearn/utils/tests/test_validation.py::test_check_dataframe_mixed_float_dtypes",
    "sklearn/utils/multiclass.py::unique_labels",
    "sklearn/datasets/_arff_parser.py::_liac_arff_parser",
    "sklearn/utils/validation.py::check_array",
    "sklearn/compose/tests/test_column_transformer.py::test_column_transform_set_output_mixed",
    "sklearn/utils/tests/test_validation.py::test_check_array_panadas_na_support_series",
    "sklearn/datasets/_arff_parser.py::_pandas_arff_parser"
  ],
  "metadata": {
    "repo": "scikit-learn/scikit-learn",
    "commit": "6adb209acd63825affc884abcd85381f148fb1b0",
    "total_functions_indexed": 9157,
    "retrieval_time_seconds": 0.7252352237701416
  },
  "raw_output": "[{\"doc_id\": \"sklearn/impute/tests/test_impute.py::test_simple_impute_pd_na\", \"score\": 275.09343837716085}, {\"doc_id\": \"sklearn/utils/tests/test_testing.py::test_convert_container\", \"score\": 255.85317311116202}, {\"doc_id\": \"sklearn/feature_selection/tests/test_base.py::test_output_dataframe\", \"score\": 248.75922167609966}, {\"doc_id\": \"sklearn/utils/tests/test_validation.py::test_check_dataframe_mixed_float_dtypes\", \"score\": 248.6726303577899}, {\"doc_id\": \"sklearn/utils/multiclass.py::unique_labels\", \"score\": 243.19113987578297}, {\"doc_id\": \"sklearn/datasets/_arff_parser.py::_liac_arff_parser\", \"score\": 236.53634797489292}, {\"doc_id\": \"sklearn/utils/validation.py::check_array\", \"score\": 233.17016362949545}, {\"doc_id\": \"sklearn/compose/tests/test_column_transformer.py::test_column_transform_set_output_mixed\", \"score\": 233.0617135298647}, {\"doc_id\": \"sklearn/utils/tests/test_validation.py::test_check_array_panadas_na_support_series\", \"score\": 230.57795077057685}, {\"doc_id\": \"sklearn/datasets/_arff_parser.py::_pandas_arff_parser\", \"score\": 229.53438572844496}]"
}