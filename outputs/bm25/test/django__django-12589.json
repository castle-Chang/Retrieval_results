{
  "instance_id": "django__django-12589",
  "query": "Django 3.0: \"GROUP BY\" clauses error with tricky field annotation\nDescription\n\t\nLet's pretend that we have next model structure with next model's relations:\nclass A(models.Model):\n\tbs = models.ManyToManyField('B',\n\t\t\t\t\t\t\t\trelated_name=\"a\",\n\t\t\t\t\t\t\t\tthrough=\"AB\")\nclass B(models.Model):\n\tpass\nclass AB(models.Model):\n\ta = models.ForeignKey(A, on_delete=models.CASCADE, related_name=\"ab_a\")\n\tb = models.ForeignKey(B, on_delete=models.CASCADE, related_name=\"ab_b\")\n\tstatus = models.IntegerField()\nclass C(models.Model):\n\ta = models.ForeignKey(\n\t\tA,\n\t\tnull=True,\n\t\tblank=True,\n\t\ton_delete=models.SET_NULL,\n\t\trelated_name=\"c\",\n\t\tverbose_name=_(\"a\")\n\t)\n\tstatus = models.IntegerField()\nLet's try to evaluate next query\nab_query = AB.objects.filter(a=OuterRef(\"pk\"), b=1)\nfilter_conditions = Q(pk=1) | Q(ab_a__b=1)\nquery = A.objects.\\\n\tfilter(filter_conditions).\\\n\tannotate(\n\t\tstatus=Subquery(ab_query.values(\"status\")),\n\t\tc_count=Count(\"c\"),\n)\nanswer = query.values(\"status\").annotate(total_count=Count(\"status\"))\nprint(answer.query)\nprint(answer)\nOn Django 3.0.4 we have an error\ndjango.db.utils.ProgrammingError: column reference \"status\" is ambiguous\nand query is next:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY \"status\"\nHowever, Django 2.2.11 processed this query properly with the next query:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))\nso, the difference in \"GROUP BY\" clauses\n(as DB provider uses \"django.db.backends.postgresql\", postgresql 11)\n",
  "ground_truth": {
    "files": [
      "django/db/models/sql/query.py"
    ],
    "locations": [
      "django/db/models/sql/query.py::Query",
      "django/db/models/sql/query.py::Query.set_group_by"
    ]
  },
  "predictions": [
    "tests/queries/tests.py::Queries1Tests.test_subquery_condition",
    "tests/raw_query/tests.py::RawQueryTests.test_annotations",
    "tests/queries/tests.py::ValuesSubqueryTests.test_values_in_subquery",
    "tests/select_for_update/tests.py::SelectForUpdateTests.test_raw_lock_not_available",
    "tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_ambiguous_relationship_model_from",
    "tests/queries/tests.py::DisjunctionPromotionTests.test_disjunction_promotion5_demote",
    "tests/expressions/tests.py::BasicExpressionsTests.test_aggregate_subquery_annotation",
    "tests/aggregation_regress/tests.py::AggregationTests.test_annotate_with_extra",
    "tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_ambiguous_relationship_model_to",
    "tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_invalid_related_query_name"
  ],
  "metadata": {
    "repo": "django/django",
    "commit": "895f28f9cbed817c00ab68770433170d83132d90",
    "total_functions_indexed": 23366,
    "retrieval_time_seconds": 2.5293047428131104
  },
  "raw_output": "[{\"doc_id\": \"tests/queries/tests.py::Queries1Tests.test_subquery_condition\", \"score\": 370.7612694603784}, {\"doc_id\": \"tests/raw_query/tests.py::RawQueryTests.test_annotations\", \"score\": 317.9992129742639}, {\"doc_id\": \"tests/queries/tests.py::ValuesSubqueryTests.test_values_in_subquery\", \"score\": 278.9206333898063}, {\"doc_id\": \"tests/select_for_update/tests.py::SelectForUpdateTests.test_raw_lock_not_available\", \"score\": 267.6732540031641}, {\"doc_id\": \"tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_ambiguous_relationship_model_from\", \"score\": 260.7519058169376}, {\"doc_id\": \"tests/queries/tests.py::DisjunctionPromotionTests.test_disjunction_promotion5_demote\", \"score\": 250.92092001773742}, {\"doc_id\": \"tests/expressions/tests.py::BasicExpressionsTests.test_aggregate_subquery_annotation\", \"score\": 245.65714560711515}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_annotate_with_extra\", \"score\": 244.9749099433688}, {\"doc_id\": \"tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_ambiguous_relationship_model_to\", \"score\": 244.72181369090058}, {\"doc_id\": \"tests/invalid_models_tests/test_relative_fields.py::RelativeFieldTests.test_invalid_related_query_name\", \"score\": 240.54569880548678}]"
}