{
  "instance_id": "sympy__sympy-21379",
  "query": "Unexpected `PolynomialError` when using simple `subs()` for particular expressions\nI am seeing weird behavior with `subs` for particular expressions with hyperbolic sinusoids with piecewise arguments. When applying `subs`, I obtain an unexpected `PolynomialError`. For context, I was umbrella-applying a casting from int to float of all int atoms for a bunch of random expressions before using a tensorflow lambdify to avoid potential tensorflow type errors. You can pretend the expression below has a `+ 1` at the end, but below is the MWE that I could produce.\r\n\r\nSee the expression below, and the conditions in which the exception arises.\r\n\r\nSympy version: 1.8.dev\r\n\r\n```python\r\nfrom sympy import *\r\nfrom sympy.core.cache import clear_cache\r\n\r\nx, y, z = symbols('x y z')\r\n\r\nclear_cache()\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This works fine\r\nexpr.subs({1: 1.0})\r\n\r\nclear_cache()\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This fails with \"PolynomialError: Piecewise generators do not make sense\"\r\nexpr.subs({1: 1.0})  # error\r\n# Now run it again (isympy...) w/o clearing cache and everything works as expected without error\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nI am not really sure where the issue is, but I think it has something to do with the order of assumptions in this specific type of expression. Here is what I found-\r\n\r\n- The error only (AFAIK) happens with `cosh` or `tanh` in place of `sinh`, otherwise it succeeds\r\n- The error goes away if removing the division by `z`\r\n- The error goes away if removing `exp` (but stays for most unary functions, `sin`, `log`, etc.)\r\n- The error only happens with real symbols for `x` and `y` (`z` does not have to be real)\r\n\r\nNot too sure how to debug this one.\n",
  "ground_truth": {
    "files": [
      "sympy/core/mod.py"
    ],
    "locations": [
      "sympy/core/mod.py::Mod",
      "sympy/core/mod.py::Mod.eval"
    ]
  },
  "predictions": [
    "sympy/utilities/lambdify.py::lambdify",
    "sympy/printing/glsl.py::glsl_code",
    "sympy/core/function.py::expand",
    "sympy/solvers/solvers.py::solve",
    "sympy/tensor/index_methods.py::get_indices",
    "sympy/simplify/simplify.py::simplify",
    "sympy/simplify/trigsimp.py::trigsimp_groebner",
    "sympy/simplify/simplify.py::separatevars",
    "sympy/core/operations.py::AssocOp._matches_commutative",
    "sympy/solvers/solvers.py::solve_linear"
  ],
  "metadata": {
    "repo": "sympy/sympy",
    "commit": "624217179aaf8d094e6ff75b7493ad1ee47599b0",
    "total_functions_indexed": 36400,
    "retrieval_time_seconds": 3.716510057449341
  },
  "raw_output": "[{\"doc_id\": \"sympy/utilities/lambdify.py::lambdify\", \"score\": 394.2145621451319}, {\"doc_id\": \"sympy/printing/glsl.py::glsl_code\", \"score\": 375.2672108883627}, {\"doc_id\": \"sympy/core/function.py::expand\", \"score\": 373.66547108084893}, {\"doc_id\": \"sympy/solvers/solvers.py::solve\", \"score\": 371.4669427729626}, {\"doc_id\": \"sympy/tensor/index_methods.py::get_indices\", \"score\": 370.4690785055947}, {\"doc_id\": \"sympy/simplify/simplify.py::simplify\", \"score\": 367.2055154863558}, {\"doc_id\": \"sympy/simplify/trigsimp.py::trigsimp_groebner\", \"score\": 355.9792105073924}, {\"doc_id\": \"sympy/simplify/simplify.py::separatevars\", \"score\": 355.92651320287536}, {\"doc_id\": \"sympy/core/operations.py::AssocOp._matches_commutative\", \"score\": 355.5548159274048}, {\"doc_id\": \"sympy/solvers/solvers.py::solve_linear\", \"score\": 354.3714776885633}]"
}