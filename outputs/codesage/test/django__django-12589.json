{
  "instance_id": "django__django-12589",
  "query": "Django 3.0: \"GROUP BY\" clauses error with tricky field annotation\nDescription\n\t\nLet's pretend that we have next model structure with next model's relations:\nclass A(models.Model):\n\tbs = models.ManyToManyField('B',\n\t\t\t\t\t\t\t\trelated_name=\"a\",\n\t\t\t\t\t\t\t\tthrough=\"AB\")\nclass B(models.Model):\n\tpass\nclass AB(models.Model):\n\ta = models.ForeignKey(A, on_delete=models.CASCADE, related_name=\"ab_a\")\n\tb = models.ForeignKey(B, on_delete=models.CASCADE, related_name=\"ab_b\")\n\tstatus = models.IntegerField()\nclass C(models.Model):\n\ta = models.ForeignKey(\n\t\tA,\n\t\tnull=True,\n\t\tblank=True,\n\t\ton_delete=models.SET_NULL,\n\t\trelated_name=\"c\",\n\t\tverbose_name=_(\"a\")\n\t)\n\tstatus = models.IntegerField()\nLet's try to evaluate next query\nab_query = AB.objects.filter(a=OuterRef(\"pk\"), b=1)\nfilter_conditions = Q(pk=1) | Q(ab_a__b=1)\nquery = A.objects.\\\n\tfilter(filter_conditions).\\\n\tannotate(\n\t\tstatus=Subquery(ab_query.values(\"status\")),\n\t\tc_count=Count(\"c\"),\n)\nanswer = query.values(\"status\").annotate(total_count=Count(\"status\"))\nprint(answer.query)\nprint(answer)\nOn Django 3.0.4 we have an error\ndjango.db.utils.ProgrammingError: column reference \"status\" is ambiguous\nand query is next:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY \"status\"\nHowever, Django 2.2.11 processed this query properly with the next query:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))\nso, the difference in \"GROUP BY\" clauses\n(as DB provider uses \"django.db.backends.postgresql\", postgresql 11)\n",
  "ground_truth": {
    "files": [
      "django/db/models/sql/query.py"
    ],
    "locations": [
      "django/db/models/sql/query.py::Query",
      "django/db/models/sql/query.py::Query.set_group_by"
    ]
  },
  "predictions": [
    "tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation",
    "tests/aggregation_regress/tests.py::AggregationTests.test_more_more",
    "tests/aggregation_regress/tests.py::AggregationTests.test_aggregate_duplicate_columns_select_related",
    "tests/aggregation_regress/tests.py::AggregationTests.test_annotate_with_extra",
    "tests/aggregation/tests.py::AggregateTestCase.test_group_by_subquery_annotation",
    "tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_multivalued",
    "tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_values",
    "tests/aggregation_regress/tests.py::AggregationTests.test_aggregate_duplicate_columns",
    "tests/expressions_case/tests.py::CaseExpressionTests.test_m2m_reuse",
    "tests/aggregation_regress/tests.py::AggregationTests.test_fobj_group_by"
  ],
  "metadata": {
    "repo": "django/django",
    "commit": "895f28f9cbed817c00ab68770433170d83132d90",
    "total_functions_indexed": 23366,
    "retrieval_time_seconds": 0.007820367813110352
  },
  "raw_output": "[{\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation\", \"score\": 0.5893086194992065}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_more_more\", \"score\": 0.5542001724243164}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_aggregate_duplicate_columns_select_related\", \"score\": 0.545263946056366}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_annotate_with_extra\", \"score\": 0.5409380793571472}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_group_by_subquery_annotation\", \"score\": 0.5318341255187988}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_multivalued\", \"score\": 0.5277631282806396}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_values\", \"score\": 0.5227609872817993}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_aggregate_duplicate_columns\", \"score\": 0.5186164975166321}, {\"doc_id\": \"tests/expressions_case/tests.py::CaseExpressionTests.test_m2m_reuse\", \"score\": 0.5141657590866089}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_fobj_group_by\", \"score\": 0.5090673565864563}]"
}