{
  "instance_id": "scikit-learn__scikit-learn-25638",
  "query": "Support nullable pandas dtypes in `unique_labels`\n### Describe the workflow you want to enable\n\nI would like to be able to pass the nullable pandas dtypes (\"Int64\", \"Float64\", \"boolean\") into sklearn's `unique_labels` function. Because the dtypes become `object` dtype when converted to numpy arrays we get `ValueError: Mix type of y not allowed, got types {'binary', 'unknown'}`:\r\n\r\nRepro with sklearn 1.2.1\r\n```py \r\n    import pandas as pd\r\n    import pytest\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"Int64\", \"Float64\", \"boolean\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        with pytest.raises(ValueError, match=\"Mix type of y not allowed, got types\"):\r\n            unique_labels(y_true, y_predicted)\r\n```\n\n### Describe your proposed solution\n\nWe should get the same behavior as when `int64`, `float64`, and `bool` dtypes are used, which is no error:  \r\n\r\n```python\r\n    import pandas as pd\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"int64\", \"float64\", \"bool\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        unique_labels(y_true, y_predicted)\r\n```\n\n### Describe alternatives you've considered, if relevant\n\nOur current workaround is to convert the data to numpy arrays with the corresponding dtype that works prior to passing it into `unique_labels`.\n\n### Additional context\n\n_No response_\n",
  "ground_truth": {
    "files": [
      "sklearn/utils/multiclass.py"
    ],
    "locations": [
      "sklearn/utils/multiclass.py::is_multilabel",
      "sklearn/utils/multiclass.py::type_of_target"
    ]
  },
  "predictions": [
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels_non_specific",
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels_mixed_types",
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels",
    "sklearn/utils/multiclass.py::unique_labels",
    "sklearn/utils/multiclass.py::_unique_multiclass",
    "sklearn/utils/tests/test_multiclass.py::test_check_classification_targets",
    "sklearn/utils/multiclass.py::check_classification_targets",
    "sklearn/utils/tests/test_encode.py::test_unique_util_missing_values_objects",
    "sklearn/utils/tests/test_encode.py::test_encode_with_check_unknown",
    "sklearn/utils/tests/test_encode.py::test_unique_util_with_all_missing_values"
  ],
  "metadata": {
    "repo": "scikit-learn/scikit-learn",
    "commit": "6adb209acd63825affc884abcd85381f148fb1b0",
    "total_functions_indexed": 9157,
    "retrieval_time_seconds": 0.09285831451416016
  },
  "raw_output": "[{\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels_non_specific\", \"score\": 0.6698585748672485}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels_mixed_types\", \"score\": 0.6266859769821167}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels\", \"score\": 0.5564652681350708}, {\"doc_id\": \"sklearn/utils/multiclass.py::unique_labels\", \"score\": 0.44989216327667236}, {\"doc_id\": \"sklearn/utils/multiclass.py::_unique_multiclass\", \"score\": 0.44062235951423645}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_check_classification_targets\", \"score\": 0.43707969784736633}, {\"doc_id\": \"sklearn/utils/multiclass.py::check_classification_targets\", \"score\": 0.413236141204834}, {\"doc_id\": \"sklearn/utils/tests/test_encode.py::test_unique_util_missing_values_objects\", \"score\": 0.4054713249206543}, {\"doc_id\": \"sklearn/utils/tests/test_encode.py::test_encode_with_check_unknown\", \"score\": 0.3841056525707245}, {\"doc_id\": \"sklearn/utils/tests/test_encode.py::test_unique_util_with_all_missing_values\", \"score\": 0.3784250020980835}]"
}