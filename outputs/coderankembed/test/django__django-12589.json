{
  "instance_id": "django__django-12589",
  "query": "Django 3.0: \"GROUP BY\" clauses error with tricky field annotation\nDescription\n\t\nLet's pretend that we have next model structure with next model's relations:\nclass A(models.Model):\n\tbs = models.ManyToManyField('B',\n\t\t\t\t\t\t\t\trelated_name=\"a\",\n\t\t\t\t\t\t\t\tthrough=\"AB\")\nclass B(models.Model):\n\tpass\nclass AB(models.Model):\n\ta = models.ForeignKey(A, on_delete=models.CASCADE, related_name=\"ab_a\")\n\tb = models.ForeignKey(B, on_delete=models.CASCADE, related_name=\"ab_b\")\n\tstatus = models.IntegerField()\nclass C(models.Model):\n\ta = models.ForeignKey(\n\t\tA,\n\t\tnull=True,\n\t\tblank=True,\n\t\ton_delete=models.SET_NULL,\n\t\trelated_name=\"c\",\n\t\tverbose_name=_(\"a\")\n\t)\n\tstatus = models.IntegerField()\nLet's try to evaluate next query\nab_query = AB.objects.filter(a=OuterRef(\"pk\"), b=1)\nfilter_conditions = Q(pk=1) | Q(ab_a__b=1)\nquery = A.objects.\\\n\tfilter(filter_conditions).\\\n\tannotate(\n\t\tstatus=Subquery(ab_query.values(\"status\")),\n\t\tc_count=Count(\"c\"),\n)\nanswer = query.values(\"status\").annotate(total_count=Count(\"status\"))\nprint(answer.query)\nprint(answer)\nOn Django 3.0.4 we have an error\ndjango.db.utils.ProgrammingError: column reference \"status\" is ambiguous\nand query is next:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = \"test_app_a\".\"id\" AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY \"status\"\nHowever, Django 2.2.11 processed this query properly with the next query:\nSELECT (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1)) AS \"status\", COUNT((SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))) AS \"total_count\" FROM \"test_app_a\" LEFT OUTER JOIN \"test_app_ab\" ON (\"test_app_a\".\"id\" = \"test_app_ab\".\"a_id\") LEFT OUTER JOIN \"test_app_c\" ON (\"test_app_a\".\"id\" = \"test_app_c\".\"a_id\") WHERE (\"test_app_a\".\"id\" = 1 OR \"test_app_ab\".\"b_id\" = 1) GROUP BY (SELECT U0.\"status\" FROM \"test_app_ab\" U0 WHERE (U0.\"a_id\" = (\"test_app_a\".\"id\") AND U0.\"b_id\" = 1))\nso, the difference in \"GROUP BY\" clauses\n(as DB provider uses \"django.db.backends.postgresql\", postgresql 11)\n",
  "ground_truth": {
    "files": [
      "django/db/models/sql/query.py"
    ],
    "locations": [
      "django/db/models/sql/query.py::Query",
      "django/db/models/sql/query.py::Query.set_group_by"
    ]
  },
  "predictions": [
    "tests/aggregation/tests.py::AggregateTestCase.test_group_by_subquery_annotation",
    "tests/aggregation_regress/tests.py::AggregationTests.test_more_more",
    "tests/expressions_case/tests.py::CaseExpressionTests.test_m2m_reuse",
    "tests/aggregation_regress/tests.py::AggregationTests.test_fobj_group_by",
    "tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation",
    "django/db/models/query.py::QuerySet.annotate",
    "tests/aggregation/tests.py::AggregateTestCase.test_values_annotation_with_expression",
    "tests/aggregation_regress/tests.py::AggregationTests.test_annotation",
    "tests/generic_relations_regress/tests.py::GenericRelationTests.test_annotate",
    "tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_related_field"
  ],
  "metadata": {
    "repo": "django/django",
    "commit": "895f28f9cbed817c00ab68770433170d83132d90",
    "total_functions_indexed": 23366,
    "retrieval_time_seconds": 0.00574040412902832
  },
  "raw_output": "[{\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_group_by_subquery_annotation\", \"score\": 0.5013279914855957}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_more_more\", \"score\": 0.4909367561340332}, {\"doc_id\": \"tests/expressions_case/tests.py::CaseExpressionTests.test_m2m_reuse\", \"score\": 0.48516833782196045}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_fobj_group_by\", \"score\": 0.4842948615550995}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation\", \"score\": 0.47386106848716736}, {\"doc_id\": \"django/db/models/query.py::QuerySet.annotate\", \"score\": 0.4729812443256378}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_values_annotation_with_expression\", \"score\": 0.4715542197227478}, {\"doc_id\": \"tests/aggregation_regress/tests.py::AggregationTests.test_annotation\", \"score\": 0.4670359194278717}, {\"doc_id\": \"tests/generic_relations_regress/tests.py::GenericRelationTests.test_annotate\", \"score\": 0.46531981229782104}, {\"doc_id\": \"tests/aggregation/tests.py::AggregateTestCase.test_aggregation_subquery_annotation_related_field\", \"score\": 0.4635796546936035}]"
}