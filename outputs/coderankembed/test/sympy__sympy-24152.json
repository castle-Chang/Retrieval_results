{
  "instance_id": "sympy__sympy-24152",
  "query": "Bug in expand of TensorProduct + Workaround + Fix\n### Error description\r\nThe expansion of a TensorProduct object stops incomplete if summands in the tensor product factors have (scalar) factors, e.g.\r\n```\r\nfrom sympy import *\r\nfrom sympy.physics.quantum import *\r\nU = Operator('U')\r\nV = Operator('V')\r\nP = TensorProduct(2*U - V, U + V)\r\nprint(P) \r\n# (2*U - V)x(U + V)\r\nprint(P.expand(tensorproduct=True)) \r\n#result: 2*Ux(U + V) - Vx(U + V) #expansion has missed 2nd tensor factor and is incomplete\r\n```\r\nThis is clearly not the expected behaviour. It also effects other functions that rely on .expand(tensorproduct=True), as e.g. qapply() .\r\n\r\n### Work around\r\nRepeat .expand(tensorproduct=True) as may times as there are tensor factors, resp. until the expanded term does no longer change. This is however only reasonable in interactive session and not in algorithms.\r\n\r\n### Code Fix\r\n.expand relies on the method TensorProduct._eval_expand_tensorproduct(). The issue arises from an inprecise check in TensorProduct._eval_expand_tensorproduct() whether a recursive call is required; it fails when the creation of a TensorProduct object returns commutative (scalar) factors up front: in that case the constructor returns a Mul(c_factors, TensorProduct(..)).\r\nI thus propose the following  code fix in TensorProduct._eval_expand_tensorproduct() in quantum/tensorproduct.py.  I have marked the four lines to be added / modified:\r\n```\r\n    def _eval_expand_tensorproduct(self, **hints):\r\n                ...\r\n                for aa in args[i].args:\r\n                    tp = TensorProduct(*args[:i] + (aa,) + args[i + 1:])\r\n                    c_part, nc_part = tp.args_cnc() #added\r\n                    if len(nc_part)==1 and isinstance(nc_part[0], TensorProduct): #modified\r\n                        nc_part = (nc_part[0]._eval_expand_tensorproduct(), ) #modified\r\n                    add_args.append(Mul(*c_part)*Mul(*nc_part)) #modified\r\n                break\r\n                ...\r\n```\r\nThe fix splits of commutative (scalar) factors from the tp returned. The TensorProduct object will be the one nc factor in nc_part (see TensorProduct.__new__ constructor), if any. Note that the constructor will return 0 if a tensor factor is 0, so there is no guarantee that tp contains a TensorProduct object (e.g. TensorProduct(U-U, U+V).\r\n\r\n\r\n\n",
  "ground_truth": {
    "files": [
      "sympy/physics/quantum/tensorproduct.py"
    ],
    "locations": [
      "sympy/physics/quantum/tensorproduct.py::TensorProduct",
      "sympy/physics/quantum/tensorproduct.py::TensorProduct._eval_expand_tensorproduct"
    ]
  },
  "predictions": [
    "sympy/physics/quantum/tensorproduct.py::TensorProduct._eval_expand_tensorproduct",
    "sympy/physics/quantum/tests/test_tensorproduct.py::test_tensor_product_expand",
    "sympy/physics/quantum/tests/test_tensorproduct.py::test_tensor_product_commutator",
    "sympy/physics/quantum/tensorproduct.py::TensorProduct._eval_rewrite",
    "sympy/core/tests/test_args.py::test_sympy__physics__quantum__tensorproduct__TensorProduct",
    "sympy/physics/quantum/tests/test_tensorproduct.py::test_issue_5923",
    "sympy/physics/quantum/tensorproduct.py::tensor_product_simp",
    "sympy/tensor/tests/test_functions.py::test_TensorProduct_construction",
    "sympy/physics/quantum/tests/test_qapply.py::test_tensorproduct",
    "sympy/physics/quantum/tensorproduct.py::tensor_product_simp_Mul"
  ],
  "metadata": {
    "repo": "sympy/sympy",
    "commit": "b9af885473ad7e34b5b0826cb424dd26d8934670",
    "total_functions_indexed": 38174,
    "retrieval_time_seconds": 0.011746406555175781
  },
  "raw_output": "[{\"doc_id\": \"sympy/physics/quantum/tensorproduct.py::TensorProduct._eval_expand_tensorproduct\", \"score\": 0.7282155752182007}, {\"doc_id\": \"sympy/physics/quantum/tests/test_tensorproduct.py::test_tensor_product_expand\", \"score\": 0.7271880507469177}, {\"doc_id\": \"sympy/physics/quantum/tests/test_tensorproduct.py::test_tensor_product_commutator\", \"score\": 0.6189531087875366}, {\"doc_id\": \"sympy/physics/quantum/tensorproduct.py::TensorProduct._eval_rewrite\", \"score\": 0.6185097694396973}, {\"doc_id\": \"sympy/core/tests/test_args.py::test_sympy__physics__quantum__tensorproduct__TensorProduct\", \"score\": 0.5789681673049927}, {\"doc_id\": \"sympy/physics/quantum/tests/test_tensorproduct.py::test_issue_5923\", \"score\": 0.5518866777420044}, {\"doc_id\": \"sympy/physics/quantum/tensorproduct.py::tensor_product_simp\", \"score\": 0.5500323176383972}, {\"doc_id\": \"sympy/tensor/tests/test_functions.py::test_TensorProduct_construction\", \"score\": 0.5475519895553589}, {\"doc_id\": \"sympy/physics/quantum/tests/test_qapply.py::test_tensorproduct\", \"score\": 0.5397912263870239}, {\"doc_id\": \"sympy/physics/quantum/tensorproduct.py::tensor_product_simp_Mul\", \"score\": 0.5388762950897217}]"
}