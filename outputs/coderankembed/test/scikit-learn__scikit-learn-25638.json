{
  "instance_id": "scikit-learn__scikit-learn-25638",
  "query": "Support nullable pandas dtypes in `unique_labels`\n### Describe the workflow you want to enable\n\nI would like to be able to pass the nullable pandas dtypes (\"Int64\", \"Float64\", \"boolean\") into sklearn's `unique_labels` function. Because the dtypes become `object` dtype when converted to numpy arrays we get `ValueError: Mix type of y not allowed, got types {'binary', 'unknown'}`:\r\n\r\nRepro with sklearn 1.2.1\r\n```py \r\n    import pandas as pd\r\n    import pytest\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"Int64\", \"Float64\", \"boolean\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        with pytest.raises(ValueError, match=\"Mix type of y not allowed, got types\"):\r\n            unique_labels(y_true, y_predicted)\r\n```\n\n### Describe your proposed solution\n\nWe should get the same behavior as when `int64`, `float64`, and `bool` dtypes are used, which is no error:  \r\n\r\n```python\r\n    import pandas as pd\r\n    from sklearn.utils.multiclass import unique_labels\r\n    \r\n    for dtype in [\"int64\", \"float64\", \"bool\"]:\r\n        y_true = pd.Series([1, 0, 0, 1, 0, 1, 1, 0, 1], dtype=dtype)\r\n        y_predicted = pd.Series([0, 0, 1, 1, 0, 1, 1, 1, 1], dtype=\"int64\")\r\n\r\n        unique_labels(y_true, y_predicted)\r\n```\n\n### Describe alternatives you've considered, if relevant\n\nOur current workaround is to convert the data to numpy arrays with the corresponding dtype that works prior to passing it into `unique_labels`.\n\n### Additional context\n\n_No response_\n",
  "ground_truth": {
    "files": [
      "sklearn/utils/multiclass.py"
    ],
    "locations": [
      "sklearn/utils/multiclass.py::is_multilabel",
      "sklearn/utils/multiclass.py::type_of_target"
    ]
  },
  "predictions": [
    "sklearn/utils/multiclass.py::unique_labels",
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels_non_specific",
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels_mixed_types",
    "sklearn/utils/tests/test_multiclass.py::test_unique_labels",
    "sklearn/tests/test_isotonic.py::test_make_unique_dtype",
    "sklearn/utils/multiclass.py::_unique_multiclass",
    "sklearn/tests/test_isotonic.py::test_make_unique_tolerance",
    "sklearn/utils/_encode.py::_unique",
    "sklearn/utils/multiclass.py::is_multilabel",
    "sklearn/utils/tests/test_encode.py::test_encode_with_check_unknown"
  ],
  "metadata": {
    "repo": "scikit-learn/scikit-learn",
    "commit": "6adb209acd63825affc884abcd85381f148fb1b0",
    "total_functions_indexed": 9157,
    "retrieval_time_seconds": 0.0026705265045166016
  },
  "raw_output": "[{\"doc_id\": \"sklearn/utils/multiclass.py::unique_labels\", \"score\": 0.6269810199737549}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels_non_specific\", \"score\": 0.6169369220733643}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels_mixed_types\", \"score\": 0.6159205436706543}, {\"doc_id\": \"sklearn/utils/tests/test_multiclass.py::test_unique_labels\", \"score\": 0.5568280220031738}, {\"doc_id\": \"sklearn/tests/test_isotonic.py::test_make_unique_dtype\", \"score\": 0.47915878891944885}, {\"doc_id\": \"sklearn/utils/multiclass.py::_unique_multiclass\", \"score\": 0.45333659648895264}, {\"doc_id\": \"sklearn/tests/test_isotonic.py::test_make_unique_tolerance\", \"score\": 0.4339280426502228}, {\"doc_id\": \"sklearn/utils/_encode.py::_unique\", \"score\": 0.4290280342102051}, {\"doc_id\": \"sklearn/utils/multiclass.py::is_multilabel\", \"score\": 0.4265487492084503}, {\"doc_id\": \"sklearn/utils/tests/test_encode.py::test_encode_with_check_unknown\", \"score\": 0.420510470867157}]"
}