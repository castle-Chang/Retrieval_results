{"doc_id": "astroid/arguments.py::CallSite.__init__", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "__init__", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def __init__(\n        self, callcontext: CallContext, argument_context_map=None, context=None\n    ):\n        if argument_context_map is None:\n            argument_context_map = {}\n        self.argument_context_map = argument_context_map\n        args = callcontext.args\n        keywords = callcontext.keywords\n        self.duplicated_keywords = set()\n        self._unpacked_args = self._unpack_args(args, context=context)\n        self._unpacked_kwargs = self._unpack_keywords(keywords, context=context)\n\n        self.positional_arguments = [\n            arg for arg in self._unpacked_args if arg is not Uninferable\n        ]\n        self.keyword_arguments = {\n            key: value\n            for key, value in self._unpacked_kwargs.items()\n            if value is not Uninferable\n        }\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "__init__", "self", "callcontext", "callcontext", "argument_context_map", "none", "context", "none", "if", "argument_context_map", "is", "none", "argument_context_map", "self", "argument_context_map", "argument_context_map", "args", "callcontext", "args", "keywords", "callcontext", "keywords", "self", "duplicated_keywords", "set", "self", "_unpacked_args", "self", "_unpack_args", "args", "context", "context", "self", "_unpacked_kwargs", "self", "_unpack_keywords", "keywords", "context", "context", "self", "positional_arguments", "arg", "for", "arg", "in", "self", "_unpacked_args", "if", "arg", "is", "not", "uninferable", "self", "keyword_arguments", "key", "value", "for", "key", "value", "in", "self", "_unpacked_kwargs", "items", "if", "value", "is", "not", "uninferable"], "doc_len": 73}
{"doc_id": "astroid/arguments.py::CallSite.from_call", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "from_call", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def from_call(cls, call_node, context: Optional[Context] = None):\n        \"\"\"Get a CallSite object from the given Call node.\n\n        context will be used to force a single inference path.\n        \"\"\"\n\n        # Determine the callcontext from the given `context` object if any.\n        context = context or InferenceContext()\n        callcontext = CallContext(call_node.args, call_node.keywords)\n        return cls(callcontext, context=context)\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "from_call", "cls", "call_node", "context", "optional", "context", "none", "get", "a", "callsite", "object", "from", "the", "given", "call", "node", "context", "will", "be", "used", "to", "force", "a", "single", "inference", "path", "determine", "the", "callcontext", "from", "the", "given", "context", "object", "if", "any", "context", "context", "or", "inferencecontext", "callcontext", "callcontext", "call_node", "args", "call_node", "keywords", "return", "cls", "callcontext", "context", "context"], "doc_len": 56}
{"doc_id": "astroid/arguments.py::CallSite.has_invalid_arguments", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "has_invalid_arguments", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def has_invalid_arguments(self):\n        \"\"\"Check if in the current CallSite were passed *invalid* arguments\n\n        This can mean multiple things. For instance, if an unpacking\n        of an invalid object was passed, then this method will return True.\n        Other cases can be when the arguments can't be inferred by astroid,\n        for example, by passing objects which aren't known statically.\n        \"\"\"\n        return len(self.positional_arguments) != len(self._unpacked_args)\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "has_invalid_arguments", "self", "check", "if", "in", "the", "current", "callsite", "were", "passed", "invalid", "arguments", "this", "can", "mean", "multiple", "things", "for", "instance", "if", "an", "unpacking", "of", "an", "invalid", "object", "was", "passed", "then", "this", "method", "will", "return", "true", "other", "cases", "can", "be", "when", "the", "arguments", "can", "t", "be", "inferred", "by", "astroid", "for", "example", "by", "passing", "objects", "which", "aren", "t", "known", "statically", "return", "len", "self", "positional_arguments", "len", "self", "_unpacked_args"], "doc_len": 69}
{"doc_id": "astroid/arguments.py::CallSite.has_invalid_keywords", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "has_invalid_keywords", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def has_invalid_keywords(self):\n        \"\"\"Check if in the current CallSite were passed *invalid* keyword arguments\n\n        For instance, unpacking a dictionary with integer keys is invalid\n        (**{1:2}), because the keys must be strings, which will make this\n        method to return True. Other cases where this might return True if\n        objects which can't be inferred were passed.\n        \"\"\"\n        return len(self.keyword_arguments) != len(self._unpacked_kwargs)\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "has_invalid_keywords", "self", "check", "if", "in", "the", "current", "callsite", "were", "passed", "invalid", "keyword", "arguments", "for", "instance", "unpacking", "a", "dictionary", "with", "integer", "keys", "is", "invalid", "1", "2", "because", "the", "keys", "must", "be", "strings", "which", "will", "make", "this", "method", "to", "return", "true", "other", "cases", "where", "this", "might", "return", "true", "if", "objects", "which", "can", "t", "be", "inferred", "were", "passed", "return", "len", "self", "keyword_arguments", "len", "self", "_unpacked_kwargs"], "doc_len": 67}
{"doc_id": "astroid/arguments.py::CallSite._unpack_keywords", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "_unpack_keywords", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def _unpack_keywords(self, keywords, context=None):\n        values = {}\n        context = context or InferenceContext()\n        context.extra_context = self.argument_context_map\n        for name, value in keywords:\n            if name is None:\n                # Then it's an unpacking operation (**)\n                try:\n                    inferred = next(value.infer(context=context))\n                except InferenceError:\n                    values[name] = Uninferable\n                    continue\n                except StopIteration:\n                    continue\n\n                if not isinstance(inferred, nodes.Dict):\n                    # Not something we can work with.\n                    values[name] = Uninferable\n                    continue\n\n                for dict_key, dict_value in inferred.items:\n                    try:\n                        dict_key = next(dict_key.infer(context=context))\n                    except InferenceError:\n                        values[name] = Uninferable\n                        continue\n                    except StopIteration:\n                        continue\n                    if not isinstance(dict_key, nodes.Const):\n                        values[name] = Uninferable\n                        continue\n                    if not isinstance(dict_key.value, str):\n                        values[name] = Uninferable\n                        continue\n                    if dict_key.value in values:\n                        # The name is already in the dictionary\n                        values[dict_key.value] = Uninferable\n                        self.duplicated_keywords.add(dict_key.value)\n                        continue\n                    values[dict_key.value] = dict_value\n            else:\n                values[name] = value\n        return values\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "_unpack_keywords", "self", "keywords", "context", "none", "values", "context", "context", "or", "inferencecontext", "context", "extra_context", "self", "argument_context_map", "for", "name", "value", "in", "keywords", "if", "name", "is", "none", "then", "it", "s", "an", "unpacking", "operation", "try", "inferred", "next", "value", "infer", "context", "context", "except", "inferenceerror", "values", "name", "uninferable", "continue", "except", "stopiteration", "continue", "if", "not", "isinstance", "inferred", "nodes", "dict", "not", "something", "we", "can", "work", "with", "values", "name", "uninferable", "continue", "for", "dict_key", "dict_value", "in", "inferred", "items", "try", "dict_key", "next", "dict_key", "infer", "context", "context", "except", "inferenceerror", "values", "name", "uninferable", "continue", "except", "stopiteration", "continue", "if", "not", "isinstance", "dict_key", "nodes", "const", "values", "name", "uninferable", "continue", "if", "not", "isinstance", "dict_key", "value", "str", "values", "name", "uninferable", "continue", "if", "dict_key", "value", "in", "values", "the", "name", "is", "already", "in", "the", "dictionary", "values", "dict_key", "value", "uninferable", "self", "duplicated_keywords", "add", "dict_key", "value", "continue", "values", "dict_key", "value", "dict_value", "else", "values", "name", "value", "return", "values"], "doc_len": 140}
{"doc_id": "astroid/arguments.py::CallSite._unpack_args", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "_unpack_args", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def _unpack_args(self, args, context=None):\n        values = []\n        context = context or InferenceContext()\n        context.extra_context = self.argument_context_map\n        for arg in args:\n            if isinstance(arg, nodes.Starred):\n                try:\n                    inferred = next(arg.value.infer(context=context))\n                except InferenceError:\n                    values.append(Uninferable)\n                    continue\n                except StopIteration:\n                    continue\n\n                if inferred is Uninferable:\n                    values.append(Uninferable)\n                    continue\n                if not hasattr(inferred, \"elts\"):\n                    values.append(Uninferable)\n                    continue\n                values.extend(inferred.elts)\n            else:\n                values.append(arg)\n        return values\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "_unpack_args", "self", "args", "context", "none", "values", "context", "context", "or", "inferencecontext", "context", "extra_context", "self", "argument_context_map", "for", "arg", "in", "args", "if", "isinstance", "arg", "nodes", "starred", "try", "inferred", "next", "arg", "value", "infer", "context", "context", "except", "inferenceerror", "values", "append", "uninferable", "continue", "except", "stopiteration", "continue", "if", "inferred", "is", "uninferable", "values", "append", "uninferable", "continue", "if", "not", "hasattr", "inferred", "elts", "values", "append", "uninferable", "continue", "values", "extend", "inferred", "elts", "else", "values", "append", "arg", "return", "values"], "doc_len": 72}
{"doc_id": "astroid/arguments.py::CallSite.infer_argument", "file_path": "astroid/arguments.py", "class_name": "CallSite", "func_name": "infer_argument", "text": "文件路径: astroid/arguments.py, 类名: CallSite\n    def infer_argument(self, funcnode, name, context):\n        \"\"\"infer a function argument value according to the call context\n\n        Arguments:\n            funcnode: The function being called.\n            name: The name of the argument whose value is being inferred.\n            context: Inference context object\n        \"\"\"\n        if name in self.duplicated_keywords:\n            raise InferenceError(\n                \"The arguments passed to {func!r} \" \" have duplicate keywords.\",\n                call_site=self,\n                func=funcnode,\n                arg=name,\n                context=context,\n            )\n\n        # Look into the keywords first, maybe it's already there.\n        try:\n            return self.keyword_arguments[name].infer(context)\n        except KeyError:\n            pass\n\n        # Too many arguments given and no variable arguments.\n        if len(self.positional_arguments) > len(funcnode.args.args):\n            if not funcnode.args.vararg and not funcnode.args.posonlyargs:\n                raise InferenceError(\n                    \"Too many positional arguments \"\n                    \"passed to {func!r} that does \"\n                    \"not have *args.\",\n                    call_site=self,\n                    func=funcnode,\n                    arg=name,\n                    context=context,\n                )\n\n        positional = self.positional_arguments[: len(funcnode.args.args)]\n        vararg = self.positional_arguments[len(funcnode.args.args) :]\n        argindex = funcnode.args.find_argname(name)[0]\n        kwonlyargs = {arg.name for arg in funcnode.args.kwonlyargs}\n        kwargs = {\n            key: value\n            for key, value in self.keyword_arguments.items()\n            if key not in kwonlyargs\n        }\n        # If there are too few positionals compared to\n        # what the function expects to receive, check to see\n        # if the missing positional arguments were passed\n        # as keyword arguments and if so, place them into the\n        # positional args list.\n        if len(positional) < len(funcnode.args.args):\n            for func_arg in funcnode.args.args:\n                if func_arg.name in kwargs:\n                    arg = kwargs.pop(func_arg.name)\n                    positional.append(arg)\n\n        if argindex is not None:\n            boundnode = getattr(context, \"boundnode\", None)\n            # 2. first argument of instance/class method\n            if argindex == 0 and funcnode.type in {\"method\", \"classmethod\"}:\n                # context.boundnode is None when an instance method is called with\n                # the class, e.g. MyClass.method(obj, ...). In this case, self\n                # is the first argument.\n                if boundnode is None and funcnode.type == \"method\" and positional:\n                    return positional[0].infer(context=context)\n                if boundnode is None:\n                    # XXX can do better ?\n                    boundnode = funcnode.parent.frame(future=True)\n\n                if isinstance(boundnode, nodes.ClassDef):\n                    # Verify that we're accessing a method\n                    # of the metaclass through a class, as in\n                    # `cls.metaclass_method`. In this case, the\n                    # first argument is always the class.\n                    method_scope = funcnode.parent.scope()\n                    if method_scope is boundnode.metaclass():\n                        return iter((boundnode,))\n\n                if funcnode.type == \"method\":\n                    if not isinstance(boundnode, Instance):\n                        boundnode = boundnode.instantiate_class()\n                    return iter((boundnode,))\n                if funcnode.type == \"classmethod\":\n                    return iter((boundnode,))\n            # if we have a method, extract one position\n            # from the index, so we'll take in account\n            # the extra parameter represented by `self` or `cls`\n            if funcnode.type in {\"method\", \"classmethod\"} and boundnode:\n                argindex -= 1\n            # 2. search arg index\n            try:\n                return self.positional_arguments[argindex].infer(context)\n            except IndexError:\n                pass\n\n        if funcnode.args.kwarg == name:\n            # It wants all the keywords that were passed into\n            # the call site.\n            if self.has_invalid_keywords():\n                raise InferenceError(\n                    \"Inference failed to find values for all keyword arguments \"\n                    \"to {func!r}: {unpacked_kwargs!r} doesn't correspond to \"\n                    \"{keyword_arguments!r}.\",\n                    keyword_arguments=self.keyword_arguments,\n                    unpacked_kwargs=self._unpacked_kwargs,\n                    call_site=self,\n                    func=funcnode,\n                    arg=name,\n                    context=context,\n                )\n            kwarg = nodes.Dict(\n                lineno=funcnode.args.lineno,\n                col_offset=funcnode.args.col_offset,\n                parent=funcnode.args,\n            )\n            kwarg.postinit(\n                [(nodes.const_factory(key), value) for key, value in kwargs.items()]\n            )\n            return iter((kwarg,))\n        if funcnode.args.vararg == name:\n            # It wants all the args that were passed into\n            # the call site.\n            if self.has_invalid_arguments():\n                raise InferenceError(\n                    \"Inference failed to find values for all positional \"\n                    \"arguments to {func!r}: {unpacked_args!r} doesn't \"\n                    \"correspond to {positional_arguments!r}.\",\n                    positional_arguments=self.positional_arguments,\n                    unpacked_args=self._unpacked_args,\n                    call_site=self,\n                    func=funcnode,\n                    arg=name,\n                    context=context,\n                )\n            args = nodes.Tuple(\n                lineno=funcnode.args.lineno,\n                col_offset=funcnode.args.col_offset,\n                parent=funcnode.args,\n            )\n            args.postinit(vararg)\n            return iter((args,))\n\n        # Check if it's a default parameter.\n        try:\n            return funcnode.args.default_value(name).infer(context)\n        except NoDefault:\n            pass\n        raise InferenceError(\n            \"No value found for argument {arg} to {func!r}\",\n            call_site=self,\n            func=funcnode,\n            arg=name,\n            context=context,\n        )\n", "tokens": ["astroid", "arguments", "py", "callsite", "def", "infer_argument", "self", "funcnode", "name", "context", "infer", "a", "function", "argument", "value", "according", "to", "the", "call", "context", "arguments", "funcnode", "the", "function", "being", "called", "name", "the", "name", "of", "the", "argument", "whose", "value", "is", "being", "inferred", "context", "inference", "context", "object", "if", "name", "in", "self", "duplicated_keywords", "raise", "inferenceerror", "the", "arguments", "passed", "to", "func", "r", "have", "duplicate", "keywords", "call_site", "self", "func", "funcnode", "arg", "name", "context", "context", "look", "into", "the", "keywords", "first", "maybe", "it", "s", "already", "there", "try", "return", "self", "keyword_arguments", "name", "infer", "context", "except", "keyerror", "pass", "too", "many", "arguments", "given", "and", "no", "variable", "arguments", "if", "len", "self", "positional_arguments", "len", "funcnode", "args", "args", "if", "not", "funcnode", "args", "vararg", "and", "not", "funcnode", "args", "posonlyargs", "raise", "inferenceerror", "too", "many", "positional", "arguments", "passed", "to", "func", "r", "that", "does", "not", "have", "args", "call_site", "self", "func", "funcnode", "arg", "name", "context", "context", "positional", "self", "positional_arguments", "len", "funcnode", "args", "args", "vararg", "self", "positional_arguments", "len", "funcnode", "args", "args", "argindex", "funcnode", "args", "find_argname", "name", "0", "kwonlyargs", "arg", "name", "for", "arg", "in", "funcnode", "args", "kwonlyargs", "kwargs", "key", "value", "for", "key", "value", "in", "self", "keyword_arguments", "items", "if", "key", "not", "in", "kwonlyargs", "if", "there", "are", "too", "few", "positionals", "compared", "to", "what", "the", "function", "expects", "to", "receive", "check", "to", "see", "if", "the", "missing", "positional", "arguments", "were", "passed", "as", "keyword", "arguments", "and", "if", "so", "place", "them", "into", "the", "positional", "args", "list", "if", "len", "positional", "len", "funcnode", "args", "args", "for", "func_arg", "in", "funcnode", "args", "args", "if", "func_arg", "name", "in", "kwargs", "arg", "kwargs", "pop", "func_arg", "name", "positional", "append", "arg", "if", "argindex", "is", "not", "none", "boundnode", "getattr", "context", "boundnode", "none", "2", "first", "argument", "of", "instance", "class", "method", "if", "argindex", "0", "and", "funcnode", "type", "in", "method", "classmethod", "context", "boundnode", "is", "none", "when", "an", "instance", "method", "is", "called", "with", "the", "class", "e", "g", "myclass", "method", "obj", "in", "this", "case", "self", "is", "the", "first", "argument", "if", "boundnode", "is", "none", "and", "funcnode", "type", "method", "and", "positional", "return", "positional", "0", "infer", "context", "context", "if", "boundnode", "is", "none", "xxx", "can", "do", "better", "boundnode", "funcnode", "parent", "frame", "future", "true", "if", "isinstance", "boundnode", "nodes", "classdef", "verify", "that", "we", "re", "accessing", "a", "method", "of", "the", "metaclass", "through", "a", "class", "as", "in", "cls", "metaclass_method", "in", "this", "case", "the", "first", "argument", "is", "always", "the", "class", "method_scope", "funcnode", "parent", "scope", "if", "method_scope", "is", "boundnode", "metaclass", "return", "iter", "boundnode", "if", "funcnode", "type", "method", "if", "not", "isinstance", "boundnode", "instance", "boundnode", "boundnode", "instantiate_class", "return", "iter", "boundnode", "if", "funcnode", "type", "classmethod", "return", "iter", "boundnode", "if", "we", "have", "a", "method", "extract", "one", "position", "from", "the", "index", "so", "we", "ll", "take", "in", "account", "the", "extra", "parameter", "represented", "by", "self", "or", "cls", "if", "funcnode", "type", "in", "method", "classmethod", "and", "boundnode", "argindex", "1", "2", "search", "arg", "index", "try", "return", "self", "positional_arguments", "argindex", "infer", "context", "except", "indexerror", "pass", "if", "funcnode", "args", "kwarg", "name", "it", "wants", "all", "the", "keywords", "that", "were", "passed", "into", "the", "call", "site", "if", "self", "has_invalid_keywords", "raise", "inferenceerror", "inference", "failed", "to", "find", "values", "for", "all", "keyword", "arguments", "to", "func", "r", "unpacked_kwargs", "r", "doesn", "t", "correspond", "to", "keyword_arguments", "r", "keyword_arguments", "self", "keyword_arguments", "unpacked_kwargs", "self", "_unpacked_kwargs", "call_site", "self", "func", "funcnode", "arg", "name", "context", "context", "kwarg", "nodes", "dict", "lineno", "funcnode", "args", "lineno", "col_offset", "funcnode", "args", "col_offset", "parent", "funcnode", "args", "kwarg", "postinit", "nodes", "const_factory", "key", "value", "for", "key", "value", "in", "kwargs", "items", "return", "iter", "kwarg", "if", "funcnode", "args", "vararg", "name", "it", "wants", "all", "the", "args", "that", "were", "passed", "into", "the", "call", "site", "if", "self", "has_invalid_arguments", "raise", "inferenceerror", "inference", "failed", "to", "find", "values", "for", "all", "positional", "arguments", "to", "func", "r", "unpacked_args", "r", "doesn", "t", "correspond", "to", "positional_arguments", "r", "positional_arguments", "self", "positional_arguments", "unpacked_args", "self", "_unpacked_args", "call_site", "self", "func", "funcnode", "arg", "name", "context", "context", "args", "nodes", "tuple", "lineno", "funcnode", "args", "lineno", "col_offset", "funcnode", "args", "col_offset", "parent", "funcnode", "args", "args", "postinit", "vararg", "return", "iter", "args", "check", "if", "it", "s", "a", "default", "parameter", "try", "return", "funcnode", "args", "default_value", "name", "infer", "context", "except", "nodefault", "pass", "raise", "inferenceerror", "no", "value", "found", "for", "argument", "arg", "to", "func", "r", "call_site", "self", "func", "funcnode", "arg", "name", "context", "context"], "doc_len": 636}
{"doc_id": "astroid/bases.py::_is_property", "file_path": "astroid/bases.py", "class_name": null, "func_name": "_is_property", "text": "文件路径: astroid/bases.py\ndef _is_property(meth, context=None):\n    decoratornames = meth.decoratornames(context=context)\n    if PROPERTIES.intersection(decoratornames):\n        return True\n    stripped = {\n        name.split(\".\")[-1] for name in decoratornames if name is not Uninferable\n    }\n    if any(name in stripped for name in POSSIBLE_PROPERTIES):\n        return True\n\n    # Lookup for subclasses of *property*\n    if not meth.decorators:\n        return False\n    for decorator in meth.decorators.nodes or ():\n        inferred = helpers.safe_infer(decorator, context=context)\n        if inferred is None or inferred is Uninferable:\n            continue\n        if inferred.__class__.__name__ == \"ClassDef\":\n            for base_class in inferred.bases:\n                if base_class.__class__.__name__ != \"Name\":\n                    continue\n                module, _ = base_class.lookup(base_class.name)\n                if module.name == \"builtins\" and base_class.name == \"property\":\n                    return True\n\n    return False\n", "tokens": ["astroid", "bases", "py", "def", "_is_property", "meth", "context", "none", "decoratornames", "meth", "decoratornames", "context", "context", "if", "properties", "intersection", "decoratornames", "return", "true", "stripped", "name", "split", "1", "for", "name", "in", "decoratornames", "if", "name", "is", "not", "uninferable", "if", "any", "name", "in", "stripped", "for", "name", "in", "possible_properties", "return", "true", "lookup", "for", "subclasses", "of", "property", "if", "not", "meth", "decorators", "return", "false", "for", "decorator", "in", "meth", "decorators", "nodes", "or", "inferred", "helpers", "safe_infer", "decorator", "context", "context", "if", "inferred", "is", "none", "or", "inferred", "is", "uninferable", "continue", "if", "inferred", "__class__", "__name__", "classdef", "for", "base_class", "in", "inferred", "bases", "if", "base_class", "__class__", "__name__", "name", "continue", "module", "_", "base_class", "lookup", "base_class", "name", "if", "module", "name", "builtins", "and", "base_class", "name", "property", "return", "true", "return", "false"], "doc_len": 110}
{"doc_id": "astroid/bases.py::Proxy.__init__", "file_path": "astroid/bases.py", "class_name": "Proxy", "func_name": "__init__", "text": "文件路径: astroid/bases.py, 类名: Proxy\n    def __init__(self, proxied=None):\n        if proxied is not None:\n            self._proxied = proxied\n", "tokens": ["astroid", "bases", "py", "proxy", "def", "__init__", "self", "proxied", "none", "if", "proxied", "is", "not", "none", "self", "_proxied", "proxied"], "doc_len": 17}
{"doc_id": "astroid/bases.py::Proxy.__getattr__", "file_path": "astroid/bases.py", "class_name": "Proxy", "func_name": "__getattr__", "text": "文件路径: astroid/bases.py, 类名: Proxy\n    def __getattr__(self, name):\n        if name == \"_proxied\":\n            return self.__class__._proxied\n        if name in self.__dict__:\n            return self.__dict__[name]\n        return getattr(self._proxied, name)\n", "tokens": ["astroid", "bases", "py", "proxy", "def", "__getattr__", "self", "name", "if", "name", "_proxied", "return", "self", "__class__", "_proxied", "if", "name", "in", "self", "__dict__", "return", "self", "__dict__", "name", "return", "getattr", "self", "_proxied", "name"], "doc_len": 29}
{"doc_id": "astroid/bases.py::Proxy.infer", "file_path": "astroid/bases.py", "class_name": "Proxy", "func_name": "infer", "text": "文件路径: astroid/bases.py, 类名: Proxy\n    def infer(self, context=None):\n        yield self\n", "tokens": ["astroid", "bases", "py", "proxy", "def", "infer", "self", "context", "none", "yield", "self"], "doc_len": 11}
{"doc_id": "astroid/bases.py::_infer_stmts", "file_path": "astroid/bases.py", "class_name": null, "func_name": "_infer_stmts", "text": "文件路径: astroid/bases.py\ndef _infer_stmts(stmts, context, frame=None):\n    \"\"\"Return an iterator on statements inferred by each statement in *stmts*.\"\"\"\n    inferred = False\n    if context is not None:\n        name = context.lookupname\n        context = context.clone()\n    else:\n        name = None\n        context = InferenceContext()\n\n    for stmt in stmts:\n        if stmt is Uninferable:\n            yield stmt\n            inferred = True\n            continue\n        context.lookupname = stmt._infer_name(frame, name)\n        try:\n            for inf in stmt.infer(context=context):\n                yield inf\n                inferred = True\n        except NameInferenceError:\n            continue\n        except InferenceError:\n            yield Uninferable\n            inferred = True\n    if not inferred:\n        raise InferenceError(\n            \"Inference failed for all members of {stmts!r}.\",\n            stmts=stmts,\n            frame=frame,\n            context=context,\n        )\n", "tokens": ["astroid", "bases", "py", "def", "_infer_stmts", "stmts", "context", "frame", "none", "return", "an", "iterator", "on", "statements", "inferred", "by", "each", "statement", "in", "stmts", "inferred", "false", "if", "context", "is", "not", "none", "name", "context", "lookupname", "context", "context", "clone", "else", "name", "none", "context", "inferencecontext", "for", "stmt", "in", "stmts", "if", "stmt", "is", "uninferable", "yield", "stmt", "inferred", "true", "continue", "context", "lookupname", "stmt", "_infer_name", "frame", "name", "try", "for", "inf", "in", "stmt", "infer", "context", "context", "yield", "inf", "inferred", "true", "except", "nameinferenceerror", "continue", "except", "inferenceerror", "yield", "uninferable", "inferred", "true", "if", "not", "inferred", "raise", "inferenceerror", "inference", "failed", "for", "all", "members", "of", "stmts", "r", "stmts", "stmts", "frame", "frame", "context", "context"], "doc_len": 97}
{"doc_id": "astroid/bases.py::_infer_method_result_truth", "file_path": "astroid/bases.py", "class_name": null, "func_name": "_infer_method_result_truth", "text": "文件路径: astroid/bases.py\ndef _infer_method_result_truth(instance, method_name, context):\n    # Get the method from the instance and try to infer\n    # its return's truth value.\n    meth = next(instance.igetattr(method_name, context=context), None)\n    if meth and hasattr(meth, \"infer_call_result\"):\n        if not meth.callable():\n            return Uninferable\n        try:\n            context.callcontext = CallContext(args=[], callee=meth)\n            for value in meth.infer_call_result(instance, context=context):\n                if value is Uninferable:\n                    return value\n                try:\n                    inferred = next(value.infer(context=context))\n                except StopIteration as e:\n                    raise InferenceError(context=context) from e\n                return inferred.bool_value()\n        except InferenceError:\n            pass\n    return Uninferable\n", "tokens": ["astroid", "bases", "py", "def", "_infer_method_result_truth", "instance", "method_name", "context", "get", "the", "method", "from", "the", "instance", "and", "try", "to", "infer", "its", "return", "s", "truth", "value", "meth", "next", "instance", "igetattr", "method_name", "context", "context", "none", "if", "meth", "and", "hasattr", "meth", "infer_call_result", "if", "not", "meth", "callable", "return", "uninferable", "try", "context", "callcontext", "callcontext", "args", "callee", "meth", "for", "value", "in", "meth", "infer_call_result", "instance", "context", "context", "if", "value", "is", "uninferable", "return", "value", "try", "inferred", "next", "value", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "return", "inferred", "bool_value", "except", "inferenceerror", "pass", "return", "uninferable"], "doc_len": 89}
{"doc_id": "astroid/bases.py::BaseInstance.display_type", "file_path": "astroid/bases.py", "class_name": "BaseInstance", "func_name": "display_type", "text": "文件路径: astroid/bases.py, 类名: BaseInstance\n    def display_type(self):\n        return \"Instance of\"\n", "tokens": ["astroid", "bases", "py", "baseinstance", "def", "display_type", "self", "return", "instance", "of"], "doc_len": 10}
{"doc_id": "astroid/bases.py::BaseInstance.getattr", "file_path": "astroid/bases.py", "class_name": "BaseInstance", "func_name": "getattr", "text": "文件路径: astroid/bases.py, 类名: BaseInstance\n    def getattr(self, name, context=None, lookupclass=True):\n        try:\n            values = self._proxied.instance_attr(name, context)\n        except AttributeInferenceError as exc:\n            if self.special_attributes and name in self.special_attributes:\n                return [self.special_attributes.lookup(name)]\n\n            if lookupclass:\n                # Class attributes not available through the instance\n                # unless they are explicitly defined.\n                return self._proxied.getattr(name, context, class_context=False)\n\n            raise AttributeInferenceError(\n                target=self, attribute=name, context=context\n            ) from exc\n        # since we've no context information, return matching class members as\n        # well\n        if lookupclass:\n            try:\n                return values + self._proxied.getattr(\n                    name, context, class_context=False\n                )\n            except AttributeInferenceError:\n                pass\n        return values\n", "tokens": ["astroid", "bases", "py", "baseinstance", "def", "getattr", "self", "name", "context", "none", "lookupclass", "true", "try", "values", "self", "_proxied", "instance_attr", "name", "context", "except", "attributeinferenceerror", "as", "exc", "if", "self", "special_attributes", "and", "name", "in", "self", "special_attributes", "return", "self", "special_attributes", "lookup", "name", "if", "lookupclass", "class", "attributes", "not", "available", "through", "the", "instance", "unless", "they", "are", "explicitly", "defined", "return", "self", "_proxied", "getattr", "name", "context", "class_context", "false", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "from", "exc", "since", "we", "ve", "no", "context", "information", "return", "matching", "class", "members", "as", "well", "if", "lookupclass", "try", "return", "values", "self", "_proxied", "getattr", "name", "context", "class_context", "false", "except", "attributeinferenceerror", "pass", "return", "values"], "doc_len": 97}
{"doc_id": "astroid/bases.py::BaseInstance.igetattr", "file_path": "astroid/bases.py", "class_name": "BaseInstance", "func_name": "igetattr", "text": "文件路径: astroid/bases.py, 类名: BaseInstance\n    def igetattr(self, name, context=None):\n        \"\"\"inferred getattr\"\"\"\n        if not context:\n            context = InferenceContext()\n        try:\n            context.lookupname = name\n            # avoid recursively inferring the same attr on the same class\n            if context.push(self._proxied):\n                raise InferenceError(\n                    message=\"Cannot infer the same attribute again\",\n                    node=self,\n                    context=context,\n                )\n\n            # XXX frame should be self._proxied, or not ?\n            get_attr = self.getattr(name, context, lookupclass=False)\n            yield from _infer_stmts(\n                self._wrap_attr(get_attr, context), context, frame=self\n            )\n        except AttributeInferenceError:\n            try:\n                # fallback to class.igetattr since it has some logic to handle\n                # descriptors\n                # But only if the _proxied is the Class.\n                if self._proxied.__class__.__name__ != \"ClassDef\":\n                    raise\n                attrs = self._proxied.igetattr(name, context, class_context=False)\n                yield from self._wrap_attr(attrs, context)\n            except AttributeInferenceError as error:\n                raise InferenceError(**vars(error)) from error\n", "tokens": ["astroid", "bases", "py", "baseinstance", "def", "igetattr", "self", "name", "context", "none", "inferred", "getattr", "if", "not", "context", "context", "inferencecontext", "try", "context", "lookupname", "name", "avoid", "recursively", "inferring", "the", "same", "attr", "on", "the", "same", "class", "if", "context", "push", "self", "_proxied", "raise", "inferenceerror", "message", "cannot", "infer", "the", "same", "attribute", "again", "node", "self", "context", "context", "xxx", "frame", "should", "be", "self", "_proxied", "or", "not", "get_attr", "self", "getattr", "name", "context", "lookupclass", "false", "yield", "from", "_infer_stmts", "self", "_wrap_attr", "get_attr", "context", "context", "frame", "self", "except", "attributeinferenceerror", "try", "fallback", "to", "class", "igetattr", "since", "it", "has", "some", "logic", "to", "handle", "descriptors", "but", "only", "if", "the", "_proxied", "is", "the", "class", "if", "self", "_proxied", "__class__", "__name__", "classdef", "raise", "attrs", "self", "_proxied", "igetattr", "name", "context", "class_context", "false", "yield", "from", "self", "_wrap_attr", "attrs", "context", "except", "attributeinferenceerror", "as", "error", "raise", "inferenceerror", "vars", "error", "from", "error"], "doc_len": 128}
{"doc_id": "astroid/bases.py::BaseInstance._wrap_attr", "file_path": "astroid/bases.py", "class_name": "BaseInstance", "func_name": "_wrap_attr", "text": "文件路径: astroid/bases.py, 类名: BaseInstance\n    def _wrap_attr(self, attrs, context=None):\n        \"\"\"wrap bound methods of attrs in a InstanceMethod proxies\"\"\"\n        for attr in attrs:\n            if isinstance(attr, UnboundMethod):\n                if _is_property(attr):\n                    yield from attr.infer_call_result(self, context)\n                else:\n                    yield BoundMethod(attr, self)\n            elif hasattr(attr, \"name\") and attr.name == \"<lambda>\":\n                if attr.args.arguments and attr.args.arguments[0].name == \"self\":\n                    yield BoundMethod(attr, self)\n                    continue\n                yield attr\n            else:\n                yield attr\n", "tokens": ["astroid", "bases", "py", "baseinstance", "def", "_wrap_attr", "self", "attrs", "context", "none", "wrap", "bound", "methods", "of", "attrs", "in", "a", "instancemethod", "proxies", "for", "attr", "in", "attrs", "if", "isinstance", "attr", "unboundmethod", "if", "_is_property", "attr", "yield", "from", "attr", "infer_call_result", "self", "context", "else", "yield", "boundmethod", "attr", "self", "elif", "hasattr", "attr", "name", "and", "attr", "name", "lambda", "if", "attr", "args", "arguments", "and", "attr", "args", "arguments", "0", "name", "self", "yield", "boundmethod", "attr", "self", "continue", "yield", "attr", "else", "yield", "attr"], "doc_len": 70}
{"doc_id": "astroid/bases.py::BaseInstance.infer_call_result", "file_path": "astroid/bases.py", "class_name": "BaseInstance", "func_name": "infer_call_result", "text": "文件路径: astroid/bases.py, 类名: BaseInstance\n    def infer_call_result(self, caller, context=None):\n        \"\"\"infer what a class instance is returning when called\"\"\"\n        context = bind_context_to_node(context, self)\n        inferred = False\n        for node in self._proxied.igetattr(\"__call__\", context):\n            if node is Uninferable or not node.callable():\n                continue\n            for res in node.infer_call_result(caller, context):\n                inferred = True\n                yield res\n        if not inferred:\n            raise InferenceError(node=self, caller=caller, context=context)\n", "tokens": ["astroid", "bases", "py", "baseinstance", "def", "infer_call_result", "self", "caller", "context", "none", "infer", "what", "a", "class", "instance", "is", "returning", "when", "called", "context", "bind_context_to_node", "context", "self", "inferred", "false", "for", "node", "in", "self", "_proxied", "igetattr", "__call__", "context", "if", "node", "is", "uninferable", "or", "not", "node", "callable", "continue", "for", "res", "in", "node", "infer_call_result", "caller", "context", "inferred", "true", "yield", "res", "if", "not", "inferred", "raise", "inferenceerror", "node", "self", "caller", "caller", "context", "context"], "doc_len": 64}
{"doc_id": "astroid/bases.py::Instance.__repr__", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "__repr__", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def __repr__(self):\n        return \"<Instance of {}.{} at 0x{}>\".format(\n            self._proxied.root().name, self._proxied.name, id(self)\n        )\n", "tokens": ["astroid", "bases", "py", "instance", "def", "__repr__", "self", "return", "instance", "of", "at", "0x", "format", "self", "_proxied", "root", "name", "self", "_proxied", "name", "id", "self"], "doc_len": 22}
{"doc_id": "astroid/bases.py::Instance.__str__", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "__str__", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def __str__(self):\n        return f\"Instance of {self._proxied.root().name}.{self._proxied.name}\"\n", "tokens": ["astroid", "bases", "py", "instance", "def", "__str__", "self", "return", "f", "instance", "of", "self", "_proxied", "root", "name", "self", "_proxied", "name"], "doc_len": 18}
{"doc_id": "astroid/bases.py::Instance.callable", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "callable", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def callable(self):\n        try:\n            self._proxied.getattr(\"__call__\", class_context=False)\n            return True\n        except AttributeInferenceError:\n            return False\n", "tokens": ["astroid", "bases", "py", "instance", "def", "callable", "self", "try", "self", "_proxied", "getattr", "__call__", "class_context", "false", "return", "true", "except", "attributeinferenceerror", "return", "false"], "doc_len": 20}
{"doc_id": "astroid/bases.py::Instance.pytype", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "pytype", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def pytype(self):\n        return self._proxied.qname()\n", "tokens": ["astroid", "bases", "py", "instance", "def", "pytype", "self", "return", "self", "_proxied", "qname"], "doc_len": 11}
{"doc_id": "astroid/bases.py::Instance.display_type", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "display_type", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def display_type(self):\n        return \"Instance of\"\n", "tokens": ["astroid", "bases", "py", "instance", "def", "display_type", "self", "return", "instance", "of"], "doc_len": 10}
{"doc_id": "astroid/bases.py::Instance.bool_value", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "bool_value", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def bool_value(self, context=None):\n        \"\"\"Infer the truth value for an Instance\n\n        The truth value of an instance is determined by these conditions:\n\n           * if it implements __bool__ on Python 3 or __nonzero__\n             on Python 2, then its bool value will be determined by\n             calling this special method and checking its result.\n           * when this method is not defined, __len__() is called, if it\n             is defined, and the object is considered true if its result is\n             nonzero. If a class defines neither __len__() nor __bool__(),\n             all its instances are considered true.\n        \"\"\"\n        context = context or InferenceContext()\n        context.boundnode = self\n\n        try:\n            result = _infer_method_result_truth(self, BOOL_SPECIAL_METHOD, context)\n        except (InferenceError, AttributeInferenceError):\n            # Fallback to __len__.\n            try:\n                result = _infer_method_result_truth(self, \"__len__\", context)\n            except (AttributeInferenceError, InferenceError):\n                return True\n        return result\n", "tokens": ["astroid", "bases", "py", "instance", "def", "bool_value", "self", "context", "none", "infer", "the", "truth", "value", "for", "an", "instance", "the", "truth", "value", "of", "an", "instance", "is", "determined", "by", "these", "conditions", "if", "it", "implements", "__bool__", "on", "python", "3", "or", "__nonzero__", "on", "python", "2", "then", "its", "bool", "value", "will", "be", "determined", "by", "calling", "this", "special", "method", "and", "checking", "its", "result", "when", "this", "method", "is", "not", "defined", "__len__", "is", "called", "if", "it", "is", "defined", "and", "the", "object", "is", "considered", "true", "if", "its", "result", "is", "nonzero", "if", "a", "class", "defines", "neither", "__len__", "nor", "__bool__", "all", "its", "instances", "are", "considered", "true", "context", "context", "or", "inferencecontext", "context", "boundnode", "self", "try", "result", "_infer_method_result_truth", "self", "bool_special_method", "context", "except", "inferenceerror", "attributeinferenceerror", "fallback", "to", "__len__", "try", "result", "_infer_method_result_truth", "self", "__len__", "context", "except", "attributeinferenceerror", "inferenceerror", "return", "true", "return", "result"], "doc_len": 125}
{"doc_id": "astroid/bases.py::Instance.getitem", "file_path": "astroid/bases.py", "class_name": "Instance", "func_name": "getitem", "text": "文件路径: astroid/bases.py, 类名: Instance\n    def getitem(self, index, context=None):\n        # TODO: Rewrap index to Const for this case\n        new_context = bind_context_to_node(context, self)\n        if not context:\n            context = new_context\n        method = next(self.igetattr(\"__getitem__\", context=context), None)\n        # Create a new CallContext for providing index as an argument.\n        new_context.callcontext = CallContext(args=[index], callee=method)\n        if not isinstance(method, BoundMethod):\n            raise InferenceError(\n                \"Could not find __getitem__ for {node!r}.\", node=self, context=context\n            )\n        if len(method.args.arguments) != 2:  # (self, index)\n            raise AstroidTypeError(\n                \"__getitem__ for {node!r} does not have correct signature\",\n                node=self,\n                context=context,\n            )\n        return next(method.infer_call_result(self, new_context), None)\n", "tokens": ["astroid", "bases", "py", "instance", "def", "getitem", "self", "index", "context", "none", "todo", "rewrap", "index", "to", "const", "for", "this", "case", "new_context", "bind_context_to_node", "context", "self", "if", "not", "context", "context", "new_context", "method", "next", "self", "igetattr", "__getitem__", "context", "context", "none", "create", "a", "new", "callcontext", "for", "providing", "index", "as", "an", "argument", "new_context", "callcontext", "callcontext", "args", "index", "callee", "method", "if", "not", "isinstance", "method", "boundmethod", "raise", "inferenceerror", "could", "not", "find", "__getitem__", "for", "node", "r", "node", "self", "context", "context", "if", "len", "method", "args", "arguments", "2", "self", "index", "raise", "astroidtypeerror", "__getitem__", "for", "node", "r", "does", "not", "have", "correct", "signature", "node", "self", "context", "context", "return", "next", "method", "infer_call_result", "self", "new_context", "none"], "doc_len": 100}
{"doc_id": "astroid/bases.py::UnboundMethod.__repr__", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "__repr__", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def __repr__(self):\n        frame = self._proxied.parent.frame(future=True)\n        return \"<{} {} of {} at 0x{}\".format(\n            self.__class__.__name__, self._proxied.name, frame.qname(), id(self)\n        )\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "__repr__", "self", "frame", "self", "_proxied", "parent", "frame", "future", "true", "return", "of", "at", "0x", "format", "self", "__class__", "__name__", "self", "_proxied", "name", "frame", "qname", "id", "self"], "doc_len": 29}
{"doc_id": "astroid/bases.py::UnboundMethod.implicit_parameters", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "implicit_parameters", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def implicit_parameters(self):\n        return 0\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "implicit_parameters", "self", "return", "0"], "doc_len": 9}
{"doc_id": "astroid/bases.py::UnboundMethod.is_bound", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "is_bound", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def is_bound(self):\n        return False\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "is_bound", "self", "return", "false"], "doc_len": 9}
{"doc_id": "astroid/bases.py::UnboundMethod.getattr", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "getattr", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def getattr(self, name, context=None):\n        if name in self.special_attributes:\n            return [self.special_attributes.lookup(name)]\n        return self._proxied.getattr(name, context)\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "getattr", "self", "name", "context", "none", "if", "name", "in", "self", "special_attributes", "return", "self", "special_attributes", "lookup", "name", "return", "self", "_proxied", "getattr", "name", "context"], "doc_len": 26}
{"doc_id": "astroid/bases.py::UnboundMethod.igetattr", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "igetattr", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def igetattr(self, name, context=None):\n        if name in self.special_attributes:\n            return iter((self.special_attributes.lookup(name),))\n        return self._proxied.igetattr(name, context)\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "igetattr", "self", "name", "context", "none", "if", "name", "in", "self", "special_attributes", "return", "iter", "self", "special_attributes", "lookup", "name", "return", "self", "_proxied", "igetattr", "name", "context"], "doc_len": 27}
{"doc_id": "astroid/bases.py::UnboundMethod.infer_call_result", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "infer_call_result", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def infer_call_result(self, caller, context):\n        \"\"\"\n        The boundnode of the regular context with a function called\n        on ``object.__new__`` will be of type ``object``,\n        which is incorrect for the argument in general.\n        If no context is given the ``object.__new__`` call argument will\n        correctly inferred except when inside a call that requires\n        the additional context (such as a classmethod) of the boundnode\n        to determine which class the method was called from\n        \"\"\"\n\n        # If we're unbound method __new__ of builtin object, the result is an\n        # instance of the class given as first argument.\n        if (\n            self._proxied.name == \"__new__\"\n            and self._proxied.parent.frame(future=True).qname() == \"builtins.object\"\n        ):\n            if caller.args:\n                node_context = context.extra_context.get(caller.args[0])\n                infer = caller.args[0].infer(context=node_context)\n            else:\n                infer = []\n            return (Instance(x) if x is not Uninferable else x for x in infer)\n        return self._proxied.infer_call_result(caller, context)\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "infer_call_result", "self", "caller", "context", "the", "boundnode", "of", "the", "regular", "context", "with", "a", "function", "called", "on", "object", "__new__", "will", "be", "of", "type", "object", "which", "is", "incorrect", "for", "the", "argument", "in", "general", "if", "no", "context", "is", "given", "the", "object", "__new__", "call", "argument", "will", "correctly", "inferred", "except", "when", "inside", "a", "call", "that", "requires", "the", "additional", "context", "such", "as", "a", "classmethod", "of", "the", "boundnode", "to", "determine", "which", "class", "the", "method", "was", "called", "from", "if", "we", "re", "unbound", "method", "__new__", "of", "builtin", "object", "the", "result", "is", "an", "instance", "of", "the", "class", "given", "as", "first", "argument", "if", "self", "_proxied", "name", "__new__", "and", "self", "_proxied", "parent", "frame", "future", "true", "qname", "builtins", "object", "if", "caller", "args", "node_context", "context", "extra_context", "get", "caller", "args", "0", "infer", "caller", "args", "0", "infer", "context", "node_context", "else", "infer", "return", "instance", "x", "if", "x", "is", "not", "uninferable", "else", "x", "for", "x", "in", "infer", "return", "self", "_proxied", "infer_call_result", "caller", "context"], "doc_len": 149}
{"doc_id": "astroid/bases.py::UnboundMethod.bool_value", "file_path": "astroid/bases.py", "class_name": "UnboundMethod", "func_name": "bool_value", "text": "文件路径: astroid/bases.py, 类名: UnboundMethod\n    def bool_value(self, context=None):\n        return True\n", "tokens": ["astroid", "bases", "py", "unboundmethod", "def", "bool_value", "self", "context", "none", "return", "true"], "doc_len": 11}
{"doc_id": "astroid/bases.py::BoundMethod.__init__", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "__init__", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def __init__(self, proxy, bound):\n        super().__init__(proxy)\n        self.bound = bound\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "__init__", "self", "proxy", "bound", "super", "__init__", "proxy", "self", "bound", "bound"], "doc_len": 15}
{"doc_id": "astroid/bases.py::BoundMethod.implicit_parameters", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "implicit_parameters", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def implicit_parameters(self):\n        if self.name == \"__new__\":\n            # __new__ acts as a classmethod but the class argument is not implicit.\n            return 0\n        return 1\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "implicit_parameters", "self", "if", "self", "name", "__new__", "__new__", "acts", "as", "a", "classmethod", "but", "the", "class", "argument", "is", "not", "implicit", "return", "0", "return", "1"], "doc_len": 27}
{"doc_id": "astroid/bases.py::BoundMethod.is_bound", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "is_bound", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def is_bound(self):\n        return True\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "is_bound", "self", "return", "true"], "doc_len": 9}
{"doc_id": "astroid/bases.py::BoundMethod._infer_type_new_call", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "_infer_type_new_call", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def _infer_type_new_call(self, caller, context):\n        \"\"\"Try to infer what type.__new__(mcs, name, bases, attrs) returns.\n\n        In order for such call to be valid, the metaclass needs to be\n        a subtype of ``type``, the name needs to be a string, the bases\n        needs to be a tuple of classes\n        \"\"\"\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.nodes import Pass\n\n        # Verify the metaclass\n        try:\n            mcs = next(caller.args[0].infer(context=context))\n        except StopIteration as e:\n            raise InferenceError(context=context) from e\n        if mcs.__class__.__name__ != \"ClassDef\":\n            # Not a valid first argument.\n            return None\n        if not mcs.is_subtype_of(\"builtins.type\"):\n            # Not a valid metaclass.\n            return None\n\n        # Verify the name\n        try:\n            name = next(caller.args[1].infer(context=context))\n        except StopIteration as e:\n            raise InferenceError(context=context) from e\n        if name.__class__.__name__ != \"Const\":\n            # Not a valid name, needs to be a const.\n            return None\n        if not isinstance(name.value, str):\n            # Needs to be a string.\n            return None\n\n        # Verify the bases\n        try:\n            bases = next(caller.args[2].infer(context=context))\n        except StopIteration as e:\n            raise InferenceError(context=context) from e\n        if bases.__class__.__name__ != \"Tuple\":\n            # Needs to be a tuple.\n            return None\n        try:\n            inferred_bases = [next(elt.infer(context=context)) for elt in bases.elts]\n        except StopIteration as e:\n            raise InferenceError(context=context) from e\n        if any(base.__class__.__name__ != \"ClassDef\" for base in inferred_bases):\n            # All the bases needs to be Classes\n            return None\n\n        # Verify the attributes.\n        try:\n            attrs = next(caller.args[3].infer(context=context))\n        except StopIteration as e:\n            raise InferenceError(context=context) from e\n        if attrs.__class__.__name__ != \"Dict\":\n            # Needs to be a dictionary.\n            return None\n        cls_locals = collections.defaultdict(list)\n        for key, value in attrs.items:\n            try:\n                key = next(key.infer(context=context))\n            except StopIteration as e:\n                raise InferenceError(context=context) from e\n            try:\n                value = next(value.infer(context=context))\n            except StopIteration as e:\n                raise InferenceError(context=context) from e\n            # Ignore non string keys\n            if key.__class__.__name__ == \"Const\" and isinstance(key.value, str):\n                cls_locals[key.value].append(value)\n\n        # Build the class from now.\n        cls = mcs.__class__(\n            name=name.value,\n            lineno=caller.lineno,\n            col_offset=caller.col_offset,\n            parent=caller,\n        )\n        empty = Pass()\n        cls.postinit(\n            bases=bases.elts,\n            body=[empty],\n            decorators=[],\n            newstyle=True,\n            metaclass=mcs,\n            keywords=[],\n        )\n        cls.locals = cls_locals\n        return cls\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "_infer_type_new_call", "self", "caller", "context", "try", "to", "infer", "what", "type", "__new__", "mcs", "name", "bases", "attrs", "returns", "in", "order", "for", "such", "call", "to", "be", "valid", "the", "metaclass", "needs", "to", "be", "a", "subtype", "of", "type", "the", "name", "needs", "to", "be", "a", "string", "the", "bases", "needs", "to", "be", "a", "tuple", "of", "classes", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "nodes", "import", "pass", "verify", "the", "metaclass", "try", "mcs", "next", "caller", "args", "0", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "if", "mcs", "__class__", "__name__", "classdef", "not", "a", "valid", "first", "argument", "return", "none", "if", "not", "mcs", "is_subtype_of", "builtins", "type", "not", "a", "valid", "metaclass", "return", "none", "verify", "the", "name", "try", "name", "next", "caller", "args", "1", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "if", "name", "__class__", "__name__", "const", "not", "a", "valid", "name", "needs", "to", "be", "a", "const", "return", "none", "if", "not", "isinstance", "name", "value", "str", "needs", "to", "be", "a", "string", "return", "none", "verify", "the", "bases", "try", "bases", "next", "caller", "args", "2", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "if", "bases", "__class__", "__name__", "tuple", "needs", "to", "be", "a", "tuple", "return", "none", "try", "inferred_bases", "next", "elt", "infer", "context", "context", "for", "elt", "in", "bases", "elts", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "if", "any", "base", "__class__", "__name__", "classdef", "for", "base", "in", "inferred_bases", "all", "the", "bases", "needs", "to", "be", "classes", "return", "none", "verify", "the", "attributes", "try", "attrs", "next", "caller", "args", "3", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "if", "attrs", "__class__", "__name__", "dict", "needs", "to", "be", "a", "dictionary", "return", "none", "cls_locals", "collections", "defaultdict", "list", "for", "key", "value", "in", "attrs", "items", "try", "key", "next", "key", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "try", "value", "next", "value", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "from", "e", "ignore", "non", "string", "keys", "if", "key", "__class__", "__name__", "const", "and", "isinstance", "key", "value", "str", "cls_locals", "key", "value", "append", "value", "build", "the", "class", "from", "now", "cls", "mcs", "__class__", "name", "name", "value", "lineno", "caller", "lineno", "col_offset", "caller", "col_offset", "parent", "caller", "empty", "pass", "cls", "postinit", "bases", "bases", "elts", "body", "empty", "decorators", "newstyle", "true", "metaclass", "mcs", "keywords", "cls", "locals", "cls_locals", "return", "cls"], "doc_len": 373}
{"doc_id": "astroid/bases.py::BoundMethod.infer_call_result", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "infer_call_result", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def infer_call_result(self, caller, context=None):\n        context = bind_context_to_node(context, self.bound)\n        if (\n            self.bound.__class__.__name__ == \"ClassDef\"\n            and self.bound.name == \"type\"\n            and self.name == \"__new__\"\n            and len(caller.args) == 4\n        ):\n            # Check if we have a ``type.__new__(mcs, name, bases, attrs)`` call.\n            new_cls = self._infer_type_new_call(caller, context)\n            if new_cls:\n                return iter((new_cls,))\n\n        return super().infer_call_result(caller, context)\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "infer_call_result", "self", "caller", "context", "none", "context", "bind_context_to_node", "context", "self", "bound", "if", "self", "bound", "__class__", "__name__", "classdef", "and", "self", "bound", "name", "type", "and", "self", "name", "__new__", "and", "len", "caller", "args", "4", "check", "if", "we", "have", "a", "type", "__new__", "mcs", "name", "bases", "attrs", "call", "new_cls", "self", "_infer_type_new_call", "caller", "context", "if", "new_cls", "return", "iter", "new_cls", "return", "super", "infer_call_result", "caller", "context"], "doc_len": 62}
{"doc_id": "astroid/bases.py::BoundMethod.bool_value", "file_path": "astroid/bases.py", "class_name": "BoundMethod", "func_name": "bool_value", "text": "文件路径: astroid/bases.py, 类名: BoundMethod\n    def bool_value(self, context=None):\n        return True\n", "tokens": ["astroid", "bases", "py", "boundmethod", "def", "bool_value", "self", "context", "none", "return", "true"], "doc_len": 11}
{"doc_id": "astroid/bases.py::Generator.__init__", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "__init__", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def __init__(self, parent=None, generator_initial_context=None):\n        super().__init__()\n        self.parent = parent\n        self._call_context = copy_context(generator_initial_context)\n", "tokens": ["astroid", "bases", "py", "generator", "def", "__init__", "self", "parent", "none", "generator_initial_context", "none", "super", "__init__", "self", "parent", "parent", "self", "_call_context", "copy_context", "generator_initial_context"], "doc_len": 20}
{"doc_id": "astroid/bases.py::Generator.infer_yield_types", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "infer_yield_types", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def infer_yield_types(self):\n        yield from self.parent.infer_yield_result(self._call_context)\n", "tokens": ["astroid", "bases", "py", "generator", "def", "infer_yield_types", "self", "yield", "from", "self", "parent", "infer_yield_result", "self", "_call_context"], "doc_len": 14}
{"doc_id": "astroid/bases.py::Generator.callable", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "callable", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def callable(self):\n        return False\n", "tokens": ["astroid", "bases", "py", "generator", "def", "callable", "self", "return", "false"], "doc_len": 9}
{"doc_id": "astroid/bases.py::Generator.pytype", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "pytype", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def pytype(self):\n        return \"builtins.generator\"\n", "tokens": ["astroid", "bases", "py", "generator", "def", "pytype", "self", "return", "builtins", "generator"], "doc_len": 10}
{"doc_id": "astroid/bases.py::Generator.display_type", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "display_type", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def display_type(self):\n        return \"Generator\"\n", "tokens": ["astroid", "bases", "py", "generator", "def", "display_type", "self", "return", "generator"], "doc_len": 9}
{"doc_id": "astroid/bases.py::Generator.bool_value", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "bool_value", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def bool_value(self, context=None):\n        return True\n", "tokens": ["astroid", "bases", "py", "generator", "def", "bool_value", "self", "context", "none", "return", "true"], "doc_len": 11}
{"doc_id": "astroid/bases.py::Generator.__repr__", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "__repr__", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def __repr__(self):\n        return f\"<Generator({self._proxied.name}) l.{self.lineno} at 0x{id(self)}>\"\n", "tokens": ["astroid", "bases", "py", "generator", "def", "__repr__", "self", "return", "f", "generator", "self", "_proxied", "name", "l", "self", "lineno", "at", "0x", "id", "self"], "doc_len": 20}
{"doc_id": "astroid/bases.py::Generator.__str__", "file_path": "astroid/bases.py", "class_name": "Generator", "func_name": "__str__", "text": "文件路径: astroid/bases.py, 类名: Generator\n    def __str__(self):\n        return f\"Generator({self._proxied.name})\"\n", "tokens": ["astroid", "bases", "py", "generator", "def", "__str__", "self", "return", "f", "generator", "self", "_proxied", "name"], "doc_len": 13}
{"doc_id": "astroid/bases.py::AsyncGenerator.pytype", "file_path": "astroid/bases.py", "class_name": "AsyncGenerator", "func_name": "pytype", "text": "文件路径: astroid/bases.py, 类名: AsyncGenerator\n    def pytype(self):\n        return \"builtins.async_generator\"\n", "tokens": ["astroid", "bases", "py", "asyncgenerator", "def", "pytype", "self", "return", "builtins", "async_generator"], "doc_len": 10}
{"doc_id": "astroid/bases.py::AsyncGenerator.display_type", "file_path": "astroid/bases.py", "class_name": "AsyncGenerator", "func_name": "display_type", "text": "文件路径: astroid/bases.py, 类名: AsyncGenerator\n    def display_type(self):\n        return \"AsyncGenerator\"\n", "tokens": ["astroid", "bases", "py", "asyncgenerator", "def", "display_type", "self", "return", "asyncgenerator"], "doc_len": 9}
{"doc_id": "astroid/bases.py::AsyncGenerator.__repr__", "file_path": "astroid/bases.py", "class_name": "AsyncGenerator", "func_name": "__repr__", "text": "文件路径: astroid/bases.py, 类名: AsyncGenerator\n    def __repr__(self):\n        return f\"<AsyncGenerator({self._proxied.name}) l.{self.lineno} at 0x{id(self)}>\"\n", "tokens": ["astroid", "bases", "py", "asyncgenerator", "def", "__repr__", "self", "return", "f", "asyncgenerator", "self", "_proxied", "name", "l", "self", "lineno", "at", "0x", "id", "self"], "doc_len": 20}
{"doc_id": "astroid/bases.py::AsyncGenerator.__str__", "file_path": "astroid/bases.py", "class_name": "AsyncGenerator", "func_name": "__str__", "text": "文件路径: astroid/bases.py, 类名: AsyncGenerator\n    def __str__(self):\n        return f\"AsyncGenerator({self._proxied.name})\"\n", "tokens": ["astroid", "bases", "py", "asyncgenerator", "def", "__str__", "self", "return", "f", "asyncgenerator", "self", "_proxied", "name"], "doc_len": 13}
{"doc_id": "astroid/builder.py::open_source_file", "file_path": "astroid/builder.py", "class_name": null, "func_name": "open_source_file", "text": "文件路径: astroid/builder.py\ndef open_source_file(filename):\n    # pylint: disable=consider-using-with\n    with open(filename, \"rb\") as byte_stream:\n        encoding = detect_encoding(byte_stream.readline)[0]\n    stream = open(filename, newline=None, encoding=encoding)\n    data = stream.read()\n    return stream, encoding, data\n", "tokens": ["astroid", "builder", "py", "def", "open_source_file", "filename", "pylint", "disable", "consider", "using", "with", "with", "open", "filename", "rb", "as", "byte_stream", "encoding", "detect_encoding", "byte_stream", "readline", "0", "stream", "open", "filename", "newline", "none", "encoding", "encoding", "data", "stream", "read", "return", "stream", "encoding", "data"], "doc_len": 36}
{"doc_id": "astroid/builder.py::_can_assign_attr", "file_path": "astroid/builder.py", "class_name": null, "func_name": "_can_assign_attr", "text": "文件路径: astroid/builder.py\ndef _can_assign_attr(node, attrname):\n    try:\n        slots = node.slots()\n    except NotImplementedError:\n        pass\n    else:\n        if slots and attrname not in {slot.value for slot in slots}:\n            return False\n    return node.qname() != \"builtins.object\"\n", "tokens": ["astroid", "builder", "py", "def", "_can_assign_attr", "node", "attrname", "try", "slots", "node", "slots", "except", "notimplementederror", "pass", "else", "if", "slots", "and", "attrname", "not", "in", "slot", "value", "for", "slot", "in", "slots", "return", "false", "return", "node", "qname", "builtins", "object"], "doc_len": 34}
{"doc_id": "astroid/builder.py::AstroidBuilder.__init__", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "__init__", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def __init__(self, manager=None, apply_transforms=True):\n        super().__init__(manager)\n        self._apply_transforms = apply_transforms\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "__init__", "self", "manager", "none", "apply_transforms", "true", "super", "__init__", "manager", "self", "_apply_transforms", "apply_transforms"], "doc_len": 17}
{"doc_id": "astroid/builder.py::AstroidBuilder.module_build", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "module_build", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def module_build(\n        self, module: types.ModuleType, modname: Optional[str] = None\n    ) -> nodes.Module:\n        \"\"\"Build an astroid from a living module instance.\"\"\"\n        node = None\n        path = getattr(module, \"__file__\", None)\n        loader = getattr(module, \"__loader__\", None)\n        # Prefer the loader to get the source rather than assuming we have a\n        # filesystem to read the source file from ourselves.\n        if loader:\n            modname = modname or module.__name__\n            source = loader.get_source(modname)\n            if source:\n                node = self.string_build(source, modname, path=path)\n        if node is None and path is not None:\n            path_, ext = os.path.splitext(modutils._path_from_filename(path))\n            if ext in {\".py\", \".pyc\", \".pyo\"} and os.path.exists(path_ + \".py\"):\n                node = self.file_build(path_ + \".py\", modname)\n        if node is None:\n            # this is a built-in module\n            # get a partial representation by introspection\n            node = self.inspect_build(module, modname=modname, path=path)\n            if self._apply_transforms:\n                # We have to handle transformation by ourselves since the\n                # rebuilder isn't called for builtin nodes\n                node = self._manager.visit_transforms(node)\n        return node\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "module_build", "self", "module", "types", "moduletype", "modname", "optional", "str", "none", "nodes", "module", "build", "an", "astroid", "from", "a", "living", "module", "instance", "node", "none", "path", "getattr", "module", "__file__", "none", "loader", "getattr", "module", "__loader__", "none", "prefer", "the", "loader", "to", "get", "the", "source", "rather", "than", "assuming", "we", "have", "a", "filesystem", "to", "read", "the", "source", "file", "from", "ourselves", "if", "loader", "modname", "modname", "or", "module", "__name__", "source", "loader", "get_source", "modname", "if", "source", "node", "self", "string_build", "source", "modname", "path", "path", "if", "node", "is", "none", "and", "path", "is", "not", "none", "path_", "ext", "os", "path", "splitext", "modutils", "_path_from_filename", "path", "if", "ext", "in", "py", "pyc", "pyo", "and", "os", "path", "exists", "path_", "py", "node", "self", "file_build", "path_", "py", "modname", "if", "node", "is", "none", "this", "is", "a", "built", "in", "module", "get", "a", "partial", "representation", "by", "introspection", "node", "self", "inspect_build", "module", "modname", "modname", "path", "path", "if", "self", "_apply_transforms", "we", "have", "to", "handle", "transformation", "by", "ourselves", "since", "the", "rebuilder", "isn", "t", "called", "for", "builtin", "nodes", "node", "self", "_manager", "visit_transforms", "node", "return", "node"], "doc_len": 162}
{"doc_id": "astroid/builder.py::AstroidBuilder.file_build", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "file_build", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def file_build(self, path, modname=None):\n        \"\"\"Build astroid from a source code file (i.e. from an ast)\n\n        *path* is expected to be a python source file\n        \"\"\"\n        try:\n            stream, encoding, data = open_source_file(path)\n        except OSError as exc:\n            raise AstroidBuildingError(\n                \"Unable to load file {path}:\\n{error}\",\n                modname=modname,\n                path=path,\n                error=exc,\n            ) from exc\n        except (SyntaxError, LookupError) as exc:\n            raise AstroidSyntaxError(\n                \"Python 3 encoding specification error or unknown encoding:\\n\"\n                \"{error}\",\n                modname=modname,\n                path=path,\n                error=exc,\n            ) from exc\n        except UnicodeError as exc:  # wrong encoding\n            # detect_encoding returns utf-8 if no encoding specified\n            raise AstroidBuildingError(\n                \"Wrong or no encoding specified for {filename}.\", filename=path\n            ) from exc\n        with stream:\n            # get module name if necessary\n            if modname is None:\n                try:\n                    modname = \".\".join(modutils.modpath_from_file(path))\n                except ImportError:\n                    modname = os.path.splitext(os.path.basename(path))[0]\n            # build astroid representation\n            module = self._data_build(data, modname, path)\n            return self._post_build(module, encoding)\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "file_build", "self", "path", "modname", "none", "build", "astroid", "from", "a", "source", "code", "file", "i", "e", "from", "an", "ast", "path", "is", "expected", "to", "be", "a", "python", "source", "file", "try", "stream", "encoding", "data", "open_source_file", "path", "except", "oserror", "as", "exc", "raise", "astroidbuildingerror", "unable", "to", "load", "file", "path", "n", "error", "modname", "modname", "path", "path", "error", "exc", "from", "exc", "except", "syntaxerror", "lookuperror", "as", "exc", "raise", "astroidsyntaxerror", "python", "3", "encoding", "specification", "error", "or", "unknown", "encoding", "n", "error", "modname", "modname", "path", "path", "error", "exc", "from", "exc", "except", "unicodeerror", "as", "exc", "wrong", "encoding", "detect_encoding", "returns", "utf", "8", "if", "no", "encoding", "specified", "raise", "astroidbuildingerror", "wrong", "or", "no", "encoding", "specified", "for", "filename", "filename", "path", "from", "exc", "with", "stream", "get", "module", "name", "if", "necessary", "if", "modname", "is", "none", "try", "modname", "join", "modutils", "modpath_from_file", "path", "except", "importerror", "modname", "os", "path", "splitext", "os", "path", "basename", "path", "0", "build", "astroid", "representation", "module", "self", "_data_build", "data", "modname", "path", "return", "self", "_post_build", "module", "encoding"], "doc_len": 152}
{"doc_id": "astroid/builder.py::AstroidBuilder.string_build", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "string_build", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def string_build(self, data, modname=\"\", path=None):\n        \"\"\"Build astroid from source code string.\"\"\"\n        module = self._data_build(data, modname, path)\n        module.file_bytes = data.encode(\"utf-8\")\n        return self._post_build(module, \"utf-8\")\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "string_build", "self", "data", "modname", "path", "none", "build", "astroid", "from", "source", "code", "string", "module", "self", "_data_build", "data", "modname", "path", "module", "file_bytes", "data", "encode", "utf", "8", "return", "self", "_post_build", "module", "utf", "8"], "doc_len": 35}
{"doc_id": "astroid/builder.py::AstroidBuilder._post_build", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "_post_build", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def _post_build(self, module, encoding):\n        \"\"\"Handles encoding and delayed nodes after a module has been built\"\"\"\n        module.file_encoding = encoding\n        self._manager.cache_module(module)\n        # post tree building steps after we stored the module in the cache:\n        for from_node in module._import_from_nodes:\n            if from_node.modname == \"__future__\":\n                for symbol, _ in from_node.names:\n                    module.future_imports.add(symbol)\n            self.add_from_names_to_locals(from_node)\n        # handle delayed assattr nodes\n        for delayed in module._delayed_assattr:\n            self.delayed_assattr(delayed)\n\n        # Visit the transforms\n        if self._apply_transforms:\n            module = self._manager.visit_transforms(module)\n        return module\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "_post_build", "self", "module", "encoding", "handles", "encoding", "and", "delayed", "nodes", "after", "a", "module", "has", "been", "built", "module", "file_encoding", "encoding", "self", "_manager", "cache_module", "module", "post", "tree", "building", "steps", "after", "we", "stored", "the", "module", "in", "the", "cache", "for", "from_node", "in", "module", "_import_from_nodes", "if", "from_node", "modname", "__future__", "for", "symbol", "_", "in", "from_node", "names", "module", "future_imports", "add", "symbol", "self", "add_from_names_to_locals", "from_node", "handle", "delayed", "assattr", "nodes", "for", "delayed", "in", "module", "_delayed_assattr", "self", "delayed_assattr", "delayed", "visit", "the", "transforms", "if", "self", "_apply_transforms", "module", "self", "_manager", "visit_transforms", "module", "return", "module"], "doc_len": 86}
{"doc_id": "astroid/builder.py::AstroidBuilder._data_build", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "_data_build", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def _data_build(self, data, modname, path):\n        \"\"\"Build tree node from data and add some information\"\"\"\n        try:\n            node, parser_module = _parse_string(data, type_comments=True)\n        except (TypeError, ValueError, SyntaxError) as exc:\n            raise AstroidSyntaxError(\n                \"Parsing Python code failed:\\n{error}\",\n                source=data,\n                modname=modname,\n                path=path,\n                error=exc,\n            ) from exc\n\n        if path is not None:\n            node_file = os.path.abspath(path)\n        else:\n            node_file = \"<?>\"\n        if modname.endswith(\".__init__\"):\n            modname = modname[:-9]\n            package = True\n        else:\n            package = (\n                path is not None\n                and os.path.splitext(os.path.basename(path))[0] == \"__init__\"\n            )\n        builder = rebuilder.TreeRebuilder(self._manager, parser_module)\n        module = builder.visit_module(node, modname, node_file, package)\n        module._import_from_nodes = builder._import_from_nodes\n        module._delayed_assattr = builder._delayed_assattr\n        return module\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "_data_build", "self", "data", "modname", "path", "build", "tree", "node", "from", "data", "and", "add", "some", "information", "try", "node", "parser_module", "_parse_string", "data", "type_comments", "true", "except", "typeerror", "valueerror", "syntaxerror", "as", "exc", "raise", "astroidsyntaxerror", "parsing", "python", "code", "failed", "n", "error", "source", "data", "modname", "modname", "path", "path", "error", "exc", "from", "exc", "if", "path", "is", "not", "none", "node_file", "os", "path", "abspath", "path", "else", "node_file", "if", "modname", "endswith", "__init__", "modname", "modname", "9", "package", "true", "else", "package", "path", "is", "not", "none", "and", "os", "path", "splitext", "os", "path", "basename", "path", "0", "__init__", "builder", "rebuilder", "treerebuilder", "self", "_manager", "parser_module", "module", "builder", "visit_module", "node", "modname", "node_file", "package", "module", "_import_from_nodes", "builder", "_import_from_nodes", "module", "_delayed_assattr", "builder", "_delayed_assattr", "return", "module"], "doc_len": 110}
{"doc_id": "astroid/builder.py::AstroidBuilder.add_from_names_to_locals", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "add_from_names_to_locals", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def add_from_names_to_locals(self, node):\n        \"\"\"Store imported names to the locals\n\n        Resort the locals if coming from a delayed node\n        \"\"\"\n\n        def _key_func(node):\n            return node.fromlineno\n\n        def sort_locals(my_list):\n            my_list.sort(key=_key_func)\n\n        for (name, asname) in node.names:\n            if name == \"*\":\n                try:\n                    imported = node.do_import_module()\n                except AstroidBuildingError:\n                    continue\n                for name in imported.public_names():\n                    node.parent.set_local(name, node)\n                    sort_locals(node.parent.scope().locals[name])\n            else:\n                node.parent.set_local(asname or name, node)\n                sort_locals(node.parent.scope().locals[asname or name])\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "add_from_names_to_locals", "self", "node", "store", "imported", "names", "to", "the", "locals", "resort", "the", "locals", "if", "coming", "from", "a", "delayed", "node", "def", "_key_func", "node", "return", "node", "fromlineno", "def", "sort_locals", "my_list", "my_list", "sort", "key", "_key_func", "for", "name", "asname", "in", "node", "names", "if", "name", "try", "imported", "node", "do_import_module", "except", "astroidbuildingerror", "continue", "for", "name", "in", "imported", "public_names", "node", "parent", "set_local", "name", "node", "sort_locals", "node", "parent", "scope", "locals", "name", "else", "node", "parent", "set_local", "asname", "or", "name", "node", "sort_locals", "node", "parent", "scope", "locals", "asname", "or", "name"], "doc_len": 83}
{"doc_id": "astroid/builder.py::AstroidBuilder.delayed_assattr", "file_path": "astroid/builder.py", "class_name": "AstroidBuilder", "func_name": "delayed_assattr", "text": "文件路径: astroid/builder.py, 类名: AstroidBuilder\n    def delayed_assattr(self, node):\n        \"\"\"Visit a AssAttr node\n\n        This adds name to locals and handle members definition.\n        \"\"\"\n        try:\n            frame = node.frame(future=True)\n            for inferred in node.expr.infer():\n                if inferred is util.Uninferable:\n                    continue\n                try:\n                    cls = inferred.__class__\n                    if cls is bases.Instance or cls is objects.ExceptionInstance:\n                        inferred = inferred._proxied\n                        iattrs = inferred.instance_attrs\n                        if not _can_assign_attr(inferred, node.attrname):\n                            continue\n                    elif isinstance(inferred, bases.Instance):\n                        # Const, Tuple or other containers that inherit from\n                        # `Instance`\n                        continue\n                    elif inferred.is_function:\n                        iattrs = inferred.instance_attrs\n                    else:\n                        iattrs = inferred.locals\n                except AttributeError:\n                    # XXX log error\n                    continue\n                values = iattrs.setdefault(node.attrname, [])\n                if node in values:\n                    continue\n                # get assign in __init__ first XXX useful ?\n                if (\n                    frame.name == \"__init__\"\n                    and values\n                    and values[0].frame(future=True).name != \"__init__\"\n                ):\n                    values.insert(0, node)\n                else:\n                    values.append(node)\n        except InferenceError:\n            pass\n", "tokens": ["astroid", "builder", "py", "astroidbuilder", "def", "delayed_assattr", "self", "node", "visit", "a", "assattr", "node", "this", "adds", "name", "to", "locals", "and", "handle", "members", "definition", "try", "frame", "node", "frame", "future", "true", "for", "inferred", "in", "node", "expr", "infer", "if", "inferred", "is", "util", "uninferable", "continue", "try", "cls", "inferred", "__class__", "if", "cls", "is", "bases", "instance", "or", "cls", "is", "objects", "exceptioninstance", "inferred", "inferred", "_proxied", "iattrs", "inferred", "instance_attrs", "if", "not", "_can_assign_attr", "inferred", "node", "attrname", "continue", "elif", "isinstance", "inferred", "bases", "instance", "const", "tuple", "or", "other", "containers", "that", "inherit", "from", "instance", "continue", "elif", "inferred", "is_function", "iattrs", "inferred", "instance_attrs", "else", "iattrs", "inferred", "locals", "except", "attributeerror", "xxx", "log", "error", "continue", "values", "iattrs", "setdefault", "node", "attrname", "if", "node", "in", "values", "continue", "get", "assign", "in", "__init__", "first", "xxx", "useful", "if", "frame", "name", "__init__", "and", "values", "and", "values", "0", "frame", "future", "true", "name", "__init__", "values", "insert", "0", "node", "else", "values", "append", "node", "except", "inferenceerror", "pass"], "doc_len": 139}
{"doc_id": "astroid/builder.py::build_namespace_package_module", "file_path": "astroid/builder.py", "class_name": null, "func_name": "build_namespace_package_module", "text": "文件路径: astroid/builder.py\ndef build_namespace_package_module(name: str, path: List[str]) -> nodes.Module:\n    return nodes.Module(name, doc=\"\", path=path, package=True)\n", "tokens": ["astroid", "builder", "py", "def", "build_namespace_package_module", "name", "str", "path", "list", "str", "nodes", "module", "return", "nodes", "module", "name", "doc", "path", "path", "package", "true"], "doc_len": 21}
{"doc_id": "astroid/builder.py::parse", "file_path": "astroid/builder.py", "class_name": null, "func_name": "parse", "text": "文件路径: astroid/builder.py\ndef parse(code, module_name=\"\", path=None, apply_transforms=True):\n    \"\"\"Parses a source string in order to obtain an astroid AST from it\n\n    :param str code: The code for the module.\n    :param str module_name: The name for the module, if any\n    :param str path: The path for the module\n    :param bool apply_transforms:\n        Apply the transforms for the give code. Use it if you\n        don't want the default transforms to be applied.\n    \"\"\"\n    code = textwrap.dedent(code)\n    builder = AstroidBuilder(\n        manager=AstroidManager(), apply_transforms=apply_transforms\n    )\n    return builder.string_build(code, modname=module_name, path=path)\n", "tokens": ["astroid", "builder", "py", "def", "parse", "code", "module_name", "path", "none", "apply_transforms", "true", "parses", "a", "source", "string", "in", "order", "to", "obtain", "an", "astroid", "ast", "from", "it", "param", "str", "code", "the", "code", "for", "the", "module", "param", "str", "module_name", "the", "name", "for", "the", "module", "if", "any", "param", "str", "path", "the", "path", "for", "the", "module", "param", "bool", "apply_transforms", "apply", "the", "transforms", "for", "the", "give", "code", "use", "it", "if", "you", "don", "t", "want", "the", "default", "transforms", "to", "be", "applied", "code", "textwrap", "dedent", "code", "builder", "astroidbuilder", "manager", "astroidmanager", "apply_transforms", "apply_transforms", "return", "builder", "string_build", "code", "modname", "module_name", "path", "path"], "doc_len": 91}
{"doc_id": "astroid/builder.py::_extract_expressions", "file_path": "astroid/builder.py", "class_name": null, "func_name": "_extract_expressions", "text": "文件路径: astroid/builder.py\ndef _extract_expressions(node):\n    \"\"\"Find expressions in a call to _TRANSIENT_FUNCTION and extract them.\n\n    The function walks the AST recursively to search for expressions that\n    are wrapped into a call to _TRANSIENT_FUNCTION. If it finds such an\n    expression, it completely removes the function call node from the tree,\n    replacing it by the wrapped expression inside the parent.\n\n    :param node: An astroid node.\n    :type node:  astroid.bases.NodeNG\n    :yields: The sequence of wrapped expressions on the modified tree\n    expression can be found.\n    \"\"\"\n    if (\n        isinstance(node, nodes.Call)\n        and isinstance(node.func, nodes.Name)\n        and node.func.name == _TRANSIENT_FUNCTION\n    ):\n        real_expr = node.args[0]\n        real_expr.parent = node.parent\n        # Search for node in all _astng_fields (the fields checked when\n        # get_children is called) of its parent. Some of those fields may\n        # be lists or tuples, in which case the elements need to be checked.\n        # When we find it, replace it by real_expr, so that the AST looks\n        # like no call to _TRANSIENT_FUNCTION ever took place.\n        for name in node.parent._astroid_fields:\n            child = getattr(node.parent, name)\n            if isinstance(child, (list, tuple)):\n                for idx, compound_child in enumerate(child):\n                    if compound_child is node:\n                        child[idx] = real_expr\n            elif child is node:\n                setattr(node.parent, name, real_expr)\n        yield real_expr\n    else:\n        for child in node.get_children():\n            yield from _extract_expressions(child)\n", "tokens": ["astroid", "builder", "py", "def", "_extract_expressions", "node", "find", "expressions", "in", "a", "call", "to", "_transient_function", "and", "extract", "them", "the", "function", "walks", "the", "ast", "recursively", "to", "search", "for", "expressions", "that", "are", "wrapped", "into", "a", "call", "to", "_transient_function", "if", "it", "finds", "such", "an", "expression", "it", "completely", "removes", "the", "function", "call", "node", "from", "the", "tree", "replacing", "it", "by", "the", "wrapped", "expression", "inside", "the", "parent", "param", "node", "an", "astroid", "node", "type", "node", "astroid", "bases", "nodeng", "yields", "the", "sequence", "of", "wrapped", "expressions", "on", "the", "modified", "tree", "expression", "can", "be", "found", "if", "isinstance", "node", "nodes", "call", "and", "isinstance", "node", "func", "nodes", "name", "and", "node", "func", "name", "_transient_function", "real_expr", "node", "args", "0", "real_expr", "parent", "node", "parent", "search", "for", "node", "in", "all", "_astng_fields", "the", "fields", "checked", "when", "get_children", "is", "called", "of", "its", "parent", "some", "of", "those", "fields", "may", "be", "lists", "or", "tuples", "in", "which", "case", "the", "elements", "need", "to", "be", "checked", "when", "we", "find", "it", "replace", "it", "by", "real_expr", "so", "that", "the", "ast", "looks", "like", "no", "call", "to", "_transient_function", "ever", "took", "place", "for", "name", "in", "node", "parent", "_astroid_fields", "child", "getattr", "node", "parent", "name", "if", "isinstance", "child", "list", "tuple", "for", "idx", "compound_child", "in", "enumerate", "child", "if", "compound_child", "is", "node", "child", "idx", "real_expr", "elif", "child", "is", "node", "setattr", "node", "parent", "name", "real_expr", "yield", "real_expr", "else", "for", "child", "in", "node", "get_children", "yield", "from", "_extract_expressions", "child"], "doc_len": 212}
{"doc_id": "astroid/builder.py::_find_statement_by_line", "file_path": "astroid/builder.py", "class_name": null, "func_name": "_find_statement_by_line", "text": "文件路径: astroid/builder.py\ndef _find_statement_by_line(node, line):\n    \"\"\"Extracts the statement on a specific line from an AST.\n\n    If the line number of node matches line, it will be returned;\n    otherwise its children are iterated and the function is called\n    recursively.\n\n    :param node: An astroid node.\n    :type node: astroid.bases.NodeNG\n    :param line: The line number of the statement to extract.\n    :type line: int\n    :returns: The statement on the line, or None if no statement for the line\n      can be found.\n    :rtype:  astroid.bases.NodeNG or None\n    \"\"\"\n    if isinstance(node, (nodes.ClassDef, nodes.FunctionDef, nodes.MatchCase)):\n        # This is an inaccuracy in the AST: the nodes that can be\n        # decorated do not carry explicit information on which line\n        # the actual definition (class/def), but .fromline seems to\n        # be close enough.\n        node_line = node.fromlineno\n    else:\n        node_line = node.lineno\n\n    if node_line == line:\n        return node\n\n    for child in node.get_children():\n        result = _find_statement_by_line(child, line)\n        if result:\n            return result\n\n    return None\n", "tokens": ["astroid", "builder", "py", "def", "_find_statement_by_line", "node", "line", "extracts", "the", "statement", "on", "a", "specific", "line", "from", "an", "ast", "if", "the", "line", "number", "of", "node", "matches", "line", "it", "will", "be", "returned", "otherwise", "its", "children", "are", "iterated", "and", "the", "function", "is", "called", "recursively", "param", "node", "an", "astroid", "node", "type", "node", "astroid", "bases", "nodeng", "param", "line", "the", "line", "number", "of", "the", "statement", "to", "extract", "type", "line", "int", "returns", "the", "statement", "on", "the", "line", "or", "none", "if", "no", "statement", "for", "the", "line", "can", "be", "found", "rtype", "astroid", "bases", "nodeng", "or", "none", "if", "isinstance", "node", "nodes", "classdef", "nodes", "functiondef", "nodes", "matchcase", "this", "is", "an", "inaccuracy", "in", "the", "ast", "the", "nodes", "that", "can", "be", "decorated", "do", "not", "carry", "explicit", "information", "on", "which", "line", "the", "actual", "definition", "class", "def", "but", "fromline", "seems", "to", "be", "close", "enough", "node_line", "node", "fromlineno", "else", "node_line", "node", "lineno", "if", "node_line", "line", "return", "node", "for", "child", "in", "node", "get_children", "result", "_find_statement_by_line", "child", "line", "if", "result", "return", "result", "return", "none"], "doc_len": 155}
{"doc_id": "astroid/builder.py::extract_node", "file_path": "astroid/builder.py", "class_name": null, "func_name": "extract_node", "text": "文件路径: astroid/builder.py\ndef extract_node(code: str, module_name: str = \"\") -> Union[NodeNG, List[NodeNG]]:\n    \"\"\"Parses some Python code as a module and extracts a designated AST node.\n\n    Statements:\n     To extract one or more statement nodes, append #@ to the end of the line\n\n     Examples:\n       >>> def x():\n       >>>   def y():\n       >>>     return 1 #@\n\n       The return statement will be extracted.\n\n       >>> class X(object):\n       >>>   def meth(self): #@\n       >>>     pass\n\n      The function object 'meth' will be extracted.\n\n    Expressions:\n     To extract arbitrary expressions, surround them with the fake\n     function call __(...). After parsing, the surrounded expression\n     will be returned and the whole AST (accessible via the returned\n     node's parent attribute) will look like the function call was\n     never there in the first place.\n\n     Examples:\n       >>> a = __(1)\n\n       The const node will be extracted.\n\n       >>> def x(d=__(foo.bar)): pass\n\n       The node containing the default argument will be extracted.\n\n       >>> def foo(a, b):\n       >>>   return 0 < __(len(a)) < b\n\n       The node containing the function call 'len' will be extracted.\n\n    If no statements or expressions are selected, the last toplevel\n    statement will be returned.\n\n    If the selected statement is a discard statement, (i.e. an expression\n    turned into a statement), the wrapped expression is returned instead.\n\n    For convenience, singleton lists are unpacked.\n\n    :param str code: A piece of Python code that is parsed as\n    a module. Will be passed through textwrap.dedent first.\n    :param str module_name: The name of the module.\n    :returns: The designated node from the parse tree, or a list of nodes.\n    \"\"\"\n\n    def _extract(node):\n        if isinstance(node, nodes.Expr):\n            return node.value\n\n        return node\n\n    requested_lines = []\n    for idx, line in enumerate(code.splitlines()):\n        if line.strip().endswith(_STATEMENT_SELECTOR):\n            requested_lines.append(idx + 1)\n\n    tree = parse(code, module_name=module_name)\n    if not tree.body:\n        raise ValueError(\"Empty tree, cannot extract from it\")\n\n    extracted = []\n    if requested_lines:\n        extracted = [_find_statement_by_line(tree, line) for line in requested_lines]\n\n    # Modifies the tree.\n    extracted.extend(_extract_expressions(tree))\n\n    if not extracted:\n        extracted.append(tree.body[-1])\n\n    extracted = [_extract(node) for node in extracted]\n    if len(extracted) == 1:\n        return extracted[0]\n    return extracted\n", "tokens": ["astroid", "builder", "py", "def", "extract_node", "code", "str", "module_name", "str", "union", "nodeng", "list", "nodeng", "parses", "some", "python", "code", "as", "a", "module", "and", "extracts", "a", "designated", "ast", "node", "statements", "to", "extract", "one", "or", "more", "statement", "nodes", "append", "to", "the", "end", "of", "the", "line", "examples", "def", "x", "def", "y", "return", "1", "the", "return", "statement", "will", "be", "extracted", "class", "x", "object", "def", "meth", "self", "pass", "the", "function", "object", "meth", "will", "be", "extracted", "expressions", "to", "extract", "arbitrary", "expressions", "surround", "them", "with", "the", "fake", "function", "call", "__", "after", "parsing", "the", "surrounded", "expression", "will", "be", "returned", "and", "the", "whole", "ast", "accessible", "via", "the", "returned", "node", "s", "parent", "attribute", "will", "look", "like", "the", "function", "call", "was", "never", "there", "in", "the", "first", "place", "examples", "a", "__", "1", "the", "const", "node", "will", "be", "extracted", "def", "x", "d", "__", "foo", "bar", "pass", "the", "node", "containing", "the", "default", "argument", "will", "be", "extracted", "def", "foo", "a", "b", "return", "0", "__", "len", "a", "b", "the", "node", "containing", "the", "function", "call", "len", "will", "be", "extracted", "if", "no", "statements", "or", "expressions", "are", "selected", "the", "last", "toplevel", "statement", "will", "be", "returned", "if", "the", "selected", "statement", "is", "a", "discard", "statement", "i", "e", "an", "expression", "turned", "into", "a", "statement", "the", "wrapped", "expression", "is", "returned", "instead", "for", "convenience", "singleton", "lists", "are", "unpacked", "param", "str", "code", "a", "piece", "of", "python", "code", "that", "is", "parsed", "as", "a", "module", "will", "be", "passed", "through", "textwrap", "dedent", "first", "param", "str", "module_name", "the", "name", "of", "the", "module", "returns", "the", "designated", "node", "from", "the", "parse", "tree", "or", "a", "list", "of", "nodes", "def", "_extract", "node", "if", "isinstance", "node", "nodes", "expr", "return", "node", "value", "return", "node", "requested_lines", "for", "idx", "line", "in", "enumerate", "code", "splitlines", "if", "line", "strip", "endswith", "_statement_selector", "requested_lines", "append", "idx", "1", "tree", "parse", "code", "module_name", "module_name", "if", "not", "tree", "body", "raise", "valueerror", "empty", "tree", "cannot", "extract", "from", "it", "extracted", "if", "requested_lines", "extracted", "_find_statement_by_line", "tree", "line", "for", "line", "in", "requested_lines", "modifies", "the", "tree", "extracted", "extend", "_extract_expressions", "tree", "if", "not", "extracted", "extracted", "append", "tree", "body", "1", "extracted", "_extract", "node", "for", "node", "in", "extracted", "if", "len", "extracted", "1", "return", "extracted", "0", "return", "extracted"], "doc_len": 333}
{"doc_id": "astroid/builder.py::_parse_string", "file_path": "astroid/builder.py", "class_name": null, "func_name": "_parse_string", "text": "文件路径: astroid/builder.py\ndef _parse_string(data, type_comments=True):\n    parser_module = get_parser_module(type_comments=type_comments)\n    try:\n        parsed = parser_module.parse(data + \"\\n\", type_comments=type_comments)\n    except SyntaxError as exc:\n        # If the type annotations are misplaced for some reason, we do not want\n        # to fail the entire parsing of the file, so we need to retry the parsing without\n        # type comment support.\n        if exc.args[0] != MISPLACED_TYPE_ANNOTATION_ERROR or not type_comments:\n            raise\n\n        parser_module = get_parser_module(type_comments=False)\n        parsed = parser_module.parse(data + \"\\n\", type_comments=False)\n    return parsed, parser_module\n", "tokens": ["astroid", "builder", "py", "def", "_parse_string", "data", "type_comments", "true", "parser_module", "get_parser_module", "type_comments", "type_comments", "try", "parsed", "parser_module", "parse", "data", "n", "type_comments", "type_comments", "except", "syntaxerror", "as", "exc", "if", "the", "type", "annotations", "are", "misplaced", "for", "some", "reason", "we", "do", "not", "want", "to", "fail", "the", "entire", "parsing", "of", "the", "file", "so", "we", "need", "to", "retry", "the", "parsing", "without", "type", "comment", "support", "if", "exc", "args", "0", "misplaced_type_annotation_error", "or", "not", "type_comments", "raise", "parser_module", "get_parser_module", "type_comments", "false", "parsed", "parser_module", "parse", "data", "n", "type_comments", "false", "return", "parsed", "parser_module"], "doc_len": 79}
{"doc_id": "astroid/context.py::_invalidate_cache", "file_path": "astroid/context.py", "class_name": null, "func_name": "_invalidate_cache", "text": "文件路径: astroid/context.py\ndef _invalidate_cache():\n    _INFERENCE_CACHE.clear()\n", "tokens": ["astroid", "context", "py", "def", "_invalidate_cache", "_inference_cache", "clear"], "doc_len": 7}
{"doc_id": "astroid/context.py::InferenceContext.__init__", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "__init__", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def __init__(self, path=None, nodes_inferred=None):\n        if nodes_inferred is None:\n            self._nodes_inferred = [0]\n        else:\n            self._nodes_inferred = nodes_inferred\n        self.path = path or set()\n        \"\"\"\n        :type: set(tuple(NodeNG, optional(str)))\n\n        Path of visited nodes and their lookupname\n\n        Currently this key is ``(node, context.lookupname)``\n        \"\"\"\n        self.lookupname = None\n        \"\"\"\n        :type: optional[str]\n\n        The original name of the node\n\n        e.g.\n        foo = 1\n        The inference of 'foo' is nodes.Const(1) but the lookup name is 'foo'\n        \"\"\"\n        self.callcontext = None\n        \"\"\"\n        :type: optional[CallContext]\n\n        The call arguments and keywords for the given context\n        \"\"\"\n        self.boundnode = None\n        \"\"\"\n        :type: optional[NodeNG]\n\n        The bound node of the given context\n\n        e.g. the bound node of object.__new__(cls) is the object node\n        \"\"\"\n        self.extra_context = {}\n        \"\"\"\n        :type: dict(NodeNG, Context)\n\n        Context that needs to be passed down through call stacks\n        for call arguments\n        \"\"\"\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "__init__", "self", "path", "none", "nodes_inferred", "none", "if", "nodes_inferred", "is", "none", "self", "_nodes_inferred", "0", "else", "self", "_nodes_inferred", "nodes_inferred", "self", "path", "path", "or", "set", "type", "set", "tuple", "nodeng", "optional", "str", "path", "of", "visited", "nodes", "and", "their", "lookupname", "currently", "this", "key", "is", "node", "context", "lookupname", "self", "lookupname", "none", "type", "optional", "str", "the", "original", "name", "of", "the", "node", "e", "g", "foo", "1", "the", "inference", "of", "foo", "is", "nodes", "const", "1", "but", "the", "lookup", "name", "is", "foo", "self", "callcontext", "none", "type", "optional", "callcontext", "the", "call", "arguments", "and", "keywords", "for", "the", "given", "context", "self", "boundnode", "none", "type", "optional", "nodeng", "the", "bound", "node", "of", "the", "given", "context", "e", "g", "the", "bound", "node", "of", "object", "__new__", "cls", "is", "the", "object", "node", "self", "extra_context", "type", "dict", "nodeng", "context", "context", "that", "needs", "to", "be", "passed", "down", "through", "call", "stacks", "for", "call", "arguments"], "doc_len": 137}
{"doc_id": "astroid/context.py::InferenceContext.nodes_inferred", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "nodes_inferred", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def nodes_inferred(self):\n        \"\"\"\n        Number of nodes inferred in this context and all its clones/descendents\n\n        Wrap inner value in a mutable cell to allow for mutating a class\n        variable in the presence of __slots__\n        \"\"\"\n        return self._nodes_inferred[0]\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "nodes_inferred", "self", "number", "of", "nodes", "inferred", "in", "this", "context", "and", "all", "its", "clones", "descendents", "wrap", "inner", "value", "in", "a", "mutable", "cell", "to", "allow", "for", "mutating", "a", "class", "variable", "in", "the", "presence", "of", "__slots__", "return", "self", "_nodes_inferred", "0"], "doc_len": 42}
{"doc_id": "astroid/context.py::InferenceContext.nodes_inferred", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "nodes_inferred", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def nodes_inferred(self, value):\n        self._nodes_inferred[0] = value\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "nodes_inferred", "self", "value", "self", "_nodes_inferred", "0", "value"], "doc_len": 12}
{"doc_id": "astroid/context.py::InferenceContext.inferred", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "inferred", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def inferred(\n        self,\n    ) -> MutableMapping[\n        Tuple[\"NodeNG\", Optional[str], Optional[str], Optional[str]], Sequence[\"NodeNG\"]\n    ]:\n        \"\"\"\n        Inferred node contexts to their mapped results\n\n        Currently the key is ``(node, lookupname, callcontext, boundnode)``\n        and the value is tuple of the inferred results\n        \"\"\"\n        return _INFERENCE_CACHE\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "inferred", "self", "mutablemapping", "tuple", "nodeng", "optional", "str", "optional", "str", "optional", "str", "sequence", "nodeng", "inferred", "node", "contexts", "to", "their", "mapped", "results", "currently", "the", "key", "is", "node", "lookupname", "callcontext", "boundnode", "and", "the", "value", "is", "tuple", "of", "the", "inferred", "results", "return", "_inference_cache"], "doc_len": 44}
{"doc_id": "astroid/context.py::InferenceContext.push", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "push", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def push(self, node):\n        \"\"\"Push node into inference path\n\n        :return: True if node is already in context path else False\n        :rtype: bool\n\n        Allows one to see if the given node has already\n        been looked at for this inference context\"\"\"\n        name = self.lookupname\n        if (node, name) in self.path:\n            return True\n\n        self.path.add((node, name))\n        return False\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "push", "self", "node", "push", "node", "into", "inference", "path", "return", "true", "if", "node", "is", "already", "in", "context", "path", "else", "false", "rtype", "bool", "allows", "one", "to", "see", "if", "the", "given", "node", "has", "already", "been", "looked", "at", "for", "this", "inference", "context", "name", "self", "lookupname", "if", "node", "name", "in", "self", "path", "return", "true", "self", "path", "add", "node", "name", "return", "false"], "doc_len": 61}
{"doc_id": "astroid/context.py::InferenceContext.clone", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "clone", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def clone(self):\n        \"\"\"Clone inference path\n\n        For example, each side of a binary operation (BinOp)\n        starts with the same context but diverge as each side is inferred\n        so the InferenceContext will need be cloned\"\"\"\n        # XXX copy lookupname/callcontext ?\n        clone = InferenceContext(self.path.copy(), nodes_inferred=self._nodes_inferred)\n        clone.callcontext = self.callcontext\n        clone.boundnode = self.boundnode\n        clone.extra_context = self.extra_context\n        return clone\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "clone", "self", "clone", "inference", "path", "for", "example", "each", "side", "of", "a", "binary", "operation", "binop", "starts", "with", "the", "same", "context", "but", "diverge", "as", "each", "side", "is", "inferred", "so", "the", "inferencecontext", "will", "need", "be", "cloned", "xxx", "copy", "lookupname", "callcontext", "clone", "inferencecontext", "self", "path", "copy", "nodes_inferred", "self", "_nodes_inferred", "clone", "callcontext", "self", "callcontext", "clone", "boundnode", "self", "boundnode", "clone", "extra_context", "self", "extra_context", "return", "clone"], "doc_len": 64}
{"doc_id": "astroid/context.py::InferenceContext.restore_path", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "restore_path", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def restore_path(self):\n        path = set(self.path)\n        yield\n        self.path = path\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "restore_path", "self", "path", "set", "self", "path", "yield", "self", "path", "path"], "doc_len": 15}
{"doc_id": "astroid/context.py::InferenceContext.__str__", "file_path": "astroid/context.py", "class_name": "InferenceContext", "func_name": "__str__", "text": "文件路径: astroid/context.py, 类名: InferenceContext\n    def __str__(self):\n        state = (\n            f\"{field}={pprint.pformat(getattr(self, field), width=80 - len(field))}\"\n            for field in self.__slots__\n        )\n        return \"{}({})\".format(type(self).__name__, \",\\n    \".join(state))\n", "tokens": ["astroid", "context", "py", "inferencecontext", "def", "__str__", "self", "state", "f", "field", "pprint", "pformat", "getattr", "self", "field", "width", "80", "len", "field", "for", "field", "in", "self", "__slots__", "return", "format", "type", "self", "__name__", "n", "join", "state"], "doc_len": 32}
{"doc_id": "astroid/context.py::CallContext.__init__", "file_path": "astroid/context.py", "class_name": "CallContext", "func_name": "__init__", "text": "文件路径: astroid/context.py, 类名: CallContext\n    def __init__(\n        self,\n        args: List[\"NodeNG\"],\n        keywords: Optional[List[\"Keyword\"]] = None,\n        callee: Optional[\"NodeNG\"] = None,\n    ):\n        self.args = args  # Call positional arguments\n        if keywords:\n            keywords = [(arg.arg, arg.value) for arg in keywords]\n        else:\n            keywords = []\n        self.keywords = keywords  # Call keyword arguments\n        self.callee = callee  # Function being called\n", "tokens": ["astroid", "context", "py", "callcontext", "def", "__init__", "self", "args", "list", "nodeng", "keywords", "optional", "list", "keyword", "none", "callee", "optional", "nodeng", "none", "self", "args", "args", "call", "positional", "arguments", "if", "keywords", "keywords", "arg", "arg", "arg", "value", "for", "arg", "in", "keywords", "else", "keywords", "self", "keywords", "keywords", "call", "keyword", "arguments", "self", "callee", "callee", "function", "being", "called"], "doc_len": 50}
{"doc_id": "astroid/context.py::copy_context", "file_path": "astroid/context.py", "class_name": null, "func_name": "copy_context", "text": "文件路径: astroid/context.py\ndef copy_context(context: Optional[InferenceContext]) -> InferenceContext:\n    \"\"\"Clone a context if given, or return a fresh contexxt\"\"\"\n    if context is not None:\n        return context.clone()\n\n    return InferenceContext()\n", "tokens": ["astroid", "context", "py", "def", "copy_context", "context", "optional", "inferencecontext", "inferencecontext", "clone", "a", "context", "if", "given", "or", "return", "a", "fresh", "contexxt", "if", "context", "is", "not", "none", "return", "context", "clone", "return", "inferencecontext"], "doc_len": 29}
{"doc_id": "astroid/context.py::bind_context_to_node", "file_path": "astroid/context.py", "class_name": null, "func_name": "bind_context_to_node", "text": "文件路径: astroid/context.py\ndef bind_context_to_node(context, node):\n    \"\"\"Give a context a boundnode\n    to retrieve the correct function name or attribute value\n    with from further inference.\n\n    Do not use an existing context since the boundnode could then\n    be incorrectly propagated higher up in the call stack.\n\n    :param context: Context to use\n    :type context: Optional(context)\n\n    :param node: Node to do name lookups from\n    :type node NodeNG:\n\n    :returns: A new context\n    :rtype: InferenceContext\n    \"\"\"\n    context = copy_context(context)\n    context.boundnode = node\n    return context\n", "tokens": ["astroid", "context", "py", "def", "bind_context_to_node", "context", "node", "give", "a", "context", "a", "boundnode", "to", "retrieve", "the", "correct", "function", "name", "or", "attribute", "value", "with", "from", "further", "inference", "do", "not", "use", "an", "existing", "context", "since", "the", "boundnode", "could", "then", "be", "incorrectly", "propagated", "higher", "up", "in", "the", "call", "stack", "param", "context", "context", "to", "use", "type", "context", "optional", "context", "param", "node", "node", "to", "do", "name", "lookups", "from", "type", "node", "nodeng", "returns", "a", "new", "context", "rtype", "inferencecontext", "context", "copy_context", "context", "context", "boundnode", "node", "return", "context"], "doc_len": 79}
{"doc_id": "astroid/decorators.py::cached", "file_path": "astroid/decorators.py", "class_name": null, "func_name": "cached", "text": "文件路径: astroid/decorators.py\ndef cached(func, instance, args, kwargs):\n    \"\"\"Simple decorator to cache result of method calls without args.\"\"\"\n    cache = getattr(instance, \"__cache\", None)\n    if cache is None:\n        instance.__cache = cache = {}\n    try:\n        return cache[func]\n    except KeyError:\n        cache[func] = result = func(*args, **kwargs)\n        return result\n", "tokens": ["astroid", "decorators", "py", "def", "cached", "func", "instance", "args", "kwargs", "simple", "decorator", "to", "cache", "result", "of", "method", "calls", "without", "args", "cache", "getattr", "instance", "__cache", "none", "if", "cache", "is", "none", "instance", "__cache", "cache", "try", "return", "cache", "func", "except", "keyerror", "cache", "func", "result", "func", "args", "kwargs", "return", "result"], "doc_len": 45}
{"doc_id": "astroid/decorators.py::cachedproperty.__init__", "file_path": "astroid/decorators.py", "class_name": "cachedproperty", "func_name": "__init__", "text": "文件路径: astroid/decorators.py, 类名: cachedproperty\n    def __init__(self, wrapped):\n        try:\n            wrapped.__name__\n        except AttributeError as exc:\n            raise TypeError(f\"{wrapped} must have a __name__ attribute\") from exc\n        self.wrapped = wrapped\n", "tokens": ["astroid", "decorators", "py", "cachedproperty", "def", "__init__", "self", "wrapped", "try", "wrapped", "__name__", "except", "attributeerror", "as", "exc", "raise", "typeerror", "f", "wrapped", "must", "have", "a", "__name__", "attribute", "from", "exc", "self", "wrapped", "wrapped"], "doc_len": 29}
{"doc_id": "astroid/decorators.py::cachedproperty.__doc__", "file_path": "astroid/decorators.py", "class_name": "cachedproperty", "func_name": "__doc__", "text": "文件路径: astroid/decorators.py, 类名: cachedproperty\n    def __doc__(self):\n        doc = getattr(self.wrapped, \"__doc__\", None)\n        return \"<wrapped by the cachedproperty decorator>%s\" % (\n            \"\\n%s\" % doc if doc else \"\"\n        )\n", "tokens": ["astroid", "decorators", "py", "cachedproperty", "def", "__doc__", "self", "doc", "getattr", "self", "wrapped", "__doc__", "none", "return", "wrapped", "by", "the", "cachedproperty", "decorator", "s", "n", "s", "doc", "if", "doc", "else"], "doc_len": 26}
{"doc_id": "astroid/decorators.py::cachedproperty.__get__", "file_path": "astroid/decorators.py", "class_name": "cachedproperty", "func_name": "__get__", "text": "文件路径: astroid/decorators.py, 类名: cachedproperty\n    def __get__(self, inst, objtype=None):\n        if inst is None:\n            return self\n        val = self.wrapped(inst)\n        setattr(inst, self.wrapped.__name__, val)\n        return val\n", "tokens": ["astroid", "decorators", "py", "cachedproperty", "def", "__get__", "self", "inst", "objtype", "none", "if", "inst", "is", "none", "return", "self", "val", "self", "wrapped", "inst", "setattr", "inst", "self", "wrapped", "__name__", "val", "return", "val"], "doc_len": 28}
{"doc_id": "astroid/decorators.py::path_wrapper", "file_path": "astroid/decorators.py", "class_name": null, "func_name": "path_wrapper", "text": "文件路径: astroid/decorators.py\ndef path_wrapper(func):\n    \"\"\"return the given infer function wrapped to handle the path\n\n    Used to stop inference if the node has already been looked\n    at for a given `InferenceContext` to prevent infinite recursion\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapped(node, context=None, _func=func, **kwargs):\n        \"\"\"wrapper function handling context\"\"\"\n        if context is None:\n            context = InferenceContext()\n        if context.push(node):\n            return\n\n        yielded = set()\n\n        for res in _func(node, context, **kwargs):\n            # unproxy only true instance, not const, tuple, dict...\n            if res.__class__.__name__ == \"Instance\":\n                ares = res._proxied\n            else:\n                ares = res\n            if ares not in yielded:\n                yield res\n                yielded.add(ares)\n\n    return wrapped\n", "tokens": ["astroid", "decorators", "py", "def", "path_wrapper", "func", "return", "the", "given", "infer", "function", "wrapped", "to", "handle", "the", "path", "used", "to", "stop", "inference", "if", "the", "node", "has", "already", "been", "looked", "at", "for", "a", "given", "inferencecontext", "to", "prevent", "infinite", "recursion", "functools", "wraps", "func", "def", "wrapped", "node", "context", "none", "_func", "func", "kwargs", "wrapper", "function", "handling", "context", "if", "context", "is", "none", "context", "inferencecontext", "if", "context", "push", "node", "return", "yielded", "set", "for", "res", "in", "_func", "node", "context", "kwargs", "unproxy", "only", "true", "instance", "not", "const", "tuple", "dict", "if", "res", "__class__", "__name__", "instance", "ares", "res", "_proxied", "else", "ares", "res", "if", "ares", "not", "in", "yielded", "yield", "res", "yielded", "add", "ares", "return", "wrapped"], "doc_len": 102}
{"doc_id": "astroid/decorators.py::yes_if_nothing_inferred", "file_path": "astroid/decorators.py", "class_name": null, "func_name": "yes_if_nothing_inferred", "text": "文件路径: astroid/decorators.py\ndef yes_if_nothing_inferred(func, instance, args, kwargs):\n    generator = func(*args, **kwargs)\n\n    try:\n        yield next(generator)\n    except StopIteration:\n        # generator is empty\n        yield util.Uninferable\n        return\n\n    yield from generator\n", "tokens": ["astroid", "decorators", "py", "def", "yes_if_nothing_inferred", "func", "instance", "args", "kwargs", "generator", "func", "args", "kwargs", "try", "yield", "next", "generator", "except", "stopiteration", "generator", "is", "empty", "yield", "util", "uninferable", "return", "yield", "from", "generator"], "doc_len": 29}
{"doc_id": "astroid/decorators.py::raise_if_nothing_inferred", "file_path": "astroid/decorators.py", "class_name": null, "func_name": "raise_if_nothing_inferred", "text": "文件路径: astroid/decorators.py\ndef raise_if_nothing_inferred(func, instance, args, kwargs):\n    generator = func(*args, **kwargs)\n    try:\n        yield next(generator)\n    except StopIteration as error:\n        # generator is empty\n        if error.args:\n            # pylint: disable=not-a-mapping\n            raise InferenceError(**error.args[0]) from error\n        raise InferenceError(\n            \"StopIteration raised without any error information.\"\n        ) from error\n\n    yield from generator\n", "tokens": ["astroid", "decorators", "py", "def", "raise_if_nothing_inferred", "func", "instance", "args", "kwargs", "generator", "func", "args", "kwargs", "try", "yield", "next", "generator", "except", "stopiteration", "as", "error", "generator", "is", "empty", "if", "error", "args", "pylint", "disable", "not", "a", "mapping", "raise", "inferenceerror", "error", "args", "0", "from", "error", "raise", "inferenceerror", "stopiteration", "raised", "without", "any", "error", "information", "from", "error", "yield", "from", "generator"], "doc_len": 52}
{"doc_id": "astroid/decorators.py::deprecate_default_argument_values", "file_path": "astroid/decorators.py", "class_name": null, "func_name": "deprecate_default_argument_values", "text": "文件路径: astroid/decorators.py\ndef deprecate_default_argument_values(\n    astroid_version: str = \"3.0\", **arguments: str\n) -> Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Decorator which emitts a DeprecationWarning if any arguments specified\n    are None or not passed at all.\n\n    Arguments should be a key-value mapping, with the key being the argument to check\n    and the value being a type annotation as string for the value of the argument.\n    \"\"\"\n    # Helpful links\n    # Decorator for DeprecationWarning: https://stackoverflow.com/a/49802489\n    # Typing of stacked decorators: https://stackoverflow.com/a/68290080\n\n    def deco(func: Callable[P, R]) -> Callable[P, R]:\n        \"\"\"Decorator function.\"\"\"\n\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n            \"\"\"Emit DeprecationWarnings if conditions are met.\"\"\"\n\n            keys = list(inspect.signature(func).parameters.keys())\n            for arg, type_annotation in arguments.items():\n                try:\n                    index = keys.index(arg)\n                except ValueError:\n                    raise Exception(\n                        f\"Can't find argument '{arg}' for '{args[0].__class__.__qualname__}'\"\n                    ) from None\n                if (\n                    # Check kwargs\n                    # - if found, check it's not None\n                    (arg in kwargs and kwargs[arg] is None)\n                    # Check args\n                    # - make sure not in kwargs\n                    # - len(args) needs to be long enough, if too short\n                    #   arg can't be in args either\n                    # - args[index] should not be None\n                    or arg not in kwargs\n                    and (\n                        index == -1\n                        or len(args) <= index\n                        or (len(args) > index and args[index] is None)\n                    )\n                ):\n                    warnings.warn(\n                        f\"'{arg}' will be a required argument for \"\n                        f\"'{args[0].__class__.__qualname__}.{func.__name__}' in astroid {astroid_version} \"\n                        f\"('{arg}' should be of type: '{type_annotation}')\",\n                        DeprecationWarning,\n                    )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return deco\n", "tokens": ["astroid", "decorators", "py", "def", "deprecate_default_argument_values", "astroid_version", "str", "3", "0", "arguments", "str", "callable", "callable", "p", "r", "callable", "p", "r", "decorator", "which", "emitts", "a", "deprecationwarning", "if", "any", "arguments", "specified", "are", "none", "or", "not", "passed", "at", "all", "arguments", "should", "be", "a", "key", "value", "mapping", "with", "the", "key", "being", "the", "argument", "to", "check", "and", "the", "value", "being", "a", "type", "annotation", "as", "string", "for", "the", "value", "of", "the", "argument", "helpful", "links", "decorator", "for", "deprecationwarning", "https", "stackoverflow", "com", "a", "49802489", "typing", "of", "stacked", "decorators", "https", "stackoverflow", "com", "a", "68290080", "def", "deco", "func", "callable", "p", "r", "callable", "p", "r", "decorator", "function", "functools", "wraps", "func", "def", "wrapper", "args", "p", "args", "kwargs", "p", "kwargs", "r", "emit", "deprecationwarnings", "if", "conditions", "are", "met", "keys", "list", "inspect", "signature", "func", "parameters", "keys", "for", "arg", "type_annotation", "in", "arguments", "items", "try", "index", "keys", "index", "arg", "except", "valueerror", "raise", "exception", "f", "can", "t", "find", "argument", "arg", "for", "args", "0", "__class__", "__qualname__", "from", "none", "if", "check", "kwargs", "if", "found", "check", "it", "s", "not", "none", "arg", "in", "kwargs", "and", "kwargs", "arg", "is", "none", "check", "args", "make", "sure", "not", "in", "kwargs", "len", "args", "needs", "to", "be", "long", "enough", "if", "too", "short", "arg", "can", "t", "be", "in", "args", "either", "args", "index", "should", "not", "be", "none", "or", "arg", "not", "in", "kwargs", "and", "index", "1", "or", "len", "args", "index", "or", "len", "args", "index", "and", "args", "index", "is", "none", "warnings", "warn", "f", "arg", "will", "be", "a", "required", "argument", "for", "f", "args", "0", "__class__", "__qualname__", "func", "__name__", "in", "astroid", "astroid_version", "f", "arg", "should", "be", "of", "type", "type_annotation", "deprecationwarning", "return", "func", "args", "kwargs", "return", "wrapper", "return", "deco"], "doc_len": 252}
{"doc_id": "astroid/exceptions.py::AstroidError.__init__", "file_path": "astroid/exceptions.py", "class_name": "AstroidError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: AstroidError\n    def __init__(self, message=\"\", **kws):\n        super().__init__(message)\n        self.message = message\n        for key, value in kws.items():\n            setattr(self, key, value)\n", "tokens": ["astroid", "exceptions", "py", "astroiderror", "def", "__init__", "self", "message", "kws", "super", "__init__", "message", "self", "message", "message", "for", "key", "value", "in", "kws", "items", "setattr", "self", "key", "value"], "doc_len": 25}
{"doc_id": "astroid/exceptions.py::AstroidError.__str__", "file_path": "astroid/exceptions.py", "class_name": "AstroidError", "func_name": "__str__", "text": "文件路径: astroid/exceptions.py, 类名: AstroidError\n    def __str__(self):\n        return self.message.format(**vars(self))\n", "tokens": ["astroid", "exceptions", "py", "astroiderror", "def", "__str__", "self", "return", "self", "message", "format", "vars", "self"], "doc_len": 13}
{"doc_id": "astroid/exceptions.py::AstroidBuildingError.__init__", "file_path": "astroid/exceptions.py", "class_name": "AstroidBuildingError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: AstroidBuildingError\n    def __init__(self, message=\"Failed to import module {modname}.\", **kws):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "astroidbuildingerror", "def", "__init__", "self", "message", "failed", "to", "import", "module", "modname", "kws", "super", "__init__", "message", "kws"], "doc_len": 18}
{"doc_id": "astroid/exceptions.py::TooManyLevelsError.__init__", "file_path": "astroid/exceptions.py", "class_name": "TooManyLevelsError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: TooManyLevelsError\n    def __init__(\n        self,\n        message=\"Relative import with too many levels \" \"({level}) for module {name!r}\",\n        **kws,\n    ):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "toomanylevelserror", "def", "__init__", "self", "message", "relative", "import", "with", "too", "many", "levels", "level", "for", "module", "name", "r", "kws", "super", "__init__", "message", "kws"], "doc_len": 24}
{"doc_id": "astroid/exceptions.py::NoDefault.__init__", "file_path": "astroid/exceptions.py", "class_name": "NoDefault", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: NoDefault\n    def __init__(self, message=\"{func!r} has no default for {name!r}.\", **kws):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "nodefault", "def", "__init__", "self", "message", "func", "r", "has", "no", "default", "for", "name", "r", "kws", "super", "__init__", "message", "kws"], "doc_len": 21}
{"doc_id": "astroid/exceptions.py::MroError.__str__", "file_path": "astroid/exceptions.py", "class_name": "MroError", "func_name": "__str__", "text": "文件路径: astroid/exceptions.py, 类名: MroError\n    def __str__(self):\n        mro_names = \", \".join(f\"({', '.join(b.name for b in m)})\" for m in self.mros)\n        return self.message.format(mros=mro_names, cls=self.cls)\n", "tokens": ["astroid", "exceptions", "py", "mroerror", "def", "__str__", "self", "mro_names", "join", "f", "join", "b", "name", "for", "b", "in", "m", "for", "m", "in", "self", "mros", "return", "self", "message", "format", "mros", "mro_names", "cls", "self", "cls"], "doc_len": 31}
{"doc_id": "astroid/exceptions.py::SuperError.__str__", "file_path": "astroid/exceptions.py", "class_name": "SuperError", "func_name": "__str__", "text": "文件路径: astroid/exceptions.py, 类名: SuperError\n    def __str__(self):\n        return self.message.format(**vars(self.super_))\n", "tokens": ["astroid", "exceptions", "py", "supererror", "def", "__str__", "self", "return", "self", "message", "format", "vars", "self", "super_"], "doc_len": 14}
{"doc_id": "astroid/exceptions.py::InferenceError.__init__", "file_path": "astroid/exceptions.py", "class_name": "InferenceError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: InferenceError\n    def __init__(self, message=\"Inference failed for {node!r}.\", **kws):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "inferenceerror", "def", "__init__", "self", "message", "inference", "failed", "for", "node", "r", "kws", "super", "__init__", "message", "kws"], "doc_len": 18}
{"doc_id": "astroid/exceptions.py::NameInferenceError.__init__", "file_path": "astroid/exceptions.py", "class_name": "NameInferenceError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: NameInferenceError\n    def __init__(self, message=\"{name!r} not found in {scope!r}.\", **kws):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "nameinferenceerror", "def", "__init__", "self", "message", "name", "r", "not", "found", "in", "scope", "r", "kws", "super", "__init__", "message", "kws"], "doc_len": 20}
{"doc_id": "astroid/exceptions.py::AttributeInferenceError.__init__", "file_path": "astroid/exceptions.py", "class_name": "AttributeInferenceError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: AttributeInferenceError\n    def __init__(self, message=\"{attribute!r} not found on {target!r}.\", **kws):\n        super().__init__(message, **kws)\n", "tokens": ["astroid", "exceptions", "py", "attributeinferenceerror", "def", "__init__", "self", "message", "attribute", "r", "not", "found", "on", "target", "r", "kws", "super", "__init__", "message", "kws"], "doc_len": 20}
{"doc_id": "astroid/exceptions.py::ParentMissingError.__init__", "file_path": "astroid/exceptions.py", "class_name": "ParentMissingError", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: ParentMissingError\n    def __init__(self, target: \"nodes.NodeNG\") -> None:\n        self.target = target\n        super().__init__(message=f\"Parent not found on {target!r}.\")\n", "tokens": ["astroid", "exceptions", "py", "parentmissingerror", "def", "__init__", "self", "target", "nodes", "nodeng", "none", "self", "target", "target", "super", "__init__", "message", "f", "parent", "not", "found", "on", "target", "r"], "doc_len": 24}
{"doc_id": "astroid/exceptions.py::StatementMissing.__init__", "file_path": "astroid/exceptions.py", "class_name": "StatementMissing", "func_name": "__init__", "text": "文件路径: astroid/exceptions.py, 类名: StatementMissing\n    def __init__(self, target: \"nodes.NodeNG\") -> None:\n        # pylint: disable-next=bad-super-call\n        # https://github.com/PyCQA/pylint/issues/2903\n        # https://github.com/PyCQA/astroid/pull/1217#discussion_r744149027\n        super(ParentMissingError, self).__init__(\n            message=f\"Statement not found on {target!r}\"\n        )\n", "tokens": ["astroid", "exceptions", "py", "statementmissing", "def", "__init__", "self", "target", "nodes", "nodeng", "none", "pylint", "disable", "next", "bad", "super", "call", "https", "github", "com", "pycqa", "pylint", "issues", "2903", "https", "github", "com", "pycqa", "astroid", "pull", "1217", "discussion_r744149027", "super", "parentmissingerror", "self", "__init__", "message", "f", "statement", "not", "found", "on", "target", "r"], "doc_len": 44}
{"doc_id": "astroid/filter_statements.py::_get_filtered_node_statements", "file_path": "astroid/filter_statements.py", "class_name": null, "func_name": "_get_filtered_node_statements", "text": "文件路径: astroid/filter_statements.py\ndef _get_filtered_node_statements(\n    base_node: nodes.NodeNG, stmt_nodes: List[nodes.NodeNG]\n) -> List[Tuple[nodes.NodeNG, nodes.Statement]]:\n    statements = [(node, node.statement(future=True)) for node in stmt_nodes]\n    # Next we check if we have ExceptHandlers that are parent\n    # of the underlying variable, in which case the last one survives\n    if len(statements) > 1 and all(\n        isinstance(stmt, nodes.ExceptHandler) for _, stmt in statements\n    ):\n        statements = [\n            (node, stmt) for node, stmt in statements if stmt.parent_of(base_node)\n        ]\n    return statements\n", "tokens": ["astroid", "filter_statements", "py", "def", "_get_filtered_node_statements", "base_node", "nodes", "nodeng", "stmt_nodes", "list", "nodes", "nodeng", "list", "tuple", "nodes", "nodeng", "nodes", "statement", "statements", "node", "node", "statement", "future", "true", "for", "node", "in", "stmt_nodes", "next", "we", "check", "if", "we", "have", "excepthandlers", "that", "are", "parent", "of", "the", "underlying", "variable", "in", "which", "case", "the", "last", "one", "survives", "if", "len", "statements", "1", "and", "all", "isinstance", "stmt", "nodes", "excepthandler", "for", "_", "stmt", "in", "statements", "statements", "node", "stmt", "for", "node", "stmt", "in", "statements", "if", "stmt", "parent_of", "base_node", "return", "statements"], "doc_len": 78}
{"doc_id": "astroid/filter_statements.py::_is_from_decorator", "file_path": "astroid/filter_statements.py", "class_name": null, "func_name": "_is_from_decorator", "text": "文件路径: astroid/filter_statements.py\ndef _is_from_decorator(node):\n    \"\"\"Return True if the given node is the child of a decorator\"\"\"\n    return any(isinstance(parent, nodes.Decorators) for parent in node.node_ancestors())\n", "tokens": ["astroid", "filter_statements", "py", "def", "_is_from_decorator", "node", "return", "true", "if", "the", "given", "node", "is", "the", "child", "of", "a", "decorator", "return", "any", "isinstance", "parent", "nodes", "decorators", "for", "parent", "in", "node", "node_ancestors"], "doc_len": 29}
{"doc_id": "astroid/filter_statements.py::_get_if_statement_ancestor", "file_path": "astroid/filter_statements.py", "class_name": null, "func_name": "_get_if_statement_ancestor", "text": "文件路径: astroid/filter_statements.py\ndef _get_if_statement_ancestor(node: nodes.NodeNG) -> Optional[nodes.If]:\n    \"\"\"Return the first parent node that is an If node (or None)\"\"\"\n    for parent in node.node_ancestors():\n        if isinstance(parent, nodes.If):\n            return parent\n    return None\n", "tokens": ["astroid", "filter_statements", "py", "def", "_get_if_statement_ancestor", "node", "nodes", "nodeng", "optional", "nodes", "if", "return", "the", "first", "parent", "node", "that", "is", "an", "if", "node", "or", "none", "for", "parent", "in", "node", "node_ancestors", "if", "isinstance", "parent", "nodes", "if", "return", "parent", "return", "none"], "doc_len": 37}
{"doc_id": "astroid/filter_statements.py::_filter_stmts", "file_path": "astroid/filter_statements.py", "class_name": null, "func_name": "_filter_stmts", "text": "文件路径: astroid/filter_statements.py\ndef _filter_stmts(base_node: nodes.NodeNG, stmts, frame, offset):\n    \"\"\"Filter the given list of statements to remove ignorable statements.\n\n    If base_node is not a frame itself and the name is found in the inner\n    frame locals, statements will be filtered to remove ignorable\n    statements according to base_node's location.\n\n    :param stmts: The statements to filter.\n    :type stmts: list(nodes.NodeNG)\n\n    :param frame: The frame that all of the given statements belong to.\n    :type frame: nodes.NodeNG\n\n    :param offset: The line offset to filter statements up to.\n    :type offset: int\n\n    :returns: The filtered statements.\n    :rtype: list(nodes.NodeNG)\n    \"\"\"\n    # if offset == -1, my actual frame is not the inner frame but its parent\n    #\n    # class A(B): pass\n    #\n    # we need this to resolve B correctly\n    if offset == -1:\n        myframe = base_node.frame().parent.frame()\n    else:\n        myframe = base_node.frame()\n        # If the frame of this node is the same as the statement\n        # of this node, then the node is part of a class or\n        # a function definition and the frame of this node should be the\n        # the upper frame, not the frame of the definition.\n        # For more information why this is important,\n        # see Pylint issue #295.\n        # For example, for 'b', the statement is the same\n        # as the frame / scope:\n        #\n        # def test(b=1):\n        #     ...\n        if (\n            base_node.parent\n            and base_node.statement(future=True) is myframe\n            and myframe.parent\n        ):\n            myframe = myframe.parent.frame()\n\n    mystmt: Optional[nodes.Statement] = None\n    if base_node.parent:\n        mystmt = base_node.statement(future=True)\n\n    # line filtering if we are in the same frame\n    #\n    # take care node may be missing lineno information (this is the case for\n    # nodes inserted for living objects)\n    if myframe is frame and mystmt and mystmt.fromlineno is not None:\n        assert mystmt.fromlineno is not None, mystmt\n        mylineno = mystmt.fromlineno + offset\n    else:\n        # disabling lineno filtering\n        mylineno = 0\n\n    _stmts = []\n    _stmt_parents = []\n    statements = _get_filtered_node_statements(base_node, stmts)\n    for node, stmt in statements:\n        # line filtering is on and we have reached our location, break\n        if stmt.fromlineno and stmt.fromlineno > mylineno > 0:\n            break\n        # Ignore decorators with the same name as the\n        # decorated function\n        # Fixes issue #375\n        if mystmt is stmt and _is_from_decorator(base_node):\n            continue\n        assert hasattr(node, \"assign_type\"), (\n            node,\n            node.scope(),\n            node.scope().locals,\n        )\n        assign_type = node.assign_type()\n        if node.has_base(base_node):\n            break\n\n        _stmts, done = assign_type._get_filtered_stmts(base_node, node, _stmts, mystmt)\n        if done:\n            break\n\n        optional_assign = assign_type.optional_assign\n        if optional_assign and assign_type.parent_of(base_node):\n            # we are inside a loop, loop var assignment is hiding previous\n            # assignment\n            _stmts = [node]\n            _stmt_parents = [stmt.parent]\n            continue\n\n        if isinstance(assign_type, nodes.NamedExpr):\n            # If the NamedExpr is in an if statement we do some basic control flow inference\n            if_parent = _get_if_statement_ancestor(assign_type)\n            if if_parent:\n                # If the if statement is within another if statement we append the node\n                # to possible statements\n                if _get_if_statement_ancestor(if_parent):\n                    optional_assign = False\n                    _stmts.append(node)\n                    _stmt_parents.append(stmt.parent)\n                # If the if statement is first-level and not within an orelse block\n                # we know that it will be evaluated\n                elif not if_parent.is_orelse:\n                    _stmts = [node]\n                    _stmt_parents = [stmt.parent]\n                # Else we do not known enough about the control flow to be 100% certain\n                # and we append to possible statements\n                else:\n                    _stmts.append(node)\n                    _stmt_parents.append(stmt.parent)\n            else:\n                _stmts = [node]\n                _stmt_parents = [stmt.parent]\n\n        # XXX comment various branches below!!!\n        try:\n            pindex = _stmt_parents.index(stmt.parent)\n        except ValueError:\n            pass\n        else:\n            # we got a parent index, this means the currently visited node\n            # is at the same block level as a previously visited node\n            if _stmts[pindex].assign_type().parent_of(assign_type):\n                # both statements are not at the same block level\n                continue\n            # if currently visited node is following previously considered\n            # assignment and both are not exclusive, we can drop the\n            # previous one. For instance in the following code ::\n            #\n            #   if a:\n            #     x = 1\n            #   else:\n            #     x = 2\n            #   print x\n            #\n            # we can't remove neither x = 1 nor x = 2 when looking for 'x'\n            # of 'print x'; while in the following ::\n            #\n            #   x = 1\n            #   x = 2\n            #   print x\n            #\n            # we can remove x = 1 when we see x = 2\n            #\n            # moreover, on loop assignment types, assignment won't\n            # necessarily be done if the loop has no iteration, so we don't\n            # want to clear previous assignments if any (hence the test on\n            # optional_assign)\n            if not (optional_assign or nodes.are_exclusive(_stmts[pindex], node)):\n                del _stmt_parents[pindex]\n                del _stmts[pindex]\n\n        # If base_node and node are exclusive, then we can ignore node\n        if nodes.are_exclusive(base_node, node):\n            continue\n\n        # An AssignName node overrides previous assignments if:\n        #   1. node's statement always assigns\n        #   2. node and base_node are in the same block (i.e., has the same parent as base_node)\n        if isinstance(node, (nodes.NamedExpr, nodes.AssignName)):\n            if isinstance(stmt, nodes.ExceptHandler):\n                # If node's statement is an ExceptHandler, then it is the variable\n                # bound to the caught exception. If base_node is not contained within\n                # the exception handler block, node should override previous assignments;\n                # otherwise, node should be ignored, as an exception variable\n                # is local to the handler block.\n                if stmt.parent_of(base_node):\n                    _stmts = []\n                    _stmt_parents = []\n                else:\n                    continue\n            elif not optional_assign and mystmt and stmt.parent is mystmt.parent:\n                _stmts = []\n                _stmt_parents = []\n        elif isinstance(node, nodes.DelName):\n            # Remove all previously stored assignments\n            _stmts = []\n            _stmt_parents = []\n            continue\n        # Add the new assignment\n        _stmts.append(node)\n        if isinstance(node, nodes.Arguments) or isinstance(\n            node.parent, nodes.Arguments\n        ):\n            # Special case for _stmt_parents when node is a function parameter;\n            # in this case, stmt is the enclosing FunctionDef, which is what we\n            # want to add to _stmt_parents, not stmt.parent. This case occurs when\n            # node is an Arguments node (representing varargs or kwargs parameter),\n            # and when node.parent is an Arguments node (other parameters).\n            # See issue #180.\n            _stmt_parents.append(stmt)\n        else:\n            _stmt_parents.append(stmt.parent)\n    return _stmts\n", "tokens": ["astroid", "filter_statements", "py", "def", "_filter_stmts", "base_node", "nodes", "nodeng", "stmts", "frame", "offset", "filter", "the", "given", "list", "of", "statements", "to", "remove", "ignorable", "statements", "if", "base_node", "is", "not", "a", "frame", "itself", "and", "the", "name", "is", "found", "in", "the", "inner", "frame", "locals", "statements", "will", "be", "filtered", "to", "remove", "ignorable", "statements", "according", "to", "base_node", "s", "location", "param", "stmts", "the", "statements", "to", "filter", "type", "stmts", "list", "nodes", "nodeng", "param", "frame", "the", "frame", "that", "all", "of", "the", "given", "statements", "belong", "to", "type", "frame", "nodes", "nodeng", "param", "offset", "the", "line", "offset", "to", "filter", "statements", "up", "to", "type", "offset", "int", "returns", "the", "filtered", "statements", "rtype", "list", "nodes", "nodeng", "if", "offset", "1", "my", "actual", "frame", "is", "not", "the", "inner", "frame", "but", "its", "parent", "class", "a", "b", "pass", "we", "need", "this", "to", "resolve", "b", "correctly", "if", "offset", "1", "myframe", "base_node", "frame", "parent", "frame", "else", "myframe", "base_node", "frame", "if", "the", "frame", "of", "this", "node", "is", "the", "same", "as", "the", "statement", "of", "this", "node", "then", "the", "node", "is", "part", "of", "a", "class", "or", "a", "function", "definition", "and", "the", "frame", "of", "this", "node", "should", "be", "the", "the", "upper", "frame", "not", "the", "frame", "of", "the", "definition", "for", "more", "information", "why", "this", "is", "important", "see", "pylint", "issue", "295", "for", "example", "for", "b", "the", "statement", "is", "the", "same", "as", "the", "frame", "scope", "def", "test", "b", "1", "if", "base_node", "parent", "and", "base_node", "statement", "future", "true", "is", "myframe", "and", "myframe", "parent", "myframe", "myframe", "parent", "frame", "mystmt", "optional", "nodes", "statement", "none", "if", "base_node", "parent", "mystmt", "base_node", "statement", "future", "true", "line", "filtering", "if", "we", "are", "in", "the", "same", "frame", "take", "care", "node", "may", "be", "missing", "lineno", "information", "this", "is", "the", "case", "for", "nodes", "inserted", "for", "living", "objects", "if", "myframe", "is", "frame", "and", "mystmt", "and", "mystmt", "fromlineno", "is", "not", "none", "assert", "mystmt", "fromlineno", "is", "not", "none", "mystmt", "mylineno", "mystmt", "fromlineno", "offset", "else", "disabling", "lineno", "filtering", "mylineno", "0", "_stmts", "_stmt_parents", "statements", "_get_filtered_node_statements", "base_node", "stmts", "for", "node", "stmt", "in", "statements", "line", "filtering", "is", "on", "and", "we", "have", "reached", "our", "location", "break", "if", "stmt", "fromlineno", "and", "stmt", "fromlineno", "mylineno", "0", "break", "ignore", "decorators", "with", "the", "same", "name", "as", "the", "decorated", "function", "fixes", "issue", "375", "if", "mystmt", "is", "stmt", "and", "_is_from_decorator", "base_node", "continue", "assert", "hasattr", "node", "assign_type", "node", "node", "scope", "node", "scope", "locals", "assign_type", "node", "assign_type", "if", "node", "has_base", "base_node", "break", "_stmts", "done", "assign_type", "_get_filtered_stmts", "base_node", "node", "_stmts", "mystmt", "if", "done", "break", "optional_assign", "assign_type", "optional_assign", "if", "optional_assign", "and", "assign_type", "parent_of", "base_node", "we", "are", "inside", "a", "loop", "loop", "var", "assignment", "is", "hiding", "previous", "assignment", "_stmts", "node", "_stmt_parents", "stmt", "parent", "continue", "if", "isinstance", "assign_type", "nodes", "namedexpr", "if", "the", "namedexpr", "is", "in", "an", "if", "statement", "we", "do", "some", "basic", "control", "flow", "inference", "if_parent", "_get_if_statement_ancestor", "assign_type", "if", "if_parent", "if", "the", "if", "statement", "is", "within", "another", "if", "statement", "we", "append", "the", "node", "to", "possible", "statements", "if", "_get_if_statement_ancestor", "if_parent", "optional_assign", "false", "_stmts", "append", "node", "_stmt_parents", "append", "stmt", "parent", "if", "the", "if", "statement", "is", "first", "level", "and", "not", "within", "an", "orelse", "block", "we", "know", "that", "it", "will", "be", "evaluated", "elif", "not", "if_parent", "is_orelse", "_stmts", "node", "_stmt_parents", "stmt", "parent", "else", "we", "do", "not", "known", "enough", "about", "the", "control", "flow", "to", "be", "100", "certain", "and", "we", "append", "to", "possible", "statements", "else", "_stmts", "append", "node", "_stmt_parents", "append", "stmt", "parent", "else", "_stmts", "node", "_stmt_parents", "stmt", "parent", "xxx", "comment", "various", "branches", "below", "try", "pindex", "_stmt_parents", "index", "stmt", "parent", "except", "valueerror", "pass", "else", "we", "got", "a", "parent", "index", "this", "means", "the", "currently", "visited", "node", "is", "at", "the", "same", "block", "level", "as", "a", "previously", "visited", "node", "if", "_stmts", "pindex", "assign_type", "parent_of", "assign_type", "both", "statements", "are", "not", "at", "the", "same", "block", "level", "continue", "if", "currently", "visited", "node", "is", "following", "previously", "considered", "assignment", "and", "both", "are", "not", "exclusive", "we", "can", "drop", "the", "previous", "one", "for", "instance", "in", "the", "following", "code", "if", "a", "x", "1", "else", "x", "2", "print", "x", "we", "can", "t", "remove", "neither", "x", "1", "nor", "x", "2", "when", "looking", "for", "x", "of", "print", "x", "while", "in", "the", "following", "x", "1", "x", "2", "print", "x", "we", "can", "remove", "x", "1", "when", "we", "see", "x", "2", "moreover", "on", "loop", "assignment", "types", "assignment", "won", "t", "necessarily", "be", "done", "if", "the", "loop", "has", "no", "iteration", "so", "we", "don", "t", "want", "to", "clear", "previous", "assignments", "if", "any", "hence", "the", "test", "on", "optional_assign", "if", "not", "optional_assign", "or", "nodes", "are_exclusive", "_stmts", "pindex", "node", "del", "_stmt_parents", "pindex", "del", "_stmts", "pindex", "if", "base_node", "and", "node", "are", "exclusive", "then", "we", "can", "ignore", "node", "if", "nodes", "are_exclusive", "base_node", "node", "continue", "an", "assignname", "node", "overrides", "previous", "assignments", "if", "1", "node", "s", "statement", "always", "assigns", "2", "node", "and", "base_node", "are", "in", "the", "same", "block", "i", "e", "has", "the", "same", "parent", "as", "base_node", "if", "isinstance", "node", "nodes", "namedexpr", "nodes", "assignname", "if", "isinstance", "stmt", "nodes", "excepthandler", "if", "node", "s", "statement", "is", "an", "excepthandler", "then", "it", "is", "the", "variable", "bound", "to", "the", "caught", "exception", "if", "base_node", "is", "not", "contained", "within", "the", "exception", "handler", "block", "node", "should", "override", "previous", "assignments", "otherwise", "node", "should", "be", "ignored", "as", "an", "exception", "variable", "is", "local", "to", "the", "handler", "block", "if", "stmt", "parent_of", "base_node", "_stmts", "_stmt_parents", "else", "continue", "elif", "not", "optional_assign", "and", "mystmt", "and", "stmt", "parent", "is", "mystmt", "parent", "_stmts", "_stmt_parents", "elif", "isinstance", "node", "nodes", "delname", "remove", "all", "previously", "stored", "assignments", "_stmts", "_stmt_parents", "continue", "add", "the", "new", "assignment", "_stmts", "append", "node", "if", "isinstance", "node", "nodes", "arguments", "or", "isinstance", "node", "parent", "nodes", "arguments", "special", "case", "for", "_stmt_parents", "when", "node", "is", "a", "function", "parameter", "in", "this", "case", "stmt", "is", "the", "enclosing", "functiondef", "which", "is", "what", "we", "want", "to", "add", "to", "_stmt_parents", "not", "stmt", "parent", "this", "case", "occurs", "when", "node", "is", "an", "arguments", "node", "representing", "varargs", "or", "kwargs", "parameter", "and", "when", "node", "parent", "is", "an", "arguments", "node", "other", "parameters", "see", "issue", "180", "_stmt_parents", "append", "stmt", "else", "_stmt_parents", "append", "stmt", "parent", "return", "_stmts"], "doc_len": 917}
{"doc_id": "astroid/helpers.py::_build_proxy_class", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "_build_proxy_class", "text": "文件路径: astroid/helpers.py\ndef _build_proxy_class(cls_name, builtins):\n    proxy = raw_building.build_class(cls_name)\n    proxy.parent = builtins\n    return proxy\n", "tokens": ["astroid", "helpers", "py", "def", "_build_proxy_class", "cls_name", "builtins", "proxy", "raw_building", "build_class", "cls_name", "proxy", "parent", "builtins", "return", "proxy"], "doc_len": 16}
{"doc_id": "astroid/helpers.py::_function_type", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "_function_type", "text": "文件路径: astroid/helpers.py\ndef _function_type(function, builtins):\n    if isinstance(function, scoped_nodes.Lambda):\n        if function.root().name == \"builtins\":\n            cls_name = \"builtin_function_or_method\"\n        else:\n            cls_name = \"function\"\n    elif isinstance(function, bases.BoundMethod):\n        cls_name = \"method\"\n    elif isinstance(function, bases.UnboundMethod):\n        cls_name = \"function\"\n    return _build_proxy_class(cls_name, builtins)\n", "tokens": ["astroid", "helpers", "py", "def", "_function_type", "function", "builtins", "if", "isinstance", "function", "scoped_nodes", "lambda", "if", "function", "root", "name", "builtins", "cls_name", "builtin_function_or_method", "else", "cls_name", "function", "elif", "isinstance", "function", "bases", "boundmethod", "cls_name", "method", "elif", "isinstance", "function", "bases", "unboundmethod", "cls_name", "function", "return", "_build_proxy_class", "cls_name", "builtins"], "doc_len": 40}
{"doc_id": "astroid/helpers.py::_object_type", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "_object_type", "text": "文件路径: astroid/helpers.py\ndef _object_type(node, context=None):\n    astroid_manager = manager.AstroidManager()\n    builtins = astroid_manager.builtins_module\n    context = context or InferenceContext()\n\n    for inferred in node.infer(context=context):\n        if isinstance(inferred, scoped_nodes.ClassDef):\n            if inferred.newstyle:\n                metaclass = inferred.metaclass(context=context)\n                if metaclass:\n                    yield metaclass\n                    continue\n            yield builtins.getattr(\"type\")[0]\n        elif isinstance(inferred, (scoped_nodes.Lambda, bases.UnboundMethod)):\n            yield _function_type(inferred, builtins)\n        elif isinstance(inferred, scoped_nodes.Module):\n            yield _build_proxy_class(\"module\", builtins)\n        else:\n            yield inferred._proxied\n", "tokens": ["astroid", "helpers", "py", "def", "_object_type", "node", "context", "none", "astroid_manager", "manager", "astroidmanager", "builtins", "astroid_manager", "builtins_module", "context", "context", "or", "inferencecontext", "for", "inferred", "in", "node", "infer", "context", "context", "if", "isinstance", "inferred", "scoped_nodes", "classdef", "if", "inferred", "newstyle", "metaclass", "inferred", "metaclass", "context", "context", "if", "metaclass", "yield", "metaclass", "continue", "yield", "builtins", "getattr", "type", "0", "elif", "isinstance", "inferred", "scoped_nodes", "lambda", "bases", "unboundmethod", "yield", "_function_type", "inferred", "builtins", "elif", "isinstance", "inferred", "scoped_nodes", "module", "yield", "_build_proxy_class", "module", "builtins", "else", "yield", "inferred", "_proxied"], "doc_len": 72}
{"doc_id": "astroid/helpers.py::object_type", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "object_type", "text": "文件路径: astroid/helpers.py\ndef object_type(node, context=None):\n    \"\"\"Obtain the type of the given node\n\n    This is used to implement the ``type`` builtin, which means that it's\n    used for inferring type calls, as well as used in a couple of other places\n    in the inference.\n    The node will be inferred first, so this function can support all\n    sorts of objects, as long as they support inference.\n    \"\"\"\n\n    try:\n        types = set(_object_type(node, context))\n    except InferenceError:\n        return util.Uninferable\n    if len(types) > 1 or not types:\n        return util.Uninferable\n    return list(types)[0]\n", "tokens": ["astroid", "helpers", "py", "def", "object_type", "node", "context", "none", "obtain", "the", "type", "of", "the", "given", "node", "this", "is", "used", "to", "implement", "the", "type", "builtin", "which", "means", "that", "it", "s", "used", "for", "inferring", "type", "calls", "as", "well", "as", "used", "in", "a", "couple", "of", "other", "places", "in", "the", "inference", "the", "node", "will", "be", "inferred", "first", "so", "this", "function", "can", "support", "all", "sorts", "of", "objects", "as", "long", "as", "they", "support", "inference", "try", "types", "set", "_object_type", "node", "context", "except", "inferenceerror", "return", "util", "uninferable", "if", "len", "types", "1", "or", "not", "types", "return", "util", "uninferable", "return", "list", "types", "0"], "doc_len": 92}
{"doc_id": "astroid/helpers.py::_object_type_is_subclass", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "_object_type_is_subclass", "text": "文件路径: astroid/helpers.py\ndef _object_type_is_subclass(obj_type, class_or_seq, context=None):\n    if not isinstance(class_or_seq, (tuple, list)):\n        class_seq = (class_or_seq,)\n    else:\n        class_seq = class_or_seq\n\n    if obj_type is util.Uninferable:\n        return util.Uninferable\n\n    # Instances are not types\n    class_seq = [\n        item if not isinstance(item, bases.Instance) else util.Uninferable\n        for item in class_seq\n    ]\n    # strict compatibility with issubclass\n    # issubclass(type, (object, 1)) evaluates to true\n    # issubclass(object, (1, type)) raises TypeError\n    for klass in class_seq:\n        if klass is util.Uninferable:\n            raise AstroidTypeError(\"arg 2 must be a type or tuple of types\")\n\n        for obj_subclass in obj_type.mro():\n            if obj_subclass == klass:\n                return True\n    return False\n", "tokens": ["astroid", "helpers", "py", "def", "_object_type_is_subclass", "obj_type", "class_or_seq", "context", "none", "if", "not", "isinstance", "class_or_seq", "tuple", "list", "class_seq", "class_or_seq", "else", "class_seq", "class_or_seq", "if", "obj_type", "is", "util", "uninferable", "return", "util", "uninferable", "instances", "are", "not", "types", "class_seq", "item", "if", "not", "isinstance", "item", "bases", "instance", "else", "util", "uninferable", "for", "item", "in", "class_seq", "strict", "compatibility", "with", "issubclass", "issubclass", "type", "object", "1", "evaluates", "to", "true", "issubclass", "object", "1", "type", "raises", "typeerror", "for", "klass", "in", "class_seq", "if", "klass", "is", "util", "uninferable", "raise", "astroidtypeerror", "arg", "2", "must", "be", "a", "type", "or", "tuple", "of", "types", "for", "obj_subclass", "in", "obj_type", "mro", "if", "obj_subclass", "klass", "return", "true", "return", "false"], "doc_len": 97}
{"doc_id": "astroid/helpers.py::object_isinstance", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "object_isinstance", "text": "文件路径: astroid/helpers.py\ndef object_isinstance(node, class_or_seq, context=None):\n    \"\"\"Check if a node 'isinstance' any node in class_or_seq\n\n    :param node: A given node\n    :param class_or_seq: Union[nodes.NodeNG, Sequence[nodes.NodeNG]]\n    :rtype: bool\n\n    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n    \"\"\"\n    obj_type = object_type(node, context)\n    if obj_type is util.Uninferable:\n        return util.Uninferable\n    return _object_type_is_subclass(obj_type, class_or_seq, context=context)\n", "tokens": ["astroid", "helpers", "py", "def", "object_isinstance", "node", "class_or_seq", "context", "none", "check", "if", "a", "node", "isinstance", "any", "node", "in", "class_or_seq", "param", "node", "a", "given", "node", "param", "class_or_seq", "union", "nodes", "nodeng", "sequence", "nodes", "nodeng", "rtype", "bool", "raises", "astroidtypeerror", "if", "the", "given", "classes_or_seq", "are", "not", "types", "obj_type", "object_type", "node", "context", "if", "obj_type", "is", "util", "uninferable", "return", "util", "uninferable", "return", "_object_type_is_subclass", "obj_type", "class_or_seq", "context", "context"], "doc_len": 60}
{"doc_id": "astroid/helpers.py::object_issubclass", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "object_issubclass", "text": "文件路径: astroid/helpers.py\ndef object_issubclass(node, class_or_seq, context=None):\n    \"\"\"Check if a type is a subclass of any node in class_or_seq\n\n    :param node: A given node\n    :param class_or_seq: Union[Nodes.NodeNG, Sequence[nodes.NodeNG]]\n    :rtype: bool\n\n    :raises AstroidTypeError: if the given ``classes_or_seq`` are not types\n    :raises AstroidError: if the type of the given node cannot be inferred\n        or its type's mro doesn't work\n    \"\"\"\n    if not isinstance(node, nodes.ClassDef):\n        raise TypeError(f\"{node} needs to be a ClassDef node\")\n    return _object_type_is_subclass(node, class_or_seq, context=context)\n", "tokens": ["astroid", "helpers", "py", "def", "object_issubclass", "node", "class_or_seq", "context", "none", "check", "if", "a", "type", "is", "a", "subclass", "of", "any", "node", "in", "class_or_seq", "param", "node", "a", "given", "node", "param", "class_or_seq", "union", "nodes", "nodeng", "sequence", "nodes", "nodeng", "rtype", "bool", "raises", "astroidtypeerror", "if", "the", "given", "classes_or_seq", "are", "not", "types", "raises", "astroiderror", "if", "the", "type", "of", "the", "given", "node", "cannot", "be", "inferred", "or", "its", "type", "s", "mro", "doesn", "t", "work", "if", "not", "isinstance", "node", "nodes", "classdef", "raise", "typeerror", "f", "node", "needs", "to", "be", "a", "classdef", "node", "return", "_object_type_is_subclass", "node", "class_or_seq", "context", "context"], "doc_len": 87}
{"doc_id": "astroid/helpers.py::safe_infer", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "safe_infer", "text": "文件路径: astroid/helpers.py\ndef safe_infer(node, context=None):\n    \"\"\"Return the inferred value for the given node.\n\n    Return None if inference failed or if there is some ambiguity (more than\n    one node has been inferred).\n    \"\"\"\n    try:\n        inferit = node.infer(context=context)\n        value = next(inferit)\n    except (InferenceError, StopIteration):\n        return None\n    try:\n        next(inferit)\n        return None  # None if there is ambiguity on the inferred node\n    except InferenceError:\n        return None  # there is some kind of ambiguity\n    except StopIteration:\n        return value\n", "tokens": ["astroid", "helpers", "py", "def", "safe_infer", "node", "context", "none", "return", "the", "inferred", "value", "for", "the", "given", "node", "return", "none", "if", "inference", "failed", "or", "if", "there", "is", "some", "ambiguity", "more", "than", "one", "node", "has", "been", "inferred", "try", "inferit", "node", "infer", "context", "context", "value", "next", "inferit", "except", "inferenceerror", "stopiteration", "return", "none", "try", "next", "inferit", "return", "none", "none", "if", "there", "is", "ambiguity", "on", "the", "inferred", "node", "except", "inferenceerror", "return", "none", "there", "is", "some", "kind", "of", "ambiguity", "except", "stopiteration", "return", "value"], "doc_len": 76}
{"doc_id": "astroid/helpers.py::has_known_bases", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "has_known_bases", "text": "文件路径: astroid/helpers.py\ndef has_known_bases(klass, context=None):\n    \"\"\"Return true if all base classes of a class could be inferred.\"\"\"\n    try:\n        return klass._all_bases_known\n    except AttributeError:\n        pass\n    for base in klass.bases:\n        result = safe_infer(base, context=context)\n        # TODO: check for A->B->A->B pattern in class structure too?\n        if (\n            not isinstance(result, scoped_nodes.ClassDef)\n            or result is klass\n            or not has_known_bases(result, context=context)\n        ):\n            klass._all_bases_known = False\n            return False\n    klass._all_bases_known = True\n    return True\n", "tokens": ["astroid", "helpers", "py", "def", "has_known_bases", "klass", "context", "none", "return", "true", "if", "all", "base", "classes", "of", "a", "class", "could", "be", "inferred", "try", "return", "klass", "_all_bases_known", "except", "attributeerror", "pass", "for", "base", "in", "klass", "bases", "result", "safe_infer", "base", "context", "context", "todo", "check", "for", "a", "b", "a", "b", "pattern", "in", "class", "structure", "too", "if", "not", "isinstance", "result", "scoped_nodes", "classdef", "or", "result", "is", "klass", "or", "not", "has_known_bases", "result", "context", "context", "klass", "_all_bases_known", "false", "return", "false", "klass", "_all_bases_known", "true", "return", "true"], "doc_len": 75}
{"doc_id": "astroid/helpers.py::_type_check", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "_type_check", "text": "文件路径: astroid/helpers.py\ndef _type_check(type1, type2):\n    if not all(map(has_known_bases, (type1, type2))):\n        raise _NonDeducibleTypeHierarchy\n\n    if not all([type1.newstyle, type2.newstyle]):\n        return False\n    try:\n        return type1 in type2.mro()[:-1]\n    except MroError as e:\n        # The MRO is invalid.\n        raise _NonDeducibleTypeHierarchy from e\n", "tokens": ["astroid", "helpers", "py", "def", "_type_check", "type1", "type2", "if", "not", "all", "map", "has_known_bases", "type1", "type2", "raise", "_nondeducibletypehierarchy", "if", "not", "all", "type1", "newstyle", "type2", "newstyle", "return", "false", "try", "return", "type1", "in", "type2", "mro", "1", "except", "mroerror", "as", "e", "the", "mro", "is", "invalid", "raise", "_nondeducibletypehierarchy", "from", "e"], "doc_len": 44}
{"doc_id": "astroid/helpers.py::is_subtype", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "is_subtype", "text": "文件路径: astroid/helpers.py\ndef is_subtype(type1, type2):\n    \"\"\"Check if *type1* is a subtype of *type2*.\"\"\"\n    return _type_check(type1=type2, type2=type1)\n", "tokens": ["astroid", "helpers", "py", "def", "is_subtype", "type1", "type2", "check", "if", "type1", "is", "a", "subtype", "of", "type2", "return", "_type_check", "type1", "type2", "type2", "type1"], "doc_len": 21}
{"doc_id": "astroid/helpers.py::is_supertype", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "is_supertype", "text": "文件路径: astroid/helpers.py\ndef is_supertype(type1, type2):\n    \"\"\"Check if *type2* is a supertype of *type1*.\"\"\"\n    return _type_check(type1, type2)\n", "tokens": ["astroid", "helpers", "py", "def", "is_supertype", "type1", "type2", "check", "if", "type2", "is", "a", "supertype", "of", "type1", "return", "_type_check", "type1", "type2"], "doc_len": 19}
{"doc_id": "astroid/helpers.py::class_instance_as_index", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "class_instance_as_index", "text": "文件路径: astroid/helpers.py\ndef class_instance_as_index(node):\n    \"\"\"Get the value as an index for the given instance.\n\n    If an instance provides an __index__ method, then it can\n    be used in some scenarios where an integer is expected,\n    for instance when multiplying or subscripting a list.\n    \"\"\"\n    context = InferenceContext()\n    try:\n        for inferred in node.igetattr(\"__index__\", context=context):\n            if not isinstance(inferred, bases.BoundMethod):\n                continue\n\n            context.boundnode = node\n            context.callcontext = CallContext(args=[], callee=inferred)\n            for result in inferred.infer_call_result(node, context=context):\n                if isinstance(result, nodes.Const) and isinstance(result.value, int):\n                    return result\n    except InferenceError:\n        pass\n    return None\n", "tokens": ["astroid", "helpers", "py", "def", "class_instance_as_index", "node", "get", "the", "value", "as", "an", "index", "for", "the", "given", "instance", "if", "an", "instance", "provides", "an", "__index__", "method", "then", "it", "can", "be", "used", "in", "some", "scenarios", "where", "an", "integer", "is", "expected", "for", "instance", "when", "multiplying", "or", "subscripting", "a", "list", "context", "inferencecontext", "try", "for", "inferred", "in", "node", "igetattr", "__index__", "context", "context", "if", "not", "isinstance", "inferred", "bases", "boundmethod", "continue", "context", "boundnode", "node", "context", "callcontext", "callcontext", "args", "callee", "inferred", "for", "result", "in", "inferred", "infer_call_result", "node", "context", "context", "if", "isinstance", "result", "nodes", "const", "and", "isinstance", "result", "value", "int", "return", "result", "except", "inferenceerror", "pass", "return", "none"], "doc_len": 96}
{"doc_id": "astroid/helpers.py::object_len", "file_path": "astroid/helpers.py", "class_name": null, "func_name": "object_len", "text": "文件路径: astroid/helpers.py\ndef object_len(node, context=None):\n    \"\"\"Infer length of given node object\n\n    :param Union[nodes.ClassDef, nodes.Instance] node:\n    :param node: Node to infer length of\n\n    :raises AstroidTypeError: If an invalid node is returned\n        from __len__ method or no __len__ method exists\n    :raises InferenceError: If the given node cannot be inferred\n        or if multiple nodes are inferred or if the code executed in python\n        would result in a infinite recursive check for length\n    :rtype int: Integer length of node\n    \"\"\"\n    # pylint: disable=import-outside-toplevel; circular import\n    from astroid.objects import FrozenSet\n\n    inferred_node = safe_infer(node, context=context)\n\n    # prevent self referential length calls from causing a recursion error\n    # see https://github.com/PyCQA/astroid/issues/777\n    node_frame = node.frame(future=True)\n    if (\n        isinstance(node_frame, scoped_nodes.FunctionDef)\n        and node_frame.name == \"__len__\"\n        and hasattr(inferred_node, \"_proxied\")\n        and inferred_node._proxied == node_frame.parent\n    ):\n        message = (\n            \"Self referential __len__ function will \"\n            \"cause a RecursionError on line {} of {}\".format(\n                node.lineno, node.root().file\n            )\n        )\n        raise InferenceError(message)\n\n    if inferred_node is None or inferred_node is util.Uninferable:\n        raise InferenceError(node=node)\n    if isinstance(inferred_node, nodes.Const) and isinstance(\n        inferred_node.value, (bytes, str)\n    ):\n        return len(inferred_node.value)\n    if isinstance(inferred_node, (nodes.List, nodes.Set, nodes.Tuple, FrozenSet)):\n        return len(inferred_node.elts)\n    if isinstance(inferred_node, nodes.Dict):\n        return len(inferred_node.items)\n\n    node_type = object_type(inferred_node, context=context)\n    if not node_type:\n        raise InferenceError(node=node)\n\n    try:\n        len_call = next(node_type.igetattr(\"__len__\", context=context))\n    except StopIteration as e:\n        raise AstroidTypeError(str(e)) from e\n    except AttributeInferenceError as e:\n        raise AstroidTypeError(\n            f\"object of type '{node_type.pytype()}' has no len()\"\n        ) from e\n\n    inferred = len_call.infer_call_result(node, context)\n    if inferred is util.Uninferable:\n        raise InferenceError(node=node, context=context)\n    result_of_len = next(inferred, None)\n    if (\n        isinstance(result_of_len, nodes.Const)\n        and result_of_len.pytype() == \"builtins.int\"\n    ):\n        return result_of_len.value\n    if (\n        result_of_len is None\n        or isinstance(result_of_len, bases.Instance)\n        and result_of_len.is_subtype_of(\"builtins.int\")\n    ):\n        # Fake a result as we don't know the arguments of the instance call.\n        return 0\n    raise AstroidTypeError(\n        f\"'{result_of_len}' object cannot be interpreted as an integer\"\n    )\n", "tokens": ["astroid", "helpers", "py", "def", "object_len", "node", "context", "none", "infer", "length", "of", "given", "node", "object", "param", "union", "nodes", "classdef", "nodes", "instance", "node", "param", "node", "node", "to", "infer", "length", "of", "raises", "astroidtypeerror", "if", "an", "invalid", "node", "is", "returned", "from", "__len__", "method", "or", "no", "__len__", "method", "exists", "raises", "inferenceerror", "if", "the", "given", "node", "cannot", "be", "inferred", "or", "if", "multiple", "nodes", "are", "inferred", "or", "if", "the", "code", "executed", "in", "python", "would", "result", "in", "a", "infinite", "recursive", "check", "for", "length", "rtype", "int", "integer", "length", "of", "node", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "objects", "import", "frozenset", "inferred_node", "safe_infer", "node", "context", "context", "prevent", "self", "referential", "length", "calls", "from", "causing", "a", "recursion", "error", "see", "https", "github", "com", "pycqa", "astroid", "issues", "777", "node_frame", "node", "frame", "future", "true", "if", "isinstance", "node_frame", "scoped_nodes", "functiondef", "and", "node_frame", "name", "__len__", "and", "hasattr", "inferred_node", "_proxied", "and", "inferred_node", "_proxied", "node_frame", "parent", "message", "self", "referential", "__len__", "function", "will", "cause", "a", "recursionerror", "on", "line", "of", "format", "node", "lineno", "node", "root", "file", "raise", "inferenceerror", "message", "if", "inferred_node", "is", "none", "or", "inferred_node", "is", "util", "uninferable", "raise", "inferenceerror", "node", "node", "if", "isinstance", "inferred_node", "nodes", "const", "and", "isinstance", "inferred_node", "value", "bytes", "str", "return", "len", "inferred_node", "value", "if", "isinstance", "inferred_node", "nodes", "list", "nodes", "set", "nodes", "tuple", "frozenset", "return", "len", "inferred_node", "elts", "if", "isinstance", "inferred_node", "nodes", "dict", "return", "len", "inferred_node", "items", "node_type", "object_type", "inferred_node", "context", "context", "if", "not", "node_type", "raise", "inferenceerror", "node", "node", "try", "len_call", "next", "node_type", "igetattr", "__len__", "context", "context", "except", "stopiteration", "as", "e", "raise", "astroidtypeerror", "str", "e", "from", "e", "except", "attributeinferenceerror", "as", "e", "raise", "astroidtypeerror", "f", "object", "of", "type", "node_type", "pytype", "has", "no", "len", "from", "e", "inferred", "len_call", "infer_call_result", "node", "context", "if", "inferred", "is", "util", "uninferable", "raise", "inferenceerror", "node", "node", "context", "context", "result_of_len", "next", "inferred", "none", "if", "isinstance", "result_of_len", "nodes", "const", "and", "result_of_len", "pytype", "builtins", "int", "return", "result_of_len", "value", "if", "result_of_len", "is", "none", "or", "isinstance", "result_of_len", "bases", "instance", "and", "result_of_len", "is_subtype_of", "builtins", "int", "fake", "a", "result", "as", "we", "don", "t", "know", "the", "arguments", "of", "the", "instance", "call", "return", "0", "raise", "astroidtypeerror", "f", "result_of_len", "object", "cannot", "be", "interpreted", "as", "an", "integer"], "doc_len": 332}
{"doc_id": "astroid/inference.py::infer_end", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_end", "text": "文件路径: astroid/inference.py\ndef infer_end(self, context=None):\n    \"\"\"Inference's end for nodes that yield themselves on inference\n\n    These are objects for which inference does not have any semantic,\n    such as Module or Consts.\n    \"\"\"\n    yield self\n", "tokens": ["astroid", "inference", "py", "def", "infer_end", "self", "context", "none", "inference", "s", "end", "for", "nodes", "that", "yield", "themselves", "on", "inference", "these", "are", "objects", "for", "which", "inference", "does", "not", "have", "any", "semantic", "such", "as", "module", "or", "consts", "yield", "self"], "doc_len": 36}
{"doc_id": "astroid/inference.py::_infer_sequence_helper", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_sequence_helper", "text": "文件路径: astroid/inference.py\ndef _infer_sequence_helper(node, context=None):\n    \"\"\"Infer all values based on _BaseContainer.elts\"\"\"\n    values = []\n\n    for elt in node.elts:\n        if isinstance(elt, nodes.Starred):\n            starred = helpers.safe_infer(elt.value, context)\n            if not starred:\n                raise InferenceError(node=node, context=context)\n            if not hasattr(starred, \"elts\"):\n                raise InferenceError(node=node, context=context)\n            values.extend(_infer_sequence_helper(starred))\n        elif isinstance(elt, nodes.NamedExpr):\n            value = helpers.safe_infer(elt.value, context)\n            if not value:\n                raise InferenceError(node=node, context=context)\n            values.append(value)\n        else:\n            values.append(elt)\n    return values\n", "tokens": ["astroid", "inference", "py", "def", "_infer_sequence_helper", "node", "context", "none", "infer", "all", "values", "based", "on", "_basecontainer", "elts", "values", "for", "elt", "in", "node", "elts", "if", "isinstance", "elt", "nodes", "starred", "starred", "helpers", "safe_infer", "elt", "value", "context", "if", "not", "starred", "raise", "inferenceerror", "node", "node", "context", "context", "if", "not", "hasattr", "starred", "elts", "raise", "inferenceerror", "node", "node", "context", "context", "values", "extend", "_infer_sequence_helper", "starred", "elif", "isinstance", "elt", "nodes", "namedexpr", "value", "helpers", "safe_infer", "elt", "value", "context", "if", "not", "value", "raise", "inferenceerror", "node", "node", "context", "context", "values", "append", "value", "else", "values", "append", "elt", "return", "values"], "doc_len": 85}
{"doc_id": "astroid/inference.py::infer_sequence", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_sequence", "text": "文件路径: astroid/inference.py\ndef infer_sequence(self, context=None):\n    has_starred_named_expr = any(\n        isinstance(e, (nodes.Starred, nodes.NamedExpr)) for e in self.elts\n    )\n    if has_starred_named_expr:\n        values = _infer_sequence_helper(self, context)\n        new_seq = type(self)(\n            lineno=self.lineno, col_offset=self.col_offset, parent=self.parent\n        )\n        new_seq.postinit(values)\n\n        yield new_seq\n    else:\n        yield self\n", "tokens": ["astroid", "inference", "py", "def", "infer_sequence", "self", "context", "none", "has_starred_named_expr", "any", "isinstance", "e", "nodes", "starred", "nodes", "namedexpr", "for", "e", "in", "self", "elts", "if", "has_starred_named_expr", "values", "_infer_sequence_helper", "self", "context", "new_seq", "type", "self", "lineno", "self", "lineno", "col_offset", "self", "col_offset", "parent", "self", "parent", "new_seq", "postinit", "values", "yield", "new_seq", "else", "yield", "self"], "doc_len": 47}
{"doc_id": "astroid/inference.py::infer_map", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_map", "text": "文件路径: astroid/inference.py\ndef infer_map(self, context=None):\n    if not any(isinstance(k, nodes.DictUnpack) for k, _ in self.items):\n        yield self\n    else:\n        items = _infer_map(self, context)\n        new_seq = type(self)(self.lineno, self.col_offset, self.parent)\n        new_seq.postinit(list(items.items()))\n        yield new_seq\n", "tokens": ["astroid", "inference", "py", "def", "infer_map", "self", "context", "none", "if", "not", "any", "isinstance", "k", "nodes", "dictunpack", "for", "k", "_", "in", "self", "items", "yield", "self", "else", "items", "_infer_map", "self", "context", "new_seq", "type", "self", "self", "lineno", "self", "col_offset", "self", "parent", "new_seq", "postinit", "list", "items", "items", "yield", "new_seq"], "doc_len": 44}
{"doc_id": "astroid/inference.py::_update_with_replacement", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_update_with_replacement", "text": "文件路径: astroid/inference.py\ndef _update_with_replacement(lhs_dict, rhs_dict):\n    \"\"\"Delete nodes that equate to duplicate keys\n\n    Since an astroid node doesn't 'equal' another node with the same value,\n    this function uses the as_string method to make sure duplicate keys\n    don't get through\n\n    Note that both the key and the value are astroid nodes\n\n    Fixes issue with DictUnpack causing duplicte keys\n    in inferred Dict items\n\n    :param dict(nodes.NodeNG, nodes.NodeNG) lhs_dict: Dictionary to 'merge' nodes into\n    :param dict(nodes.NodeNG, nodes.NodeNG) rhs_dict: Dictionary with nodes to pull from\n    :return dict(nodes.NodeNG, nodes.NodeNG): merged dictionary of nodes\n    \"\"\"\n    combined_dict = itertools.chain(lhs_dict.items(), rhs_dict.items())\n    # Overwrite keys which have the same string values\n    string_map = {key.as_string(): (key, value) for key, value in combined_dict}\n    # Return to dictionary\n    return dict(string_map.values())\n", "tokens": ["astroid", "inference", "py", "def", "_update_with_replacement", "lhs_dict", "rhs_dict", "delete", "nodes", "that", "equate", "to", "duplicate", "keys", "since", "an", "astroid", "node", "doesn", "t", "equal", "another", "node", "with", "the", "same", "value", "this", "function", "uses", "the", "as_string", "method", "to", "make", "sure", "duplicate", "keys", "don", "t", "get", "through", "note", "that", "both", "the", "key", "and", "the", "value", "are", "astroid", "nodes", "fixes", "issue", "with", "dictunpack", "causing", "duplicte", "keys", "in", "inferred", "dict", "items", "param", "dict", "nodes", "nodeng", "nodes", "nodeng", "lhs_dict", "dictionary", "to", "merge", "nodes", "into", "param", "dict", "nodes", "nodeng", "nodes", "nodeng", "rhs_dict", "dictionary", "with", "nodes", "to", "pull", "from", "return", "dict", "nodes", "nodeng", "nodes", "nodeng", "merged", "dictionary", "of", "nodes", "combined_dict", "itertools", "chain", "lhs_dict", "items", "rhs_dict", "items", "overwrite", "keys", "which", "have", "the", "same", "string", "values", "string_map", "key", "as_string", "key", "value", "for", "key", "value", "in", "combined_dict", "return", "to", "dictionary", "return", "dict", "string_map", "values"], "doc_len": 131}
{"doc_id": "astroid/inference.py::_infer_map", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_map", "text": "文件路径: astroid/inference.py\ndef _infer_map(node, context):\n    \"\"\"Infer all values based on Dict.items\"\"\"\n    values = {}\n    for name, value in node.items:\n        if isinstance(name, nodes.DictUnpack):\n            double_starred = helpers.safe_infer(value, context)\n            if not double_starred:\n                raise InferenceError\n            if not isinstance(double_starred, nodes.Dict):\n                raise InferenceError(node=node, context=context)\n            unpack_items = _infer_map(double_starred, context)\n            values = _update_with_replacement(values, unpack_items)\n        else:\n            key = helpers.safe_infer(name, context=context)\n            value = helpers.safe_infer(value, context=context)\n            if any(not elem for elem in (key, value)):\n                raise InferenceError(node=node, context=context)\n            values = _update_with_replacement(values, {key: value})\n    return values\n", "tokens": ["astroid", "inference", "py", "def", "_infer_map", "node", "context", "infer", "all", "values", "based", "on", "dict", "items", "values", "for", "name", "value", "in", "node", "items", "if", "isinstance", "name", "nodes", "dictunpack", "double_starred", "helpers", "safe_infer", "value", "context", "if", "not", "double_starred", "raise", "inferenceerror", "if", "not", "isinstance", "double_starred", "nodes", "dict", "raise", "inferenceerror", "node", "node", "context", "context", "unpack_items", "_infer_map", "double_starred", "context", "values", "_update_with_replacement", "values", "unpack_items", "else", "key", "helpers", "safe_infer", "name", "context", "context", "value", "helpers", "safe_infer", "value", "context", "context", "if", "any", "not", "elem", "for", "elem", "in", "key", "value", "raise", "inferenceerror", "node", "node", "context", "context", "values", "_update_with_replacement", "values", "key", "value", "return", "values"], "doc_len": 91}
{"doc_id": "astroid/inference.py::_higher_function_scope", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_higher_function_scope", "text": "文件路径: astroid/inference.py\ndef _higher_function_scope(node):\n    \"\"\"Search for the first function which encloses the given\n    scope. This can be used for looking up in that function's\n    scope, in case looking up in a lower scope for a particular\n    name fails.\n\n    :param node: A scope node.\n    :returns:\n        ``None``, if no parent function scope was found,\n        otherwise an instance of :class:`astroid.nodes.scoped_nodes.Function`,\n        which encloses the given node.\n    \"\"\"\n    current = node\n    while current.parent and not isinstance(current.parent, nodes.FunctionDef):\n        current = current.parent\n    if current and current.parent:\n        return current.parent\n    return None\n", "tokens": ["astroid", "inference", "py", "def", "_higher_function_scope", "node", "search", "for", "the", "first", "function", "which", "encloses", "the", "given", "scope", "this", "can", "be", "used", "for", "looking", "up", "in", "that", "function", "s", "scope", "in", "case", "looking", "up", "in", "a", "lower", "scope", "for", "a", "particular", "name", "fails", "param", "node", "a", "scope", "node", "returns", "none", "if", "no", "parent", "function", "scope", "was", "found", "otherwise", "an", "instance", "of", "class", "astroid", "nodes", "scoped_nodes", "function", "which", "encloses", "the", "given", "node", "current", "node", "while", "current", "parent", "and", "not", "isinstance", "current", "parent", "nodes", "functiondef", "current", "current", "parent", "if", "current", "and", "current", "parent", "return", "current", "parent", "return", "none"], "doc_len": 94}
{"doc_id": "astroid/inference.py::infer_name", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_name", "text": "文件路径: astroid/inference.py\ndef infer_name(self, context=None):\n    \"\"\"infer a Name: use name lookup rules\"\"\"\n    frame, stmts = self.lookup(self.name)\n    if not stmts:\n        # Try to see if the name is enclosed in a nested function\n        # and use the higher (first function) scope for searching.\n        parent_function = _higher_function_scope(self.scope())\n        if parent_function:\n            _, stmts = parent_function.lookup(self.name)\n\n        if not stmts:\n            raise NameInferenceError(\n                name=self.name, scope=self.scope(), context=context\n            )\n    context = copy_context(context)\n    context.lookupname = self.name\n    return bases._infer_stmts(stmts, context, frame)\n", "tokens": ["astroid", "inference", "py", "def", "infer_name", "self", "context", "none", "infer", "a", "name", "use", "name", "lookup", "rules", "frame", "stmts", "self", "lookup", "self", "name", "if", "not", "stmts", "try", "to", "see", "if", "the", "name", "is", "enclosed", "in", "a", "nested", "function", "and", "use", "the", "higher", "first", "function", "scope", "for", "searching", "parent_function", "_higher_function_scope", "self", "scope", "if", "parent_function", "_", "stmts", "parent_function", "lookup", "self", "name", "if", "not", "stmts", "raise", "nameinferenceerror", "name", "self", "name", "scope", "self", "scope", "context", "context", "context", "copy_context", "context", "context", "lookupname", "self", "name", "return", "bases", "_infer_stmts", "stmts", "context", "frame"], "doc_len": 83}
{"doc_id": "astroid/inference.py::infer_call", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_call", "text": "文件路径: astroid/inference.py\ndef infer_call(self, context=None):\n    \"\"\"infer a Call node by trying to guess what the function returns\"\"\"\n    callcontext = copy_context(context)\n    callcontext.boundnode = None\n    if context is not None:\n        callcontext.extra_context = _populate_context_lookup(self, context.clone())\n\n    for callee in self.func.infer(context):\n        if callee is util.Uninferable:\n            yield callee\n            continue\n        try:\n            if hasattr(callee, \"infer_call_result\"):\n                callcontext.callcontext = CallContext(\n                    args=self.args, keywords=self.keywords, callee=callee\n                )\n                yield from callee.infer_call_result(caller=self, context=callcontext)\n        except InferenceError:\n            continue\n    return dict(node=self, context=context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_call", "self", "context", "none", "infer", "a", "call", "node", "by", "trying", "to", "guess", "what", "the", "function", "returns", "callcontext", "copy_context", "context", "callcontext", "boundnode", "none", "if", "context", "is", "not", "none", "callcontext", "extra_context", "_populate_context_lookup", "self", "context", "clone", "for", "callee", "in", "self", "func", "infer", "context", "if", "callee", "is", "util", "uninferable", "yield", "callee", "continue", "try", "if", "hasattr", "callee", "infer_call_result", "callcontext", "callcontext", "callcontext", "args", "self", "args", "keywords", "self", "keywords", "callee", "callee", "yield", "from", "callee", "infer_call_result", "caller", "self", "context", "callcontext", "except", "inferenceerror", "continue", "return", "dict", "node", "self", "context", "context"], "doc_len": 85}
{"doc_id": "astroid/inference.py::infer_import", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_import", "text": "文件路径: astroid/inference.py\ndef infer_import(self, context=None, asname=True):\n    \"\"\"infer an Import node: return the imported module/object\"\"\"\n    name = context.lookupname\n    if name is None:\n        raise InferenceError(node=self, context=context)\n\n    try:\n        if asname:\n            yield self.do_import_module(self.real_name(name))\n        else:\n            yield self.do_import_module(name)\n    except AstroidBuildingError as exc:\n        raise InferenceError(node=self, context=context) from exc\n", "tokens": ["astroid", "inference", "py", "def", "infer_import", "self", "context", "none", "asname", "true", "infer", "an", "import", "node", "return", "the", "imported", "module", "object", "name", "context", "lookupname", "if", "name", "is", "none", "raise", "inferenceerror", "node", "self", "context", "context", "try", "if", "asname", "yield", "self", "do_import_module", "self", "real_name", "name", "else", "yield", "self", "do_import_module", "name", "except", "astroidbuildingerror", "as", "exc", "raise", "inferenceerror", "node", "self", "context", "context", "from", "exc"], "doc_len": 58}
{"doc_id": "astroid/inference.py::infer_import_from", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_import_from", "text": "文件路径: astroid/inference.py\ndef infer_import_from(self, context=None, asname=True):\n    \"\"\"infer a ImportFrom node: return the imported module/object\"\"\"\n    name = context.lookupname\n    if name is None:\n        raise InferenceError(node=self, context=context)\n    if asname:\n        try:\n            name = self.real_name(name)\n        except AttributeInferenceError as exc:\n            # See https://github.com/PyCQA/pylint/issues/4692\n            raise InferenceError(node=self, context=context) from exc\n    try:\n        module = self.do_import_module()\n    except AstroidBuildingError as exc:\n        raise InferenceError(node=self, context=context) from exc\n\n    try:\n        context = copy_context(context)\n        context.lookupname = name\n        stmts = module.getattr(name, ignore_locals=module is self.root())\n        return bases._infer_stmts(stmts, context)\n    except AttributeInferenceError as error:\n        raise InferenceError(\n            str(error), target=self, attribute=name, context=context\n        ) from error\n", "tokens": ["astroid", "inference", "py", "def", "infer_import_from", "self", "context", "none", "asname", "true", "infer", "a", "importfrom", "node", "return", "the", "imported", "module", "object", "name", "context", "lookupname", "if", "name", "is", "none", "raise", "inferenceerror", "node", "self", "context", "context", "if", "asname", "try", "name", "self", "real_name", "name", "except", "attributeinferenceerror", "as", "exc", "see", "https", "github", "com", "pycqa", "pylint", "issues", "4692", "raise", "inferenceerror", "node", "self", "context", "context", "from", "exc", "try", "module", "self", "do_import_module", "except", "astroidbuildingerror", "as", "exc", "raise", "inferenceerror", "node", "self", "context", "context", "from", "exc", "try", "context", "copy_context", "context", "context", "lookupname", "name", "stmts", "module", "getattr", "name", "ignore_locals", "module", "is", "self", "root", "return", "bases", "_infer_stmts", "stmts", "context", "except", "attributeinferenceerror", "as", "error", "raise", "inferenceerror", "str", "error", "target", "self", "attribute", "name", "context", "context", "from", "error"], "doc_len": 112}
{"doc_id": "astroid/inference.py::infer_attribute", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_attribute", "text": "文件路径: astroid/inference.py\ndef infer_attribute(self, context=None):\n    \"\"\"infer an Attribute node by using getattr on the associated object\"\"\"\n    for owner in self.expr.infer(context):\n        if owner is util.Uninferable:\n            yield owner\n            continue\n\n        if not context:\n            context = InferenceContext()\n\n        old_boundnode = context.boundnode\n        try:\n            context.boundnode = owner\n            yield from owner.igetattr(self.attrname, context)\n        except (\n            AttributeInferenceError,\n            InferenceError,\n            AttributeError,\n        ):\n            pass\n        finally:\n            context.boundnode = old_boundnode\n    return dict(node=self, context=context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_attribute", "self", "context", "none", "infer", "an", "attribute", "node", "by", "using", "getattr", "on", "the", "associated", "object", "for", "owner", "in", "self", "expr", "infer", "context", "if", "owner", "is", "util", "uninferable", "yield", "owner", "continue", "if", "not", "context", "context", "inferencecontext", "old_boundnode", "context", "boundnode", "try", "context", "boundnode", "owner", "yield", "from", "owner", "igetattr", "self", "attrname", "context", "except", "attributeinferenceerror", "inferenceerror", "attributeerror", "pass", "finally", "context", "boundnode", "old_boundnode", "return", "dict", "node", "self", "context", "context"], "doc_len": 68}
{"doc_id": "astroid/inference.py::infer_global", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_global", "text": "文件路径: astroid/inference.py\ndef infer_global(self, context=None):\n    if context.lookupname is None:\n        raise InferenceError(node=self, context=context)\n    try:\n        return bases._infer_stmts(self.root().getattr(context.lookupname), context)\n    except AttributeInferenceError as error:\n        raise InferenceError(\n            str(error), target=self, attribute=context.lookupname, context=context\n        ) from error\n", "tokens": ["astroid", "inference", "py", "def", "infer_global", "self", "context", "none", "if", "context", "lookupname", "is", "none", "raise", "inferenceerror", "node", "self", "context", "context", "try", "return", "bases", "_infer_stmts", "self", "root", "getattr", "context", "lookupname", "context", "except", "attributeinferenceerror", "as", "error", "raise", "inferenceerror", "str", "error", "target", "self", "attribute", "context", "lookupname", "context", "context", "from", "error"], "doc_len": 46}
{"doc_id": "astroid/inference.py::infer_subscript", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_subscript", "text": "文件路径: astroid/inference.py\ndef infer_subscript(self, context=None):\n    \"\"\"Inference for subscripts\n\n    We're understanding if the index is a Const\n    or a slice, passing the result of inference\n    to the value's `getitem` method, which should\n    handle each supported index type accordingly.\n    \"\"\"\n\n    found_one = False\n    for value in self.value.infer(context):\n        if value is util.Uninferable:\n            yield util.Uninferable\n            return None\n        for index in self.slice.infer(context):\n            if index is util.Uninferable:\n                yield util.Uninferable\n                return None\n\n            # Try to deduce the index value.\n            index_value = _SUBSCRIPT_SENTINEL\n            if value.__class__ == bases.Instance:\n                index_value = index\n            elif index.__class__ == bases.Instance:\n                instance_as_index = helpers.class_instance_as_index(index)\n                if instance_as_index:\n                    index_value = instance_as_index\n            else:\n                index_value = index\n\n            if index_value is _SUBSCRIPT_SENTINEL:\n                raise InferenceError(node=self, context=context)\n\n            try:\n                assigned = value.getitem(index_value, context)\n            except (\n                AstroidTypeError,\n                AstroidIndexError,\n                AttributeInferenceError,\n                AttributeError,\n            ) as exc:\n                raise InferenceError(node=self, context=context) from exc\n\n            # Prevent inferring if the inferred subscript\n            # is the same as the original subscripted object.\n            if self is assigned or assigned is util.Uninferable:\n                yield util.Uninferable\n                return None\n            yield from assigned.infer(context)\n            found_one = True\n\n    if found_one:\n        return dict(node=self, context=context)\n    return None\n", "tokens": ["astroid", "inference", "py", "def", "infer_subscript", "self", "context", "none", "inference", "for", "subscripts", "we", "re", "understanding", "if", "the", "index", "is", "a", "const", "or", "a", "slice", "passing", "the", "result", "of", "inference", "to", "the", "value", "s", "getitem", "method", "which", "should", "handle", "each", "supported", "index", "type", "accordingly", "found_one", "false", "for", "value", "in", "self", "value", "infer", "context", "if", "value", "is", "util", "uninferable", "yield", "util", "uninferable", "return", "none", "for", "index", "in", "self", "slice", "infer", "context", "if", "index", "is", "util", "uninferable", "yield", "util", "uninferable", "return", "none", "try", "to", "deduce", "the", "index", "value", "index_value", "_subscript_sentinel", "if", "value", "__class__", "bases", "instance", "index_value", "index", "elif", "index", "__class__", "bases", "instance", "instance_as_index", "helpers", "class_instance_as_index", "index", "if", "instance_as_index", "index_value", "instance_as_index", "else", "index_value", "index", "if", "index_value", "is", "_subscript_sentinel", "raise", "inferenceerror", "node", "self", "context", "context", "try", "assigned", "value", "getitem", "index_value", "context", "except", "astroidtypeerror", "astroidindexerror", "attributeinferenceerror", "attributeerror", "as", "exc", "raise", "inferenceerror", "node", "self", "context", "context", "from", "exc", "prevent", "inferring", "if", "the", "inferred", "subscript", "is", "the", "same", "as", "the", "original", "subscripted", "object", "if", "self", "is", "assigned", "or", "assigned", "is", "util", "uninferable", "yield", "util", "uninferable", "return", "none", "yield", "from", "assigned", "infer", "context", "found_one", "true", "if", "found_one", "return", "dict", "node", "self", "context", "context", "return", "none"], "doc_len": 185}
{"doc_id": "astroid/inference.py::_infer_boolop", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_boolop", "text": "文件路径: astroid/inference.py\ndef _infer_boolop(self, context=None):\n    \"\"\"Infer a boolean operation (and / or / not).\n\n    The function will calculate the boolean operation\n    for all pairs generated through inference for each component\n    node.\n    \"\"\"\n    values = self.values\n    if self.op == \"or\":\n        predicate = operator.truth\n    else:\n        predicate = operator.not_\n\n    try:\n        values = [value.infer(context=context) for value in values]\n    except InferenceError:\n        yield util.Uninferable\n        return None\n\n    for pair in itertools.product(*values):\n        if any(item is util.Uninferable for item in pair):\n            # Can't infer the final result, just yield Uninferable.\n            yield util.Uninferable\n            continue\n\n        bool_values = [item.bool_value() for item in pair]\n        if any(item is util.Uninferable for item in bool_values):\n            # Can't infer the final result, just yield Uninferable.\n            yield util.Uninferable\n            continue\n\n        # Since the boolean operations are short circuited operations,\n        # this code yields the first value for which the predicate is True\n        # and if no value respected the predicate, then the last value will\n        # be returned (or Uninferable if there was no last value).\n        # This is conforming to the semantics of `and` and `or`:\n        #   1 and 0 -> 1\n        #   0 and 1 -> 0\n        #   1 or 0 -> 1\n        #   0 or 1 -> 1\n        value = util.Uninferable\n        for value, bool_value in zip(pair, bool_values):\n            if predicate(bool_value):\n                yield value\n                break\n        else:\n            yield value\n\n    return dict(node=self, context=context)\n", "tokens": ["astroid", "inference", "py", "def", "_infer_boolop", "self", "context", "none", "infer", "a", "boolean", "operation", "and", "or", "not", "the", "function", "will", "calculate", "the", "boolean", "operation", "for", "all", "pairs", "generated", "through", "inference", "for", "each", "component", "node", "values", "self", "values", "if", "self", "op", "or", "predicate", "operator", "truth", "else", "predicate", "operator", "not_", "try", "values", "value", "infer", "context", "context", "for", "value", "in", "values", "except", "inferenceerror", "yield", "util", "uninferable", "return", "none", "for", "pair", "in", "itertools", "product", "values", "if", "any", "item", "is", "util", "uninferable", "for", "item", "in", "pair", "can", "t", "infer", "the", "final", "result", "just", "yield", "uninferable", "yield", "util", "uninferable", "continue", "bool_values", "item", "bool_value", "for", "item", "in", "pair", "if", "any", "item", "is", "util", "uninferable", "for", "item", "in", "bool_values", "can", "t", "infer", "the", "final", "result", "just", "yield", "uninferable", "yield", "util", "uninferable", "continue", "since", "the", "boolean", "operations", "are", "short", "circuited", "operations", "this", "code", "yields", "the", "first", "value", "for", "which", "the", "predicate", "is", "true", "and", "if", "no", "value", "respected", "the", "predicate", "then", "the", "last", "value", "will", "be", "returned", "or", "uninferable", "if", "there", "was", "no", "last", "value", "this", "is", "conforming", "to", "the", "semantics", "of", "and", "and", "or", "1", "and", "0", "1", "0", "and", "1", "0", "1", "or", "0", "1", "0", "or", "1", "1", "value", "util", "uninferable", "for", "value", "bool_value", "in", "zip", "pair", "bool_values", "if", "predicate", "bool_value", "yield", "value", "break", "else", "yield", "value", "return", "dict", "node", "self", "context", "context"], "doc_len": 215}
{"doc_id": "astroid/inference.py::_filter_operation_errors", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_filter_operation_errors", "text": "文件路径: astroid/inference.py\ndef _filter_operation_errors(self, infer_callable, context, error):\n    for result in infer_callable(self, context):\n        if isinstance(result, error):\n            # For the sake of .infer(), we don't care about operation\n            # errors, which is the job of pylint. So return something\n            # which shows that we can't infer the result.\n            yield util.Uninferable\n        else:\n            yield result\n", "tokens": ["astroid", "inference", "py", "def", "_filter_operation_errors", "self", "infer_callable", "context", "error", "for", "result", "in", "infer_callable", "self", "context", "if", "isinstance", "result", "error", "for", "the", "sake", "of", "infer", "we", "don", "t", "care", "about", "operation", "errors", "which", "is", "the", "job", "of", "pylint", "so", "return", "something", "which", "shows", "that", "we", "can", "t", "infer", "the", "result", "yield", "util", "uninferable", "else", "yield", "result"], "doc_len": 55}
{"doc_id": "astroid/inference.py::_infer_unaryop", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_unaryop", "text": "文件路径: astroid/inference.py\ndef _infer_unaryop(self, context=None):\n    \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n    for operand in self.operand.infer(context):\n        try:\n            yield operand.infer_unary_op(self.op)\n        except TypeError as exc:\n            # The operand doesn't support this operation.\n            yield util.BadUnaryOperationMessage(operand, self.op, exc)\n        except AttributeError as exc:\n            meth = protocols.UNARY_OP_METHOD[self.op]\n            if meth is None:\n                # `not node`. Determine node's boolean\n                # value and negate its result, unless it is\n                # Uninferable, which will be returned as is.\n                bool_value = operand.bool_value()\n                if bool_value is not util.Uninferable:\n                    yield nodes.const_factory(not bool_value)\n                else:\n                    yield util.Uninferable\n            else:\n                if not isinstance(operand, (bases.Instance, nodes.ClassDef)):\n                    # The operation was used on something which\n                    # doesn't support it.\n                    yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                    continue\n\n                try:\n                    try:\n                        methods = dunder_lookup.lookup(operand, meth)\n                    except AttributeInferenceError:\n                        yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                        continue\n\n                    meth = methods[0]\n                    inferred = next(meth.infer(context=context), None)\n                    if inferred is util.Uninferable or not inferred.callable():\n                        continue\n\n                    context = copy_context(context)\n                    context.boundnode = operand\n                    context.callcontext = CallContext(args=[], callee=inferred)\n\n                    call_results = inferred.infer_call_result(self, context=context)\n                    result = next(call_results, None)\n                    if result is None:\n                        # Failed to infer, return the same type.\n                        yield operand\n                    else:\n                        yield result\n                except AttributeInferenceError as exc:\n                    # The unary operation special method was not found.\n                    yield util.BadUnaryOperationMessage(operand, self.op, exc)\n                except InferenceError:\n                    yield util.Uninferable\n", "tokens": ["astroid", "inference", "py", "def", "_infer_unaryop", "self", "context", "none", "infer", "what", "an", "unaryop", "should", "return", "when", "evaluated", "for", "operand", "in", "self", "operand", "infer", "context", "try", "yield", "operand", "infer_unary_op", "self", "op", "except", "typeerror", "as", "exc", "the", "operand", "doesn", "t", "support", "this", "operation", "yield", "util", "badunaryoperationmessage", "operand", "self", "op", "exc", "except", "attributeerror", "as", "exc", "meth", "protocols", "unary_op_method", "self", "op", "if", "meth", "is", "none", "not", "node", "determine", "node", "s", "boolean", "value", "and", "negate", "its", "result", "unless", "it", "is", "uninferable", "which", "will", "be", "returned", "as", "is", "bool_value", "operand", "bool_value", "if", "bool_value", "is", "not", "util", "uninferable", "yield", "nodes", "const_factory", "not", "bool_value", "else", "yield", "util", "uninferable", "else", "if", "not", "isinstance", "operand", "bases", "instance", "nodes", "classdef", "the", "operation", "was", "used", "on", "something", "which", "doesn", "t", "support", "it", "yield", "util", "badunaryoperationmessage", "operand", "self", "op", "exc", "continue", "try", "try", "methods", "dunder_lookup", "lookup", "operand", "meth", "except", "attributeinferenceerror", "yield", "util", "badunaryoperationmessage", "operand", "self", "op", "exc", "continue", "meth", "methods", "0", "inferred", "next", "meth", "infer", "context", "context", "none", "if", "inferred", "is", "util", "uninferable", "or", "not", "inferred", "callable", "continue", "context", "copy_context", "context", "context", "boundnode", "operand", "context", "callcontext", "callcontext", "args", "callee", "inferred", "call_results", "inferred", "infer_call_result", "self", "context", "context", "result", "next", "call_results", "none", "if", "result", "is", "none", "failed", "to", "infer", "return", "the", "same", "type", "yield", "operand", "else", "yield", "result", "except", "attributeinferenceerror", "as", "exc", "the", "unary", "operation", "special", "method", "was", "not", "found", "yield", "util", "badunaryoperationmessage", "operand", "self", "op", "exc", "except", "inferenceerror", "yield", "util", "uninferable"], "doc_len": 226}
{"doc_id": "astroid/inference.py::infer_unaryop", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_unaryop", "text": "文件路径: astroid/inference.py\ndef infer_unaryop(self, context=None):\n    \"\"\"Infer what an UnaryOp should return when evaluated.\"\"\"\n    yield from _filter_operation_errors(\n        self, _infer_unaryop, context, util.BadUnaryOperationMessage\n    )\n    return dict(node=self, context=context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_unaryop", "self", "context", "none", "infer", "what", "an", "unaryop", "should", "return", "when", "evaluated", "yield", "from", "_filter_operation_errors", "self", "_infer_unaryop", "context", "util", "badunaryoperationmessage", "return", "dict", "node", "self", "context", "context"], "doc_len": 30}
{"doc_id": "astroid/inference.py::_is_not_implemented", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_is_not_implemented", "text": "文件路径: astroid/inference.py\ndef _is_not_implemented(const):\n    \"\"\"Check if the given const node is NotImplemented.\"\"\"\n    return isinstance(const, nodes.Const) and const.value is NotImplemented\n", "tokens": ["astroid", "inference", "py", "def", "_is_not_implemented", "const", "check", "if", "the", "given", "const", "node", "is", "notimplemented", "return", "isinstance", "const", "nodes", "const", "and", "const", "value", "is", "notimplemented"], "doc_len": 24}
{"doc_id": "astroid/inference.py::_invoke_binop_inference", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_invoke_binop_inference", "text": "文件路径: astroid/inference.py\ndef _invoke_binop_inference(instance, opnode, op, other, context, method_name):\n    \"\"\"Invoke binary operation inference on the given instance.\"\"\"\n    methods = dunder_lookup.lookup(instance, method_name)\n    context = bind_context_to_node(context, instance)\n    method = methods[0]\n    context.callcontext.callee = method\n    try:\n        inferred = next(method.infer(context=context))\n    except StopIteration as e:\n        raise InferenceError(node=method, context=context) from e\n    if inferred is util.Uninferable:\n        raise InferenceError\n    return instance.infer_binary_op(opnode, op, other, context, inferred)\n", "tokens": ["astroid", "inference", "py", "def", "_invoke_binop_inference", "instance", "opnode", "op", "other", "context", "method_name", "invoke", "binary", "operation", "inference", "on", "the", "given", "instance", "methods", "dunder_lookup", "lookup", "instance", "method_name", "context", "bind_context_to_node", "context", "instance", "method", "methods", "0", "context", "callcontext", "callee", "method", "try", "inferred", "next", "method", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "method", "context", "context", "from", "e", "if", "inferred", "is", "util", "uninferable", "raise", "inferenceerror", "return", "instance", "infer_binary_op", "opnode", "op", "other", "context", "inferred"], "doc_len": 69}
{"doc_id": "astroid/inference.py::_aug_op", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_aug_op", "text": "文件路径: astroid/inference.py\ndef _aug_op(instance, opnode, op, other, context, reverse=False):\n    \"\"\"Get an inference callable for an augmented binary operation.\"\"\"\n    method_name = protocols.AUGMENTED_OP_METHOD[op]\n    return functools.partial(\n        _invoke_binop_inference,\n        instance=instance,\n        op=op,\n        opnode=opnode,\n        other=other,\n        context=context,\n        method_name=method_name,\n    )\n", "tokens": ["astroid", "inference", "py", "def", "_aug_op", "instance", "opnode", "op", "other", "context", "reverse", "false", "get", "an", "inference", "callable", "for", "an", "augmented", "binary", "operation", "method_name", "protocols", "augmented_op_method", "op", "return", "functools", "partial", "_invoke_binop_inference", "instance", "instance", "op", "op", "opnode", "opnode", "other", "other", "context", "context", "method_name", "method_name"], "doc_len": 41}
{"doc_id": "astroid/inference.py::_bin_op", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_bin_op", "text": "文件路径: astroid/inference.py\ndef _bin_op(instance, opnode, op, other, context, reverse=False):\n    \"\"\"Get an inference callable for a normal binary operation.\n\n    If *reverse* is True, then the reflected method will be used instead.\n    \"\"\"\n    if reverse:\n        method_name = protocols.REFLECTED_BIN_OP_METHOD[op]\n    else:\n        method_name = protocols.BIN_OP_METHOD[op]\n    return functools.partial(\n        _invoke_binop_inference,\n        instance=instance,\n        op=op,\n        opnode=opnode,\n        other=other,\n        context=context,\n        method_name=method_name,\n    )\n", "tokens": ["astroid", "inference", "py", "def", "_bin_op", "instance", "opnode", "op", "other", "context", "reverse", "false", "get", "an", "inference", "callable", "for", "a", "normal", "binary", "operation", "if", "reverse", "is", "true", "then", "the", "reflected", "method", "will", "be", "used", "instead", "if", "reverse", "method_name", "protocols", "reflected_bin_op_method", "op", "else", "method_name", "protocols", "bin_op_method", "op", "return", "functools", "partial", "_invoke_binop_inference", "instance", "instance", "op", "op", "opnode", "opnode", "other", "other", "context", "context", "method_name", "method_name"], "doc_len": 60}
{"doc_id": "astroid/inference.py::_get_binop_contexts", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_get_binop_contexts", "text": "文件路径: astroid/inference.py\ndef _get_binop_contexts(context, left, right):\n    \"\"\"Get contexts for binary operations.\n\n    This will return two inference contexts, the first one\n    for x.__op__(y), the other one for y.__rop__(x), where\n    only the arguments are inversed.\n    \"\"\"\n    # The order is important, since the first one should be\n    # left.__op__(right).\n    for arg in (right, left):\n        new_context = context.clone()\n        new_context.callcontext = CallContext(args=[arg])\n        new_context.boundnode = None\n        yield new_context\n", "tokens": ["astroid", "inference", "py", "def", "_get_binop_contexts", "context", "left", "right", "get", "contexts", "for", "binary", "operations", "this", "will", "return", "two", "inference", "contexts", "the", "first", "one", "for", "x", "__op__", "y", "the", "other", "one", "for", "y", "__rop__", "x", "where", "only", "the", "arguments", "are", "inversed", "the", "order", "is", "important", "since", "the", "first", "one", "should", "be", "left", "__op__", "right", "for", "arg", "in", "right", "left", "new_context", "context", "clone", "new_context", "callcontext", "callcontext", "args", "arg", "new_context", "boundnode", "none", "yield", "new_context"], "doc_len": 70}
{"doc_id": "astroid/inference.py::_same_type", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_same_type", "text": "文件路径: astroid/inference.py\ndef _same_type(type1, type2):\n    \"\"\"Check if type1 is the same as type2.\"\"\"\n    return type1.qname() == type2.qname()\n", "tokens": ["astroid", "inference", "py", "def", "_same_type", "type1", "type2", "check", "if", "type1", "is", "the", "same", "as", "type2", "return", "type1", "qname", "type2", "qname"], "doc_len": 20}
{"doc_id": "astroid/inference.py::_get_binop_flow", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_get_binop_flow", "text": "文件路径: astroid/inference.py\ndef _get_binop_flow(\n    left, left_type, binary_opnode, right, right_type, context, reverse_context\n):\n    \"\"\"Get the flow for binary operations.\n\n    The rules are a bit messy:\n\n        * if left and right have the same type, then only one\n          method will be called, left.__op__(right)\n        * if left and right are unrelated typewise, then first\n          left.__op__(right) is tried and if this does not exist\n          or returns NotImplemented, then right.__rop__(left) is tried.\n        * if left is a subtype of right, then only left.__op__(right)\n          is tried.\n        * if left is a supertype of right, then right.__rop__(left)\n          is first tried and then left.__op__(right)\n    \"\"\"\n    op = binary_opnode.op\n    if _same_type(left_type, right_type):\n        methods = [_bin_op(left, binary_opnode, op, right, context)]\n    elif helpers.is_subtype(left_type, right_type):\n        methods = [_bin_op(left, binary_opnode, op, right, context)]\n    elif helpers.is_supertype(left_type, right_type):\n        methods = [\n            _bin_op(right, binary_opnode, op, left, reverse_context, reverse=True),\n            _bin_op(left, binary_opnode, op, right, context),\n        ]\n    else:\n        methods = [\n            _bin_op(left, binary_opnode, op, right, context),\n            _bin_op(right, binary_opnode, op, left, reverse_context, reverse=True),\n        ]\n    return methods\n", "tokens": ["astroid", "inference", "py", "def", "_get_binop_flow", "left", "left_type", "binary_opnode", "right", "right_type", "context", "reverse_context", "get", "the", "flow", "for", "binary", "operations", "the", "rules", "are", "a", "bit", "messy", "if", "left", "and", "right", "have", "the", "same", "type", "then", "only", "one", "method", "will", "be", "called", "left", "__op__", "right", "if", "left", "and", "right", "are", "unrelated", "typewise", "then", "first", "left", "__op__", "right", "is", "tried", "and", "if", "this", "does", "not", "exist", "or", "returns", "notimplemented", "then", "right", "__rop__", "left", "is", "tried", "if", "left", "is", "a", "subtype", "of", "right", "then", "only", "left", "__op__", "right", "is", "tried", "if", "left", "is", "a", "supertype", "of", "right", "then", "right", "__rop__", "left", "is", "first", "tried", "and", "then", "left", "__op__", "right", "op", "binary_opnode", "op", "if", "_same_type", "left_type", "right_type", "methods", "_bin_op", "left", "binary_opnode", "op", "right", "context", "elif", "helpers", "is_subtype", "left_type", "right_type", "methods", "_bin_op", "left", "binary_opnode", "op", "right", "context", "elif", "helpers", "is_supertype", "left_type", "right_type", "methods", "_bin_op", "right", "binary_opnode", "op", "left", "reverse_context", "reverse", "true", "_bin_op", "left", "binary_opnode", "op", "right", "context", "else", "methods", "_bin_op", "left", "binary_opnode", "op", "right", "context", "_bin_op", "right", "binary_opnode", "op", "left", "reverse_context", "reverse", "true", "return", "methods"], "doc_len": 168}
{"doc_id": "astroid/inference.py::_get_aug_flow", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_get_aug_flow", "text": "文件路径: astroid/inference.py\ndef _get_aug_flow(\n    left, left_type, aug_opnode, right, right_type, context, reverse_context\n):\n    \"\"\"Get the flow for augmented binary operations.\n\n    The rules are a bit messy:\n\n        * if left and right have the same type, then left.__augop__(right)\n          is first tried and then left.__op__(right).\n        * if left and right are unrelated typewise, then\n          left.__augop__(right) is tried, then left.__op__(right)\n          is tried and then right.__rop__(left) is tried.\n        * if left is a subtype of right, then left.__augop__(right)\n          is tried and then left.__op__(right).\n        * if left is a supertype of right, then left.__augop__(right)\n          is tried, then right.__rop__(left) and then\n          left.__op__(right)\n    \"\"\"\n    bin_op = aug_opnode.op.strip(\"=\")\n    aug_op = aug_opnode.op\n    if _same_type(left_type, right_type):\n        methods = [\n            _aug_op(left, aug_opnode, aug_op, right, context),\n            _bin_op(left, aug_opnode, bin_op, right, context),\n        ]\n    elif helpers.is_subtype(left_type, right_type):\n        methods = [\n            _aug_op(left, aug_opnode, aug_op, right, context),\n            _bin_op(left, aug_opnode, bin_op, right, context),\n        ]\n    elif helpers.is_supertype(left_type, right_type):\n        methods = [\n            _aug_op(left, aug_opnode, aug_op, right, context),\n            _bin_op(right, aug_opnode, bin_op, left, reverse_context, reverse=True),\n            _bin_op(left, aug_opnode, bin_op, right, context),\n        ]\n    else:\n        methods = [\n            _aug_op(left, aug_opnode, aug_op, right, context),\n            _bin_op(left, aug_opnode, bin_op, right, context),\n            _bin_op(right, aug_opnode, bin_op, left, reverse_context, reverse=True),\n        ]\n    return methods\n", "tokens": ["astroid", "inference", "py", "def", "_get_aug_flow", "left", "left_type", "aug_opnode", "right", "right_type", "context", "reverse_context", "get", "the", "flow", "for", "augmented", "binary", "operations", "the", "rules", "are", "a", "bit", "messy", "if", "left", "and", "right", "have", "the", "same", "type", "then", "left", "__augop__", "right", "is", "first", "tried", "and", "then", "left", "__op__", "right", "if", "left", "and", "right", "are", "unrelated", "typewise", "then", "left", "__augop__", "right", "is", "tried", "then", "left", "__op__", "right", "is", "tried", "and", "then", "right", "__rop__", "left", "is", "tried", "if", "left", "is", "a", "subtype", "of", "right", "then", "left", "__augop__", "right", "is", "tried", "and", "then", "left", "__op__", "right", "if", "left", "is", "a", "supertype", "of", "right", "then", "left", "__augop__", "right", "is", "tried", "then", "right", "__rop__", "left", "and", "then", "left", "__op__", "right", "bin_op", "aug_opnode", "op", "strip", "aug_op", "aug_opnode", "op", "if", "_same_type", "left_type", "right_type", "methods", "_aug_op", "left", "aug_opnode", "aug_op", "right", "context", "_bin_op", "left", "aug_opnode", "bin_op", "right", "context", "elif", "helpers", "is_subtype", "left_type", "right_type", "methods", "_aug_op", "left", "aug_opnode", "aug_op", "right", "context", "_bin_op", "left", "aug_opnode", "bin_op", "right", "context", "elif", "helpers", "is_supertype", "left_type", "right_type", "methods", "_aug_op", "left", "aug_opnode", "aug_op", "right", "context", "_bin_op", "right", "aug_opnode", "bin_op", "left", "reverse_context", "reverse", "true", "_bin_op", "left", "aug_opnode", "bin_op", "right", "context", "else", "methods", "_aug_op", "left", "aug_opnode", "aug_op", "right", "context", "_bin_op", "left", "aug_opnode", "bin_op", "right", "context", "_bin_op", "right", "aug_opnode", "bin_op", "left", "reverse_context", "reverse", "true", "return", "methods"], "doc_len": 203}
{"doc_id": "astroid/inference.py::_infer_binary_operation", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_binary_operation", "text": "文件路径: astroid/inference.py\ndef _infer_binary_operation(left, right, binary_opnode, context, flow_factory):\n    \"\"\"Infer a binary operation between a left operand and a right operand\n\n    This is used by both normal binary operations and augmented binary\n    operations, the only difference is the flow factory used.\n    \"\"\"\n\n    context, reverse_context = _get_binop_contexts(context, left, right)\n    left_type = helpers.object_type(left)\n    right_type = helpers.object_type(right)\n    methods = flow_factory(\n        left, left_type, binary_opnode, right, right_type, context, reverse_context\n    )\n    for method in methods:\n        try:\n            results = list(method())\n        except AttributeError:\n            continue\n        except AttributeInferenceError:\n            continue\n        except InferenceError:\n            yield util.Uninferable\n            return\n        else:\n            if any(result is util.Uninferable for result in results):\n                yield util.Uninferable\n                return\n\n            if all(map(_is_not_implemented, results)):\n                continue\n            not_implemented = sum(\n                1 for result in results if _is_not_implemented(result)\n            )\n            if not_implemented and not_implemented != len(results):\n                # Can't infer yet what this is.\n                yield util.Uninferable\n                return\n\n            yield from results\n            return\n    # The operation doesn't seem to be supported so let the caller know about it\n    yield util.BadBinaryOperationMessage(left_type, binary_opnode.op, right_type)\n", "tokens": ["astroid", "inference", "py", "def", "_infer_binary_operation", "left", "right", "binary_opnode", "context", "flow_factory", "infer", "a", "binary", "operation", "between", "a", "left", "operand", "and", "a", "right", "operand", "this", "is", "used", "by", "both", "normal", "binary", "operations", "and", "augmented", "binary", "operations", "the", "only", "difference", "is", "the", "flow", "factory", "used", "context", "reverse_context", "_get_binop_contexts", "context", "left", "right", "left_type", "helpers", "object_type", "left", "right_type", "helpers", "object_type", "right", "methods", "flow_factory", "left", "left_type", "binary_opnode", "right", "right_type", "context", "reverse_context", "for", "method", "in", "methods", "try", "results", "list", "method", "except", "attributeerror", "continue", "except", "attributeinferenceerror", "continue", "except", "inferenceerror", "yield", "util", "uninferable", "return", "else", "if", "any", "result", "is", "util", "uninferable", "for", "result", "in", "results", "yield", "util", "uninferable", "return", "if", "all", "map", "_is_not_implemented", "results", "continue", "not_implemented", "sum", "1", "for", "result", "in", "results", "if", "_is_not_implemented", "result", "if", "not_implemented", "and", "not_implemented", "len", "results", "can", "t", "infer", "yet", "what", "this", "is", "yield", "util", "uninferable", "return", "yield", "from", "results", "return", "the", "operation", "doesn", "t", "seem", "to", "be", "supported", "so", "let", "the", "caller", "know", "about", "it", "yield", "util", "badbinaryoperationmessage", "left_type", "binary_opnode", "op", "right_type"], "doc_len": 159}
{"doc_id": "astroid/inference.py::_infer_binop", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_binop", "text": "文件路径: astroid/inference.py\ndef _infer_binop(self, context):\n    \"\"\"Binary operation inference logic.\"\"\"\n    left = self.left\n    right = self.right\n\n    # we use two separate contexts for evaluating lhs and rhs because\n    # 1. evaluating lhs may leave some undesired entries in context.path\n    #    which may not let us infer right value of rhs\n    context = context or InferenceContext()\n    lhs_context = copy_context(context)\n    rhs_context = copy_context(context)\n    lhs_iter = left.infer(context=lhs_context)\n    rhs_iter = right.infer(context=rhs_context)\n    for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n        if any(value is util.Uninferable for value in (rhs, lhs)):\n            # Don't know how to process this.\n            yield util.Uninferable\n            return\n\n        try:\n            yield from _infer_binary_operation(lhs, rhs, self, context, _get_binop_flow)\n        except _NonDeducibleTypeHierarchy:\n            yield util.Uninferable\n", "tokens": ["astroid", "inference", "py", "def", "_infer_binop", "self", "context", "binary", "operation", "inference", "logic", "left", "self", "left", "right", "self", "right", "we", "use", "two", "separate", "contexts", "for", "evaluating", "lhs", "and", "rhs", "because", "1", "evaluating", "lhs", "may", "leave", "some", "undesired", "entries", "in", "context", "path", "which", "may", "not", "let", "us", "infer", "right", "value", "of", "rhs", "context", "context", "or", "inferencecontext", "lhs_context", "copy_context", "context", "rhs_context", "copy_context", "context", "lhs_iter", "left", "infer", "context", "lhs_context", "rhs_iter", "right", "infer", "context", "rhs_context", "for", "lhs", "rhs", "in", "itertools", "product", "lhs_iter", "rhs_iter", "if", "any", "value", "is", "util", "uninferable", "for", "value", "in", "rhs", "lhs", "don", "t", "know", "how", "to", "process", "this", "yield", "util", "uninferable", "return", "try", "yield", "from", "_infer_binary_operation", "lhs", "rhs", "self", "context", "_get_binop_flow", "except", "_nondeducibletypehierarchy", "yield", "util", "uninferable"], "doc_len": 113}
{"doc_id": "astroid/inference.py::infer_binop", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_binop", "text": "文件路径: astroid/inference.py\ndef infer_binop(self, context=None):\n    return _filter_operation_errors(\n        self, _infer_binop, context, util.BadBinaryOperationMessage\n    )\n", "tokens": ["astroid", "inference", "py", "def", "infer_binop", "self", "context", "none", "return", "_filter_operation_errors", "self", "_infer_binop", "context", "util", "badbinaryoperationmessage"], "doc_len": 15}
{"doc_id": "astroid/inference.py::_to_literal", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_to_literal", "text": "文件路径: astroid/inference.py\ndef _to_literal(node: nodes.NodeNG) -> Any:\n    # Can raise SyntaxError or ValueError from ast.literal_eval\n    # Can raise AttributeError from node.as_string() as not all nodes have a visitor\n    # Is this the stupidest idea or the simplest idea?\n    return ast.literal_eval(node.as_string())\n", "tokens": ["astroid", "inference", "py", "def", "_to_literal", "node", "nodes", "nodeng", "any", "can", "raise", "syntaxerror", "or", "valueerror", "from", "ast", "literal_eval", "can", "raise", "attributeerror", "from", "node", "as_string", "as", "not", "all", "nodes", "have", "a", "visitor", "is", "this", "the", "stupidest", "idea", "or", "the", "simplest", "idea", "return", "ast", "literal_eval", "node", "as_string"], "doc_len": 44}
{"doc_id": "astroid/inference.py::_do_compare", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_do_compare", "text": "文件路径: astroid/inference.py\ndef _do_compare(\n    left_iter: Iterable[nodes.NodeNG], op: str, right_iter: Iterable[nodes.NodeNG]\n) -> \"bool | type[util.Uninferable]\":\n    \"\"\"\n    If all possible combinations are either True or False, return that:\n    >>> _do_compare([1, 2], '<=', [3, 4])\n    True\n    >>> _do_compare([1, 2], '==', [3, 4])\n    False\n\n    If any item is uninferable, or if some combinations are True and some\n    are False, return Uninferable:\n    >>> _do_compare([1, 3], '<=', [2, 4])\n    util.Uninferable\n    \"\"\"\n    retval = None\n    if op in UNINFERABLE_OPS:\n        return util.Uninferable\n    op_func = COMPARE_OPS[op]\n\n    for left, right in itertools.product(left_iter, right_iter):\n        if left is util.Uninferable or right is util.Uninferable:\n            return util.Uninferable\n\n        try:\n            left, right = _to_literal(left), _to_literal(right)\n        except (SyntaxError, ValueError, AttributeError):\n            return util.Uninferable\n\n        try:\n            expr = op_func(left, right)\n        except TypeError as exc:\n            raise AstroidTypeError from exc\n\n        if retval is None:\n            retval = expr\n        elif retval != expr:\n            return util.Uninferable\n            # (or both, but \"True | False\" is basically the same)\n\n    return retval  # it was all the same value\n", "tokens": ["astroid", "inference", "py", "def", "_do_compare", "left_iter", "iterable", "nodes", "nodeng", "op", "str", "right_iter", "iterable", "nodes", "nodeng", "bool", "type", "util", "uninferable", "if", "all", "possible", "combinations", "are", "either", "true", "or", "false", "return", "that", "_do_compare", "1", "2", "3", "4", "true", "_do_compare", "1", "2", "3", "4", "false", "if", "any", "item", "is", "uninferable", "or", "if", "some", "combinations", "are", "true", "and", "some", "are", "false", "return", "uninferable", "_do_compare", "1", "3", "2", "4", "util", "uninferable", "retval", "none", "if", "op", "in", "uninferable_ops", "return", "util", "uninferable", "op_func", "compare_ops", "op", "for", "left", "right", "in", "itertools", "product", "left_iter", "right_iter", "if", "left", "is", "util", "uninferable", "or", "right", "is", "util", "uninferable", "return", "util", "uninferable", "try", "left", "right", "_to_literal", "left", "_to_literal", "right", "except", "syntaxerror", "valueerror", "attributeerror", "return", "util", "uninferable", "try", "expr", "op_func", "left", "right", "except", "typeerror", "as", "exc", "raise", "astroidtypeerror", "from", "exc", "if", "retval", "is", "none", "retval", "expr", "elif", "retval", "expr", "return", "util", "uninferable", "or", "both", "but", "true", "false", "is", "basically", "the", "same", "return", "retval", "it", "was", "all", "the", "same", "value"], "doc_len": 155}
{"doc_id": "astroid/inference.py::_infer_compare", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_compare", "text": "文件路径: astroid/inference.py\ndef _infer_compare(\n    self: nodes.Compare, context: Optional[InferenceContext] = None\n) -> Any:\n    \"\"\"Chained comparison inference logic.\"\"\"\n    retval = True\n\n    ops = self.ops\n    left_node = self.left\n    lhs = list(left_node.infer(context=context))\n    # should we break early if first element is uninferable?\n    for op, right_node in ops:\n        # eagerly evaluate rhs so that values can be re-used as lhs\n        rhs = list(right_node.infer(context=context))\n        try:\n            retval = _do_compare(lhs, op, rhs)\n        except AstroidTypeError:\n            retval = util.Uninferable\n            break\n        if retval is not True:\n            break  # short-circuit\n        lhs = rhs  # continue\n    if retval is util.Uninferable:\n        yield retval\n    else:\n        yield nodes.Const(retval)\n", "tokens": ["astroid", "inference", "py", "def", "_infer_compare", "self", "nodes", "compare", "context", "optional", "inferencecontext", "none", "any", "chained", "comparison", "inference", "logic", "retval", "true", "ops", "self", "ops", "left_node", "self", "left", "lhs", "list", "left_node", "infer", "context", "context", "should", "we", "break", "early", "if", "first", "element", "is", "uninferable", "for", "op", "right_node", "in", "ops", "eagerly", "evaluate", "rhs", "so", "that", "values", "can", "be", "re", "used", "as", "lhs", "rhs", "list", "right_node", "infer", "context", "context", "try", "retval", "_do_compare", "lhs", "op", "rhs", "except", "astroidtypeerror", "retval", "util", "uninferable", "break", "if", "retval", "is", "not", "true", "break", "short", "circuit", "lhs", "rhs", "continue", "if", "retval", "is", "util", "uninferable", "yield", "retval", "else", "yield", "nodes", "const", "retval"], "doc_len": 98}
{"doc_id": "astroid/inference.py::_infer_augassign", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_infer_augassign", "text": "文件路径: astroid/inference.py\ndef _infer_augassign(self, context=None):\n    \"\"\"Inference logic for augmented binary operations.\"\"\"\n    if context is None:\n        context = InferenceContext()\n\n    rhs_context = context.clone()\n\n    lhs_iter = self.target.infer_lhs(context=context)\n    rhs_iter = self.value.infer(context=rhs_context)\n    for lhs, rhs in itertools.product(lhs_iter, rhs_iter):\n        if any(value is util.Uninferable for value in (rhs, lhs)):\n            # Don't know how to process this.\n            yield util.Uninferable\n            return\n\n        try:\n            yield from _infer_binary_operation(\n                left=lhs,\n                right=rhs,\n                binary_opnode=self,\n                context=context,\n                flow_factory=_get_aug_flow,\n            )\n        except _NonDeducibleTypeHierarchy:\n            yield util.Uninferable\n", "tokens": ["astroid", "inference", "py", "def", "_infer_augassign", "self", "context", "none", "inference", "logic", "for", "augmented", "binary", "operations", "if", "context", "is", "none", "context", "inferencecontext", "rhs_context", "context", "clone", "lhs_iter", "self", "target", "infer_lhs", "context", "context", "rhs_iter", "self", "value", "infer", "context", "rhs_context", "for", "lhs", "rhs", "in", "itertools", "product", "lhs_iter", "rhs_iter", "if", "any", "value", "is", "util", "uninferable", "for", "value", "in", "rhs", "lhs", "don", "t", "know", "how", "to", "process", "this", "yield", "util", "uninferable", "return", "try", "yield", "from", "_infer_binary_operation", "left", "lhs", "right", "rhs", "binary_opnode", "self", "context", "context", "flow_factory", "_get_aug_flow", "except", "_nondeducibletypehierarchy", "yield", "util", "uninferable"], "doc_len": 84}
{"doc_id": "astroid/inference.py::infer_augassign", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_augassign", "text": "文件路径: astroid/inference.py\ndef infer_augassign(self, context=None):\n    return _filter_operation_errors(\n        self, _infer_augassign, context, util.BadBinaryOperationMessage\n    )\n", "tokens": ["astroid", "inference", "py", "def", "infer_augassign", "self", "context", "none", "return", "_filter_operation_errors", "self", "_infer_augassign", "context", "util", "badbinaryoperationmessage"], "doc_len": 15}
{"doc_id": "astroid/inference.py::infer_arguments", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_arguments", "text": "文件路径: astroid/inference.py\ndef infer_arguments(self, context=None):\n    name = context.lookupname\n    if name is None:\n        raise InferenceError(node=self, context=context)\n    return protocols._arguments_infer_argname(self, name, context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_arguments", "self", "context", "none", "name", "context", "lookupname", "if", "name", "is", "none", "raise", "inferenceerror", "node", "self", "context", "context", "return", "protocols", "_arguments_infer_argname", "self", "name", "context"], "doc_len": 27}
{"doc_id": "astroid/inference.py::infer_assign", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_assign", "text": "文件路径: astroid/inference.py\ndef infer_assign(self, context=None):\n    \"\"\"infer a AssignName/AssignAttr: need to inspect the RHS part of the\n    assign node\n    \"\"\"\n    if isinstance(self.parent, nodes.AugAssign):\n        return self.parent.infer(context)\n\n    stmts = list(self.assigned_stmts(context=context))\n    return bases._infer_stmts(stmts, context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_assign", "self", "context", "none", "infer", "a", "assignname", "assignattr", "need", "to", "inspect", "the", "rhs", "part", "of", "the", "assign", "node", "if", "isinstance", "self", "parent", "nodes", "augassign", "return", "self", "parent", "infer", "context", "stmts", "list", "self", "assigned_stmts", "context", "context", "return", "bases", "_infer_stmts", "stmts", "context"], "doc_len": 44}
{"doc_id": "astroid/inference.py::infer_empty_node", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_empty_node", "text": "文件路径: astroid/inference.py\ndef infer_empty_node(self, context=None):\n    if not self.has_underlying_object():\n        yield util.Uninferable\n    else:\n        try:\n            yield from AstroidManager().infer_ast_from_something(\n                self.object, context=context\n            )\n        except AstroidError:\n            yield util.Uninferable\n", "tokens": ["astroid", "inference", "py", "def", "infer_empty_node", "self", "context", "none", "if", "not", "self", "has_underlying_object", "yield", "util", "uninferable", "else", "try", "yield", "from", "astroidmanager", "infer_ast_from_something", "self", "object", "context", "context", "except", "astroiderror", "yield", "util", "uninferable"], "doc_len": 30}
{"doc_id": "astroid/inference.py::infer_index", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_index", "text": "文件路径: astroid/inference.py\ndef infer_index(self, context=None):\n    return self.value.infer(context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_index", "self", "context", "none", "return", "self", "value", "infer", "context"], "doc_len": 13}
{"doc_id": "astroid/inference.py::_populate_context_lookup", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_populate_context_lookup", "text": "文件路径: astroid/inference.py\ndef _populate_context_lookup(call, context):\n    # Allows context to be saved for later\n    # for inference inside a function\n    context_lookup = {}\n    if context is None:\n        return context_lookup\n    for arg in call.args:\n        if isinstance(arg, nodes.Starred):\n            context_lookup[arg.value] = context\n        else:\n            context_lookup[arg] = context\n    keywords = call.keywords if call.keywords is not None else []\n    for keyword in keywords:\n        context_lookup[keyword.value] = context\n    return context_lookup\n", "tokens": ["astroid", "inference", "py", "def", "_populate_context_lookup", "call", "context", "allows", "context", "to", "be", "saved", "for", "later", "for", "inference", "inside", "a", "function", "context_lookup", "if", "context", "is", "none", "return", "context_lookup", "for", "arg", "in", "call", "args", "if", "isinstance", "arg", "nodes", "starred", "context_lookup", "arg", "value", "context", "else", "context_lookup", "arg", "context", "keywords", "call", "keywords", "if", "call", "keywords", "is", "not", "none", "else", "for", "keyword", "in", "keywords", "context_lookup", "keyword", "value", "context", "return", "context_lookup"], "doc_len": 64}
{"doc_id": "astroid/inference.py::infer_ifexp", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_ifexp", "text": "文件路径: astroid/inference.py\ndef infer_ifexp(self, context=None):\n    \"\"\"Support IfExp inference\n\n    If we can't infer the truthiness of the condition, we default\n    to inferring both branches. Otherwise, we infer either branch\n    depending on the condition.\n    \"\"\"\n    both_branches = False\n    # We use two separate contexts for evaluating lhs and rhs because\n    # evaluating lhs may leave some undesired entries in context.path\n    # which may not let us infer right value of rhs.\n\n    context = context or InferenceContext()\n    lhs_context = copy_context(context)\n    rhs_context = copy_context(context)\n    try:\n        test = next(self.test.infer(context=context.clone()))\n    except (InferenceError, StopIteration):\n        both_branches = True\n    else:\n        if test is not util.Uninferable:\n            if test.bool_value():\n                yield from self.body.infer(context=lhs_context)\n            else:\n                yield from self.orelse.infer(context=rhs_context)\n        else:\n            both_branches = True\n    if both_branches:\n        yield from self.body.infer(context=lhs_context)\n        yield from self.orelse.infer(context=rhs_context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_ifexp", "self", "context", "none", "support", "ifexp", "inference", "if", "we", "can", "t", "infer", "the", "truthiness", "of", "the", "condition", "we", "default", "to", "inferring", "both", "branches", "otherwise", "we", "infer", "either", "branch", "depending", "on", "the", "condition", "both_branches", "false", "we", "use", "two", "separate", "contexts", "for", "evaluating", "lhs", "and", "rhs", "because", "evaluating", "lhs", "may", "leave", "some", "undesired", "entries", "in", "context", "path", "which", "may", "not", "let", "us", "infer", "right", "value", "of", "rhs", "context", "context", "or", "inferencecontext", "lhs_context", "copy_context", "context", "rhs_context", "copy_context", "context", "try", "test", "next", "self", "test", "infer", "context", "context", "clone", "except", "inferenceerror", "stopiteration", "both_branches", "true", "else", "if", "test", "is", "not", "util", "uninferable", "if", "test", "bool_value", "yield", "from", "self", "body", "infer", "context", "lhs_context", "else", "yield", "from", "self", "orelse", "infer", "context", "rhs_context", "else", "both_branches", "true", "if", "both_branches", "yield", "from", "self", "body", "infer", "context", "lhs_context", "yield", "from", "self", "orelse", "infer", "context", "rhs_context"], "doc_len": 137}
{"doc_id": "astroid/inference.py::_cached_generator", "file_path": "astroid/inference.py", "class_name": null, "func_name": "_cached_generator", "text": "文件路径: astroid/inference.py\ndef _cached_generator(func, instance, args, kwargs, _cache={}):  # noqa: B006\n    node = args[0]\n    try:\n        return iter(_cache[func, id(node)])\n    except KeyError:\n        result = func(*args, **kwargs)\n        # Need to keep an iterator around\n        original, copy = itertools.tee(result)\n        _cache[func, id(node)] = list(copy)\n        return original\n", "tokens": ["astroid", "inference", "py", "def", "_cached_generator", "func", "instance", "args", "kwargs", "_cache", "noqa", "b006", "node", "args", "0", "try", "return", "iter", "_cache", "func", "id", "node", "except", "keyerror", "result", "func", "args", "kwargs", "need", "to", "keep", "an", "iterator", "around", "original", "copy", "itertools", "tee", "result", "_cache", "func", "id", "node", "list", "copy", "return", "original"], "doc_len": 47}
{"doc_id": "astroid/inference.py::infer_functiondef", "file_path": "astroid/inference.py", "class_name": null, "func_name": "infer_functiondef", "text": "文件路径: astroid/inference.py\ndef infer_functiondef(self, context=None):\n    if not self.decorators or not bases._is_property(self):\n        yield self\n        return dict(node=self, context=context)\n\n    prop_func = objects.Property(\n        function=self,\n        name=self.name,\n        doc=self.doc,\n        lineno=self.lineno,\n        parent=self.parent,\n        col_offset=self.col_offset,\n    )\n    prop_func.postinit(body=[], args=self.args)\n    yield prop_func\n    return dict(node=self, context=context)\n", "tokens": ["astroid", "inference", "py", "def", "infer_functiondef", "self", "context", "none", "if", "not", "self", "decorators", "or", "not", "bases", "_is_property", "self", "yield", "self", "return", "dict", "node", "self", "context", "context", "prop_func", "objects", "property", "function", "self", "name", "self", "name", "doc", "self", "doc", "lineno", "self", "lineno", "parent", "self", "parent", "col_offset", "self", "col_offset", "prop_func", "postinit", "body", "args", "self", "args", "yield", "prop_func", "return", "dict", "node", "self", "context", "context"], "doc_len": 59}
{"doc_id": "astroid/inference_tip.py::clear_inference_tip_cache", "file_path": "astroid/inference_tip.py", "class_name": null, "func_name": "clear_inference_tip_cache", "text": "文件路径: astroid/inference_tip.py\ndef clear_inference_tip_cache():\n    \"\"\"Clear the inference tips cache.\"\"\"\n    _cache.clear()\n", "tokens": ["astroid", "inference_tip", "py", "def", "clear_inference_tip_cache", "clear", "the", "inference", "tips", "cache", "_cache", "clear"], "doc_len": 12}
{"doc_id": "astroid/inference_tip.py::_inference_tip_cached", "file_path": "astroid/inference_tip.py", "class_name": null, "func_name": "_inference_tip_cached", "text": "文件路径: astroid/inference_tip.py\ndef _inference_tip_cached(func, instance, args, kwargs):\n    \"\"\"Cache decorator used for inference tips\"\"\"\n    node = args[0]\n    try:\n        result = _cache[func, node]\n    except KeyError:\n        result = _cache[func, node] = list(func(*args, **kwargs))\n    return iter(result)\n", "tokens": ["astroid", "inference_tip", "py", "def", "_inference_tip_cached", "func", "instance", "args", "kwargs", "cache", "decorator", "used", "for", "inference", "tips", "node", "args", "0", "try", "result", "_cache", "func", "node", "except", "keyerror", "result", "_cache", "func", "node", "list", "func", "args", "kwargs", "return", "iter", "result"], "doc_len": 36}
{"doc_id": "astroid/inference_tip.py::inference_tip", "file_path": "astroid/inference_tip.py", "class_name": null, "func_name": "inference_tip", "text": "文件路径: astroid/inference_tip.py\ndef inference_tip(infer_function: InferFn, raise_on_overwrite: bool = False) -> InferFn:\n    \"\"\"Given an instance specific inference function, return a function to be\n    given to AstroidManager().register_transform to set this inference function.\n\n    :param bool raise_on_overwrite: Raise an `InferenceOverwriteError`\n        if the inference tip will overwrite another. Used for debugging\n\n    Typical usage\n\n    .. sourcecode:: python\n\n       AstroidManager().register_transform(Call, inference_tip(infer_named_tuple),\n                                  predicate)\n\n    .. Note::\n\n        Using an inference tip will override\n        any previously set inference tip for the given\n        node. Use a predicate in the transform to prevent\n        excess overwrites.\n    \"\"\"\n\n    def transform(node: NodeNG, infer_function: InferFn = infer_function) -> NodeNG:\n        if (\n            raise_on_overwrite\n            and node._explicit_inference is not None\n            and node._explicit_inference is not infer_function\n        ):\n            raise InferenceOverwriteError(\n                \"Inference already set to {existing_inference}. \"\n                \"Trying to overwrite with {new_inference} for {node}\".format(\n                    existing_inference=infer_function,\n                    new_inference=node._explicit_inference,\n                    node=node,\n                )\n            )\n        # pylint: disable=no-value-for-parameter\n        node._explicit_inference = _inference_tip_cached(infer_function)\n        return node\n\n    return transform\n", "tokens": ["astroid", "inference_tip", "py", "def", "inference_tip", "infer_function", "inferfn", "raise_on_overwrite", "bool", "false", "inferfn", "given", "an", "instance", "specific", "inference", "function", "return", "a", "function", "to", "be", "given", "to", "astroidmanager", "register_transform", "to", "set", "this", "inference", "function", "param", "bool", "raise_on_overwrite", "raise", "an", "inferenceoverwriteerror", "if", "the", "inference", "tip", "will", "overwrite", "another", "used", "for", "debugging", "typical", "usage", "sourcecode", "python", "astroidmanager", "register_transform", "call", "inference_tip", "infer_named_tuple", "predicate", "note", "using", "an", "inference", "tip", "will", "override", "any", "previously", "set", "inference", "tip", "for", "the", "given", "node", "use", "a", "predicate", "in", "the", "transform", "to", "prevent", "excess", "overwrites", "def", "transform", "node", "nodeng", "infer_function", "inferfn", "infer_function", "nodeng", "if", "raise_on_overwrite", "and", "node", "_explicit_inference", "is", "not", "none", "and", "node", "_explicit_inference", "is", "not", "infer_function", "raise", "inferenceoverwriteerror", "inference", "already", "set", "to", "existing_inference", "trying", "to", "overwrite", "with", "new_inference", "for", "node", "format", "existing_inference", "infer_function", "new_inference", "node", "_explicit_inference", "node", "node", "pylint", "disable", "no", "value", "for", "parameter", "node", "_explicit_inference", "_inference_tip_cached", "infer_function", "return", "node", "return", "transform"], "doc_len": 141}
{"doc_id": "astroid/manager.py::safe_repr", "file_path": "astroid/manager.py", "class_name": null, "func_name": "safe_repr", "text": "文件路径: astroid/manager.py\ndef safe_repr(obj):\n    try:\n        return repr(obj)\n    except Exception:  # pylint: disable=broad-except\n        return \"???\"\n", "tokens": ["astroid", "manager", "py", "def", "safe_repr", "obj", "try", "return", "repr", "obj", "except", "exception", "pylint", "disable", "broad", "except", "return"], "doc_len": 17}
{"doc_id": "astroid/manager.py::AstroidManager.__init__", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "__init__", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def __init__(self):\n        self.__dict__ = AstroidManager.brain\n        if not self.__dict__:\n            # NOTE: cache entries are added by the [re]builder\n            self.astroid_cache = {}\n            self._mod_file_cache = {}\n            self._failed_import_hooks = []\n            self.always_load_extensions = False\n            self.optimize_ast = False\n            self.extension_package_whitelist = set()\n            self._transform = TransformVisitor()\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "__init__", "self", "self", "__dict__", "astroidmanager", "brain", "if", "not", "self", "__dict__", "note", "cache", "entries", "are", "added", "by", "the", "re", "builder", "self", "astroid_cache", "self", "_mod_file_cache", "self", "_failed_import_hooks", "self", "always_load_extensions", "false", "self", "optimize_ast", "false", "self", "extension_package_whitelist", "set", "self", "_transform", "transformvisitor"], "doc_len": 42}
{"doc_id": "astroid/manager.py::AstroidManager.register_transform", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "register_transform", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def register_transform(self):\n        # This and unregister_transform below are exported for convenience\n        return self._transform.register_transform\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "register_transform", "self", "this", "and", "unregister_transform", "below", "are", "exported", "for", "convenience", "return", "self", "_transform", "register_transform"], "doc_len": 19}
{"doc_id": "astroid/manager.py::AstroidManager.unregister_transform", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "unregister_transform", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def unregister_transform(self):\n        return self._transform.unregister_transform\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "unregister_transform", "self", "return", "self", "_transform", "unregister_transform"], "doc_len": 11}
{"doc_id": "astroid/manager.py::AstroidManager.builtins_module", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "builtins_module", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def builtins_module(self):\n        return self.astroid_cache[\"builtins\"]\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "builtins_module", "self", "return", "self", "astroid_cache", "builtins"], "doc_len": 11}
{"doc_id": "astroid/manager.py::AstroidManager.visit_transforms", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "visit_transforms", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def visit_transforms(self, node):\n        \"\"\"Visit the transforms and apply them to the given *node*.\"\"\"\n        return self._transform.visit(node)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "visit_transforms", "self", "node", "visit", "the", "transforms", "and", "apply", "them", "to", "the", "given", "node", "return", "self", "_transform", "visit", "node"], "doc_len": 23}
{"doc_id": "astroid/manager.py::AstroidManager.ast_from_file", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "ast_from_file", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def ast_from_file(self, filepath, modname=None, fallback=True, source=False):\n        \"\"\"given a module name, return the astroid object\"\"\"\n        try:\n            filepath = get_source_file(filepath, include_no_ext=True)\n            source = True\n        except NoSourceFile:\n            pass\n        if modname is None:\n            try:\n                modname = \".\".join(modpath_from_file(filepath))\n            except ImportError:\n                modname = filepath\n        if (\n            modname in self.astroid_cache\n            and self.astroid_cache[modname].file == filepath\n        ):\n            return self.astroid_cache[modname]\n        if source:\n            # pylint: disable=import-outside-toplevel; circular import\n            from astroid.builder import AstroidBuilder\n\n            return AstroidBuilder(self).file_build(filepath, modname)\n        if fallback and modname:\n            return self.ast_from_module_name(modname)\n        raise AstroidBuildingError(\"Unable to build an AST for {path}.\", path=filepath)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "ast_from_file", "self", "filepath", "modname", "none", "fallback", "true", "source", "false", "given", "a", "module", "name", "return", "the", "astroid", "object", "try", "filepath", "get_source_file", "filepath", "include_no_ext", "true", "source", "true", "except", "nosourcefile", "pass", "if", "modname", "is", "none", "try", "modname", "join", "modpath_from_file", "filepath", "except", "importerror", "modname", "filepath", "if", "modname", "in", "self", "astroid_cache", "and", "self", "astroid_cache", "modname", "file", "filepath", "return", "self", "astroid_cache", "modname", "if", "source", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "astroidbuilder", "return", "astroidbuilder", "self", "file_build", "filepath", "modname", "if", "fallback", "and", "modname", "return", "self", "ast_from_module_name", "modname", "raise", "astroidbuildingerror", "unable", "to", "build", "an", "ast", "for", "path", "path", "filepath"], "doc_len": 100}
{"doc_id": "astroid/manager.py::AstroidManager.ast_from_string", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "ast_from_string", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def ast_from_string(self, data, modname=\"\", filepath=None):\n        \"\"\"Given some source code as a string, return its corresponding astroid object\"\"\"\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.builder import AstroidBuilder\n\n        return AstroidBuilder(self).string_build(data, modname, filepath)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "ast_from_string", "self", "data", "modname", "filepath", "none", "given", "some", "source", "code", "as", "a", "string", "return", "its", "corresponding", "astroid", "object", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "astroidbuilder", "return", "astroidbuilder", "self", "string_build", "data", "modname", "filepath"], "doc_len": 42}
{"doc_id": "astroid/manager.py::AstroidManager._build_stub_module", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "_build_stub_module", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def _build_stub_module(self, modname):\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.builder import AstroidBuilder\n\n        return AstroidBuilder(self).string_build(\"\", modname)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "_build_stub_module", "self", "modname", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "astroidbuilder", "return", "astroidbuilder", "self", "string_build", "modname"], "doc_len": 25}
{"doc_id": "astroid/manager.py::AstroidManager._build_namespace_module", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "_build_namespace_module", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def _build_namespace_module(self, modname: str, path: List[str]) -> \"nodes.Module\":\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.builder import build_namespace_package_module\n\n        return build_namespace_package_module(modname, path)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "_build_namespace_module", "self", "modname", "str", "path", "list", "str", "nodes", "module", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "build_namespace_package_module", "return", "build_namespace_package_module", "modname", "path"], "doc_len": 30}
{"doc_id": "astroid/manager.py::AstroidManager._can_load_extension", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "_can_load_extension", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def _can_load_extension(self, modname: str) -> bool:\n        if self.always_load_extensions:\n            return True\n        if is_standard_module(modname):\n            return True\n        return is_module_name_part_of_extension_package_whitelist(\n            modname, self.extension_package_whitelist\n        )\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "_can_load_extension", "self", "modname", "str", "bool", "if", "self", "always_load_extensions", "return", "true", "if", "is_standard_module", "modname", "return", "true", "return", "is_module_name_part_of_extension_package_whitelist", "modname", "self", "extension_package_whitelist"], "doc_len": 25}
{"doc_id": "astroid/manager.py::AstroidManager.ast_from_module_name", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "ast_from_module_name", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def ast_from_module_name(self, modname, context_file=None):\n        \"\"\"given a module name, return the astroid object\"\"\"\n        if modname in self.astroid_cache:\n            return self.astroid_cache[modname]\n        if modname == \"__main__\":\n            return self._build_stub_module(modname)\n        if context_file:\n            old_cwd = os.getcwd()\n            os.chdir(os.path.dirname(context_file))\n        try:\n            found_spec = self.file_from_module_name(modname, context_file)\n            if found_spec.type == spec.ModuleType.PY_ZIPMODULE:\n                module = self.zip_import_data(found_spec.location)\n                if module is not None:\n                    return module\n\n            elif found_spec.type in (\n                spec.ModuleType.C_BUILTIN,\n                spec.ModuleType.C_EXTENSION,\n            ):\n                if (\n                    found_spec.type == spec.ModuleType.C_EXTENSION\n                    and not self._can_load_extension(modname)\n                ):\n                    return self._build_stub_module(modname)\n                try:\n                    module = load_module_from_name(modname)\n                except Exception as e:\n                    raise AstroidImportError(\n                        \"Loading {modname} failed with:\\n{error}\",\n                        modname=modname,\n                        path=found_spec.location,\n                    ) from e\n                return self.ast_from_module(module, modname)\n\n            elif found_spec.type == spec.ModuleType.PY_COMPILED:\n                raise AstroidImportError(\n                    \"Unable to load compiled module {modname}.\",\n                    modname=modname,\n                    path=found_spec.location,\n                )\n\n            elif found_spec.type == spec.ModuleType.PY_NAMESPACE:\n                return self._build_namespace_module(\n                    modname, found_spec.submodule_search_locations\n                )\n            elif found_spec.type == spec.ModuleType.PY_FROZEN:\n                return self._build_stub_module(modname)\n\n            if found_spec.location is None:\n                raise AstroidImportError(\n                    \"Can't find a file for module {modname}.\", modname=modname\n                )\n\n            return self.ast_from_file(found_spec.location, modname, fallback=False)\n        except AstroidBuildingError as e:\n            for hook in self._failed_import_hooks:\n                try:\n                    return hook(modname)\n                except AstroidBuildingError:\n                    pass\n            raise e\n        finally:\n            if context_file:\n                os.chdir(old_cwd)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "ast_from_module_name", "self", "modname", "context_file", "none", "given", "a", "module", "name", "return", "the", "astroid", "object", "if", "modname", "in", "self", "astroid_cache", "return", "self", "astroid_cache", "modname", "if", "modname", "__main__", "return", "self", "_build_stub_module", "modname", "if", "context_file", "old_cwd", "os", "getcwd", "os", "chdir", "os", "path", "dirname", "context_file", "try", "found_spec", "self", "file_from_module_name", "modname", "context_file", "if", "found_spec", "type", "spec", "moduletype", "py_zipmodule", "module", "self", "zip_import_data", "found_spec", "location", "if", "module", "is", "not", "none", "return", "module", "elif", "found_spec", "type", "in", "spec", "moduletype", "c_builtin", "spec", "moduletype", "c_extension", "if", "found_spec", "type", "spec", "moduletype", "c_extension", "and", "not", "self", "_can_load_extension", "modname", "return", "self", "_build_stub_module", "modname", "try", "module", "load_module_from_name", "modname", "except", "exception", "as", "e", "raise", "astroidimporterror", "loading", "modname", "failed", "with", "n", "error", "modname", "modname", "path", "found_spec", "location", "from", "e", "return", "self", "ast_from_module", "module", "modname", "elif", "found_spec", "type", "spec", "moduletype", "py_compiled", "raise", "astroidimporterror", "unable", "to", "load", "compiled", "module", "modname", "modname", "modname", "path", "found_spec", "location", "elif", "found_spec", "type", "spec", "moduletype", "py_namespace", "return", "self", "_build_namespace_module", "modname", "found_spec", "submodule_search_locations", "elif", "found_spec", "type", "spec", "moduletype", "py_frozen", "return", "self", "_build_stub_module", "modname", "if", "found_spec", "location", "is", "none", "raise", "astroidimporterror", "can", "t", "find", "a", "file", "for", "module", "modname", "modname", "modname", "return", "self", "ast_from_file", "found_spec", "location", "modname", "fallback", "false", "except", "astroidbuildingerror", "as", "e", "for", "hook", "in", "self", "_failed_import_hooks", "try", "return", "hook", "modname", "except", "astroidbuildingerror", "pass", "raise", "e", "finally", "if", "context_file", "os", "chdir", "old_cwd"], "doc_len": 212}
{"doc_id": "astroid/manager.py::AstroidManager.zip_import_data", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "zip_import_data", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def zip_import_data(self, filepath):\n        if zipimport is None:\n            return None\n\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.builder import AstroidBuilder\n\n        builder = AstroidBuilder(self)\n        for ext in ZIP_IMPORT_EXTS:\n            try:\n                eggpath, resource = filepath.rsplit(ext + os.path.sep, 1)\n            except ValueError:\n                continue\n            try:\n                # pylint: disable-next=no-member\n                importer = zipimport.zipimporter(eggpath + ext)\n                zmodname = resource.replace(os.path.sep, \".\")\n                if importer.is_package(resource):\n                    zmodname = zmodname + \".__init__\"\n                module = builder.string_build(\n                    importer.get_source(resource), zmodname, filepath\n                )\n                return module\n            except Exception:  # pylint: disable=broad-except\n                continue\n        return None\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "zip_import_data", "self", "filepath", "if", "zipimport", "is", "none", "return", "none", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "astroidbuilder", "builder", "astroidbuilder", "self", "for", "ext", "in", "zip_import_exts", "try", "eggpath", "resource", "filepath", "rsplit", "ext", "os", "path", "sep", "1", "except", "valueerror", "continue", "try", "pylint", "disable", "next", "no", "member", "importer", "zipimport", "zipimporter", "eggpath", "ext", "zmodname", "resource", "replace", "os", "path", "sep", "if", "importer", "is_package", "resource", "zmodname", "zmodname", "__init__", "module", "builder", "string_build", "importer", "get_source", "resource", "zmodname", "filepath", "return", "module", "except", "exception", "pylint", "disable", "broad", "except", "continue", "return", "none"], "doc_len": 89}
{"doc_id": "astroid/manager.py::AstroidManager.file_from_module_name", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "file_from_module_name", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def file_from_module_name(self, modname, contextfile):\n        try:\n            value = self._mod_file_cache[(modname, contextfile)]\n        except KeyError:\n            try:\n                value = file_info_from_modpath(\n                    modname.split(\".\"), context_file=contextfile\n                )\n            except ImportError as e:\n                value = AstroidImportError(\n                    \"Failed to import module {modname} with error:\\n{error}.\",\n                    modname=modname,\n                    # we remove the traceback here to save on memory usage (since these exceptions are cached)\n                    error=e.with_traceback(None),\n                )\n            self._mod_file_cache[(modname, contextfile)] = value\n        if isinstance(value, AstroidBuildingError):\n            # we remove the traceback here to save on memory usage (since these exceptions are cached)\n            raise value.with_traceback(None)\n        return value\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "file_from_module_name", "self", "modname", "contextfile", "try", "value", "self", "_mod_file_cache", "modname", "contextfile", "except", "keyerror", "try", "value", "file_info_from_modpath", "modname", "split", "context_file", "contextfile", "except", "importerror", "as", "e", "value", "astroidimporterror", "failed", "to", "import", "module", "modname", "with", "error", "n", "error", "modname", "modname", "we", "remove", "the", "traceback", "here", "to", "save", "on", "memory", "usage", "since", "these", "exceptions", "are", "cached", "error", "e", "with_traceback", "none", "self", "_mod_file_cache", "modname", "contextfile", "value", "if", "isinstance", "value", "astroidbuildingerror", "we", "remove", "the", "traceback", "here", "to", "save", "on", "memory", "usage", "since", "these", "exceptions", "are", "cached", "raise", "value", "with_traceback", "none", "return", "value"], "doc_len": 90}
{"doc_id": "astroid/manager.py::AstroidManager.ast_from_module", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "ast_from_module", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def ast_from_module(self, module: types.ModuleType, modname: Optional[str] = None):\n        \"\"\"given an imported module, return the astroid object\"\"\"\n        modname = modname or module.__name__\n        if modname in self.astroid_cache:\n            return self.astroid_cache[modname]\n        try:\n            # some builtin modules don't have __file__ attribute\n            filepath = module.__file__\n            if is_python_source(filepath):\n                return self.ast_from_file(filepath, modname)\n        except AttributeError:\n            pass\n\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid.builder import AstroidBuilder\n\n        return AstroidBuilder(self).module_build(module, modname)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "ast_from_module", "self", "module", "types", "moduletype", "modname", "optional", "str", "none", "given", "an", "imported", "module", "return", "the", "astroid", "object", "modname", "modname", "or", "module", "__name__", "if", "modname", "in", "self", "astroid_cache", "return", "self", "astroid_cache", "modname", "try", "some", "builtin", "modules", "don", "t", "have", "__file__", "attribute", "filepath", "module", "__file__", "if", "is_python_source", "filepath", "return", "self", "ast_from_file", "filepath", "modname", "except", "attributeerror", "pass", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "builder", "import", "astroidbuilder", "return", "astroidbuilder", "self", "module_build", "module", "modname"], "doc_len": 77}
{"doc_id": "astroid/manager.py::AstroidManager.ast_from_class", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "ast_from_class", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def ast_from_class(self, klass, modname=None):\n        \"\"\"get astroid for the given class\"\"\"\n        if modname is None:\n            try:\n                modname = klass.__module__\n            except AttributeError as exc:\n                raise AstroidBuildingError(\n                    \"Unable to get module for class {class_name}.\",\n                    cls=klass,\n                    class_repr=safe_repr(klass),\n                    modname=modname,\n                ) from exc\n        modastroid = self.ast_from_module_name(modname)\n        return modastroid.getattr(klass.__name__)[0]  # XXX\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "ast_from_class", "self", "klass", "modname", "none", "get", "astroid", "for", "the", "given", "class", "if", "modname", "is", "none", "try", "modname", "klass", "__module__", "except", "attributeerror", "as", "exc", "raise", "astroidbuildingerror", "unable", "to", "get", "module", "for", "class", "class_name", "cls", "klass", "class_repr", "safe_repr", "klass", "modname", "modname", "from", "exc", "modastroid", "self", "ast_from_module_name", "modname", "return", "modastroid", "getattr", "klass", "__name__", "0", "xxx"], "doc_len": 57}
{"doc_id": "astroid/manager.py::AstroidManager.infer_ast_from_something", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "infer_ast_from_something", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def infer_ast_from_something(self, obj, context=None):\n        \"\"\"infer astroid for the given class\"\"\"\n        if hasattr(obj, \"__class__\") and not isinstance(obj, type):\n            klass = obj.__class__\n        else:\n            klass = obj\n        try:\n            modname = klass.__module__\n        except AttributeError as exc:\n            raise AstroidBuildingError(\n                \"Unable to get module for {class_repr}.\",\n                cls=klass,\n                class_repr=safe_repr(klass),\n            ) from exc\n        except Exception as exc:\n            raise AstroidImportError(\n                \"Unexpected error while retrieving module for {class_repr}:\\n\"\n                \"{error}\",\n                cls=klass,\n                class_repr=safe_repr(klass),\n            ) from exc\n        try:\n            name = klass.__name__\n        except AttributeError as exc:\n            raise AstroidBuildingError(\n                \"Unable to get name for {class_repr}:\\n\",\n                cls=klass,\n                class_repr=safe_repr(klass),\n            ) from exc\n        except Exception as exc:\n            raise AstroidImportError(\n                \"Unexpected error while retrieving name for {class_repr}:\\n\" \"{error}\",\n                cls=klass,\n                class_repr=safe_repr(klass),\n            ) from exc\n        # take care, on living object __module__ is regularly wrong :(\n        modastroid = self.ast_from_module_name(modname)\n        if klass is obj:\n            for inferred in modastroid.igetattr(name, context):\n                yield inferred\n        else:\n            for inferred in modastroid.igetattr(name, context):\n                yield inferred.instantiate_class()\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "infer_ast_from_something", "self", "obj", "context", "none", "infer", "astroid", "for", "the", "given", "class", "if", "hasattr", "obj", "__class__", "and", "not", "isinstance", "obj", "type", "klass", "obj", "__class__", "else", "klass", "obj", "try", "modname", "klass", "__module__", "except", "attributeerror", "as", "exc", "raise", "astroidbuildingerror", "unable", "to", "get", "module", "for", "class_repr", "cls", "klass", "class_repr", "safe_repr", "klass", "from", "exc", "except", "exception", "as", "exc", "raise", "astroidimporterror", "unexpected", "error", "while", "retrieving", "module", "for", "class_repr", "n", "error", "cls", "klass", "class_repr", "safe_repr", "klass", "from", "exc", "try", "name", "klass", "__name__", "except", "attributeerror", "as", "exc", "raise", "astroidbuildingerror", "unable", "to", "get", "name", "for", "class_repr", "n", "cls", "klass", "class_repr", "safe_repr", "klass", "from", "exc", "except", "exception", "as", "exc", "raise", "astroidimporterror", "unexpected", "error", "while", "retrieving", "name", "for", "class_repr", "n", "error", "cls", "klass", "class_repr", "safe_repr", "klass", "from", "exc", "take", "care", "on", "living", "object", "__module__", "is", "regularly", "wrong", "modastroid", "self", "ast_from_module_name", "modname", "if", "klass", "is", "obj", "for", "inferred", "in", "modastroid", "igetattr", "name", "context", "yield", "inferred", "else", "for", "inferred", "in", "modastroid", "igetattr", "name", "context", "yield", "inferred", "instantiate_class"], "doc_len": 159}
{"doc_id": "astroid/manager.py::AstroidManager.register_failed_import_hook", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "register_failed_import_hook", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def register_failed_import_hook(self, hook):\n        \"\"\"Registers a hook to resolve imports that cannot be found otherwise.\n\n        `hook` must be a function that accepts a single argument `modname` which\n        contains the name of the module or package that could not be imported.\n        If `hook` can resolve the import, must return a node of type `astroid.Module`,\n        otherwise, it must raise `AstroidBuildingError`.\n        \"\"\"\n        self._failed_import_hooks.append(hook)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "register_failed_import_hook", "self", "hook", "registers", "a", "hook", "to", "resolve", "imports", "that", "cannot", "be", "found", "otherwise", "hook", "must", "be", "a", "function", "that", "accepts", "a", "single", "argument", "modname", "which", "contains", "the", "name", "of", "the", "module", "or", "package", "that", "could", "not", "be", "imported", "if", "hook", "can", "resolve", "the", "import", "must", "return", "a", "node", "of", "type", "astroid", "module", "otherwise", "it", "must", "raise", "astroidbuildingerror", "self", "_failed_import_hooks", "append", "hook"], "doc_len": 67}
{"doc_id": "astroid/manager.py::AstroidManager.cache_module", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "cache_module", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def cache_module(self, module):\n        \"\"\"Cache a module if no module with the same name is known yet.\"\"\"\n        self.astroid_cache.setdefault(module.name, module)\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "cache_module", "self", "module", "cache", "a", "module", "if", "no", "module", "with", "the", "same", "name", "is", "known", "yet", "self", "astroid_cache", "setdefault", "module", "name", "module"], "doc_len": 27}
{"doc_id": "astroid/manager.py::AstroidManager.bootstrap", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "bootstrap", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def bootstrap(self):\n        \"\"\"Bootstrap the required AST modules needed for the manager to work\n\n        The bootstrap usually involves building the AST for the builtins\n        module, which is required by the rest of astroid to work correctly.\n        \"\"\"\n        from astroid import raw_building  # pylint: disable=import-outside-toplevel\n\n        raw_building._astroid_bootstrapping()\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "bootstrap", "self", "bootstrap", "the", "required", "ast", "modules", "needed", "for", "the", "manager", "to", "work", "the", "bootstrap", "usually", "involves", "building", "the", "ast", "for", "the", "builtins", "module", "which", "is", "required", "by", "the", "rest", "of", "astroid", "to", "work", "correctly", "from", "astroid", "import", "raw_building", "pylint", "disable", "import", "outside", "toplevel", "raw_building", "_astroid_bootstrapping"], "doc_len": 51}
{"doc_id": "astroid/manager.py::AstroidManager.clear_cache", "file_path": "astroid/manager.py", "class_name": "AstroidManager", "func_name": "clear_cache", "text": "文件路径: astroid/manager.py, 类名: AstroidManager\n    def clear_cache(self):\n        \"\"\"Clear the underlying cache. Also bootstraps the builtins module.\"\"\"\n        self.astroid_cache.clear()\n        self.bootstrap()\n", "tokens": ["astroid", "manager", "py", "astroidmanager", "def", "clear_cache", "self", "clear", "the", "underlying", "cache", "also", "bootstraps", "the", "builtins", "module", "self", "astroid_cache", "clear", "self", "bootstrap"], "doc_len": 21}
{"doc_id": "astroid/mixins.py::BlockRangeMixIn.blockstart_tolineno", "file_path": "astroid/mixins.py", "class_name": "BlockRangeMixIn", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/mixins.py, 类名: BlockRangeMixIn\n    def blockstart_tolineno(self):\n        return self.lineno\n", "tokens": ["astroid", "mixins", "py", "blockrangemixin", "def", "blockstart_tolineno", "self", "return", "self", "lineno"], "doc_len": 10}
{"doc_id": "astroid/mixins.py::BlockRangeMixIn._elsed_block_range", "file_path": "astroid/mixins.py", "class_name": "BlockRangeMixIn", "func_name": "_elsed_block_range", "text": "文件路径: astroid/mixins.py, 类名: BlockRangeMixIn\n    def _elsed_block_range(self, lineno, orelse, last=None):\n        \"\"\"handle block line numbers range for try/finally, for, if and while\n        statements\n        \"\"\"\n        if lineno == self.fromlineno:\n            return lineno, lineno\n        if orelse:\n            if lineno >= orelse[0].fromlineno:\n                return lineno, orelse[-1].tolineno\n            return lineno, orelse[0].fromlineno - 1\n        return lineno, last or self.tolineno\n", "tokens": ["astroid", "mixins", "py", "blockrangemixin", "def", "_elsed_block_range", "self", "lineno", "orelse", "last", "none", "handle", "block", "line", "numbers", "range", "for", "try", "finally", "for", "if", "and", "while", "statements", "if", "lineno", "self", "fromlineno", "return", "lineno", "lineno", "if", "orelse", "if", "lineno", "orelse", "0", "fromlineno", "return", "lineno", "orelse", "1", "tolineno", "return", "lineno", "orelse", "0", "fromlineno", "1", "return", "lineno", "last", "or", "self", "tolineno"], "doc_len": 55}
{"doc_id": "astroid/mixins.py::FilterStmtsMixin._get_filtered_stmts", "file_path": "astroid/mixins.py", "class_name": "FilterStmtsMixin", "func_name": "_get_filtered_stmts", "text": "文件路径: astroid/mixins.py, 类名: FilterStmtsMixin\n    def _get_filtered_stmts(self, _, node, _stmts, mystmt: Optional[\"nodes.Statement\"]):\n        \"\"\"method used in _filter_stmts to get statements and trigger break\"\"\"\n        if self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keep\n            # current node (gen exp, list comp)\n            return [node], True\n        return _stmts, False\n", "tokens": ["astroid", "mixins", "py", "filterstmtsmixin", "def", "_get_filtered_stmts", "self", "_", "node", "_stmts", "mystmt", "optional", "nodes", "statement", "method", "used", "in", "_filter_stmts", "to", "get", "statements", "and", "trigger", "break", "if", "self", "statement", "future", "true", "is", "mystmt", "original", "node", "s", "statement", "is", "the", "assignment", "only", "keep", "current", "node", "gen", "exp", "list", "comp", "return", "node", "true", "return", "_stmts", "false"], "doc_len": 52}
{"doc_id": "astroid/mixins.py::FilterStmtsMixin.assign_type", "file_path": "astroid/mixins.py", "class_name": "FilterStmtsMixin", "func_name": "assign_type", "text": "文件路径: astroid/mixins.py, 类名: FilterStmtsMixin\n    def assign_type(self):\n        return self\n", "tokens": ["astroid", "mixins", "py", "filterstmtsmixin", "def", "assign_type", "self", "return", "self"], "doc_len": 9}
{"doc_id": "astroid/mixins.py::AssignTypeMixin.assign_type", "file_path": "astroid/mixins.py", "class_name": "AssignTypeMixin", "func_name": "assign_type", "text": "文件路径: astroid/mixins.py, 类名: AssignTypeMixin\n    def assign_type(self):\n        return self\n", "tokens": ["astroid", "mixins", "py", "assigntypemixin", "def", "assign_type", "self", "return", "self"], "doc_len": 9}
{"doc_id": "astroid/mixins.py::AssignTypeMixin._get_filtered_stmts", "file_path": "astroid/mixins.py", "class_name": "AssignTypeMixin", "func_name": "_get_filtered_stmts", "text": "文件路径: astroid/mixins.py, 类名: AssignTypeMixin\n    def _get_filtered_stmts(\n        self, lookup_node, node, _stmts, mystmt: Optional[\"nodes.Statement\"]\n    ):\n        \"\"\"method used in filter_stmts\"\"\"\n        if self is mystmt:\n            return _stmts, True\n        if self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keep\n            # current node (gen exp, list comp)\n            return [node], True\n        return _stmts, False\n", "tokens": ["astroid", "mixins", "py", "assigntypemixin", "def", "_get_filtered_stmts", "self", "lookup_node", "node", "_stmts", "mystmt", "optional", "nodes", "statement", "method", "used", "in", "filter_stmts", "if", "self", "is", "mystmt", "return", "_stmts", "true", "if", "self", "statement", "future", "true", "is", "mystmt", "original", "node", "s", "statement", "is", "the", "assignment", "only", "keep", "current", "node", "gen", "exp", "list", "comp", "return", "node", "true", "return", "_stmts", "false"], "doc_len": 53}
{"doc_id": "astroid/mixins.py::ParentAssignTypeMixin.assign_type", "file_path": "astroid/mixins.py", "class_name": "ParentAssignTypeMixin", "func_name": "assign_type", "text": "文件路径: astroid/mixins.py, 类名: ParentAssignTypeMixin\n    def assign_type(self):\n        return self.parent.assign_type()\n", "tokens": ["astroid", "mixins", "py", "parentassigntypemixin", "def", "assign_type", "self", "return", "self", "parent", "assign_type"], "doc_len": 11}
{"doc_id": "astroid/mixins.py::ImportFromMixin._infer_name", "file_path": "astroid/mixins.py", "class_name": "ImportFromMixin", "func_name": "_infer_name", "text": "文件路径: astroid/mixins.py, 类名: ImportFromMixin\n    def _infer_name(self, frame, name):\n        return name\n", "tokens": ["astroid", "mixins", "py", "importfrommixin", "def", "_infer_name", "self", "frame", "name", "return", "name"], "doc_len": 11}
{"doc_id": "astroid/mixins.py::ImportFromMixin.do_import_module", "file_path": "astroid/mixins.py", "class_name": "ImportFromMixin", "func_name": "do_import_module", "text": "文件路径: astroid/mixins.py, 类名: ImportFromMixin\n    def do_import_module(self, modname=None):\n        \"\"\"return the ast for a module whose name is <modname> imported by <self>\"\"\"\n        # handle special case where we are on a package node importing a module\n        # using the same name as the package, which may end in an infinite loop\n        # on relative imports\n        # XXX: no more needed ?\n        mymodule = self.root()\n        level = getattr(self, \"level\", None)  # Import as no level\n        if modname is None:\n            modname = self.modname\n        # XXX we should investigate deeper if we really want to check\n        # importing itself: modname and mymodule.name be relative or absolute\n        if mymodule.relative_to_absolute_name(modname, level) == mymodule.name:\n            # FIXME: we used to raise InferenceError here, but why ?\n            return mymodule\n\n        return mymodule.import_module(\n            modname, level=level, relative_only=level and level >= 1\n        )\n", "tokens": ["astroid", "mixins", "py", "importfrommixin", "def", "do_import_module", "self", "modname", "none", "return", "the", "ast", "for", "a", "module", "whose", "name", "is", "modname", "imported", "by", "self", "handle", "special", "case", "where", "we", "are", "on", "a", "package", "node", "importing", "a", "module", "using", "the", "same", "name", "as", "the", "package", "which", "may", "end", "in", "an", "infinite", "loop", "on", "relative", "imports", "xxx", "no", "more", "needed", "mymodule", "self", "root", "level", "getattr", "self", "level", "none", "import", "as", "no", "level", "if", "modname", "is", "none", "modname", "self", "modname", "xxx", "we", "should", "investigate", "deeper", "if", "we", "really", "want", "to", "check", "importing", "itself", "modname", "and", "mymodule", "name", "be", "relative", "or", "absolute", "if", "mymodule", "relative_to_absolute_name", "modname", "level", "mymodule", "name", "fixme", "we", "used", "to", "raise", "inferenceerror", "here", "but", "why", "return", "mymodule", "return", "mymodule", "import_module", "modname", "level", "level", "relative_only", "level", "and", "level", "1"], "doc_len": 125}
{"doc_id": "astroid/mixins.py::ImportFromMixin.real_name", "file_path": "astroid/mixins.py", "class_name": "ImportFromMixin", "func_name": "real_name", "text": "文件路径: astroid/mixins.py, 类名: ImportFromMixin\n    def real_name(self, asname):\n        \"\"\"get name from 'as' name\"\"\"\n        for name, _asname in self.names:\n            if name == \"*\":\n                return asname\n            if not _asname:\n                name = name.split(\".\", 1)[0]\n                _asname = name\n            if asname == _asname:\n                return name\n        raise AttributeInferenceError(\n            \"Could not find original name for {attribute} in {target!r}\",\n            target=self,\n            attribute=asname,\n        )\n", "tokens": ["astroid", "mixins", "py", "importfrommixin", "def", "real_name", "self", "asname", "get", "name", "from", "as", "name", "for", "name", "_asname", "in", "self", "names", "if", "name", "return", "asname", "if", "not", "_asname", "name", "name", "split", "1", "0", "_asname", "name", "if", "asname", "_asname", "return", "name", "raise", "attributeinferenceerror", "could", "not", "find", "original", "name", "for", "attribute", "in", "target", "r", "target", "self", "attribute", "asname"], "doc_len": 54}
{"doc_id": "astroid/mixins.py::MultiLineBlockMixin._multi_line_blocks", "file_path": "astroid/mixins.py", "class_name": "MultiLineBlockMixin", "func_name": "_multi_line_blocks", "text": "文件路径: astroid/mixins.py, 类名: MultiLineBlockMixin\n    def _multi_line_blocks(self):\n        return tuple(getattr(self, field) for field in self._multi_line_block_fields)\n", "tokens": ["astroid", "mixins", "py", "multilineblockmixin", "def", "_multi_line_blocks", "self", "return", "tuple", "getattr", "self", "field", "for", "field", "in", "self", "_multi_line_block_fields"], "doc_len": 17}
{"doc_id": "astroid/mixins.py::MultiLineBlockMixin._get_return_nodes_skip_functions", "file_path": "astroid/mixins.py", "class_name": "MultiLineBlockMixin", "func_name": "_get_return_nodes_skip_functions", "text": "文件路径: astroid/mixins.py, 类名: MultiLineBlockMixin\n    def _get_return_nodes_skip_functions(self):\n        for block in self._multi_line_blocks:\n            for child_node in block:\n                if child_node.is_function:\n                    continue\n                yield from child_node._get_return_nodes_skip_functions()\n", "tokens": ["astroid", "mixins", "py", "multilineblockmixin", "def", "_get_return_nodes_skip_functions", "self", "for", "block", "in", "self", "_multi_line_blocks", "for", "child_node", "in", "block", "if", "child_node", "is_function", "continue", "yield", "from", "child_node", "_get_return_nodes_skip_functions"], "doc_len": 24}
{"doc_id": "astroid/mixins.py::MultiLineBlockMixin._get_yield_nodes_skip_lambdas", "file_path": "astroid/mixins.py", "class_name": "MultiLineBlockMixin", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/mixins.py, 类名: MultiLineBlockMixin\n    def _get_yield_nodes_skip_lambdas(self):\n        for block in self._multi_line_blocks:\n            for child_node in block:\n                if child_node.is_lambda:\n                    continue\n                yield from child_node._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "mixins", "py", "multilineblockmixin", "def", "_get_yield_nodes_skip_lambdas", "self", "for", "block", "in", "self", "_multi_line_blocks", "for", "child_node", "in", "block", "if", "child_node", "is_lambda", "continue", "yield", "from", "child_node", "_get_yield_nodes_skip_lambdas"], "doc_len": 24}
{"doc_id": "astroid/mixins.py::MultiLineBlockMixin._get_assign_nodes", "file_path": "astroid/mixins.py", "class_name": "MultiLineBlockMixin", "func_name": "_get_assign_nodes", "text": "文件路径: astroid/mixins.py, 类名: MultiLineBlockMixin\n    def _get_assign_nodes(self):\n        children_assign_nodes = (\n            child_node._get_assign_nodes()\n            for block in self._multi_line_blocks\n            for child_node in block\n        )\n        return list(itertools.chain.from_iterable(children_assign_nodes))\n", "tokens": ["astroid", "mixins", "py", "multilineblockmixin", "def", "_get_assign_nodes", "self", "children_assign_nodes", "child_node", "_get_assign_nodes", "for", "block", "in", "self", "_multi_line_blocks", "for", "child_node", "in", "block", "return", "list", "itertools", "chain", "from_iterable", "children_assign_nodes"], "doc_len": 25}
{"doc_id": "astroid/mixins.py::NoChildrenMixin.get_children", "file_path": "astroid/mixins.py", "class_name": "NoChildrenMixin", "func_name": "get_children", "text": "文件路径: astroid/mixins.py, 类名: NoChildrenMixin\n    def get_children(self):\n        yield from ()\n", "tokens": ["astroid", "mixins", "py", "nochildrenmixin", "def", "get_children", "self", "yield", "from"], "doc_len": 9}
{"doc_id": "astroid/modutils.py::_normalize_path", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_normalize_path", "text": "文件路径: astroid/modutils.py\ndef _normalize_path(path: str) -> str:\n    \"\"\"Resolve symlinks in path and convert to absolute path.\n\n    Note that environment variables and ~ in the path need to be expanded in\n    advance.\n\n    This can be cached by using _cache_normalize_path.\n    \"\"\"\n    return os.path.normcase(os.path.realpath(path))\n", "tokens": ["astroid", "modutils", "py", "def", "_normalize_path", "path", "str", "str", "resolve", "symlinks", "in", "path", "and", "convert", "to", "absolute", "path", "note", "that", "environment", "variables", "and", "in", "the", "path", "need", "to", "be", "expanded", "in", "advance", "this", "can", "be", "cached", "by", "using", "_cache_normalize_path", "return", "os", "path", "normcase", "os", "path", "realpath", "path"], "doc_len": 46}
{"doc_id": "astroid/modutils.py::_path_from_filename", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_path_from_filename", "text": "文件路径: astroid/modutils.py\ndef _path_from_filename(filename, is_jython=IS_JYTHON):\n    if not is_jython:\n        return filename\n    head, has_pyclass, _ = filename.partition(\"$py.class\")\n    if has_pyclass:\n        return head + \".py\"\n    return filename\n", "tokens": ["astroid", "modutils", "py", "def", "_path_from_filename", "filename", "is_jython", "is_jython", "if", "not", "is_jython", "return", "filename", "head", "has_pyclass", "_", "filename", "partition", "py", "class", "if", "has_pyclass", "return", "head", "py", "return", "filename"], "doc_len": 27}
{"doc_id": "astroid/modutils.py::_handle_blacklist", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_handle_blacklist", "text": "文件路径: astroid/modutils.py\ndef _handle_blacklist(blacklist, dirnames, filenames):\n    \"\"\"remove files/directories in the black list\n\n    dirnames/filenames are usually from os.walk\n    \"\"\"\n    for norecurs in blacklist:\n        if norecurs in dirnames:\n            dirnames.remove(norecurs)\n        elif norecurs in filenames:\n            filenames.remove(norecurs)\n", "tokens": ["astroid", "modutils", "py", "def", "_handle_blacklist", "blacklist", "dirnames", "filenames", "remove", "files", "directories", "in", "the", "black", "list", "dirnames", "filenames", "are", "usually", "from", "os", "walk", "for", "norecurs", "in", "blacklist", "if", "norecurs", "in", "dirnames", "dirnames", "remove", "norecurs", "elif", "norecurs", "in", "filenames", "filenames", "remove", "norecurs"], "doc_len": 40}
{"doc_id": "astroid/modutils.py::_cache_normalize_path", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_cache_normalize_path", "text": "文件路径: astroid/modutils.py\ndef _cache_normalize_path(path: str) -> str:\n    \"\"\"Normalize path with caching.\"\"\"\n    # _module_file calls abspath on every path in sys.path every time it's\n    # called; on a larger codebase this easily adds up to half a second just\n    # assembling path components. This cache alleviates that.\n    try:\n        return _NORM_PATH_CACHE[path]\n    except KeyError:\n        if not path:  # don't cache result for ''\n            return _normalize_path(path)\n        result = _NORM_PATH_CACHE[path] = _normalize_path(path)\n        return result\n", "tokens": ["astroid", "modutils", "py", "def", "_cache_normalize_path", "path", "str", "str", "normalize", "path", "with", "caching", "_module_file", "calls", "abspath", "on", "every", "path", "in", "sys", "path", "every", "time", "it", "s", "called", "on", "a", "larger", "codebase", "this", "easily", "adds", "up", "to", "half", "a", "second", "just", "assembling", "path", "components", "this", "cache", "alleviates", "that", "try", "return", "_norm_path_cache", "path", "except", "keyerror", "if", "not", "path", "don", "t", "cache", "result", "for", "return", "_normalize_path", "path", "result", "_norm_path_cache", "path", "_normalize_path", "path", "return", "result"], "doc_len": 70}
{"doc_id": "astroid/modutils.py::load_module_from_name", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "load_module_from_name", "text": "文件路径: astroid/modutils.py\ndef load_module_from_name(dotted_name: str) -> types.ModuleType:\n    \"\"\"Load a Python module from its name.\n\n    :type dotted_name: str\n    :param dotted_name: python name of a module or package\n\n    :raise ImportError: if the module or package is not found\n\n    :rtype: module\n    :return: the loaded module\n    \"\"\"\n    try:\n        return sys.modules[dotted_name]\n    except KeyError:\n        pass\n\n    return importlib.import_module(dotted_name)\n", "tokens": ["astroid", "modutils", "py", "def", "load_module_from_name", "dotted_name", "str", "types", "moduletype", "load", "a", "python", "module", "from", "its", "name", "type", "dotted_name", "str", "param", "dotted_name", "python", "name", "of", "a", "module", "or", "package", "raise", "importerror", "if", "the", "module", "or", "package", "is", "not", "found", "rtype", "module", "return", "the", "loaded", "module", "try", "return", "sys", "modules", "dotted_name", "except", "keyerror", "pass", "return", "importlib", "import_module", "dotted_name"], "doc_len": 56}
{"doc_id": "astroid/modutils.py::load_module_from_modpath", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "load_module_from_modpath", "text": "文件路径: astroid/modutils.py\ndef load_module_from_modpath(parts):\n    \"\"\"Load a python module from its split name.\n\n    :type parts: list(str) or tuple(str)\n    :param parts:\n      python name of a module or package split on '.'\n\n    :raise ImportError: if the module or package is not found\n\n    :rtype: module\n    :return: the loaded module\n    \"\"\"\n    return load_module_from_name(\".\".join(parts))\n", "tokens": ["astroid", "modutils", "py", "def", "load_module_from_modpath", "parts", "load", "a", "python", "module", "from", "its", "split", "name", "type", "parts", "list", "str", "or", "tuple", "str", "param", "parts", "python", "name", "of", "a", "module", "or", "package", "split", "on", "raise", "importerror", "if", "the", "module", "or", "package", "is", "not", "found", "rtype", "module", "return", "the", "loaded", "module", "return", "load_module_from_name", "join", "parts"], "doc_len": 52}
{"doc_id": "astroid/modutils.py::load_module_from_file", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "load_module_from_file", "text": "文件路径: astroid/modutils.py\ndef load_module_from_file(filepath: str):\n    \"\"\"Load a Python module from it's path.\n\n    :type filepath: str\n    :param filepath: path to the python module or package\n\n    :raise ImportError: if the module or package is not found\n\n    :rtype: module\n    :return: the loaded module\n    \"\"\"\n    modpath = modpath_from_file(filepath)\n    return load_module_from_modpath(modpath)\n", "tokens": ["astroid", "modutils", "py", "def", "load_module_from_file", "filepath", "str", "load", "a", "python", "module", "from", "it", "s", "path", "type", "filepath", "str", "param", "filepath", "path", "to", "the", "python", "module", "or", "package", "raise", "importerror", "if", "the", "module", "or", "package", "is", "not", "found", "rtype", "module", "return", "the", "loaded", "module", "modpath", "modpath_from_file", "filepath", "return", "load_module_from_modpath", "modpath"], "doc_len": 49}
{"doc_id": "astroid/modutils.py::check_modpath_has_init", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "check_modpath_has_init", "text": "文件路径: astroid/modutils.py\ndef check_modpath_has_init(path, mod_path):\n    \"\"\"check there are some __init__.py all along the way\"\"\"\n    modpath = []\n    for part in mod_path:\n        modpath.append(part)\n        path = os.path.join(path, part)\n        if not _has_init(path):\n            old_namespace = util.is_namespace(\".\".join(modpath))\n            if not old_namespace:\n                return False\n    return True\n", "tokens": ["astroid", "modutils", "py", "def", "check_modpath_has_init", "path", "mod_path", "check", "there", "are", "some", "__init__", "py", "all", "along", "the", "way", "modpath", "for", "part", "in", "mod_path", "modpath", "append", "part", "path", "os", "path", "join", "path", "part", "if", "not", "_has_init", "path", "old_namespace", "util", "is_namespace", "join", "modpath", "if", "not", "old_namespace", "return", "false", "return", "true"], "doc_len": 47}
{"doc_id": "astroid/modutils.py::_get_relative_base_path", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_get_relative_base_path", "text": "文件路径: astroid/modutils.py\ndef _get_relative_base_path(filename, path_to_check):\n    \"\"\"Extracts the relative mod path of the file to import from\n\n    Check if a file is within the passed in path and if so, returns the\n    relative mod path from the one passed in.\n\n    If the filename is no in path_to_check, returns None\n\n    Note this function will look for both abs and realpath of the file,\n    this allows to find the relative base path even if the file is a\n    symlink of a file in the passed in path\n\n    Examples:\n        _get_relative_base_path(\"/a/b/c/d.py\", \"/a/b\") ->  [\"c\",\"d\"]\n        _get_relative_base_path(\"/a/b/c/d.py\", \"/dev\") ->  None\n    \"\"\"\n    importable_path = None\n    path_to_check = os.path.normcase(path_to_check)\n    abs_filename = os.path.abspath(filename)\n    if os.path.normcase(abs_filename).startswith(path_to_check):\n        importable_path = abs_filename\n\n    real_filename = os.path.realpath(filename)\n    if os.path.normcase(real_filename).startswith(path_to_check):\n        importable_path = real_filename\n\n    if importable_path:\n        base_path = os.path.splitext(importable_path)[0]\n        relative_base_path = base_path[len(path_to_check) :]\n        return [pkg for pkg in relative_base_path.split(os.sep) if pkg]\n\n    return None\n", "tokens": ["astroid", "modutils", "py", "def", "_get_relative_base_path", "filename", "path_to_check", "extracts", "the", "relative", "mod", "path", "of", "the", "file", "to", "import", "from", "check", "if", "a", "file", "is", "within", "the", "passed", "in", "path", "and", "if", "so", "returns", "the", "relative", "mod", "path", "from", "the", "one", "passed", "in", "if", "the", "filename", "is", "no", "in", "path_to_check", "returns", "none", "note", "this", "function", "will", "look", "for", "both", "abs", "and", "realpath", "of", "the", "file", "this", "allows", "to", "find", "the", "relative", "base", "path", "even", "if", "the", "file", "is", "a", "symlink", "of", "a", "file", "in", "the", "passed", "in", "path", "examples", "_get_relative_base_path", "a", "b", "c", "d", "py", "a", "b", "c", "d", "_get_relative_base_path", "a", "b", "c", "d", "py", "dev", "none", "importable_path", "none", "path_to_check", "os", "path", "normcase", "path_to_check", "abs_filename", "os", "path", "abspath", "filename", "if", "os", "path", "normcase", "abs_filename", "startswith", "path_to_check", "importable_path", "abs_filename", "real_filename", "os", "path", "realpath", "filename", "if", "os", "path", "normcase", "real_filename", "startswith", "path_to_check", "importable_path", "real_filename", "if", "importable_path", "base_path", "os", "path", "splitext", "importable_path", "0", "relative_base_path", "base_path", "len", "path_to_check", "return", "pkg", "for", "pkg", "in", "relative_base_path", "split", "os", "sep", "if", "pkg", "return", "none"], "doc_len": 165}
{"doc_id": "astroid/modutils.py::modpath_from_file_with_callback", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "modpath_from_file_with_callback", "text": "文件路径: astroid/modutils.py\ndef modpath_from_file_with_callback(filename, path=None, is_package_cb=None):\n    filename = os.path.expanduser(_path_from_filename(filename))\n    for pathname in itertools.chain(\n        path or [], map(_cache_normalize_path, sys.path), sys.path\n    ):\n        if not pathname:\n            continue\n        modpath = _get_relative_base_path(filename, pathname)\n        if not modpath:\n            continue\n        if is_package_cb(pathname, modpath[:-1]):\n            return modpath\n\n    raise ImportError(\n        \"Unable to find module for {} in {}\".format(filename, \", \\n\".join(sys.path))\n    )\n", "tokens": ["astroid", "modutils", "py", "def", "modpath_from_file_with_callback", "filename", "path", "none", "is_package_cb", "none", "filename", "os", "path", "expanduser", "_path_from_filename", "filename", "for", "pathname", "in", "itertools", "chain", "path", "or", "map", "_cache_normalize_path", "sys", "path", "sys", "path", "if", "not", "pathname", "continue", "modpath", "_get_relative_base_path", "filename", "pathname", "if", "not", "modpath", "continue", "if", "is_package_cb", "pathname", "modpath", "1", "return", "modpath", "raise", "importerror", "unable", "to", "find", "module", "for", "in", "format", "filename", "n", "join", "sys", "path"], "doc_len": 62}
{"doc_id": "astroid/modutils.py::modpath_from_file", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "modpath_from_file", "text": "文件路径: astroid/modutils.py\ndef modpath_from_file(filename, path=None):\n    \"\"\"Get the corresponding split module's name from a filename\n\n    This function will return the name of a module or package split on `.`.\n\n    :type filename: str\n    :param filename: file's path for which we want the module's name\n\n    :type Optional[List[str]] path:\n      Optional list of path where the module or package should be\n      searched (use sys.path if nothing or None is given)\n\n    :raise ImportError:\n      if the corresponding module's name has not been found\n\n    :rtype: list(str)\n    :return: the corresponding split module's name\n    \"\"\"\n    return modpath_from_file_with_callback(filename, path, check_modpath_has_init)\n", "tokens": ["astroid", "modutils", "py", "def", "modpath_from_file", "filename", "path", "none", "get", "the", "corresponding", "split", "module", "s", "name", "from", "a", "filename", "this", "function", "will", "return", "the", "name", "of", "a", "module", "or", "package", "split", "on", "type", "filename", "str", "param", "filename", "file", "s", "path", "for", "which", "we", "want", "the", "module", "s", "name", "type", "optional", "list", "str", "path", "optional", "list", "of", "path", "where", "the", "module", "or", "package", "should", "be", "searched", "use", "sys", "path", "if", "nothing", "or", "none", "is", "given", "raise", "importerror", "if", "the", "corresponding", "module", "s", "name", "has", "not", "been", "found", "rtype", "list", "str", "return", "the", "corresponding", "split", "module", "s", "name", "return", "modpath_from_file_with_callback", "filename", "path", "check_modpath_has_init"], "doc_len": 100}
{"doc_id": "astroid/modutils.py::file_from_modpath", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "file_from_modpath", "text": "文件路径: astroid/modutils.py\ndef file_from_modpath(modpath, path=None, context_file=None):\n    return file_info_from_modpath(modpath, path, context_file).location\n", "tokens": ["astroid", "modutils", "py", "def", "file_from_modpath", "modpath", "path", "none", "context_file", "none", "return", "file_info_from_modpath", "modpath", "path", "context_file", "location"], "doc_len": 16}
{"doc_id": "astroid/modutils.py::file_info_from_modpath", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "file_info_from_modpath", "text": "文件路径: astroid/modutils.py\ndef file_info_from_modpath(modpath, path=None, context_file=None):\n    \"\"\"given a mod path (i.e. split module / package name), return the\n    corresponding file, giving priority to source file over precompiled\n    file if it exists\n\n    :type modpath: list or tuple\n    :param modpath:\n      split module's name (i.e name of a module or package split\n      on '.')\n      (this means explicit relative imports that start with dots have\n      empty strings in this list!)\n\n    :type path: list or None\n    :param path:\n      optional list of path where the module or package should be\n      searched (use sys.path if nothing or None is given)\n\n    :type context_file: str or None\n    :param context_file:\n      context file to consider, necessary if the identifier has been\n      introduced using a relative import unresolvable in the actual\n      context (i.e. modutils)\n\n    :raise ImportError: if there is no such module in the directory\n\n    :rtype: (str or None, import type)\n    :return:\n      the path to the module's file or None if it's an integrated\n      builtin module such as 'sys'\n    \"\"\"\n    if context_file is not None:\n        context = os.path.dirname(context_file)\n    else:\n        context = context_file\n    if modpath[0] == \"xml\":\n        # handle _xmlplus\n        try:\n            return _spec_from_modpath([\"_xmlplus\"] + modpath[1:], path, context)\n        except ImportError:\n            return _spec_from_modpath(modpath, path, context)\n    elif modpath == [\"os\", \"path\"]:\n        # FIXME: currently ignoring search_path...\n        return spec.ModuleSpec(\n            name=\"os.path\",\n            location=os.path.__file__,\n            module_type=spec.ModuleType.PY_SOURCE,\n        )\n    return _spec_from_modpath(modpath, path, context)\n", "tokens": ["astroid", "modutils", "py", "def", "file_info_from_modpath", "modpath", "path", "none", "context_file", "none", "given", "a", "mod", "path", "i", "e", "split", "module", "package", "name", "return", "the", "corresponding", "file", "giving", "priority", "to", "source", "file", "over", "precompiled", "file", "if", "it", "exists", "type", "modpath", "list", "or", "tuple", "param", "modpath", "split", "module", "s", "name", "i", "e", "name", "of", "a", "module", "or", "package", "split", "on", "this", "means", "explicit", "relative", "imports", "that", "start", "with", "dots", "have", "empty", "strings", "in", "this", "list", "type", "path", "list", "or", "none", "param", "path", "optional", "list", "of", "path", "where", "the", "module", "or", "package", "should", "be", "searched", "use", "sys", "path", "if", "nothing", "or", "none", "is", "given", "type", "context_file", "str", "or", "none", "param", "context_file", "context", "file", "to", "consider", "necessary", "if", "the", "identifier", "has", "been", "introduced", "using", "a", "relative", "import", "unresolvable", "in", "the", "actual", "context", "i", "e", "modutils", "raise", "importerror", "if", "there", "is", "no", "such", "module", "in", "the", "directory", "rtype", "str", "or", "none", "import", "type", "return", "the", "path", "to", "the", "module", "s", "file", "or", "none", "if", "it", "s", "an", "integrated", "builtin", "module", "such", "as", "sys", "if", "context_file", "is", "not", "none", "context", "os", "path", "dirname", "context_file", "else", "context", "context_file", "if", "modpath", "0", "xml", "handle", "_xmlplus", "try", "return", "_spec_from_modpath", "_xmlplus", "modpath", "1", "path", "context", "except", "importerror", "return", "_spec_from_modpath", "modpath", "path", "context", "elif", "modpath", "os", "path", "fixme", "currently", "ignoring", "search_path", "return", "spec", "modulespec", "name", "os", "path", "location", "os", "path", "__file__", "module_type", "spec", "moduletype", "py_source", "return", "_spec_from_modpath", "modpath", "path", "context"], "doc_len": 227}
{"doc_id": "astroid/modutils.py::get_module_part", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "get_module_part", "text": "文件路径: astroid/modutils.py\ndef get_module_part(dotted_name, context_file=None):\n    \"\"\"given a dotted name return the module part of the name :\n\n    >>> get_module_part('astroid.as_string.dump')\n    'astroid.as_string'\n\n    :type dotted_name: str\n    :param dotted_name: full name of the identifier we are interested in\n\n    :type context_file: str or None\n    :param context_file:\n      context file to consider, necessary if the identifier has been\n      introduced using a relative import unresolvable in the actual\n      context (i.e. modutils)\n\n\n    :raise ImportError: if there is no such module in the directory\n\n    :rtype: str or None\n    :return:\n      the module part of the name or None if we have not been able at\n      all to import the given name\n\n    XXX: deprecated, since it doesn't handle package precedence over module\n    (see #10066)\n    \"\"\"\n    # os.path trick\n    if dotted_name.startswith(\"os.path\"):\n        return \"os.path\"\n    parts = dotted_name.split(\".\")\n    if context_file is not None:\n        # first check for builtin module which won't be considered latter\n        # in that case (path != None)\n        if parts[0] in BUILTIN_MODULES:\n            if len(parts) > 2:\n                raise ImportError(dotted_name)\n            return parts[0]\n        # don't use += or insert, we want a new list to be created !\n    path = None\n    starti = 0\n    if parts[0] == \"\":\n        assert (\n            context_file is not None\n        ), \"explicit relative import, but no context_file?\"\n        path = []  # prevent resolving the import non-relatively\n        starti = 1\n    while parts[starti] == \"\":  # for all further dots: change context\n        starti += 1\n        context_file = os.path.dirname(context_file)\n    for i in range(starti, len(parts)):\n        try:\n            file_from_modpath(\n                parts[starti : i + 1], path=path, context_file=context_file\n            )\n        except ImportError:\n            if i < max(1, len(parts) - 2):\n                raise\n            return \".\".join(parts[:i])\n    return dotted_name\n", "tokens": ["astroid", "modutils", "py", "def", "get_module_part", "dotted_name", "context_file", "none", "given", "a", "dotted", "name", "return", "the", "module", "part", "of", "the", "name", "get_module_part", "astroid", "as_string", "dump", "astroid", "as_string", "type", "dotted_name", "str", "param", "dotted_name", "full", "name", "of", "the", "identifier", "we", "are", "interested", "in", "type", "context_file", "str", "or", "none", "param", "context_file", "context", "file", "to", "consider", "necessary", "if", "the", "identifier", "has", "been", "introduced", "using", "a", "relative", "import", "unresolvable", "in", "the", "actual", "context", "i", "e", "modutils", "raise", "importerror", "if", "there", "is", "no", "such", "module", "in", "the", "directory", "rtype", "str", "or", "none", "return", "the", "module", "part", "of", "the", "name", "or", "none", "if", "we", "have", "not", "been", "able", "at", "all", "to", "import", "the", "given", "name", "xxx", "deprecated", "since", "it", "doesn", "t", "handle", "package", "precedence", "over", "module", "see", "10066", "os", "path", "trick", "if", "dotted_name", "startswith", "os", "path", "return", "os", "path", "parts", "dotted_name", "split", "if", "context_file", "is", "not", "none", "first", "check", "for", "builtin", "module", "which", "won", "t", "be", "considered", "latter", "in", "that", "case", "path", "none", "if", "parts", "0", "in", "builtin_modules", "if", "len", "parts", "2", "raise", "importerror", "dotted_name", "return", "parts", "0", "don", "t", "use", "or", "insert", "we", "want", "a", "new", "list", "to", "be", "created", "path", "none", "starti", "0", "if", "parts", "0", "assert", "context_file", "is", "not", "none", "explicit", "relative", "import", "but", "no", "context_file", "path", "prevent", "resolving", "the", "import", "non", "relatively", "starti", "1", "while", "parts", "starti", "for", "all", "further", "dots", "change", "context", "starti", "1", "context_file", "os", "path", "dirname", "context_file", "for", "i", "in", "range", "starti", "len", "parts", "try", "file_from_modpath", "parts", "starti", "i", "1", "path", "path", "context_file", "context_file", "except", "importerror", "if", "i", "max", "1", "len", "parts", "2", "raise", "return", "join", "parts", "i", "return", "dotted_name"], "doc_len": 258}
{"doc_id": "astroid/modutils.py::get_module_files", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "get_module_files", "text": "文件路径: astroid/modutils.py\ndef get_module_files(src_directory, blacklist, list_all=False):\n    \"\"\"given a package directory return a list of all available python\n    module's files in the package and its subpackages\n\n    :type src_directory: str\n    :param src_directory:\n      path of the directory corresponding to the package\n\n    :type blacklist: list or tuple\n    :param blacklist: iterable\n      list of files or directories to ignore.\n\n    :type list_all: bool\n    :param list_all:\n        get files from all paths, including ones without __init__.py\n\n    :rtype: list\n    :return:\n      the list of all available python module's files in the package and\n      its subpackages\n    \"\"\"\n    files = []\n    for directory, dirnames, filenames in os.walk(src_directory):\n        if directory in blacklist:\n            continue\n        _handle_blacklist(blacklist, dirnames, filenames)\n        # check for __init__.py\n        if not list_all and \"__init__.py\" not in filenames:\n            dirnames[:] = ()\n            continue\n        for filename in filenames:\n            if _is_python_file(filename):\n                src = os.path.join(directory, filename)\n                files.append(src)\n    return files\n", "tokens": ["astroid", "modutils", "py", "def", "get_module_files", "src_directory", "blacklist", "list_all", "false", "given", "a", "package", "directory", "return", "a", "list", "of", "all", "available", "python", "module", "s", "files", "in", "the", "package", "and", "its", "subpackages", "type", "src_directory", "str", "param", "src_directory", "path", "of", "the", "directory", "corresponding", "to", "the", "package", "type", "blacklist", "list", "or", "tuple", "param", "blacklist", "iterable", "list", "of", "files", "or", "directories", "to", "ignore", "type", "list_all", "bool", "param", "list_all", "get", "files", "from", "all", "paths", "including", "ones", "without", "__init__", "py", "rtype", "list", "return", "the", "list", "of", "all", "available", "python", "module", "s", "files", "in", "the", "package", "and", "its", "subpackages", "files", "for", "directory", "dirnames", "filenames", "in", "os", "walk", "src_directory", "if", "directory", "in", "blacklist", "continue", "_handle_blacklist", "blacklist", "dirnames", "filenames", "check", "for", "__init__", "py", "if", "not", "list_all", "and", "__init__", "py", "not", "in", "filenames", "dirnames", "continue", "for", "filename", "in", "filenames", "if", "_is_python_file", "filename", "src", "os", "path", "join", "directory", "filename", "files", "append", "src", "return", "files"], "doc_len": 141}
{"doc_id": "astroid/modutils.py::get_source_file", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "get_source_file", "text": "文件路径: astroid/modutils.py\ndef get_source_file(filename, include_no_ext=False):\n    \"\"\"given a python module's file name return the matching source file\n    name (the filename will be returned identically if it's already an\n    absolute path to a python source file...)\n\n    :type filename: str\n    :param filename: python module's file name\n\n\n    :raise NoSourceFile: if no source file exists on the file system\n\n    :rtype: str\n    :return: the absolute path of the source file if it exists\n    \"\"\"\n    filename = os.path.abspath(_path_from_filename(filename))\n    base, orig_ext = os.path.splitext(filename)\n    for ext in PY_SOURCE_EXTS:\n        source_path = f\"{base}.{ext}\"\n        if os.path.exists(source_path):\n            return source_path\n    if include_no_ext and not orig_ext and os.path.exists(base):\n        return base\n    raise NoSourceFile(filename)\n", "tokens": ["astroid", "modutils", "py", "def", "get_source_file", "filename", "include_no_ext", "false", "given", "a", "python", "module", "s", "file", "name", "return", "the", "matching", "source", "file", "name", "the", "filename", "will", "be", "returned", "identically", "if", "it", "s", "already", "an", "absolute", "path", "to", "a", "python", "source", "file", "type", "filename", "str", "param", "filename", "python", "module", "s", "file", "name", "raise", "nosourcefile", "if", "no", "source", "file", "exists", "on", "the", "file", "system", "rtype", "str", "return", "the", "absolute", "path", "of", "the", "source", "file", "if", "it", "exists", "filename", "os", "path", "abspath", "_path_from_filename", "filename", "base", "orig_ext", "os", "path", "splitext", "filename", "for", "ext", "in", "py_source_exts", "source_path", "f", "base", "ext", "if", "os", "path", "exists", "source_path", "return", "source_path", "if", "include_no_ext", "and", "not", "orig_ext", "and", "os", "path", "exists", "base", "return", "base", "raise", "nosourcefile", "filename"], "doc_len": 115}
{"doc_id": "astroid/modutils.py::is_python_source", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_python_source", "text": "文件路径: astroid/modutils.py\ndef is_python_source(filename):\n    \"\"\"\n    rtype: bool\n    return: True if the filename is a python source file\n    \"\"\"\n    return os.path.splitext(filename)[1][1:] in PY_SOURCE_EXTS\n", "tokens": ["astroid", "modutils", "py", "def", "is_python_source", "filename", "rtype", "bool", "return", "true", "if", "the", "filename", "is", "a", "python", "source", "file", "return", "os", "path", "splitext", "filename", "1", "1", "in", "py_source_exts"], "doc_len": 27}
{"doc_id": "astroid/modutils.py::is_standard_module", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_standard_module", "text": "文件路径: astroid/modutils.py\ndef is_standard_module(modname, std_path=None):\n    \"\"\"try to guess if a module is a standard python module (by default,\n    see `std_path` parameter's description)\n\n    :type modname: str\n    :param modname: name of the module we are interested in\n\n    :type std_path: list(str) or tuple(str)\n    :param std_path: list of path considered has standard\n\n\n    :rtype: bool\n    :return:\n      true if the module:\n      - is located on the path listed in one of the directory in `std_path`\n      - is a built-in module\n    \"\"\"\n    modname = modname.split(\".\")[0]\n    try:\n        filename = file_from_modpath([modname])\n    except ImportError:\n        # import failed, i'm probably not so wrong by supposing it's\n        # not standard...\n        return False\n    # modules which are not living in a file are considered standard\n    # (sys and __builtin__ for instance)\n    if filename is None:\n        # we assume there are no namespaces in stdlib\n        return not util.is_namespace(modname)\n    filename = _normalize_path(filename)\n    for path in EXT_LIB_DIRS:\n        if filename.startswith(_cache_normalize_path(path)):\n            return False\n    if std_path is None:\n        std_path = STD_LIB_DIRS\n\n    return any(filename.startswith(_cache_normalize_path(path)) for path in std_path)\n", "tokens": ["astroid", "modutils", "py", "def", "is_standard_module", "modname", "std_path", "none", "try", "to", "guess", "if", "a", "module", "is", "a", "standard", "python", "module", "by", "default", "see", "std_path", "parameter", "s", "description", "type", "modname", "str", "param", "modname", "name", "of", "the", "module", "we", "are", "interested", "in", "type", "std_path", "list", "str", "or", "tuple", "str", "param", "std_path", "list", "of", "path", "considered", "has", "standard", "rtype", "bool", "return", "true", "if", "the", "module", "is", "located", "on", "the", "path", "listed", "in", "one", "of", "the", "directory", "in", "std_path", "is", "a", "built", "in", "module", "modname", "modname", "split", "0", "try", "filename", "file_from_modpath", "modname", "except", "importerror", "import", "failed", "i", "m", "probably", "not", "so", "wrong", "by", "supposing", "it", "s", "not", "standard", "return", "false", "modules", "which", "are", "not", "living", "in", "a", "file", "are", "considered", "standard", "sys", "and", "__builtin__", "for", "instance", "if", "filename", "is", "none", "we", "assume", "there", "are", "no", "namespaces", "in", "stdlib", "return", "not", "util", "is_namespace", "modname", "filename", "_normalize_path", "filename", "for", "path", "in", "ext_lib_dirs", "if", "filename", "startswith", "_cache_normalize_path", "path", "return", "false", "if", "std_path", "is", "none", "std_path", "std_lib_dirs", "return", "any", "filename", "startswith", "_cache_normalize_path", "path", "for", "path", "in", "std_path"], "doc_len": 168}
{"doc_id": "astroid/modutils.py::is_relative", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_relative", "text": "文件路径: astroid/modutils.py\ndef is_relative(modname, from_file):\n    \"\"\"return true if the given module name is relative to the given\n    file name\n\n    :type modname: str\n    :param modname: name of the module we are interested in\n\n    :type from_file: str\n    :param from_file:\n      path of the module from which modname has been imported\n\n    :rtype: bool\n    :return:\n      true if the module has been imported relatively to `from_file`\n    \"\"\"\n    if not os.path.isdir(from_file):\n        from_file = os.path.dirname(from_file)\n    if from_file in sys.path:\n        return False\n    return bool(\n        importlib.machinery.PathFinder.find_spec(\n            modname.split(\".\", maxsplit=1)[0], [from_file]\n        )\n    )\n", "tokens": ["astroid", "modutils", "py", "def", "is_relative", "modname", "from_file", "return", "true", "if", "the", "given", "module", "name", "is", "relative", "to", "the", "given", "file", "name", "type", "modname", "str", "param", "modname", "name", "of", "the", "module", "we", "are", "interested", "in", "type", "from_file", "str", "param", "from_file", "path", "of", "the", "module", "from", "which", "modname", "has", "been", "imported", "rtype", "bool", "return", "true", "if", "the", "module", "has", "been", "imported", "relatively", "to", "from_file", "if", "not", "os", "path", "isdir", "from_file", "from_file", "os", "path", "dirname", "from_file", "if", "from_file", "in", "sys", "path", "return", "false", "return", "bool", "importlib", "machinery", "pathfinder", "find_spec", "modname", "split", "maxsplit", "1", "0", "from_file"], "doc_len": 92}
{"doc_id": "astroid/modutils.py::_spec_from_modpath", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_spec_from_modpath", "text": "文件路径: astroid/modutils.py\ndef _spec_from_modpath(modpath, path=None, context=None):\n    \"\"\"given a mod path (i.e. split module / package name), return the\n    corresponding spec\n\n    this function is used internally, see `file_from_modpath`'s\n    documentation for more information\n    \"\"\"\n    assert modpath\n    location = None\n    if context is not None:\n        try:\n            found_spec = spec.find_spec(modpath, [context])\n            location = found_spec.location\n        except ImportError:\n            found_spec = spec.find_spec(modpath, path)\n            location = found_spec.location\n    else:\n        found_spec = spec.find_spec(modpath, path)\n    if found_spec.type == spec.ModuleType.PY_COMPILED:\n        try:\n            location = get_source_file(found_spec.location)\n            return found_spec._replace(\n                location=location, type=spec.ModuleType.PY_SOURCE\n            )\n        except NoSourceFile:\n            return found_spec._replace(location=location)\n    elif found_spec.type == spec.ModuleType.C_BUILTIN:\n        # integrated builtin module\n        return found_spec._replace(location=None)\n    elif found_spec.type == spec.ModuleType.PKG_DIRECTORY:\n        location = _has_init(found_spec.location)\n        return found_spec._replace(location=location, type=spec.ModuleType.PY_SOURCE)\n    return found_spec\n", "tokens": ["astroid", "modutils", "py", "def", "_spec_from_modpath", "modpath", "path", "none", "context", "none", "given", "a", "mod", "path", "i", "e", "split", "module", "package", "name", "return", "the", "corresponding", "spec", "this", "function", "is", "used", "internally", "see", "file_from_modpath", "s", "documentation", "for", "more", "information", "assert", "modpath", "location", "none", "if", "context", "is", "not", "none", "try", "found_spec", "spec", "find_spec", "modpath", "context", "location", "found_spec", "location", "except", "importerror", "found_spec", "spec", "find_spec", "modpath", "path", "location", "found_spec", "location", "else", "found_spec", "spec", "find_spec", "modpath", "path", "if", "found_spec", "type", "spec", "moduletype", "py_compiled", "try", "location", "get_source_file", "found_spec", "location", "return", "found_spec", "_replace", "location", "location", "type", "spec", "moduletype", "py_source", "except", "nosourcefile", "return", "found_spec", "_replace", "location", "location", "elif", "found_spec", "type", "spec", "moduletype", "c_builtin", "integrated", "builtin", "module", "return", "found_spec", "_replace", "location", "none", "elif", "found_spec", "type", "spec", "moduletype", "pkg_directory", "location", "_has_init", "found_spec", "location", "return", "found_spec", "_replace", "location", "location", "type", "spec", "moduletype", "py_source", "return", "found_spec"], "doc_len": 132}
{"doc_id": "astroid/modutils.py::_is_python_file", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_is_python_file", "text": "文件路径: astroid/modutils.py\ndef _is_python_file(filename):\n    \"\"\"return true if the given filename should be considered as a python file\n\n    .pyc and .pyo are ignored\n    \"\"\"\n    return filename.endswith((\".py\", \".so\", \".pyd\", \".pyw\"))\n", "tokens": ["astroid", "modutils", "py", "def", "_is_python_file", "filename", "return", "true", "if", "the", "given", "filename", "should", "be", "considered", "as", "a", "python", "file", "pyc", "and", "pyo", "are", "ignored", "return", "filename", "endswith", "py", "so", "pyd", "pyw"], "doc_len": 31}
{"doc_id": "astroid/modutils.py::_has_init", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "_has_init", "text": "文件路径: astroid/modutils.py\ndef _has_init(directory):\n    \"\"\"if the given directory has a valid __init__ file, return its path,\n    else return None\n    \"\"\"\n    mod_or_pack = os.path.join(directory, \"__init__\")\n    for ext in PY_SOURCE_EXTS + (\"pyc\", \"pyo\"):\n        if os.path.exists(mod_or_pack + \".\" + ext):\n            return mod_or_pack + \".\" + ext\n    return None\n", "tokens": ["astroid", "modutils", "py", "def", "_has_init", "directory", "if", "the", "given", "directory", "has", "a", "valid", "__init__", "file", "return", "its", "path", "else", "return", "none", "mod_or_pack", "os", "path", "join", "directory", "__init__", "for", "ext", "in", "py_source_exts", "pyc", "pyo", "if", "os", "path", "exists", "mod_or_pack", "ext", "return", "mod_or_pack", "ext", "return", "none"], "doc_len": 44}
{"doc_id": "astroid/modutils.py::is_namespace", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_namespace", "text": "文件路径: astroid/modutils.py\ndef is_namespace(specobj):\n    return specobj.type == spec.ModuleType.PY_NAMESPACE\n", "tokens": ["astroid", "modutils", "py", "def", "is_namespace", "specobj", "return", "specobj", "type", "spec", "moduletype", "py_namespace"], "doc_len": 12}
{"doc_id": "astroid/modutils.py::is_directory", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_directory", "text": "文件路径: astroid/modutils.py\ndef is_directory(specobj):\n    return specobj.type == spec.ModuleType.PKG_DIRECTORY\n", "tokens": ["astroid", "modutils", "py", "def", "is_directory", "specobj", "return", "specobj", "type", "spec", "moduletype", "pkg_directory"], "doc_len": 12}
{"doc_id": "astroid/modutils.py::is_module_name_part_of_extension_package_whitelist", "file_path": "astroid/modutils.py", "class_name": null, "func_name": "is_module_name_part_of_extension_package_whitelist", "text": "文件路径: astroid/modutils.py\ndef is_module_name_part_of_extension_package_whitelist(\n    module_name: str, package_whitelist: Set[str]\n) -> bool:\n    \"\"\"\n    Returns True if one part of the module name is in the package whitelist\n\n    >>> is_module_name_part_of_extension_package_whitelist('numpy.core.umath', {'numpy'})\n    True\n    \"\"\"\n    parts = module_name.split(\".\")\n    return any(\n        \".\".join(parts[:x]) in package_whitelist for x in range(1, len(parts) + 1)\n    )\n", "tokens": ["astroid", "modutils", "py", "def", "is_module_name_part_of_extension_package_whitelist", "module_name", "str", "package_whitelist", "set", "str", "bool", "returns", "true", "if", "one", "part", "of", "the", "module", "name", "is", "in", "the", "package", "whitelist", "is_module_name_part_of_extension_package_whitelist", "numpy", "core", "umath", "numpy", "true", "parts", "module_name", "split", "return", "any", "join", "parts", "x", "in", "package_whitelist", "for", "x", "in", "range", "1", "len", "parts", "1"], "doc_len": 49}
{"doc_id": "astroid/objects.py::FrozenSet.pytype", "file_path": "astroid/objects.py", "class_name": "FrozenSet", "func_name": "pytype", "text": "文件路径: astroid/objects.py, 类名: FrozenSet\n    def pytype(self):\n        return \"builtins.frozenset\"\n", "tokens": ["astroid", "objects", "py", "frozenset", "def", "pytype", "self", "return", "builtins", "frozenset"], "doc_len": 10}
{"doc_id": "astroid/objects.py::FrozenSet._infer", "file_path": "astroid/objects.py", "class_name": "FrozenSet", "func_name": "_infer", "text": "文件路径: astroid/objects.py, 类名: FrozenSet\n    def _infer(self, context=None):\n        yield self\n", "tokens": ["astroid", "objects", "py", "frozenset", "def", "_infer", "self", "context", "none", "yield", "self"], "doc_len": 11}
{"doc_id": "astroid/objects.py::FrozenSet._proxied", "file_path": "astroid/objects.py", "class_name": "FrozenSet", "func_name": "_proxied", "text": "文件路径: astroid/objects.py, 类名: FrozenSet\n    def _proxied(self):  # pylint: disable=method-hidden\n        ast_builtins = AstroidManager().builtins_module\n        return ast_builtins.getattr(\"frozenset\")[0]\n", "tokens": ["astroid", "objects", "py", "frozenset", "def", "_proxied", "self", "pylint", "disable", "method", "hidden", "ast_builtins", "astroidmanager", "builtins_module", "return", "ast_builtins", "getattr", "frozenset", "0"], "doc_len": 19}
{"doc_id": "astroid/objects.py::Super.__init__", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "__init__", "text": "文件路径: astroid/objects.py, 类名: Super\n    def __init__(self, mro_pointer, mro_type, self_class, scope):\n        self.type = mro_type\n        self.mro_pointer = mro_pointer\n        self._class_based = False\n        self._self_class = self_class\n        self._scope = scope\n        super().__init__()\n", "tokens": ["astroid", "objects", "py", "super", "def", "__init__", "self", "mro_pointer", "mro_type", "self_class", "scope", "self", "type", "mro_type", "self", "mro_pointer", "mro_pointer", "self", "_class_based", "false", "self", "_self_class", "self_class", "self", "_scope", "scope", "super", "__init__"], "doc_len": 28}
{"doc_id": "astroid/objects.py::Super._infer", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "_infer", "text": "文件路径: astroid/objects.py, 类名: Super\n    def _infer(self, context=None):\n        yield self\n", "tokens": ["astroid", "objects", "py", "super", "def", "_infer", "self", "context", "none", "yield", "self"], "doc_len": 11}
{"doc_id": "astroid/objects.py::Super.super_mro", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "super_mro", "text": "文件路径: astroid/objects.py, 类名: Super\n    def super_mro(self):\n        \"\"\"Get the MRO which will be used to lookup attributes in this super.\"\"\"\n        if not isinstance(self.mro_pointer, scoped_nodes.ClassDef):\n            raise SuperError(\n                \"The first argument to super must be a subtype of \"\n                \"type, not {mro_pointer}.\",\n                super_=self,\n            )\n\n        if isinstance(self.type, scoped_nodes.ClassDef):\n            # `super(type, type)`, most likely in a class method.\n            self._class_based = True\n            mro_type = self.type\n        else:\n            mro_type = getattr(self.type, \"_proxied\", None)\n            if not isinstance(mro_type, (bases.Instance, scoped_nodes.ClassDef)):\n                raise SuperError(\n                    \"The second argument to super must be an \"\n                    \"instance or subtype of type, not {type}.\",\n                    super_=self,\n                )\n\n        if not mro_type.newstyle:\n            raise SuperError(\"Unable to call super on old-style classes.\", super_=self)\n\n        mro = mro_type.mro()\n        if self.mro_pointer not in mro:\n            raise SuperError(\n                \"The second argument to super must be an \"\n                \"instance or subtype of type, not {type}.\",\n                super_=self,\n            )\n\n        index = mro.index(self.mro_pointer)\n        return mro[index + 1 :]\n", "tokens": ["astroid", "objects", "py", "super", "def", "super_mro", "self", "get", "the", "mro", "which", "will", "be", "used", "to", "lookup", "attributes", "in", "this", "super", "if", "not", "isinstance", "self", "mro_pointer", "scoped_nodes", "classdef", "raise", "supererror", "the", "first", "argument", "to", "super", "must", "be", "a", "subtype", "of", "type", "not", "mro_pointer", "super_", "self", "if", "isinstance", "self", "type", "scoped_nodes", "classdef", "super", "type", "type", "most", "likely", "in", "a", "class", "method", "self", "_class_based", "true", "mro_type", "self", "type", "else", "mro_type", "getattr", "self", "type", "_proxied", "none", "if", "not", "isinstance", "mro_type", "bases", "instance", "scoped_nodes", "classdef", "raise", "supererror", "the", "second", "argument", "to", "super", "must", "be", "an", "instance", "or", "subtype", "of", "type", "not", "type", "super_", "self", "if", "not", "mro_type", "newstyle", "raise", "supererror", "unable", "to", "call", "super", "on", "old", "style", "classes", "super_", "self", "mro", "mro_type", "mro", "if", "self", "mro_pointer", "not", "in", "mro", "raise", "supererror", "the", "second", "argument", "to", "super", "must", "be", "an", "instance", "or", "subtype", "of", "type", "not", "type", "super_", "self", "index", "mro", "index", "self", "mro_pointer", "return", "mro", "index", "1"], "doc_len": 152}
{"doc_id": "astroid/objects.py::Super._proxied", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "_proxied", "text": "文件路径: astroid/objects.py, 类名: Super\n    def _proxied(self):\n        ast_builtins = AstroidManager().builtins_module\n        return ast_builtins.getattr(\"super\")[0]\n", "tokens": ["astroid", "objects", "py", "super", "def", "_proxied", "self", "ast_builtins", "astroidmanager", "builtins_module", "return", "ast_builtins", "getattr", "super", "0"], "doc_len": 15}
{"doc_id": "astroid/objects.py::Super.pytype", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "pytype", "text": "文件路径: astroid/objects.py, 类名: Super\n    def pytype(self):\n        return \"builtins.super\"\n", "tokens": ["astroid", "objects", "py", "super", "def", "pytype", "self", "return", "builtins", "super"], "doc_len": 10}
{"doc_id": "astroid/objects.py::Super.display_type", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "display_type", "text": "文件路径: astroid/objects.py, 类名: Super\n    def display_type(self):\n        return \"Super of\"\n", "tokens": ["astroid", "objects", "py", "super", "def", "display_type", "self", "return", "super", "of"], "doc_len": 10}
{"doc_id": "astroid/objects.py::Super.name", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "name", "text": "文件路径: astroid/objects.py, 类名: Super\n    def name(self):\n        \"\"\"Get the name of the MRO pointer.\"\"\"\n        return self.mro_pointer.name\n", "tokens": ["astroid", "objects", "py", "super", "def", "name", "self", "get", "the", "name", "of", "the", "mro", "pointer", "return", "self", "mro_pointer", "name"], "doc_len": 18}
{"doc_id": "astroid/objects.py::Super.qname", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "qname", "text": "文件路径: astroid/objects.py, 类名: Super\n    def qname(self):\n        return \"super\"\n", "tokens": ["astroid", "objects", "py", "super", "def", "qname", "self", "return", "super"], "doc_len": 9}
{"doc_id": "astroid/objects.py::Super.igetattr", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "igetattr", "text": "文件路径: astroid/objects.py, 类名: Super\n    def igetattr(self, name, context=None):\n        \"\"\"Retrieve the inferred values of the given attribute name.\"\"\"\n\n        if name in self.special_attributes:\n            yield self.special_attributes.lookup(name)\n            return\n\n        try:\n            mro = self.super_mro()\n        # Don't let invalid MROs or invalid super calls\n        # leak out as is from this function.\n        except SuperError as exc:\n            raise AttributeInferenceError(\n                (\n                    \"Lookup for {name} on {target!r} because super call {super!r} \"\n                    \"is invalid.\"\n                ),\n                target=self,\n                attribute=name,\n                context=context,\n                super_=exc.super_,\n            ) from exc\n        except MroError as exc:\n            raise AttributeInferenceError(\n                (\n                    \"Lookup for {name} on {target!r} failed because {cls!r} has an \"\n                    \"invalid MRO.\"\n                ),\n                target=self,\n                attribute=name,\n                context=context,\n                mros=exc.mros,\n                cls=exc.cls,\n            ) from exc\n        found = False\n        for cls in mro:\n            if name not in cls.locals:\n                continue\n\n            found = True\n            for inferred in bases._infer_stmts([cls[name]], context, frame=self):\n                if not isinstance(inferred, scoped_nodes.FunctionDef):\n                    yield inferred\n                    continue\n\n                # We can obtain different descriptors from a super depending\n                # on what we are accessing and where the super call is.\n                if inferred.type == \"classmethod\":\n                    yield bases.BoundMethod(inferred, cls)\n                elif self._scope.type == \"classmethod\" and inferred.type == \"method\":\n                    yield inferred\n                elif self._class_based or inferred.type == \"staticmethod\":\n                    yield inferred\n                elif isinstance(inferred, Property):\n                    function = inferred.function\n                    try:\n                        yield from function.infer_call_result(\n                            caller=self, context=context\n                        )\n                    except InferenceError:\n                        yield util.Uninferable\n                elif bases._is_property(inferred):\n                    # TODO: support other descriptors as well.\n                    try:\n                        yield from inferred.infer_call_result(self, context)\n                    except InferenceError:\n                        yield util.Uninferable\n                else:\n                    yield bases.BoundMethod(inferred, cls)\n\n        if not found:\n            raise AttributeInferenceError(target=self, attribute=name, context=context)\n", "tokens": ["astroid", "objects", "py", "super", "def", "igetattr", "self", "name", "context", "none", "retrieve", "the", "inferred", "values", "of", "the", "given", "attribute", "name", "if", "name", "in", "self", "special_attributes", "yield", "self", "special_attributes", "lookup", "name", "return", "try", "mro", "self", "super_mro", "don", "t", "let", "invalid", "mros", "or", "invalid", "super", "calls", "leak", "out", "as", "is", "from", "this", "function", "except", "supererror", "as", "exc", "raise", "attributeinferenceerror", "lookup", "for", "name", "on", "target", "r", "because", "super", "call", "super", "r", "is", "invalid", "target", "self", "attribute", "name", "context", "context", "super_", "exc", "super_", "from", "exc", "except", "mroerror", "as", "exc", "raise", "attributeinferenceerror", "lookup", "for", "name", "on", "target", "r", "failed", "because", "cls", "r", "has", "an", "invalid", "mro", "target", "self", "attribute", "name", "context", "context", "mros", "exc", "mros", "cls", "exc", "cls", "from", "exc", "found", "false", "for", "cls", "in", "mro", "if", "name", "not", "in", "cls", "locals", "continue", "found", "true", "for", "inferred", "in", "bases", "_infer_stmts", "cls", "name", "context", "frame", "self", "if", "not", "isinstance", "inferred", "scoped_nodes", "functiondef", "yield", "inferred", "continue", "we", "can", "obtain", "different", "descriptors", "from", "a", "super", "depending", "on", "what", "we", "are", "accessing", "and", "where", "the", "super", "call", "is", "if", "inferred", "type", "classmethod", "yield", "bases", "boundmethod", "inferred", "cls", "elif", "self", "_scope", "type", "classmethod", "and", "inferred", "type", "method", "yield", "inferred", "elif", "self", "_class_based", "or", "inferred", "type", "staticmethod", "yield", "inferred", "elif", "isinstance", "inferred", "property", "function", "inferred", "function", "try", "yield", "from", "function", "infer_call_result", "caller", "self", "context", "context", "except", "inferenceerror", "yield", "util", "uninferable", "elif", "bases", "_is_property", "inferred", "todo", "support", "other", "descriptors", "as", "well", "try", "yield", "from", "inferred", "infer_call_result", "self", "context", "except", "inferenceerror", "yield", "util", "uninferable", "else", "yield", "bases", "boundmethod", "inferred", "cls", "if", "not", "found", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context"], "doc_len": 257}
{"doc_id": "astroid/objects.py::Super.getattr", "file_path": "astroid/objects.py", "class_name": "Super", "func_name": "getattr", "text": "文件路径: astroid/objects.py, 类名: Super\n    def getattr(self, name, context=None):\n        return list(self.igetattr(name, context=context))\n", "tokens": ["astroid", "objects", "py", "super", "def", "getattr", "self", "name", "context", "none", "return", "list", "self", "igetattr", "name", "context", "context"], "doc_len": 17}
{"doc_id": "astroid/objects.py::ExceptionInstance.special_attributes", "file_path": "astroid/objects.py", "class_name": "ExceptionInstance", "func_name": "special_attributes", "text": "文件路径: astroid/objects.py, 类名: ExceptionInstance\n    def special_attributes(self):\n        qname = self.qname()\n        instance = objectmodel.BUILTIN_EXCEPTIONS.get(\n            qname, objectmodel.ExceptionInstanceModel\n        )\n        return instance()(self)\n", "tokens": ["astroid", "objects", "py", "exceptioninstance", "def", "special_attributes", "self", "qname", "self", "qname", "instance", "objectmodel", "builtin_exceptions", "get", "qname", "objectmodel", "exceptioninstancemodel", "return", "instance", "self"], "doc_len": 20}
{"doc_id": "astroid/objects.py::PartialFunction.__init__", "file_path": "astroid/objects.py", "class_name": "PartialFunction", "func_name": "__init__", "text": "文件路径: astroid/objects.py, 类名: PartialFunction\n    def __init__(\n        self, call, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        super().__init__(name, doc, lineno, col_offset, parent=None)\n        # A typical FunctionDef automatically adds its name to the parent scope,\n        # but a partial should not, so defer setting parent until after init\n        self.parent = parent\n        self.filled_args = call.positional_arguments[1:]\n        self.filled_keywords = call.keyword_arguments\n\n        wrapped_function = call.positional_arguments[0]\n        inferred_wrapped_function = next(wrapped_function.infer())\n        if isinstance(inferred_wrapped_function, PartialFunction):\n            self.filled_args = inferred_wrapped_function.filled_args + self.filled_args\n            self.filled_keywords = {\n                **inferred_wrapped_function.filled_keywords,\n                **self.filled_keywords,\n            }\n\n        self.filled_positionals = len(self.filled_args)\n", "tokens": ["astroid", "objects", "py", "partialfunction", "def", "__init__", "self", "call", "name", "none", "doc", "none", "lineno", "none", "col_offset", "none", "parent", "none", "super", "__init__", "name", "doc", "lineno", "col_offset", "parent", "none", "a", "typical", "functiondef", "automatically", "adds", "its", "name", "to", "the", "parent", "scope", "but", "a", "partial", "should", "not", "so", "defer", "setting", "parent", "until", "after", "init", "self", "parent", "parent", "self", "filled_args", "call", "positional_arguments", "1", "self", "filled_keywords", "call", "keyword_arguments", "wrapped_function", "call", "positional_arguments", "0", "inferred_wrapped_function", "next", "wrapped_function", "infer", "if", "isinstance", "inferred_wrapped_function", "partialfunction", "self", "filled_args", "inferred_wrapped_function", "filled_args", "self", "filled_args", "self", "filled_keywords", "inferred_wrapped_function", "filled_keywords", "self", "filled_keywords", "self", "filled_positionals", "len", "self", "filled_args"], "doc_len": 90}
{"doc_id": "astroid/objects.py::PartialFunction.infer_call_result", "file_path": "astroid/objects.py", "class_name": "PartialFunction", "func_name": "infer_call_result", "text": "文件路径: astroid/objects.py, 类名: PartialFunction\n    def infer_call_result(self, caller=None, context=None):\n        if context:\n            current_passed_keywords = {\n                keyword for (keyword, _) in context.callcontext.keywords\n            }\n            for keyword, value in self.filled_keywords.items():\n                if keyword not in current_passed_keywords:\n                    context.callcontext.keywords.append((keyword, value))\n\n            call_context_args = context.callcontext.args or []\n            context.callcontext.args = self.filled_args + call_context_args\n\n        return super().infer_call_result(caller=caller, context=context)\n", "tokens": ["astroid", "objects", "py", "partialfunction", "def", "infer_call_result", "self", "caller", "none", "context", "none", "if", "context", "current_passed_keywords", "keyword", "for", "keyword", "_", "in", "context", "callcontext", "keywords", "for", "keyword", "value", "in", "self", "filled_keywords", "items", "if", "keyword", "not", "in", "current_passed_keywords", "context", "callcontext", "keywords", "append", "keyword", "value", "call_context_args", "context", "callcontext", "args", "or", "context", "callcontext", "args", "self", "filled_args", "call_context_args", "return", "super", "infer_call_result", "caller", "caller", "context", "context"], "doc_len": 58}
{"doc_id": "astroid/objects.py::PartialFunction.qname", "file_path": "astroid/objects.py", "class_name": "PartialFunction", "func_name": "qname", "text": "文件路径: astroid/objects.py, 类名: PartialFunction\n    def qname(self):\n        return self.__class__.__name__\n", "tokens": ["astroid", "objects", "py", "partialfunction", "def", "qname", "self", "return", "self", "__class__", "__name__"], "doc_len": 11}
{"doc_id": "astroid/objects.py::Property.__init__", "file_path": "astroid/objects.py", "class_name": "Property", "func_name": "__init__", "text": "文件路径: astroid/objects.py, 类名: Property\n    def __init__(\n        self, function, name=None, doc=None, lineno=None, col_offset=None, parent=None\n    ):\n        self.function = function\n        super().__init__(name, doc, lineno, col_offset, parent)\n", "tokens": ["astroid", "objects", "py", "property", "def", "__init__", "self", "function", "name", "none", "doc", "none", "lineno", "none", "col_offset", "none", "parent", "none", "self", "function", "function", "super", "__init__", "name", "doc", "lineno", "col_offset", "parent"], "doc_len": 28}
{"doc_id": "astroid/objects.py::Property.pytype", "file_path": "astroid/objects.py", "class_name": "Property", "func_name": "pytype", "text": "文件路径: astroid/objects.py, 类名: Property\n    def pytype(self):\n        return \"builtins.property\"\n", "tokens": ["astroid", "objects", "py", "property", "def", "pytype", "self", "return", "builtins", "property"], "doc_len": 10}
{"doc_id": "astroid/objects.py::Property.infer_call_result", "file_path": "astroid/objects.py", "class_name": "Property", "func_name": "infer_call_result", "text": "文件路径: astroid/objects.py, 类名: Property\n    def infer_call_result(self, caller=None, context=None):\n        raise InferenceError(\"Properties are not callable\")\n", "tokens": ["astroid", "objects", "py", "property", "def", "infer_call_result", "self", "caller", "none", "context", "none", "raise", "inferenceerror", "properties", "are", "not", "callable"], "doc_len": 17}
{"doc_id": "astroid/objects.py::Property.infer", "file_path": "astroid/objects.py", "class_name": "Property", "func_name": "infer", "text": "文件路径: astroid/objects.py, 类名: Property\n    def infer(self, context=None, **kwargs):\n        return iter((self,))\n", "tokens": ["astroid", "objects", "py", "property", "def", "infer", "self", "context", "none", "kwargs", "return", "iter", "self"], "doc_len": 13}
{"doc_id": "astroid/protocols.py::_reflected_name", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_reflected_name", "text": "文件路径: astroid/protocols.py\ndef _reflected_name(name):\n    return \"__r\" + name[2:]\n", "tokens": ["astroid", "protocols", "py", "def", "_reflected_name", "name", "return", "__r", "name", "2"], "doc_len": 10}
{"doc_id": "astroid/protocols.py::_augmented_name", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_augmented_name", "text": "文件路径: astroid/protocols.py\ndef _augmented_name(name):\n    return \"__i\" + name[2:]\n", "tokens": ["astroid", "protocols", "py", "def", "_augmented_name", "name", "return", "__i", "name", "2"], "doc_len": 10}
{"doc_id": "astroid/protocols.py::_infer_unary_op", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_infer_unary_op", "text": "文件路径: astroid/protocols.py\ndef _infer_unary_op(obj, op):\n    func = _UNARY_OPERATORS[op]\n    value = func(obj)\n    return nodes.const_factory(value)\n", "tokens": ["astroid", "protocols", "py", "def", "_infer_unary_op", "obj", "op", "func", "_unary_operators", "op", "value", "func", "obj", "return", "nodes", "const_factory", "value"], "doc_len": 17}
{"doc_id": "astroid/protocols.py::const_infer_binary_op", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "const_infer_binary_op", "text": "文件路径: astroid/protocols.py\ndef const_infer_binary_op(self, opnode, operator, other, context, _):\n    not_implemented = nodes.Const(NotImplemented)\n    if isinstance(other, nodes.Const):\n        try:\n            impl = BIN_OP_IMPL[operator]\n            try:\n                yield nodes.const_factory(impl(self.value, other.value))\n            except TypeError:\n                # ArithmeticError is not enough: float >> float is a TypeError\n                yield not_implemented\n            except Exception:  # pylint: disable=broad-except\n                yield util.Uninferable\n        except TypeError:\n            yield not_implemented\n    elif isinstance(self.value, str) and operator == \"%\":\n        # TODO(cpopa): implement string interpolation later on.\n        yield util.Uninferable\n    else:\n        yield not_implemented\n", "tokens": ["astroid", "protocols", "py", "def", "const_infer_binary_op", "self", "opnode", "operator", "other", "context", "_", "not_implemented", "nodes", "const", "notimplemented", "if", "isinstance", "other", "nodes", "const", "try", "impl", "bin_op_impl", "operator", "try", "yield", "nodes", "const_factory", "impl", "self", "value", "other", "value", "except", "typeerror", "arithmeticerror", "is", "not", "enough", "float", "float", "is", "a", "typeerror", "yield", "not_implemented", "except", "exception", "pylint", "disable", "broad", "except", "yield", "util", "uninferable", "except", "typeerror", "yield", "not_implemented", "elif", "isinstance", "self", "value", "str", "and", "operator", "todo", "cpopa", "implement", "string", "interpolation", "later", "on", "yield", "util", "uninferable", "else", "yield", "not_implemented"], "doc_len": 79}
{"doc_id": "astroid/protocols.py::_multiply_seq_by_int", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_multiply_seq_by_int", "text": "文件路径: astroid/protocols.py\ndef _multiply_seq_by_int(self, opnode, other, context):\n    node = self.__class__(parent=opnode)\n    filtered_elts = (\n        helpers.safe_infer(elt, context) or util.Uninferable\n        for elt in self.elts\n        if elt is not util.Uninferable\n    )\n    node.elts = list(filtered_elts) * other.value\n    return node\n", "tokens": ["astroid", "protocols", "py", "def", "_multiply_seq_by_int", "self", "opnode", "other", "context", "node", "self", "__class__", "parent", "opnode", "filtered_elts", "helpers", "safe_infer", "elt", "context", "or", "util", "uninferable", "for", "elt", "in", "self", "elts", "if", "elt", "is", "not", "util", "uninferable", "node", "elts", "list", "filtered_elts", "other", "value", "return", "node"], "doc_len": 41}
{"doc_id": "astroid/protocols.py::_filter_uninferable_nodes", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_filter_uninferable_nodes", "text": "文件路径: astroid/protocols.py\ndef _filter_uninferable_nodes(elts, context):\n    for elt in elts:\n        if elt is util.Uninferable:\n            yield nodes.Unknown()\n        else:\n            for inferred in elt.infer(context):\n                if inferred is not util.Uninferable:\n                    yield inferred\n                else:\n                    yield nodes.Unknown()\n", "tokens": ["astroid", "protocols", "py", "def", "_filter_uninferable_nodes", "elts", "context", "for", "elt", "in", "elts", "if", "elt", "is", "util", "uninferable", "yield", "nodes", "unknown", "else", "for", "inferred", "in", "elt", "infer", "context", "if", "inferred", "is", "not", "util", "uninferable", "yield", "inferred", "else", "yield", "nodes", "unknown"], "doc_len": 38}
{"doc_id": "astroid/protocols.py::tl_infer_binary_op", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "tl_infer_binary_op", "text": "文件路径: astroid/protocols.py\ndef tl_infer_binary_op(self, opnode, operator, other, context, method):\n    not_implemented = nodes.Const(NotImplemented)\n    if isinstance(other, self.__class__) and operator == \"+\":\n        node = self.__class__(parent=opnode)\n        node.elts = list(\n            itertools.chain(\n                _filter_uninferable_nodes(self.elts, context),\n                _filter_uninferable_nodes(other.elts, context),\n            )\n        )\n        yield node\n    elif isinstance(other, nodes.Const) and operator == \"*\":\n        if not isinstance(other.value, int):\n            yield not_implemented\n            return\n        yield _multiply_seq_by_int(self, opnode, other, context)\n    elif isinstance(other, bases.Instance) and operator == \"*\":\n        # Verify if the instance supports __index__.\n        as_index = helpers.class_instance_as_index(other)\n        if not as_index:\n            yield util.Uninferable\n        else:\n            yield _multiply_seq_by_int(self, opnode, as_index, context)\n    else:\n        yield not_implemented\n", "tokens": ["astroid", "protocols", "py", "def", "tl_infer_binary_op", "self", "opnode", "operator", "other", "context", "method", "not_implemented", "nodes", "const", "notimplemented", "if", "isinstance", "other", "self", "__class__", "and", "operator", "node", "self", "__class__", "parent", "opnode", "node", "elts", "list", "itertools", "chain", "_filter_uninferable_nodes", "self", "elts", "context", "_filter_uninferable_nodes", "other", "elts", "context", "yield", "node", "elif", "isinstance", "other", "nodes", "const", "and", "operator", "if", "not", "isinstance", "other", "value", "int", "yield", "not_implemented", "return", "yield", "_multiply_seq_by_int", "self", "opnode", "other", "context", "elif", "isinstance", "other", "bases", "instance", "and", "operator", "verify", "if", "the", "instance", "supports", "__index__", "as_index", "helpers", "class_instance_as_index", "other", "if", "not", "as_index", "yield", "util", "uninferable", "else", "yield", "_multiply_seq_by_int", "self", "opnode", "as_index", "context", "else", "yield", "not_implemented"], "doc_len": 97}
{"doc_id": "astroid/protocols.py::instance_class_infer_binary_op", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "instance_class_infer_binary_op", "text": "文件路径: astroid/protocols.py\ndef instance_class_infer_binary_op(self, opnode, operator, other, context, method):\n    return method.infer_call_result(self, context)\n", "tokens": ["astroid", "protocols", "py", "def", "instance_class_infer_binary_op", "self", "opnode", "operator", "other", "context", "method", "return", "method", "infer_call_result", "self", "context"], "doc_len": 16}
{"doc_id": "astroid/protocols.py::_resolve_looppart", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_resolve_looppart", "text": "文件路径: astroid/protocols.py\ndef _resolve_looppart(parts, assign_path, context):\n    \"\"\"recursive function to resolve multiple assignments on loops\"\"\"\n    assign_path = assign_path[:]\n    index = assign_path.pop(0)\n    for part in parts:\n        if part is util.Uninferable:\n            continue\n        if not hasattr(part, \"itered\"):\n            continue\n        try:\n            itered = part.itered()\n        except TypeError:\n            continue\n        for stmt in itered:\n            index_node = nodes.Const(index)\n            try:\n                assigned = stmt.getitem(index_node, context)\n            except (AttributeError, AstroidTypeError, AstroidIndexError):\n                continue\n            if not assign_path:\n                # we achieved to resolved the assignment path,\n                # don't infer the last part\n                yield assigned\n            elif assigned is util.Uninferable:\n                break\n            else:\n                # we are not yet on the last part of the path\n                # search on each possibly inferred value\n                try:\n                    yield from _resolve_looppart(\n                        assigned.infer(context), assign_path, context\n                    )\n                except InferenceError:\n                    break\n", "tokens": ["astroid", "protocols", "py", "def", "_resolve_looppart", "parts", "assign_path", "context", "recursive", "function", "to", "resolve", "multiple", "assignments", "on", "loops", "assign_path", "assign_path", "index", "assign_path", "pop", "0", "for", "part", "in", "parts", "if", "part", "is", "util", "uninferable", "continue", "if", "not", "hasattr", "part", "itered", "continue", "try", "itered", "part", "itered", "except", "typeerror", "continue", "for", "stmt", "in", "itered", "index_node", "nodes", "const", "index", "try", "assigned", "stmt", "getitem", "index_node", "context", "except", "attributeerror", "astroidtypeerror", "astroidindexerror", "continue", "if", "not", "assign_path", "we", "achieved", "to", "resolved", "the", "assignment", "path", "don", "t", "infer", "the", "last", "part", "yield", "assigned", "elif", "assigned", "is", "util", "uninferable", "break", "else", "we", "are", "not", "yet", "on", "the", "last", "part", "of", "the", "path", "search", "on", "each", "possibly", "inferred", "value", "try", "yield", "from", "_resolve_looppart", "assigned", "infer", "context", "assign_path", "context", "except", "inferenceerror", "break"], "doc_len": 118}
{"doc_id": "astroid/protocols.py::for_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "for_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef for_assigned_stmts(\n    self: Union[nodes.For, nodes.Comprehension],\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    if isinstance(self, nodes.AsyncFor) or getattr(self, \"is_async\", False):\n        # Skip inferring of async code for now\n        return dict(node=self, unknown=node, assign_path=assign_path, context=context)\n    if assign_path is None:\n        for lst in self.iter.infer(context):\n            if isinstance(lst, (nodes.Tuple, nodes.List)):\n                yield from lst.elts\n    else:\n        yield from _resolve_looppart(self.iter.infer(context), assign_path, context)\n    return dict(node=self, unknown=node, assign_path=assign_path, context=context)\n", "tokens": ["astroid", "protocols", "py", "def", "for_assigned_stmts", "self", "union", "nodes", "for", "nodes", "comprehension", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "if", "isinstance", "self", "nodes", "asyncfor", "or", "getattr", "self", "is_async", "false", "skip", "inferring", "of", "async", "code", "for", "now", "return", "dict", "node", "self", "unknown", "node", "assign_path", "assign_path", "context", "context", "if", "assign_path", "is", "none", "for", "lst", "in", "self", "iter", "infer", "context", "if", "isinstance", "lst", "nodes", "tuple", "nodes", "list", "yield", "from", "lst", "elts", "else", "yield", "from", "_resolve_looppart", "self", "iter", "infer", "context", "assign_path", "context", "return", "dict", "node", "self", "unknown", "node", "assign_path", "assign_path", "context", "context"], "doc_len": 94}
{"doc_id": "astroid/protocols.py::sequence_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "sequence_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef sequence_assigned_stmts(\n    self: Union[nodes.Tuple, nodes.List],\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    if assign_path is None:\n        assign_path = []\n    try:\n        index = self.elts.index(node)\n    except ValueError as exc:\n        raise InferenceError(\n            \"Tried to retrieve a node {node!r} which does not exist\",\n            node=self,\n            assign_path=assign_path,\n            context=context,\n        ) from exc\n\n    assign_path.insert(0, index)\n    return self.parent.assigned_stmts(\n        node=self, context=context, assign_path=assign_path\n    )\n", "tokens": ["astroid", "protocols", "py", "def", "sequence_assigned_stmts", "self", "union", "nodes", "tuple", "nodes", "list", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "if", "assign_path", "is", "none", "assign_path", "try", "index", "self", "elts", "index", "node", "except", "valueerror", "as", "exc", "raise", "inferenceerror", "tried", "to", "retrieve", "a", "node", "node", "r", "which", "does", "not", "exist", "node", "self", "assign_path", "assign_path", "context", "context", "from", "exc", "assign_path", "insert", "0", "index", "return", "self", "parent", "assigned_stmts", "node", "self", "context", "context", "assign_path", "assign_path"], "doc_len": 75}
{"doc_id": "astroid/protocols.py::assend_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "assend_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef assend_assigned_stmts(\n    self: Union[nodes.AssignName, nodes.AssignAttr],\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    return self.parent.assigned_stmts(node=self, context=context)\n", "tokens": ["astroid", "protocols", "py", "def", "assend_assigned_stmts", "self", "union", "nodes", "assignname", "nodes", "assignattr", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "return", "self", "parent", "assigned_stmts", "node", "self", "context", "context"], "doc_len": 33}
{"doc_id": "astroid/protocols.py::_arguments_infer_argname", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_arguments_infer_argname", "text": "文件路径: astroid/protocols.py\ndef _arguments_infer_argname(self, name, context):\n    # arguments information may be missing, in which case we can't do anything\n    # more\n    if not (self.arguments or self.vararg or self.kwarg):\n        yield util.Uninferable\n        return\n\n    functype = self.parent.type\n    # first argument of instance/class method\n    if (\n        self.arguments\n        and getattr(self.arguments[0], \"name\", None) == name\n        and functype != \"staticmethod\"\n    ):\n        cls = self.parent.parent.scope()\n        is_metaclass = isinstance(cls, nodes.ClassDef) and cls.type == \"metaclass\"\n        # If this is a metaclass, then the first argument will always\n        # be the class, not an instance.\n        if context.boundnode and isinstance(context.boundnode, bases.Instance):\n            cls = context.boundnode._proxied\n        if is_metaclass or functype == \"classmethod\":\n            yield cls\n            return\n        if functype == \"method\":\n            yield cls.instantiate_class()\n            return\n\n    if context and context.callcontext:\n        callee = context.callcontext.callee\n        while hasattr(callee, \"_proxied\"):\n            callee = callee._proxied\n        if getattr(callee, \"name\", None) == self.parent.name:\n            call_site = arguments.CallSite(context.callcontext, context.extra_context)\n            yield from call_site.infer_argument(self.parent, name, context)\n            return\n\n    if name == self.vararg:\n        vararg = nodes.const_factory(())\n        vararg.parent = self\n        if not self.arguments and self.parent.name == \"__init__\":\n            cls = self.parent.parent.scope()\n            vararg.elts = [cls.instantiate_class()]\n        yield vararg\n        return\n    if name == self.kwarg:\n        kwarg = nodes.const_factory({})\n        kwarg.parent = self\n        yield kwarg\n        return\n    # if there is a default value, yield it. And then yield Uninferable to reflect\n    # we can't guess given argument value\n    try:\n        context = copy_context(context)\n        yield from self.default_value(name).infer(context)\n        yield util.Uninferable\n    except NoDefault:\n        yield util.Uninferable\n", "tokens": ["astroid", "protocols", "py", "def", "_arguments_infer_argname", "self", "name", "context", "arguments", "information", "may", "be", "missing", "in", "which", "case", "we", "can", "t", "do", "anything", "more", "if", "not", "self", "arguments", "or", "self", "vararg", "or", "self", "kwarg", "yield", "util", "uninferable", "return", "functype", "self", "parent", "type", "first", "argument", "of", "instance", "class", "method", "if", "self", "arguments", "and", "getattr", "self", "arguments", "0", "name", "none", "name", "and", "functype", "staticmethod", "cls", "self", "parent", "parent", "scope", "is_metaclass", "isinstance", "cls", "nodes", "classdef", "and", "cls", "type", "metaclass", "if", "this", "is", "a", "metaclass", "then", "the", "first", "argument", "will", "always", "be", "the", "class", "not", "an", "instance", "if", "context", "boundnode", "and", "isinstance", "context", "boundnode", "bases", "instance", "cls", "context", "boundnode", "_proxied", "if", "is_metaclass", "or", "functype", "classmethod", "yield", "cls", "return", "if", "functype", "method", "yield", "cls", "instantiate_class", "return", "if", "context", "and", "context", "callcontext", "callee", "context", "callcontext", "callee", "while", "hasattr", "callee", "_proxied", "callee", "callee", "_proxied", "if", "getattr", "callee", "name", "none", "self", "parent", "name", "call_site", "arguments", "callsite", "context", "callcontext", "context", "extra_context", "yield", "from", "call_site", "infer_argument", "self", "parent", "name", "context", "return", "if", "name", "self", "vararg", "vararg", "nodes", "const_factory", "vararg", "parent", "self", "if", "not", "self", "arguments", "and", "self", "parent", "name", "__init__", "cls", "self", "parent", "parent", "scope", "vararg", "elts", "cls", "instantiate_class", "yield", "vararg", "return", "if", "name", "self", "kwarg", "kwarg", "nodes", "const_factory", "kwarg", "parent", "self", "yield", "kwarg", "return", "if", "there", "is", "a", "default", "value", "yield", "it", "and", "then", "yield", "uninferable", "to", "reflect", "we", "can", "t", "guess", "given", "argument", "value", "try", "context", "copy_context", "context", "yield", "from", "self", "default_value", "name", "infer", "context", "yield", "util", "uninferable", "except", "nodefault", "yield", "util", "uninferable"], "doc_len": 243}
{"doc_id": "astroid/protocols.py::arguments_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "arguments_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef arguments_assigned_stmts(\n    self: nodes.Arguments,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    if context.callcontext:\n        callee = context.callcontext.callee\n        while hasattr(callee, \"_proxied\"):\n            callee = callee._proxied\n    else:\n        callee = None\n    if (\n        context.callcontext\n        and node\n        and getattr(callee, \"name\", None) == node.frame(future=True).name\n    ):\n        # reset call context/name\n        callcontext = context.callcontext\n        context = copy_context(context)\n        context.callcontext = None\n        args = arguments.CallSite(callcontext, context=context)\n        return args.infer_argument(self.parent, node.name, context)\n    return _arguments_infer_argname(self, node.name, context)\n", "tokens": ["astroid", "protocols", "py", "def", "arguments_assigned_stmts", "self", "nodes", "arguments", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "if", "context", "callcontext", "callee", "context", "callcontext", "callee", "while", "hasattr", "callee", "_proxied", "callee", "callee", "_proxied", "else", "callee", "none", "if", "context", "callcontext", "and", "node", "and", "getattr", "callee", "name", "none", "node", "frame", "future", "true", "name", "reset", "call", "context", "name", "callcontext", "context", "callcontext", "context", "copy_context", "context", "context", "callcontext", "none", "args", "arguments", "callsite", "callcontext", "context", "context", "return", "args", "infer_argument", "self", "parent", "node", "name", "context", "return", "_arguments_infer_argname", "self", "node", "name", "context"], "doc_len": 87}
{"doc_id": "astroid/protocols.py::assign_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "assign_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef assign_assigned_stmts(\n    self: Union[nodes.AugAssign, nodes.Assign, nodes.AnnAssign],\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    if not assign_path:\n        yield self.value\n        return None\n    yield from _resolve_assignment_parts(\n        self.value.infer(context), assign_path, context\n    )\n\n    return dict(node=self, unknown=node, assign_path=assign_path, context=context)\n", "tokens": ["astroid", "protocols", "py", "def", "assign_assigned_stmts", "self", "union", "nodes", "augassign", "nodes", "assign", "nodes", "annassign", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "if", "not", "assign_path", "yield", "self", "value", "return", "none", "yield", "from", "_resolve_assignment_parts", "self", "value", "infer", "context", "assign_path", "context", "return", "dict", "node", "self", "unknown", "node", "assign_path", "assign_path", "context", "context"], "doc_len": 54}
{"doc_id": "astroid/protocols.py::assign_annassigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "assign_annassigned_stmts", "text": "文件路径: astroid/protocols.py\ndef assign_annassigned_stmts(\n    self: nodes.AnnAssign,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    for inferred in assign_assigned_stmts(self, node, context, assign_path):\n        if inferred is None:\n            yield util.Uninferable\n        else:\n            yield inferred\n", "tokens": ["astroid", "protocols", "py", "def", "assign_annassigned_stmts", "self", "nodes", "annassign", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "for", "inferred", "in", "assign_assigned_stmts", "self", "node", "context", "assign_path", "if", "inferred", "is", "none", "yield", "util", "uninferable", "else", "yield", "inferred"], "doc_len": 40}
{"doc_id": "astroid/protocols.py::_resolve_assignment_parts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_resolve_assignment_parts", "text": "文件路径: astroid/protocols.py\ndef _resolve_assignment_parts(parts, assign_path, context):\n    \"\"\"recursive function to resolve multiple assignments\"\"\"\n    assign_path = assign_path[:]\n    index = assign_path.pop(0)\n    for part in parts:\n        assigned = None\n        if isinstance(part, nodes.Dict):\n            # A dictionary in an iterating context\n            try:\n                assigned, _ = part.items[index]\n            except IndexError:\n                return\n\n        elif hasattr(part, \"getitem\"):\n            index_node = nodes.Const(index)\n            try:\n                assigned = part.getitem(index_node, context)\n            except (AstroidTypeError, AstroidIndexError):\n                return\n\n        if not assigned:\n            return\n\n        if not assign_path:\n            # we achieved to resolved the assignment path, don't infer the\n            # last part\n            yield assigned\n        elif assigned is util.Uninferable:\n            return\n        else:\n            # we are not yet on the last part of the path search on each\n            # possibly inferred value\n            try:\n                yield from _resolve_assignment_parts(\n                    assigned.infer(context), assign_path, context\n                )\n            except InferenceError:\n                return\n", "tokens": ["astroid", "protocols", "py", "def", "_resolve_assignment_parts", "parts", "assign_path", "context", "recursive", "function", "to", "resolve", "multiple", "assignments", "assign_path", "assign_path", "index", "assign_path", "pop", "0", "for", "part", "in", "parts", "assigned", "none", "if", "isinstance", "part", "nodes", "dict", "a", "dictionary", "in", "an", "iterating", "context", "try", "assigned", "_", "part", "items", "index", "except", "indexerror", "return", "elif", "hasattr", "part", "getitem", "index_node", "nodes", "const", "index", "try", "assigned", "part", "getitem", "index_node", "context", "except", "astroidtypeerror", "astroidindexerror", "return", "if", "not", "assigned", "return", "if", "not", "assign_path", "we", "achieved", "to", "resolved", "the", "assignment", "path", "don", "t", "infer", "the", "last", "part", "yield", "assigned", "elif", "assigned", "is", "util", "uninferable", "return", "else", "we", "are", "not", "yet", "on", "the", "last", "part", "of", "the", "path", "search", "on", "each", "possibly", "inferred", "value", "try", "yield", "from", "_resolve_assignment_parts", "assigned", "infer", "context", "assign_path", "context", "except", "inferenceerror", "return"], "doc_len": 122}
{"doc_id": "astroid/protocols.py::excepthandler_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "excepthandler_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef excepthandler_assigned_stmts(\n    self: nodes.ExceptHandler,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    for assigned in node_classes.unpack_infer(self.type):\n        if isinstance(assigned, nodes.ClassDef):\n            assigned = objects.ExceptionInstance(assigned)\n\n        yield assigned\n    return dict(node=self, unknown=node, assign_path=assign_path, context=context)\n", "tokens": ["astroid", "protocols", "py", "def", "excepthandler_assigned_stmts", "self", "nodes", "excepthandler", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "for", "assigned", "in", "node_classes", "unpack_infer", "self", "type", "if", "isinstance", "assigned", "nodes", "classdef", "assigned", "objects", "exceptioninstance", "assigned", "yield", "assigned", "return", "dict", "node", "self", "unknown", "node", "assign_path", "assign_path", "context", "context"], "doc_len": 50}
{"doc_id": "astroid/protocols.py::_infer_context_manager", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "_infer_context_manager", "text": "文件路径: astroid/protocols.py\ndef _infer_context_manager(self, mgr, context):\n    try:\n        inferred = next(mgr.infer(context=context))\n    except StopIteration as e:\n        raise InferenceError(node=mgr) from e\n    if isinstance(inferred, bases.Generator):\n        # Check if it is decorated with contextlib.contextmanager.\n        func = inferred.parent\n        if not func.decorators:\n            raise InferenceError(\n                \"No decorators found on inferred generator %s\", node=func\n            )\n\n        for decorator_node in func.decorators.nodes:\n            decorator = next(decorator_node.infer(context=context), None)\n            if isinstance(decorator, nodes.FunctionDef):\n                if decorator.qname() == _CONTEXTLIB_MGR:\n                    break\n        else:\n            # It doesn't interest us.\n            raise InferenceError(node=func)\n        try:\n            yield next(inferred.infer_yield_types())\n        except StopIteration as e:\n            raise InferenceError(node=func) from e\n\n    elif isinstance(inferred, bases.Instance):\n        try:\n            enter = next(inferred.igetattr(\"__enter__\", context=context))\n        except (InferenceError, AttributeInferenceError, StopIteration) as exc:\n            raise InferenceError(node=inferred) from exc\n        if not isinstance(enter, bases.BoundMethod):\n            raise InferenceError(node=enter)\n        yield from enter.infer_call_result(self, context)\n    else:\n        raise InferenceError(node=mgr)\n", "tokens": ["astroid", "protocols", "py", "def", "_infer_context_manager", "self", "mgr", "context", "try", "inferred", "next", "mgr", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "mgr", "from", "e", "if", "isinstance", "inferred", "bases", "generator", "check", "if", "it", "is", "decorated", "with", "contextlib", "contextmanager", "func", "inferred", "parent", "if", "not", "func", "decorators", "raise", "inferenceerror", "no", "decorators", "found", "on", "inferred", "generator", "s", "node", "func", "for", "decorator_node", "in", "func", "decorators", "nodes", "decorator", "next", "decorator_node", "infer", "context", "context", "none", "if", "isinstance", "decorator", "nodes", "functiondef", "if", "decorator", "qname", "_contextlib_mgr", "break", "else", "it", "doesn", "t", "interest", "us", "raise", "inferenceerror", "node", "func", "try", "yield", "next", "inferred", "infer_yield_types", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "func", "from", "e", "elif", "isinstance", "inferred", "bases", "instance", "try", "enter", "next", "inferred", "igetattr", "__enter__", "context", "context", "except", "inferenceerror", "attributeinferenceerror", "stopiteration", "as", "exc", "raise", "inferenceerror", "node", "inferred", "from", "exc", "if", "not", "isinstance", "enter", "bases", "boundmethod", "raise", "inferenceerror", "node", "enter", "yield", "from", "enter", "infer_call_result", "self", "context", "else", "raise", "inferenceerror", "node", "mgr"], "doc_len": 150}
{"doc_id": "astroid/protocols.py::with_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "with_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef with_assigned_stmts(\n    self: nodes.With,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    \"\"\"Infer names and other nodes from a *with* statement.\n\n    This enables only inference for name binding in a *with* statement.\n    For instance, in the following code, inferring `func` will return\n    the `ContextManager` class, not whatever ``__enter__`` returns.\n    We are doing this intentionally, because we consider that the context\n    manager result is whatever __enter__ returns and what it is binded\n    using the ``as`` keyword.\n\n        class ContextManager(object):\n            def __enter__(self):\n                return 42\n        with ContextManager() as f:\n            pass\n\n        # ContextManager().infer() will return ContextManager\n        # f.infer() will return 42.\n\n    Arguments:\n        self: nodes.With\n        node: The target of the assignment, `as (a, b)` in `with foo as (a, b)`.\n        context: Inference context used for caching already inferred objects\n        assign_path:\n            A list of indices, where each index specifies what item to fetch from\n            the inference results.\n    \"\"\"\n    try:\n        mgr = next(mgr for (mgr, vars) in self.items if vars == node)\n    except StopIteration:\n        return None\n    if assign_path is None:\n        yield from _infer_context_manager(self, mgr, context)\n    else:\n        for result in _infer_context_manager(self, mgr, context):\n            # Walk the assign_path and get the item at the final index.\n            obj = result\n            for index in assign_path:\n                if not hasattr(obj, \"elts\"):\n                    raise InferenceError(\n                        \"Wrong type ({targets!r}) for {node!r} assignment\",\n                        node=self,\n                        targets=node,\n                        assign_path=assign_path,\n                        context=context,\n                    )\n                try:\n                    obj = obj.elts[index]\n                except IndexError as exc:\n                    raise InferenceError(\n                        \"Tried to infer a nonexistent target with index {index} \"\n                        \"in {node!r}.\",\n                        node=self,\n                        targets=node,\n                        assign_path=assign_path,\n                        context=context,\n                    ) from exc\n                except TypeError as exc:\n                    raise InferenceError(\n                        \"Tried to unpack a non-iterable value \" \"in {node!r}.\",\n                        node=self,\n                        targets=node,\n                        assign_path=assign_path,\n                        context=context,\n                    ) from exc\n            yield obj\n    return dict(node=self, unknown=node, assign_path=assign_path, context=context)\n", "tokens": ["astroid", "protocols", "py", "def", "with_assigned_stmts", "self", "nodes", "with", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "infer", "names", "and", "other", "nodes", "from", "a", "with", "statement", "this", "enables", "only", "inference", "for", "name", "binding", "in", "a", "with", "statement", "for", "instance", "in", "the", "following", "code", "inferring", "func", "will", "return", "the", "contextmanager", "class", "not", "whatever", "__enter__", "returns", "we", "are", "doing", "this", "intentionally", "because", "we", "consider", "that", "the", "context", "manager", "result", "is", "whatever", "__enter__", "returns", "and", "what", "it", "is", "binded", "using", "the", "as", "keyword", "class", "contextmanager", "object", "def", "__enter__", "self", "return", "42", "with", "contextmanager", "as", "f", "pass", "contextmanager", "infer", "will", "return", "contextmanager", "f", "infer", "will", "return", "42", "arguments", "self", "nodes", "with", "node", "the", "target", "of", "the", "assignment", "as", "a", "b", "in", "with", "foo", "as", "a", "b", "context", "inference", "context", "used", "for", "caching", "already", "inferred", "objects", "assign_path", "a", "list", "of", "indices", "where", "each", "index", "specifies", "what", "item", "to", "fetch", "from", "the", "inference", "results", "try", "mgr", "next", "mgr", "for", "mgr", "vars", "in", "self", "items", "if", "vars", "node", "except", "stopiteration", "return", "none", "if", "assign_path", "is", "none", "yield", "from", "_infer_context_manager", "self", "mgr", "context", "else", "for", "result", "in", "_infer_context_manager", "self", "mgr", "context", "walk", "the", "assign_path", "and", "get", "the", "item", "at", "the", "final", "index", "obj", "result", "for", "index", "in", "assign_path", "if", "not", "hasattr", "obj", "elts", "raise", "inferenceerror", "wrong", "type", "targets", "r", "for", "node", "r", "assignment", "node", "self", "targets", "node", "assign_path", "assign_path", "context", "context", "try", "obj", "obj", "elts", "index", "except", "indexerror", "as", "exc", "raise", "inferenceerror", "tried", "to", "infer", "a", "nonexistent", "target", "with", "index", "index", "in", "node", "r", "node", "self", "targets", "node", "assign_path", "assign_path", "context", "context", "from", "exc", "except", "typeerror", "as", "exc", "raise", "inferenceerror", "tried", "to", "unpack", "a", "non", "iterable", "value", "in", "node", "r", "node", "self", "targets", "node", "assign_path", "assign_path", "context", "context", "from", "exc", "yield", "obj", "return", "dict", "node", "self", "unknown", "node", "assign_path", "assign_path", "context", "context"], "doc_len": 299}
{"doc_id": "astroid/protocols.py::named_expr_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "named_expr_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef named_expr_assigned_stmts(\n    self: nodes.NamedExpr,\n    node: node_classes.AssignedStmtsPossibleNode,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    \"\"\"Infer names and other nodes from an assignment expression\"\"\"\n    if self.target == node:\n        yield from self.value.infer(context=context)\n    else:\n        raise InferenceError(\n            \"Cannot infer NamedExpr node {node!r}\",\n            node=self,\n            assign_path=assign_path,\n            context=context,\n        )\n", "tokens": ["astroid", "protocols", "py", "def", "named_expr_assigned_stmts", "self", "nodes", "namedexpr", "node", "node_classes", "assignedstmtspossiblenode", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "infer", "names", "and", "other", "nodes", "from", "an", "assignment", "expression", "if", "self", "target", "node", "yield", "from", "self", "value", "infer", "context", "context", "else", "raise", "inferenceerror", "cannot", "infer", "namedexpr", "node", "node", "r", "node", "self", "assign_path", "assign_path", "context", "context"], "doc_len": 56}
{"doc_id": "astroid/protocols.py::starred_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "starred_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef starred_assigned_stmts(\n    self: nodes.Starred,\n    node: node_classes.AssignedStmtsPossibleNode = None,\n    context: Optional[InferenceContext] = None,\n    assign_path: Optional[List[int]] = None,\n) -> Any:\n    \"\"\"\n    Arguments:\n        self: nodes.Starred\n        node: a node related to the current underlying Node.\n        context: Inference context used for caching already inferred objects\n        assign_path:\n            A list of indices, where each index specifies what item to fetch from\n            the inference results.\n    \"\"\"\n    # pylint: disable=too-many-locals,too-many-statements\n    def _determine_starred_iteration_lookups(starred, target, lookups):\n        # Determine the lookups for the rhs of the iteration\n        itered = target.itered()\n        for index, element in enumerate(itered):\n            if (\n                isinstance(element, nodes.Starred)\n                and element.value.name == starred.value.name\n            ):\n                lookups.append((index, len(itered)))\n                break\n            if isinstance(element, nodes.Tuple):\n                lookups.append((index, len(element.itered())))\n                _determine_starred_iteration_lookups(starred, element, lookups)\n\n    stmt = self.statement(future=True)\n    if not isinstance(stmt, (nodes.Assign, nodes.For)):\n        raise InferenceError(\n            \"Statement {stmt!r} enclosing {node!r} \" \"must be an Assign or For node.\",\n            node=self,\n            stmt=stmt,\n            unknown=node,\n            context=context,\n        )\n\n    if context is None:\n        context = InferenceContext()\n\n    if isinstance(stmt, nodes.Assign):\n        value = stmt.value\n        lhs = stmt.targets[0]\n\n        if sum(1 for _ in lhs.nodes_of_class(nodes.Starred)) > 1:\n            raise InferenceError(\n                \"Too many starred arguments in the \" \" assignment targets {lhs!r}.\",\n                node=self,\n                targets=lhs,\n                unknown=node,\n                context=context,\n            )\n\n        try:\n            rhs = next(value.infer(context))\n        except (InferenceError, StopIteration):\n            yield util.Uninferable\n            return\n        if rhs is util.Uninferable or not hasattr(rhs, \"itered\"):\n            yield util.Uninferable\n            return\n\n        try:\n            elts = collections.deque(rhs.itered())\n        except TypeError:\n            yield util.Uninferable\n            return\n\n        # Unpack iteratively the values from the rhs of the assignment,\n        # until the find the starred node. What will remain will\n        # be the list of values which the Starred node will represent\n        # This is done in two steps, from left to right to remove\n        # anything before the starred node and from right to left\n        # to remove anything after the starred node.\n\n        for index, left_node in enumerate(lhs.elts):\n            if not isinstance(left_node, nodes.Starred):\n                if not elts:\n                    break\n                elts.popleft()\n                continue\n            lhs_elts = collections.deque(reversed(lhs.elts[index:]))\n            for right_node in lhs_elts:\n                if not isinstance(right_node, nodes.Starred):\n                    if not elts:\n                        break\n                    elts.pop()\n                    continue\n\n                # We're done unpacking.\n                packed = nodes.List(\n                    ctx=Context.Store,\n                    parent=self,\n                    lineno=lhs.lineno,\n                    col_offset=lhs.col_offset,\n                )\n                packed.postinit(elts=list(elts))\n                yield packed\n                break\n\n    if isinstance(stmt, nodes.For):\n        try:\n            inferred_iterable = next(stmt.iter.infer(context=context))\n        except (InferenceError, StopIteration):\n            yield util.Uninferable\n            return\n        if inferred_iterable is util.Uninferable or not hasattr(\n            inferred_iterable, \"itered\"\n        ):\n            yield util.Uninferable\n            return\n        try:\n            itered = inferred_iterable.itered()\n        except TypeError:\n            yield util.Uninferable\n            return\n\n        target = stmt.target\n\n        if not isinstance(target, nodes.Tuple):\n            raise InferenceError(\n                \"Could not make sense of this, the target must be a tuple\",\n                context=context,\n            )\n\n        lookups = []\n        _determine_starred_iteration_lookups(self, target, lookups)\n        if not lookups:\n            raise InferenceError(\n                \"Could not make sense of this, needs at least a lookup\", context=context\n            )\n\n        # Make the last lookup a slice, since that what we want for a Starred node\n        last_element_index, last_element_length = lookups[-1]\n        is_starred_last = last_element_index == (last_element_length - 1)\n\n        lookup_slice = slice(\n            last_element_index,\n            None if is_starred_last else (last_element_length - last_element_index),\n        )\n        lookups[-1] = lookup_slice\n\n        for element in itered:\n\n            # We probably want to infer the potential values *for each* element in an\n            # iterable, but we can't infer a list of all values, when only a list of\n            # step values are expected:\n            #\n            # for a, *b in [...]:\n            #   b\n            #\n            # *b* should now point to just the elements at that particular iteration step,\n            # which astroid can't know about.\n\n            found_element = None\n            for lookup in lookups:\n                if not hasattr(element, \"itered\"):\n                    break\n                if not isinstance(lookup, slice):\n                    # Grab just the index, not the whole length\n                    lookup = lookup[0]\n                try:\n                    itered_inner_element = element.itered()\n                    element = itered_inner_element[lookup]\n                except IndexError:\n                    break\n                except TypeError:\n                    # Most likely the itered() call failed, cannot make sense of this\n                    yield util.Uninferable\n                    return\n                else:\n                    found_element = element\n\n            unpacked = nodes.List(\n                ctx=Context.Store,\n                parent=self,\n                lineno=self.lineno,\n                col_offset=self.col_offset,\n            )\n            unpacked.postinit(elts=found_element or [])\n            yield unpacked\n            return\n\n        yield util.Uninferable\n", "tokens": ["astroid", "protocols", "py", "def", "starred_assigned_stmts", "self", "nodes", "starred", "node", "node_classes", "assignedstmtspossiblenode", "none", "context", "optional", "inferencecontext", "none", "assign_path", "optional", "list", "int", "none", "any", "arguments", "self", "nodes", "starred", "node", "a", "node", "related", "to", "the", "current", "underlying", "node", "context", "inference", "context", "used", "for", "caching", "already", "inferred", "objects", "assign_path", "a", "list", "of", "indices", "where", "each", "index", "specifies", "what", "item", "to", "fetch", "from", "the", "inference", "results", "pylint", "disable", "too", "many", "locals", "too", "many", "statements", "def", "_determine_starred_iteration_lookups", "starred", "target", "lookups", "determine", "the", "lookups", "for", "the", "rhs", "of", "the", "iteration", "itered", "target", "itered", "for", "index", "element", "in", "enumerate", "itered", "if", "isinstance", "element", "nodes", "starred", "and", "element", "value", "name", "starred", "value", "name", "lookups", "append", "index", "len", "itered", "break", "if", "isinstance", "element", "nodes", "tuple", "lookups", "append", "index", "len", "element", "itered", "_determine_starred_iteration_lookups", "starred", "element", "lookups", "stmt", "self", "statement", "future", "true", "if", "not", "isinstance", "stmt", "nodes", "assign", "nodes", "for", "raise", "inferenceerror", "statement", "stmt", "r", "enclosing", "node", "r", "must", "be", "an", "assign", "or", "for", "node", "node", "self", "stmt", "stmt", "unknown", "node", "context", "context", "if", "context", "is", "none", "context", "inferencecontext", "if", "isinstance", "stmt", "nodes", "assign", "value", "stmt", "value", "lhs", "stmt", "targets", "0", "if", "sum", "1", "for", "_", "in", "lhs", "nodes_of_class", "nodes", "starred", "1", "raise", "inferenceerror", "too", "many", "starred", "arguments", "in", "the", "assignment", "targets", "lhs", "r", "node", "self", "targets", "lhs", "unknown", "node", "context", "context", "try", "rhs", "next", "value", "infer", "context", "except", "inferenceerror", "stopiteration", "yield", "util", "uninferable", "return", "if", "rhs", "is", "util", "uninferable", "or", "not", "hasattr", "rhs", "itered", "yield", "util", "uninferable", "return", "try", "elts", "collections", "deque", "rhs", "itered", "except", "typeerror", "yield", "util", "uninferable", "return", "unpack", "iteratively", "the", "values", "from", "the", "rhs", "of", "the", "assignment", "until", "the", "find", "the", "starred", "node", "what", "will", "remain", "will", "be", "the", "list", "of", "values", "which", "the", "starred", "node", "will", "represent", "this", "is", "done", "in", "two", "steps", "from", "left", "to", "right", "to", "remove", "anything", "before", "the", "starred", "node", "and", "from", "right", "to", "left", "to", "remove", "anything", "after", "the", "starred", "node", "for", "index", "left_node", "in", "enumerate", "lhs", "elts", "if", "not", "isinstance", "left_node", "nodes", "starred", "if", "not", "elts", "break", "elts", "popleft", "continue", "lhs_elts", "collections", "deque", "reversed", "lhs", "elts", "index", "for", "right_node", "in", "lhs_elts", "if", "not", "isinstance", "right_node", "nodes", "starred", "if", "not", "elts", "break", "elts", "pop", "continue", "we", "re", "done", "unpacking", "packed", "nodes", "list", "ctx", "context", "store", "parent", "self", "lineno", "lhs", "lineno", "col_offset", "lhs", "col_offset", "packed", "postinit", "elts", "list", "elts", "yield", "packed", "break", "if", "isinstance", "stmt", "nodes", "for", "try", "inferred_iterable", "next", "stmt", "iter", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "yield", "util", "uninferable", "return", "if", "inferred_iterable", "is", "util", "uninferable", "or", "not", "hasattr", "inferred_iterable", "itered", "yield", "util", "uninferable", "return", "try", "itered", "inferred_iterable", "itered", "except", "typeerror", "yield", "util", "uninferable", "return", "target", "stmt", "target", "if", "not", "isinstance", "target", "nodes", "tuple", "raise", "inferenceerror", "could", "not", "make", "sense", "of", "this", "the", "target", "must", "be", "a", "tuple", "context", "context", "lookups", "_determine_starred_iteration_lookups", "self", "target", "lookups", "if", "not", "lookups", "raise", "inferenceerror", "could", "not", "make", "sense", "of", "this", "needs", "at", "least", "a", "lookup", "context", "context", "make", "the", "last", "lookup", "a", "slice", "since", "that", "what", "we", "want", "for", "a", "starred", "node", "last_element_index", "last_element_length", "lookups", "1", "is_starred_last", "last_element_index", "last_element_length", "1", "lookup_slice", "slice", "last_element_index", "none", "if", "is_starred_last", "else", "last_element_length", "last_element_index", "lookups", "1", "lookup_slice", "for", "element", "in", "itered", "we", "probably", "want", "to", "infer", "the", "potential", "values", "for", "each", "element", "in", "an", "iterable", "but", "we", "can", "t", "infer", "a", "list", "of", "all", "values", "when", "only", "a", "list", "of", "step", "values", "are", "expected", "for", "a", "b", "in", "b", "b", "should", "now", "point", "to", "just", "the", "elements", "at", "that", "particular", "iteration", "step", "which", "astroid", "can", "t", "know", "about", "found_element", "none", "for", "lookup", "in", "lookups", "if", "not", "hasattr", "element", "itered", "break", "if", "not", "isinstance", "lookup", "slice", "grab", "just", "the", "index", "not", "the", "whole", "length", "lookup", "lookup", "0", "try", "itered_inner_element", "element", "itered", "element", "itered_inner_element", "lookup", "except", "indexerror", "break", "except", "typeerror", "most", "likely", "the", "itered", "call", "failed", "cannot", "make", "sense", "of", "this", "yield", "util", "uninferable", "return", "else", "found_element", "element", "unpacked", "nodes", "list", "ctx", "context", "store", "parent", "self", "lineno", "self", "lineno", "col_offset", "self", "col_offset", "unpacked", "postinit", "elts", "found_element", "or", "yield", "unpacked", "return", "yield", "util", "uninferable"], "doc_len": 650}
{"doc_id": "astroid/protocols.py::match_mapping_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "match_mapping_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef match_mapping_assigned_stmts(\n    self: nodes.MatchMapping,\n    node: nodes.AssignName,\n    context: Optional[InferenceContext] = None,\n    assign_path: Literal[None] = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.\n    \"\"\"\n    return\n    yield\n", "tokens": ["astroid", "protocols", "py", "def", "match_mapping_assigned_stmts", "self", "nodes", "matchmapping", "node", "nodes", "assignname", "context", "optional", "inferencecontext", "none", "assign_path", "literal", "none", "none", "generator", "nodes", "nodeng", "none", "none", "return", "empty", "generator", "return", "raises", "stopiteration", "so", "inferred", "value", "is", "uninferable", "return", "yield"], "doc_len": 37}
{"doc_id": "astroid/protocols.py::match_star_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "match_star_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef match_star_assigned_stmts(\n    self: nodes.MatchStar,\n    node: nodes.AssignName,\n    context: Optional[InferenceContext] = None,\n    assign_path: Literal[None] = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Return empty generator (return -> raises StopIteration) so inferred value\n    is Uninferable.\n    \"\"\"\n    return\n    yield\n", "tokens": ["astroid", "protocols", "py", "def", "match_star_assigned_stmts", "self", "nodes", "matchstar", "node", "nodes", "assignname", "context", "optional", "inferencecontext", "none", "assign_path", "literal", "none", "none", "generator", "nodes", "nodeng", "none", "none", "return", "empty", "generator", "return", "raises", "stopiteration", "so", "inferred", "value", "is", "uninferable", "return", "yield"], "doc_len": 37}
{"doc_id": "astroid/protocols.py::match_as_assigned_stmts", "file_path": "astroid/protocols.py", "class_name": null, "func_name": "match_as_assigned_stmts", "text": "文件路径: astroid/protocols.py\ndef match_as_assigned_stmts(\n    self: nodes.MatchAs,\n    node: nodes.AssignName,\n    context: Optional[InferenceContext] = None,\n    assign_path: Literal[None] = None,\n) -> Generator[nodes.NodeNG, None, None]:\n    \"\"\"Infer MatchAs as the Match subject if it's the only MatchCase pattern\n    else raise StopIteration to yield Uninferable.\n    \"\"\"\n    if (\n        isinstance(self.parent, nodes.MatchCase)\n        and isinstance(self.parent.parent, nodes.Match)\n        and self.pattern is None\n    ):\n        yield self.parent.parent.subject\n", "tokens": ["astroid", "protocols", "py", "def", "match_as_assigned_stmts", "self", "nodes", "matchas", "node", "nodes", "assignname", "context", "optional", "inferencecontext", "none", "assign_path", "literal", "none", "none", "generator", "nodes", "nodeng", "none", "none", "infer", "matchas", "as", "the", "match", "subject", "if", "it", "s", "the", "only", "matchcase", "pattern", "else", "raise", "stopiteration", "to", "yield", "uninferable", "if", "isinstance", "self", "parent", "nodes", "matchcase", "and", "isinstance", "self", "parent", "parent", "nodes", "match", "and", "self", "pattern", "is", "none", "yield", "self", "parent", "parent", "subject"], "doc_len": 66}
{"doc_id": "astroid/raw_building.py::_io_discrepancy", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_io_discrepancy", "text": "文件路径: astroid/raw_building.py\ndef _io_discrepancy(member):\n    # _io module names itself `io`: http://bugs.python.org/issue18602\n    member_self = getattr(member, \"__self__\", None)\n    return (\n        member_self\n        and inspect.ismodule(member_self)\n        and member_self.__name__ == \"_io\"\n        and member.__module__ == \"io\"\n    )\n", "tokens": ["astroid", "raw_building", "py", "def", "_io_discrepancy", "member", "_io", "module", "names", "itself", "io", "http", "bugs", "python", "org", "issue18602", "member_self", "getattr", "member", "__self__", "none", "return", "member_self", "and", "inspect", "ismodule", "member_self", "and", "member_self", "__name__", "_io", "and", "member", "__module__", "io"], "doc_len": 35}
{"doc_id": "astroid/raw_building.py::_attach_local_node", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_attach_local_node", "text": "文件路径: astroid/raw_building.py\ndef _attach_local_node(parent, node, name):\n    node.name = name  # needed by add_local_node\n    parent.add_local_node(node)\n", "tokens": ["astroid", "raw_building", "py", "def", "_attach_local_node", "parent", "node", "name", "node", "name", "name", "needed", "by", "add_local_node", "parent", "add_local_node", "node"], "doc_len": 17}
{"doc_id": "astroid/raw_building.py::_add_dunder_class", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_add_dunder_class", "text": "文件路径: astroid/raw_building.py\ndef _add_dunder_class(func, member):\n    \"\"\"Add a __class__ member to the given func node, if we can determine it.\"\"\"\n    python_cls = member.__class__\n    cls_name = getattr(python_cls, \"__name__\", None)\n    if not cls_name:\n        return\n    cls_bases = [ancestor.__name__ for ancestor in python_cls.__bases__]\n    ast_klass = build_class(cls_name, cls_bases, python_cls.__doc__)\n    func.instance_attrs[\"__class__\"] = [ast_klass]\n", "tokens": ["astroid", "raw_building", "py", "def", "_add_dunder_class", "func", "member", "add", "a", "__class__", "member", "to", "the", "given", "func", "node", "if", "we", "can", "determine", "it", "python_cls", "member", "__class__", "cls_name", "getattr", "python_cls", "__name__", "none", "if", "not", "cls_name", "return", "cls_bases", "ancestor", "__name__", "for", "ancestor", "in", "python_cls", "__bases__", "ast_klass", "build_class", "cls_name", "cls_bases", "python_cls", "__doc__", "func", "instance_attrs", "__class__", "ast_klass"], "doc_len": 51}
{"doc_id": "astroid/raw_building.py::attach_dummy_node", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "attach_dummy_node", "text": "文件路径: astroid/raw_building.py\ndef attach_dummy_node(node, name, runtime_object=_marker):\n    \"\"\"create a dummy node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    enode = nodes.EmptyNode()\n    enode.object = runtime_object\n    _attach_local_node(node, enode, name)\n", "tokens": ["astroid", "raw_building", "py", "def", "attach_dummy_node", "node", "name", "runtime_object", "_marker", "create", "a", "dummy", "node", "and", "register", "it", "in", "the", "locals", "of", "the", "given", "node", "with", "the", "specified", "name", "enode", "nodes", "emptynode", "enode", "object", "runtime_object", "_attach_local_node", "node", "enode", "name"], "doc_len": 37}
{"doc_id": "astroid/raw_building.py::_has_underlying_object", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_has_underlying_object", "text": "文件路径: astroid/raw_building.py\ndef _has_underlying_object(self):\n    return self.object is not None and self.object is not _marker\n", "tokens": ["astroid", "raw_building", "py", "def", "_has_underlying_object", "self", "return", "self", "object", "is", "not", "none", "and", "self", "object", "is", "not", "_marker"], "doc_len": 18}
{"doc_id": "astroid/raw_building.py::attach_const_node", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "attach_const_node", "text": "文件路径: astroid/raw_building.py\ndef attach_const_node(node, name, value):\n    \"\"\"create a Const node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    if name not in node.special_attributes:\n        _attach_local_node(node, nodes.const_factory(value), name)\n", "tokens": ["astroid", "raw_building", "py", "def", "attach_const_node", "node", "name", "value", "create", "a", "const", "node", "and", "register", "it", "in", "the", "locals", "of", "the", "given", "node", "with", "the", "specified", "name", "if", "name", "not", "in", "node", "special_attributes", "_attach_local_node", "node", "nodes", "const_factory", "value", "name"], "doc_len": 38}
{"doc_id": "astroid/raw_building.py::attach_import_node", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "attach_import_node", "text": "文件路径: astroid/raw_building.py\ndef attach_import_node(node, modname, membername):\n    \"\"\"create a ImportFrom node and register it in the locals of the given\n    node with the specified name\n    \"\"\"\n    from_node = nodes.ImportFrom(modname, [(membername, None)])\n    _attach_local_node(node, from_node, membername)\n", "tokens": ["astroid", "raw_building", "py", "def", "attach_import_node", "node", "modname", "membername", "create", "a", "importfrom", "node", "and", "register", "it", "in", "the", "locals", "of", "the", "given", "node", "with", "the", "specified", "name", "from_node", "nodes", "importfrom", "modname", "membername", "none", "_attach_local_node", "node", "from_node", "membername"], "doc_len": 36}
{"doc_id": "astroid/raw_building.py::build_module", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "build_module", "text": "文件路径: astroid/raw_building.py\ndef build_module(name: str, doc: Optional[str] = None) -> nodes.Module:\n    \"\"\"create and initialize an astroid Module node\"\"\"\n    node = nodes.Module(name, doc, pure_python=False)\n    node.package = False\n    node.parent = None\n    return node\n", "tokens": ["astroid", "raw_building", "py", "def", "build_module", "name", "str", "doc", "optional", "str", "none", "nodes", "module", "create", "and", "initialize", "an", "astroid", "module", "node", "node", "nodes", "module", "name", "doc", "pure_python", "false", "node", "package", "false", "node", "parent", "none", "return", "node"], "doc_len": 35}
{"doc_id": "astroid/raw_building.py::build_class", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "build_class", "text": "文件路径: astroid/raw_building.py\ndef build_class(name, basenames=(), doc=None):\n    \"\"\"create and initialize an astroid ClassDef node\"\"\"\n    node = nodes.ClassDef(name, doc)\n    for base in basenames:\n        basenode = nodes.Name(name=base)\n        node.bases.append(basenode)\n        basenode.parent = node\n    return node\n", "tokens": ["astroid", "raw_building", "py", "def", "build_class", "name", "basenames", "doc", "none", "create", "and", "initialize", "an", "astroid", "classdef", "node", "node", "nodes", "classdef", "name", "doc", "for", "base", "in", "basenames", "basenode", "nodes", "name", "name", "base", "node", "bases", "append", "basenode", "basenode", "parent", "node", "return", "node"], "doc_len": 39}
{"doc_id": "astroid/raw_building.py::build_function", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "build_function", "text": "文件路径: astroid/raw_building.py\ndef build_function(\n    name,\n    args: Optional[List[str]] = None,\n    posonlyargs: Optional[List[str]] = None,\n    defaults=None,\n    doc=None,\n    kwonlyargs: Optional[List[str]] = None,\n) -> nodes.FunctionDef:\n    \"\"\"create and initialize an astroid FunctionDef node\"\"\"\n    # first argument is now a list of decorators\n    func = nodes.FunctionDef(name, doc)\n    func.args = argsnode = nodes.Arguments(parent=func)\n    argsnode.postinit(\n        args=[nodes.AssignName(name=arg, parent=argsnode) for arg in args or ()],\n        defaults=[],\n        kwonlyargs=[\n            nodes.AssignName(name=arg, parent=argsnode) for arg in kwonlyargs or ()\n        ],\n        kw_defaults=[],\n        annotations=[],\n        posonlyargs=[\n            nodes.AssignName(name=arg, parent=argsnode) for arg in posonlyargs or ()\n        ],\n    )\n    for default in defaults or ():\n        argsnode.defaults.append(nodes.const_factory(default))\n        argsnode.defaults[-1].parent = argsnode\n    if args:\n        register_arguments(func)\n    return func\n", "tokens": ["astroid", "raw_building", "py", "def", "build_function", "name", "args", "optional", "list", "str", "none", "posonlyargs", "optional", "list", "str", "none", "defaults", "none", "doc", "none", "kwonlyargs", "optional", "list", "str", "none", "nodes", "functiondef", "create", "and", "initialize", "an", "astroid", "functiondef", "node", "first", "argument", "is", "now", "a", "list", "of", "decorators", "func", "nodes", "functiondef", "name", "doc", "func", "args", "argsnode", "nodes", "arguments", "parent", "func", "argsnode", "postinit", "args", "nodes", "assignname", "name", "arg", "parent", "argsnode", "for", "arg", "in", "args", "or", "defaults", "kwonlyargs", "nodes", "assignname", "name", "arg", "parent", "argsnode", "for", "arg", "in", "kwonlyargs", "or", "kw_defaults", "annotations", "posonlyargs", "nodes", "assignname", "name", "arg", "parent", "argsnode", "for", "arg", "in", "posonlyargs", "or", "for", "default", "in", "defaults", "or", "argsnode", "defaults", "append", "nodes", "const_factory", "default", "argsnode", "defaults", "1", "parent", "argsnode", "if", "args", "register_arguments", "func", "return", "func"], "doc_len": 117}
{"doc_id": "astroid/raw_building.py::build_from_import", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "build_from_import", "text": "文件路径: astroid/raw_building.py\ndef build_from_import(fromname, names):\n    \"\"\"create and initialize an astroid ImportFrom import statement\"\"\"\n    return nodes.ImportFrom(fromname, [(name, None) for name in names])\n", "tokens": ["astroid", "raw_building", "py", "def", "build_from_import", "fromname", "names", "create", "and", "initialize", "an", "astroid", "importfrom", "import", "statement", "return", "nodes", "importfrom", "fromname", "name", "none", "for", "name", "in", "names"], "doc_len": 25}
{"doc_id": "astroid/raw_building.py::register_arguments", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "register_arguments", "text": "文件路径: astroid/raw_building.py\ndef register_arguments(func, args=None):\n    \"\"\"add given arguments to local\n\n    args is a list that may contains nested lists\n    (i.e. def func(a, (b, c, d)): ...)\n    \"\"\"\n    if args is None:\n        args = func.args.args\n        if func.args.vararg:\n            func.set_local(func.args.vararg, func.args)\n        if func.args.kwarg:\n            func.set_local(func.args.kwarg, func.args)\n    for arg in args:\n        if isinstance(arg, nodes.AssignName):\n            func.set_local(arg.name, arg)\n        else:\n            register_arguments(func, arg.elts)\n", "tokens": ["astroid", "raw_building", "py", "def", "register_arguments", "func", "args", "none", "add", "given", "arguments", "to", "local", "args", "is", "a", "list", "that", "may", "contains", "nested", "lists", "i", "e", "def", "func", "a", "b", "c", "d", "if", "args", "is", "none", "args", "func", "args", "args", "if", "func", "args", "vararg", "func", "set_local", "func", "args", "vararg", "func", "args", "if", "func", "args", "kwarg", "func", "set_local", "func", "args", "kwarg", "func", "args", "for", "arg", "in", "args", "if", "isinstance", "arg", "nodes", "assignname", "func", "set_local", "arg", "name", "arg", "else", "register_arguments", "func", "arg", "elts"], "doc_len": 79}
{"doc_id": "astroid/raw_building.py::object_build_class", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "object_build_class", "text": "文件路径: astroid/raw_building.py\ndef object_build_class(node, member, localname):\n    \"\"\"create astroid for a living class object\"\"\"\n    basenames = [base.__name__ for base in member.__bases__]\n    return _base_class_object_build(node, member, basenames, localname=localname)\n", "tokens": ["astroid", "raw_building", "py", "def", "object_build_class", "node", "member", "localname", "create", "astroid", "for", "a", "living", "class", "object", "basenames", "base", "__name__", "for", "base", "in", "member", "__bases__", "return", "_base_class_object_build", "node", "member", "basenames", "localname", "localname"], "doc_len": 30}
{"doc_id": "astroid/raw_building.py::object_build_function", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "object_build_function", "text": "文件路径: astroid/raw_building.py\ndef object_build_function(node, member, localname):\n    \"\"\"create astroid for a living function object\"\"\"\n    signature = inspect.signature(member)\n    args = []\n    defaults = []\n    posonlyargs = []\n    kwonlyargs = []\n    for param_name, param in signature.parameters.items():\n        if param.kind == inspect.Parameter.POSITIONAL_ONLY:\n            posonlyargs.append(param_name)\n        elif param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n            args.append(param_name)\n        elif param.kind == inspect.Parameter.VAR_POSITIONAL:\n            args.append(param_name)\n        elif param.kind == inspect.Parameter.VAR_KEYWORD:\n            args.append(param_name)\n        elif param.kind == inspect.Parameter.KEYWORD_ONLY:\n            kwonlyargs.append(param_name)\n        if param.default is not inspect._empty:\n            defaults.append(param.default)\n    func = build_function(\n        getattr(member, \"__name__\", None) or localname,\n        args,\n        posonlyargs,\n        defaults,\n        member.__doc__,\n    )\n    node.add_local_node(func, localname)\n", "tokens": ["astroid", "raw_building", "py", "def", "object_build_function", "node", "member", "localname", "create", "astroid", "for", "a", "living", "function", "object", "signature", "inspect", "signature", "member", "args", "defaults", "posonlyargs", "kwonlyargs", "for", "param_name", "param", "in", "signature", "parameters", "items", "if", "param", "kind", "inspect", "parameter", "positional_only", "posonlyargs", "append", "param_name", "elif", "param", "kind", "inspect", "parameter", "positional_or_keyword", "args", "append", "param_name", "elif", "param", "kind", "inspect", "parameter", "var_positional", "args", "append", "param_name", "elif", "param", "kind", "inspect", "parameter", "var_keyword", "args", "append", "param_name", "elif", "param", "kind", "inspect", "parameter", "keyword_only", "kwonlyargs", "append", "param_name", "if", "param", "default", "is", "not", "inspect", "_empty", "defaults", "append", "param", "default", "func", "build_function", "getattr", "member", "__name__", "none", "or", "localname", "args", "posonlyargs", "defaults", "member", "__doc__", "node", "add_local_node", "func", "localname"], "doc_len": 103}
{"doc_id": "astroid/raw_building.py::object_build_datadescriptor", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "object_build_datadescriptor", "text": "文件路径: astroid/raw_building.py\ndef object_build_datadescriptor(node, member, name):\n    \"\"\"create astroid for a living data descriptor object\"\"\"\n    return _base_class_object_build(node, member, [], name)\n", "tokens": ["astroid", "raw_building", "py", "def", "object_build_datadescriptor", "node", "member", "name", "create", "astroid", "for", "a", "living", "data", "descriptor", "object", "return", "_base_class_object_build", "node", "member", "name"], "doc_len": 21}
{"doc_id": "astroid/raw_building.py::object_build_methoddescriptor", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "object_build_methoddescriptor", "text": "文件路径: astroid/raw_building.py\ndef object_build_methoddescriptor(node, member, localname):\n    \"\"\"create astroid for a living method descriptor object\"\"\"\n    # FIXME get arguments ?\n    func = build_function(\n        getattr(member, \"__name__\", None) or localname, doc=member.__doc__\n    )\n    # set node's arguments to None to notice that we have no information, not\n    # and empty argument list\n    func.args.args = None\n    node.add_local_node(func, localname)\n    _add_dunder_class(func, member)\n", "tokens": ["astroid", "raw_building", "py", "def", "object_build_methoddescriptor", "node", "member", "localname", "create", "astroid", "for", "a", "living", "method", "descriptor", "object", "fixme", "get", "arguments", "func", "build_function", "getattr", "member", "__name__", "none", "or", "localname", "doc", "member", "__doc__", "set", "node", "s", "arguments", "to", "none", "to", "notice", "that", "we", "have", "no", "information", "not", "and", "empty", "argument", "list", "func", "args", "args", "none", "node", "add_local_node", "func", "localname", "_add_dunder_class", "func", "member"], "doc_len": 59}
{"doc_id": "astroid/raw_building.py::_base_class_object_build", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_base_class_object_build", "text": "文件路径: astroid/raw_building.py\ndef _base_class_object_build(node, member, basenames, name=None, localname=None):\n    \"\"\"create astroid for a living class object, with a given set of base names\n    (e.g. ancestors)\n    \"\"\"\n    klass = build_class(\n        name or getattr(member, \"__name__\", None) or localname,\n        basenames,\n        member.__doc__,\n    )\n    klass._newstyle = isinstance(member, type)\n    node.add_local_node(klass, localname)\n    try:\n        # limit the instantiation trick since it's too dangerous\n        # (such as infinite test execution...)\n        # this at least resolves common case such as Exception.args,\n        # OSError.errno\n        if issubclass(member, Exception):\n            instdict = member().__dict__\n        else:\n            raise TypeError\n    except TypeError:\n        pass\n    else:\n        for item_name, obj in instdict.items():\n            valnode = nodes.EmptyNode()\n            valnode.object = obj\n            valnode.parent = klass\n            valnode.lineno = 1\n            klass.instance_attrs[item_name] = [valnode]\n    return klass\n", "tokens": ["astroid", "raw_building", "py", "def", "_base_class_object_build", "node", "member", "basenames", "name", "none", "localname", "none", "create", "astroid", "for", "a", "living", "class", "object", "with", "a", "given", "set", "of", "base", "names", "e", "g", "ancestors", "klass", "build_class", "name", "or", "getattr", "member", "__name__", "none", "or", "localname", "basenames", "member", "__doc__", "klass", "_newstyle", "isinstance", "member", "type", "node", "add_local_node", "klass", "localname", "try", "limit", "the", "instantiation", "trick", "since", "it", "s", "too", "dangerous", "such", "as", "infinite", "test", "execution", "this", "at", "least", "resolves", "common", "case", "such", "as", "exception", "args", "oserror", "errno", "if", "issubclass", "member", "exception", "instdict", "member", "__dict__", "else", "raise", "typeerror", "except", "typeerror", "pass", "else", "for", "item_name", "obj", "in", "instdict", "items", "valnode", "nodes", "emptynode", "valnode", "object", "obj", "valnode", "parent", "klass", "valnode", "lineno", "1", "klass", "instance_attrs", "item_name", "valnode", "return", "klass"], "doc_len": 116}
{"doc_id": "astroid/raw_building.py::_build_from_function", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_build_from_function", "text": "文件路径: astroid/raw_building.py\ndef _build_from_function(node, name, member, module):\n    # verify this is not an imported function\n    try:\n        code = member.__code__\n    except AttributeError:\n        # Some implementations don't provide the code object,\n        # such as Jython.\n        code = None\n    filename = getattr(code, \"co_filename\", None)\n    if filename is None:\n        assert isinstance(member, object)\n        object_build_methoddescriptor(node, member, name)\n    elif filename != getattr(module, \"__file__\", None):\n        attach_dummy_node(node, name, member)\n    else:\n        object_build_function(node, member, name)\n", "tokens": ["astroid", "raw_building", "py", "def", "_build_from_function", "node", "name", "member", "module", "verify", "this", "is", "not", "an", "imported", "function", "try", "code", "member", "__code__", "except", "attributeerror", "some", "implementations", "don", "t", "provide", "the", "code", "object", "such", "as", "jython", "code", "none", "filename", "getattr", "code", "co_filename", "none", "if", "filename", "is", "none", "assert", "isinstance", "member", "object", "object_build_methoddescriptor", "node", "member", "name", "elif", "filename", "getattr", "module", "__file__", "none", "attach_dummy_node", "node", "name", "member", "else", "object_build_function", "node", "member", "name"], "doc_len": 67}
{"doc_id": "astroid/raw_building.py::_safe_has_attribute", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_safe_has_attribute", "text": "文件路径: astroid/raw_building.py\ndef _safe_has_attribute(obj, member):\n    try:\n        return hasattr(obj, member)\n    except Exception:  # pylint: disable=broad-except\n        return False\n", "tokens": ["astroid", "raw_building", "py", "def", "_safe_has_attribute", "obj", "member", "try", "return", "hasattr", "obj", "member", "except", "exception", "pylint", "disable", "broad", "except", "return", "false"], "doc_len": 20}
{"doc_id": "astroid/raw_building.py::InspectBuilder.__init__", "file_path": "astroid/raw_building.py", "class_name": "InspectBuilder", "func_name": "__init__", "text": "文件路径: astroid/raw_building.py, 类名: InspectBuilder\n    def __init__(self, manager_instance=None):\n        self._manager = manager_instance or AstroidManager()\n        self._done = {}\n        self._module = None\n", "tokens": ["astroid", "raw_building", "py", "inspectbuilder", "def", "__init__", "self", "manager_instance", "none", "self", "_manager", "manager_instance", "or", "astroidmanager", "self", "_done", "self", "_module", "none"], "doc_len": 19}
{"doc_id": "astroid/raw_building.py::InspectBuilder.inspect_build", "file_path": "astroid/raw_building.py", "class_name": "InspectBuilder", "func_name": "inspect_build", "text": "文件路径: astroid/raw_building.py, 类名: InspectBuilder\n    def inspect_build(\n        self,\n        module: types.ModuleType,\n        modname: Optional[str] = None,\n        path: Optional[str] = None,\n    ) -> nodes.Module:\n        \"\"\"build astroid from a living module (i.e. using inspect)\n        this is used when there is no python source code available (either\n        because it's a built-in module or because the .py is not available)\n        \"\"\"\n        self._module = module\n        if modname is None:\n            modname = module.__name__\n        try:\n            node = build_module(modname, module.__doc__)\n        except AttributeError:\n            # in jython, java modules have no __doc__ (see #109562)\n            node = build_module(modname)\n        node.file = node.path = os.path.abspath(path) if path else path\n        node.name = modname\n        self._manager.cache_module(node)\n        node.package = hasattr(module, \"__path__\")\n        self._done = {}\n        self.object_build(node, module)\n        return node\n", "tokens": ["astroid", "raw_building", "py", "inspectbuilder", "def", "inspect_build", "self", "module", "types", "moduletype", "modname", "optional", "str", "none", "path", "optional", "str", "none", "nodes", "module", "build", "astroid", "from", "a", "living", "module", "i", "e", "using", "inspect", "this", "is", "used", "when", "there", "is", "no", "python", "source", "code", "available", "either", "because", "it", "s", "a", "built", "in", "module", "or", "because", "the", "py", "is", "not", "available", "self", "_module", "module", "if", "modname", "is", "none", "modname", "module", "__name__", "try", "node", "build_module", "modname", "module", "__doc__", "except", "attributeerror", "in", "jython", "java", "modules", "have", "no", "__doc__", "see", "109562", "node", "build_module", "modname", "node", "file", "node", "path", "os", "path", "abspath", "path", "if", "path", "else", "path", "node", "name", "modname", "self", "_manager", "cache_module", "node", "node", "package", "hasattr", "module", "__path__", "self", "_done", "self", "object_build", "node", "module", "return", "node"], "doc_len": 118}
{"doc_id": "astroid/raw_building.py::InspectBuilder.object_build", "file_path": "astroid/raw_building.py", "class_name": "InspectBuilder", "func_name": "object_build", "text": "文件路径: astroid/raw_building.py, 类名: InspectBuilder\n    def object_build(self, node, obj):\n        \"\"\"recursive method which create a partial ast from real objects\n        (only function, class, and method are handled)\n        \"\"\"\n        if obj in self._done:\n            return self._done[obj]\n        self._done[obj] = node\n        for name in dir(obj):\n            try:\n                with warnings.catch_warnings():\n                    warnings.filterwarnings(\"error\")\n                    member = getattr(obj, name)\n            except (AttributeError, DeprecationWarning):\n                # damned ExtensionClass.Base, I know you're there !\n                attach_dummy_node(node, name)\n                continue\n            if inspect.ismethod(member):\n                member = member.__func__\n            if inspect.isfunction(member):\n                _build_from_function(node, name, member, self._module)\n            elif inspect.isbuiltin(member):\n                if not _io_discrepancy(member) and self.imported_member(\n                    node, member, name\n                ):\n                    continue\n                object_build_methoddescriptor(node, member, name)\n            elif inspect.isclass(member):\n                if self.imported_member(node, member, name):\n                    continue\n                if member in self._done:\n                    class_node = self._done[member]\n                    if class_node not in node.locals.get(name, ()):\n                        node.add_local_node(class_node, name)\n                else:\n                    class_node = object_build_class(node, member, name)\n                    # recursion\n                    self.object_build(class_node, member)\n                if name == \"__class__\" and class_node.parent is None:\n                    class_node.parent = self._done[self._module]\n            elif inspect.ismethoddescriptor(member):\n                assert isinstance(member, object)\n                object_build_methoddescriptor(node, member, name)\n            elif inspect.isdatadescriptor(member):\n                assert isinstance(member, object)\n                object_build_datadescriptor(node, member, name)\n            elif isinstance(member, _CONSTANTS):\n                attach_const_node(node, name, member)\n            elif inspect.isroutine(member):\n                # This should be called for Jython, where some builtin\n                # methods aren't caught by isbuiltin branch.\n                _build_from_function(node, name, member, self._module)\n            elif _safe_has_attribute(member, \"__all__\"):\n                module = build_module(name)\n                _attach_local_node(node, module, name)\n                # recursion\n                self.object_build(module, member)\n            else:\n                # create an empty node so that the name is actually defined\n                attach_dummy_node(node, name, member)\n        return None\n", "tokens": ["astroid", "raw_building", "py", "inspectbuilder", "def", "object_build", "self", "node", "obj", "recursive", "method", "which", "create", "a", "partial", "ast", "from", "real", "objects", "only", "function", "class", "and", "method", "are", "handled", "if", "obj", "in", "self", "_done", "return", "self", "_done", "obj", "self", "_done", "obj", "node", "for", "name", "in", "dir", "obj", "try", "with", "warnings", "catch_warnings", "warnings", "filterwarnings", "error", "member", "getattr", "obj", "name", "except", "attributeerror", "deprecationwarning", "damned", "extensionclass", "base", "i", "know", "you", "re", "there", "attach_dummy_node", "node", "name", "continue", "if", "inspect", "ismethod", "member", "member", "member", "__func__", "if", "inspect", "isfunction", "member", "_build_from_function", "node", "name", "member", "self", "_module", "elif", "inspect", "isbuiltin", "member", "if", "not", "_io_discrepancy", "member", "and", "self", "imported_member", "node", "member", "name", "continue", "object_build_methoddescriptor", "node", "member", "name", "elif", "inspect", "isclass", "member", "if", "self", "imported_member", "node", "member", "name", "continue", "if", "member", "in", "self", "_done", "class_node", "self", "_done", "member", "if", "class_node", "not", "in", "node", "locals", "get", "name", "node", "add_local_node", "class_node", "name", "else", "class_node", "object_build_class", "node", "member", "name", "recursion", "self", "object_build", "class_node", "member", "if", "name", "__class__", "and", "class_node", "parent", "is", "none", "class_node", "parent", "self", "_done", "self", "_module", "elif", "inspect", "ismethoddescriptor", "member", "assert", "isinstance", "member", "object", "object_build_methoddescriptor", "node", "member", "name", "elif", "inspect", "isdatadescriptor", "member", "assert", "isinstance", "member", "object", "object_build_datadescriptor", "node", "member", "name", "elif", "isinstance", "member", "_constants", "attach_const_node", "node", "name", "member", "elif", "inspect", "isroutine", "member", "this", "should", "be", "called", "for", "jython", "where", "some", "builtin", "methods", "aren", "t", "caught", "by", "isbuiltin", "branch", "_build_from_function", "node", "name", "member", "self", "_module", "elif", "_safe_has_attribute", "member", "__all__", "module", "build_module", "name", "_attach_local_node", "node", "module", "name", "recursion", "self", "object_build", "module", "member", "else", "create", "an", "empty", "node", "so", "that", "the", "name", "is", "actually", "defined", "attach_dummy_node", "node", "name", "member", "return", "none"], "doc_len": 255}
{"doc_id": "astroid/raw_building.py::InspectBuilder.imported_member", "file_path": "astroid/raw_building.py", "class_name": "InspectBuilder", "func_name": "imported_member", "text": "文件路径: astroid/raw_building.py, 类名: InspectBuilder\n    def imported_member(self, node, member, name):\n        \"\"\"verify this is not an imported class or handle it\"\"\"\n        # /!\\ some classes like ExtensionClass doesn't have a __module__\n        # attribute ! Also, this may trigger an exception on badly built module\n        # (see http://www.logilab.org/ticket/57299 for instance)\n        try:\n            modname = getattr(member, \"__module__\", None)\n        except TypeError:\n            modname = None\n        if modname is None:\n            if name in {\"__new__\", \"__subclasshook__\"}:\n                # Python 2.5.1 (r251:54863, Sep  1 2010, 22:03:14)\n                # >>> print object.__new__.__module__\n                # None\n                modname = builtins.__name__\n            else:\n                attach_dummy_node(node, name, member)\n                return True\n\n        real_name = {\"gtk\": \"gtk_gtk\", \"_io\": \"io\"}.get(modname, modname)\n\n        if real_name != self._module.__name__:\n            # check if it sounds valid and then add an import node, else use a\n            # dummy node\n            try:\n                getattr(sys.modules[modname], name)\n            except (KeyError, AttributeError):\n                attach_dummy_node(node, name, member)\n            else:\n                attach_import_node(node, modname, name)\n            return True\n        return False\n", "tokens": ["astroid", "raw_building", "py", "inspectbuilder", "def", "imported_member", "self", "node", "member", "name", "verify", "this", "is", "not", "an", "imported", "class", "or", "handle", "it", "some", "classes", "like", "extensionclass", "doesn", "t", "have", "a", "__module__", "attribute", "also", "this", "may", "trigger", "an", "exception", "on", "badly", "built", "module", "see", "http", "www", "logilab", "org", "ticket", "57299", "for", "instance", "try", "modname", "getattr", "member", "__module__", "none", "except", "typeerror", "modname", "none", "if", "modname", "is", "none", "if", "name", "in", "__new__", "__subclasshook__", "python", "2", "5", "1", "r251", "54863", "sep", "1", "2010", "22", "03", "14", "print", "object", "__new__", "__module__", "none", "modname", "builtins", "__name__", "else", "attach_dummy_node", "node", "name", "member", "return", "true", "real_name", "gtk", "gtk_gtk", "_io", "io", "get", "modname", "modname", "if", "real_name", "self", "_module", "__name__", "check", "if", "it", "sounds", "valid", "and", "then", "add", "an", "import", "node", "else", "use", "a", "dummy", "node", "try", "getattr", "sys", "modules", "modname", "name", "except", "keyerror", "attributeerror", "attach_dummy_node", "node", "name", "member", "else", "attach_import_node", "node", "modname", "name", "return", "true", "return", "false"], "doc_len": 146}
{"doc_id": "astroid/raw_building.py::_set_proxied", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_set_proxied", "text": "文件路径: astroid/raw_building.py\ndef _set_proxied(const):\n    # TODO : find a nicer way to handle this situation;\n    return _CONST_PROXY[const.value.__class__]\n", "tokens": ["astroid", "raw_building", "py", "def", "_set_proxied", "const", "todo", "find", "a", "nicer", "way", "to", "handle", "this", "situation", "return", "_const_proxy", "const", "value", "__class__"], "doc_len": 20}
{"doc_id": "astroid/raw_building.py::_astroid_bootstrapping", "file_path": "astroid/raw_building.py", "class_name": null, "func_name": "_astroid_bootstrapping", "text": "文件路径: astroid/raw_building.py\ndef _astroid_bootstrapping():\n    \"\"\"astroid bootstrapping the builtins module\"\"\"\n    # this boot strapping is necessary since we need the Const nodes to\n    # inspect_build builtins, and then we can proxy Const\n    builder = InspectBuilder()\n    astroid_builtin = builder.inspect_build(builtins)\n\n    for cls, node_cls in node_classes.CONST_CLS.items():\n        if cls is TYPE_NONE:\n            proxy = build_class(\"NoneType\")\n            proxy.parent = astroid_builtin\n        elif cls is TYPE_NOTIMPLEMENTED:\n            proxy = build_class(\"NotImplementedType\")\n            proxy.parent = astroid_builtin\n        elif cls is TYPE_ELLIPSIS:\n            proxy = build_class(\"Ellipsis\")\n            proxy.parent = astroid_builtin\n        else:\n            proxy = astroid_builtin.getattr(cls.__name__)[0]\n        if cls in (dict, list, set, tuple):\n            node_cls._proxied = proxy\n        else:\n            _CONST_PROXY[cls] = proxy\n\n    # Set the builtin module as parent for some builtins.\n    nodes.Const._proxied = property(_set_proxied)\n\n    _GeneratorType = nodes.ClassDef(\n        types.GeneratorType.__name__, types.GeneratorType.__doc__\n    )\n    _GeneratorType.parent = astroid_builtin\n    bases.Generator._proxied = _GeneratorType\n    builder.object_build(bases.Generator._proxied, types.GeneratorType)\n\n    if hasattr(types, \"AsyncGeneratorType\"):\n        _AsyncGeneratorType = nodes.ClassDef(\n            types.AsyncGeneratorType.__name__, types.AsyncGeneratorType.__doc__\n        )\n        _AsyncGeneratorType.parent = astroid_builtin\n        bases.AsyncGenerator._proxied = _AsyncGeneratorType\n        builder.object_build(bases.AsyncGenerator._proxied, types.AsyncGeneratorType)\n    builtin_types = (\n        types.GetSetDescriptorType,\n        types.GeneratorType,\n        types.MemberDescriptorType,\n        TYPE_NONE,\n        TYPE_NOTIMPLEMENTED,\n        types.FunctionType,\n        types.MethodType,\n        types.BuiltinFunctionType,\n        types.ModuleType,\n        types.TracebackType,\n    )\n    for _type in builtin_types:\n        if _type.__name__ not in astroid_builtin:\n            cls = nodes.ClassDef(_type.__name__, _type.__doc__)\n            cls.parent = astroid_builtin\n            builder.object_build(cls, _type)\n            astroid_builtin[_type.__name__] = cls\n", "tokens": ["astroid", "raw_building", "py", "def", "_astroid_bootstrapping", "astroid", "bootstrapping", "the", "builtins", "module", "this", "boot", "strapping", "is", "necessary", "since", "we", "need", "the", "const", "nodes", "to", "inspect_build", "builtins", "and", "then", "we", "can", "proxy", "const", "builder", "inspectbuilder", "astroid_builtin", "builder", "inspect_build", "builtins", "for", "cls", "node_cls", "in", "node_classes", "const_cls", "items", "if", "cls", "is", "type_none", "proxy", "build_class", "nonetype", "proxy", "parent", "astroid_builtin", "elif", "cls", "is", "type_notimplemented", "proxy", "build_class", "notimplementedtype", "proxy", "parent", "astroid_builtin", "elif", "cls", "is", "type_ellipsis", "proxy", "build_class", "ellipsis", "proxy", "parent", "astroid_builtin", "else", "proxy", "astroid_builtin", "getattr", "cls", "__name__", "0", "if", "cls", "in", "dict", "list", "set", "tuple", "node_cls", "_proxied", "proxy", "else", "_const_proxy", "cls", "proxy", "set", "the", "builtin", "module", "as", "parent", "for", "some", "builtins", "nodes", "const", "_proxied", "property", "_set_proxied", "_generatortype", "nodes", "classdef", "types", "generatortype", "__name__", "types", "generatortype", "__doc__", "_generatortype", "parent", "astroid_builtin", "bases", "generator", "_proxied", "_generatortype", "builder", "object_build", "bases", "generator", "_proxied", "types", "generatortype", "if", "hasattr", "types", "asyncgeneratortype", "_asyncgeneratortype", "nodes", "classdef", "types", "asyncgeneratortype", "__name__", "types", "asyncgeneratortype", "__doc__", "_asyncgeneratortype", "parent", "astroid_builtin", "bases", "asyncgenerator", "_proxied", "_asyncgeneratortype", "builder", "object_build", "bases", "asyncgenerator", "_proxied", "types", "asyncgeneratortype", "builtin_types", "types", "getsetdescriptortype", "types", "generatortype", "types", "memberdescriptortype", "type_none", "type_notimplemented", "types", "functiontype", "types", "methodtype", "types", "builtinfunctiontype", "types", "moduletype", "types", "tracebacktype", "for", "_type", "in", "builtin_types", "if", "_type", "__name__", "not", "in", "astroid_builtin", "cls", "nodes", "classdef", "_type", "__name__", "_type", "__doc__", "cls", "parent", "astroid_builtin", "builder", "object_build", "cls", "_type", "astroid_builtin", "_type", "__name__", "cls"], "doc_len": 205}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.__init__", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "__init__", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def __init__(\n        self, manager: AstroidManager, parser_module: Optional[ParserModule] = None\n    ):\n        self._manager = manager\n        self._global_names: List[Dict[str, List[nodes.Global]]] = []\n        self._import_from_nodes: List[nodes.ImportFrom] = []\n        self._delayed_assattr: List[nodes.AssignAttr] = []\n        self._visit_meths: Dict[\n            Type[\"ast.AST\"], Callable[[\"ast.AST\", NodeNG], NodeNG]\n        ] = {}\n\n        if parser_module is None:\n            self._parser_module = get_parser_module()\n        else:\n            self._parser_module = parser_module\n        self._module = self._parser_module.module\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "__init__", "self", "manager", "astroidmanager", "parser_module", "optional", "parsermodule", "none", "self", "_manager", "manager", "self", "_global_names", "list", "dict", "str", "list", "nodes", "global", "self", "_import_from_nodes", "list", "nodes", "importfrom", "self", "_delayed_assattr", "list", "nodes", "assignattr", "self", "_visit_meths", "dict", "type", "ast", "ast", "callable", "ast", "ast", "nodeng", "nodeng", "if", "parser_module", "is", "none", "self", "_parser_module", "get_parser_module", "else", "self", "_parser_module", "parser_module", "self", "_module", "self", "_parser_module", "module"], "doc_len": 61}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._get_doc", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_get_doc", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _get_doc(self, node: T_Doc) -> Tuple[T_Doc, Optional[str]]:\n        try:\n            if node.body and isinstance(node.body[0], self._module.Expr):\n                first_value = node.body[0].value\n                if isinstance(first_value, self._module.Str) or (\n                    PY38_PLUS\n                    and isinstance(first_value, self._module.Constant)\n                    and isinstance(first_value.value, str)\n                ):\n                    doc = first_value.value if PY38_PLUS else first_value.s\n                    node.body = node.body[1:]\n                    return node, doc\n        except IndexError:\n            pass  # ast built from scratch\n        return node, None\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_get_doc", "self", "node", "t_doc", "tuple", "t_doc", "optional", "str", "try", "if", "node", "body", "and", "isinstance", "node", "body", "0", "self", "_module", "expr", "first_value", "node", "body", "0", "value", "if", "isinstance", "first_value", "self", "_module", "str", "or", "py38_plus", "and", "isinstance", "first_value", "self", "_module", "constant", "and", "isinstance", "first_value", "value", "str", "doc", "first_value", "value", "if", "py38_plus", "else", "first_value", "s", "node", "body", "node", "body", "1", "return", "node", "doc", "except", "indexerror", "pass", "ast", "built", "from", "scratch", "return", "node", "none"], "doc_len": 75}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._get_context", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_get_context", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _get_context(\n        self,\n        node: Union[\n            \"ast.Attribute\",\n            \"ast.List\",\n            \"ast.Name\",\n            \"ast.Subscript\",\n            \"ast.Starred\",\n            \"ast.Tuple\",\n        ],\n    ) -> Context:\n        return self._parser_module.context_classes.get(type(node.ctx), Context.Load)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_get_context", "self", "node", "union", "ast", "attribute", "ast", "list", "ast", "name", "ast", "subscript", "ast", "starred", "ast", "tuple", "context", "return", "self", "_parser_module", "context_classes", "get", "type", "node", "ctx", "context", "load"], "doc_len": 32}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_module", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_module", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_module(\n        self, node: \"ast.Module\", modname: str, modpath: str, package: bool\n    ) -> nodes.Module:\n        \"\"\"visit a Module node by returning a fresh instance of it\n\n        Note: Method not called by 'visit'\n        \"\"\"\n        node, doc = self._get_doc(node)\n        newnode = nodes.Module(\n            name=modname,\n            doc=doc,\n            file=modpath,\n            path=[modpath],\n            package=package,\n            parent=None,\n        )\n        newnode.postinit([self.visit(child, newnode) for child in node.body])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_module", "self", "node", "ast", "module", "modname", "str", "modpath", "str", "package", "bool", "nodes", "module", "visit", "a", "module", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "note", "method", "not", "called", "by", "visit", "node", "doc", "self", "_get_doc", "node", "newnode", "nodes", "module", "name", "modname", "doc", "doc", "file", "modpath", "path", "modpath", "package", "package", "parent", "none", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "return", "newnode"], "doc_len": 68}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._save_assignment", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_save_assignment", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _save_assignment(self, node: Union[nodes.AssignName, nodes.DelName]) -> None:\n        \"\"\"save assignment situation since node.parent is not available yet\"\"\"\n        if self._global_names and node.name in self._global_names[-1]:\n            node.root().set_local(node.name, node)\n        else:\n            assert node.parent\n            node.parent.set_local(node.name, node)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_save_assignment", "self", "node", "union", "nodes", "assignname", "nodes", "delname", "none", "save", "assignment", "situation", "since", "node", "parent", "is", "not", "available", "yet", "if", "self", "_global_names", "and", "node", "name", "in", "self", "_global_names", "1", "node", "root", "set_local", "node", "name", "node", "else", "assert", "node", "parent", "node", "parent", "set_local", "node", "name", "node"], "doc_len": 50}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_arg", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_arg", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_arg(self, node: \"ast.arg\", parent: NodeNG) -> nodes.AssignName:\n        \"\"\"visit an arg node by returning a fresh AssName instance\"\"\"\n        return self.visit_assignname(node, parent, node.arg)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_arg", "self", "node", "ast", "arg", "parent", "nodeng", "nodes", "assignname", "visit", "an", "arg", "node", "by", "returning", "a", "fresh", "assname", "instance", "return", "self", "visit_assignname", "node", "parent", "node", "arg"], "doc_len": 31}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_arguments", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_arguments", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_arguments(self, node: \"ast.arguments\", parent: NodeNG) -> nodes.Arguments:\n        \"\"\"visit an Arguments node by returning a fresh instance of it\"\"\"\n        vararg: Optional[str] = None\n        kwarg: Optional[str] = None\n        newnode = nodes.Arguments(\n            node.vararg.arg if node.vararg else None,\n            node.kwarg.arg if node.kwarg else None,\n            parent,\n        )\n        args = [self.visit(child, newnode) for child in node.args]\n        defaults = [self.visit(child, newnode) for child in node.defaults]\n        varargannotation: Optional[NodeNG] = None\n        kwargannotation: Optional[NodeNG] = None\n        posonlyargs: List[nodes.AssignName] = []\n        if node.vararg:\n            vararg = node.vararg.arg\n            varargannotation = self.visit(node.vararg.annotation, newnode)\n        if node.kwarg:\n            kwarg = node.kwarg.arg\n            kwargannotation = self.visit(node.kwarg.annotation, newnode)\n\n        if PY38:\n            # In Python 3.8 'end_lineno' and 'end_col_offset'\n            # for 'kwonlyargs' don't include the annotation.\n            for arg in node.kwonlyargs:\n                if arg.annotation is not None:\n                    arg.end_lineno = arg.annotation.end_lineno\n                    arg.end_col_offset = arg.annotation.end_col_offset\n\n        kwonlyargs = [self.visit(child, newnode) for child in node.kwonlyargs]\n        kw_defaults = [self.visit(child, newnode) for child in node.kw_defaults]\n        annotations = [self.visit(arg.annotation, newnode) for arg in node.args]\n        kwonlyargs_annotations = [\n            self.visit(arg.annotation, newnode) for arg in node.kwonlyargs\n        ]\n\n        posonlyargs_annotations: List[Optional[NodeNG]] = []\n        if PY38_PLUS:\n            posonlyargs = [self.visit(child, newnode) for child in node.posonlyargs]\n            posonlyargs_annotations = [\n                self.visit(arg.annotation, newnode) for arg in node.posonlyargs\n            ]\n        type_comment_args = [\n            self.check_type_comment(child, parent=newnode) for child in node.args\n        ]\n        type_comment_kwonlyargs = [\n            self.check_type_comment(child, parent=newnode) for child in node.kwonlyargs\n        ]\n        type_comment_posonlyargs: List[Optional[NodeNG]] = []\n        if PY38_PLUS:\n            type_comment_posonlyargs = [\n                self.check_type_comment(child, parent=newnode)\n                for child in node.posonlyargs\n            ]\n\n        newnode.postinit(\n            args=args,\n            defaults=defaults,\n            kwonlyargs=kwonlyargs,\n            posonlyargs=posonlyargs,\n            kw_defaults=kw_defaults,\n            annotations=annotations,\n            kwonlyargs_annotations=kwonlyargs_annotations,\n            posonlyargs_annotations=posonlyargs_annotations,\n            varargannotation=varargannotation,\n            kwargannotation=kwargannotation,\n            type_comment_args=type_comment_args,\n            type_comment_kwonlyargs=type_comment_kwonlyargs,\n            type_comment_posonlyargs=type_comment_posonlyargs,\n        )\n        # save argument names in locals:\n        assert newnode.parent\n        if vararg:\n            newnode.parent.set_local(vararg, newnode)\n        if kwarg:\n            newnode.parent.set_local(kwarg, newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_arguments", "self", "node", "ast", "arguments", "parent", "nodeng", "nodes", "arguments", "visit", "an", "arguments", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "vararg", "optional", "str", "none", "kwarg", "optional", "str", "none", "newnode", "nodes", "arguments", "node", "vararg", "arg", "if", "node", "vararg", "else", "none", "node", "kwarg", "arg", "if", "node", "kwarg", "else", "none", "parent", "args", "self", "visit", "child", "newnode", "for", "child", "in", "node", "args", "defaults", "self", "visit", "child", "newnode", "for", "child", "in", "node", "defaults", "varargannotation", "optional", "nodeng", "none", "kwargannotation", "optional", "nodeng", "none", "posonlyargs", "list", "nodes", "assignname", "if", "node", "vararg", "vararg", "node", "vararg", "arg", "varargannotation", "self", "visit", "node", "vararg", "annotation", "newnode", "if", "node", "kwarg", "kwarg", "node", "kwarg", "arg", "kwargannotation", "self", "visit", "node", "kwarg", "annotation", "newnode", "if", "py38", "in", "python", "3", "8", "end_lineno", "and", "end_col_offset", "for", "kwonlyargs", "don", "t", "include", "the", "annotation", "for", "arg", "in", "node", "kwonlyargs", "if", "arg", "annotation", "is", "not", "none", "arg", "end_lineno", "arg", "annotation", "end_lineno", "arg", "end_col_offset", "arg", "annotation", "end_col_offset", "kwonlyargs", "self", "visit", "child", "newnode", "for", "child", "in", "node", "kwonlyargs", "kw_defaults", "self", "visit", "child", "newnode", "for", "child", "in", "node", "kw_defaults", "annotations", "self", "visit", "arg", "annotation", "newnode", "for", "arg", "in", "node", "args", "kwonlyargs_annotations", "self", "visit", "arg", "annotation", "newnode", "for", "arg", "in", "node", "kwonlyargs", "posonlyargs_annotations", "list", "optional", "nodeng", "if", "py38_plus", "posonlyargs", "self", "visit", "child", "newnode", "for", "child", "in", "node", "posonlyargs", "posonlyargs_annotations", "self", "visit", "arg", "annotation", "newnode", "for", "arg", "in", "node", "posonlyargs", "type_comment_args", "self", "check_type_comment", "child", "parent", "newnode", "for", "child", "in", "node", "args", "type_comment_kwonlyargs", "self", "check_type_comment", "child", "parent", "newnode", "for", "child", "in", "node", "kwonlyargs", "type_comment_posonlyargs", "list", "optional", "nodeng", "if", "py38_plus", "type_comment_posonlyargs", "self", "check_type_comment", "child", "parent", "newnode", "for", "child", "in", "node", "posonlyargs", "newnode", "postinit", "args", "args", "defaults", "defaults", "kwonlyargs", "kwonlyargs", "posonlyargs", "posonlyargs", "kw_defaults", "kw_defaults", "annotations", "annotations", "kwonlyargs_annotations", "kwonlyargs_annotations", "posonlyargs_annotations", "posonlyargs_annotations", "varargannotation", "varargannotation", "kwargannotation", "kwargannotation", "type_comment_args", "type_comment_args", "type_comment_kwonlyargs", "type_comment_kwonlyargs", "type_comment_posonlyargs", "type_comment_posonlyargs", "save", "argument", "names", "in", "locals", "assert", "newnode", "parent", "if", "vararg", "newnode", "parent", "set_local", "vararg", "newnode", "if", "kwarg", "newnode", "parent", "set_local", "kwarg", "newnode", "return", "newnode"], "doc_len": 310}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_assert", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_assert", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_assert(self, node: \"ast.Assert\", parent: NodeNG) -> nodes.Assert:\n        \"\"\"visit a Assert node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Assert(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Assert(node.lineno, node.col_offset, parent)\n        msg: Optional[NodeNG] = None\n        if node.msg:\n            msg = self.visit(node.msg, newnode)\n        newnode.postinit(self.visit(node.test, newnode), msg)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_assert", "self", "node", "ast", "assert", "parent", "nodeng", "nodes", "assert", "visit", "a", "assert", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "assert", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "assert", "node", "lineno", "node", "col_offset", "parent", "msg", "optional", "nodeng", "none", "if", "node", "msg", "msg", "self", "visit", "node", "msg", "newnode", "newnode", "postinit", "self", "visit", "node", "test", "newnode", "msg", "return", "newnode"], "doc_len": 79}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.check_type_comment", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "check_type_comment", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def check_type_comment(\n        self,\n        node: Union[\n            \"ast.Assign\",\n            \"ast.arg\",\n            \"ast.For\",\n            \"ast.AsyncFor\",\n            \"ast.With\",\n            \"ast.AsyncWith\",\n        ],\n        parent: Union[\n            nodes.Assign,\n            nodes.Arguments,\n            nodes.For,\n            nodes.AsyncFor,\n            nodes.With,\n            nodes.AsyncWith,\n        ],\n    ) -> Optional[NodeNG]:\n        type_comment = getattr(node, \"type_comment\", None)  # Added in Python 3.8\n        if not type_comment:\n            return None\n\n        try:\n            type_comment_ast = self._parser_module.parse(type_comment)\n        except SyntaxError:\n            # Invalid type comment, just skip it.\n            return None\n\n        type_object = self.visit(type_comment_ast.body[0], parent=parent)\n        if not isinstance(type_object, nodes.Expr):\n            return None\n\n        return type_object.value\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "check_type_comment", "self", "node", "union", "ast", "assign", "ast", "arg", "ast", "for", "ast", "asyncfor", "ast", "with", "ast", "asyncwith", "parent", "union", "nodes", "assign", "nodes", "arguments", "nodes", "for", "nodes", "asyncfor", "nodes", "with", "nodes", "asyncwith", "optional", "nodeng", "type_comment", "getattr", "node", "type_comment", "none", "added", "in", "python", "3", "8", "if", "not", "type_comment", "return", "none", "try", "type_comment_ast", "self", "_parser_module", "parse", "type_comment", "except", "syntaxerror", "invalid", "type", "comment", "just", "skip", "it", "return", "none", "type_object", "self", "visit", "type_comment_ast", "body", "0", "parent", "parent", "if", "not", "isinstance", "type_object", "nodes", "expr", "return", "none", "return", "type_object", "value"], "doc_len": 87}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.check_function_type_comment", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "check_function_type_comment", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def check_function_type_comment(\n        self, node: Union[\"ast.FunctionDef\", \"ast.AsyncFunctionDef\"], parent: NodeNG\n    ) -> Optional[Tuple[Optional[NodeNG], List[NodeNG]]]:\n        type_comment = getattr(node, \"type_comment\", None)  # Added in Python 3.8\n        if not type_comment:\n            return None\n\n        try:\n            type_comment_ast = parse_function_type_comment(type_comment)\n        except SyntaxError:\n            # Invalid type comment, just skip it.\n            return None\n\n        if not type_comment_ast:\n            return None\n\n        returns: Optional[NodeNG] = None\n        argtypes: List[NodeNG] = [\n            self.visit(elem, parent) for elem in (type_comment_ast.argtypes or [])\n        ]\n        if type_comment_ast.returns:\n            returns = self.visit(type_comment_ast.returns, parent)\n\n        return returns, argtypes\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "check_function_type_comment", "self", "node", "union", "ast", "functiondef", "ast", "asyncfunctiondef", "parent", "nodeng", "optional", "tuple", "optional", "nodeng", "list", "nodeng", "type_comment", "getattr", "node", "type_comment", "none", "added", "in", "python", "3", "8", "if", "not", "type_comment", "return", "none", "try", "type_comment_ast", "parse_function_type_comment", "type_comment", "except", "syntaxerror", "invalid", "type", "comment", "just", "skip", "it", "return", "none", "if", "not", "type_comment_ast", "return", "none", "returns", "optional", "nodeng", "none", "argtypes", "list", "nodeng", "self", "visit", "elem", "parent", "for", "elem", "in", "type_comment_ast", "argtypes", "or", "if", "type_comment_ast", "returns", "returns", "self", "visit", "type_comment_ast", "returns", "parent", "return", "returns", "argtypes"], "doc_len": 84}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_asyncfunctiondef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_asyncfunctiondef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_asyncfunctiondef(\n        self, node: \"ast.AsyncFunctionDef\", parent: NodeNG\n    ) -> nodes.AsyncFunctionDef:\n        return self._visit_functiondef(nodes.AsyncFunctionDef, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_asyncfunctiondef", "self", "node", "ast", "asyncfunctiondef", "parent", "nodeng", "nodes", "asyncfunctiondef", "return", "self", "_visit_functiondef", "nodes", "asyncfunctiondef", "node", "parent"], "doc_len": 21}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_asyncfor", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_asyncfor", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_asyncfor(self, node: \"ast.AsyncFor\", parent: NodeNG) -> nodes.AsyncFor:\n        return self._visit_for(nodes.AsyncFor, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_asyncfor", "self", "node", "ast", "asyncfor", "parent", "nodeng", "nodes", "asyncfor", "return", "self", "_visit_for", "nodes", "asyncfor", "node", "parent"], "doc_len": 21}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_await", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_await", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_await(self, node: \"ast.Await\", parent: NodeNG) -> nodes.Await:\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Await(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Await(node.lineno, node.col_offset, parent)\n        newnode.postinit(value=self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_await", "self", "node", "ast", "await", "parent", "nodeng", "nodes", "await", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "await", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "await", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "value", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 55}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_asyncwith", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_asyncwith", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_asyncwith(self, node: \"ast.AsyncWith\", parent: NodeNG) -> nodes.AsyncWith:\n        return self._visit_with(nodes.AsyncWith, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_asyncwith", "self", "node", "ast", "asyncwith", "parent", "nodeng", "nodes", "asyncwith", "return", "self", "_visit_with", "nodes", "asyncwith", "node", "parent"], "doc_len": 21}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_assign", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_assign", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_assign(self, node: \"ast.Assign\", parent: NodeNG) -> nodes.Assign:\n        \"\"\"visit a Assign node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Assign(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Assign(node.lineno, node.col_offset, parent)\n        type_annotation = self.check_type_comment(node, parent=newnode)\n        newnode.postinit(\n            targets=[self.visit(child, newnode) for child in node.targets],\n            value=self.visit(node.value, newnode),\n            type_annotation=type_annotation,\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_assign", "self", "node", "ast", "assign", "parent", "nodeng", "nodes", "assign", "visit", "a", "assign", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "assign", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "assign", "node", "lineno", "node", "col_offset", "parent", "type_annotation", "self", "check_type_comment", "node", "parent", "newnode", "newnode", "postinit", "targets", "self", "visit", "child", "newnode", "for", "child", "in", "node", "targets", "value", "self", "visit", "node", "value", "newnode", "type_annotation", "type_annotation", "return", "newnode"], "doc_len": 84}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_annassign", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_annassign", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_annassign(self, node: \"ast.AnnAssign\", parent: NodeNG) -> nodes.AnnAssign:\n        \"\"\"visit an AnnAssign node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.AnnAssign(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.AnnAssign(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            target=self.visit(node.target, newnode),\n            annotation=self.visit(node.annotation, newnode),\n            simple=node.simple,\n            value=self.visit(node.value, newnode),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_annassign", "self", "node", "ast", "annassign", "parent", "nodeng", "nodes", "annassign", "visit", "an", "annassign", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "annassign", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "annassign", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "target", "self", "visit", "node", "target", "newnode", "annotation", "self", "visit", "node", "annotation", "newnode", "simple", "node", "simple", "value", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 81}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_assignname", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_assignname", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_assignname(\n        self, node: \"ast.AST\", parent: NodeNG, node_name: str\n    ) -> nodes.AssignName:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_assignname", "self", "node", "ast", "ast", "parent", "nodeng", "node_name", "str", "nodes", "assignname"], "doc_len": 16}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_assignname", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_assignname", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_assignname(\n        self, node: \"ast.AST\", parent: NodeNG, node_name: None\n    ) -> None:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_assignname", "self", "node", "ast", "ast", "parent", "nodeng", "node_name", "none", "none"], "doc_len": 15}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_assignname", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_assignname", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_assignname(\n        self, node: \"ast.AST\", parent: NodeNG, node_name: Optional[str]\n    ) -> Optional[nodes.AssignName]:\n        \"\"\"visit a node and return a AssignName node\n\n        Note: Method not called by 'visit'\n        \"\"\"\n        if node_name is None:\n            return None\n        if sys.version_info >= (3, 8):\n            newnode = nodes.AssignName(\n                name=node_name,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.AssignName(\n                node_name,\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        self._save_assignment(newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_assignname", "self", "node", "ast", "ast", "parent", "nodeng", "node_name", "optional", "str", "optional", "nodes", "assignname", "visit", "a", "node", "and", "return", "a", "assignname", "node", "note", "method", "not", "called", "by", "visit", "if", "node_name", "is", "none", "return", "none", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "assignname", "name", "node_name", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "assignname", "node_name", "node", "lineno", "node", "col_offset", "parent", "self", "_save_assignment", "newnode", "return", "newnode"], "doc_len": 77}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_augassign", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_augassign", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_augassign(self, node: \"ast.AugAssign\", parent: NodeNG) -> nodes.AugAssign:\n        \"\"\"visit a AugAssign node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.AugAssign(\n                op=self._parser_module.bin_op_classes[type(node.op)] + \"=\",\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.AugAssign(\n                self._parser_module.bin_op_classes[type(node.op)] + \"=\",\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        newnode.postinit(\n            self.visit(node.target, newnode), self.visit(node.value, newnode)\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_augassign", "self", "node", "ast", "augassign", "parent", "nodeng", "nodes", "augassign", "visit", "a", "augassign", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "augassign", "op", "self", "_parser_module", "bin_op_classes", "type", "node", "op", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "augassign", "self", "_parser_module", "bin_op_classes", "type", "node", "op", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "target", "newnode", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 83}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_binop", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_binop", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_binop(self, node: \"ast.BinOp\", parent: NodeNG) -> nodes.BinOp:\n        \"\"\"visit a BinOp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.BinOp(\n                op=self._parser_module.bin_op_classes[type(node.op)],\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.BinOp(\n                self._parser_module.bin_op_classes[type(node.op)],\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        newnode.postinit(\n            self.visit(node.left, newnode), self.visit(node.right, newnode)\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_binop", "self", "node", "ast", "binop", "parent", "nodeng", "nodes", "binop", "visit", "a", "binop", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "binop", "op", "self", "_parser_module", "bin_op_classes", "type", "node", "op", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "binop", "self", "_parser_module", "bin_op_classes", "type", "node", "op", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "left", "newnode", "self", "visit", "node", "right", "newnode", "return", "newnode"], "doc_len": 83}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_boolop", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_boolop", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_boolop(self, node: \"ast.BoolOp\", parent: NodeNG) -> nodes.BoolOp:\n        \"\"\"visit a BoolOp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.BoolOp(\n                op=self._parser_module.bool_op_classes[type(node.op)],\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.BoolOp(\n                self._parser_module.bool_op_classes[type(node.op)],\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        newnode.postinit([self.visit(child, newnode) for child in node.values])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_boolop", "self", "node", "ast", "boolop", "parent", "nodeng", "nodes", "boolop", "visit", "a", "boolop", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "boolop", "op", "self", "_parser_module", "bool_op_classes", "type", "node", "op", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "boolop", "self", "_parser_module", "bool_op_classes", "type", "node", "op", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "values", "return", "newnode"], "doc_len": 82}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_break", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_break", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_break(self, node: \"ast.Break\", parent: NodeNG) -> nodes.Break:\n        \"\"\"visit a Break node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            return nodes.Break(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        return nodes.Break(node.lineno, node.col_offset, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_break", "self", "node", "ast", "break", "parent", "nodeng", "nodes", "break", "visit", "a", "break", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "return", "nodes", "break", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "return", "nodes", "break", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 55}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_call", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_call", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_call(self, node: \"ast.Call\", parent: NodeNG) -> nodes.Call:\n        \"\"\"visit a CallFunc node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Call(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Call(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            func=self.visit(node.func, newnode),\n            args=[self.visit(child, newnode) for child in node.args],\n            keywords=[self.visit(child, newnode) for child in node.keywords],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_call", "self", "node", "ast", "call", "parent", "nodeng", "nodes", "call", "visit", "a", "callfunc", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "call", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "call", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "func", "self", "visit", "node", "func", "newnode", "args", "self", "visit", "child", "newnode", "for", "child", "in", "node", "args", "keywords", "self", "visit", "child", "newnode", "for", "child", "in", "node", "keywords", "return", "newnode"], "doc_len": 86}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_classdef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_classdef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_classdef(\n        self, node: \"ast.ClassDef\", parent: NodeNG, newstyle: bool = True\n    ) -> nodes.ClassDef:\n        \"\"\"visit a ClassDef node to become astroid\"\"\"\n        node, doc = self._get_doc(node)\n        if sys.version_info >= (3, 8):\n            newnode = nodes.ClassDef(\n                name=node.name,\n                doc=doc,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.ClassDef(\n                node.name, doc, node.lineno, node.col_offset, parent\n            )\n        metaclass = None\n        for keyword in node.keywords:\n            if keyword.arg == \"metaclass\":\n                metaclass = self.visit(keyword, newnode).value\n                break\n        decorators = self.visit_decorators(node, newnode)\n        newnode.postinit(\n            [self.visit(child, newnode) for child in node.bases],\n            [self.visit(child, newnode) for child in node.body],\n            decorators,\n            newstyle,\n            metaclass,\n            [\n                self.visit(kwd, newnode)\n                for kwd in node.keywords\n                if kwd.arg != \"metaclass\"\n            ],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_classdef", "self", "node", "ast", "classdef", "parent", "nodeng", "newstyle", "bool", "true", "nodes", "classdef", "visit", "a", "classdef", "node", "to", "become", "astroid", "node", "doc", "self", "_get_doc", "node", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "classdef", "name", "node", "name", "doc", "doc", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "classdef", "node", "name", "doc", "node", "lineno", "node", "col_offset", "parent", "metaclass", "none", "for", "keyword", "in", "node", "keywords", "if", "keyword", "arg", "metaclass", "metaclass", "self", "visit", "keyword", "newnode", "value", "break", "decorators", "self", "visit_decorators", "node", "newnode", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "bases", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "decorators", "newstyle", "metaclass", "self", "visit", "kwd", "newnode", "for", "kwd", "in", "node", "keywords", "if", "kwd", "arg", "metaclass", "return", "newnode"], "doc_len": 129}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_continue", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_continue", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_continue(self, node: \"ast.Continue\", parent: NodeNG) -> nodes.Continue:\n        \"\"\"visit a Continue node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            return nodes.Continue(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        return nodes.Continue(node.lineno, node.col_offset, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_continue", "self", "node", "ast", "continue", "parent", "nodeng", "nodes", "continue", "visit", "a", "continue", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "return", "nodes", "continue", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "return", "nodes", "continue", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 55}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_compare", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_compare", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_compare(self, node: \"ast.Compare\", parent: NodeNG) -> nodes.Compare:\n        \"\"\"visit a Compare node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Compare(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Compare(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.left, newnode),\n            [\n                (\n                    self._parser_module.cmp_op_classes[op.__class__],\n                    self.visit(expr, newnode),\n                )\n                for (op, expr) in zip(node.ops, node.comparators)\n            ],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_compare", "self", "node", "ast", "compare", "parent", "nodeng", "nodes", "compare", "visit", "a", "compare", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "compare", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "compare", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "left", "newnode", "self", "_parser_module", "cmp_op_classes", "op", "__class__", "self", "visit", "expr", "newnode", "for", "op", "expr", "in", "zip", "node", "ops", "node", "comparators", "return", "newnode"], "doc_len": 83}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_comprehension", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_comprehension", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_comprehension(\n        self, node: \"ast.comprehension\", parent: NodeNG\n    ) -> nodes.Comprehension:\n        \"\"\"visit a Comprehension node by returning a fresh instance of it\"\"\"\n        newnode = nodes.Comprehension(parent)\n        newnode.postinit(\n            self.visit(node.target, newnode),\n            self.visit(node.iter, newnode),\n            [self.visit(child, newnode) for child in node.ifs],\n            bool(node.is_async),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_comprehension", "self", "node", "ast", "comprehension", "parent", "nodeng", "nodes", "comprehension", "visit", "a", "comprehension", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "newnode", "nodes", "comprehension", "parent", "newnode", "postinit", "self", "visit", "node", "target", "newnode", "self", "visit", "node", "iter", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "ifs", "bool", "node", "is_async", "return", "newnode"], "doc_len": 55}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_decorators", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_decorators", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_decorators(\n        self,\n        node: Union[\"ast.ClassDef\", \"ast.FunctionDef\", \"ast.AsyncFunctionDef\"],\n        parent: NodeNG,\n    ) -> Optional[nodes.Decorators]:\n        \"\"\"visit a Decorators node by returning a fresh instance of it\n\n        Note: Method not called by 'visit'\n        \"\"\"\n        if not node.decorator_list:\n            return None\n        # /!\\ node is actually an _ast.FunctionDef node while\n        # parent is an astroid.nodes.FunctionDef node\n        if sys.version_info >= (3, 8):\n            # Set the line number of the first decorator for Python 3.8+.\n            lineno = node.decorator_list[0].lineno\n            end_lineno = node.decorator_list[-1].end_lineno\n            end_col_offset = node.decorator_list[-1].end_col_offset\n        else:\n            lineno = node.lineno\n            end_lineno = None\n            end_col_offset = None\n        newnode = nodes.Decorators(\n            lineno=lineno,\n            col_offset=node.col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n        newnode.postinit([self.visit(child, newnode) for child in node.decorator_list])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_decorators", "self", "node", "union", "ast", "classdef", "ast", "functiondef", "ast", "asyncfunctiondef", "parent", "nodeng", "optional", "nodes", "decorators", "visit", "a", "decorators", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "note", "method", "not", "called", "by", "visit", "if", "not", "node", "decorator_list", "return", "none", "node", "is", "actually", "an", "_ast", "functiondef", "node", "while", "parent", "is", "an", "astroid", "nodes", "functiondef", "node", "if", "sys", "version_info", "3", "8", "set", "the", "line", "number", "of", "the", "first", "decorator", "for", "python", "3", "8", "lineno", "node", "decorator_list", "0", "lineno", "end_lineno", "node", "decorator_list", "1", "end_lineno", "end_col_offset", "node", "decorator_list", "1", "end_col_offset", "else", "lineno", "node", "lineno", "end_lineno", "none", "end_col_offset", "none", "newnode", "nodes", "decorators", "lineno", "lineno", "col_offset", "node", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "decorator_list", "return", "newnode"], "doc_len": 125}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_delete", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_delete", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_delete(self, node: \"ast.Delete\", parent: NodeNG) -> nodes.Delete:\n        \"\"\"visit a Delete node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Delete(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Delete(node.lineno, node.col_offset, parent)\n        newnode.postinit([self.visit(child, newnode) for child in node.targets])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_delete", "self", "node", "ast", "delete", "parent", "nodeng", "nodes", "delete", "visit", "a", "delete", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "delete", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "delete", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "targets", "return", "newnode"], "doc_len": 69}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_dict_items", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_dict_items", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_dict_items(\n        self, node: \"ast.Dict\", parent: NodeNG, newnode: nodes.Dict\n    ) -> Generator[Tuple[NodeNG, NodeNG], None, None]:\n        for key, value in zip(node.keys, node.values):\n            rebuilt_key: NodeNG\n            rebuilt_value = self.visit(value, newnode)\n            if not key:\n                # Extended unpacking\n                if sys.version_info >= (3, 8):\n                    rebuilt_key = nodes.DictUnpack(\n                        lineno=rebuilt_value.lineno,\n                        col_offset=rebuilt_value.col_offset,\n                        end_lineno=rebuilt_value.end_lineno,\n                        end_col_offset=rebuilt_value.end_col_offset,\n                        parent=parent,\n                    )\n                else:\n                    rebuilt_key = nodes.DictUnpack(\n                        rebuilt_value.lineno, rebuilt_value.col_offset, parent\n                    )\n            else:\n                rebuilt_key = self.visit(key, newnode)\n            yield rebuilt_key, rebuilt_value\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_dict_items", "self", "node", "ast", "dict", "parent", "nodeng", "newnode", "nodes", "dict", "generator", "tuple", "nodeng", "nodeng", "none", "none", "for", "key", "value", "in", "zip", "node", "keys", "node", "values", "rebuilt_key", "nodeng", "rebuilt_value", "self", "visit", "value", "newnode", "if", "not", "key", "extended", "unpacking", "if", "sys", "version_info", "3", "8", "rebuilt_key", "nodes", "dictunpack", "lineno", "rebuilt_value", "lineno", "col_offset", "rebuilt_value", "col_offset", "end_lineno", "rebuilt_value", "end_lineno", "end_col_offset", "rebuilt_value", "end_col_offset", "parent", "parent", "else", "rebuilt_key", "nodes", "dictunpack", "rebuilt_value", "lineno", "rebuilt_value", "col_offset", "parent", "else", "rebuilt_key", "self", "visit", "key", "newnode", "yield", "rebuilt_key", "rebuilt_value"], "doc_len": 82}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_dict", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_dict", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_dict(self, node: \"ast.Dict\", parent: NodeNG) -> nodes.Dict:\n        \"\"\"visit a Dict node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Dict(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Dict(node.lineno, node.col_offset, parent)\n        items = list(self._visit_dict_items(node, parent, newnode))\n        newnode.postinit(items)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_dict", "self", "node", "ast", "dict", "parent", "nodeng", "nodes", "dict", "visit", "a", "dict", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "dict", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "dict", "node", "lineno", "node", "col_offset", "parent", "items", "list", "self", "_visit_dict_items", "node", "parent", "newnode", "newnode", "postinit", "items", "return", "newnode"], "doc_len": 68}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_dictcomp", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_dictcomp", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_dictcomp(self, node: \"ast.DictComp\", parent: NodeNG) -> nodes.DictComp:\n        \"\"\"visit a DictComp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.DictComp(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.DictComp(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.key, newnode),\n            self.visit(node.value, newnode),\n            [self.visit(child, newnode) for child in node.generators],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_dictcomp", "self", "node", "ast", "dictcomp", "parent", "nodeng", "nodes", "dictcomp", "visit", "a", "dictcomp", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "dictcomp", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "dictcomp", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "key", "newnode", "self", "visit", "node", "value", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "generators", "return", "newnode"], "doc_len": 79}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_expr", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_expr", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_expr(self, node: \"ast.Expr\", parent: NodeNG) -> nodes.Expr:\n        \"\"\"visit a Expr node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Expr(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Expr(node.lineno, node.col_offset, parent)\n        newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_expr", "self", "node", "ast", "expr", "parent", "nodeng", "nodes", "expr", "visit", "a", "expr", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "expr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "expr", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 65}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_ellipsis", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_ellipsis", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_ellipsis(self, node: \"ast.Ellipsis\", parent: NodeNG) -> nodes.Const:\n        \"\"\"visit an Ellipsis node by returning a fresh instance of Const\"\"\"\n        return nodes.Const(\n            value=Ellipsis,\n            lineno=node.lineno,\n            col_offset=node.col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_ellipsis", "self", "node", "ast", "ellipsis", "parent", "nodeng", "nodes", "const", "visit", "an", "ellipsis", "node", "by", "returning", "a", "fresh", "instance", "of", "const", "return", "nodes", "const", "value", "ellipsis", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "parent"], "doc_len": 38}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_excepthandler", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_excepthandler", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_excepthandler(\n        self, node: \"ast.ExceptHandler\", parent: NodeNG\n    ) -> nodes.ExceptHandler:\n        \"\"\"visit an ExceptHandler node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.ExceptHandler(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.ExceptHandler(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.type, newnode),\n            self.visit_assignname(node, newnode, node.name),\n            [self.visit(child, newnode) for child in node.body],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_excepthandler", "self", "node", "ast", "excepthandler", "parent", "nodeng", "nodes", "excepthandler", "visit", "an", "excepthandler", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "excepthandler", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "excepthandler", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "type", "newnode", "self", "visit_assignname", "node", "newnode", "node", "name", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "return", "newnode"], "doc_len": 80}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_extslice", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_extslice", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_extslice(\n        self, node: \"ast.ExtSlice\", parent: nodes.Subscript\n    ) -> nodes.Tuple:\n        \"\"\"visit an ExtSlice node by returning a fresh instance of Tuple\"\"\"\n        # ExtSlice doesn't have lineno or col_offset information\n        newnode = nodes.Tuple(ctx=Context.Load, parent=parent)\n        newnode.postinit([self.visit(dim, newnode) for dim in node.dims])  # type: ignore[attr-defined]\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_extslice", "self", "node", "ast", "extslice", "parent", "nodes", "subscript", "nodes", "tuple", "visit", "an", "extslice", "node", "by", "returning", "a", "fresh", "instance", "of", "tuple", "extslice", "doesn", "t", "have", "lineno", "or", "col_offset", "information", "newnode", "nodes", "tuple", "ctx", "context", "load", "parent", "parent", "newnode", "postinit", "self", "visit", "dim", "newnode", "for", "dim", "in", "node", "dims", "type", "ignore", "attr", "defined", "return", "newnode"], "doc_len": 59}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_for", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_for", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_for(\n        self, cls: Type[nodes.For], node: \"ast.For\", parent: NodeNG\n    ) -> nodes.For:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_for", "self", "cls", "type", "nodes", "for", "node", "ast", "for", "parent", "nodeng", "nodes", "for"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_for", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_for", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_for(\n        self, cls: Type[nodes.AsyncFor], node: \"ast.AsyncFor\", parent: NodeNG\n    ) -> nodes.AsyncFor:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_for", "self", "cls", "type", "nodes", "asyncfor", "node", "ast", "asyncfor", "parent", "nodeng", "nodes", "asyncfor"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_for", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_for", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_for(\n        self, cls: Type[T_For], node: Union[\"ast.For\", \"ast.AsyncFor\"], parent: NodeNG\n    ) -> T_For:\n        \"\"\"visit a For node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = cls(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = cls(node.lineno, node.col_offset, parent)\n        type_annotation = self.check_type_comment(node, parent=newnode)\n        newnode.postinit(\n            target=self.visit(node.target, newnode),\n            iter=self.visit(node.iter, newnode),\n            body=[self.visit(child, newnode) for child in node.body],\n            orelse=[self.visit(child, newnode) for child in node.orelse],\n            type_annotation=type_annotation,\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_for", "self", "cls", "type", "t_for", "node", "union", "ast", "for", "ast", "asyncfor", "parent", "nodeng", "t_for", "visit", "a", "for", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "cls", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "cls", "node", "lineno", "node", "col_offset", "parent", "type_annotation", "self", "check_type_comment", "node", "parent", "newnode", "newnode", "postinit", "target", "self", "visit", "node", "target", "newnode", "iter", "self", "visit", "node", "iter", "newnode", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "orelse", "self", "visit", "child", "newnode", "for", "child", "in", "node", "orelse", "type_annotation", "type_annotation", "return", "newnode"], "doc_len": 103}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_for", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_for", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_for(self, node: \"ast.For\", parent: NodeNG) -> nodes.For:\n        return self._visit_for(nodes.For, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_for", "self", "node", "ast", "for", "parent", "nodeng", "nodes", "for", "return", "self", "_visit_for", "nodes", "for", "node", "parent"], "doc_len": 21}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_importfrom", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_importfrom", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_importfrom(\n        self, node: \"ast.ImportFrom\", parent: NodeNG\n    ) -> nodes.ImportFrom:\n        \"\"\"visit an ImportFrom node by returning a fresh instance of it\"\"\"\n        names = [(alias.name, alias.asname) for alias in node.names]\n        if sys.version_info >= (3, 8):\n            newnode = nodes.ImportFrom(\n                fromname=node.module or \"\",\n                names=names,\n                level=node.level or None,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.ImportFrom(\n                node.module or \"\",\n                names,\n                node.level or None,\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        # store From names to add them to locals after building\n        self._import_from_nodes.append(newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_importfrom", "self", "node", "ast", "importfrom", "parent", "nodeng", "nodes", "importfrom", "visit", "an", "importfrom", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "names", "alias", "name", "alias", "asname", "for", "alias", "in", "node", "names", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "importfrom", "fromname", "node", "module", "or", "names", "names", "level", "node", "level", "or", "none", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "importfrom", "node", "module", "or", "names", "node", "level", "or", "none", "node", "lineno", "node", "col_offset", "parent", "store", "from", "names", "to", "add", "them", "to", "locals", "after", "building", "self", "_import_from_nodes", "append", "newnode", "return", "newnode"], "doc_len": 101}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_functiondef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_functiondef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_functiondef(\n        self, cls: Type[nodes.FunctionDef], node: \"ast.FunctionDef\", parent: NodeNG\n    ) -> nodes.FunctionDef:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_functiondef", "self", "cls", "type", "nodes", "functiondef", "node", "ast", "functiondef", "parent", "nodeng", "nodes", "functiondef"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_functiondef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_functiondef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_functiondef(\n        self,\n        cls: Type[nodes.AsyncFunctionDef],\n        node: \"ast.AsyncFunctionDef\",\n        parent: NodeNG,\n    ) -> nodes.AsyncFunctionDef:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_functiondef", "self", "cls", "type", "nodes", "asyncfunctiondef", "node", "ast", "asyncfunctiondef", "parent", "nodeng", "nodes", "asyncfunctiondef"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_functiondef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_functiondef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_functiondef(\n        self,\n        cls: Type[T_Function],\n        node: Union[\"ast.FunctionDef\", \"ast.AsyncFunctionDef\"],\n        parent: NodeNG,\n    ) -> T_Function:\n        \"\"\"visit an FunctionDef node to become astroid\"\"\"\n        self._global_names.append({})\n        node, doc = self._get_doc(node)\n\n        lineno = node.lineno\n        if PY38_PLUS and node.decorator_list:\n            # Python 3.8 sets the line number of a decorated function\n            # to be the actual line number of the function, but the\n            # previous versions expected the decorator's line number instead.\n            # We reset the function's line number to that of the\n            # first decorator to maintain backward compatibility.\n            # It's not ideal but this discrepancy was baked into\n            # the framework for *years*.\n            lineno = node.decorator_list[0].lineno\n\n        if sys.version_info >= (3, 8):\n            newnode = cls(\n                name=node.name,\n                doc=doc,\n                lineno=lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = cls(node.name, doc, lineno, node.col_offset, parent)\n        decorators = self.visit_decorators(node, newnode)\n        returns: Optional[NodeNG]\n        if node.returns:\n            returns = self.visit(node.returns, newnode)\n        else:\n            returns = None\n\n        type_comment_args = type_comment_returns = None\n        type_comment_annotation = self.check_function_type_comment(node, newnode)\n        if type_comment_annotation:\n            type_comment_returns, type_comment_args = type_comment_annotation\n        newnode.postinit(\n            args=self.visit(node.args, newnode),\n            body=[self.visit(child, newnode) for child in node.body],\n            decorators=decorators,\n            returns=returns,\n            type_comment_returns=type_comment_returns,\n            type_comment_args=type_comment_args,\n        )\n        self._global_names.pop()\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_functiondef", "self", "cls", "type", "t_function", "node", "union", "ast", "functiondef", "ast", "asyncfunctiondef", "parent", "nodeng", "t_function", "visit", "an", "functiondef", "node", "to", "become", "astroid", "self", "_global_names", "append", "node", "doc", "self", "_get_doc", "node", "lineno", "node", "lineno", "if", "py38_plus", "and", "node", "decorator_list", "python", "3", "8", "sets", "the", "line", "number", "of", "a", "decorated", "function", "to", "be", "the", "actual", "line", "number", "of", "the", "function", "but", "the", "previous", "versions", "expected", "the", "decorator", "s", "line", "number", "instead", "we", "reset", "the", "function", "s", "line", "number", "to", "that", "of", "the", "first", "decorator", "to", "maintain", "backward", "compatibility", "it", "s", "not", "ideal", "but", "this", "discrepancy", "was", "baked", "into", "the", "framework", "for", "years", "lineno", "node", "decorator_list", "0", "lineno", "if", "sys", "version_info", "3", "8", "newnode", "cls", "name", "node", "name", "doc", "doc", "lineno", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "cls", "node", "name", "doc", "lineno", "node", "col_offset", "parent", "decorators", "self", "visit_decorators", "node", "newnode", "returns", "optional", "nodeng", "if", "node", "returns", "returns", "self", "visit", "node", "returns", "newnode", "else", "returns", "none", "type_comment_args", "type_comment_returns", "none", "type_comment_annotation", "self", "check_function_type_comment", "node", "newnode", "if", "type_comment_annotation", "type_comment_returns", "type_comment_args", "type_comment_annotation", "newnode", "postinit", "args", "self", "visit", "node", "args", "newnode", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "decorators", "decorators", "returns", "returns", "type_comment_returns", "type_comment_returns", "type_comment_args", "type_comment_args", "self", "_global_names", "pop", "return", "newnode"], "doc_len": 208}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_functiondef", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_functiondef", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_functiondef(\n        self, node: \"ast.FunctionDef\", parent: NodeNG\n    ) -> nodes.FunctionDef:\n        return self._visit_functiondef(nodes.FunctionDef, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_functiondef", "self", "node", "ast", "functiondef", "parent", "nodeng", "nodes", "functiondef", "return", "self", "_visit_functiondef", "nodes", "functiondef", "node", "parent"], "doc_len": 21}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_generatorexp", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_generatorexp", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_generatorexp(\n        self, node: \"ast.GeneratorExp\", parent: NodeNG\n    ) -> nodes.GeneratorExp:\n        \"\"\"visit a GeneratorExp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.GeneratorExp(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.GeneratorExp(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.elt, newnode),\n            [self.visit(child, newnode) for child in node.generators],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_generatorexp", "self", "node", "ast", "generatorexp", "parent", "nodeng", "nodes", "generatorexp", "visit", "a", "generatorexp", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "generatorexp", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "generatorexp", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "elt", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "generators", "return", "newnode"], "doc_len": 74}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_attribute", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_attribute", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_attribute(\n        self, node: \"ast.Attribute\", parent: NodeNG\n    ) -> Union[nodes.Attribute, nodes.AssignAttr, nodes.DelAttr]:\n        \"\"\"visit an Attribute node by returning a fresh instance of it\"\"\"\n        context = self._get_context(node)\n        newnode: Union[nodes.Attribute, nodes.AssignAttr, nodes.DelAttr]\n        if context == Context.Del:\n            # FIXME : maybe we should reintroduce and visit_delattr ?\n            # for instance, deactivating assign_ctx\n            if sys.version_info >= (3, 8):\n                newnode = nodes.DelAttr(\n                    attrname=node.attr,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.DelAttr(node.attr, node.lineno, node.col_offset, parent)\n        elif context == Context.Store:\n            if sys.version_info >= (3, 8):\n                newnode = nodes.AssignAttr(\n                    attrname=node.attr,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.AssignAttr(\n                    node.attr, node.lineno, node.col_offset, parent\n                )\n            # Prohibit a local save if we are in an ExceptHandler.\n            if not isinstance(parent, nodes.ExceptHandler):\n                # mypy doesn't recognize that newnode has to be AssignAttr because it doesn't support ParamSpec\n                # See https://github.com/python/mypy/issues/8645\n                self._delayed_assattr.append(newnode)  # type: ignore[arg-type]\n        else:\n            # pylint: disable-next=else-if-used\n            # Preserve symmetry with other cases\n            if sys.version_info >= (3, 8):\n                newnode = nodes.Attribute(\n                    attrname=node.attr,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.Attribute(\n                    node.attr, node.lineno, node.col_offset, parent\n                )\n        newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_attribute", "self", "node", "ast", "attribute", "parent", "nodeng", "union", "nodes", "attribute", "nodes", "assignattr", "nodes", "delattr", "visit", "an", "attribute", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "context", "self", "_get_context", "node", "newnode", "union", "nodes", "attribute", "nodes", "assignattr", "nodes", "delattr", "if", "context", "context", "del", "fixme", "maybe", "we", "should", "reintroduce", "and", "visit_delattr", "for", "instance", "deactivating", "assign_ctx", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "delattr", "attrname", "node", "attr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "delattr", "node", "attr", "node", "lineno", "node", "col_offset", "parent", "elif", "context", "context", "store", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "assignattr", "attrname", "node", "attr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "assignattr", "node", "attr", "node", "lineno", "node", "col_offset", "parent", "prohibit", "a", "local", "save", "if", "we", "are", "in", "an", "excepthandler", "if", "not", "isinstance", "parent", "nodes", "excepthandler", "mypy", "doesn", "t", "recognize", "that", "newnode", "has", "to", "be", "assignattr", "because", "it", "doesn", "t", "support", "paramspec", "see", "https", "github", "com", "python", "mypy", "issues", "8645", "self", "_delayed_assattr", "append", "newnode", "type", "ignore", "arg", "type", "else", "pylint", "disable", "next", "else", "if", "used", "preserve", "symmetry", "with", "other", "cases", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "attribute", "attrname", "node", "attr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "attribute", "node", "attr", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 238}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_global", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_global", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_global(self, node: \"ast.Global\", parent: NodeNG) -> nodes.Global:\n        \"\"\"visit a Global node to become astroid\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Global(\n                names=node.names,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Global(\n                node.names,\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        if self._global_names:  # global at the module level, no effect\n            for name in node.names:\n                self._global_names[-1].setdefault(name, []).append(newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_global", "self", "node", "ast", "global", "parent", "nodeng", "nodes", "global", "visit", "a", "global", "node", "to", "become", "astroid", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "global", "names", "node", "names", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "global", "node", "names", "node", "lineno", "node", "col_offset", "parent", "if", "self", "_global_names", "global", "at", "the", "module", "level", "no", "effect", "for", "name", "in", "node", "names", "self", "_global_names", "1", "setdefault", "name", "append", "newnode", "return", "newnode"], "doc_len": 81}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_if", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_if", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_if(self, node: \"ast.If\", parent: NodeNG) -> nodes.If:\n        \"\"\"visit an If node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.If(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.If(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.test, newnode),\n            [self.visit(child, newnode) for child in node.body],\n            [self.visit(child, newnode) for child in node.orelse],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_if", "self", "node", "ast", "if", "parent", "nodeng", "nodes", "if", "visit", "an", "if", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "if", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "if", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "test", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "orelse", "return", "newnode"], "doc_len": 83}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_ifexp", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_ifexp", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_ifexp(self, node: \"ast.IfExp\", parent: NodeNG) -> nodes.IfExp:\n        \"\"\"visit a IfExp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.IfExp(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.IfExp(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.test, newnode),\n            self.visit(node.body, newnode),\n            self.visit(node.orelse, newnode),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_ifexp", "self", "node", "ast", "ifexp", "parent", "nodeng", "nodes", "ifexp", "visit", "a", "ifexp", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "ifexp", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "ifexp", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "test", "newnode", "self", "visit", "node", "body", "newnode", "self", "visit", "node", "orelse", "newnode", "return", "newnode"], "doc_len": 75}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_import", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_import", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_import(self, node: \"ast.Import\", parent: NodeNG) -> nodes.Import:\n        \"\"\"visit a Import node by returning a fresh instance of it\"\"\"\n        names = [(alias.name, alias.asname) for alias in node.names]\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Import(\n                names=names,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Import(\n                names,\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        # save import names in parent's locals:\n        for (name, asname) in newnode.names:\n            name = asname or name\n            parent.set_local(name.split(\".\")[0], newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_import", "self", "node", "ast", "import", "parent", "nodeng", "nodes", "import", "visit", "a", "import", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "names", "alias", "name", "alias", "asname", "for", "alias", "in", "node", "names", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "import", "names", "names", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "import", "names", "node", "lineno", "node", "col_offset", "parent", "save", "import", "names", "in", "parent", "s", "locals", "for", "name", "asname", "in", "newnode", "names", "name", "asname", "or", "name", "parent", "set_local", "name", "split", "0", "newnode", "return", "newnode"], "doc_len": 94}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_joinedstr", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_joinedstr", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_joinedstr(self, node: \"ast.JoinedStr\", parent: NodeNG) -> nodes.JoinedStr:\n        if sys.version_info >= (3, 8):\n            newnode = nodes.JoinedStr(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.JoinedStr(node.lineno, node.col_offset, parent)\n        newnode.postinit([self.visit(child, newnode) for child in node.values])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_joinedstr", "self", "node", "ast", "joinedstr", "parent", "nodeng", "nodes", "joinedstr", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "joinedstr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "joinedstr", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "values", "return", "newnode"], "doc_len": 58}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_formattedvalue", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_formattedvalue", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_formattedvalue(\n        self, node: \"ast.FormattedValue\", parent: NodeNG\n    ) -> nodes.FormattedValue:\n        if sys.version_info >= (3, 8):\n            newnode = nodes.FormattedValue(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.FormattedValue(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.value, newnode),\n            node.conversion,\n            self.visit(node.format_spec, newnode),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_formattedvalue", "self", "node", "ast", "formattedvalue", "parent", "nodeng", "nodes", "formattedvalue", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "formattedvalue", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "formattedvalue", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "node", "conversion", "self", "visit", "node", "format_spec", "newnode", "return", "newnode"], "doc_len": 61}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_namedexpr", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_namedexpr", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_namedexpr(self, node: \"ast.NamedExpr\", parent: NodeNG) -> nodes.NamedExpr:\n        if sys.version_info >= (3, 8):\n            newnode = nodes.NamedExpr(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.NamedExpr(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.target, newnode), self.visit(node.value, newnode)\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_namedexpr", "self", "node", "ast", "namedexpr", "parent", "nodeng", "nodes", "namedexpr", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "namedexpr", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "namedexpr", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "target", "newnode", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 59}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_index", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_index", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_index(self, node: \"ast.Index\", parent: nodes.Subscript) -> NodeNG:\n        \"\"\"visit a Index node by returning a fresh instance of NodeNG\"\"\"\n        return self.visit(node.value, parent)  # type: ignore[attr-defined]\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_index", "self", "node", "ast", "index", "parent", "nodes", "subscript", "nodeng", "visit", "a", "index", "node", "by", "returning", "a", "fresh", "instance", "of", "nodeng", "return", "self", "visit", "node", "value", "parent", "type", "ignore", "attr", "defined"], "doc_len": 35}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_keyword", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_keyword", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_keyword(self, node: \"ast.keyword\", parent: NodeNG) -> nodes.Keyword:\n        \"\"\"visit a Keyword node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 9):\n            newnode = nodes.Keyword(\n                arg=node.arg,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Keyword(node.arg, parent=parent)\n        newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_keyword", "self", "node", "ast", "keyword", "parent", "nodeng", "nodes", "keyword", "visit", "a", "keyword", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "9", "newnode", "nodes", "keyword", "arg", "node", "arg", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "keyword", "node", "arg", "parent", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 67}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_lambda", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_lambda", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_lambda(self, node: \"ast.Lambda\", parent: NodeNG) -> nodes.Lambda:\n        \"\"\"visit a Lambda node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Lambda(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Lambda(node.lineno, node.col_offset, parent)\n        newnode.postinit(self.visit(node.args, newnode), self.visit(node.body, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_lambda", "self", "node", "ast", "lambda", "parent", "nodeng", "nodes", "lambda", "visit", "a", "lambda", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "lambda", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "lambda", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "args", "newnode", "self", "visit", "node", "body", "newnode", "return", "newnode"], "doc_len": 70}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_list", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_list", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_list(self, node: \"ast.List\", parent: NodeNG) -> nodes.List:\n        \"\"\"visit a List node by returning a fresh instance of it\"\"\"\n        context = self._get_context(node)\n        if sys.version_info >= (3, 8):\n            newnode = nodes.List(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.List(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                parent=parent,\n            )\n        newnode.postinit([self.visit(child, newnode) for child in node.elts])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_list", "self", "node", "ast", "list", "parent", "nodeng", "nodes", "list", "visit", "a", "list", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "context", "self", "_get_context", "node", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "list", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "list", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "elts", "return", "newnode"], "doc_len": 80}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_listcomp", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_listcomp", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_listcomp(self, node: \"ast.ListComp\", parent: NodeNG) -> nodes.ListComp:\n        \"\"\"visit a ListComp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.ListComp(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.ListComp(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.elt, newnode),\n            [self.visit(child, newnode) for child in node.generators],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_listcomp", "self", "node", "ast", "listcomp", "parent", "nodeng", "nodes", "listcomp", "visit", "a", "listcomp", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "listcomp", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "listcomp", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "elt", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "generators", "return", "newnode"], "doc_len": 74}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_name", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_name", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_name(\n        self, node: \"ast.Name\", parent: NodeNG\n    ) -> Union[nodes.Name, nodes.AssignName, nodes.DelName]:\n        \"\"\"visit a Name node by returning a fresh instance of it\"\"\"\n        context = self._get_context(node)\n        newnode: Union[nodes.Name, nodes.AssignName, nodes.DelName]\n        if context == Context.Del:\n            if sys.version_info >= (3, 8):\n                newnode = nodes.DelName(\n                    name=node.id,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.DelName(node.id, node.lineno, node.col_offset, parent)\n        elif context == Context.Store:\n            if sys.version_info >= (3, 8):\n                newnode = nodes.AssignName(\n                    name=node.id,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.AssignName(\n                    node.id, node.lineno, node.col_offset, parent\n                )\n        else:\n            # pylint: disable-next=else-if-used\n            # Preserve symmetry with other cases\n            if sys.version_info >= (3, 8):\n                newnode = nodes.Name(\n                    name=node.id,\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.Name(node.id, node.lineno, node.col_offset, parent)\n        # XXX REMOVE me :\n        if context in (Context.Del, Context.Store):  # 'Aug' ??\n            newnode = cast(Union[nodes.AssignName, nodes.DelName], newnode)\n            self._save_assignment(newnode)\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_name", "self", "node", "ast", "name", "parent", "nodeng", "union", "nodes", "name", "nodes", "assignname", "nodes", "delname", "visit", "a", "name", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "context", "self", "_get_context", "node", "newnode", "union", "nodes", "name", "nodes", "assignname", "nodes", "delname", "if", "context", "context", "del", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "delname", "name", "node", "id", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "delname", "node", "id", "node", "lineno", "node", "col_offset", "parent", "elif", "context", "context", "store", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "assignname", "name", "node", "id", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "assignname", "node", "id", "node", "lineno", "node", "col_offset", "parent", "else", "pylint", "disable", "next", "else", "if", "used", "preserve", "symmetry", "with", "other", "cases", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "name", "name", "node", "id", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "name", "node", "id", "node", "lineno", "node", "col_offset", "parent", "xxx", "remove", "me", "if", "context", "in", "context", "del", "context", "store", "aug", "newnode", "cast", "union", "nodes", "assignname", "nodes", "delname", "newnode", "self", "_save_assignment", "newnode", "return", "newnode"], "doc_len": 194}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_nameconstant", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_nameconstant", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_nameconstant(\n        self, node: \"ast.NameConstant\", parent: NodeNG\n    ) -> nodes.Const:\n        # For singleton values True / False / None\n        return nodes.Const(\n            node.value,\n            node.lineno,\n            node.col_offset,\n            parent,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_nameconstant", "self", "node", "ast", "nameconstant", "parent", "nodeng", "nodes", "const", "for", "singleton", "values", "true", "false", "none", "return", "nodes", "const", "node", "value", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 30}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_nonlocal", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_nonlocal", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_nonlocal(self, node: \"ast.Nonlocal\", parent: NodeNG) -> nodes.Nonlocal:\n        \"\"\"visit a Nonlocal node and return a new instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            return nodes.Nonlocal(\n                names=node.names,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        return nodes.Nonlocal(\n            node.names,\n            node.lineno,\n            node.col_offset,\n            parent,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_nonlocal", "self", "node", "ast", "nonlocal", "parent", "nodeng", "nodes", "nonlocal", "visit", "a", "nonlocal", "node", "and", "return", "a", "new", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "return", "nodes", "nonlocal", "names", "node", "names", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "return", "nodes", "nonlocal", "node", "names", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 60}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_constant", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_constant", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_constant(self, node: \"ast.Constant\", parent: NodeNG) -> nodes.Const:\n        \"\"\"visit a Constant node by returning a fresh instance of Const\"\"\"\n        if sys.version_info >= (3, 8):\n            return nodes.Const(\n                value=node.value,\n                kind=node.kind,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        return nodes.Const(\n            node.value,\n            node.lineno,\n            node.col_offset,\n            parent,\n            node.kind,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_constant", "self", "node", "ast", "constant", "parent", "nodeng", "nodes", "const", "visit", "a", "constant", "node", "by", "returning", "a", "fresh", "instance", "of", "const", "if", "sys", "version_info", "3", "8", "return", "nodes", "const", "value", "node", "value", "kind", "node", "kind", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "return", "nodes", "const", "node", "value", "node", "lineno", "node", "col_offset", "parent", "node", "kind"], "doc_len": 65}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_str", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_str", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_str(\n        self, node: Union[\"ast.Str\", \"ast.Bytes\"], parent: NodeNG\n    ) -> nodes.Const:\n        \"\"\"visit a String/Bytes node by returning a fresh instance of Const\"\"\"\n        return nodes.Const(\n            node.s,\n            node.lineno,\n            node.col_offset,\n            parent,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_str", "self", "node", "union", "ast", "str", "ast", "bytes", "parent", "nodeng", "nodes", "const", "visit", "a", "string", "bytes", "node", "by", "returning", "a", "fresh", "instance", "of", "const", "return", "nodes", "const", "node", "s", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 39}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_num", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_num", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_num(self, node: \"ast.Num\", parent: NodeNG) -> nodes.Const:\n        \"\"\"visit a Num node by returning a fresh instance of Const\"\"\"\n        return nodes.Const(\n            node.n,\n            node.lineno,\n            node.col_offset,\n            parent,\n        )\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_num", "self", "node", "ast", "num", "parent", "nodeng", "nodes", "const", "visit", "a", "num", "node", "by", "returning", "a", "fresh", "instance", "of", "const", "return", "nodes", "const", "node", "n", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 35}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_pass", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_pass", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_pass(self, node: \"ast.Pass\", parent: NodeNG) -> nodes.Pass:\n        \"\"\"visit a Pass node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            return nodes.Pass(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        return nodes.Pass(node.lineno, node.col_offset, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_pass", "self", "node", "ast", "pass", "parent", "nodeng", "nodes", "pass", "visit", "a", "pass", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "return", "nodes", "pass", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "return", "nodes", "pass", "node", "lineno", "node", "col_offset", "parent"], "doc_len": 55}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_raise", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_raise", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_raise(self, node: \"ast.Raise\", parent: NodeNG) -> nodes.Raise:\n        \"\"\"visit a Raise node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Raise(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Raise(node.lineno, node.col_offset, parent)\n        # no traceback; anyway it is not used in Pylint\n        newnode.postinit(\n            exc=self.visit(node.exc, newnode),\n            cause=self.visit(node.cause, newnode),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_raise", "self", "node", "ast", "raise", "parent", "nodeng", "nodes", "raise", "visit", "a", "raise", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "raise", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "raise", "node", "lineno", "node", "col_offset", "parent", "no", "traceback", "anyway", "it", "is", "not", "used", "in", "pylint", "newnode", "postinit", "exc", "self", "visit", "node", "exc", "newnode", "cause", "self", "visit", "node", "cause", "newnode", "return", "newnode"], "doc_len": 81}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_return", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_return", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_return(self, node: \"ast.Return\", parent: NodeNG) -> nodes.Return:\n        \"\"\"visit a Return node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Return(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Return(node.lineno, node.col_offset, parent)\n        if node.value is not None:\n            newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_return", "self", "node", "ast", "return", "parent", "nodeng", "nodes", "return", "visit", "a", "return", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "return", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "return", "node", "lineno", "node", "col_offset", "parent", "if", "node", "value", "is", "not", "none", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 71}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_set", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_set", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_set(self, node: \"ast.Set\", parent: NodeNG) -> nodes.Set:\n        \"\"\"visit a Set node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Set(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Set(node.lineno, node.col_offset, parent)\n        newnode.postinit([self.visit(child, newnode) for child in node.elts])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_set", "self", "node", "ast", "set", "parent", "nodeng", "nodes", "set", "visit", "a", "set", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "set", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "set", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "elts", "return", "newnode"], "doc_len": 69}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_setcomp", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_setcomp", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_setcomp(self, node: \"ast.SetComp\", parent: NodeNG) -> nodes.SetComp:\n        \"\"\"visit a SetComp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.SetComp(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.SetComp(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.elt, newnode),\n            [self.visit(child, newnode) for child in node.generators],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_setcomp", "self", "node", "ast", "setcomp", "parent", "nodeng", "nodes", "setcomp", "visit", "a", "setcomp", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "setcomp", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "setcomp", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "elt", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "generators", "return", "newnode"], "doc_len": 74}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_slice", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_slice", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_slice(self, node: \"ast.Slice\", parent: nodes.Subscript) -> nodes.Slice:\n        \"\"\"visit a Slice node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 9):\n            newnode = nodes.Slice(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Slice(parent=parent)\n        newnode.postinit(\n            lower=self.visit(node.lower, newnode),\n            upper=self.visit(node.upper, newnode),\n            step=self.visit(node.step, newnode),\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_slice", "self", "node", "ast", "slice", "parent", "nodes", "subscript", "nodes", "slice", "visit", "a", "slice", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "9", "newnode", "nodes", "slice", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "slice", "parent", "parent", "newnode", "postinit", "lower", "self", "visit", "node", "lower", "newnode", "upper", "self", "visit", "node", "upper", "newnode", "step", "self", "visit", "node", "step", "newnode", "return", "newnode"], "doc_len": 76}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_subscript", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_subscript", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_subscript(self, node: \"ast.Subscript\", parent: NodeNG) -> nodes.Subscript:\n        \"\"\"visit a Subscript node by returning a fresh instance of it\"\"\"\n        context = self._get_context(node)\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Subscript(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Subscript(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                parent=parent,\n            )\n        newnode.postinit(\n            self.visit(node.value, newnode), self.visit(node.slice, newnode)\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_subscript", "self", "node", "ast", "subscript", "parent", "nodeng", "nodes", "subscript", "visit", "a", "subscript", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "context", "self", "_get_context", "node", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "subscript", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "subscript", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "self", "visit", "node", "slice", "newnode", "return", "newnode"], "doc_len": 81}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_starred", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_starred", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_starred(self, node: \"ast.Starred\", parent: NodeNG) -> nodes.Starred:\n        \"\"\"visit a Starred node and return a new instance of it\"\"\"\n        context = self._get_context(node)\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Starred(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Starred(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                parent=parent,\n            )\n        newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_starred", "self", "node", "ast", "starred", "parent", "nodeng", "nodes", "starred", "visit", "a", "starred", "node", "and", "return", "a", "new", "instance", "of", "it", "context", "self", "_get_context", "node", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "starred", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "starred", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 76}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_tryexcept", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_tryexcept", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_tryexcept(self, node: \"ast.Try\", parent: NodeNG) -> nodes.TryExcept:\n        \"\"\"visit a TryExcept node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.TryExcept(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.TryExcept(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            [self.visit(child, newnode) for child in node.body],\n            [self.visit(child, newnode) for child in node.handlers],\n            [self.visit(child, newnode) for child in node.orelse],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_tryexcept", "self", "node", "ast", "try", "parent", "nodeng", "nodes", "tryexcept", "visit", "a", "tryexcept", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "tryexcept", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "tryexcept", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "handlers", "self", "visit", "child", "newnode", "for", "child", "in", "node", "orelse", "return", "newnode"], "doc_len": 87}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_try", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_try", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_try(\n        self, node: \"ast.Try\", parent: NodeNG\n    ) -> Union[nodes.TryExcept, nodes.TryFinally, None]:\n        # python 3.3 introduce a new Try node replacing\n        # TryFinally/TryExcept nodes\n        if node.finalbody:\n            if sys.version_info >= (3, 8):\n                newnode = nodes.TryFinally(\n                    lineno=node.lineno,\n                    col_offset=node.col_offset,\n                    end_lineno=node.end_lineno,\n                    end_col_offset=node.end_col_offset,\n                    parent=parent,\n                )\n            else:\n                newnode = nodes.TryFinally(node.lineno, node.col_offset, parent)\n            body: Union[List[nodes.TryExcept], List[NodeNG]]\n            if node.handlers:\n                body = [self.visit_tryexcept(node, newnode)]\n            else:\n                body = [self.visit(child, newnode) for child in node.body]\n            newnode.postinit(body, [self.visit(n, newnode) for n in node.finalbody])\n            return newnode\n        if node.handlers:\n            return self.visit_tryexcept(node, parent)\n        return None\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_try", "self", "node", "ast", "try", "parent", "nodeng", "union", "nodes", "tryexcept", "nodes", "tryfinally", "none", "python", "3", "3", "introduce", "a", "new", "try", "node", "replacing", "tryfinally", "tryexcept", "nodes", "if", "node", "finalbody", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "tryfinally", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "tryfinally", "node", "lineno", "node", "col_offset", "parent", "body", "union", "list", "nodes", "tryexcept", "list", "nodeng", "if", "node", "handlers", "body", "self", "visit_tryexcept", "node", "newnode", "else", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "newnode", "postinit", "body", "self", "visit", "n", "newnode", "for", "n", "in", "node", "finalbody", "return", "newnode", "if", "node", "handlers", "return", "self", "visit_tryexcept", "node", "parent", "return", "none"], "doc_len": 114}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_tryfinally", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_tryfinally", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_tryfinally(self, node: \"ast.Try\", parent: NodeNG) -> nodes.TryFinally:\n        \"\"\"visit a TryFinally node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.TryFinally(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.TryFinally(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            [self.visit(child, newnode) for child in node.body],\n            [self.visit(n, newnode) for n in node.finalbody],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_tryfinally", "self", "node", "ast", "try", "parent", "nodeng", "nodes", "tryfinally", "visit", "a", "tryfinally", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "tryfinally", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "tryfinally", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "self", "visit", "n", "newnode", "for", "n", "in", "node", "finalbody", "return", "newnode"], "doc_len": 78}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_tuple", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_tuple", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_tuple(self, node: \"ast.Tuple\", parent: NodeNG) -> nodes.Tuple:\n        \"\"\"visit a Tuple node by returning a fresh instance of it\"\"\"\n        context = self._get_context(node)\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Tuple(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Tuple(\n                ctx=context,\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                parent=parent,\n            )\n        newnode.postinit([self.visit(child, newnode) for child in node.elts])\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_tuple", "self", "node", "ast", "tuple", "parent", "nodeng", "nodes", "tuple", "visit", "a", "tuple", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "context", "self", "_get_context", "node", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "tuple", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "tuple", "ctx", "context", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "newnode", "postinit", "self", "visit", "child", "newnode", "for", "child", "in", "node", "elts", "return", "newnode"], "doc_len": 80}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_unaryop", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_unaryop", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_unaryop(self, node: \"ast.UnaryOp\", parent: NodeNG) -> nodes.UnaryOp:\n        \"\"\"visit a UnaryOp node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.UnaryOp(\n                op=self._parser_module.unary_op_classes[node.op.__class__],\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.UnaryOp(\n                self._parser_module.unary_op_classes[node.op.__class__],\n                node.lineno,\n                node.col_offset,\n                parent,\n            )\n        newnode.postinit(self.visit(node.operand, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_unaryop", "self", "node", "ast", "unaryop", "parent", "nodeng", "nodes", "unaryop", "visit", "a", "unaryop", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "unaryop", "op", "self", "_parser_module", "unary_op_classes", "node", "op", "__class__", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "unaryop", "self", "_parser_module", "unary_op_classes", "node", "op", "__class__", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "operand", "newnode", "return", "newnode"], "doc_len": 78}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_while", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_while", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_while(self, node: \"ast.While\", parent: NodeNG) -> nodes.While:\n        \"\"\"visit a While node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.While(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.While(node.lineno, node.col_offset, parent)\n        newnode.postinit(\n            self.visit(node.test, newnode),\n            [self.visit(child, newnode) for child in node.body],\n            [self.visit(child, newnode) for child in node.orelse],\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_while", "self", "node", "ast", "while", "parent", "nodeng", "nodes", "while", "visit", "a", "while", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "while", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "while", "node", "lineno", "node", "col_offset", "parent", "newnode", "postinit", "self", "visit", "node", "test", "newnode", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "orelse", "return", "newnode"], "doc_len": 83}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_with", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_with", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_with(\n        self, cls: Type[nodes.With], node: \"ast.With\", parent: NodeNG\n    ) -> nodes.With:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_with", "self", "cls", "type", "nodes", "with", "node", "ast", "with", "parent", "nodeng", "nodes", "with"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_with", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_with", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_with(\n        self, cls: Type[nodes.AsyncWith], node: \"ast.AsyncWith\", parent: NodeNG\n    ) -> nodes.AsyncWith:\n        ...\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_with", "self", "cls", "type", "nodes", "asyncwith", "node", "ast", "asyncwith", "parent", "nodeng", "nodes", "asyncwith"], "doc_len": 18}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder._visit_with", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "_visit_with", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def _visit_with(\n        self,\n        cls: Type[T_With],\n        node: Union[\"ast.With\", \"ast.AsyncWith\"],\n        parent: NodeNG,\n    ) -> T_With:\n        if sys.version_info >= (3, 8):\n            newnode = cls(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = cls(node.lineno, node.col_offset, parent)\n\n        def visit_child(child: \"ast.withitem\") -> Tuple[NodeNG, Optional[NodeNG]]:\n            expr = self.visit(child.context_expr, newnode)\n            var = self.visit(child.optional_vars, newnode)\n            return expr, var\n\n        type_annotation = self.check_type_comment(node, parent=newnode)\n        newnode.postinit(\n            items=[visit_child(child) for child in node.items],\n            body=[self.visit(child, newnode) for child in node.body],\n            type_annotation=type_annotation,\n        )\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "_visit_with", "self", "cls", "type", "t_with", "node", "union", "ast", "with", "ast", "asyncwith", "parent", "nodeng", "t_with", "if", "sys", "version_info", "3", "8", "newnode", "cls", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "cls", "node", "lineno", "node", "col_offset", "parent", "def", "visit_child", "child", "ast", "withitem", "tuple", "nodeng", "optional", "nodeng", "expr", "self", "visit", "child", "context_expr", "newnode", "var", "self", "visit", "child", "optional_vars", "newnode", "return", "expr", "var", "type_annotation", "self", "check_type_comment", "node", "parent", "newnode", "newnode", "postinit", "items", "visit_child", "child", "for", "child", "in", "node", "items", "body", "self", "visit", "child", "newnode", "for", "child", "in", "node", "body", "type_annotation", "type_annotation", "return", "newnode"], "doc_len": 102}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_with", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_with", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_with(self, node: \"ast.With\", parent: NodeNG) -> NodeNG:\n        return self._visit_with(nodes.With, node, parent)\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_with", "self", "node", "ast", "with", "parent", "nodeng", "nodeng", "return", "self", "_visit_with", "nodes", "with", "node", "parent"], "doc_len": 20}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_yield", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_yield", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_yield(self, node: \"ast.Yield\", parent: NodeNG) -> NodeNG:\n        \"\"\"visit a Yield node by returning a fresh instance of it\"\"\"\n        if sys.version_info >= (3, 8):\n            newnode = nodes.Yield(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.Yield(node.lineno, node.col_offset, parent)\n        if node.value is not None:\n            newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_yield", "self", "node", "ast", "yield", "parent", "nodeng", "nodeng", "visit", "a", "yield", "node", "by", "returning", "a", "fresh", "instance", "of", "it", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "yield", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "yield", "node", "lineno", "node", "col_offset", "parent", "if", "node", "value", "is", "not", "none", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 70}
{"doc_id": "astroid/rebuilder.py::TreeRebuilder.visit_yieldfrom", "file_path": "astroid/rebuilder.py", "class_name": "TreeRebuilder", "func_name": "visit_yieldfrom", "text": "文件路径: astroid/rebuilder.py, 类名: TreeRebuilder\n    def visit_yieldfrom(self, node: \"ast.YieldFrom\", parent: NodeNG) -> NodeNG:\n        if sys.version_info >= (3, 8):\n            newnode = nodes.YieldFrom(\n                lineno=node.lineno,\n                col_offset=node.col_offset,\n                end_lineno=node.end_lineno,\n                end_col_offset=node.end_col_offset,\n                parent=parent,\n            )\n        else:\n            newnode = nodes.YieldFrom(node.lineno, node.col_offset, parent)\n        if node.value is not None:\n            newnode.postinit(self.visit(node.value, newnode))\n        return newnode\n", "tokens": ["astroid", "rebuilder", "py", "treerebuilder", "def", "visit_yieldfrom", "self", "node", "ast", "yieldfrom", "parent", "nodeng", "nodeng", "if", "sys", "version_info", "3", "8", "newnode", "nodes", "yieldfrom", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "end_lineno", "node", "end_lineno", "end_col_offset", "node", "end_col_offset", "parent", "parent", "else", "newnode", "nodes", "yieldfrom", "node", "lineno", "node", "col_offset", "parent", "if", "node", "value", "is", "not", "none", "newnode", "postinit", "self", "visit", "node", "value", "newnode", "return", "newnode"], "doc_len": 59}
{"doc_id": "astroid/test_utils.py::require_version", "file_path": "astroid/test_utils.py", "class_name": null, "func_name": "require_version", "text": "文件路径: astroid/test_utils.py\ndef require_version(minver: str = \"0.0.0\", maxver: str = \"4.0.0\") -> Callable:\n    \"\"\"Compare version of python interpreter to the given one.\n    Skip the test if older.\n    \"\"\"\n\n    def parse(python_version: str) -> Tuple[int, ...]:\n        try:\n            return tuple(int(v) for v in python_version.split(\".\"))\n        except ValueError as e:\n            msg = f\"{python_version} is not a correct version : should be X.Y[.Z].\"\n            raise ValueError(msg) from e\n\n    min_version = parse(minver)\n    max_version = parse(maxver)\n\n    def check_require_version(f):\n        current: Tuple[int, int, int] = sys.version_info[:3]\n        if min_version < current <= max_version:\n            return f\n\n        version: str = \".\".join(str(v) for v in sys.version_info)\n\n        @functools.wraps(f)\n        def new_f(*args, **kwargs):\n            if minver != \"0.0.0\":\n                pytest.skip(f\"Needs Python > {minver}. Current version is {version}.\")\n            elif maxver != \"4.0.0\":\n                pytest.skip(f\"Needs Python <= {maxver}. Current version is {version}.\")\n\n        return new_f\n\n    return check_require_version\n", "tokens": ["astroid", "test_utils", "py", "def", "require_version", "minver", "str", "0", "0", "0", "maxver", "str", "4", "0", "0", "callable", "compare", "version", "of", "python", "interpreter", "to", "the", "given", "one", "skip", "the", "test", "if", "older", "def", "parse", "python_version", "str", "tuple", "int", "try", "return", "tuple", "int", "v", "for", "v", "in", "python_version", "split", "except", "valueerror", "as", "e", "msg", "f", "python_version", "is", "not", "a", "correct", "version", "should", "be", "x", "y", "z", "raise", "valueerror", "msg", "from", "e", "min_version", "parse", "minver", "max_version", "parse", "maxver", "def", "check_require_version", "f", "current", "tuple", "int", "int", "int", "sys", "version_info", "3", "if", "min_version", "current", "max_version", "return", "f", "version", "str", "join", "str", "v", "for", "v", "in", "sys", "version_info", "functools", "wraps", "f", "def", "new_f", "args", "kwargs", "if", "minver", "0", "0", "0", "pytest", "skip", "f", "needs", "python", "minver", "current", "version", "is", "version", "elif", "maxver", "4", "0", "0", "pytest", "skip", "f", "needs", "python", "maxver", "current", "version", "is", "version", "return", "new_f", "return", "check_require_version"], "doc_len": 142}
{"doc_id": "astroid/test_utils.py::get_name_node", "file_path": "astroid/test_utils.py", "class_name": null, "func_name": "get_name_node", "text": "文件路径: astroid/test_utils.py\ndef get_name_node(start_from, name, index=0):\n    return [n for n in start_from.nodes_of_class(nodes.Name) if n.name == name][index]\n", "tokens": ["astroid", "test_utils", "py", "def", "get_name_node", "start_from", "name", "index", "0", "return", "n", "for", "n", "in", "start_from", "nodes_of_class", "nodes", "name", "if", "n", "name", "name", "index"], "doc_len": 23}
{"doc_id": "astroid/test_utils.py::enable_warning", "file_path": "astroid/test_utils.py", "class_name": null, "func_name": "enable_warning", "text": "文件路径: astroid/test_utils.py\ndef enable_warning(warning):\n    warnings.simplefilter(\"always\", warning)\n    try:\n        yield\n    finally:\n        # Reset it to default value, so it will take\n        # into account the values from the -W flag.\n        warnings.simplefilter(\"default\", warning)\n", "tokens": ["astroid", "test_utils", "py", "def", "enable_warning", "warning", "warnings", "simplefilter", "always", "warning", "try", "yield", "finally", "reset", "it", "to", "default", "value", "so", "it", "will", "take", "into", "account", "the", "values", "from", "the", "w", "flag", "warnings", "simplefilter", "default", "warning"], "doc_len": 34}
{"doc_id": "astroid/test_utils.py::brainless_manager", "file_path": "astroid/test_utils.py", "class_name": null, "func_name": "brainless_manager", "text": "文件路径: astroid/test_utils.py\ndef brainless_manager():\n    m = manager.AstroidManager()\n    # avoid caching into the AstroidManager borg since we get problems\n    # with other tests :\n    m.__dict__ = {}\n    m._failed_import_hooks = []\n    m.astroid_cache = {}\n    m._mod_file_cache = {}\n    m._transform = transforms.TransformVisitor()\n    m.extension_package_whitelist = {}\n    return m\n", "tokens": ["astroid", "test_utils", "py", "def", "brainless_manager", "m", "manager", "astroidmanager", "avoid", "caching", "into", "the", "astroidmanager", "borg", "since", "we", "get", "problems", "with", "other", "tests", "m", "__dict__", "m", "_failed_import_hooks", "m", "astroid_cache", "m", "_mod_file_cache", "m", "_transform", "transforms", "transformvisitor", "m", "extension_package_whitelist", "return", "m"], "doc_len": 37}
{"doc_id": "astroid/transforms.py::TransformVisitor.__init__", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "__init__", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def __init__(self):\n        self.transforms = collections.defaultdict(list)\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "__init__", "self", "self", "transforms", "collections", "defaultdict", "list"], "doc_len": 12}
{"doc_id": "astroid/transforms.py::TransformVisitor._transform", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "_transform", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def _transform(self, node):\n        \"\"\"Call matching transforms for the given node if any and return the\n        transformed node.\n        \"\"\"\n        cls = node.__class__\n        if cls not in self.transforms:\n            # no transform registered for this class of node\n            return node\n\n        transforms = self.transforms[cls]\n        for transform_func, predicate in transforms:\n            if predicate is None or predicate(node):\n                ret = transform_func(node)\n                # if the transformation function returns something, it's\n                # expected to be a replacement for the node\n                if ret is not None:\n                    _invalidate_cache()\n                    node = ret\n                if ret.__class__ != cls:\n                    # Can no longer apply the rest of the transforms.\n                    break\n        return node\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "_transform", "self", "node", "call", "matching", "transforms", "for", "the", "given", "node", "if", "any", "and", "return", "the", "transformed", "node", "cls", "node", "__class__", "if", "cls", "not", "in", "self", "transforms", "no", "transform", "registered", "for", "this", "class", "of", "node", "return", "node", "transforms", "self", "transforms", "cls", "for", "transform_func", "predicate", "in", "transforms", "if", "predicate", "is", "none", "or", "predicate", "node", "ret", "transform_func", "node", "if", "the", "transformation", "function", "returns", "something", "it", "s", "expected", "to", "be", "a", "replacement", "for", "the", "node", "if", "ret", "is", "not", "none", "_invalidate_cache", "node", "ret", "if", "ret", "__class__", "cls", "can", "no", "longer", "apply", "the", "rest", "of", "the", "transforms", "break", "return", "node"], "doc_len": 100}
{"doc_id": "astroid/transforms.py::TransformVisitor._visit", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "_visit", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def _visit(self, node):\n        if hasattr(node, \"_astroid_fields\"):\n            for name in node._astroid_fields:\n                value = getattr(node, name)\n                visited = self._visit_generic(value)\n                if visited != value:\n                    setattr(node, name, visited)\n        return self._transform(node)\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "_visit", "self", "node", "if", "hasattr", "node", "_astroid_fields", "for", "name", "in", "node", "_astroid_fields", "value", "getattr", "node", "name", "visited", "self", "_visit_generic", "value", "if", "visited", "value", "setattr", "node", "name", "visited", "return", "self", "_transform", "node"], "doc_len": 36}
{"doc_id": "astroid/transforms.py::TransformVisitor._visit_generic", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "_visit_generic", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def _visit_generic(self, node):\n        if isinstance(node, list):\n            return [self._visit_generic(child) for child in node]\n        if isinstance(node, tuple):\n            return tuple(self._visit_generic(child) for child in node)\n        if not node or isinstance(node, str):\n            return node\n\n        return self._visit(node)\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "_visit_generic", "self", "node", "if", "isinstance", "node", "list", "return", "self", "_visit_generic", "child", "for", "child", "in", "node", "if", "isinstance", "node", "tuple", "return", "tuple", "self", "_visit_generic", "child", "for", "child", "in", "node", "if", "not", "node", "or", "isinstance", "node", "str", "return", "node", "return", "self", "_visit", "node"], "doc_len": 46}
{"doc_id": "astroid/transforms.py::TransformVisitor.register_transform", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "register_transform", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def register_transform(self, node_class, transform, predicate=None):\n        \"\"\"Register `transform(node)` function to be applied on the given\n        astroid's `node_class` if `predicate` is None or returns true\n        when called with the node as argument.\n\n        The transform function may return a value which is then used to\n        substitute the original node in the tree.\n        \"\"\"\n        self.transforms[node_class].append((transform, predicate))\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "register_transform", "self", "node_class", "transform", "predicate", "none", "register", "transform", "node", "function", "to", "be", "applied", "on", "the", "given", "astroid", "s", "node_class", "if", "predicate", "is", "none", "or", "returns", "true", "when", "called", "with", "the", "node", "as", "argument", "the", "transform", "function", "may", "return", "a", "value", "which", "is", "then", "used", "to", "substitute", "the", "original", "node", "in", "the", "tree", "self", "transforms", "node_class", "append", "transform", "predicate"], "doc_len": 63}
{"doc_id": "astroid/transforms.py::TransformVisitor.unregister_transform", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "unregister_transform", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def unregister_transform(self, node_class, transform, predicate=None):\n        \"\"\"Unregister the given transform.\"\"\"\n        self.transforms[node_class].remove((transform, predicate))\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "unregister_transform", "self", "node_class", "transform", "predicate", "none", "unregister", "the", "given", "transform", "self", "transforms", "node_class", "remove", "transform", "predicate"], "doc_len": 21}
{"doc_id": "astroid/transforms.py::TransformVisitor.visit", "file_path": "astroid/transforms.py", "class_name": "TransformVisitor", "func_name": "visit", "text": "文件路径: astroid/transforms.py, 类名: TransformVisitor\n    def visit(self, module):\n        \"\"\"Walk the given astroid *tree* and transform each encountered node\n\n        Only the nodes which have transforms registered will actually\n        be replaced or changed.\n        \"\"\"\n        return self._visit(module)\n", "tokens": ["astroid", "transforms", "py", "transformvisitor", "def", "visit", "self", "module", "walk", "the", "given", "astroid", "tree", "and", "transform", "each", "encountered", "node", "only", "the", "nodes", "which", "have", "transforms", "registered", "will", "actually", "be", "replaced", "or", "changed", "return", "self", "_visit", "module"], "doc_len": 35}
{"doc_id": "astroid/util.py::lazy_descriptor", "file_path": "astroid/util.py", "class_name": null, "func_name": "lazy_descriptor", "text": "文件路径: astroid/util.py\ndef lazy_descriptor(obj):\n    class DescriptorProxy(lazy_object_proxy.Proxy):\n        def __get__(self, instance, owner=None):\n            return self.__class__.__get__(self, instance)\n\n    return DescriptorProxy(obj)\n", "tokens": ["astroid", "util", "py", "def", "lazy_descriptor", "obj", "class", "descriptorproxy", "lazy_object_proxy", "proxy", "def", "__get__", "self", "instance", "owner", "none", "return", "self", "__class__", "__get__", "self", "instance", "return", "descriptorproxy", "obj"], "doc_len": 25}
{"doc_id": "astroid/util.py::lazy_import", "file_path": "astroid/util.py", "class_name": null, "func_name": "lazy_import", "text": "文件路径: astroid/util.py\ndef lazy_import(module_name):\n    return lazy_object_proxy.Proxy(\n        lambda: importlib.import_module(\".\" + module_name, \"astroid\")\n    )\n", "tokens": ["astroid", "util", "py", "def", "lazy_import", "module_name", "return", "lazy_object_proxy", "proxy", "lambda", "importlib", "import_module", "module_name", "astroid"], "doc_len": 14}
{"doc_id": "astroid/util.py::Uninferable.__repr__", "file_path": "astroid/util.py", "class_name": "Uninferable", "func_name": "__repr__", "text": "文件路径: astroid/util.py, 类名: Uninferable\n    def __repr__(self):\n        return \"Uninferable\"\n", "tokens": ["astroid", "util", "py", "uninferable", "def", "__repr__", "self", "return", "uninferable"], "doc_len": 9}
{"doc_id": "astroid/util.py::Uninferable.__getattribute__", "file_path": "astroid/util.py", "class_name": "Uninferable", "func_name": "__getattribute__", "text": "文件路径: astroid/util.py, 类名: Uninferable\n    def __getattribute__(self, name):\n        if name == \"next\":\n            raise AttributeError(\"next method should not be called\")\n        if name.startswith(\"__\") and name.endswith(\"__\"):\n            return object.__getattribute__(self, name)\n        if name == \"accept\":\n            return object.__getattribute__(self, name)\n        return self\n", "tokens": ["astroid", "util", "py", "uninferable", "def", "__getattribute__", "self", "name", "if", "name", "next", "raise", "attributeerror", "next", "method", "should", "not", "be", "called", "if", "name", "startswith", "__", "and", "name", "endswith", "__", "return", "object", "__getattribute__", "self", "name", "if", "name", "accept", "return", "object", "__getattribute__", "self", "name", "return", "self"], "doc_len": 42}
{"doc_id": "astroid/util.py::Uninferable.__call__", "file_path": "astroid/util.py", "class_name": "Uninferable", "func_name": "__call__", "text": "文件路径: astroid/util.py, 类名: Uninferable\n    def __call__(self, *args, **kwargs):\n        return self\n", "tokens": ["astroid", "util", "py", "uninferable", "def", "__call__", "self", "args", "kwargs", "return", "self"], "doc_len": 11}
{"doc_id": "astroid/util.py::Uninferable.__bool__", "file_path": "astroid/util.py", "class_name": "Uninferable", "func_name": "__bool__", "text": "文件路径: astroid/util.py, 类名: Uninferable\n    def __bool__(self):\n        return False\n", "tokens": ["astroid", "util", "py", "uninferable", "def", "__bool__", "self", "return", "false"], "doc_len": 9}
{"doc_id": "astroid/util.py::Uninferable.accept", "file_path": "astroid/util.py", "class_name": "Uninferable", "func_name": "accept", "text": "文件路径: astroid/util.py, 类名: Uninferable\n    def accept(self, visitor):\n        return visitor.visit_uninferable(self)\n", "tokens": ["astroid", "util", "py", "uninferable", "def", "accept", "self", "visitor", "return", "visitor", "visit_uninferable", "self"], "doc_len": 12}
{"doc_id": "astroid/util.py::BadUnaryOperationMessage.__init__", "file_path": "astroid/util.py", "class_name": "BadUnaryOperationMessage", "func_name": "__init__", "text": "文件路径: astroid/util.py, 类名: BadUnaryOperationMessage\n    def __init__(self, operand, op, error):\n        self.operand = operand\n        self.op = op\n        self.error = error\n", "tokens": ["astroid", "util", "py", "badunaryoperationmessage", "def", "__init__", "self", "operand", "op", "error", "self", "operand", "operand", "self", "op", "op", "self", "error", "error"], "doc_len": 19}
{"doc_id": "astroid/util.py::BadUnaryOperationMessage._object_type_helper", "file_path": "astroid/util.py", "class_name": "BadUnaryOperationMessage", "func_name": "_object_type_helper", "text": "文件路径: astroid/util.py, 类名: BadUnaryOperationMessage\n    def _object_type_helper(self):\n        helpers = lazy_import(\"helpers\")\n        return helpers.object_type\n", "tokens": ["astroid", "util", "py", "badunaryoperationmessage", "def", "_object_type_helper", "self", "helpers", "lazy_import", "helpers", "return", "helpers", "object_type"], "doc_len": 13}
{"doc_id": "astroid/util.py::BadUnaryOperationMessage._object_type", "file_path": "astroid/util.py", "class_name": "BadUnaryOperationMessage", "func_name": "_object_type", "text": "文件路径: astroid/util.py, 类名: BadUnaryOperationMessage\n    def _object_type(self, obj):\n        objtype = self._object_type_helper(obj)\n        if objtype is Uninferable:\n            return None\n\n        return objtype\n", "tokens": ["astroid", "util", "py", "badunaryoperationmessage", "def", "_object_type", "self", "obj", "objtype", "self", "_object_type_helper", "obj", "if", "objtype", "is", "uninferable", "return", "none", "return", "objtype"], "doc_len": 20}
{"doc_id": "astroid/util.py::BadUnaryOperationMessage.__str__", "file_path": "astroid/util.py", "class_name": "BadUnaryOperationMessage", "func_name": "__str__", "text": "文件路径: astroid/util.py, 类名: BadUnaryOperationMessage\n    def __str__(self):\n        if hasattr(self.operand, \"name\"):\n            operand_type = self.operand.name\n        else:\n            object_type = self._object_type(self.operand)\n            if hasattr(object_type, \"name\"):\n                operand_type = object_type.name\n            else:\n                # Just fallback to as_string\n                operand_type = object_type.as_string()\n\n        msg = \"bad operand type for unary {}: {}\"\n        return msg.format(self.op, operand_type)\n", "tokens": ["astroid", "util", "py", "badunaryoperationmessage", "def", "__str__", "self", "if", "hasattr", "self", "operand", "name", "operand_type", "self", "operand", "name", "else", "object_type", "self", "_object_type", "self", "operand", "if", "hasattr", "object_type", "name", "operand_type", "object_type", "name", "else", "just", "fallback", "to", "as_string", "operand_type", "object_type", "as_string", "msg", "bad", "operand", "type", "for", "unary", "return", "msg", "format", "self", "op", "operand_type"], "doc_len": 49}
{"doc_id": "astroid/util.py::BadBinaryOperationMessage.__init__", "file_path": "astroid/util.py", "class_name": "BadBinaryOperationMessage", "func_name": "__init__", "text": "文件路径: astroid/util.py, 类名: BadBinaryOperationMessage\n    def __init__(self, left_type, op, right_type):\n        self.left_type = left_type\n        self.right_type = right_type\n        self.op = op\n", "tokens": ["astroid", "util", "py", "badbinaryoperationmessage", "def", "__init__", "self", "left_type", "op", "right_type", "self", "left_type", "left_type", "self", "right_type", "right_type", "self", "op", "op"], "doc_len": 19}
{"doc_id": "astroid/util.py::BadBinaryOperationMessage.__str__", "file_path": "astroid/util.py", "class_name": "BadBinaryOperationMessage", "func_name": "__str__", "text": "文件路径: astroid/util.py, 类名: BadBinaryOperationMessage\n    def __str__(self):\n        msg = \"unsupported operand type(s) for {}: {!r} and {!r}\"\n        return msg.format(self.op, self.left_type.name, self.right_type.name)\n", "tokens": ["astroid", "util", "py", "badbinaryoperationmessage", "def", "__str__", "self", "msg", "unsupported", "operand", "type", "s", "for", "r", "and", "r", "return", "msg", "format", "self", "op", "self", "left_type", "name", "self", "right_type", "name"], "doc_len": 27}
{"doc_id": "astroid/util.py::_instancecheck", "file_path": "astroid/util.py", "class_name": null, "func_name": "_instancecheck", "text": "文件路径: astroid/util.py\ndef _instancecheck(cls, other):\n    wrapped = cls.__wrapped__\n    other_cls = other.__class__\n    is_instance_of = wrapped is other_cls or issubclass(other_cls, wrapped)\n    warnings.warn(\n        \"%r is deprecated and slated for removal in astroid \"\n        \"2.0, use %r instead\" % (cls.__class__.__name__, wrapped.__name__),\n        PendingDeprecationWarning,\n        stacklevel=2,\n    )\n    return is_instance_of\n", "tokens": ["astroid", "util", "py", "def", "_instancecheck", "cls", "other", "wrapped", "cls", "__wrapped__", "other_cls", "other", "__class__", "is_instance_of", "wrapped", "is", "other_cls", "or", "issubclass", "other_cls", "wrapped", "warnings", "warn", "r", "is", "deprecated", "and", "slated", "for", "removal", "in", "astroid", "2", "0", "use", "r", "instead", "cls", "__class__", "__name__", "wrapped", "__name__", "pendingdeprecationwarning", "stacklevel", "2", "return", "is_instance_of"], "doc_len": 47}
{"doc_id": "astroid/util.py::proxy_alias", "file_path": "astroid/util.py", "class_name": null, "func_name": "proxy_alias", "text": "文件路径: astroid/util.py\ndef proxy_alias(alias_name, node_type):\n    \"\"\"Get a Proxy from the given name to the given node type.\"\"\"\n    proxy = type(\n        alias_name,\n        (lazy_object_proxy.Proxy,),\n        {\n            \"__class__\": object.__dict__[\"__class__\"],\n            \"__instancecheck__\": _instancecheck,\n        },\n    )\n    return proxy(lambda: node_type)\n", "tokens": ["astroid", "util", "py", "def", "proxy_alias", "alias_name", "node_type", "get", "a", "proxy", "from", "the", "given", "name", "to", "the", "given", "node", "type", "proxy", "type", "alias_name", "lazy_object_proxy", "proxy", "__class__", "object", "__dict__", "__class__", "__instancecheck__", "_instancecheck", "return", "proxy", "lambda", "node_type"], "doc_len": 34}
{"doc_id": "astroid/_ast.py::ParserModule.parse", "file_path": "astroid/_ast.py", "class_name": "ParserModule", "func_name": "parse", "text": "文件路径: astroid/_ast.py, 类名: ParserModule\n    def parse(self, string: str, type_comments=True):\n        if self.module is _ast_py3:\n            if PY38_PLUS:\n                parse_func = partial(self.module.parse, type_comments=type_comments)\n            else:\n                parse_func = partial(\n                    self.module.parse, feature_version=sys.version_info.minor\n                )\n        else:\n            parse_func = self.module.parse\n        return parse_func(string)\n", "tokens": ["astroid", "_ast", "py", "parsermodule", "def", "parse", "self", "string", "str", "type_comments", "true", "if", "self", "module", "is", "_ast_py3", "if", "py38_plus", "parse_func", "partial", "self", "module", "parse", "type_comments", "type_comments", "else", "parse_func", "partial", "self", "module", "parse", "feature_version", "sys", "version_info", "minor", "else", "parse_func", "self", "module", "parse", "return", "parse_func", "string"], "doc_len": 43}
{"doc_id": "astroid/_ast.py::parse_function_type_comment", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "parse_function_type_comment", "text": "文件路径: astroid/_ast.py\ndef parse_function_type_comment(type_comment: str) -> Optional[FunctionType]:\n    \"\"\"Given a correct type comment, obtain a FunctionType object\"\"\"\n    if _ast_py3 is None:\n        return None\n\n    func_type = _ast_py3.parse(type_comment, \"<type_comment>\", \"func_type\")  # type: ignore[attr-defined]\n    return FunctionType(argtypes=func_type.argtypes, returns=func_type.returns)\n", "tokens": ["astroid", "_ast", "py", "def", "parse_function_type_comment", "type_comment", "str", "optional", "functiontype", "given", "a", "correct", "type", "comment", "obtain", "a", "functiontype", "object", "if", "_ast_py3", "is", "none", "return", "none", "func_type", "_ast_py3", "parse", "type_comment", "type_comment", "func_type", "type", "ignore", "attr", "defined", "return", "functiontype", "argtypes", "func_type", "argtypes", "returns", "func_type", "returns"], "doc_len": 42}
{"doc_id": "astroid/_ast.py::get_parser_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "get_parser_module", "text": "文件路径: astroid/_ast.py\ndef get_parser_module(type_comments=True) -> ParserModule:\n    parser_module = ast\n    if type_comments and _ast_py3:\n        parser_module = _ast_py3\n\n    unary_op_classes = _unary_operators_from_module(parser_module)\n    cmp_op_classes = _compare_operators_from_module(parser_module)\n    bool_op_classes = _bool_operators_from_module(parser_module)\n    bin_op_classes = _binary_operators_from_module(parser_module)\n    context_classes = _contexts_from_module(parser_module)\n\n    return ParserModule(\n        parser_module,\n        unary_op_classes,\n        cmp_op_classes,\n        bool_op_classes,\n        bin_op_classes,\n        context_classes,\n    )\n", "tokens": ["astroid", "_ast", "py", "def", "get_parser_module", "type_comments", "true", "parsermodule", "parser_module", "ast", "if", "type_comments", "and", "_ast_py3", "parser_module", "_ast_py3", "unary_op_classes", "_unary_operators_from_module", "parser_module", "cmp_op_classes", "_compare_operators_from_module", "parser_module", "bool_op_classes", "_bool_operators_from_module", "parser_module", "bin_op_classes", "_binary_operators_from_module", "parser_module", "context_classes", "_contexts_from_module", "parser_module", "return", "parsermodule", "parser_module", "unary_op_classes", "cmp_op_classes", "bool_op_classes", "bin_op_classes", "context_classes"], "doc_len": 39}
{"doc_id": "astroid/_ast.py::_unary_operators_from_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "_unary_operators_from_module", "text": "文件路径: astroid/_ast.py\ndef _unary_operators_from_module(module):\n    return {module.UAdd: \"+\", module.USub: \"-\", module.Not: \"not\", module.Invert: \"~\"}\n", "tokens": ["astroid", "_ast", "py", "def", "_unary_operators_from_module", "module", "return", "module", "uadd", "module", "usub", "module", "not", "not", "module", "invert"], "doc_len": 16}
{"doc_id": "astroid/_ast.py::_binary_operators_from_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "_binary_operators_from_module", "text": "文件路径: astroid/_ast.py\ndef _binary_operators_from_module(module):\n    binary_operators = {\n        module.Add: \"+\",\n        module.BitAnd: \"&\",\n        module.BitOr: \"|\",\n        module.BitXor: \"^\",\n        module.Div: \"/\",\n        module.FloorDiv: \"//\",\n        module.MatMult: \"@\",\n        module.Mod: \"%\",\n        module.Mult: \"*\",\n        module.Pow: \"**\",\n        module.Sub: \"-\",\n        module.LShift: \"<<\",\n        module.RShift: \">>\",\n    }\n    return binary_operators\n", "tokens": ["astroid", "_ast", "py", "def", "_binary_operators_from_module", "module", "binary_operators", "module", "add", "module", "bitand", "module", "bitor", "module", "bitxor", "module", "div", "module", "floordiv", "module", "matmult", "module", "mod", "module", "mult", "module", "pow", "module", "sub", "module", "lshift", "module", "rshift", "return", "binary_operators"], "doc_len": 35}
{"doc_id": "astroid/_ast.py::_bool_operators_from_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "_bool_operators_from_module", "text": "文件路径: astroid/_ast.py\ndef _bool_operators_from_module(module):\n    return {module.And: \"and\", module.Or: \"or\"}\n", "tokens": ["astroid", "_ast", "py", "def", "_bool_operators_from_module", "module", "return", "module", "and", "and", "module", "or", "or"], "doc_len": 13}
{"doc_id": "astroid/_ast.py::_compare_operators_from_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "_compare_operators_from_module", "text": "文件路径: astroid/_ast.py\ndef _compare_operators_from_module(module):\n    return {\n        module.Eq: \"==\",\n        module.Gt: \">\",\n        module.GtE: \">=\",\n        module.In: \"in\",\n        module.Is: \"is\",\n        module.IsNot: \"is not\",\n        module.Lt: \"<\",\n        module.LtE: \"<=\",\n        module.NotEq: \"!=\",\n        module.NotIn: \"not in\",\n    }\n", "tokens": ["astroid", "_ast", "py", "def", "_compare_operators_from_module", "module", "return", "module", "eq", "module", "gt", "module", "gte", "module", "in", "in", "module", "is", "is", "module", "isnot", "is", "not", "module", "lt", "module", "lte", "module", "noteq", "module", "notin", "not", "in"], "doc_len": 33}
{"doc_id": "astroid/_ast.py::_contexts_from_module", "file_path": "astroid/_ast.py", "class_name": null, "func_name": "_contexts_from_module", "text": "文件路径: astroid/_ast.py\ndef _contexts_from_module(module) -> Dict[ast.expr_context, Context]:\n    return {\n        module.Load: Context.Load,\n        module.Store: Context.Store,\n        module.Del: Context.Del,\n        module.Param: Context.Store,\n    }\n", "tokens": ["astroid", "_ast", "py", "def", "_contexts_from_module", "module", "dict", "ast", "expr_context", "context", "return", "module", "load", "context", "load", "module", "store", "context", "store", "module", "del", "context", "del", "module", "param", "context", "store"], "doc_len": 27}
{"doc_id": "astroid/brain/brain_argparse.py::infer_namespace", "file_path": "astroid/brain/brain_argparse.py", "class_name": null, "func_name": "infer_namespace", "text": "文件路径: astroid/brain/brain_argparse.py\ndef infer_namespace(node, context=None):\n    callsite = arguments.CallSite.from_call(node, context=context)\n    if not callsite.keyword_arguments:\n        # Cannot make sense of it.\n        raise UseInferenceDefault()\n\n    class_node = nodes.ClassDef(\"Namespace\", \"docstring\")\n    class_node.parent = node.parent\n    for attr in set(callsite.keyword_arguments):\n        fake_node = nodes.EmptyNode()\n        fake_node.parent = class_node\n        fake_node.attrname = attr\n        class_node.instance_attrs[attr] = [fake_node]\n    return iter((class_node.instantiate_class(),))\n", "tokens": ["astroid", "brain", "brain_argparse", "py", "def", "infer_namespace", "node", "context", "none", "callsite", "arguments", "callsite", "from_call", "node", "context", "context", "if", "not", "callsite", "keyword_arguments", "cannot", "make", "sense", "of", "it", "raise", "useinferencedefault", "class_node", "nodes", "classdef", "namespace", "docstring", "class_node", "parent", "node", "parent", "for", "attr", "in", "set", "callsite", "keyword_arguments", "fake_node", "nodes", "emptynode", "fake_node", "parent", "class_node", "fake_node", "attrname", "attr", "class_node", "instance_attrs", "attr", "fake_node", "return", "iter", "class_node", "instantiate_class"], "doc_len": 59}
{"doc_id": "astroid/brain/brain_argparse.py::_looks_like_namespace", "file_path": "astroid/brain/brain_argparse.py", "class_name": null, "func_name": "_looks_like_namespace", "text": "文件路径: astroid/brain/brain_argparse.py\ndef _looks_like_namespace(node):\n    func = node.func\n    if isinstance(func, nodes.Attribute):\n        return (\n            func.attrname == \"Namespace\"\n            and isinstance(func.expr, nodes.Name)\n            and func.expr.name == \"argparse\"\n        )\n    return False\n", "tokens": ["astroid", "brain", "brain_argparse", "py", "def", "_looks_like_namespace", "node", "func", "node", "func", "if", "isinstance", "func", "nodes", "attribute", "return", "func", "attrname", "namespace", "and", "isinstance", "func", "expr", "nodes", "name", "and", "func", "expr", "name", "argparse", "return", "false"], "doc_len": 32}
{"doc_id": "astroid/brain/brain_attrs.py::is_decorated_with_attrs", "file_path": "astroid/brain/brain_attrs.py", "class_name": null, "func_name": "is_decorated_with_attrs", "text": "文件路径: astroid/brain/brain_attrs.py\ndef is_decorated_with_attrs(node, decorator_names=ATTRS_NAMES):\n    \"\"\"Return True if a decorated node has\n    an attr decorator applied.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator_attribute in node.decorators.nodes:\n        if isinstance(decorator_attribute, Call):  # decorator with arguments\n            decorator_attribute = decorator_attribute.func\n        if decorator_attribute.as_string() in decorator_names:\n            return True\n    return False\n", "tokens": ["astroid", "brain", "brain_attrs", "py", "def", "is_decorated_with_attrs", "node", "decorator_names", "attrs_names", "return", "true", "if", "a", "decorated", "node", "has", "an", "attr", "decorator", "applied", "if", "not", "node", "decorators", "return", "false", "for", "decorator_attribute", "in", "node", "decorators", "nodes", "if", "isinstance", "decorator_attribute", "call", "decorator", "with", "arguments", "decorator_attribute", "decorator_attribute", "func", "if", "decorator_attribute", "as_string", "in", "decorator_names", "return", "true", "return", "false"], "doc_len": 51}
{"doc_id": "astroid/brain/brain_attrs.py::attr_attributes_transform", "file_path": "astroid/brain/brain_attrs.py", "class_name": null, "func_name": "attr_attributes_transform", "text": "文件路径: astroid/brain/brain_attrs.py\ndef attr_attributes_transform(node: ClassDef) -> None:\n    \"\"\"Given that the ClassNode has an attr decorator,\n    rewrite class attributes as instance attributes\n    \"\"\"\n    # Astroid can't infer this attribute properly\n    # Prevents https://github.com/PyCQA/pylint/issues/1884\n    node.locals[\"__attrs_attrs__\"] = [Unknown(parent=node)]\n\n    for cdef_body_node in node.body:\n        if not isinstance(cdef_body_node, (Assign, AnnAssign)):\n            continue\n        if isinstance(cdef_body_node.value, Call):\n            if cdef_body_node.value.func.as_string() not in ATTRIB_NAMES:\n                continue\n        else:\n            continue\n        targets = (\n            cdef_body_node.targets\n            if hasattr(cdef_body_node, \"targets\")\n            else [cdef_body_node.target]\n        )\n        for target in targets:\n            rhs_node = Unknown(\n                lineno=cdef_body_node.lineno,\n                col_offset=cdef_body_node.col_offset,\n                parent=cdef_body_node,\n            )\n            if isinstance(target, AssignName):\n                # Could be a subscript if the code analysed is\n                # i = Optional[str] = \"\"\n                # See https://github.com/PyCQA/pylint/issues/4439\n                node.locals[target.name] = [rhs_node]\n                node.instance_attrs[target.name] = [rhs_node]\n", "tokens": ["astroid", "brain", "brain_attrs", "py", "def", "attr_attributes_transform", "node", "classdef", "none", "given", "that", "the", "classnode", "has", "an", "attr", "decorator", "rewrite", "class", "attributes", "as", "instance", "attributes", "astroid", "can", "t", "infer", "this", "attribute", "properly", "prevents", "https", "github", "com", "pycqa", "pylint", "issues", "1884", "node", "locals", "__attrs_attrs__", "unknown", "parent", "node", "for", "cdef_body_node", "in", "node", "body", "if", "not", "isinstance", "cdef_body_node", "assign", "annassign", "continue", "if", "isinstance", "cdef_body_node", "value", "call", "if", "cdef_body_node", "value", "func", "as_string", "not", "in", "attrib_names", "continue", "else", "continue", "targets", "cdef_body_node", "targets", "if", "hasattr", "cdef_body_node", "targets", "else", "cdef_body_node", "target", "for", "target", "in", "targets", "rhs_node", "unknown", "lineno", "cdef_body_node", "lineno", "col_offset", "cdef_body_node", "col_offset", "parent", "cdef_body_node", "if", "isinstance", "target", "assignname", "could", "be", "a", "subscript", "if", "the", "code", "analysed", "is", "i", "optional", "str", "see", "https", "github", "com", "pycqa", "pylint", "issues", "4439", "node", "locals", "target", "name", "rhs_node", "node", "instance_attrs", "target", "name", "rhs_node"], "doc_len": 130}
{"doc_id": "astroid/brain/brain_boto3.py::service_request_transform", "file_path": "astroid/brain/brain_boto3.py", "class_name": null, "func_name": "service_request_transform", "text": "文件路径: astroid/brain/brain_boto3.py\ndef service_request_transform(node):\n    \"\"\"Transform ServiceResource to look like dynamic classes\"\"\"\n    code = \"\"\"\n    def __getattr__(self, attr):\n        return 0\n    \"\"\"\n    func_getattr = extract_node(code)\n    node.locals[\"__getattr__\"] = [func_getattr]\n    return node\n", "tokens": ["astroid", "brain", "brain_boto3", "py", "def", "service_request_transform", "node", "transform", "serviceresource", "to", "look", "like", "dynamic", "classes", "code", "def", "__getattr__", "self", "attr", "return", "0", "func_getattr", "extract_node", "code", "node", "locals", "__getattr__", "func_getattr", "return", "node"], "doc_len": 30}
{"doc_id": "astroid/brain/brain_boto3.py::_looks_like_boto3_service_request", "file_path": "astroid/brain/brain_boto3.py", "class_name": null, "func_name": "_looks_like_boto3_service_request", "text": "文件路径: astroid/brain/brain_boto3.py\ndef _looks_like_boto3_service_request(node):\n    return node.qname() == BOTO_SERVICE_FACTORY_QUALIFIED_NAME\n", "tokens": ["astroid", "brain", "brain_boto3", "py", "def", "_looks_like_boto3_service_request", "node", "return", "node", "qname", "boto_service_factory_qualified_name"], "doc_len": 11}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_extend_string_class", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_extend_string_class", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _extend_string_class(class_node, code, rvalue):\n    \"\"\"function to extend builtin str/unicode class\"\"\"\n    code = code.format(rvalue=rvalue)\n    fake = AstroidBuilder(AstroidManager()).string_build(code)[\"whatever\"]\n    for method in fake.mymethods():\n        method.parent = class_node\n        method.lineno = None\n        method.col_offset = None\n        if \"__class__\" in method.locals:\n            method.locals[\"__class__\"] = [class_node]\n        class_node.locals[method.name] = [method]\n        method.parent = class_node\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_extend_string_class", "class_node", "code", "rvalue", "function", "to", "extend", "builtin", "str", "unicode", "class", "code", "code", "format", "rvalue", "rvalue", "fake", "astroidbuilder", "astroidmanager", "string_build", "code", "whatever", "for", "method", "in", "fake", "mymethods", "method", "parent", "class_node", "method", "lineno", "none", "method", "col_offset", "none", "if", "__class__", "in", "method", "locals", "method", "locals", "__class__", "class_node", "class_node", "locals", "method", "name", "method", "method", "parent", "class_node"], "doc_len": 58}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_extend_builtins", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_extend_builtins", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _extend_builtins(class_transforms):\n    builtin_ast = AstroidManager().builtins_module\n    for class_name, transform in class_transforms.items():\n        transform(builtin_ast[class_name])\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_extend_builtins", "class_transforms", "builtin_ast", "astroidmanager", "builtins_module", "for", "class_name", "transform", "in", "class_transforms", "items", "transform", "builtin_ast", "class_name"], "doc_len": 19}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_builtin_filter_predicate", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_builtin_filter_predicate", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _builtin_filter_predicate(node, builtin_name):\n    if (\n        builtin_name == \"type\"\n        and node.root().name == \"re\"\n        and isinstance(node.func, nodes.Name)\n        and node.func.name == \"type\"\n        and isinstance(node.parent, nodes.Assign)\n        and len(node.parent.targets) == 1\n        and isinstance(node.parent.targets[0], nodes.AssignName)\n        and node.parent.targets[0].name in {\"Pattern\", \"Match\"}\n    ):\n        # Handle re.Pattern and re.Match in brain_re\n        # Match these patterns from stdlib/re.py\n        # ```py\n        # Pattern = type(...)\n        # Match = type(...)\n        # ```\n        return False\n    if isinstance(node.func, nodes.Name) and node.func.name == builtin_name:\n        return True\n    if isinstance(node.func, nodes.Attribute):\n        return (\n            node.func.attrname == \"fromkeys\"\n            and isinstance(node.func.expr, nodes.Name)\n            and node.func.expr.name == \"dict\"\n        )\n    return False\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_builtin_filter_predicate", "node", "builtin_name", "if", "builtin_name", "type", "and", "node", "root", "name", "re", "and", "isinstance", "node", "func", "nodes", "name", "and", "node", "func", "name", "type", "and", "isinstance", "node", "parent", "nodes", "assign", "and", "len", "node", "parent", "targets", "1", "and", "isinstance", "node", "parent", "targets", "0", "nodes", "assignname", "and", "node", "parent", "targets", "0", "name", "in", "pattern", "match", "handle", "re", "pattern", "and", "re", "match", "in", "brain_re", "match", "these", "patterns", "from", "stdlib", "re", "py", "py", "pattern", "type", "match", "type", "return", "false", "if", "isinstance", "node", "func", "nodes", "name", "and", "node", "func", "name", "builtin_name", "return", "true", "if", "isinstance", "node", "func", "nodes", "attribute", "return", "node", "func", "attrname", "fromkeys", "and", "isinstance", "node", "func", "expr", "nodes", "name", "and", "node", "func", "expr", "name", "dict", "return", "false"], "doc_len": 117}
{"doc_id": "astroid/brain/brain_builtin_inference.py::register_builtin_transform", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "register_builtin_transform", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef register_builtin_transform(transform, builtin_name):\n    \"\"\"Register a new transform function for the given *builtin_name*.\n\n    The transform function must accept two parameters, a node and\n    an optional context.\n    \"\"\"\n\n    def _transform_wrapper(node, context=None):\n        result = transform(node, context=context)\n        if result:\n            if not result.parent:\n                # Let the transformation function determine\n                # the parent for its result. Otherwise,\n                # we set it to be the node we transformed from.\n                result.parent = node\n\n            if result.lineno is None:\n                result.lineno = node.lineno\n            # Can be a 'Module' see https://github.com/PyCQA/pylint/issues/4671\n            # We don't have a regression test on this one: tread carefully\n            if hasattr(result, \"col_offset\") and result.col_offset is None:\n                result.col_offset = node.col_offset\n        return iter([result])\n\n    AstroidManager().register_transform(\n        nodes.Call,\n        inference_tip(_transform_wrapper),\n        partial(_builtin_filter_predicate, builtin_name=builtin_name),\n    )\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "register_builtin_transform", "transform", "builtin_name", "register", "a", "new", "transform", "function", "for", "the", "given", "builtin_name", "the", "transform", "function", "must", "accept", "two", "parameters", "a", "node", "and", "an", "optional", "context", "def", "_transform_wrapper", "node", "context", "none", "result", "transform", "node", "context", "context", "if", "result", "if", "not", "result", "parent", "let", "the", "transformation", "function", "determine", "the", "parent", "for", "its", "result", "otherwise", "we", "set", "it", "to", "be", "the", "node", "we", "transformed", "from", "result", "parent", "node", "if", "result", "lineno", "is", "none", "result", "lineno", "node", "lineno", "can", "be", "a", "module", "see", "https", "github", "com", "pycqa", "pylint", "issues", "4671", "we", "don", "t", "have", "a", "regression", "test", "on", "this", "one", "tread", "carefully", "if", "hasattr", "result", "col_offset", "and", "result", "col_offset", "is", "none", "result", "col_offset", "node", "col_offset", "return", "iter", "result", "astroidmanager", "register_transform", "nodes", "call", "inference_tip", "_transform_wrapper", "partial", "_builtin_filter_predicate", "builtin_name", "builtin_name"], "doc_len": 129}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_container_generic_inference", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_container_generic_inference", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _container_generic_inference(node, context, node_type, transform):\n    args = node.args\n    if not args:\n        return node_type()\n    if len(node.args) > 1:\n        raise UseInferenceDefault()\n\n    (arg,) = args\n    transformed = transform(arg)\n    if not transformed:\n        try:\n            inferred = next(arg.infer(context=context))\n        except (InferenceError, StopIteration) as exc:\n            raise UseInferenceDefault from exc\n        if inferred is util.Uninferable:\n            raise UseInferenceDefault\n        transformed = transform(inferred)\n    if not transformed or transformed is util.Uninferable:\n        raise UseInferenceDefault\n    return transformed\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_container_generic_inference", "node", "context", "node_type", "transform", "args", "node", "args", "if", "not", "args", "return", "node_type", "if", "len", "node", "args", "1", "raise", "useinferencedefault", "arg", "args", "transformed", "transform", "arg", "if", "not", "transformed", "try", "inferred", "next", "arg", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "inferred", "is", "util", "uninferable", "raise", "useinferencedefault", "transformed", "transform", "inferred", "if", "not", "transformed", "or", "transformed", "is", "util", "uninferable", "raise", "useinferencedefault", "return", "transformed"], "doc_len": 71}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_container_generic_transform", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_container_generic_transform", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _container_generic_transform(  # pylint: disable=inconsistent-return-statements\n    arg, context, klass, iterables, build_elts\n):\n    if isinstance(arg, klass):\n        return arg\n    if isinstance(arg, iterables):\n        if all(isinstance(elt, nodes.Const) for elt in arg.elts):\n            elts = [elt.value for elt in arg.elts]\n        else:\n            # TODO: Does not handle deduplication for sets.\n            elts = []\n            for element in arg.elts:\n                if not element:\n                    continue\n                inferred = helpers.safe_infer(element, context=context)\n                if inferred:\n                    evaluated_object = nodes.EvaluatedObject(\n                        original=element, value=inferred\n                    )\n                    elts.append(evaluated_object)\n    elif isinstance(arg, nodes.Dict):\n        # Dicts need to have consts as strings already.\n        if not all(isinstance(elt[0], nodes.Const) for elt in arg.items):\n            raise UseInferenceDefault()\n        elts = [item[0].value for item in arg.items]\n    elif isinstance(arg, nodes.Const) and isinstance(arg.value, (str, bytes)):\n        elts = arg.value\n    else:\n        return\n    return klass.from_elements(elts=build_elts(elts))\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_container_generic_transform", "pylint", "disable", "inconsistent", "return", "statements", "arg", "context", "klass", "iterables", "build_elts", "if", "isinstance", "arg", "klass", "return", "arg", "if", "isinstance", "arg", "iterables", "if", "all", "isinstance", "elt", "nodes", "const", "for", "elt", "in", "arg", "elts", "elts", "elt", "value", "for", "elt", "in", "arg", "elts", "else", "todo", "does", "not", "handle", "deduplication", "for", "sets", "elts", "for", "element", "in", "arg", "elts", "if", "not", "element", "continue", "inferred", "helpers", "safe_infer", "element", "context", "context", "if", "inferred", "evaluated_object", "nodes", "evaluatedobject", "original", "element", "value", "inferred", "elts", "append", "evaluated_object", "elif", "isinstance", "arg", "nodes", "dict", "dicts", "need", "to", "have", "consts", "as", "strings", "already", "if", "not", "all", "isinstance", "elt", "0", "nodes", "const", "for", "elt", "in", "arg", "items", "raise", "useinferencedefault", "elts", "item", "0", "value", "for", "item", "in", "arg", "items", "elif", "isinstance", "arg", "nodes", "const", "and", "isinstance", "arg", "value", "str", "bytes", "elts", "arg", "value", "else", "return", "return", "klass", "from_elements", "elts", "build_elts", "elts"], "doc_len": 140}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_infer_builtin_container", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_infer_builtin_container", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _infer_builtin_container(\n    node, context, klass=None, iterables=None, build_elts=None\n):\n    transform_func = partial(\n        _container_generic_transform,\n        context=context,\n        klass=klass,\n        iterables=iterables,\n        build_elts=build_elts,\n    )\n\n    return _container_generic_inference(node, context, klass, transform_func)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_infer_builtin_container", "node", "context", "klass", "none", "iterables", "none", "build_elts", "none", "transform_func", "partial", "_container_generic_transform", "context", "context", "klass", "klass", "iterables", "iterables", "build_elts", "build_elts", "return", "_container_generic_inference", "node", "context", "klass", "transform_func"], "doc_len": 31}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_get_elts", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_get_elts", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _get_elts(arg, context):\n    def is_iterable(n):\n        return isinstance(n, (nodes.List, nodes.Tuple, nodes.Set))\n\n    try:\n        inferred = next(arg.infer(context))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if isinstance(inferred, nodes.Dict):\n        items = inferred.items\n    elif is_iterable(inferred):\n        items = []\n        for elt in inferred.elts:\n            # If an item is not a pair of two items,\n            # then fallback to the default inference.\n            # Also, take in consideration only hashable items,\n            # tuples and consts. We are choosing Names as well.\n            if not is_iterable(elt):\n                raise UseInferenceDefault()\n            if len(elt.elts) != 2:\n                raise UseInferenceDefault()\n            if not isinstance(elt.elts[0], (nodes.Tuple, nodes.Const, nodes.Name)):\n                raise UseInferenceDefault()\n            items.append(tuple(elt.elts))\n    else:\n        raise UseInferenceDefault()\n    return items\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_get_elts", "arg", "context", "def", "is_iterable", "n", "return", "isinstance", "n", "nodes", "list", "nodes", "tuple", "nodes", "set", "try", "inferred", "next", "arg", "infer", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "isinstance", "inferred", "nodes", "dict", "items", "inferred", "items", "elif", "is_iterable", "inferred", "items", "for", "elt", "in", "inferred", "elts", "if", "an", "item", "is", "not", "a", "pair", "of", "two", "items", "then", "fallback", "to", "the", "default", "inference", "also", "take", "in", "consideration", "only", "hashable", "items", "tuples", "and", "consts", "we", "are", "choosing", "names", "as", "well", "if", "not", "is_iterable", "elt", "raise", "useinferencedefault", "if", "len", "elt", "elts", "2", "raise", "useinferencedefault", "if", "not", "isinstance", "elt", "elts", "0", "nodes", "tuple", "nodes", "const", "nodes", "name", "raise", "useinferencedefault", "items", "append", "tuple", "elt", "elts", "else", "raise", "useinferencedefault", "return", "items"], "doc_len": 121}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_dict", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_dict", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_dict(node, context=None):\n    \"\"\"Try to infer a dict call to a Dict node.\n\n    The function treats the following cases:\n\n        * dict()\n        * dict(mapping)\n        * dict(iterable)\n        * dict(iterable, **kwargs)\n        * dict(mapping, **kwargs)\n        * dict(**kwargs)\n\n    If a case can't be inferred, we'll fallback to default inference.\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.has_invalid_arguments() or call.has_invalid_keywords():\n        raise UseInferenceDefault\n\n    args = call.positional_arguments\n    kwargs = list(call.keyword_arguments.items())\n\n    if not args and not kwargs:\n        # dict()\n        return nodes.Dict()\n    if kwargs and not args:\n        # dict(a=1, b=2, c=4)\n        items = [(nodes.Const(key), value) for key, value in kwargs]\n    elif len(args) == 1 and kwargs:\n        # dict(some_iterable, b=2, c=4)\n        elts = _get_elts(args[0], context)\n        keys = [(nodes.Const(key), value) for key, value in kwargs]\n        items = elts + keys\n    elif len(args) == 1:\n        items = _get_elts(args[0], context)\n    else:\n        raise UseInferenceDefault()\n    value = nodes.Dict(\n        col_offset=node.col_offset, lineno=node.lineno, parent=node.parent\n    )\n    value.postinit(items)\n    return value\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_dict", "node", "context", "none", "try", "to", "infer", "a", "dict", "call", "to", "a", "dict", "node", "the", "function", "treats", "the", "following", "cases", "dict", "dict", "mapping", "dict", "iterable", "dict", "iterable", "kwargs", "dict", "mapping", "kwargs", "dict", "kwargs", "if", "a", "case", "can", "t", "be", "inferred", "we", "ll", "fallback", "to", "default", "inference", "call", "arguments", "callsite", "from_call", "node", "context", "context", "if", "call", "has_invalid_arguments", "or", "call", "has_invalid_keywords", "raise", "useinferencedefault", "args", "call", "positional_arguments", "kwargs", "list", "call", "keyword_arguments", "items", "if", "not", "args", "and", "not", "kwargs", "dict", "return", "nodes", "dict", "if", "kwargs", "and", "not", "args", "dict", "a", "1", "b", "2", "c", "4", "items", "nodes", "const", "key", "value", "for", "key", "value", "in", "kwargs", "elif", "len", "args", "1", "and", "kwargs", "dict", "some_iterable", "b", "2", "c", "4", "elts", "_get_elts", "args", "0", "context", "keys", "nodes", "const", "key", "value", "for", "key", "value", "in", "kwargs", "items", "elts", "keys", "elif", "len", "args", "1", "items", "_get_elts", "args", "0", "context", "else", "raise", "useinferencedefault", "value", "nodes", "dict", "col_offset", "node", "col_offset", "lineno", "node", "lineno", "parent", "node", "parent", "value", "postinit", "items", "return", "value"], "doc_len": 165}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_super", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_super", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_super(node, context=None):\n    \"\"\"Understand super calls.\n\n    There are some restrictions for what can be understood:\n\n        * unbounded super (one argument form) is not understood.\n\n        * if the super call is not inside a function (classmethod or method),\n          then the default inference will be used.\n\n        * if the super arguments can't be inferred, the default inference\n          will be used.\n    \"\"\"\n    if len(node.args) == 1:\n        # Ignore unbounded super.\n        raise UseInferenceDefault\n\n    scope = node.scope()\n    if not isinstance(scope, nodes.FunctionDef):\n        # Ignore non-method uses of super.\n        raise UseInferenceDefault\n    if scope.type not in (\"classmethod\", \"method\"):\n        # Not interested in staticmethods.\n        raise UseInferenceDefault\n\n    cls = scoped_nodes.get_wrapping_class(scope)\n    if not node.args:\n        mro_pointer = cls\n        # In we are in a classmethod, the interpreter will fill\n        # automatically the class as the second argument, not an instance.\n        if scope.type == \"classmethod\":\n            mro_type = cls\n        else:\n            mro_type = cls.instantiate_class()\n    else:\n        try:\n            mro_pointer = next(node.args[0].infer(context=context))\n        except (InferenceError, StopIteration) as exc:\n            raise UseInferenceDefault from exc\n        try:\n            mro_type = next(node.args[1].infer(context=context))\n        except (InferenceError, StopIteration) as exc:\n            raise UseInferenceDefault from exc\n\n    if mro_pointer is util.Uninferable or mro_type is util.Uninferable:\n        # No way we could understand this.\n        raise UseInferenceDefault\n\n    super_obj = objects.Super(\n        mro_pointer=mro_pointer, mro_type=mro_type, self_class=cls, scope=scope\n    )\n    super_obj.parent = node\n    return super_obj\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_super", "node", "context", "none", "understand", "super", "calls", "there", "are", "some", "restrictions", "for", "what", "can", "be", "understood", "unbounded", "super", "one", "argument", "form", "is", "not", "understood", "if", "the", "super", "call", "is", "not", "inside", "a", "function", "classmethod", "or", "method", "then", "the", "default", "inference", "will", "be", "used", "if", "the", "super", "arguments", "can", "t", "be", "inferred", "the", "default", "inference", "will", "be", "used", "if", "len", "node", "args", "1", "ignore", "unbounded", "super", "raise", "useinferencedefault", "scope", "node", "scope", "if", "not", "isinstance", "scope", "nodes", "functiondef", "ignore", "non", "method", "uses", "of", "super", "raise", "useinferencedefault", "if", "scope", "type", "not", "in", "classmethod", "method", "not", "interested", "in", "staticmethods", "raise", "useinferencedefault", "cls", "scoped_nodes", "get_wrapping_class", "scope", "if", "not", "node", "args", "mro_pointer", "cls", "in", "we", "are", "in", "a", "classmethod", "the", "interpreter", "will", "fill", "automatically", "the", "class", "as", "the", "second", "argument", "not", "an", "instance", "if", "scope", "type", "classmethod", "mro_type", "cls", "else", "mro_type", "cls", "instantiate_class", "else", "try", "mro_pointer", "next", "node", "args", "0", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "try", "mro_type", "next", "node", "args", "1", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "mro_pointer", "is", "util", "uninferable", "or", "mro_type", "is", "util", "uninferable", "no", "way", "we", "could", "understand", "this", "raise", "useinferencedefault", "super_obj", "objects", "super", "mro_pointer", "mro_pointer", "mro_type", "mro_type", "self_class", "cls", "scope", "scope", "super_obj", "parent", "node", "return", "super_obj"], "doc_len": 213}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_infer_getattr_args", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_infer_getattr_args", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _infer_getattr_args(node, context):\n    if len(node.args) not in (2, 3):\n        # Not a valid getattr call.\n        raise UseInferenceDefault\n\n    try:\n        obj = next(node.args[0].infer(context=context))\n        attr = next(node.args[1].infer(context=context))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n\n    if obj is util.Uninferable or attr is util.Uninferable:\n        # If one of the arguments is something we can't infer,\n        # then also make the result of the getattr call something\n        # which is unknown.\n        return util.Uninferable, util.Uninferable\n\n    is_string = isinstance(attr, nodes.Const) and isinstance(attr.value, str)\n    if not is_string:\n        raise UseInferenceDefault\n\n    return obj, attr.value\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_infer_getattr_args", "node", "context", "if", "len", "node", "args", "not", "in", "2", "3", "not", "a", "valid", "getattr", "call", "raise", "useinferencedefault", "try", "obj", "next", "node", "args", "0", "infer", "context", "context", "attr", "next", "node", "args", "1", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "obj", "is", "util", "uninferable", "or", "attr", "is", "util", "uninferable", "if", "one", "of", "the", "arguments", "is", "something", "we", "can", "t", "infer", "then", "also", "make", "the", "result", "of", "the", "getattr", "call", "something", "which", "is", "unknown", "return", "util", "uninferable", "util", "uninferable", "is_string", "isinstance", "attr", "nodes", "const", "and", "isinstance", "attr", "value", "str", "if", "not", "is_string", "raise", "useinferencedefault", "return", "obj", "attr", "value"], "doc_len": 107}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_getattr", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_getattr", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_getattr(node, context=None):\n    \"\"\"Understand getattr calls\n\n    If one of the arguments is an Uninferable object, then the\n    result will be an Uninferable object. Otherwise, the normal attribute\n    lookup will be done.\n    \"\"\"\n    obj, attr = _infer_getattr_args(node, context)\n    if (\n        obj is util.Uninferable\n        or attr is util.Uninferable\n        or not hasattr(obj, \"igetattr\")\n    ):\n        return util.Uninferable\n\n    try:\n        return next(obj.igetattr(attr, context=context))\n    except (StopIteration, InferenceError, AttributeInferenceError):\n        if len(node.args) == 3:\n            # Try to infer the default and return it instead.\n            try:\n                return next(node.args[2].infer(context=context))\n            except (StopIteration, InferenceError) as exc:\n                raise UseInferenceDefault from exc\n\n    raise UseInferenceDefault\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_getattr", "node", "context", "none", "understand", "getattr", "calls", "if", "one", "of", "the", "arguments", "is", "an", "uninferable", "object", "then", "the", "result", "will", "be", "an", "uninferable", "object", "otherwise", "the", "normal", "attribute", "lookup", "will", "be", "done", "obj", "attr", "_infer_getattr_args", "node", "context", "if", "obj", "is", "util", "uninferable", "or", "attr", "is", "util", "uninferable", "or", "not", "hasattr", "obj", "igetattr", "return", "util", "uninferable", "try", "return", "next", "obj", "igetattr", "attr", "context", "context", "except", "stopiteration", "inferenceerror", "attributeinferenceerror", "if", "len", "node", "args", "3", "try", "to", "infer", "the", "default", "and", "return", "it", "instead", "try", "return", "next", "node", "args", "2", "infer", "context", "context", "except", "stopiteration", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "raise", "useinferencedefault"], "doc_len": 106}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_hasattr", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_hasattr", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_hasattr(node, context=None):\n    \"\"\"Understand hasattr calls\n\n    This always guarantees three possible outcomes for calling\n    hasattr: Const(False) when we are sure that the object\n    doesn't have the intended attribute, Const(True) when\n    we know that the object has the attribute and Uninferable\n    when we are unsure of the outcome of the function call.\n    \"\"\"\n    try:\n        obj, attr = _infer_getattr_args(node, context)\n        if (\n            obj is util.Uninferable\n            or attr is util.Uninferable\n            or not hasattr(obj, \"getattr\")\n        ):\n            return util.Uninferable\n        obj.getattr(attr, context=context)\n    except UseInferenceDefault:\n        # Can't infer something from this function call.\n        return util.Uninferable\n    except AttributeInferenceError:\n        # Doesn't have it.\n        return nodes.Const(False)\n    return nodes.Const(True)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_hasattr", "node", "context", "none", "understand", "hasattr", "calls", "this", "always", "guarantees", "three", "possible", "outcomes", "for", "calling", "hasattr", "const", "false", "when", "we", "are", "sure", "that", "the", "object", "doesn", "t", "have", "the", "intended", "attribute", "const", "true", "when", "we", "know", "that", "the", "object", "has", "the", "attribute", "and", "uninferable", "when", "we", "are", "unsure", "of", "the", "outcome", "of", "the", "function", "call", "try", "obj", "attr", "_infer_getattr_args", "node", "context", "if", "obj", "is", "util", "uninferable", "or", "attr", "is", "util", "uninferable", "or", "not", "hasattr", "obj", "getattr", "return", "util", "uninferable", "obj", "getattr", "attr", "context", "context", "except", "useinferencedefault", "can", "t", "infer", "something", "from", "this", "function", "call", "return", "util", "uninferable", "except", "attributeinferenceerror", "doesn", "t", "have", "it", "return", "nodes", "const", "false", "return", "nodes", "const", "true"], "doc_len": 116}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_callable", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_callable", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_callable(node, context=None):\n    \"\"\"Understand callable calls\n\n    This follows Python's semantics, where an object\n    is callable if it provides an attribute __call__,\n    even though that attribute is something which can't be\n    called.\n    \"\"\"\n    if len(node.args) != 1:\n        # Invalid callable call.\n        raise UseInferenceDefault\n\n    argument = node.args[0]\n    try:\n        inferred = next(argument.infer(context=context))\n    except (InferenceError, StopIteration):\n        return util.Uninferable\n    if inferred is util.Uninferable:\n        return util.Uninferable\n    return nodes.Const(inferred.callable())\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_callable", "node", "context", "none", "understand", "callable", "calls", "this", "follows", "python", "s", "semantics", "where", "an", "object", "is", "callable", "if", "it", "provides", "an", "attribute", "__call__", "even", "though", "that", "attribute", "is", "something", "which", "can", "t", "be", "called", "if", "len", "node", "args", "1", "invalid", "callable", "call", "raise", "useinferencedefault", "argument", "node", "args", "0", "try", "inferred", "next", "argument", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "return", "util", "uninferable", "if", "inferred", "is", "util", "uninferable", "return", "util", "uninferable", "return", "nodes", "const", "inferred", "callable"], "doc_len": 79}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_property", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_property", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_property(node, context=None):\n    \"\"\"Understand `property` class\n\n    This only infers the output of `property`\n    call, not the arguments themselves.\n    \"\"\"\n    if len(node.args) < 1:\n        # Invalid property call.\n        raise UseInferenceDefault\n\n    getter = node.args[0]\n    try:\n        inferred = next(getter.infer(context=context))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n\n    if not isinstance(inferred, (nodes.FunctionDef, nodes.Lambda)):\n        raise UseInferenceDefault\n\n    return objects.Property(\n        function=inferred,\n        name=inferred.name,\n        doc=getattr(inferred, \"doc\", None),\n        lineno=node.lineno,\n        parent=node,\n        col_offset=node.col_offset,\n    )\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_property", "node", "context", "none", "understand", "property", "class", "this", "only", "infers", "the", "output", "of", "property", "call", "not", "the", "arguments", "themselves", "if", "len", "node", "args", "1", "invalid", "property", "call", "raise", "useinferencedefault", "getter", "node", "args", "0", "try", "inferred", "next", "getter", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "not", "isinstance", "inferred", "nodes", "functiondef", "nodes", "lambda", "raise", "useinferencedefault", "return", "objects", "property", "function", "inferred", "name", "inferred", "name", "doc", "getattr", "inferred", "doc", "none", "lineno", "node", "lineno", "parent", "node", "col_offset", "node", "col_offset"], "doc_len": 85}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_bool", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_bool", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_bool(node, context=None):\n    \"\"\"Understand bool calls.\"\"\"\n    if len(node.args) > 1:\n        # Invalid bool call.\n        raise UseInferenceDefault\n\n    if not node.args:\n        return nodes.Const(False)\n\n    argument = node.args[0]\n    try:\n        inferred = next(argument.infer(context=context))\n    except (InferenceError, StopIteration):\n        return util.Uninferable\n    if inferred is util.Uninferable:\n        return util.Uninferable\n\n    bool_value = inferred.bool_value(context=context)\n    if bool_value is util.Uninferable:\n        return util.Uninferable\n    return nodes.Const(bool_value)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_bool", "node", "context", "none", "understand", "bool", "calls", "if", "len", "node", "args", "1", "invalid", "bool", "call", "raise", "useinferencedefault", "if", "not", "node", "args", "return", "nodes", "const", "false", "argument", "node", "args", "0", "try", "inferred", "next", "argument", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "return", "util", "uninferable", "if", "inferred", "is", "util", "uninferable", "return", "util", "uninferable", "bool_value", "inferred", "bool_value", "context", "context", "if", "bool_value", "is", "util", "uninferable", "return", "util", "uninferable", "return", "nodes", "const", "bool_value"], "doc_len": 72}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_type", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_type", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_type(node, context=None):\n    \"\"\"Understand the one-argument form of *type*.\"\"\"\n    if len(node.args) != 1:\n        raise UseInferenceDefault\n\n    return helpers.object_type(node.args[0], context)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_type", "node", "context", "none", "understand", "the", "one", "argument", "form", "of", "type", "if", "len", "node", "args", "1", "raise", "useinferencedefault", "return", "helpers", "object_type", "node", "args", "0", "context"], "doc_len": 30}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_slice", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_slice", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_slice(node, context=None):\n    \"\"\"Understand `slice` calls.\"\"\"\n    args = node.args\n    if not 0 < len(args) <= 3:\n        raise UseInferenceDefault\n\n    infer_func = partial(helpers.safe_infer, context=context)\n    args = [infer_func(arg) for arg in args]\n    for arg in args:\n        if not arg or arg is util.Uninferable:\n            raise UseInferenceDefault\n        if not isinstance(arg, nodes.Const):\n            raise UseInferenceDefault\n        if not isinstance(arg.value, (type(None), int)):\n            raise UseInferenceDefault\n\n    if len(args) < 3:\n        # Make sure we have 3 arguments.\n        args.extend([None] * (3 - len(args)))\n\n    slice_node = nodes.Slice(\n        lineno=node.lineno, col_offset=node.col_offset, parent=node.parent\n    )\n    slice_node.postinit(*args)\n    return slice_node\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_slice", "node", "context", "none", "understand", "slice", "calls", "args", "node", "args", "if", "not", "0", "len", "args", "3", "raise", "useinferencedefault", "infer_func", "partial", "helpers", "safe_infer", "context", "context", "args", "infer_func", "arg", "for", "arg", "in", "args", "for", "arg", "in", "args", "if", "not", "arg", "or", "arg", "is", "util", "uninferable", "raise", "useinferencedefault", "if", "not", "isinstance", "arg", "nodes", "const", "raise", "useinferencedefault", "if", "not", "isinstance", "arg", "value", "type", "none", "int", "raise", "useinferencedefault", "if", "len", "args", "3", "make", "sure", "we", "have", "3", "arguments", "args", "extend", "none", "3", "len", "args", "slice_node", "nodes", "slice", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "node", "parent", "slice_node", "postinit", "args", "return", "slice_node"], "doc_len": 101}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_infer_object__new__decorator", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_infer_object__new__decorator", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _infer_object__new__decorator(node, context=None):\n    # Instantiate class immediately\n    # since that's what @object.__new__ does\n    return iter((node.instantiate_class(),))\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_infer_object__new__decorator", "node", "context", "none", "instantiate", "class", "immediately", "since", "that", "s", "what", "object", "__new__", "does", "return", "iter", "node", "instantiate_class"], "doc_len": 23}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_infer_object__new__decorator_check", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_infer_object__new__decorator_check", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _infer_object__new__decorator_check(node):\n    \"\"\"Predicate before inference_tip\n\n    Check if the given ClassDef has an @object.__new__ decorator\n    \"\"\"\n    if not node.decorators:\n        return False\n\n    for decorator in node.decorators.nodes:\n        if isinstance(decorator, nodes.Attribute):\n            if decorator.as_string() == OBJECT_DUNDER_NEW:\n                return True\n    return False\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_infer_object__new__decorator_check", "node", "predicate", "before", "inference_tip", "check", "if", "the", "given", "classdef", "has", "an", "object", "__new__", "decorator", "if", "not", "node", "decorators", "return", "false", "for", "decorator", "in", "node", "decorators", "nodes", "if", "isinstance", "decorator", "nodes", "attribute", "if", "decorator", "as_string", "object_dunder_new", "return", "true", "return", "false"], "doc_len": 45}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_issubclass", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_issubclass", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_issubclass(callnode, context=None):\n    \"\"\"Infer issubclass() calls\n\n    :param nodes.Call callnode: an `issubclass` call\n    :param InferenceContext context: the context for the inference\n    :rtype nodes.Const: Boolean Const value of the `issubclass` call\n    :raises UseInferenceDefault: If the node cannot be inferred\n    \"\"\"\n    call = arguments.CallSite.from_call(callnode, context=context)\n    if call.keyword_arguments:\n        # issubclass doesn't support keyword arguments\n        raise UseInferenceDefault(\"TypeError: issubclass() takes no keyword arguments\")\n    if len(call.positional_arguments) != 2:\n        raise UseInferenceDefault(\n            f\"Expected two arguments, got {len(call.positional_arguments)}\"\n        )\n    # The left hand argument is the obj to be checked\n    obj_node, class_or_tuple_node = call.positional_arguments\n\n    try:\n        obj_type = next(obj_node.infer(context=context))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if not isinstance(obj_type, nodes.ClassDef):\n        raise UseInferenceDefault(\"TypeError: arg 1 must be class\")\n\n    # The right hand argument is the class(es) that the given\n    # object is to be checked against.\n    try:\n        class_container = _class_or_tuple_to_container(\n            class_or_tuple_node, context=context\n        )\n    except InferenceError as exc:\n        raise UseInferenceDefault from exc\n    try:\n        issubclass_bool = helpers.object_issubclass(obj_type, class_container, context)\n    except AstroidTypeError as exc:\n        raise UseInferenceDefault(\"TypeError: \" + str(exc)) from exc\n    except MroError as exc:\n        raise UseInferenceDefault from exc\n    return nodes.Const(issubclass_bool)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_issubclass", "callnode", "context", "none", "infer", "issubclass", "calls", "param", "nodes", "call", "callnode", "an", "issubclass", "call", "param", "inferencecontext", "context", "the", "context", "for", "the", "inference", "rtype", "nodes", "const", "boolean", "const", "value", "of", "the", "issubclass", "call", "raises", "useinferencedefault", "if", "the", "node", "cannot", "be", "inferred", "call", "arguments", "callsite", "from_call", "callnode", "context", "context", "if", "call", "keyword_arguments", "issubclass", "doesn", "t", "support", "keyword", "arguments", "raise", "useinferencedefault", "typeerror", "issubclass", "takes", "no", "keyword", "arguments", "if", "len", "call", "positional_arguments", "2", "raise", "useinferencedefault", "f", "expected", "two", "arguments", "got", "len", "call", "positional_arguments", "the", "left", "hand", "argument", "is", "the", "obj", "to", "be", "checked", "obj_node", "class_or_tuple_node", "call", "positional_arguments", "try", "obj_type", "next", "obj_node", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "not", "isinstance", "obj_type", "nodes", "classdef", "raise", "useinferencedefault", "typeerror", "arg", "1", "must", "be", "class", "the", "right", "hand", "argument", "is", "the", "class", "es", "that", "the", "given", "object", "is", "to", "be", "checked", "against", "try", "class_container", "_class_or_tuple_to_container", "class_or_tuple_node", "context", "context", "except", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "try", "issubclass_bool", "helpers", "object_issubclass", "obj_type", "class_container", "context", "except", "astroidtypeerror", "as", "exc", "raise", "useinferencedefault", "typeerror", "str", "exc", "from", "exc", "except", "mroerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "return", "nodes", "const", "issubclass_bool"], "doc_len": 189}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_isinstance", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_isinstance", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_isinstance(callnode, context=None):\n    \"\"\"Infer isinstance calls\n\n    :param nodes.Call callnode: an isinstance call\n    :param InferenceContext context: context for call\n        (currently unused but is a common interface for inference)\n    :rtype nodes.Const: Boolean Const value of isinstance call\n\n    :raises UseInferenceDefault: If the node cannot be inferred\n    \"\"\"\n    call = arguments.CallSite.from_call(callnode, context=context)\n    if call.keyword_arguments:\n        # isinstance doesn't support keyword arguments\n        raise UseInferenceDefault(\"TypeError: isinstance() takes no keyword arguments\")\n    if len(call.positional_arguments) != 2:\n        raise UseInferenceDefault(\n            f\"Expected two arguments, got {len(call.positional_arguments)}\"\n        )\n    # The left hand argument is the obj to be checked\n    obj_node, class_or_tuple_node = call.positional_arguments\n    # The right hand argument is the class(es) that the given\n    # obj is to be check is an instance of\n    try:\n        class_container = _class_or_tuple_to_container(\n            class_or_tuple_node, context=context\n        )\n    except InferenceError as exc:\n        raise UseInferenceDefault from exc\n    try:\n        isinstance_bool = helpers.object_isinstance(obj_node, class_container, context)\n    except AstroidTypeError as exc:\n        raise UseInferenceDefault(\"TypeError: \" + str(exc)) from exc\n    except MroError as exc:\n        raise UseInferenceDefault from exc\n    if isinstance_bool is util.Uninferable:\n        raise UseInferenceDefault\n    return nodes.Const(isinstance_bool)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_isinstance", "callnode", "context", "none", "infer", "isinstance", "calls", "param", "nodes", "call", "callnode", "an", "isinstance", "call", "param", "inferencecontext", "context", "context", "for", "call", "currently", "unused", "but", "is", "a", "common", "interface", "for", "inference", "rtype", "nodes", "const", "boolean", "const", "value", "of", "isinstance", "call", "raises", "useinferencedefault", "if", "the", "node", "cannot", "be", "inferred", "call", "arguments", "callsite", "from_call", "callnode", "context", "context", "if", "call", "keyword_arguments", "isinstance", "doesn", "t", "support", "keyword", "arguments", "raise", "useinferencedefault", "typeerror", "isinstance", "takes", "no", "keyword", "arguments", "if", "len", "call", "positional_arguments", "2", "raise", "useinferencedefault", "f", "expected", "two", "arguments", "got", "len", "call", "positional_arguments", "the", "left", "hand", "argument", "is", "the", "obj", "to", "be", "checked", "obj_node", "class_or_tuple_node", "call", "positional_arguments", "the", "right", "hand", "argument", "is", "the", "class", "es", "that", "the", "given", "obj", "is", "to", "be", "check", "is", "an", "instance", "of", "try", "class_container", "_class_or_tuple_to_container", "class_or_tuple_node", "context", "context", "except", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "try", "isinstance_bool", "helpers", "object_isinstance", "obj_node", "class_container", "context", "except", "astroidtypeerror", "as", "exc", "raise", "useinferencedefault", "typeerror", "str", "exc", "from", "exc", "except", "mroerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "isinstance_bool", "is", "util", "uninferable", "raise", "useinferencedefault", "return", "nodes", "const", "isinstance_bool"], "doc_len": 175}
{"doc_id": "astroid/brain/brain_builtin_inference.py::_class_or_tuple_to_container", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "_class_or_tuple_to_container", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef _class_or_tuple_to_container(node, context=None):\n    # Move inferences results into container\n    # to simplify later logic\n    # raises InferenceError if any of the inferences fall through\n    try:\n        node_infer = next(node.infer(context=context))\n    except StopIteration as e:\n        raise InferenceError(node=node, context=context) from e\n    # arg2 MUST be a type or a TUPLE of types\n    # for isinstance\n    if isinstance(node_infer, nodes.Tuple):\n        try:\n            class_container = [\n                next(node.infer(context=context)) for node in node_infer.elts\n            ]\n        except StopIteration as e:\n            raise InferenceError(node=node, context=context) from e\n        class_container = [\n            klass_node for klass_node in class_container if klass_node is not None\n        ]\n    else:\n        class_container = [node_infer]\n    return class_container\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "_class_or_tuple_to_container", "node", "context", "none", "move", "inferences", "results", "into", "container", "to", "simplify", "later", "logic", "raises", "inferenceerror", "if", "any", "of", "the", "inferences", "fall", "through", "try", "node_infer", "next", "node", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "context", "context", "from", "e", "arg2", "must", "be", "a", "type", "or", "a", "tuple", "of", "types", "for", "isinstance", "if", "isinstance", "node_infer", "nodes", "tuple", "try", "class_container", "next", "node", "infer", "context", "context", "for", "node", "in", "node_infer", "elts", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "context", "context", "from", "e", "class_container", "klass_node", "for", "klass_node", "in", "class_container", "if", "klass_node", "is", "not", "none", "else", "class_container", "node_infer", "return", "class_container"], "doc_len": 103}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_len", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_len", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_len(node, context=None):\n    \"\"\"Infer length calls\n\n    :param nodes.Call node: len call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const node with the inferred length, if possible\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: len() must take no keyword arguments\")\n    if len(call.positional_arguments) != 1:\n        raise UseInferenceDefault(\n            \"TypeError: len() must take exactly one argument \"\n            \"({len}) given\".format(len=len(call.positional_arguments))\n        )\n    [argument_node] = call.positional_arguments\n\n    try:\n        return nodes.Const(helpers.object_len(argument_node, context=context))\n    except (AstroidTypeError, InferenceError) as exc:\n        raise UseInferenceDefault(str(exc)) from exc\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_len", "node", "context", "none", "infer", "length", "calls", "param", "nodes", "call", "node", "len", "call", "to", "infer", "param", "context", "inferencecontext", "node", "context", "rtype", "nodes", "const", "a", "const", "node", "with", "the", "inferred", "length", "if", "possible", "call", "arguments", "callsite", "from_call", "node", "context", "context", "if", "call", "keyword_arguments", "raise", "useinferencedefault", "typeerror", "len", "must", "take", "no", "keyword", "arguments", "if", "len", "call", "positional_arguments", "1", "raise", "useinferencedefault", "typeerror", "len", "must", "take", "exactly", "one", "argument", "len", "given", "format", "len", "len", "call", "positional_arguments", "argument_node", "call", "positional_arguments", "try", "return", "nodes", "const", "helpers", "object_len", "argument_node", "context", "context", "except", "astroidtypeerror", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "str", "exc", "from", "exc"], "doc_len": 100}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_str", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_str", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_str(node, context=None):\n    \"\"\"Infer str() calls\n\n    :param nodes.Call node: str() call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const containing an empty string\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: str() must take no keyword arguments\")\n    try:\n        return nodes.Const(\"\")\n    except (AstroidTypeError, InferenceError) as exc:\n        raise UseInferenceDefault(str(exc)) from exc\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_str", "node", "context", "none", "infer", "str", "calls", "param", "nodes", "call", "node", "str", "call", "to", "infer", "param", "context", "inferencecontext", "node", "context", "rtype", "nodes", "const", "a", "const", "containing", "an", "empty", "string", "call", "arguments", "callsite", "from_call", "node", "context", "context", "if", "call", "keyword_arguments", "raise", "useinferencedefault", "typeerror", "str", "must", "take", "no", "keyword", "arguments", "try", "return", "nodes", "const", "except", "astroidtypeerror", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "str", "exc", "from", "exc"], "doc_len": 68}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_int", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_int", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_int(node, context=None):\n    \"\"\"Infer int() calls\n\n    :param nodes.Call node: int() call to infer\n    :param context.InferenceContext: node context\n    :rtype nodes.Const: a Const containing the integer value of the int() call\n    \"\"\"\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: int() must take no keyword arguments\")\n\n    if call.positional_arguments:\n        try:\n            first_value = next(call.positional_arguments[0].infer(context=context))\n        except (InferenceError, StopIteration) as exc:\n            raise UseInferenceDefault(str(exc)) from exc\n\n        if first_value is util.Uninferable:\n            raise UseInferenceDefault\n\n        if isinstance(first_value, nodes.Const) and isinstance(\n            first_value.value, (int, str)\n        ):\n            try:\n                actual_value = int(first_value.value)\n            except ValueError:\n                return nodes.Const(0)\n            return nodes.Const(actual_value)\n\n    return nodes.Const(0)\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_int", "node", "context", "none", "infer", "int", "calls", "param", "nodes", "call", "node", "int", "call", "to", "infer", "param", "context", "inferencecontext", "node", "context", "rtype", "nodes", "const", "a", "const", "containing", "the", "integer", "value", "of", "the", "int", "call", "call", "arguments", "callsite", "from_call", "node", "context", "context", "if", "call", "keyword_arguments", "raise", "useinferencedefault", "typeerror", "int", "must", "take", "no", "keyword", "arguments", "if", "call", "positional_arguments", "try", "first_value", "next", "call", "positional_arguments", "0", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "str", "exc", "from", "exc", "if", "first_value", "is", "util", "uninferable", "raise", "useinferencedefault", "if", "isinstance", "first_value", "nodes", "const", "and", "isinstance", "first_value", "value", "int", "str", "try", "actual_value", "int", "first_value", "value", "except", "valueerror", "return", "nodes", "const", "0", "return", "nodes", "const", "actual_value", "return", "nodes", "const", "0"], "doc_len": 117}
{"doc_id": "astroid/brain/brain_builtin_inference.py::infer_dict_fromkeys", "file_path": "astroid/brain/brain_builtin_inference.py", "class_name": null, "func_name": "infer_dict_fromkeys", "text": "文件路径: astroid/brain/brain_builtin_inference.py\ndef infer_dict_fromkeys(node, context=None):\n    \"\"\"Infer dict.fromkeys\n\n    :param nodes.Call node: dict.fromkeys() call to infer\n    :param context.InferenceContext context: node context\n    :rtype nodes.Dict:\n        a Dictionary containing the values that astroid was able to infer.\n        In case the inference failed for any reason, an empty dictionary\n        will be inferred instead.\n    \"\"\"\n\n    def _build_dict_with_elements(elements):\n        new_node = nodes.Dict(\n            col_offset=node.col_offset, lineno=node.lineno, parent=node.parent\n        )\n        new_node.postinit(elements)\n        return new_node\n\n    call = arguments.CallSite.from_call(node, context=context)\n    if call.keyword_arguments:\n        raise UseInferenceDefault(\"TypeError: int() must take no keyword arguments\")\n    if len(call.positional_arguments) not in {1, 2}:\n        raise UseInferenceDefault(\n            \"TypeError: Needs between 1 and 2 positional arguments\"\n        )\n\n    default = nodes.Const(None)\n    values = call.positional_arguments[0]\n    try:\n        inferred_values = next(values.infer(context=context))\n    except (InferenceError, StopIteration):\n        return _build_dict_with_elements([])\n    if inferred_values is util.Uninferable:\n        return _build_dict_with_elements([])\n\n    # Limit to a couple of potential values, as this can become pretty complicated\n    accepted_iterable_elements = (nodes.Const,)\n    if isinstance(inferred_values, (nodes.List, nodes.Set, nodes.Tuple)):\n        elements = inferred_values.elts\n        for element in elements:\n            if not isinstance(element, accepted_iterable_elements):\n                # Fallback to an empty dict\n                return _build_dict_with_elements([])\n\n        elements_with_value = [(element, default) for element in elements]\n        return _build_dict_with_elements(elements_with_value)\n    if isinstance(inferred_values, nodes.Const) and isinstance(\n        inferred_values.value, (str, bytes)\n    ):\n        elements = [\n            (nodes.Const(element), default) for element in inferred_values.value\n        ]\n        return _build_dict_with_elements(elements)\n    if isinstance(inferred_values, nodes.Dict):\n        keys = inferred_values.itered()\n        for key in keys:\n            if not isinstance(key, accepted_iterable_elements):\n                # Fallback to an empty dict\n                return _build_dict_with_elements([])\n\n        elements_with_value = [(element, default) for element in keys]\n        return _build_dict_with_elements(elements_with_value)\n\n    # Fallback to an empty dictionary\n    return _build_dict_with_elements([])\n", "tokens": ["astroid", "brain", "brain_builtin_inference", "py", "def", "infer_dict_fromkeys", "node", "context", "none", "infer", "dict", "fromkeys", "param", "nodes", "call", "node", "dict", "fromkeys", "call", "to", "infer", "param", "context", "inferencecontext", "context", "node", "context", "rtype", "nodes", "dict", "a", "dictionary", "containing", "the", "values", "that", "astroid", "was", "able", "to", "infer", "in", "case", "the", "inference", "failed", "for", "any", "reason", "an", "empty", "dictionary", "will", "be", "inferred", "instead", "def", "_build_dict_with_elements", "elements", "new_node", "nodes", "dict", "col_offset", "node", "col_offset", "lineno", "node", "lineno", "parent", "node", "parent", "new_node", "postinit", "elements", "return", "new_node", "call", "arguments", "callsite", "from_call", "node", "context", "context", "if", "call", "keyword_arguments", "raise", "useinferencedefault", "typeerror", "int", "must", "take", "no", "keyword", "arguments", "if", "len", "call", "positional_arguments", "not", "in", "1", "2", "raise", "useinferencedefault", "typeerror", "needs", "between", "1", "and", "2", "positional", "arguments", "default", "nodes", "const", "none", "values", "call", "positional_arguments", "0", "try", "inferred_values", "next", "values", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "return", "_build_dict_with_elements", "if", "inferred_values", "is", "util", "uninferable", "return", "_build_dict_with_elements", "limit", "to", "a", "couple", "of", "potential", "values", "as", "this", "can", "become", "pretty", "complicated", "accepted_iterable_elements", "nodes", "const", "if", "isinstance", "inferred_values", "nodes", "list", "nodes", "set", "nodes", "tuple", "elements", "inferred_values", "elts", "for", "element", "in", "elements", "if", "not", "isinstance", "element", "accepted_iterable_elements", "fallback", "to", "an", "empty", "dict", "return", "_build_dict_with_elements", "elements_with_value", "element", "default", "for", "element", "in", "elements", "return", "_build_dict_with_elements", "elements_with_value", "if", "isinstance", "inferred_values", "nodes", "const", "and", "isinstance", "inferred_values", "value", "str", "bytes", "elements", "nodes", "const", "element", "default", "for", "element", "in", "inferred_values", "value", "return", "_build_dict_with_elements", "elements", "if", "isinstance", "inferred_values", "nodes", "dict", "keys", "inferred_values", "itered", "for", "key", "in", "keys", "if", "not", "isinstance", "key", "accepted_iterable_elements", "fallback", "to", "an", "empty", "dict", "return", "_build_dict_with_elements", "elements_with_value", "element", "default", "for", "element", "in", "keys", "return", "_build_dict_with_elements", "elements_with_value", "fallback", "to", "an", "empty", "dictionary", "return", "_build_dict_with_elements"], "doc_len": 259}
{"doc_id": "astroid/brain/brain_collections.py::_collections_transform", "file_path": "astroid/brain/brain_collections.py", "class_name": null, "func_name": "_collections_transform", "text": "文件路径: astroid/brain/brain_collections.py\ndef _collections_transform():\n    return parse(\n        \"\"\"\n    class defaultdict(dict):\n        default_factory = None\n        def __missing__(self, key): pass\n        def __getitem__(self, key): return default_factory\n\n    \"\"\"\n        + _deque_mock()\n        + _ordered_dict_mock()\n    )\n", "tokens": ["astroid", "brain", "brain_collections", "py", "def", "_collections_transform", "return", "parse", "class", "defaultdict", "dict", "default_factory", "none", "def", "__missing__", "self", "key", "pass", "def", "__getitem__", "self", "key", "return", "default_factory", "_deque_mock", "_ordered_dict_mock"], "doc_len": 26}
{"doc_id": "astroid/brain/brain_collections.py::_deque_mock", "file_path": "astroid/brain/brain_collections.py", "class_name": null, "func_name": "_deque_mock", "text": "文件路径: astroid/brain/brain_collections.py\ndef _deque_mock():\n    base_deque_class = \"\"\"\n    class deque(object):\n        maxlen = 0\n        def __init__(self, iterable=None, maxlen=None):\n            self.iterable = iterable or []\n        def append(self, x): pass\n        def appendleft(self, x): pass\n        def clear(self): pass\n        def count(self, x): return 0\n        def extend(self, iterable): pass\n        def extendleft(self, iterable): pass\n        def pop(self): return self.iterable[0]\n        def popleft(self): return self.iterable[0]\n        def remove(self, value): pass\n        def reverse(self): return reversed(self.iterable)\n        def rotate(self, n=1): return self\n        def __iter__(self): return self\n        def __reversed__(self): return self.iterable[::-1]\n        def __getitem__(self, index): return self.iterable[index]\n        def __setitem__(self, index, value): pass\n        def __delitem__(self, index): pass\n        def __bool__(self): return bool(self.iterable)\n        def __nonzero__(self): return bool(self.iterable)\n        def __contains__(self, o): return o in self.iterable\n        def __len__(self): return len(self.iterable)\n        def __copy__(self): return deque(self.iterable)\n        def copy(self): return deque(self.iterable)\n        def index(self, x, start=0, end=0): return 0\n        def insert(self, i, x): pass\n        def __add__(self, other): pass\n        def __iadd__(self, other): pass\n        def __mul__(self, other): pass\n        def __imul__(self, other): pass\n        def __rmul__(self, other): pass\"\"\"\n    if PY39_PLUS:\n        base_deque_class += \"\"\"\n        @classmethod\n        def __class_getitem__(self, item): return cls\"\"\"\n    return base_deque_class\n", "tokens": ["astroid", "brain", "brain_collections", "py", "def", "_deque_mock", "base_deque_class", "class", "deque", "object", "maxlen", "0", "def", "__init__", "self", "iterable", "none", "maxlen", "none", "self", "iterable", "iterable", "or", "def", "append", "self", "x", "pass", "def", "appendleft", "self", "x", "pass", "def", "clear", "self", "pass", "def", "count", "self", "x", "return", "0", "def", "extend", "self", "iterable", "pass", "def", "extendleft", "self", "iterable", "pass", "def", "pop", "self", "return", "self", "iterable", "0", "def", "popleft", "self", "return", "self", "iterable", "0", "def", "remove", "self", "value", "pass", "def", "reverse", "self", "return", "reversed", "self", "iterable", "def", "rotate", "self", "n", "1", "return", "self", "def", "__iter__", "self", "return", "self", "def", "__reversed__", "self", "return", "self", "iterable", "1", "def", "__getitem__", "self", "index", "return", "self", "iterable", "index", "def", "__setitem__", "self", "index", "value", "pass", "def", "__delitem__", "self", "index", "pass", "def", "__bool__", "self", "return", "bool", "self", "iterable", "def", "__nonzero__", "self", "return", "bool", "self", "iterable", "def", "__contains__", "self", "o", "return", "o", "in", "self", "iterable", "def", "__len__", "self", "return", "len", "self", "iterable", "def", "__copy__", "self", "return", "deque", "self", "iterable", "def", "copy", "self", "return", "deque", "self", "iterable", "def", "index", "self", "x", "start", "0", "end", "0", "return", "0", "def", "insert", "self", "i", "x", "pass", "def", "__add__", "self", "other", "pass", "def", "__iadd__", "self", "other", "pass", "def", "__mul__", "self", "other", "pass", "def", "__imul__", "self", "other", "pass", "def", "__rmul__", "self", "other", "pass", "if", "py39_plus", "base_deque_class", "classmethod", "def", "__class_getitem__", "self", "item", "return", "cls", "return", "base_deque_class"], "doc_len": 214}
{"doc_id": "astroid/brain/brain_collections.py::_ordered_dict_mock", "file_path": "astroid/brain/brain_collections.py", "class_name": null, "func_name": "_ordered_dict_mock", "text": "文件路径: astroid/brain/brain_collections.py\ndef _ordered_dict_mock():\n    base_ordered_dict_class = \"\"\"\n    class OrderedDict(dict):\n        def __reversed__(self): return self[::-1]\n        def move_to_end(self, key, last=False): pass\"\"\"\n    if PY39_PLUS:\n        base_ordered_dict_class += \"\"\"\n        @classmethod\n        def __class_getitem__(cls, item): return cls\"\"\"\n    return base_ordered_dict_class\n", "tokens": ["astroid", "brain", "brain_collections", "py", "def", "_ordered_dict_mock", "base_ordered_dict_class", "class", "ordereddict", "dict", "def", "__reversed__", "self", "return", "self", "1", "def", "move_to_end", "self", "key", "last", "false", "pass", "if", "py39_plus", "base_ordered_dict_class", "classmethod", "def", "__class_getitem__", "cls", "item", "return", "cls", "return", "base_ordered_dict_class"], "doc_len": 35}
{"doc_id": "astroid/brain/brain_collections.py::_looks_like_subscriptable", "file_path": "astroid/brain/brain_collections.py", "class_name": null, "func_name": "_looks_like_subscriptable", "text": "文件路径: astroid/brain/brain_collections.py\ndef _looks_like_subscriptable(node: ClassDef) -> bool:\n    \"\"\"\n    Returns True if the node corresponds to a ClassDef of the Collections.abc module that\n    supports subscripting\n\n    :param node: ClassDef node\n    \"\"\"\n    if node.qname().startswith(\"_collections\") or node.qname().startswith(\n        \"collections\"\n    ):\n        try:\n            node.getattr(\"__class_getitem__\")\n            return True\n        except AttributeInferenceError:\n            pass\n    return False\n", "tokens": ["astroid", "brain", "brain_collections", "py", "def", "_looks_like_subscriptable", "node", "classdef", "bool", "returns", "true", "if", "the", "node", "corresponds", "to", "a", "classdef", "of", "the", "collections", "abc", "module", "that", "supports", "subscripting", "param", "node", "classdef", "node", "if", "node", "qname", "startswith", "_collections", "or", "node", "qname", "startswith", "collections", "try", "node", "getattr", "__class_getitem__", "return", "true", "except", "attributeinferenceerror", "pass", "return", "false"], "doc_len": 51}
{"doc_id": "astroid/brain/brain_collections.py::easy_class_getitem_inference", "file_path": "astroid/brain/brain_collections.py", "class_name": null, "func_name": "easy_class_getitem_inference", "text": "文件路径: astroid/brain/brain_collections.py\ndef easy_class_getitem_inference(node, context=None):\n    # Here __class_getitem__ exists but is quite a mess to infer thus\n    # put an easy inference tip\n    func_to_add = extract_node(CLASS_GET_ITEM_TEMPLATE)\n    node.locals[\"__class_getitem__\"] = [func_to_add]\n", "tokens": ["astroid", "brain", "brain_collections", "py", "def", "easy_class_getitem_inference", "node", "context", "none", "here", "__class_getitem__", "exists", "but", "is", "quite", "a", "mess", "to", "infer", "thus", "put", "an", "easy", "inference", "tip", "func_to_add", "extract_node", "class_get_item_template", "node", "locals", "__class_getitem__", "func_to_add"], "doc_len": 32}
{"doc_id": "astroid/brain/brain_ctypes.py::enrich_ctypes_redefined_types", "file_path": "astroid/brain/brain_ctypes.py", "class_name": null, "func_name": "enrich_ctypes_redefined_types", "text": "文件路径: astroid/brain/brain_ctypes.py\ndef enrich_ctypes_redefined_types():\n    \"\"\"\n    For each ctypes redefined types, overload 'value' and '_type_' members definition.\n    Overloading 'value' is mandatory otherwise astroid cannot infer the correct type for it.\n    Overloading '_type_' is necessary because the class definition made here replaces the original\n    one, in which '_type_' member is defined. Luckily those original class definitions are very short\n    and contain only the '_type_' member definition.\n    \"\"\"\n    c_class_to_type = (\n        (\"c_byte\", \"int\", \"b\"),\n        (\"c_char\", \"bytes\", \"c\"),\n        (\"c_double\", \"float\", \"d\"),\n        (\"c_float\", \"float\", \"f\"),\n        (\"c_int\", \"int\", \"i\"),\n        (\"c_int16\", \"int\", \"h\"),\n        (\"c_int32\", \"int\", \"i\"),\n        (\"c_int64\", \"int\", \"l\"),\n        (\"c_int8\", \"int\", \"b\"),\n        (\"c_long\", \"int\", \"l\"),\n        (\"c_longdouble\", \"float\", \"g\"),\n        (\"c_longlong\", \"int\", \"l\"),\n        (\"c_short\", \"int\", \"h\"),\n        (\"c_size_t\", \"int\", \"L\"),\n        (\"c_ssize_t\", \"int\", \"l\"),\n        (\"c_ubyte\", \"int\", \"B\"),\n        (\"c_uint\", \"int\", \"I\"),\n        (\"c_uint16\", \"int\", \"H\"),\n        (\"c_uint32\", \"int\", \"I\"),\n        (\"c_uint64\", \"int\", \"L\"),\n        (\"c_uint8\", \"int\", \"B\"),\n        (\"c_ulong\", \"int\", \"L\"),\n        (\"c_ulonglong\", \"int\", \"L\"),\n        (\"c_ushort\", \"int\", \"H\"),\n        (\"c_wchar\", \"str\", \"u\"),\n    )\n\n    src = [\n        \"\"\"\nfrom _ctypes import _SimpleCData\n\nclass c_bool(_SimpleCData):\n    def __init__(self, value):\n        self.value = True\n        self._type_ = '?'\n    \"\"\"\n    ]\n\n    for c_type, builtin_type, type_code in c_class_to_type:\n        src.append(\n            f\"\"\"\nclass {c_type}(_SimpleCData):\n    def __init__(self, value):\n        self.value = {builtin_type}(value)\n        self._type_ = '{type_code}'\n        \"\"\"\n        )\n\n    return parse(\"\\n\".join(src))\n", "tokens": ["astroid", "brain", "brain_ctypes", "py", "def", "enrich_ctypes_redefined_types", "for", "each", "ctypes", "redefined", "types", "overload", "value", "and", "_type_", "members", "definition", "overloading", "value", "is", "mandatory", "otherwise", "astroid", "cannot", "infer", "the", "correct", "type", "for", "it", "overloading", "_type_", "is", "necessary", "because", "the", "class", "definition", "made", "here", "replaces", "the", "original", "one", "in", "which", "_type_", "member", "is", "defined", "luckily", "those", "original", "class", "definitions", "are", "very", "short", "and", "contain", "only", "the", "_type_", "member", "definition", "c_class_to_type", "c_byte", "int", "b", "c_char", "bytes", "c", "c_double", "float", "d", "c_float", "float", "f", "c_int", "int", "i", "c_int16", "int", "h", "c_int32", "int", "i", "c_int64", "int", "l", "c_int8", "int", "b", "c_long", "int", "l", "c_longdouble", "float", "g", "c_longlong", "int", "l", "c_short", "int", "h", "c_size_t", "int", "l", "c_ssize_t", "int", "l", "c_ubyte", "int", "b", "c_uint", "int", "i", "c_uint16", "int", "h", "c_uint32", "int", "i", "c_uint64", "int", "l", "c_uint8", "int", "b", "c_ulong", "int", "l", "c_ulonglong", "int", "l", "c_ushort", "int", "h", "c_wchar", "str", "u", "src", "from", "_ctypes", "import", "_simplecdata", "class", "c_bool", "_simplecdata", "def", "__init__", "self", "value", "self", "value", "true", "self", "_type_", "for", "c_type", "builtin_type", "type_code", "in", "c_class_to_type", "src", "append", "f", "class", "c_type", "_simplecdata", "def", "__init__", "self", "value", "self", "value", "builtin_type", "value", "self", "_type_", "type_code", "return", "parse", "n", "join", "src"], "doc_len": 186}
{"doc_id": "astroid/brain/brain_curses.py::_curses_transform", "file_path": "astroid/brain/brain_curses.py", "class_name": null, "func_name": "_curses_transform", "text": "文件路径: astroid/brain/brain_curses.py\ndef _curses_transform():\n    return parse(\n        \"\"\"\n    A_ALTCHARSET = 1\n    A_BLINK = 1\n    A_BOLD = 1\n    A_DIM = 1\n    A_INVIS = 1\n    A_ITALIC = 1\n    A_NORMAL = 1\n    A_PROTECT = 1\n    A_REVERSE = 1\n    A_STANDOUT = 1\n    A_UNDERLINE = 1\n    A_HORIZONTAL = 1\n    A_LEFT = 1\n    A_LOW = 1\n    A_RIGHT = 1\n    A_TOP = 1\n    A_VERTICAL = 1\n    A_CHARTEXT = 1\n    A_ATTRIBUTES = 1\n    A_CHARTEXT = 1\n    A_COLOR = 1\n    KEY_MIN = 1\n    KEY_BREAK = 1\n    KEY_DOWN = 1\n    KEY_UP = 1\n    KEY_LEFT = 1\n    KEY_RIGHT = 1\n    KEY_HOME = 1\n    KEY_BACKSPACE = 1\n    KEY_F0 = 1\n    KEY_Fn = 1\n    KEY_DL = 1\n    KEY_IL = 1\n    KEY_DC = 1\n    KEY_IC = 1\n    KEY_EIC = 1\n    KEY_CLEAR = 1\n    KEY_EOS = 1\n    KEY_EOL = 1\n    KEY_SF = 1\n    KEY_SR = 1\n    KEY_NPAGE = 1\n    KEY_PPAGE = 1\n    KEY_STAB = 1\n    KEY_CTAB = 1\n    KEY_CATAB = 1\n    KEY_ENTER = 1\n    KEY_SRESET = 1\n    KEY_RESET = 1\n    KEY_PRINT = 1\n    KEY_LL = 1\n    KEY_A1 = 1\n    KEY_A3 = 1\n    KEY_B2 = 1\n    KEY_C1 = 1\n    KEY_C3 = 1\n    KEY_BTAB = 1\n    KEY_BEG = 1\n    KEY_CANCEL = 1\n    KEY_CLOSE = 1\n    KEY_COMMAND = 1\n    KEY_COPY = 1\n    KEY_CREATE = 1\n    KEY_END = 1\n    KEY_EXIT = 1\n    KEY_FIND = 1\n    KEY_HELP = 1\n    KEY_MARK = 1\n    KEY_MESSAGE = 1\n    KEY_MOVE = 1\n    KEY_NEXT = 1\n    KEY_OPEN = 1\n    KEY_OPTIONS = 1\n    KEY_PREVIOUS = 1\n    KEY_REDO = 1\n    KEY_REFERENCE = 1\n    KEY_REFRESH = 1\n    KEY_REPLACE = 1\n    KEY_RESTART = 1\n    KEY_RESUME = 1\n    KEY_SAVE = 1\n    KEY_SBEG = 1\n    KEY_SCANCEL = 1\n    KEY_SCOMMAND = 1\n    KEY_SCOPY = 1\n    KEY_SCREATE = 1\n    KEY_SDC = 1\n    KEY_SDL = 1\n    KEY_SELECT = 1\n    KEY_SEND = 1\n    KEY_SEOL = 1\n    KEY_SEXIT = 1\n    KEY_SFIND = 1\n    KEY_SHELP = 1\n    KEY_SHOME = 1\n    KEY_SIC = 1\n    KEY_SLEFT = 1\n    KEY_SMESSAGE = 1\n    KEY_SMOVE = 1\n    KEY_SNEXT = 1\n    KEY_SOPTIONS = 1\n    KEY_SPREVIOUS = 1\n    KEY_SPRINT = 1\n    KEY_SREDO = 1\n    KEY_SREPLACE = 1\n    KEY_SRIGHT = 1\n    KEY_SRSUME = 1\n    KEY_SSAVE = 1\n    KEY_SSUSPEND = 1\n    KEY_SUNDO = 1\n    KEY_SUSPEND = 1\n    KEY_UNDO = 1\n    KEY_MOUSE = 1\n    KEY_RESIZE = 1\n    KEY_MAX = 1\n    ACS_BBSS = 1\n    ACS_BLOCK = 1\n    ACS_BOARD = 1\n    ACS_BSBS = 1\n    ACS_BSSB = 1\n    ACS_BSSS = 1\n    ACS_BTEE = 1\n    ACS_BULLET = 1\n    ACS_CKBOARD = 1\n    ACS_DARROW = 1\n    ACS_DEGREE = 1\n    ACS_DIAMOND = 1\n    ACS_GEQUAL = 1\n    ACS_HLINE = 1\n    ACS_LANTERN = 1\n    ACS_LARROW = 1\n    ACS_LEQUAL = 1\n    ACS_LLCORNER = 1\n    ACS_LRCORNER = 1\n    ACS_LTEE = 1\n    ACS_NEQUAL = 1\n    ACS_PI = 1\n    ACS_PLMINUS = 1\n    ACS_PLUS = 1\n    ACS_RARROW = 1\n    ACS_RTEE = 1\n    ACS_S1 = 1\n    ACS_S3 = 1\n    ACS_S7 = 1\n    ACS_S9 = 1\n    ACS_SBBS = 1\n    ACS_SBSB = 1\n    ACS_SBSS = 1\n    ACS_SSBB = 1\n    ACS_SSBS = 1\n    ACS_SSSB = 1\n    ACS_SSSS = 1\n    ACS_STERLING = 1\n    ACS_TTEE = 1\n    ACS_UARROW = 1\n    ACS_ULCORNER = 1\n    ACS_URCORNER = 1\n    ACS_VLINE = 1\n    COLOR_BLACK = 1\n    COLOR_BLUE = 1\n    COLOR_CYAN = 1\n    COLOR_GREEN = 1\n    COLOR_MAGENTA = 1\n    COLOR_RED = 1\n    COLOR_WHITE = 1\n    COLOR_YELLOW = 1\n        \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_curses", "py", "def", "_curses_transform", "return", "parse", "a_altcharset", "1", "a_blink", "1", "a_bold", "1", "a_dim", "1", "a_invis", "1", "a_italic", "1", "a_normal", "1", "a_protect", "1", "a_reverse", "1", "a_standout", "1", "a_underline", "1", "a_horizontal", "1", "a_left", "1", "a_low", "1", "a_right", "1", "a_top", "1", "a_vertical", "1", "a_chartext", "1", "a_attributes", "1", "a_chartext", "1", "a_color", "1", "key_min", "1", "key_break", "1", "key_down", "1", "key_up", "1", "key_left", "1", "key_right", "1", "key_home", "1", "key_backspace", "1", "key_f0", "1", "key_fn", "1", "key_dl", "1", "key_il", "1", "key_dc", "1", "key_ic", "1", "key_eic", "1", "key_clear", "1", "key_eos", "1", "key_eol", "1", "key_sf", "1", "key_sr", "1", "key_npage", "1", "key_ppage", "1", "key_stab", "1", "key_ctab", "1", "key_catab", "1", "key_enter", "1", "key_sreset", "1", "key_reset", "1", "key_print", "1", "key_ll", "1", "key_a1", "1", "key_a3", "1", "key_b2", "1", "key_c1", "1", "key_c3", "1", "key_btab", "1", "key_beg", "1", "key_cancel", "1", "key_close", "1", "key_command", "1", "key_copy", "1", "key_create", "1", "key_end", "1", "key_exit", "1", "key_find", "1", "key_help", "1", "key_mark", "1", "key_message", "1", "key_move", "1", "key_next", "1", "key_open", "1", "key_options", "1", "key_previous", "1", "key_redo", "1", "key_reference", "1", "key_refresh", "1", "key_replace", "1", "key_restart", "1", "key_resume", "1", "key_save", "1", "key_sbeg", "1", "key_scancel", "1", "key_scommand", "1", "key_scopy", "1", "key_screate", "1", "key_sdc", "1", "key_sdl", "1", "key_select", "1", "key_send", "1", "key_seol", "1", "key_sexit", "1", "key_sfind", "1", "key_shelp", "1", "key_shome", "1", "key_sic", "1", "key_sleft", "1", "key_smessage", "1", "key_smove", "1", "key_snext", "1", "key_soptions", "1", "key_sprevious", "1", "key_sprint", "1", "key_sredo", "1", "key_sreplace", "1", "key_sright", "1", "key_srsume", "1", "key_ssave", "1", "key_ssuspend", "1", "key_sundo", "1", "key_suspend", "1", "key_undo", "1", "key_mouse", "1", "key_resize", "1", "key_max", "1", "acs_bbss", "1", "acs_block", "1", "acs_board", "1", "acs_bsbs", "1", "acs_bssb", "1", "acs_bsss", "1", "acs_btee", "1", "acs_bullet", "1", "acs_ckboard", "1", "acs_darrow", "1", "acs_degree", "1", "acs_diamond", "1", "acs_gequal", "1", "acs_hline", "1", "acs_lantern", "1", "acs_larrow", "1", "acs_lequal", "1", "acs_llcorner", "1", "acs_lrcorner", "1", "acs_ltee", "1", "acs_nequal", "1", "acs_pi", "1", "acs_plminus", "1", "acs_plus", "1", "acs_rarrow", "1", "acs_rtee", "1", "acs_s1", "1", "acs_s3", "1", "acs_s7", "1", "acs_s9", "1", "acs_sbbs", "1", "acs_sbsb", "1", "acs_sbss", "1", "acs_ssbb", "1", "acs_ssbs", "1", "acs_sssb", "1", "acs_ssss", "1", "acs_sterling", "1", "acs_ttee", "1", "acs_uarrow", "1", "acs_ulcorner", "1", "acs_urcorner", "1", "acs_vline", "1", "color_black", "1", "color_blue", "1", "color_cyan", "1", "color_green", "1", "color_magenta", "1", "color_red", "1", "color_white", "1", "color_yellow", "1"], "doc_len": 340}
{"doc_id": "astroid/brain/brain_dataclasses.py::is_decorated_with_dataclass", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "is_decorated_with_dataclass", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef is_decorated_with_dataclass(node, decorator_names=DATACLASSES_DECORATORS):\n    \"\"\"Return True if a decorated node has a `dataclass` decorator applied.\"\"\"\n    if not isinstance(node, ClassDef) or not node.decorators:\n        return False\n\n    return any(\n        _looks_like_dataclass_decorator(decorator_attribute, decorator_names)\n        for decorator_attribute in node.decorators.nodes\n    )\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "is_decorated_with_dataclass", "node", "decorator_names", "dataclasses_decorators", "return", "true", "if", "a", "decorated", "node", "has", "a", "dataclass", "decorator", "applied", "if", "not", "isinstance", "node", "classdef", "or", "not", "node", "decorators", "return", "false", "return", "any", "_looks_like_dataclass_decorator", "decorator_attribute", "decorator_names", "for", "decorator_attribute", "in", "node", "decorators", "nodes"], "doc_len": 42}
{"doc_id": "astroid/brain/brain_dataclasses.py::dataclass_transform", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "dataclass_transform", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef dataclass_transform(node: ClassDef) -> None:\n    \"\"\"Rewrite a dataclass to be easily understood by pylint\"\"\"\n\n    for assign_node in _get_dataclass_attributes(node):\n        name = assign_node.target.name\n\n        rhs_node = Unknown(\n            lineno=assign_node.lineno,\n            col_offset=assign_node.col_offset,\n            parent=assign_node,\n        )\n        rhs_node = AstroidManager().visit_transforms(rhs_node)\n        node.instance_attrs[name] = [rhs_node]\n\n    if not _check_generate_dataclass_init(node):\n        return\n\n    try:\n        reversed_mro = list(reversed(node.mro()))\n    except MroError:\n        reversed_mro = [node]\n\n    field_assigns = {}\n    field_order = []\n    for klass in (k for k in reversed_mro if is_decorated_with_dataclass(k)):\n        for assign_node in _get_dataclass_attributes(klass, init=True):\n            name = assign_node.target.name\n            if name not in field_assigns:\n                field_order.append(name)\n            field_assigns[name] = assign_node\n\n    init_str = _generate_dataclass_init([field_assigns[name] for name in field_order])\n    try:\n        init_node = parse(init_str)[\"__init__\"]\n    except AstroidSyntaxError:\n        pass\n    else:\n        init_node.parent = node\n        init_node.lineno, init_node.col_offset = None, None\n        node.locals[\"__init__\"] = [init_node]\n\n        root = node.root()\n        if DEFAULT_FACTORY not in root.locals:\n            new_assign = parse(f\"{DEFAULT_FACTORY} = object()\").body[0]\n            new_assign.parent = root\n            root.locals[DEFAULT_FACTORY] = [new_assign.targets[0]]\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "dataclass_transform", "node", "classdef", "none", "rewrite", "a", "dataclass", "to", "be", "easily", "understood", "by", "pylint", "for", "assign_node", "in", "_get_dataclass_attributes", "node", "name", "assign_node", "target", "name", "rhs_node", "unknown", "lineno", "assign_node", "lineno", "col_offset", "assign_node", "col_offset", "parent", "assign_node", "rhs_node", "astroidmanager", "visit_transforms", "rhs_node", "node", "instance_attrs", "name", "rhs_node", "if", "not", "_check_generate_dataclass_init", "node", "return", "try", "reversed_mro", "list", "reversed", "node", "mro", "except", "mroerror", "reversed_mro", "node", "field_assigns", "field_order", "for", "klass", "in", "k", "for", "k", "in", "reversed_mro", "if", "is_decorated_with_dataclass", "k", "for", "assign_node", "in", "_get_dataclass_attributes", "klass", "init", "true", "name", "assign_node", "target", "name", "if", "name", "not", "in", "field_assigns", "field_order", "append", "name", "field_assigns", "name", "assign_node", "init_str", "_generate_dataclass_init", "field_assigns", "name", "for", "name", "in", "field_order", "try", "init_node", "parse", "init_str", "__init__", "except", "astroidsyntaxerror", "pass", "else", "init_node", "parent", "node", "init_node", "lineno", "init_node", "col_offset", "none", "none", "node", "locals", "__init__", "init_node", "root", "node", "root", "if", "default_factory", "not", "in", "root", "locals", "new_assign", "parse", "f", "default_factory", "object", "body", "0", "new_assign", "parent", "root", "root", "locals", "default_factory", "new_assign", "targets", "0"], "doc_len": 150}
{"doc_id": "astroid/brain/brain_dataclasses.py::_get_dataclass_attributes", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_get_dataclass_attributes", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _get_dataclass_attributes(node: ClassDef, init: bool = False) -> Generator:\n    \"\"\"Yield the AnnAssign nodes of dataclass attributes for the node.\n\n    If init is True, also include InitVars, but exclude attributes from calls to\n    field where init=False.\n    \"\"\"\n    for assign_node in node.body:\n        if not isinstance(assign_node, AnnAssign) or not isinstance(\n            assign_node.target, AssignName\n        ):\n            continue\n\n        if _is_class_var(assign_node.annotation):  # type: ignore[arg-type] # annotation is never None\n            continue\n\n        if init:\n            value = assign_node.value\n            if (\n                isinstance(value, Call)\n                and _looks_like_dataclass_field_call(value, check_scope=False)\n                and any(\n                    keyword.arg == \"init\"\n                    and not keyword.value.bool_value()  # type: ignore[union-attr] # value is never None\n                    for keyword in value.keywords\n                )\n            ):\n                continue\n        elif _is_init_var(assign_node.annotation):  # type: ignore[arg-type] # annotation is never None\n            continue\n\n        yield assign_node\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_get_dataclass_attributes", "node", "classdef", "init", "bool", "false", "generator", "yield", "the", "annassign", "nodes", "of", "dataclass", "attributes", "for", "the", "node", "if", "init", "is", "true", "also", "include", "initvars", "but", "exclude", "attributes", "from", "calls", "to", "field", "where", "init", "false", "for", "assign_node", "in", "node", "body", "if", "not", "isinstance", "assign_node", "annassign", "or", "not", "isinstance", "assign_node", "target", "assignname", "continue", "if", "_is_class_var", "assign_node", "annotation", "type", "ignore", "arg", "type", "annotation", "is", "never", "none", "continue", "if", "init", "value", "assign_node", "value", "if", "isinstance", "value", "call", "and", "_looks_like_dataclass_field_call", "value", "check_scope", "false", "and", "any", "keyword", "arg", "init", "and", "not", "keyword", "value", "bool_value", "type", "ignore", "union", "attr", "value", "is", "never", "none", "for", "keyword", "in", "value", "keywords", "continue", "elif", "_is_init_var", "assign_node", "annotation", "type", "ignore", "arg", "type", "annotation", "is", "never", "none", "continue", "yield", "assign_node"], "doc_len": 122}
{"doc_id": "astroid/brain/brain_dataclasses.py::_check_generate_dataclass_init", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_check_generate_dataclass_init", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _check_generate_dataclass_init(node: ClassDef) -> bool:\n    \"\"\"Return True if we should generate an __init__ method for node.\n\n    This is True when:\n        - node doesn't define its own __init__ method\n        - the dataclass decorator was called *without* the keyword argument init=False\n    \"\"\"\n    if \"__init__\" in node.locals:\n        return False\n\n    found = None\n\n    for decorator_attribute in node.decorators.nodes:\n        if not isinstance(decorator_attribute, Call):\n            continue\n\n        if _looks_like_dataclass_decorator(decorator_attribute):\n            found = decorator_attribute\n\n    if found is None:\n        return True\n\n    # Check for keyword arguments of the form init=False\n    return all(\n        keyword.arg != \"init\"\n        and keyword.value.bool_value()  # type: ignore[union-attr] # value is never None\n        for keyword in found.keywords\n    )\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_check_generate_dataclass_init", "node", "classdef", "bool", "return", "true", "if", "we", "should", "generate", "an", "__init__", "method", "for", "node", "this", "is", "true", "when", "node", "doesn", "t", "define", "its", "own", "__init__", "method", "the", "dataclass", "decorator", "was", "called", "without", "the", "keyword", "argument", "init", "false", "if", "__init__", "in", "node", "locals", "return", "false", "found", "none", "for", "decorator_attribute", "in", "node", "decorators", "nodes", "if", "not", "isinstance", "decorator_attribute", "call", "continue", "if", "_looks_like_dataclass_decorator", "decorator_attribute", "found", "decorator_attribute", "if", "found", "is", "none", "return", "true", "check", "for", "keyword", "arguments", "of", "the", "form", "init", "false", "return", "all", "keyword", "arg", "init", "and", "keyword", "value", "bool_value", "type", "ignore", "union", "attr", "value", "is", "never", "none", "for", "keyword", "in", "found", "keywords"], "doc_len": 106}
{"doc_id": "astroid/brain/brain_dataclasses.py::_generate_dataclass_init", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_generate_dataclass_init", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _generate_dataclass_init(assigns: List[AnnAssign]) -> str:\n    \"\"\"Return an init method for a dataclass given the targets.\"\"\"\n    target_names = []\n    params = []\n    assignments = []\n\n    for assign in assigns:\n        name, annotation, value = assign.target.name, assign.annotation, assign.value\n        target_names.append(name)\n\n        if _is_init_var(annotation):  # type: ignore[arg-type] # annotation is never None\n            init_var = True\n            if isinstance(annotation, Subscript):\n                annotation = annotation.slice\n            else:\n                # Cannot determine type annotation for parameter from InitVar\n                annotation = None\n            assignment_str = \"\"\n        else:\n            init_var = False\n            assignment_str = f\"self.{name} = {name}\"\n\n        if annotation:\n            param_str = f\"{name}: {annotation.as_string()}\"\n        else:\n            param_str = name\n\n        if value:\n            if isinstance(value, Call) and _looks_like_dataclass_field_call(\n                value, check_scope=False\n            ):\n                result = _get_field_default(value)\n                if result:\n                    default_type, default_node = result\n                    if default_type == \"default\":\n                        param_str += f\" = {default_node.as_string()}\"\n                    elif default_type == \"default_factory\":\n                        param_str += f\" = {DEFAULT_FACTORY}\"\n                        assignment_str = (\n                            f\"self.{name} = {default_node.as_string()} \"\n                            f\"if {name} is {DEFAULT_FACTORY} else {name}\"\n                        )\n            else:\n                param_str += f\" = {value.as_string()}\"\n\n        params.append(param_str)\n        if not init_var:\n            assignments.append(assignment_str)\n\n    params_string = \", \".join([\"self\"] + params)\n    assignments_string = \"\\n    \".join(assignments) if assignments else \"pass\"\n    return f\"def __init__({params_string}) -> None:\\n    {assignments_string}\"\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_generate_dataclass_init", "assigns", "list", "annassign", "str", "return", "an", "init", "method", "for", "a", "dataclass", "given", "the", "targets", "target_names", "params", "assignments", "for", "assign", "in", "assigns", "name", "annotation", "value", "assign", "target", "name", "assign", "annotation", "assign", "value", "target_names", "append", "name", "if", "_is_init_var", "annotation", "type", "ignore", "arg", "type", "annotation", "is", "never", "none", "init_var", "true", "if", "isinstance", "annotation", "subscript", "annotation", "annotation", "slice", "else", "cannot", "determine", "type", "annotation", "for", "parameter", "from", "initvar", "annotation", "none", "assignment_str", "else", "init_var", "false", "assignment_str", "f", "self", "name", "name", "if", "annotation", "param_str", "f", "name", "annotation", "as_string", "else", "param_str", "name", "if", "value", "if", "isinstance", "value", "call", "and", "_looks_like_dataclass_field_call", "value", "check_scope", "false", "result", "_get_field_default", "value", "if", "result", "default_type", "default_node", "result", "if", "default_type", "default", "param_str", "f", "default_node", "as_string", "elif", "default_type", "default_factory", "param_str", "f", "default_factory", "assignment_str", "f", "self", "name", "default_node", "as_string", "f", "if", "name", "is", "default_factory", "else", "name", "else", "param_str", "f", "value", "as_string", "params", "append", "param_str", "if", "not", "init_var", "assignments", "append", "assignment_str", "params_string", "join", "self", "params", "assignments_string", "n", "join", "assignments", "if", "assignments", "else", "pass", "return", "f", "def", "__init__", "params_string", "none", "n", "assignments_string"], "doc_len": 169}
{"doc_id": "astroid/brain/brain_dataclasses.py::infer_dataclass_attribute", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "infer_dataclass_attribute", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef infer_dataclass_attribute(\n    node: Unknown, ctx: Optional[context.InferenceContext] = None\n) -> Generator:\n    \"\"\"Inference tip for an Unknown node that was dynamically generated to\n    represent a dataclass attribute.\n\n    In the case that a default value is provided, that is inferred first.\n    Then, an Instance of the annotated class is yielded.\n    \"\"\"\n    assign = node.parent\n    if not isinstance(assign, AnnAssign):\n        yield Uninferable\n        return\n\n    annotation, value = assign.annotation, assign.value\n    if value is not None:\n        yield from value.infer(context=ctx)\n    if annotation is not None:\n        yield from _infer_instance_from_annotation(annotation, ctx=ctx)\n    else:\n        yield Uninferable\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "infer_dataclass_attribute", "node", "unknown", "ctx", "optional", "context", "inferencecontext", "none", "generator", "inference", "tip", "for", "an", "unknown", "node", "that", "was", "dynamically", "generated", "to", "represent", "a", "dataclass", "attribute", "in", "the", "case", "that", "a", "default", "value", "is", "provided", "that", "is", "inferred", "first", "then", "an", "instance", "of", "the", "annotated", "class", "is", "yielded", "assign", "node", "parent", "if", "not", "isinstance", "assign", "annassign", "yield", "uninferable", "return", "annotation", "value", "assign", "annotation", "assign", "value", "if", "value", "is", "not", "none", "yield", "from", "value", "infer", "context", "ctx", "if", "annotation", "is", "not", "none", "yield", "from", "_infer_instance_from_annotation", "annotation", "ctx", "ctx", "else", "yield", "uninferable"], "doc_len": 93}
{"doc_id": "astroid/brain/brain_dataclasses.py::infer_dataclass_field_call", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "infer_dataclass_field_call", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef infer_dataclass_field_call(\n    node: Call, ctx: Optional[context.InferenceContext] = None\n) -> Generator:\n    \"\"\"Inference tip for dataclass field calls.\"\"\"\n    if not isinstance(node.parent, (AnnAssign, Assign)):\n        raise UseInferenceDefault\n    result = _get_field_default(node)\n    if not result:\n        yield Uninferable\n    else:\n        default_type, default = result\n        if default_type == \"default\":\n            yield from default.infer(context=ctx)\n        else:\n            new_call = parse(default.as_string()).body[0].value\n            new_call.parent = node.parent\n            yield from new_call.infer(context=ctx)\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "infer_dataclass_field_call", "node", "call", "ctx", "optional", "context", "inferencecontext", "none", "generator", "inference", "tip", "for", "dataclass", "field", "calls", "if", "not", "isinstance", "node", "parent", "annassign", "assign", "raise", "useinferencedefault", "result", "_get_field_default", "node", "if", "not", "result", "yield", "uninferable", "else", "default_type", "default", "result", "if", "default_type", "default", "yield", "from", "default", "infer", "context", "ctx", "else", "new_call", "parse", "default", "as_string", "body", "0", "value", "new_call", "parent", "node", "parent", "yield", "from", "new_call", "infer", "context", "ctx"], "doc_len": 68}
{"doc_id": "astroid/brain/brain_dataclasses.py::_looks_like_dataclass_decorator", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_looks_like_dataclass_decorator", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _looks_like_dataclass_decorator(\n    node: NodeNG, decorator_names: FrozenSet[str] = DATACLASSES_DECORATORS\n) -> bool:\n    \"\"\"Return True if node looks like a dataclass decorator.\n\n    Uses inference to lookup the value of the node, and if that fails,\n    matches against specific names.\n    \"\"\"\n    if isinstance(node, Call):  # decorator with arguments\n        node = node.func\n    try:\n        inferred = next(node.infer())\n    except (InferenceError, StopIteration):\n        inferred = Uninferable\n\n    if inferred is Uninferable:\n        if isinstance(node, Name):\n            return node.name in decorator_names\n        if isinstance(node, Attribute):\n            return node.attrname in decorator_names\n\n        return False\n\n    return (\n        isinstance(inferred, FunctionDef)\n        and inferred.name in decorator_names\n        and inferred.root().name in DATACLASS_MODULES\n    )\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_looks_like_dataclass_decorator", "node", "nodeng", "decorator_names", "frozenset", "str", "dataclasses_decorators", "bool", "return", "true", "if", "node", "looks", "like", "a", "dataclass", "decorator", "uses", "inference", "to", "lookup", "the", "value", "of", "the", "node", "and", "if", "that", "fails", "matches", "against", "specific", "names", "if", "isinstance", "node", "call", "decorator", "with", "arguments", "node", "node", "func", "try", "inferred", "next", "node", "infer", "except", "inferenceerror", "stopiteration", "inferred", "uninferable", "if", "inferred", "is", "uninferable", "if", "isinstance", "node", "name", "return", "node", "name", "in", "decorator_names", "if", "isinstance", "node", "attribute", "return", "node", "attrname", "in", "decorator_names", "return", "false", "return", "isinstance", "inferred", "functiondef", "and", "inferred", "name", "in", "decorator_names", "and", "inferred", "root", "name", "in", "dataclass_modules"], "doc_len": 98}
{"doc_id": "astroid/brain/brain_dataclasses.py::_looks_like_dataclass_attribute", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_looks_like_dataclass_attribute", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _looks_like_dataclass_attribute(node: Unknown) -> bool:\n    \"\"\"Return True if node was dynamically generated as the child of an AnnAssign\n    statement.\n    \"\"\"\n    parent = node.parent\n    if not parent:\n        return False\n\n    scope = parent.scope()\n    return (\n        isinstance(parent, AnnAssign)\n        and isinstance(scope, ClassDef)\n        and is_decorated_with_dataclass(scope)\n    )\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_looks_like_dataclass_attribute", "node", "unknown", "bool", "return", "true", "if", "node", "was", "dynamically", "generated", "as", "the", "child", "of", "an", "annassign", "statement", "parent", "node", "parent", "if", "not", "parent", "return", "false", "scope", "parent", "scope", "return", "isinstance", "parent", "annassign", "and", "isinstance", "scope", "classdef", "and", "is_decorated_with_dataclass", "scope"], "doc_len": 45}
{"doc_id": "astroid/brain/brain_dataclasses.py::_looks_like_dataclass_field_call", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_looks_like_dataclass_field_call", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _looks_like_dataclass_field_call(node: Call, check_scope: bool = True) -> bool:\n    \"\"\"Return True if node is calling dataclasses field or Field\n    from an AnnAssign statement directly in the body of a ClassDef.\n\n    If check_scope is False, skips checking the statement and body.\n    \"\"\"\n    if check_scope:\n        stmt = node.statement(future=True)\n        scope = stmt.scope()\n        if not (\n            isinstance(stmt, AnnAssign)\n            and stmt.value is not None\n            and isinstance(scope, ClassDef)\n            and is_decorated_with_dataclass(scope)\n        ):\n            return False\n\n    try:\n        inferred = next(node.func.infer())\n    except (InferenceError, StopIteration):\n        return False\n\n    if not isinstance(inferred, FunctionDef):\n        return False\n\n    return inferred.name == FIELD_NAME and inferred.root().name in DATACLASS_MODULES\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_looks_like_dataclass_field_call", "node", "call", "check_scope", "bool", "true", "bool", "return", "true", "if", "node", "is", "calling", "dataclasses", "field", "or", "field", "from", "an", "annassign", "statement", "directly", "in", "the", "body", "of", "a", "classdef", "if", "check_scope", "is", "false", "skips", "checking", "the", "statement", "and", "body", "if", "check_scope", "stmt", "node", "statement", "future", "true", "scope", "stmt", "scope", "if", "not", "isinstance", "stmt", "annassign", "and", "stmt", "value", "is", "not", "none", "and", "isinstance", "scope", "classdef", "and", "is_decorated_with_dataclass", "scope", "return", "false", "try", "inferred", "next", "node", "func", "infer", "except", "inferenceerror", "stopiteration", "return", "false", "if", "not", "isinstance", "inferred", "functiondef", "return", "false", "return", "inferred", "name", "field_name", "and", "inferred", "root", "name", "in", "dataclass_modules"], "doc_len": 101}
{"doc_id": "astroid/brain/brain_dataclasses.py::_get_field_default", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_get_field_default", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _get_field_default(field_call: Call) -> _FieldDefaultReturn:\n    \"\"\"Return a the default value of a field call, and the corresponding keyword argument name.\n\n    field(default=...) results in the ... node\n    field(default_factory=...) results in a Call node with func ... and no arguments\n\n    If neither or both arguments are present, return (\"\", None) instead,\n    indicating that there is not a valid default value.\n    \"\"\"\n    default, default_factory = None, None\n    for keyword in field_call.keywords:\n        if keyword.arg == \"default\":\n            default = keyword.value\n        elif keyword.arg == \"default_factory\":\n            default_factory = keyword.value\n\n    if default is not None and default_factory is None:\n        return \"default\", default\n\n    if default is None and default_factory is not None:\n        new_call = Call(\n            lineno=field_call.lineno,\n            col_offset=field_call.col_offset,\n            parent=field_call.parent,\n        )\n        new_call.postinit(func=default_factory)\n        return \"default_factory\", new_call\n\n    return None\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_get_field_default", "field_call", "call", "_fielddefaultreturn", "return", "a", "the", "default", "value", "of", "a", "field", "call", "and", "the", "corresponding", "keyword", "argument", "name", "field", "default", "results", "in", "the", "node", "field", "default_factory", "results", "in", "a", "call", "node", "with", "func", "and", "no", "arguments", "if", "neither", "or", "both", "arguments", "are", "present", "return", "none", "instead", "indicating", "that", "there", "is", "not", "a", "valid", "default", "value", "default", "default_factory", "none", "none", "for", "keyword", "in", "field_call", "keywords", "if", "keyword", "arg", "default", "default", "keyword", "value", "elif", "keyword", "arg", "default_factory", "default_factory", "keyword", "value", "if", "default", "is", "not", "none", "and", "default_factory", "is", "none", "return", "default", "default", "if", "default", "is", "none", "and", "default_factory", "is", "not", "none", "new_call", "call", "lineno", "field_call", "lineno", "col_offset", "field_call", "col_offset", "parent", "field_call", "parent", "new_call", "postinit", "func", "default_factory", "return", "default_factory", "new_call", "return", "none"], "doc_len": 125}
{"doc_id": "astroid/brain/brain_dataclasses.py::_is_class_var", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_is_class_var", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _is_class_var(node: NodeNG) -> bool:\n    \"\"\"Return True if node is a ClassVar, with or without subscripting.\"\"\"\n    if PY39_PLUS:\n        try:\n            inferred = next(node.infer())\n        except (InferenceError, StopIteration):\n            return False\n\n        return getattr(inferred, \"name\", \"\") == \"ClassVar\"\n\n    # Before Python 3.9, inference returns typing._SpecialForm instead of ClassVar.\n    # Our backup is to inspect the node's structure.\n    return isinstance(node, Subscript) and (\n        isinstance(node.value, Name)\n        and node.value.name == \"ClassVar\"\n        or isinstance(node.value, Attribute)\n        and node.value.attrname == \"ClassVar\"\n    )\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_is_class_var", "node", "nodeng", "bool", "return", "true", "if", "node", "is", "a", "classvar", "with", "or", "without", "subscripting", "if", "py39_plus", "try", "inferred", "next", "node", "infer", "except", "inferenceerror", "stopiteration", "return", "false", "return", "getattr", "inferred", "name", "classvar", "before", "python", "3", "9", "inference", "returns", "typing", "_specialform", "instead", "of", "classvar", "our", "backup", "is", "to", "inspect", "the", "node", "s", "structure", "return", "isinstance", "node", "subscript", "and", "isinstance", "node", "value", "name", "and", "node", "value", "name", "classvar", "or", "isinstance", "node", "value", "attribute", "and", "node", "value", "attrname", "classvar"], "doc_len": 81}
{"doc_id": "astroid/brain/brain_dataclasses.py::_is_init_var", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_is_init_var", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _is_init_var(node: NodeNG) -> bool:\n    \"\"\"Return True if node is an InitVar, with or without subscripting.\"\"\"\n    try:\n        inferred = next(node.infer())\n    except (InferenceError, StopIteration):\n        return False\n\n    return getattr(inferred, \"name\", \"\") == \"InitVar\"\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_is_init_var", "node", "nodeng", "bool", "return", "true", "if", "node", "is", "an", "initvar", "with", "or", "without", "subscripting", "try", "inferred", "next", "node", "infer", "except", "inferenceerror", "stopiteration", "return", "false", "return", "getattr", "inferred", "name", "initvar"], "doc_len": 35}
{"doc_id": "astroid/brain/brain_dataclasses.py::_infer_instance_from_annotation", "file_path": "astroid/brain/brain_dataclasses.py", "class_name": null, "func_name": "_infer_instance_from_annotation", "text": "文件路径: astroid/brain/brain_dataclasses.py\ndef _infer_instance_from_annotation(\n    node: NodeNG, ctx: Optional[context.InferenceContext] = None\n) -> Generator:\n    \"\"\"Infer an instance corresponding to the type annotation represented by node.\n\n    Currently has limited support for the typing module.\n    \"\"\"\n    klass = None\n    try:\n        klass = next(node.infer(context=ctx))\n    except (InferenceError, StopIteration):\n        yield Uninferable\n    if not isinstance(klass, ClassDef):\n        yield Uninferable\n    elif klass.root().name in {\n        \"typing\",\n        \"_collections_abc\",\n        \"\",\n    }:  # \"\" because of synthetic nodes in brain_typing.py\n        if klass.name in _INFERABLE_TYPING_TYPES:\n            yield klass.instantiate_class()\n        else:\n            yield Uninferable\n    else:\n        yield klass.instantiate_class()\n", "tokens": ["astroid", "brain", "brain_dataclasses", "py", "def", "_infer_instance_from_annotation", "node", "nodeng", "ctx", "optional", "context", "inferencecontext", "none", "generator", "infer", "an", "instance", "corresponding", "to", "the", "type", "annotation", "represented", "by", "node", "currently", "has", "limited", "support", "for", "the", "typing", "module", "klass", "none", "try", "klass", "next", "node", "infer", "context", "ctx", "except", "inferenceerror", "stopiteration", "yield", "uninferable", "if", "not", "isinstance", "klass", "classdef", "yield", "uninferable", "elif", "klass", "root", "name", "in", "typing", "_collections_abc", "because", "of", "synthetic", "nodes", "in", "brain_typing", "py", "if", "klass", "name", "in", "_inferable_typing_types", "yield", "klass", "instantiate_class", "else", "yield", "uninferable", "else", "yield", "klass", "instantiate_class"], "doc_len": 83}
{"doc_id": "astroid/brain/brain_dateutil.py::dateutil_transform", "file_path": "astroid/brain/brain_dateutil.py", "class_name": null, "func_name": "dateutil_transform", "text": "文件路径: astroid/brain/brain_dateutil.py\ndef dateutil_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        textwrap.dedent(\n            \"\"\"\n    import datetime\n    def parse(timestr, parserinfo=None, **kwargs):\n        return datetime.datetime()\n    \"\"\"\n        )\n    )\n", "tokens": ["astroid", "brain", "brain_dateutil", "py", "def", "dateutil_transform", "return", "astroidbuilder", "astroidmanager", "string_build", "textwrap", "dedent", "import", "datetime", "def", "parse", "timestr", "parserinfo", "none", "kwargs", "return", "datetime", "datetime"], "doc_len": 23}
{"doc_id": "astroid/brain/brain_fstrings.py::_clone_node_with_lineno", "file_path": "astroid/brain/brain_fstrings.py", "class_name": null, "func_name": "_clone_node_with_lineno", "text": "文件路径: astroid/brain/brain_fstrings.py\ndef _clone_node_with_lineno(node, parent, lineno):\n    cls = node.__class__\n    other_fields = node._other_fields\n    _astroid_fields = node._astroid_fields\n    init_params = {\"lineno\": lineno, \"col_offset\": node.col_offset, \"parent\": parent}\n    postinit_params = {param: getattr(node, param) for param in _astroid_fields}\n    if other_fields:\n        init_params.update({param: getattr(node, param) for param in other_fields})\n    new_node = cls(**init_params)\n    if hasattr(node, \"postinit\") and _astroid_fields:\n        for param, child in postinit_params.items():\n            if child and not isinstance(child, collections.abc.Sequence):\n                cloned_child = _clone_node_with_lineno(\n                    node=child, lineno=new_node.lineno, parent=new_node\n                )\n                postinit_params[param] = cloned_child\n        new_node.postinit(**postinit_params)\n    return new_node\n", "tokens": ["astroid", "brain", "brain_fstrings", "py", "def", "_clone_node_with_lineno", "node", "parent", "lineno", "cls", "node", "__class__", "other_fields", "node", "_other_fields", "_astroid_fields", "node", "_astroid_fields", "init_params", "lineno", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "postinit_params", "param", "getattr", "node", "param", "for", "param", "in", "_astroid_fields", "if", "other_fields", "init_params", "update", "param", "getattr", "node", "param", "for", "param", "in", "other_fields", "new_node", "cls", "init_params", "if", "hasattr", "node", "postinit", "and", "_astroid_fields", "for", "param", "child", "in", "postinit_params", "items", "if", "child", "and", "not", "isinstance", "child", "collections", "abc", "sequence", "cloned_child", "_clone_node_with_lineno", "node", "child", "lineno", "new_node", "lineno", "parent", "new_node", "postinit_params", "param", "cloned_child", "new_node", "postinit", "postinit_params", "return", "new_node"], "doc_len": 88}
{"doc_id": "astroid/brain/brain_fstrings.py::_transform_formatted_value", "file_path": "astroid/brain/brain_fstrings.py", "class_name": null, "func_name": "_transform_formatted_value", "text": "文件路径: astroid/brain/brain_fstrings.py\ndef _transform_formatted_value(node):  # pylint: disable=inconsistent-return-statements\n    if node.value and node.value.lineno == 1:\n        if node.lineno != node.value.lineno:\n            new_node = FormattedValue(\n                lineno=node.lineno, col_offset=node.col_offset, parent=node.parent\n            )\n            new_value = _clone_node_with_lineno(\n                node=node.value, lineno=node.lineno, parent=new_node\n            )\n            new_node.postinit(value=new_value, format_spec=node.format_spec)\n            return new_node\n", "tokens": ["astroid", "brain", "brain_fstrings", "py", "def", "_transform_formatted_value", "node", "pylint", "disable", "inconsistent", "return", "statements", "if", "node", "value", "and", "node", "value", "lineno", "1", "if", "node", "lineno", "node", "value", "lineno", "new_node", "formattedvalue", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "node", "parent", "new_value", "_clone_node_with_lineno", "node", "node", "value", "lineno", "node", "lineno", "parent", "new_node", "new_node", "postinit", "value", "new_value", "format_spec", "node", "format_spec", "return", "new_node"], "doc_len": 56}
{"doc_id": "astroid/brain/brain_functools.py::LruWrappedModel.attr___wrapped__", "file_path": "astroid/brain/brain_functools.py", "class_name": "LruWrappedModel", "func_name": "attr___wrapped__", "text": "文件路径: astroid/brain/brain_functools.py, 类名: LruWrappedModel\n    def attr___wrapped__(self):\n        return self._instance\n", "tokens": ["astroid", "brain", "brain_functools", "py", "lruwrappedmodel", "def", "attr___wrapped__", "self", "return", "self", "_instance"], "doc_len": 11}
{"doc_id": "astroid/brain/brain_functools.py::LruWrappedModel.attr_cache_info", "file_path": "astroid/brain/brain_functools.py", "class_name": "LruWrappedModel", "func_name": "attr_cache_info", "text": "文件路径: astroid/brain/brain_functools.py, 类名: LruWrappedModel\n    def attr_cache_info(self):\n        cache_info = extract_node(\n            \"\"\"\n        from functools import _CacheInfo\n        _CacheInfo(0, 0, 0, 0)\n        \"\"\"\n        )\n\n        class CacheInfoBoundMethod(BoundMethod):\n            def infer_call_result(self, caller, context=None):\n                yield helpers.safe_infer(cache_info)\n\n        return CacheInfoBoundMethod(proxy=self._instance, bound=self._instance)\n", "tokens": ["astroid", "brain", "brain_functools", "py", "lruwrappedmodel", "def", "attr_cache_info", "self", "cache_info", "extract_node", "from", "functools", "import", "_cacheinfo", "_cacheinfo", "0", "0", "0", "0", "class", "cacheinfoboundmethod", "boundmethod", "def", "infer_call_result", "self", "caller", "context", "none", "yield", "helpers", "safe_infer", "cache_info", "return", "cacheinfoboundmethod", "proxy", "self", "_instance", "bound", "self", "_instance"], "doc_len": 40}
{"doc_id": "astroid/brain/brain_functools.py::LruWrappedModel.attr_cache_clear", "file_path": "astroid/brain/brain_functools.py", "class_name": "LruWrappedModel", "func_name": "attr_cache_clear", "text": "文件路径: astroid/brain/brain_functools.py, 类名: LruWrappedModel\n    def attr_cache_clear(self):\n        node = extract_node(\"\"\"def cache_clear(self): pass\"\"\")\n        return BoundMethod(proxy=node, bound=self._instance.parent.scope())\n", "tokens": ["astroid", "brain", "brain_functools", "py", "lruwrappedmodel", "def", "attr_cache_clear", "self", "node", "extract_node", "def", "cache_clear", "self", "pass", "return", "boundmethod", "proxy", "node", "bound", "self", "_instance", "parent", "scope"], "doc_len": 23}
{"doc_id": "astroid/brain/brain_functools.py::_transform_lru_cache", "file_path": "astroid/brain/brain_functools.py", "class_name": null, "func_name": "_transform_lru_cache", "text": "文件路径: astroid/brain/brain_functools.py\ndef _transform_lru_cache(node, context=None) -> None:\n    # TODO: this is not ideal, since the node should be immutable,\n    # but due to https://github.com/PyCQA/astroid/issues/354,\n    # there's not much we can do now.\n    # Replacing the node would work partially, because,\n    # in pylint, the old node would still be available, leading\n    # to spurious false positives.\n    node.special_attributes = LruWrappedModel()(node)\n", "tokens": ["astroid", "brain", "brain_functools", "py", "def", "_transform_lru_cache", "node", "context", "none", "none", "todo", "this", "is", "not", "ideal", "since", "the", "node", "should", "be", "immutable", "but", "due", "to", "https", "github", "com", "pycqa", "astroid", "issues", "354", "there", "s", "not", "much", "we", "can", "do", "now", "replacing", "the", "node", "would", "work", "partially", "because", "in", "pylint", "the", "old", "node", "would", "still", "be", "available", "leading", "to", "spurious", "false", "positives", "node", "special_attributes", "lruwrappedmodel", "node"], "doc_len": 64}
{"doc_id": "astroid/brain/brain_functools.py::_functools_partial_inference", "file_path": "astroid/brain/brain_functools.py", "class_name": null, "func_name": "_functools_partial_inference", "text": "文件路径: astroid/brain/brain_functools.py\ndef _functools_partial_inference(node, context=None):\n    call = arguments.CallSite.from_call(node, context=context)\n    number_of_positional = len(call.positional_arguments)\n    if number_of_positional < 1:\n        raise UseInferenceDefault(\"functools.partial takes at least one argument\")\n    if number_of_positional == 1 and not call.keyword_arguments:\n        raise UseInferenceDefault(\n            \"functools.partial needs at least to have some filled arguments\"\n        )\n\n    partial_function = call.positional_arguments[0]\n    try:\n        inferred_wrapped_function = next(partial_function.infer(context=context))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if inferred_wrapped_function is Uninferable:\n        raise UseInferenceDefault(\"Cannot infer the wrapped function\")\n    if not isinstance(inferred_wrapped_function, FunctionDef):\n        raise UseInferenceDefault(\"The wrapped function is not a function\")\n\n    # Determine if the passed keywords into the callsite are supported\n    # by the wrapped function.\n    if not inferred_wrapped_function.args:\n        function_parameters = []\n    else:\n        function_parameters = chain(\n            inferred_wrapped_function.args.args or (),\n            inferred_wrapped_function.args.posonlyargs or (),\n            inferred_wrapped_function.args.kwonlyargs or (),\n        )\n    parameter_names = {\n        param.name for param in function_parameters if isinstance(param, AssignName)\n    }\n    if set(call.keyword_arguments) - parameter_names:\n        raise UseInferenceDefault(\"wrapped function received unknown parameters\")\n\n    partial_function = objects.PartialFunction(\n        call,\n        name=inferred_wrapped_function.name,\n        doc=inferred_wrapped_function.doc,\n        lineno=inferred_wrapped_function.lineno,\n        col_offset=inferred_wrapped_function.col_offset,\n        parent=node.parent,\n    )\n    partial_function.postinit(\n        args=inferred_wrapped_function.args,\n        body=inferred_wrapped_function.body,\n        decorators=inferred_wrapped_function.decorators,\n        returns=inferred_wrapped_function.returns,\n        type_comment_returns=inferred_wrapped_function.type_comment_returns,\n        type_comment_args=inferred_wrapped_function.type_comment_args,\n    )\n    return iter((partial_function,))\n", "tokens": ["astroid", "brain", "brain_functools", "py", "def", "_functools_partial_inference", "node", "context", "none", "call", "arguments", "callsite", "from_call", "node", "context", "context", "number_of_positional", "len", "call", "positional_arguments", "if", "number_of_positional", "1", "raise", "useinferencedefault", "functools", "partial", "takes", "at", "least", "one", "argument", "if", "number_of_positional", "1", "and", "not", "call", "keyword_arguments", "raise", "useinferencedefault", "functools", "partial", "needs", "at", "least", "to", "have", "some", "filled", "arguments", "partial_function", "call", "positional_arguments", "0", "try", "inferred_wrapped_function", "next", "partial_function", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "inferred_wrapped_function", "is", "uninferable", "raise", "useinferencedefault", "cannot", "infer", "the", "wrapped", "function", "if", "not", "isinstance", "inferred_wrapped_function", "functiondef", "raise", "useinferencedefault", "the", "wrapped", "function", "is", "not", "a", "function", "determine", "if", "the", "passed", "keywords", "into", "the", "callsite", "are", "supported", "by", "the", "wrapped", "function", "if", "not", "inferred_wrapped_function", "args", "function_parameters", "else", "function_parameters", "chain", "inferred_wrapped_function", "args", "args", "or", "inferred_wrapped_function", "args", "posonlyargs", "or", "inferred_wrapped_function", "args", "kwonlyargs", "or", "parameter_names", "param", "name", "for", "param", "in", "function_parameters", "if", "isinstance", "param", "assignname", "if", "set", "call", "keyword_arguments", "parameter_names", "raise", "useinferencedefault", "wrapped", "function", "received", "unknown", "parameters", "partial_function", "objects", "partialfunction", "call", "name", "inferred_wrapped_function", "name", "doc", "inferred_wrapped_function", "doc", "lineno", "inferred_wrapped_function", "lineno", "col_offset", "inferred_wrapped_function", "col_offset", "parent", "node", "parent", "partial_function", "postinit", "args", "inferred_wrapped_function", "args", "body", "inferred_wrapped_function", "body", "decorators", "inferred_wrapped_function", "decorators", "returns", "inferred_wrapped_function", "returns", "type_comment_returns", "inferred_wrapped_function", "type_comment_returns", "type_comment_args", "inferred_wrapped_function", "type_comment_args", "return", "iter", "partial_function"], "doc_len": 195}
{"doc_id": "astroid/brain/brain_functools.py::_looks_like_lru_cache", "file_path": "astroid/brain/brain_functools.py", "class_name": null, "func_name": "_looks_like_lru_cache", "text": "文件路径: astroid/brain/brain_functools.py\ndef _looks_like_lru_cache(node):\n    \"\"\"Check if the given function node is decorated with lru_cache.\"\"\"\n    if not node.decorators:\n        return False\n    for decorator in node.decorators.nodes:\n        if not isinstance(decorator, Call):\n            continue\n        if _looks_like_functools_member(decorator, \"lru_cache\"):\n            return True\n    return False\n", "tokens": ["astroid", "brain", "brain_functools", "py", "def", "_looks_like_lru_cache", "node", "check", "if", "the", "given", "function", "node", "is", "decorated", "with", "lru_cache", "if", "not", "node", "decorators", "return", "false", "for", "decorator", "in", "node", "decorators", "nodes", "if", "not", "isinstance", "decorator", "call", "continue", "if", "_looks_like_functools_member", "decorator", "lru_cache", "return", "true", "return", "false"], "doc_len": 43}
{"doc_id": "astroid/brain/brain_functools.py::_looks_like_functools_member", "file_path": "astroid/brain/brain_functools.py", "class_name": null, "func_name": "_looks_like_functools_member", "text": "文件路径: astroid/brain/brain_functools.py\ndef _looks_like_functools_member(node, member) -> bool:\n    \"\"\"Check if the given Call node is a functools.partial call\"\"\"\n    if isinstance(node.func, Name):\n        return node.func.name == member\n    if isinstance(node.func, Attribute):\n        return (\n            node.func.attrname == member\n            and isinstance(node.func.expr, Name)\n            and node.func.expr.name == \"functools\"\n        )\n    return False\n", "tokens": ["astroid", "brain", "brain_functools", "py", "def", "_looks_like_functools_member", "node", "member", "bool", "check", "if", "the", "given", "call", "node", "is", "a", "functools", "partial", "call", "if", "isinstance", "node", "func", "name", "return", "node", "func", "name", "member", "if", "isinstance", "node", "func", "attribute", "return", "node", "func", "attrname", "member", "and", "isinstance", "node", "func", "expr", "name", "and", "node", "func", "expr", "name", "functools", "return", "false"], "doc_len": 54}
{"doc_id": "astroid/brain/brain_gi.py::_gi_build_stub", "file_path": "astroid/brain/brain_gi.py", "class_name": null, "func_name": "_gi_build_stub", "text": "文件路径: astroid/brain/brain_gi.py\ndef _gi_build_stub(parent):\n    \"\"\"\n    Inspect the passed module recursively and build stubs for functions,\n    classes, etc.\n    \"\"\"\n    classes = {}\n    functions = {}\n    constants = {}\n    methods = {}\n    for name in dir(parent):\n        if name.startswith(\"__\") and name not in _special_methods:\n            continue\n\n        # Check if this is a valid name in python\n        if not re.match(_identifier_re, name):\n            continue\n\n        try:\n            obj = getattr(parent, name)\n        except AttributeError:\n            continue\n\n        if inspect.isclass(obj):\n            classes[name] = obj\n        elif inspect.isfunction(obj) or inspect.isbuiltin(obj):\n            functions[name] = obj\n        elif inspect.ismethod(obj) or inspect.ismethoddescriptor(obj):\n            methods[name] = obj\n        elif (\n            str(obj).startswith(\"<flags\")\n            or str(obj).startswith(\"<enum \")\n            or str(obj).startswith(\"<GType \")\n            or inspect.isdatadescriptor(obj)\n        ):\n            constants[name] = 0\n        elif isinstance(obj, (int, str)):\n            constants[name] = obj\n        elif callable(obj):\n            # Fall back to a function for anything callable\n            functions[name] = obj\n        else:\n            # Assume everything else is some manner of constant\n            constants[name] = 0\n\n    ret = \"\"\n\n    if constants:\n        ret += f\"# {parent.__name__} constants\\n\\n\"\n    for name in sorted(constants):\n        if name[0].isdigit():\n            # GDK has some busted constant names like\n            # Gdk.EventType.2BUTTON_PRESS\n            continue\n\n        val = constants[name]\n\n        strval = str(val)\n        if isinstance(val, str):\n            strval = '\"%s\"' % str(val).replace(\"\\\\\", \"\\\\\\\\\")\n        ret += f\"{name} = {strval}\\n\"\n\n    if ret:\n        ret += \"\\n\\n\"\n    if functions:\n        ret += f\"# {parent.__name__} functions\\n\\n\"\n    for name in sorted(functions):\n        ret += f\"def {name}(*args, **kwargs):\\n\"\n        ret += \"    pass\\n\"\n\n    if ret:\n        ret += \"\\n\\n\"\n    if methods:\n        ret += f\"# {parent.__name__} methods\\n\\n\"\n    for name in sorted(methods):\n        ret += f\"def {name}(self, *args, **kwargs):\\n\"\n        ret += \"    pass\\n\"\n\n    if ret:\n        ret += \"\\n\\n\"\n    if classes:\n        ret += f\"# {parent.__name__} classes\\n\\n\"\n    for name, obj in sorted(classes.items()):\n        base = \"object\"\n        if issubclass(obj, Exception):\n            base = \"Exception\"\n        ret += f\"class {name}({base}):\\n\"\n\n        classret = _gi_build_stub(obj)\n        if not classret:\n            classret = \"pass\\n\"\n\n        for line in classret.splitlines():\n            ret += \"    \" + line + \"\\n\"\n        ret += \"\\n\"\n\n    return ret\n", "tokens": ["astroid", "brain", "brain_gi", "py", "def", "_gi_build_stub", "parent", "inspect", "the", "passed", "module", "recursively", "and", "build", "stubs", "for", "functions", "classes", "etc", "classes", "functions", "constants", "methods", "for", "name", "in", "dir", "parent", "if", "name", "startswith", "__", "and", "name", "not", "in", "_special_methods", "continue", "check", "if", "this", "is", "a", "valid", "name", "in", "python", "if", "not", "re", "match", "_identifier_re", "name", "continue", "try", "obj", "getattr", "parent", "name", "except", "attributeerror", "continue", "if", "inspect", "isclass", "obj", "classes", "name", "obj", "elif", "inspect", "isfunction", "obj", "or", "inspect", "isbuiltin", "obj", "functions", "name", "obj", "elif", "inspect", "ismethod", "obj", "or", "inspect", "ismethoddescriptor", "obj", "methods", "name", "obj", "elif", "str", "obj", "startswith", "flags", "or", "str", "obj", "startswith", "enum", "or", "str", "obj", "startswith", "gtype", "or", "inspect", "isdatadescriptor", "obj", "constants", "name", "0", "elif", "isinstance", "obj", "int", "str", "constants", "name", "obj", "elif", "callable", "obj", "fall", "back", "to", "a", "function", "for", "anything", "callable", "functions", "name", "obj", "else", "assume", "everything", "else", "is", "some", "manner", "of", "constant", "constants", "name", "0", "ret", "if", "constants", "ret", "f", "parent", "__name__", "constants", "n", "n", "for", "name", "in", "sorted", "constants", "if", "name", "0", "isdigit", "gdk", "has", "some", "busted", "constant", "names", "like", "gdk", "eventtype", "2button_press", "continue", "val", "constants", "name", "strval", "str", "val", "if", "isinstance", "val", "str", "strval", "s", "str", "val", "replace", "ret", "f", "name", "strval", "n", "if", "ret", "ret", "n", "n", "if", "functions", "ret", "f", "parent", "__name__", "functions", "n", "n", "for", "name", "in", "sorted", "functions", "ret", "f", "def", "name", "args", "kwargs", "n", "ret", "pass", "n", "if", "ret", "ret", "n", "n", "if", "methods", "ret", "f", "parent", "__name__", "methods", "n", "n", "for", "name", "in", "sorted", "methods", "ret", "f", "def", "name", "self", "args", "kwargs", "n", "ret", "pass", "n", "if", "ret", "ret", "n", "n", "if", "classes", "ret", "f", "parent", "__name__", "classes", "n", "n", "for", "name", "obj", "in", "sorted", "classes", "items", "base", "object", "if", "issubclass", "obj", "exception", "base", "exception", "ret", "f", "class", "name", "base", "n", "classret", "_gi_build_stub", "obj", "if", "not", "classret", "classret", "pass", "n", "for", "line", "in", "classret", "splitlines", "ret", "line", "n", "ret", "n", "return", "ret"], "doc_len": 312}
{"doc_id": "astroid/brain/brain_gi.py::_import_gi_module", "file_path": "astroid/brain/brain_gi.py", "class_name": null, "func_name": "_import_gi_module", "text": "文件路径: astroid/brain/brain_gi.py\ndef _import_gi_module(modname):\n    # we only consider gi.repository submodules\n    if not modname.startswith(\"gi.repository.\"):\n        raise AstroidBuildingError(modname=modname)\n    # build astroid representation unless we already tried so\n    if modname not in _inspected_modules:\n        modnames = [modname]\n        optional_modnames = []\n\n        # GLib and GObject may have some special case handling\n        # in pygobject that we need to cope with. However at\n        # least as of pygobject3-3.13.91 the _glib module doesn't\n        # exist anymore, so if treat these modules as optional.\n        if modname == \"gi.repository.GLib\":\n            optional_modnames.append(\"gi._glib\")\n        elif modname == \"gi.repository.GObject\":\n            optional_modnames.append(\"gi._gobject\")\n\n        try:\n            modcode = \"\"\n            for m in itertools.chain(modnames, optional_modnames):\n                try:\n                    with warnings.catch_warnings():\n                        # Just inspecting the code can raise gi deprecation\n                        # warnings, so ignore them.\n                        try:\n                            from gi import (  # pylint:disable=import-error\n                                PyGIDeprecationWarning,\n                                PyGIWarning,\n                            )\n\n                            warnings.simplefilter(\"ignore\", PyGIDeprecationWarning)\n                            warnings.simplefilter(\"ignore\", PyGIWarning)\n                        except Exception:  # pylint:disable=broad-except\n                            pass\n\n                        __import__(m)\n                        modcode += _gi_build_stub(sys.modules[m])\n                except ImportError:\n                    if m not in optional_modnames:\n                        raise\n        except ImportError:\n            astng = _inspected_modules[modname] = None\n        else:\n            astng = AstroidBuilder(AstroidManager()).string_build(modcode, modname)\n            _inspected_modules[modname] = astng\n    else:\n        astng = _inspected_modules[modname]\n    if astng is None:\n        raise AstroidBuildingError(modname=modname)\n    return astng\n", "tokens": ["astroid", "brain", "brain_gi", "py", "def", "_import_gi_module", "modname", "we", "only", "consider", "gi", "repository", "submodules", "if", "not", "modname", "startswith", "gi", "repository", "raise", "astroidbuildingerror", "modname", "modname", "build", "astroid", "representation", "unless", "we", "already", "tried", "so", "if", "modname", "not", "in", "_inspected_modules", "modnames", "modname", "optional_modnames", "glib", "and", "gobject", "may", "have", "some", "special", "case", "handling", "in", "pygobject", "that", "we", "need", "to", "cope", "with", "however", "at", "least", "as", "of", "pygobject3", "3", "13", "91", "the", "_glib", "module", "doesn", "t", "exist", "anymore", "so", "if", "treat", "these", "modules", "as", "optional", "if", "modname", "gi", "repository", "glib", "optional_modnames", "append", "gi", "_glib", "elif", "modname", "gi", "repository", "gobject", "optional_modnames", "append", "gi", "_gobject", "try", "modcode", "for", "m", "in", "itertools", "chain", "modnames", "optional_modnames", "try", "with", "warnings", "catch_warnings", "just", "inspecting", "the", "code", "can", "raise", "gi", "deprecation", "warnings", "so", "ignore", "them", "try", "from", "gi", "import", "pylint", "disable", "import", "error", "pygideprecationwarning", "pygiwarning", "warnings", "simplefilter", "ignore", "pygideprecationwarning", "warnings", "simplefilter", "ignore", "pygiwarning", "except", "exception", "pylint", "disable", "broad", "except", "pass", "__import__", "m", "modcode", "_gi_build_stub", "sys", "modules", "m", "except", "importerror", "if", "m", "not", "in", "optional_modnames", "raise", "except", "importerror", "astng", "_inspected_modules", "modname", "none", "else", "astng", "astroidbuilder", "astroidmanager", "string_build", "modcode", "modname", "_inspected_modules", "modname", "astng", "else", "astng", "_inspected_modules", "modname", "if", "astng", "is", "none", "raise", "astroidbuildingerror", "modname", "modname", "return", "astng"], "doc_len": 192}
{"doc_id": "astroid/brain/brain_gi.py::_looks_like_require_version", "file_path": "astroid/brain/brain_gi.py", "class_name": null, "func_name": "_looks_like_require_version", "text": "文件路径: astroid/brain/brain_gi.py\ndef _looks_like_require_version(node):\n    # Return whether this looks like a call to gi.require_version(<name>, <version>)\n    # Only accept function calls with two constant arguments\n    if len(node.args) != 2:\n        return False\n\n    if not all(isinstance(arg, nodes.Const) for arg in node.args):\n        return False\n\n    func = node.func\n    if isinstance(func, nodes.Attribute):\n        if func.attrname != \"require_version\":\n            return False\n        if isinstance(func.expr, nodes.Name) and func.expr.name == \"gi\":\n            return True\n\n        return False\n\n    if isinstance(func, nodes.Name):\n        return func.name == \"require_version\"\n\n    return False\n", "tokens": ["astroid", "brain", "brain_gi", "py", "def", "_looks_like_require_version", "node", "return", "whether", "this", "looks", "like", "a", "call", "to", "gi", "require_version", "name", "version", "only", "accept", "function", "calls", "with", "two", "constant", "arguments", "if", "len", "node", "args", "2", "return", "false", "if", "not", "all", "isinstance", "arg", "nodes", "const", "for", "arg", "in", "node", "args", "return", "false", "func", "node", "func", "if", "isinstance", "func", "nodes", "attribute", "if", "func", "attrname", "require_version", "return", "false", "if", "isinstance", "func", "expr", "nodes", "name", "and", "func", "expr", "name", "gi", "return", "true", "return", "false", "if", "isinstance", "func", "nodes", "name", "return", "func", "name", "require_version", "return", "false"], "doc_len": 88}
{"doc_id": "astroid/brain/brain_gi.py::_register_require_version", "file_path": "astroid/brain/brain_gi.py", "class_name": null, "func_name": "_register_require_version", "text": "文件路径: astroid/brain/brain_gi.py\ndef _register_require_version(node):\n    # Load the gi.require_version locally\n    try:\n        import gi\n\n        gi.require_version(node.args[0].value, node.args[1].value)\n    except Exception:  # pylint:disable=broad-except\n        pass\n\n    return node\n", "tokens": ["astroid", "brain", "brain_gi", "py", "def", "_register_require_version", "node", "load", "the", "gi", "require_version", "locally", "try", "import", "gi", "gi", "require_version", "node", "args", "0", "value", "node", "args", "1", "value", "except", "exception", "pylint", "disable", "broad", "except", "pass", "return", "node"], "doc_len": 34}
{"doc_id": "astroid/brain/brain_hashlib.py::_hashlib_transform", "file_path": "astroid/brain/brain_hashlib.py", "class_name": null, "func_name": "_hashlib_transform", "text": "文件路径: astroid/brain/brain_hashlib.py\ndef _hashlib_transform():\n    signature = \"value=''\"\n    template = \"\"\"\n    class %(name)s(object):\n      def __init__(self, %(signature)s): pass\n      def digest(self):\n        return %(digest)s\n      def copy(self):\n        return self\n      def update(self, value): pass\n      def hexdigest(self):\n        return ''\n      @property\n      def name(self):\n        return %(name)r\n      @property\n      def block_size(self):\n        return 1\n      @property\n      def digest_size(self):\n        return 1\n    \"\"\"\n    algorithms_with_signature = dict.fromkeys(\n        [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"], signature\n    )\n    blake2b_signature = \"data=b'', *, digest_size=64, key=b'', salt=b'', \\\n            person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, \\\n            node_depth=0, inner_size=0, last_node=False\"\n    blake2s_signature = \"data=b'', *, digest_size=32, key=b'', salt=b'', \\\n            person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, \\\n            node_depth=0, inner_size=0, last_node=False\"\n    new_algorithms = dict.fromkeys(\n        [\"sha3_224\", \"sha3_256\", \"sha3_384\", \"sha3_512\", \"shake_128\", \"shake_256\"],\n        signature,\n    )\n    algorithms_with_signature.update(new_algorithms)\n    algorithms_with_signature.update(\n        {\"blake2b\": blake2b_signature, \"blake2s\": blake2s_signature}\n    )\n    classes = \"\".join(\n        template % {\"name\": hashfunc, \"digest\": 'b\"\"', \"signature\": signature}\n        for hashfunc, signature in algorithms_with_signature.items()\n    )\n    return parse(classes)\n", "tokens": ["astroid", "brain", "brain_hashlib", "py", "def", "_hashlib_transform", "signature", "value", "template", "class", "name", "s", "object", "def", "__init__", "self", "signature", "s", "pass", "def", "digest", "self", "return", "digest", "s", "def", "copy", "self", "return", "self", "def", "update", "self", "value", "pass", "def", "hexdigest", "self", "return", "property", "def", "name", "self", "return", "name", "r", "property", "def", "block_size", "self", "return", "1", "property", "def", "digest_size", "self", "return", "1", "algorithms_with_signature", "dict", "fromkeys", "md5", "sha1", "sha224", "sha256", "sha384", "sha512", "signature", "blake2b_signature", "data", "b", "digest_size", "64", "key", "b", "salt", "b", "person", "b", "fanout", "1", "depth", "1", "leaf_size", "0", "node_offset", "0", "node_depth", "0", "inner_size", "0", "last_node", "false", "blake2s_signature", "data", "b", "digest_size", "32", "key", "b", "salt", "b", "person", "b", "fanout", "1", "depth", "1", "leaf_size", "0", "node_offset", "0", "node_depth", "0", "inner_size", "0", "last_node", "false", "new_algorithms", "dict", "fromkeys", "sha3_224", "sha3_256", "sha3_384", "sha3_512", "shake_128", "shake_256", "signature", "algorithms_with_signature", "update", "new_algorithms", "algorithms_with_signature", "update", "blake2b", "blake2b_signature", "blake2s", "blake2s_signature", "classes", "join", "template", "name", "hashfunc", "digest", "b", "signature", "signature", "for", "hashfunc", "signature", "in", "algorithms_with_signature", "items", "return", "parse", "classes"], "doc_len": 155}
{"doc_id": "astroid/brain/brain_http.py::_http_transform", "file_path": "astroid/brain/brain_http.py", "class_name": null, "func_name": "_http_transform", "text": "文件路径: astroid/brain/brain_http.py\ndef _http_transform():\n    code = textwrap.dedent(\n        \"\"\"\n    from collections import namedtuple\n    _HTTPStatus = namedtuple('_HTTPStatus', 'value phrase description')\n\n    class HTTPStatus:\n\n        @property\n        def phrase(self):\n            return \"\"\n        @property\n        def value(self):\n            return 0\n        @property\n        def description(self):\n            return \"\"\n\n        # informational\n        CONTINUE = _HTTPStatus(100, 'Continue', 'Request received, please continue')\n        SWITCHING_PROTOCOLS = _HTTPStatus(101, 'Switching Protocols',\n                'Switching to new protocol; obey Upgrade header')\n        PROCESSING = _HTTPStatus(102, 'Processing', '')\n        OK = _HTTPStatus(200, 'OK', 'Request fulfilled, document follows')\n        CREATED = _HTTPStatus(201, 'Created', 'Document created, URL follows')\n        ACCEPTED = _HTTPStatus(202, 'Accepted',\n            'Request accepted, processing continues off-line')\n        NON_AUTHORITATIVE_INFORMATION = _HTTPStatus(203,\n            'Non-Authoritative Information', 'Request fulfilled from cache')\n        NO_CONTENT = _HTTPStatus(204, 'No Content', 'Request fulfilled, nothing follows')\n        RESET_CONTENT =_HTTPStatus(205, 'Reset Content', 'Clear input form for further input')\n        PARTIAL_CONTENT = _HTTPStatus(206, 'Partial Content', 'Partial content follows')\n        MULTI_STATUS = _HTTPStatus(207, 'Multi-Status', '')\n        ALREADY_REPORTED = _HTTPStatus(208, 'Already Reported', '')\n        IM_USED = _HTTPStatus(226, 'IM Used', '')\n        MULTIPLE_CHOICES = _HTTPStatus(300, 'Multiple Choices',\n            'Object has several resources -- see URI list')\n        MOVED_PERMANENTLY = _HTTPStatus(301, 'Moved Permanently',\n            'Object moved permanently -- see URI list')\n        FOUND = _HTTPStatus(302, 'Found', 'Object moved temporarily -- see URI list')\n        SEE_OTHER = _HTTPStatus(303, 'See Other', 'Object moved -- see Method and URL list')\n        NOT_MODIFIED = _HTTPStatus(304, 'Not Modified',\n            'Document has not changed since given time')\n        USE_PROXY = _HTTPStatus(305, 'Use Proxy',\n            'You must use proxy specified in Location to access this resource')\n        TEMPORARY_REDIRECT = _HTTPStatus(307, 'Temporary Redirect',\n            'Object moved temporarily -- see URI list')\n        PERMANENT_REDIRECT = _HTTPStatus(308, 'Permanent Redirect',\n            'Object moved permanently -- see URI list')\n        BAD_REQUEST = _HTTPStatus(400, 'Bad Request',\n            'Bad request syntax or unsupported method')\n        UNAUTHORIZED = _HTTPStatus(401, 'Unauthorized',\n            'No permission -- see authorization schemes')\n        PAYMENT_REQUIRED = _HTTPStatus(402, 'Payment Required',\n            'No payment -- see charging schemes')\n        FORBIDDEN = _HTTPStatus(403, 'Forbidden',\n            'Request forbidden -- authorization will not help')\n        NOT_FOUND = _HTTPStatus(404, 'Not Found',\n            'Nothing matches the given URI')\n        METHOD_NOT_ALLOWED = _HTTPStatus(405, 'Method Not Allowed',\n            'Specified method is invalid for this resource')\n        NOT_ACCEPTABLE = _HTTPStatus(406, 'Not Acceptable',\n            'URI not available in preferred format')\n        PROXY_AUTHENTICATION_REQUIRED = _HTTPStatus(407,\n            'Proxy Authentication Required',\n            'You must authenticate with this proxy before proceeding')\n        REQUEST_TIMEOUT = _HTTPStatus(408, 'Request Timeout',\n            'Request timed out; try again later')\n        CONFLICT = _HTTPStatus(409, 'Conflict', 'Request conflict')\n        GONE = _HTTPStatus(410, 'Gone',\n            'URI no longer exists and has been permanently removed')\n        LENGTH_REQUIRED = _HTTPStatus(411, 'Length Required',\n            'Client must specify Content-Length')\n        PRECONDITION_FAILED = _HTTPStatus(412, 'Precondition Failed',\n            'Precondition in headers is false')\n        REQUEST_ENTITY_TOO_LARGE = _HTTPStatus(413, 'Request Entity Too Large',\n            'Entity is too large')\n        REQUEST_URI_TOO_LONG = _HTTPStatus(414, 'Request-URI Too Long',\n            'URI is too long')\n        UNSUPPORTED_MEDIA_TYPE = _HTTPStatus(415, 'Unsupported Media Type',\n            'Entity body in unsupported format')\n        REQUESTED_RANGE_NOT_SATISFIABLE = _HTTPStatus(416,\n            'Requested Range Not Satisfiable',\n            'Cannot satisfy request range')\n        EXPECTATION_FAILED = _HTTPStatus(417, 'Expectation Failed',\n            'Expect condition could not be satisfied')\n        MISDIRECTED_REQUEST = _HTTPStatus(421, 'Misdirected Request',\n            'Server is not able to produce a response')\n        UNPROCESSABLE_ENTITY = _HTTPStatus(422, 'Unprocessable Entity')\n        LOCKED = _HTTPStatus(423, 'Locked')\n        FAILED_DEPENDENCY = _HTTPStatus(424, 'Failed Dependency')\n        UPGRADE_REQUIRED = _HTTPStatus(426, 'Upgrade Required')\n        PRECONDITION_REQUIRED = _HTTPStatus(428, 'Precondition Required',\n            'The origin server requires the request to be conditional')\n        TOO_MANY_REQUESTS = _HTTPStatus(429, 'Too Many Requests',\n            'The user has sent too many requests in '\n            'a given amount of time (\"rate limiting\")')\n        REQUEST_HEADER_FIELDS_TOO_LARGE = _HTTPStatus(431,\n            'Request Header Fields Too Large',\n            'The server is unwilling to process the request because its header '\n            'fields are too large')\n        UNAVAILABLE_FOR_LEGAL_REASONS = _HTTPStatus(451,\n            'Unavailable For Legal Reasons',\n            'The server is denying access to the '\n            'resource as a consequence of a legal demand')\n        INTERNAL_SERVER_ERROR = _HTTPStatus(500, 'Internal Server Error',\n            'Server got itself in trouble')\n        NOT_IMPLEMENTED = _HTTPStatus(501, 'Not Implemented',\n            'Server does not support this operation')\n        BAD_GATEWAY = _HTTPStatus(502, 'Bad Gateway',\n            'Invalid responses from another server/proxy')\n        SERVICE_UNAVAILABLE = _HTTPStatus(503, 'Service Unavailable',\n            'The server cannot process the request due to a high load')\n        GATEWAY_TIMEOUT = _HTTPStatus(504, 'Gateway Timeout',\n            'The gateway server did not receive a timely response')\n        HTTP_VERSION_NOT_SUPPORTED = _HTTPStatus(505, 'HTTP Version Not Supported',\n            'Cannot fulfill request')\n        VARIANT_ALSO_NEGOTIATES = _HTTPStatus(506, 'Variant Also Negotiates')\n        INSUFFICIENT_STORAGE = _HTTPStatus(507, 'Insufficient Storage')\n        LOOP_DETECTED = _HTTPStatus(508, 'Loop Detected')\n        NOT_EXTENDED = _HTTPStatus(510, 'Not Extended')\n        NETWORK_AUTHENTICATION_REQUIRED = _HTTPStatus(511,\n            'Network Authentication Required',\n            'The client needs to authenticate to gain network access')\n    \"\"\"\n    )\n    return AstroidBuilder(AstroidManager()).string_build(code)\n", "tokens": ["astroid", "brain", "brain_http", "py", "def", "_http_transform", "code", "textwrap", "dedent", "from", "collections", "import", "namedtuple", "_httpstatus", "namedtuple", "_httpstatus", "value", "phrase", "description", "class", "httpstatus", "property", "def", "phrase", "self", "return", "property", "def", "value", "self", "return", "0", "property", "def", "description", "self", "return", "informational", "continue", "_httpstatus", "100", "continue", "request", "received", "please", "continue", "switching_protocols", "_httpstatus", "101", "switching", "protocols", "switching", "to", "new", "protocol", "obey", "upgrade", "header", "processing", "_httpstatus", "102", "processing", "ok", "_httpstatus", "200", "ok", "request", "fulfilled", "document", "follows", "created", "_httpstatus", "201", "created", "document", "created", "url", "follows", "accepted", "_httpstatus", "202", "accepted", "request", "accepted", "processing", "continues", "off", "line", "non_authoritative_information", "_httpstatus", "203", "non", "authoritative", "information", "request", "fulfilled", "from", "cache", "no_content", "_httpstatus", "204", "no", "content", "request", "fulfilled", "nothing", "follows", "reset_content", "_httpstatus", "205", "reset", "content", "clear", "input", "form", "for", "further", "input", "partial_content", "_httpstatus", "206", "partial", "content", "partial", "content", "follows", "multi_status", "_httpstatus", "207", "multi", "status", "already_reported", "_httpstatus", "208", "already", "reported", "im_used", "_httpstatus", "226", "im", "used", "multiple_choices", "_httpstatus", "300", "multiple", "choices", "object", "has", "several", "resources", "see", "uri", "list", "moved_permanently", "_httpstatus", "301", "moved", "permanently", "object", "moved", "permanently", "see", "uri", "list", "found", "_httpstatus", "302", "found", "object", "moved", "temporarily", "see", "uri", "list", "see_other", "_httpstatus", "303", "see", "other", "object", "moved", "see", "method", "and", "url", "list", "not_modified", "_httpstatus", "304", "not", "modified", "document", "has", "not", "changed", "since", "given", "time", "use_proxy", "_httpstatus", "305", "use", "proxy", "you", "must", "use", "proxy", "specified", "in", "location", "to", "access", "this", "resource", "temporary_redirect", "_httpstatus", "307", "temporary", "redirect", "object", "moved", "temporarily", "see", "uri", "list", "permanent_redirect", "_httpstatus", "308", "permanent", "redirect", "object", "moved", "permanently", "see", "uri", "list", "bad_request", "_httpstatus", "400", "bad", "request", "bad", "request", "syntax", "or", "unsupported", "method", "unauthorized", "_httpstatus", "401", "unauthorized", "no", "permission", "see", "authorization", "schemes", "payment_required", "_httpstatus", "402", "payment", "required", "no", "payment", "see", "charging", "schemes", "forbidden", "_httpstatus", "403", "forbidden", "request", "forbidden", "authorization", "will", "not", "help", "not_found", "_httpstatus", "404", "not", "found", "nothing", "matches", "the", "given", "uri", "method_not_allowed", "_httpstatus", "405", "method", "not", "allowed", "specified", "method", "is", "invalid", "for", "this", "resource", "not_acceptable", "_httpstatus", "406", "not", "acceptable", "uri", "not", "available", "in", "preferred", "format", "proxy_authentication_required", "_httpstatus", "407", "proxy", "authentication", "required", "you", "must", "authenticate", "with", "this", "proxy", "before", "proceeding", "request_timeout", "_httpstatus", "408", "request", "timeout", "request", "timed", "out", "try", "again", "later", "conflict", "_httpstatus", "409", "conflict", "request", "conflict", "gone", "_httpstatus", "410", "gone", "uri", "no", "longer", "exists", "and", "has", "been", "permanently", "removed", "length_required", "_httpstatus", "411", "length", "required", "client", "must", "specify", "content", "length", "precondition_failed", "_httpstatus", "412", "precondition", "failed", "precondition", "in", "headers", "is", "false", "request_entity_too_large", "_httpstatus", "413", "request", "entity", "too", "large", "entity", "is", "too", "large", "request_uri_too_long", "_httpstatus", "414", "request", "uri", "too", "long", "uri", "is", "too", "long", "unsupported_media_type", "_httpstatus", "415", "unsupported", "media", "type", "entity", "body", "in", "unsupported", "format", "requested_range_not_satisfiable", "_httpstatus", "416", "requested", "range", "not", "satisfiable", "cannot", "satisfy", "request", "range", "expectation_failed", "_httpstatus", "417", "expectation", "failed", "expect", "condition", "could", "not", "be", "satisfied", "misdirected_request", "_httpstatus", "421", "misdirected", "request", "server", "is", "not", "able", "to", "produce", "a", "response", "unprocessable_entity", "_httpstatus", "422", "unprocessable", "entity", "locked", "_httpstatus", "423", "locked", "failed_dependency", "_httpstatus", "424", "failed", "dependency", "upgrade_required", "_httpstatus", "426", "upgrade", "required", "precondition_required", "_httpstatus", "428", "precondition", "required", "the", "origin", "server", "requires", "the", "request", "to", "be", "conditional", "too_many_requests", "_httpstatus", "429", "too", "many", "requests", "the", "user", "has", "sent", "too", "many", "requests", "in", "a", "given", "amount", "of", "time", "rate", "limiting", "request_header_fields_too_large", "_httpstatus", "431", "request", "header", "fields", "too", "large", "the", "server", "is", "unwilling", "to", "process", "the", "request", "because", "its", "header", "fields", "are", "too", "large", "unavailable_for_legal_reasons", "_httpstatus", "451", "unavailable", "for", "legal", "reasons", "the", "server", "is", "denying", "access", "to", "the", "resource", "as", "a", "consequence", "of", "a", "legal", "demand", "internal_server_error", "_httpstatus", "500", "internal", "server", "error", "server", "got", "itself", "in", "trouble", "not_implemented", "_httpstatus", "501", "not", "implemented", "server", "does", "not", "support", "this", "operation", "bad_gateway", "_httpstatus", "502", "bad", "gateway", "invalid", "responses", "from", "another", "server", "proxy", "service_unavailable", "_httpstatus", "503", "service", "unavailable", "the", "server", "cannot", "process", "the", "request", "due", "to", "a", "high", "load", "gateway_timeout", "_httpstatus", "504", "gateway", "timeout", "the", "gateway", "server", "did", "not", "receive", "a", "timely", "response", "http_version_not_supported", "_httpstatus", "505", "http", "version", "not", "supported", "cannot", "fulfill", "request", "variant_also_negotiates", "_httpstatus", "506", "variant", "also", "negotiates", "insufficient_storage", "_httpstatus", "507", "insufficient", "storage", "loop_detected", "_httpstatus", "508", "loop", "detected", "not_extended", "_httpstatus", "510", "not", "extended", "network_authentication_required", "_httpstatus", "511", "network", "authentication", "required", "the", "client", "needs", "to", "authenticate", "to", "gain", "network", "access", "return", "astroidbuilder", "astroidmanager", "string_build", "code"], "doc_len": 655}
{"doc_id": "astroid/brain/brain_http.py::_http_client_transform", "file_path": "astroid/brain/brain_http.py", "class_name": null, "func_name": "_http_client_transform", "text": "文件路径: astroid/brain/brain_http.py\ndef _http_client_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        textwrap.dedent(\n            \"\"\"\n    from http import HTTPStatus\n\n    CONTINUE = HTTPStatus.CONTINUE\n    SWITCHING_PROTOCOLS = HTTPStatus.SWITCHING_PROTOCOLS\n    PROCESSING = HTTPStatus.PROCESSING\n    OK = HTTPStatus.OK\n    CREATED = HTTPStatus.CREATED\n    ACCEPTED = HTTPStatus.ACCEPTED\n    NON_AUTHORITATIVE_INFORMATION = HTTPStatus.NON_AUTHORITATIVE_INFORMATION\n    NO_CONTENT = HTTPStatus.NO_CONTENT\n    RESET_CONTENT = HTTPStatus.RESET_CONTENT\n    PARTIAL_CONTENT = HTTPStatus.PARTIAL_CONTENT\n    MULTI_STATUS = HTTPStatus.MULTI_STATUS\n    ALREADY_REPORTED = HTTPStatus.ALREADY_REPORTED\n    IM_USED = HTTPStatus.IM_USED\n    MULTIPLE_CHOICES = HTTPStatus.MULTIPLE_CHOICES\n    MOVED_PERMANENTLY = HTTPStatus.MOVED_PERMANENTLY\n    FOUND = HTTPStatus.FOUND\n    SEE_OTHER = HTTPStatus.SEE_OTHER\n    NOT_MODIFIED = HTTPStatus.NOT_MODIFIED\n    USE_PROXY = HTTPStatus.USE_PROXY\n    TEMPORARY_REDIRECT = HTTPStatus.TEMPORARY_REDIRECT\n    PERMANENT_REDIRECT = HTTPStatus.PERMANENT_REDIRECT\n    BAD_REQUEST = HTTPStatus.BAD_REQUEST\n    UNAUTHORIZED = HTTPStatus.UNAUTHORIZED\n    PAYMENT_REQUIRED = HTTPStatus.PAYMENT_REQUIRED\n    FORBIDDEN = HTTPStatus.FORBIDDEN\n    NOT_FOUND = HTTPStatus.NOT_FOUND\n    METHOD_NOT_ALLOWED = HTTPStatus.METHOD_NOT_ALLOWED\n    NOT_ACCEPTABLE = HTTPStatus.NOT_ACCEPTABLE\n    PROXY_AUTHENTICATION_REQUIRED = HTTPStatus.PROXY_AUTHENTICATION_REQUIRED\n    REQUEST_TIMEOUT = HTTPStatus.REQUEST_TIMEOUT\n    CONFLICT = HTTPStatus.CONFLICT\n    GONE = HTTPStatus.GONE\n    LENGTH_REQUIRED = HTTPStatus.LENGTH_REQUIRED\n    PRECONDITION_FAILED = HTTPStatus.PRECONDITION_FAILED\n    REQUEST_ENTITY_TOO_LARGE = HTTPStatus.REQUEST_ENTITY_TOO_LARGE\n    REQUEST_URI_TOO_LONG = HTTPStatus.REQUEST_URI_TOO_LONG\n    UNSUPPORTED_MEDIA_TYPE = HTTPStatus.UNSUPPORTED_MEDIA_TYPE\n    REQUESTED_RANGE_NOT_SATISFIABLE = HTTPStatus.REQUESTED_RANGE_NOT_SATISFIABLE\n    EXPECTATION_FAILED = HTTPStatus.EXPECTATION_FAILED\n    UNPROCESSABLE_ENTITY = HTTPStatus.UNPROCESSABLE_ENTITY\n    LOCKED = HTTPStatus.LOCKED\n    FAILED_DEPENDENCY = HTTPStatus.FAILED_DEPENDENCY\n    UPGRADE_REQUIRED = HTTPStatus.UPGRADE_REQUIRED\n    PRECONDITION_REQUIRED = HTTPStatus.PRECONDITION_REQUIRED\n    TOO_MANY_REQUESTS = HTTPStatus.TOO_MANY_REQUESTS\n    REQUEST_HEADER_FIELDS_TOO_LARGE = HTTPStatus.REQUEST_HEADER_FIELDS_TOO_LARGE\n    INTERNAL_SERVER_ERROR = HTTPStatus.INTERNAL_SERVER_ERROR\n    NOT_IMPLEMENTED = HTTPStatus.NOT_IMPLEMENTED\n    BAD_GATEWAY = HTTPStatus.BAD_GATEWAY\n    SERVICE_UNAVAILABLE = HTTPStatus.SERVICE_UNAVAILABLE\n    GATEWAY_TIMEOUT = HTTPStatus.GATEWAY_TIMEOUT\n    HTTP_VERSION_NOT_SUPPORTED = HTTPStatus.HTTP_VERSION_NOT_SUPPORTED\n    VARIANT_ALSO_NEGOTIATES = HTTPStatus.VARIANT_ALSO_NEGOTIATES\n    INSUFFICIENT_STORAGE = HTTPStatus.INSUFFICIENT_STORAGE\n    LOOP_DETECTED = HTTPStatus.LOOP_DETECTED\n    NOT_EXTENDED = HTTPStatus.NOT_EXTENDED\n    NETWORK_AUTHENTICATION_REQUIRED = HTTPStatus.NETWORK_AUTHENTICATION_REQUIRED\n    \"\"\"\n        )\n    )\n", "tokens": ["astroid", "brain", "brain_http", "py", "def", "_http_client_transform", "return", "astroidbuilder", "astroidmanager", "string_build", "textwrap", "dedent", "from", "http", "import", "httpstatus", "continue", "httpstatus", "continue", "switching_protocols", "httpstatus", "switching_protocols", "processing", "httpstatus", "processing", "ok", "httpstatus", "ok", "created", "httpstatus", "created", "accepted", "httpstatus", "accepted", "non_authoritative_information", "httpstatus", "non_authoritative_information", "no_content", "httpstatus", "no_content", "reset_content", "httpstatus", "reset_content", "partial_content", "httpstatus", "partial_content", "multi_status", "httpstatus", "multi_status", "already_reported", "httpstatus", "already_reported", "im_used", "httpstatus", "im_used", "multiple_choices", "httpstatus", "multiple_choices", "moved_permanently", "httpstatus", "moved_permanently", "found", "httpstatus", "found", "see_other", "httpstatus", "see_other", "not_modified", "httpstatus", "not_modified", "use_proxy", "httpstatus", "use_proxy", "temporary_redirect", "httpstatus", "temporary_redirect", "permanent_redirect", "httpstatus", "permanent_redirect", "bad_request", "httpstatus", "bad_request", "unauthorized", "httpstatus", "unauthorized", "payment_required", "httpstatus", "payment_required", "forbidden", "httpstatus", "forbidden", "not_found", "httpstatus", "not_found", "method_not_allowed", "httpstatus", "method_not_allowed", "not_acceptable", "httpstatus", "not_acceptable", "proxy_authentication_required", "httpstatus", "proxy_authentication_required", "request_timeout", "httpstatus", "request_timeout", "conflict", "httpstatus", "conflict", "gone", "httpstatus", "gone", "length_required", "httpstatus", "length_required", "precondition_failed", "httpstatus", "precondition_failed", "request_entity_too_large", "httpstatus", "request_entity_too_large", "request_uri_too_long", "httpstatus", "request_uri_too_long", "unsupported_media_type", "httpstatus", "unsupported_media_type", "requested_range_not_satisfiable", "httpstatus", "requested_range_not_satisfiable", "expectation_failed", "httpstatus", "expectation_failed", "unprocessable_entity", "httpstatus", "unprocessable_entity", "locked", "httpstatus", "locked", "failed_dependency", "httpstatus", "failed_dependency", "upgrade_required", "httpstatus", "upgrade_required", "precondition_required", "httpstatus", "precondition_required", "too_many_requests", "httpstatus", "too_many_requests", "request_header_fields_too_large", "httpstatus", "request_header_fields_too_large", "internal_server_error", "httpstatus", "internal_server_error", "not_implemented", "httpstatus", "not_implemented", "bad_gateway", "httpstatus", "bad_gateway", "service_unavailable", "httpstatus", "service_unavailable", "gateway_timeout", "httpstatus", "gateway_timeout", "http_version_not_supported", "httpstatus", "http_version_not_supported", "variant_also_negotiates", "httpstatus", "variant_also_negotiates", "insufficient_storage", "httpstatus", "insufficient_storage", "loop_detected", "httpstatus", "loop_detected", "not_extended", "httpstatus", "not_extended", "network_authentication_required", "httpstatus", "network_authentication_required"], "doc_len": 187}
{"doc_id": "astroid/brain/brain_hypothesis.py::is_decorated_with_st_composite", "file_path": "astroid/brain/brain_hypothesis.py", "class_name": null, "func_name": "is_decorated_with_st_composite", "text": "文件路径: astroid/brain/brain_hypothesis.py\ndef is_decorated_with_st_composite(node):\n    \"\"\"Return True if a decorated node has @st.composite applied.\"\"\"\n    if node.decorators and node.args.args and node.args.args[0].name == \"draw\":\n        for decorator_attribute in node.decorators.nodes:\n            if decorator_attribute.as_string() in COMPOSITE_NAMES:\n                return True\n    return False\n", "tokens": ["astroid", "brain", "brain_hypothesis", "py", "def", "is_decorated_with_st_composite", "node", "return", "true", "if", "a", "decorated", "node", "has", "st", "composite", "applied", "if", "node", "decorators", "and", "node", "args", "args", "and", "node", "args", "args", "0", "name", "draw", "for", "decorator_attribute", "in", "node", "decorators", "nodes", "if", "decorator_attribute", "as_string", "in", "composite_names", "return", "true", "return", "false"], "doc_len": 46}
{"doc_id": "astroid/brain/brain_hypothesis.py::remove_draw_parameter_from_composite_strategy", "file_path": "astroid/brain/brain_hypothesis.py", "class_name": null, "func_name": "remove_draw_parameter_from_composite_strategy", "text": "文件路径: astroid/brain/brain_hypothesis.py\ndef remove_draw_parameter_from_composite_strategy(node):\n    \"\"\"Given that the FunctionDef is decorated with @st.composite, remove the\n    first argument (`draw`) - it's always supplied by Hypothesis so we don't\n    need to emit the no-value-for-parameter lint.\n    \"\"\"\n    del node.args.args[0]\n    del node.args.annotations[0]\n    del node.args.type_comment_args[0]\n    return node\n", "tokens": ["astroid", "brain", "brain_hypothesis", "py", "def", "remove_draw_parameter_from_composite_strategy", "node", "given", "that", "the", "functiondef", "is", "decorated", "with", "st", "composite", "remove", "the", "first", "argument", "draw", "it", "s", "always", "supplied", "by", "hypothesis", "so", "we", "don", "t", "need", "to", "emit", "the", "no", "value", "for", "parameter", "lint", "del", "node", "args", "args", "0", "del", "node", "args", "annotations", "0", "del", "node", "args", "type_comment_args", "0", "return", "node"], "doc_len": 57}
{"doc_id": "astroid/brain/brain_io.py::_generic_io_transform", "file_path": "astroid/brain/brain_io.py", "class_name": null, "func_name": "_generic_io_transform", "text": "文件路径: astroid/brain/brain_io.py\ndef _generic_io_transform(node, name, cls):\n    \"\"\"Transform the given name, by adding the given *class* as a member of the node.\"\"\"\n\n    io_module = AstroidManager().ast_from_module_name(\"_io\")\n    attribute_object = io_module[cls]\n    instance = attribute_object.instantiate_class()\n    node.locals[name] = [instance]\n", "tokens": ["astroid", "brain", "brain_io", "py", "def", "_generic_io_transform", "node", "name", "cls", "transform", "the", "given", "name", "by", "adding", "the", "given", "class", "as", "a", "member", "of", "the", "node", "io_module", "astroidmanager", "ast_from_module_name", "_io", "attribute_object", "io_module", "cls", "instance", "attribute_object", "instantiate_class", "node", "locals", "name", "instance"], "doc_len": 38}
{"doc_id": "astroid/brain/brain_io.py::_transform_text_io_wrapper", "file_path": "astroid/brain/brain_io.py", "class_name": null, "func_name": "_transform_text_io_wrapper", "text": "文件路径: astroid/brain/brain_io.py\ndef _transform_text_io_wrapper(node):\n    # This is not always correct, since it can vary with the type of the descriptor,\n    # being stdout, stderr or stdin. But we cannot get access to the name of the\n    # stream, which is why we are using the BufferedWriter class as a default\n    # value\n    return _generic_io_transform(node, name=\"buffer\", cls=BufferedWriter)\n", "tokens": ["astroid", "brain", "brain_io", "py", "def", "_transform_text_io_wrapper", "node", "this", "is", "not", "always", "correct", "since", "it", "can", "vary", "with", "the", "type", "of", "the", "descriptor", "being", "stdout", "stderr", "or", "stdin", "but", "we", "cannot", "get", "access", "to", "the", "name", "of", "the", "stream", "which", "is", "why", "we", "are", "using", "the", "bufferedwriter", "class", "as", "a", "default", "value", "return", "_generic_io_transform", "node", "name", "buffer", "cls", "bufferedwriter"], "doc_len": 58}
{"doc_id": "astroid/brain/brain_io.py::_transform_buffered", "file_path": "astroid/brain/brain_io.py", "class_name": null, "func_name": "_transform_buffered", "text": "文件路径: astroid/brain/brain_io.py\ndef _transform_buffered(node):\n    return _generic_io_transform(node, name=\"raw\", cls=FileIO)\n", "tokens": ["astroid", "brain", "brain_io", "py", "def", "_transform_buffered", "node", "return", "_generic_io_transform", "node", "name", "raw", "cls", "fileio"], "doc_len": 14}
{"doc_id": "astroid/brain/brain_mechanize.py::mechanize_transform", "file_path": "astroid/brain/brain_mechanize.py", "class_name": null, "func_name": "mechanize_transform", "text": "文件路径: astroid/brain/brain_mechanize.py\ndef mechanize_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"\n\nclass Browser(object):\n    def __getattr__(self, name):\n        return None\n    def __getitem__(self, name):\n        return None\n    def __setitem__(self, name, val):\n        return None\n    def back(self, n=1):\n        return None\n    def clear_history(self):\n        return None\n    def click(self, *args, **kwds):\n        return None\n    def click_link(self, link=None, **kwds):\n        return None\n    def close(self):\n        return None\n    def encoding(self):\n        return None\n    def find_link(self, text=None, text_regex=None, name=None, name_regex=None, url=None, url_regex=None, tag=None, predicate=None, nr=0):\n        return None\n    def follow_link(self, link=None, **kwds):\n        return None\n    def forms(self):\n        return None\n    def geturl(self):\n        return None\n    def global_form(self):\n        return None\n    def links(self, **kwds):\n        return None\n    def open_local_file(self, filename):\n        return None\n    def open(self, url, data=None, timeout=None):\n        return None\n    def open_novisit(self, url, data=None, timeout=None):\n        return None\n    def open_local_file(self, filename):\n        return None\n    def reload(self):\n        return None\n    def response(self):\n        return None\n    def select_form(self, name=None, predicate=None, nr=None, **attrs):\n        return None\n    def set_cookie(self, cookie_string):\n        return None\n    def set_handle_referer(self, handle):\n        return None\n    def set_header(self, header, value=None):\n        return None\n    def set_html(self, html, url=\"http://example.com/\"):\n        return None\n    def set_response(self, response):\n        return None\n    def set_simple_cookie(self, name, value, domain, path='/'):\n        return None\n    def submit(self, *args, **kwds):\n        return None\n    def title(self):\n        return None\n    def viewing_html(self):\n        return None\n    def visit_response(self, response, request=None):\n        return None\n\"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_mechanize", "py", "def", "mechanize_transform", "return", "astroidbuilder", "astroidmanager", "string_build", "class", "browser", "object", "def", "__getattr__", "self", "name", "return", "none", "def", "__getitem__", "self", "name", "return", "none", "def", "__setitem__", "self", "name", "val", "return", "none", "def", "back", "self", "n", "1", "return", "none", "def", "clear_history", "self", "return", "none", "def", "click", "self", "args", "kwds", "return", "none", "def", "click_link", "self", "link", "none", "kwds", "return", "none", "def", "close", "self", "return", "none", "def", "encoding", "self", "return", "none", "def", "find_link", "self", "text", "none", "text_regex", "none", "name", "none", "name_regex", "none", "url", "none", "url_regex", "none", "tag", "none", "predicate", "none", "nr", "0", "return", "none", "def", "follow_link", "self", "link", "none", "kwds", "return", "none", "def", "forms", "self", "return", "none", "def", "geturl", "self", "return", "none", "def", "global_form", "self", "return", "none", "def", "links", "self", "kwds", "return", "none", "def", "open_local_file", "self", "filename", "return", "none", "def", "open", "self", "url", "data", "none", "timeout", "none", "return", "none", "def", "open_novisit", "self", "url", "data", "none", "timeout", "none", "return", "none", "def", "open_local_file", "self", "filename", "return", "none", "def", "reload", "self", "return", "none", "def", "response", "self", "return", "none", "def", "select_form", "self", "name", "none", "predicate", "none", "nr", "none", "attrs", "return", "none", "def", "set_cookie", "self", "cookie_string", "return", "none", "def", "set_handle_referer", "self", "handle", "return", "none", "def", "set_header", "self", "header", "value", "none", "return", "none", "def", "set_html", "self", "html", "url", "http", "example", "com", "return", "none", "def", "set_response", "self", "response", "return", "none", "def", "set_simple_cookie", "self", "name", "value", "domain", "path", "return", "none", "def", "submit", "self", "args", "kwds", "return", "none", "def", "title", "self", "return", "none", "def", "viewing_html", "self", "return", "none", "def", "visit_response", "self", "response", "request", "none", "return", "none"], "doc_len": 245}
{"doc_id": "astroid/brain/brain_multiprocessing.py::_multiprocessing_transform", "file_path": "astroid/brain/brain_multiprocessing.py", "class_name": null, "func_name": "_multiprocessing_transform", "text": "文件路径: astroid/brain/brain_multiprocessing.py\ndef _multiprocessing_transform():\n    module = parse(\n        \"\"\"\n    from multiprocessing.managers import SyncManager\n    def Manager():\n        return SyncManager()\n    \"\"\"\n    )\n    # Multiprocessing uses a getattr lookup inside contexts,\n    # in order to get the attributes they need. Since it's extremely\n    # dynamic, we use this approach to fake it.\n    node = parse(\n        \"\"\"\n    from multiprocessing.context import DefaultContext, BaseContext\n    default = DefaultContext()\n    base = BaseContext()\n    \"\"\"\n    )\n    try:\n        context = next(node[\"default\"].infer())\n        base = next(node[\"base\"].infer())\n    except (InferenceError, StopIteration):\n        return module\n\n    for node in (context, base):\n        for key, value in node.locals.items():\n            if key.startswith(\"_\"):\n                continue\n\n            value = value[0]\n            if isinstance(value, FunctionDef):\n                # We need to rebound this, since otherwise\n                # it will have an extra argument (self).\n                value = BoundMethod(value, node)\n            module[key] = value\n    return module\n", "tokens": ["astroid", "brain", "brain_multiprocessing", "py", "def", "_multiprocessing_transform", "module", "parse", "from", "multiprocessing", "managers", "import", "syncmanager", "def", "manager", "return", "syncmanager", "multiprocessing", "uses", "a", "getattr", "lookup", "inside", "contexts", "in", "order", "to", "get", "the", "attributes", "they", "need", "since", "it", "s", "extremely", "dynamic", "we", "use", "this", "approach", "to", "fake", "it", "node", "parse", "from", "multiprocessing", "context", "import", "defaultcontext", "basecontext", "default", "defaultcontext", "base", "basecontext", "try", "context", "next", "node", "default", "infer", "base", "next", "node", "base", "infer", "except", "inferenceerror", "stopiteration", "return", "module", "for", "node", "in", "context", "base", "for", "key", "value", "in", "node", "locals", "items", "if", "key", "startswith", "_", "continue", "value", "value", "0", "if", "isinstance", "value", "functiondef", "we", "need", "to", "rebound", "this", "since", "otherwise", "it", "will", "have", "an", "extra", "argument", "self", "value", "boundmethod", "value", "node", "module", "key", "value", "return", "module"], "doc_len": 119}
{"doc_id": "astroid/brain/brain_multiprocessing.py::_multiprocessing_managers_transform", "file_path": "astroid/brain/brain_multiprocessing.py", "class_name": null, "func_name": "_multiprocessing_managers_transform", "text": "文件路径: astroid/brain/brain_multiprocessing.py\ndef _multiprocessing_managers_transform():\n    return parse(\n        \"\"\"\n    import array\n    import threading\n    import multiprocessing.pool as pool\n    import queue\n\n    class Namespace(object):\n        pass\n\n    class Value(object):\n        def __init__(self, typecode, value, lock=True):\n            self._typecode = typecode\n            self._value = value\n        def get(self):\n            return self._value\n        def set(self, value):\n            self._value = value\n        def __repr__(self):\n            return '%s(%r, %r)'%(type(self).__name__, self._typecode, self._value)\n        value = property(get, set)\n\n    def Array(typecode, sequence, lock=True):\n        return array.array(typecode, sequence)\n\n    class SyncManager(object):\n        Queue = JoinableQueue = queue.Queue\n        Event = threading.Event\n        RLock = threading.RLock\n        BoundedSemaphore = threading.BoundedSemaphore\n        Condition = threading.Condition\n        Barrier = threading.Barrier\n        Pool = pool.Pool\n        list = list\n        dict = dict\n        Value = Value\n        Array = Array\n        Namespace = Namespace\n        __enter__ = lambda self: self\n        __exit__ = lambda *args: args\n\n        def start(self, initializer=None, initargs=None):\n            pass\n        def shutdown(self):\n            pass\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_multiprocessing", "py", "def", "_multiprocessing_managers_transform", "return", "parse", "import", "array", "import", "threading", "import", "multiprocessing", "pool", "as", "pool", "import", "queue", "class", "namespace", "object", "pass", "class", "value", "object", "def", "__init__", "self", "typecode", "value", "lock", "true", "self", "_typecode", "typecode", "self", "_value", "value", "def", "get", "self", "return", "self", "_value", "def", "set", "self", "value", "self", "_value", "value", "def", "__repr__", "self", "return", "s", "r", "r", "type", "self", "__name__", "self", "_typecode", "self", "_value", "value", "property", "get", "set", "def", "array", "typecode", "sequence", "lock", "true", "return", "array", "array", "typecode", "sequence", "class", "syncmanager", "object", "queue", "joinablequeue", "queue", "queue", "event", "threading", "event", "rlock", "threading", "rlock", "boundedsemaphore", "threading", "boundedsemaphore", "condition", "threading", "condition", "barrier", "threading", "barrier", "pool", "pool", "pool", "list", "list", "dict", "dict", "value", "value", "array", "array", "namespace", "namespace", "__enter__", "lambda", "self", "self", "__exit__", "lambda", "args", "args", "def", "start", "self", "initializer", "none", "initargs", "none", "pass", "def", "shutdown", "self", "pass"], "doc_len": 136}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_infer_first", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_infer_first", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _infer_first(node, context):\n    if node is util.Uninferable:\n        raise UseInferenceDefault\n    try:\n        value = next(node.infer(context=context))\n    except StopIteration as exc:\n        raise InferenceError from exc\n    if value is util.Uninferable:\n        raise UseInferenceDefault()\n    return value\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_infer_first", "node", "context", "if", "node", "is", "util", "uninferable", "raise", "useinferencedefault", "try", "value", "next", "node", "infer", "context", "context", "except", "stopiteration", "as", "exc", "raise", "inferenceerror", "from", "exc", "if", "value", "is", "util", "uninferable", "raise", "useinferencedefault", "return", "value"], "doc_len": 39}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_find_func_form_arguments", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_find_func_form_arguments", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _find_func_form_arguments(node, context):\n    def _extract_namedtuple_arg_or_keyword(  # pylint: disable=inconsistent-return-statements\n        position, key_name=None\n    ):\n        if len(args) > position:\n            return _infer_first(args[position], context)\n        if key_name and key_name in found_keywords:\n            return _infer_first(found_keywords[key_name], context)\n\n    args = node.args\n    keywords = node.keywords\n    found_keywords = (\n        {keyword.arg: keyword.value for keyword in keywords} if keywords else {}\n    )\n\n    name = _extract_namedtuple_arg_or_keyword(position=0, key_name=\"typename\")\n    names = _extract_namedtuple_arg_or_keyword(position=1, key_name=\"field_names\")\n    if name and names:\n        return name.value, names\n\n    raise UseInferenceDefault()\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_find_func_form_arguments", "node", "context", "def", "_extract_namedtuple_arg_or_keyword", "pylint", "disable", "inconsistent", "return", "statements", "position", "key_name", "none", "if", "len", "args", "position", "return", "_infer_first", "args", "position", "context", "if", "key_name", "and", "key_name", "in", "found_keywords", "return", "_infer_first", "found_keywords", "key_name", "context", "args", "node", "args", "keywords", "node", "keywords", "found_keywords", "keyword", "arg", "keyword", "value", "for", "keyword", "in", "keywords", "if", "keywords", "else", "name", "_extract_namedtuple_arg_or_keyword", "position", "0", "key_name", "typename", "names", "_extract_namedtuple_arg_or_keyword", "position", "1", "key_name", "field_names", "if", "name", "and", "names", "return", "name", "value", "names", "raise", "useinferencedefault"], "doc_len": 78}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_func_form", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_func_form", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_func_form(node, base_type, context=None, enum=False):\n    \"\"\"Specific inference function for namedtuple or Python 3 enum.\"\"\"\n    # node is a Call node, class name as first argument and generated class\n    # attributes as second argument\n\n    # namedtuple or enums list of attributes can be a list of strings or a\n    # whitespace-separate string\n    try:\n        name, names = _find_func_form_arguments(node, context)\n        try:\n            attributes = names.value.replace(\",\", \" \").split()\n        except AttributeError as exc:\n            if not enum:\n                attributes = [\n                    _infer_first(const, context).value for const in names.elts\n                ]\n            else:\n                # Enums supports either iterator of (name, value) pairs\n                # or mappings.\n                if hasattr(names, \"items\") and isinstance(names.items, list):\n                    attributes = [\n                        _infer_first(const[0], context).value\n                        for const in names.items\n                        if isinstance(const[0], nodes.Const)\n                    ]\n                elif hasattr(names, \"elts\"):\n                    # Enums can support either [\"a\", \"b\", \"c\"]\n                    # or [(\"a\", 1), (\"b\", 2), ...], but they can't\n                    # be mixed.\n                    if all(isinstance(const, nodes.Tuple) for const in names.elts):\n                        attributes = [\n                            _infer_first(const.elts[0], context).value\n                            for const in names.elts\n                            if isinstance(const, nodes.Tuple)\n                        ]\n                    else:\n                        attributes = [\n                            _infer_first(const, context).value for const in names.elts\n                        ]\n                else:\n                    raise AttributeError from exc\n                if not attributes:\n                    raise AttributeError from exc\n    except (AttributeError, InferenceError) as exc:\n        raise UseInferenceDefault from exc\n\n    if not enum:\n        # namedtuple maps sys.intern(str()) over over field_names\n        attributes = [str(attr) for attr in attributes]\n        # XXX this should succeed *unless* __str__/__repr__ is incorrect or throws\n        # in which case we should not have inferred these values and raised earlier\n    attributes = [attr for attr in attributes if \" \" not in attr]\n\n    # If we can't infer the name of the class, don't crash, up to this point\n    # we know it is a namedtuple anyway.\n    name = name or \"Uninferable\"\n    # we want to return a Class node instance with proper attributes set\n    class_node = nodes.ClassDef(name, \"docstring\")\n    class_node.parent = node.parent\n    # set base class=tuple\n    class_node.bases.append(base_type)\n    # XXX add __init__(*attributes) method\n    for attr in attributes:\n        fake_node = nodes.EmptyNode()\n        fake_node.parent = class_node\n        fake_node.attrname = attr\n        class_node.instance_attrs[attr] = [fake_node]\n    return class_node, name, attributes\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_func_form", "node", "base_type", "context", "none", "enum", "false", "specific", "inference", "function", "for", "namedtuple", "or", "python", "3", "enum", "node", "is", "a", "call", "node", "class", "name", "as", "first", "argument", "and", "generated", "class", "attributes", "as", "second", "argument", "namedtuple", "or", "enums", "list", "of", "attributes", "can", "be", "a", "list", "of", "strings", "or", "a", "whitespace", "separate", "string", "try", "name", "names", "_find_func_form_arguments", "node", "context", "try", "attributes", "names", "value", "replace", "split", "except", "attributeerror", "as", "exc", "if", "not", "enum", "attributes", "_infer_first", "const", "context", "value", "for", "const", "in", "names", "elts", "else", "enums", "supports", "either", "iterator", "of", "name", "value", "pairs", "or", "mappings", "if", "hasattr", "names", "items", "and", "isinstance", "names", "items", "list", "attributes", "_infer_first", "const", "0", "context", "value", "for", "const", "in", "names", "items", "if", "isinstance", "const", "0", "nodes", "const", "elif", "hasattr", "names", "elts", "enums", "can", "support", "either", "a", "b", "c", "or", "a", "1", "b", "2", "but", "they", "can", "t", "be", "mixed", "if", "all", "isinstance", "const", "nodes", "tuple", "for", "const", "in", "names", "elts", "attributes", "_infer_first", "const", "elts", "0", "context", "value", "for", "const", "in", "names", "elts", "if", "isinstance", "const", "nodes", "tuple", "else", "attributes", "_infer_first", "const", "context", "value", "for", "const", "in", "names", "elts", "else", "raise", "attributeerror", "from", "exc", "if", "not", "attributes", "raise", "attributeerror", "from", "exc", "except", "attributeerror", "inferenceerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "not", "enum", "namedtuple", "maps", "sys", "intern", "str", "over", "over", "field_names", "attributes", "str", "attr", "for", "attr", "in", "attributes", "xxx", "this", "should", "succeed", "unless", "__str__", "__repr__", "is", "incorrect", "or", "throws", "in", "which", "case", "we", "should", "not", "have", "inferred", "these", "values", "and", "raised", "earlier", "attributes", "attr", "for", "attr", "in", "attributes", "if", "not", "in", "attr", "if", "we", "can", "t", "infer", "the", "name", "of", "the", "class", "don", "t", "crash", "up", "to", "this", "point", "we", "know", "it", "is", "a", "namedtuple", "anyway", "name", "name", "or", "uninferable", "we", "want", "to", "return", "a", "class", "node", "instance", "with", "proper", "attributes", "set", "class_node", "nodes", "classdef", "name", "docstring", "class_node", "parent", "node", "parent", "set", "base", "class", "tuple", "class_node", "bases", "append", "base_type", "xxx", "add", "__init__", "attributes", "method", "for", "attr", "in", "attributes", "fake_node", "nodes", "emptynode", "fake_node", "parent", "class_node", "fake_node", "attrname", "attr", "class_node", "instance_attrs", "attr", "fake_node", "return", "class_node", "name", "attributes"], "doc_len": 338}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_has_namedtuple_base", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_has_namedtuple_base", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _has_namedtuple_base(node):\n    \"\"\"Predicate for class inference tip\n\n    :type node: ClassDef\n    :rtype: bool\n    \"\"\"\n    return set(node.basenames) & TYPING_NAMEDTUPLE_BASENAMES\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_has_namedtuple_base", "node", "predicate", "for", "class", "inference", "tip", "type", "node", "classdef", "rtype", "bool", "return", "set", "node", "basenames", "typing_namedtuple_basenames"], "doc_len": 22}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_looks_like", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_looks_like", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _looks_like(node, name):\n    func = node.func\n    if isinstance(func, nodes.Attribute):\n        return func.attrname == name\n    if isinstance(func, nodes.Name):\n        return func.name == name\n    return False\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_looks_like", "node", "name", "func", "node", "func", "if", "isinstance", "func", "nodes", "attribute", "return", "func", "attrname", "name", "if", "isinstance", "func", "nodes", "name", "return", "func", "name", "name", "return", "false"], "doc_len": 31}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_named_tuple", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_named_tuple", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_named_tuple(node, context=None):\n    \"\"\"Specific inference function for namedtuple Call node\"\"\"\n    tuple_base_name = nodes.Name(name=\"tuple\", parent=node.root())\n    class_node, name, attributes = infer_func_form(\n        node, tuple_base_name, context=context\n    )\n    call_site = arguments.CallSite.from_call(node, context=context)\n    node = extract_node(\"import collections; collections.namedtuple\")\n    try:\n\n        func = next(node.infer())\n    except StopIteration as e:\n        raise InferenceError(node=node) from e\n    try:\n        rename = next(call_site.infer_argument(func, \"rename\", context)).bool_value()\n    except (InferenceError, StopIteration):\n        rename = False\n\n    try:\n        attributes = _check_namedtuple_attributes(name, attributes, rename)\n    except AstroidTypeError as exc:\n        raise UseInferenceDefault(\"TypeError: \" + str(exc)) from exc\n    except AstroidValueError as exc:\n        raise UseInferenceDefault(\"ValueError: \" + str(exc)) from exc\n\n    replace_args = \", \".join(f\"{arg}=None\" for arg in attributes)\n    field_def = (\n        \"    {name} = property(lambda self: self[{index:d}], \"\n        \"doc='Alias for field number {index:d}')\"\n    )\n    field_defs = \"\\n\".join(\n        field_def.format(name=name, index=index)\n        for index, name in enumerate(attributes)\n    )\n    fake = AstroidBuilder(AstroidManager()).string_build(\n        f\"\"\"\nclass {name}(tuple):\n    __slots__ = ()\n    _fields = {attributes!r}\n    def _asdict(self):\n        return self.__dict__\n    @classmethod\n    def _make(cls, iterable, new=tuple.__new__, len=len):\n        return new(cls, iterable)\n    def _replace(self, {replace_args}):\n        return self\n    def __getnewargs__(self):\n        return tuple(self)\n{field_defs}\n    \"\"\"\n    )\n    class_node.locals[\"_asdict\"] = fake.body[0].locals[\"_asdict\"]\n    class_node.locals[\"_make\"] = fake.body[0].locals[\"_make\"]\n    class_node.locals[\"_replace\"] = fake.body[0].locals[\"_replace\"]\n    class_node.locals[\"_fields\"] = fake.body[0].locals[\"_fields\"]\n    for attr in attributes:\n        class_node.locals[attr] = fake.body[0].locals[attr]\n    # we use UseInferenceDefault, we can't be a generator so return an iterator\n    return iter([class_node])\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_named_tuple", "node", "context", "none", "specific", "inference", "function", "for", "namedtuple", "call", "node", "tuple_base_name", "nodes", "name", "name", "tuple", "parent", "node", "root", "class_node", "name", "attributes", "infer_func_form", "node", "tuple_base_name", "context", "context", "call_site", "arguments", "callsite", "from_call", "node", "context", "context", "node", "extract_node", "import", "collections", "collections", "namedtuple", "try", "func", "next", "node", "infer", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "from", "e", "try", "rename", "next", "call_site", "infer_argument", "func", "rename", "context", "bool_value", "except", "inferenceerror", "stopiteration", "rename", "false", "try", "attributes", "_check_namedtuple_attributes", "name", "attributes", "rename", "except", "astroidtypeerror", "as", "exc", "raise", "useinferencedefault", "typeerror", "str", "exc", "from", "exc", "except", "astroidvalueerror", "as", "exc", "raise", "useinferencedefault", "valueerror", "str", "exc", "from", "exc", "replace_args", "join", "f", "arg", "none", "for", "arg", "in", "attributes", "field_def", "name", "property", "lambda", "self", "self", "index", "d", "doc", "alias", "for", "field", "number", "index", "d", "field_defs", "n", "join", "field_def", "format", "name", "name", "index", "index", "for", "index", "name", "in", "enumerate", "attributes", "fake", "astroidbuilder", "astroidmanager", "string_build", "f", "class", "name", "tuple", "__slots__", "_fields", "attributes", "r", "def", "_asdict", "self", "return", "self", "__dict__", "classmethod", "def", "_make", "cls", "iterable", "new", "tuple", "__new__", "len", "len", "return", "new", "cls", "iterable", "def", "_replace", "self", "replace_args", "return", "self", "def", "__getnewargs__", "self", "return", "tuple", "self", "field_defs", "class_node", "locals", "_asdict", "fake", "body", "0", "locals", "_asdict", "class_node", "locals", "_make", "fake", "body", "0", "locals", "_make", "class_node", "locals", "_replace", "fake", "body", "0", "locals", "_replace", "class_node", "locals", "_fields", "fake", "body", "0", "locals", "_fields", "for", "attr", "in", "attributes", "class_node", "locals", "attr", "fake", "body", "0", "locals", "attr", "we", "use", "useinferencedefault", "we", "can", "t", "be", "a", "generator", "so", "return", "an", "iterator", "return", "iter", "class_node"], "doc_len": 246}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_get_renamed_namedtuple_attributes", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_get_renamed_namedtuple_attributes", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _get_renamed_namedtuple_attributes(field_names):\n    names = list(field_names)\n    seen = set()\n    for i, name in enumerate(field_names):\n        if (\n            not all(c.isalnum() or c == \"_\" for c in name)\n            or keyword.iskeyword(name)\n            or not name\n            or name[0].isdigit()\n            or name.startswith(\"_\")\n            or name in seen\n        ):\n            names[i] = \"_%d\" % i\n        seen.add(name)\n    return tuple(names)\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_get_renamed_namedtuple_attributes", "field_names", "names", "list", "field_names", "seen", "set", "for", "i", "name", "in", "enumerate", "field_names", "if", "not", "all", "c", "isalnum", "or", "c", "_", "for", "c", "in", "name", "or", "keyword", "iskeyword", "name", "or", "not", "name", "or", "name", "0", "isdigit", "or", "name", "startswith", "_", "or", "name", "in", "seen", "names", "i", "_", "d", "i", "seen", "add", "name", "return", "tuple", "names"], "doc_len": 60}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_check_namedtuple_attributes", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_check_namedtuple_attributes", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _check_namedtuple_attributes(typename, attributes, rename=False):\n    attributes = tuple(attributes)\n    if rename:\n        attributes = _get_renamed_namedtuple_attributes(attributes)\n\n    # The following snippet is derived from the CPython Lib/collections/__init__.py sources\n    # <snippet>\n    for name in (typename,) + attributes:\n        if not isinstance(name, str):\n            raise AstroidTypeError(\"Type names and field names must be strings\")\n        if not name.isidentifier():\n            raise AstroidValueError(\n                \"Type names and field names must be valid\" + f\"identifiers: {name!r}\"\n            )\n        if keyword.iskeyword(name):\n            raise AstroidValueError(\n                f\"Type names and field names cannot be a keyword: {name!r}\"\n            )\n\n    seen = set()\n    for name in attributes:\n        if name.startswith(\"_\") and not rename:\n            raise AstroidValueError(\n                f\"Field names cannot start with an underscore: {name!r}\"\n            )\n        if name in seen:\n            raise AstroidValueError(f\"Encountered duplicate field name: {name!r}\")\n        seen.add(name)\n    # </snippet>\n\n    return attributes\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_check_namedtuple_attributes", "typename", "attributes", "rename", "false", "attributes", "tuple", "attributes", "if", "rename", "attributes", "_get_renamed_namedtuple_attributes", "attributes", "the", "following", "snippet", "is", "derived", "from", "the", "cpython", "lib", "collections", "__init__", "py", "sources", "snippet", "for", "name", "in", "typename", "attributes", "if", "not", "isinstance", "name", "str", "raise", "astroidtypeerror", "type", "names", "and", "field", "names", "must", "be", "strings", "if", "not", "name", "isidentifier", "raise", "astroidvalueerror", "type", "names", "and", "field", "names", "must", "be", "valid", "f", "identifiers", "name", "r", "if", "keyword", "iskeyword", "name", "raise", "astroidvalueerror", "f", "type", "names", "and", "field", "names", "cannot", "be", "a", "keyword", "name", "r", "seen", "set", "for", "name", "in", "attributes", "if", "name", "startswith", "_", "and", "not", "rename", "raise", "astroidvalueerror", "f", "field", "names", "cannot", "start", "with", "an", "underscore", "name", "r", "if", "name", "in", "seen", "raise", "astroidvalueerror", "f", "encountered", "duplicate", "field", "name", "name", "r", "seen", "add", "name", "snippet", "return", "attributes"], "doc_len": 132}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_enum", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_enum", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_enum(node, context=None):\n    \"\"\"Specific inference function for enum Call node.\"\"\"\n    enum_meta = extract_node(\n        \"\"\"\n    class EnumMeta(object):\n        'docstring'\n        def __call__(self, node):\n            class EnumAttribute(object):\n                name = ''\n                value = 0\n            return EnumAttribute()\n        def __iter__(self):\n            class EnumAttribute(object):\n                name = ''\n                value = 0\n            return [EnumAttribute()]\n        def __reversed__(self):\n            class EnumAttribute(object):\n                name = ''\n                value = 0\n            return (EnumAttribute, )\n        def __next__(self):\n            return next(iter(self))\n        def __getitem__(self, attr):\n            class Value(object):\n                @property\n                def name(self):\n                    return ''\n                @property\n                def value(self):\n                    return attr\n\n            return Value()\n        __members__ = ['']\n    \"\"\"\n    )\n    class_node = infer_func_form(node, enum_meta, context=context, enum=True)[0]\n    return iter([class_node.instantiate_class()])\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_enum", "node", "context", "none", "specific", "inference", "function", "for", "enum", "call", "node", "enum_meta", "extract_node", "class", "enummeta", "object", "docstring", "def", "__call__", "self", "node", "class", "enumattribute", "object", "name", "value", "0", "return", "enumattribute", "def", "__iter__", "self", "class", "enumattribute", "object", "name", "value", "0", "return", "enumattribute", "def", "__reversed__", "self", "class", "enumattribute", "object", "name", "value", "0", "return", "enumattribute", "def", "__next__", "self", "return", "next", "iter", "self", "def", "__getitem__", "self", "attr", "class", "value", "object", "property", "def", "name", "self", "return", "property", "def", "value", "self", "return", "attr", "return", "value", "__members__", "class_node", "infer_func_form", "node", "enum_meta", "context", "context", "enum", "true", "0", "return", "iter", "class_node", "instantiate_class"], "doc_len": 97}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_enum_class", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_enum_class", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_enum_class(node):\n    \"\"\"Specific inference for enums.\"\"\"\n    for basename in (b for cls in node.mro() for b in cls.basenames):\n        if basename not in ENUM_BASE_NAMES:\n            continue\n        if node.root().name == \"enum\":\n            # Skip if the class is directly from enum module.\n            break\n        dunder_members = {}\n        target_names = set()\n        for local, values in node.locals.items():\n            if any(not isinstance(value, nodes.AssignName) for value in values):\n                continue\n\n            stmt = values[0].statement(future=True)\n            if isinstance(stmt, nodes.Assign):\n                if isinstance(stmt.targets[0], nodes.Tuple):\n                    targets = stmt.targets[0].itered()\n                else:\n                    targets = stmt.targets\n            elif isinstance(stmt, nodes.AnnAssign):\n                targets = [stmt.target]\n            else:\n                continue\n\n            inferred_return_value = None\n            if isinstance(stmt, nodes.Assign):\n                if isinstance(stmt.value, nodes.Const):\n                    if isinstance(stmt.value.value, str):\n                        inferred_return_value = repr(stmt.value.value)\n                    else:\n                        inferred_return_value = stmt.value.value\n                else:\n                    inferred_return_value = stmt.value.as_string()\n\n            new_targets = []\n            for target in targets:\n                if isinstance(target, nodes.Starred):\n                    continue\n                target_names.add(target.name)\n                # Replace all the assignments with our mocked class.\n                classdef = dedent(\n                    \"\"\"\n                class {name}({types}):\n                    @property\n                    def value(self):\n                        return {return_value}\n                    @property\n                    def name(self):\n                        return \"{name}\"\n                \"\"\".format(\n                        name=target.name,\n                        types=\", \".join(node.basenames),\n                        return_value=inferred_return_value,\n                    )\n                )\n                if \"IntFlag\" in basename:\n                    # Alright, we need to add some additional methods.\n                    # Unfortunately we still can't infer the resulting objects as\n                    # Enum members, but once we'll be able to do that, the following\n                    # should result in some nice symbolic execution\n                    classdef += INT_FLAG_ADDITION_METHODS.format(name=target.name)\n\n                fake = AstroidBuilder(\n                    AstroidManager(), apply_transforms=False\n                ).string_build(classdef)[target.name]\n                fake.parent = target.parent\n                for method in node.mymethods():\n                    fake.locals[method.name] = [method]\n                new_targets.append(fake.instantiate_class())\n                dunder_members[local] = fake\n            node.locals[local] = new_targets\n        members = nodes.Dict(parent=node)\n        members.postinit(\n            [\n                (nodes.Const(k, parent=members), nodes.Name(v.name, parent=members))\n                for k, v in dunder_members.items()\n            ]\n        )\n        node.locals[\"__members__\"] = [members]\n        # The enum.Enum class itself defines two @DynamicClassAttribute data-descriptors\n        # \"name\" and \"value\" (which we override in the mocked class for each enum member\n        # above). When dealing with inference of an arbitrary instance of the enum\n        # class, e.g. in a method defined in the class body like:\n        #     class SomeEnum(enum.Enum):\n        #         def method(self):\n        #             self.name  # <- here\n        # In the absence of an enum member called \"name\" or \"value\", these attributes\n        # should resolve to the descriptor on that particular instance, i.e. enum member.\n        # For \"value\", we have no idea what that should be, but for \"name\", we at least\n        # know that it should be a string, so infer that as a guess.\n        if \"name\" not in target_names:\n            code = dedent(\n                \"\"\"\n            @property\n            def name(self):\n                return ''\n            \"\"\"\n            )\n            name_dynamicclassattr = AstroidBuilder(AstroidManager()).string_build(code)[\n                \"name\"\n            ]\n            node.locals[\"name\"] = [name_dynamicclassattr]\n        break\n    return node\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_enum_class", "node", "specific", "inference", "for", "enums", "for", "basename", "in", "b", "for", "cls", "in", "node", "mro", "for", "b", "in", "cls", "basenames", "if", "basename", "not", "in", "enum_base_names", "continue", "if", "node", "root", "name", "enum", "skip", "if", "the", "class", "is", "directly", "from", "enum", "module", "break", "dunder_members", "target_names", "set", "for", "local", "values", "in", "node", "locals", "items", "if", "any", "not", "isinstance", "value", "nodes", "assignname", "for", "value", "in", "values", "continue", "stmt", "values", "0", "statement", "future", "true", "if", "isinstance", "stmt", "nodes", "assign", "if", "isinstance", "stmt", "targets", "0", "nodes", "tuple", "targets", "stmt", "targets", "0", "itered", "else", "targets", "stmt", "targets", "elif", "isinstance", "stmt", "nodes", "annassign", "targets", "stmt", "target", "else", "continue", "inferred_return_value", "none", "if", "isinstance", "stmt", "nodes", "assign", "if", "isinstance", "stmt", "value", "nodes", "const", "if", "isinstance", "stmt", "value", "value", "str", "inferred_return_value", "repr", "stmt", "value", "value", "else", "inferred_return_value", "stmt", "value", "value", "else", "inferred_return_value", "stmt", "value", "as_string", "new_targets", "for", "target", "in", "targets", "if", "isinstance", "target", "nodes", "starred", "continue", "target_names", "add", "target", "name", "replace", "all", "the", "assignments", "with", "our", "mocked", "class", "classdef", "dedent", "class", "name", "types", "property", "def", "value", "self", "return", "return_value", "property", "def", "name", "self", "return", "name", "format", "name", "target", "name", "types", "join", "node", "basenames", "return_value", "inferred_return_value", "if", "intflag", "in", "basename", "alright", "we", "need", "to", "add", "some", "additional", "methods", "unfortunately", "we", "still", "can", "t", "infer", "the", "resulting", "objects", "as", "enum", "members", "but", "once", "we", "ll", "be", "able", "to", "do", "that", "the", "following", "should", "result", "in", "some", "nice", "symbolic", "execution", "classdef", "int_flag_addition_methods", "format", "name", "target", "name", "fake", "astroidbuilder", "astroidmanager", "apply_transforms", "false", "string_build", "classdef", "target", "name", "fake", "parent", "target", "parent", "for", "method", "in", "node", "mymethods", "fake", "locals", "method", "name", "method", "new_targets", "append", "fake", "instantiate_class", "dunder_members", "local", "fake", "node", "locals", "local", "new_targets", "members", "nodes", "dict", "parent", "node", "members", "postinit", "nodes", "const", "k", "parent", "members", "nodes", "name", "v", "name", "parent", "members", "for", "k", "v", "in", "dunder_members", "items", "node", "locals", "__members__", "members", "the", "enum", "enum", "class", "itself", "defines", "two", "dynamicclassattribute", "data", "descriptors", "name", "and", "value", "which", "we", "override", "in", "the", "mocked", "class", "for", "each", "enum", "member", "above", "when", "dealing", "with", "inference", "of", "an", "arbitrary", "instance", "of", "the", "enum", "class", "e", "g", "in", "a", "method", "defined", "in", "the", "class", "body", "like", "class", "someenum", "enum", "enum", "def", "method", "self", "self", "name", "here", "in", "the", "absence", "of", "an", "enum", "member", "called", "name", "or", "value", "these", "attributes", "should", "resolve", "to", "the", "descriptor", "on", "that", "particular", "instance", "i", "e", "enum", "member", "for", "value", "we", "have", "no", "idea", "what", "that", "should", "be", "but", "for", "name", "we", "at", "least", "know", "that", "it", "should", "be", "a", "string", "so", "infer", "that", "as", "a", "guess", "if", "name", "not", "in", "target_names", "code", "dedent", "property", "def", "name", "self", "return", "name_dynamicclassattr", "astroidbuilder", "astroidmanager", "string_build", "code", "name", "node", "locals", "name", "name_dynamicclassattr", "break", "return", "node"], "doc_len": 437}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_typing_namedtuple_class", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_typing_namedtuple_class", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_typing_namedtuple_class(class_node, context=None):\n    \"\"\"Infer a subclass of typing.NamedTuple\"\"\"\n    # Check if it has the corresponding bases\n    annassigns_fields = [\n        annassign.target.name\n        for annassign in class_node.body\n        if isinstance(annassign, nodes.AnnAssign)\n    ]\n    code = dedent(\n        \"\"\"\n    from collections import namedtuple\n    namedtuple({typename!r}, {fields!r})\n    \"\"\"\n    ).format(typename=class_node.name, fields=\",\".join(annassigns_fields))\n    node = extract_node(code)\n    try:\n        generated_class_node = next(infer_named_tuple(node, context))\n    except StopIteration as e:\n        raise InferenceError(node=node, context=context) from e\n    for method in class_node.mymethods():\n        generated_class_node.locals[method.name] = [method]\n\n    for body_node in class_node.body:\n        if isinstance(body_node, nodes.Assign):\n            for target in body_node.targets:\n                attr = target.name\n                generated_class_node.locals[attr] = class_node.locals[attr]\n        elif isinstance(body_node, nodes.ClassDef):\n            generated_class_node.locals[body_node.name] = [body_node]\n\n    return iter((generated_class_node,))\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_typing_namedtuple_class", "class_node", "context", "none", "infer", "a", "subclass", "of", "typing", "namedtuple", "check", "if", "it", "has", "the", "corresponding", "bases", "annassigns_fields", "annassign", "target", "name", "for", "annassign", "in", "class_node", "body", "if", "isinstance", "annassign", "nodes", "annassign", "code", "dedent", "from", "collections", "import", "namedtuple", "namedtuple", "typename", "r", "fields", "r", "format", "typename", "class_node", "name", "fields", "join", "annassigns_fields", "node", "extract_node", "code", "try", "generated_class_node", "next", "infer_named_tuple", "node", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "context", "context", "from", "e", "for", "method", "in", "class_node", "mymethods", "generated_class_node", "locals", "method", "name", "method", "for", "body_node", "in", "class_node", "body", "if", "isinstance", "body_node", "nodes", "assign", "for", "target", "in", "body_node", "targets", "attr", "target", "name", "generated_class_node", "locals", "attr", "class_node", "locals", "attr", "elif", "isinstance", "body_node", "nodes", "classdef", "generated_class_node", "locals", "body_node", "name", "body_node", "return", "iter", "generated_class_node"], "doc_len": 122}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_typing_namedtuple_function", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_typing_namedtuple_function", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_typing_namedtuple_function(node, context=None):\n    \"\"\"\n    Starting with python3.9, NamedTuple is a function of the typing module.\n    The class NamedTuple is build dynamically through a call to `type` during\n    initialization of the `_NamedTuple` variable.\n    \"\"\"\n    klass = extract_node(\n        \"\"\"\n        from typing import _NamedTuple\n        _NamedTuple\n        \"\"\"\n    )\n    return klass.infer(context)\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_typing_namedtuple_function", "node", "context", "none", "starting", "with", "python3", "9", "namedtuple", "is", "a", "function", "of", "the", "typing", "module", "the", "class", "namedtuple", "is", "build", "dynamically", "through", "a", "call", "to", "type", "during", "initialization", "of", "the", "_namedtuple", "variable", "klass", "extract_node", "from", "typing", "import", "_namedtuple", "_namedtuple", "return", "klass", "infer", "context"], "doc_len": 49}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::infer_typing_namedtuple", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "infer_typing_namedtuple", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef infer_typing_namedtuple(node, context=None):\n    \"\"\"Infer a typing.NamedTuple(...) call.\"\"\"\n    # This is essentially a namedtuple with different arguments\n    # so we extract the args and infer a named tuple.\n    try:\n        func = next(node.func.infer())\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n\n    if func.qname() != \"typing.NamedTuple\":\n        raise UseInferenceDefault\n\n    if len(node.args) != 2:\n        raise UseInferenceDefault\n\n    if not isinstance(node.args[1], (nodes.List, nodes.Tuple)):\n        raise UseInferenceDefault\n\n    names = []\n    for elt in node.args[1].elts:\n        if not isinstance(elt, (nodes.List, nodes.Tuple)):\n            raise UseInferenceDefault\n        if len(elt.elts) != 2:\n            raise UseInferenceDefault\n        names.append(elt.elts[0].as_string())\n\n    typename = node.args[0].as_string()\n    if names:\n        field_names = f\"({','.join(names)},)\"\n    else:\n        field_names = \"''\"\n    node = extract_node(f\"namedtuple({typename}, {field_names})\")\n    return infer_named_tuple(node, context)\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "infer_typing_namedtuple", "node", "context", "none", "infer", "a", "typing", "namedtuple", "call", "this", "is", "essentially", "a", "namedtuple", "with", "different", "arguments", "so", "we", "extract", "the", "args", "and", "infer", "a", "named", "tuple", "try", "func", "next", "node", "func", "infer", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "func", "qname", "typing", "namedtuple", "raise", "useinferencedefault", "if", "len", "node", "args", "2", "raise", "useinferencedefault", "if", "not", "isinstance", "node", "args", "1", "nodes", "list", "nodes", "tuple", "raise", "useinferencedefault", "names", "for", "elt", "in", "node", "args", "1", "elts", "if", "not", "isinstance", "elt", "nodes", "list", "nodes", "tuple", "raise", "useinferencedefault", "if", "len", "elt", "elts", "2", "raise", "useinferencedefault", "names", "append", "elt", "elts", "0", "as_string", "typename", "node", "args", "0", "as_string", "if", "names", "field_names", "f", "join", "names", "else", "field_names", "node", "extract_node", "f", "namedtuple", "typename", "field_names", "return", "infer_named_tuple", "node", "context"], "doc_len": 127}
{"doc_id": "astroid/brain/brain_namedtuple_enum.py::_is_enum_subclass", "file_path": "astroid/brain/brain_namedtuple_enum.py", "class_name": null, "func_name": "_is_enum_subclass", "text": "文件路径: astroid/brain/brain_namedtuple_enum.py\ndef _is_enum_subclass(cls: astroid.ClassDef) -> bool:\n    \"\"\"Return whether cls is a subclass of an Enum.\"\"\"\n    try:\n        return any(\n            klass.name in ENUM_BASE_NAMES\n            and getattr(klass.root(), \"name\", None) == \"enum\"\n            for klass in cls.mro()\n        )\n    except MroError:\n        return False\n", "tokens": ["astroid", "brain", "brain_namedtuple_enum", "py", "def", "_is_enum_subclass", "cls", "astroid", "classdef", "bool", "return", "whether", "cls", "is", "a", "subclass", "of", "an", "enum", "try", "return", "any", "klass", "name", "in", "enum_base_names", "and", "getattr", "klass", "root", "name", "none", "enum", "for", "klass", "in", "cls", "mro", "except", "mroerror", "return", "false"], "doc_len": 42}
{"doc_id": "astroid/brain/brain_nose.py::_pep8", "file_path": "astroid/brain/brain_nose.py", "class_name": null, "func_name": "_pep8", "text": "文件路径: astroid/brain/brain_nose.py\ndef _pep8(name, caps=CAPITALS):\n    return caps.sub(lambda m: \"_\" + m.groups()[0].lower(), name)\n", "tokens": ["astroid", "brain", "brain_nose", "py", "def", "_pep8", "name", "caps", "capitals", "return", "caps", "sub", "lambda", "m", "_", "m", "groups", "0", "lower", "name"], "doc_len": 20}
{"doc_id": "astroid/brain/brain_nose.py::_nose_tools_functions", "file_path": "astroid/brain/brain_nose.py", "class_name": null, "func_name": "_nose_tools_functions", "text": "文件路径: astroid/brain/brain_nose.py\ndef _nose_tools_functions():\n    \"\"\"Get an iterator of names and bound methods.\"\"\"\n    module = _BUILDER.string_build(\n        textwrap.dedent(\n            \"\"\"\n    import unittest\n\n    class Test(unittest.TestCase):\n        pass\n    a = Test()\n    \"\"\"\n        )\n    )\n    try:\n        case = next(module[\"a\"].infer())\n    except (InferenceError, StopIteration):\n        return\n    for method in case.methods():\n        if method.name.startswith(\"assert\") and \"_\" not in method.name:\n            pep8_name = _pep8(method.name)\n            yield pep8_name, astroid.BoundMethod(method, case)\n        if method.name == \"assertEqual\":\n            # nose also exports assert_equals.\n            yield \"assert_equals\", astroid.BoundMethod(method, case)\n", "tokens": ["astroid", "brain", "brain_nose", "py", "def", "_nose_tools_functions", "get", "an", "iterator", "of", "names", "and", "bound", "methods", "module", "_builder", "string_build", "textwrap", "dedent", "import", "unittest", "class", "test", "unittest", "testcase", "pass", "a", "test", "try", "case", "next", "module", "a", "infer", "except", "inferenceerror", "stopiteration", "return", "for", "method", "in", "case", "methods", "if", "method", "name", "startswith", "assert", "and", "_", "not", "in", "method", "name", "pep8_name", "_pep8", "method", "name", "yield", "pep8_name", "astroid", "boundmethod", "method", "case", "if", "method", "name", "assertequal", "nose", "also", "exports", "assert_equals", "yield", "assert_equals", "astroid", "boundmethod", "method", "case"], "doc_len": 78}
{"doc_id": "astroid/brain/brain_nose.py::_nose_tools_transform", "file_path": "astroid/brain/brain_nose.py", "class_name": null, "func_name": "_nose_tools_transform", "text": "文件路径: astroid/brain/brain_nose.py\ndef _nose_tools_transform(node):\n    for method_name, method in _nose_tools_functions():\n        node.locals[method_name] = [method]\n", "tokens": ["astroid", "brain", "brain_nose", "py", "def", "_nose_tools_transform", "node", "for", "method_name", "method", "in", "_nose_tools_functions", "node", "locals", "method_name", "method"], "doc_len": 16}
{"doc_id": "astroid/brain/brain_nose.py::_nose_tools_trivial_transform", "file_path": "astroid/brain/brain_nose.py", "class_name": null, "func_name": "_nose_tools_trivial_transform", "text": "文件路径: astroid/brain/brain_nose.py\ndef _nose_tools_trivial_transform():\n    \"\"\"Custom transform for the nose.tools module.\"\"\"\n    stub = _BUILDER.string_build(\"\"\"__all__ = []\"\"\")\n    all_entries = [\"ok_\", \"eq_\"]\n\n    for pep8_name, method in _nose_tools_functions():\n        all_entries.append(pep8_name)\n        stub[pep8_name] = method\n\n    # Update the __all__ variable, since nose.tools\n    # does this manually with .append.\n    all_assign = stub[\"__all__\"].parent\n    all_object = astroid.List(all_entries)\n    all_object.parent = all_assign\n    all_assign.value = all_object\n    return stub\n", "tokens": ["astroid", "brain", "brain_nose", "py", "def", "_nose_tools_trivial_transform", "custom", "transform", "for", "the", "nose", "tools", "module", "stub", "_builder", "string_build", "__all__", "all_entries", "ok_", "eq_", "for", "pep8_name", "method", "in", "_nose_tools_functions", "all_entries", "append", "pep8_name", "stub", "pep8_name", "method", "update", "the", "__all__", "variable", "since", "nose", "tools", "does", "this", "manually", "with", "append", "all_assign", "stub", "__all__", "parent", "all_object", "astroid", "list", "all_entries", "all_object", "parent", "all_assign", "all_assign", "value", "all_object", "return", "stub"], "doc_len": 59}
{"doc_id": "astroid/brain/brain_numpy_core_fromnumeric.py::numpy_core_fromnumeric_transform", "file_path": "astroid/brain/brain_numpy_core_fromnumeric.py", "class_name": null, "func_name": "numpy_core_fromnumeric_transform", "text": "文件路径: astroid/brain/brain_numpy_core_fromnumeric.py\ndef numpy_core_fromnumeric_transform():\n    return parse(\n        \"\"\"\n    def sum(a, axis=None, dtype=None, out=None, keepdims=None, initial=None):\n        return numpy.ndarray([0, 0])\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_core_fromnumeric", "py", "def", "numpy_core_fromnumeric_transform", "return", "parse", "def", "sum", "a", "axis", "none", "dtype", "none", "out", "none", "keepdims", "none", "initial", "none", "return", "numpy", "ndarray", "0", "0"], "doc_len": 26}
{"doc_id": "astroid/brain/brain_numpy_core_multiarray.py::numpy_core_multiarray_transform", "file_path": "astroid/brain/brain_numpy_core_multiarray.py", "class_name": null, "func_name": "numpy_core_multiarray_transform", "text": "文件路径: astroid/brain/brain_numpy_core_multiarray.py\ndef numpy_core_multiarray_transform():\n    return parse(\n        \"\"\"\n    # different functions defined in multiarray.py\n    def inner(a, b):\n        return numpy.ndarray([0, 0])\n\n    def vdot(a, b):\n        return numpy.ndarray([0, 0])\n        \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_core_multiarray", "py", "def", "numpy_core_multiarray_transform", "return", "parse", "different", "functions", "defined", "in", "multiarray", "py", "def", "inner", "a", "b", "return", "numpy", "ndarray", "0", "0", "def", "vdot", "a", "b", "return", "numpy", "ndarray", "0", "0"], "doc_len": 32}
{"doc_id": "astroid/brain/brain_numpy_core_numeric.py::numpy_core_numeric_transform", "file_path": "astroid/brain/brain_numpy_core_numeric.py", "class_name": null, "func_name": "numpy_core_numeric_transform", "text": "文件路径: astroid/brain/brain_numpy_core_numeric.py\ndef numpy_core_numeric_transform():\n    return parse(\n        \"\"\"\n    # different functions defined in numeric.py\n    import numpy\n    def zeros_like(a, dtype=None, order='K', subok=True): return numpy.ndarray((0, 0))\n    def ones_like(a, dtype=None, order='K', subok=True): return numpy.ndarray((0, 0))\n    def full_like(a, fill_value, dtype=None, order='K', subok=True): return numpy.ndarray((0, 0))\n        \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_core_numeric", "py", "def", "numpy_core_numeric_transform", "return", "parse", "different", "functions", "defined", "in", "numeric", "py", "import", "numpy", "def", "zeros_like", "a", "dtype", "none", "order", "k", "subok", "true", "return", "numpy", "ndarray", "0", "0", "def", "ones_like", "a", "dtype", "none", "order", "k", "subok", "true", "return", "numpy", "ndarray", "0", "0", "def", "full_like", "a", "fill_value", "dtype", "none", "order", "k", "subok", "true", "return", "numpy", "ndarray", "0", "0"], "doc_len": 59}
{"doc_id": "astroid/brain/brain_numpy_core_numerictypes.py::numpy_core_numerictypes_transform", "file_path": "astroid/brain/brain_numpy_core_numerictypes.py", "class_name": null, "func_name": "numpy_core_numerictypes_transform", "text": "文件路径: astroid/brain/brain_numpy_core_numerictypes.py\ndef numpy_core_numerictypes_transform():\n    # TODO: Uniformize the generic API with the ndarray one.\n    #       According to numpy doc the generic object should expose\n    #       the same API than ndarray. This has been done here partially\n    #       through the astype method.\n    generic_src = \"\"\"\n    class generic(object):\n        def __init__(self, value):\n            self.T = np.ndarray([0, 0])\n            self.base = None\n            self.data = None\n            self.dtype = None\n            self.flags = None\n            # Should be a numpy.flatiter instance but not available for now\n            # Putting an array instead so that iteration and indexing are authorized\n            self.flat = np.ndarray([0, 0])\n            self.imag = None\n            self.itemsize = None\n            self.nbytes = None\n            self.ndim = None\n            self.real = None\n            self.size = None\n            self.strides = None\n\n        def all(self): return uninferable\n        def any(self): return uninferable\n        def argmax(self): return uninferable\n        def argmin(self): return uninferable\n        def argsort(self): return uninferable\n        def astype(self, dtype, order='K', casting='unsafe', subok=True, copy=True): return np.ndarray([0, 0])\n        def base(self): return uninferable\n        def byteswap(self): return uninferable\n        def choose(self): return uninferable\n        def clip(self): return uninferable\n        def compress(self): return uninferable\n        def conj(self): return uninferable\n        def conjugate(self): return uninferable\n        def copy(self): return uninferable\n        def cumprod(self): return uninferable\n        def cumsum(self): return uninferable\n        def data(self): return uninferable\n        def diagonal(self): return uninferable\n        def dtype(self): return uninferable\n        def dump(self): return uninferable\n        def dumps(self): return uninferable\n        def fill(self): return uninferable\n        def flags(self): return uninferable\n        def flat(self): return uninferable\n        def flatten(self): return uninferable\n        def getfield(self): return uninferable\n        def imag(self): return uninferable\n        def item(self): return uninferable\n        def itemset(self): return uninferable\n        def itemsize(self): return uninferable\n        def max(self): return uninferable\n        def mean(self): return uninferable\n        def min(self): return uninferable\n        def nbytes(self): return uninferable\n        def ndim(self): return uninferable\n        def newbyteorder(self): return uninferable\n        def nonzero(self): return uninferable\n        def prod(self): return uninferable\n        def ptp(self): return uninferable\n        def put(self): return uninferable\n        def ravel(self): return uninferable\n        def real(self): return uninferable\n        def repeat(self): return uninferable\n        def reshape(self): return uninferable\n        def resize(self): return uninferable\n        def round(self): return uninferable\n        def searchsorted(self): return uninferable\n        def setfield(self): return uninferable\n        def setflags(self): return uninferable\n        def shape(self): return uninferable\n        def size(self): return uninferable\n        def sort(self): return uninferable\n        def squeeze(self): return uninferable\n        def std(self): return uninferable\n        def strides(self): return uninferable\n        def sum(self): return uninferable\n        def swapaxes(self): return uninferable\n        def take(self): return uninferable\n        def tobytes(self): return uninferable\n        def tofile(self): return uninferable\n        def tolist(self): return uninferable\n        def tostring(self): return uninferable\n        def trace(self): return uninferable\n        def transpose(self): return uninferable\n        def var(self): return uninferable\n        def view(self): return uninferable\n        \"\"\"\n    if numpy_supports_type_hints():\n        generic_src += \"\"\"\n        @classmethod\n        def __class_getitem__(cls, value):\n            return cls\n        \"\"\"\n    return parse(\n        generic_src\n        + \"\"\"\n    class dtype(object):\n        def __init__(self, obj, align=False, copy=False):\n            self.alignment = None\n            self.base = None\n            self.byteorder = None\n            self.char = None\n            self.descr = None\n            self.fields = None\n            self.flags = None\n            self.hasobject = None\n            self.isalignedstruct = None\n            self.isbuiltin = None\n            self.isnative = None\n            self.itemsize = None\n            self.kind = None\n            self.metadata = None\n            self.name = None\n            self.names = None\n            self.num = None\n            self.shape = None\n            self.str = None\n            self.subdtype = None\n            self.type = None\n\n        def newbyteorder(self, new_order='S'): return uninferable\n        def __neg__(self): return uninferable\n\n    class busdaycalendar(object):\n        def __init__(self, weekmask='1111100', holidays=None):\n            self.holidays = None\n            self.weekmask = None\n\n    class flexible(generic): pass\n    class bool_(generic): pass\n    class number(generic):\n        def __neg__(self): return uninferable\n    class datetime64(generic):\n        def __init__(self, nb, unit=None): pass\n\n\n    class void(flexible):\n        def __init__(self, *args, **kwargs):\n            self.base = None\n            self.dtype = None\n            self.flags = None\n        def getfield(self): return uninferable\n        def setfield(self): return uninferable\n\n\n    class character(flexible): pass\n\n\n    class integer(number):\n        def __init__(self, value):\n           self.denominator = None\n           self.numerator = None\n\n\n    class inexact(number): pass\n\n\n    class str_(str, character):\n        def maketrans(self, x, y=None, z=None): return uninferable\n\n\n    class bytes_(bytes, character):\n        def fromhex(self, string): return uninferable\n        def maketrans(self, frm, to): return uninferable\n\n\n    class signedinteger(integer): pass\n\n\n    class unsignedinteger(integer): pass\n\n\n    class complexfloating(inexact): pass\n\n\n    class floating(inexact): pass\n\n\n    class float64(floating, float):\n        def fromhex(self, string): return uninferable\n\n\n    class uint64(unsignedinteger): pass\n    class complex64(complexfloating): pass\n    class int16(signedinteger): pass\n    class float96(floating): pass\n    class int8(signedinteger): pass\n    class uint32(unsignedinteger): pass\n    class uint8(unsignedinteger): pass\n    class _typedict(dict): pass\n    class complex192(complexfloating): pass\n    class timedelta64(signedinteger):\n        def __init__(self, nb, unit=None): pass\n    class int32(signedinteger): pass\n    class uint16(unsignedinteger): pass\n    class float32(floating): pass\n    class complex128(complexfloating, complex): pass\n    class float16(floating): pass\n    class int64(signedinteger): pass\n\n    buffer_type = memoryview\n    bool8 = bool_\n    byte = int8\n    bytes0 = bytes_\n    cdouble = complex128\n    cfloat = complex128\n    clongdouble = complex192\n    clongfloat = complex192\n    complex_ = complex128\n    csingle = complex64\n    double = float64\n    float_ = float64\n    half = float16\n    int0 = int32\n    int_ = int32\n    intc = int32\n    intp = int32\n    long = int32\n    longcomplex = complex192\n    longdouble = float96\n    longfloat = float96\n    longlong = int64\n    object0 = object_\n    object_ = object_\n    short = int16\n    single = float32\n    singlecomplex = complex64\n    str0 = str_\n    string_ = bytes_\n    ubyte = uint8\n    uint = uint32\n    uint0 = uint32\n    uintc = uint32\n    uintp = uint32\n    ulonglong = uint64\n    unicode = str_\n    unicode_ = str_\n    ushort = uint16\n    void0 = void\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_core_numerictypes", "py", "def", "numpy_core_numerictypes_transform", "todo", "uniformize", "the", "generic", "api", "with", "the", "ndarray", "one", "according", "to", "numpy", "doc", "the", "generic", "object", "should", "expose", "the", "same", "api", "than", "ndarray", "this", "has", "been", "done", "here", "partially", "through", "the", "astype", "method", "generic_src", "class", "generic", "object", "def", "__init__", "self", "value", "self", "t", "np", "ndarray", "0", "0", "self", "base", "none", "self", "data", "none", "self", "dtype", "none", "self", "flags", "none", "should", "be", "a", "numpy", "flatiter", "instance", "but", "not", "available", "for", "now", "putting", "an", "array", "instead", "so", "that", "iteration", "and", "indexing", "are", "authorized", "self", "flat", "np", "ndarray", "0", "0", "self", "imag", "none", "self", "itemsize", "none", "self", "nbytes", "none", "self", "ndim", "none", "self", "real", "none", "self", "size", "none", "self", "strides", "none", "def", "all", "self", "return", "uninferable", "def", "any", "self", "return", "uninferable", "def", "argmax", "self", "return", "uninferable", "def", "argmin", "self", "return", "uninferable", "def", "argsort", "self", "return", "uninferable", "def", "astype", "self", "dtype", "order", "k", "casting", "unsafe", "subok", "true", "copy", "true", "return", "np", "ndarray", "0", "0", "def", "base", "self", "return", "uninferable", "def", "byteswap", "self", "return", "uninferable", "def", "choose", "self", "return", "uninferable", "def", "clip", "self", "return", "uninferable", "def", "compress", "self", "return", "uninferable", "def", "conj", "self", "return", "uninferable", "def", "conjugate", "self", "return", "uninferable", "def", "copy", "self", "return", "uninferable", "def", "cumprod", "self", "return", "uninferable", "def", "cumsum", "self", "return", "uninferable", "def", "data", "self", "return", "uninferable", "def", "diagonal", "self", "return", "uninferable", "def", "dtype", "self", "return", "uninferable", "def", "dump", "self", "return", "uninferable", "def", "dumps", "self", "return", "uninferable", "def", "fill", "self", "return", "uninferable", "def", "flags", "self", "return", "uninferable", "def", "flat", "self", "return", "uninferable", "def", "flatten", "self", "return", "uninferable", "def", "getfield", "self", "return", "uninferable", "def", "imag", "self", "return", "uninferable", "def", "item", "self", "return", "uninferable", "def", "itemset", "self", "return", "uninferable", "def", "itemsize", "self", "return", "uninferable", "def", "max", "self", "return", "uninferable", "def", "mean", "self", "return", "uninferable", "def", "min", "self", "return", "uninferable", "def", "nbytes", "self", "return", "uninferable", "def", "ndim", "self", "return", "uninferable", "def", "newbyteorder", "self", "return", "uninferable", "def", "nonzero", "self", "return", "uninferable", "def", "prod", "self", "return", "uninferable", "def", "ptp", "self", "return", "uninferable", "def", "put", "self", "return", "uninferable", "def", "ravel", "self", "return", "uninferable", "def", "real", "self", "return", "uninferable", "def", "repeat", "self", "return", "uninferable", "def", "reshape", "self", "return", "uninferable", "def", "resize", "self", "return", "uninferable", "def", "round", "self", "return", "uninferable", "def", "searchsorted", "self", "return", "uninferable", "def", "setfield", "self", "return", "uninferable", "def", "setflags", "self", "return", "uninferable", "def", "shape", "self", "return", "uninferable", "def", "size", "self", "return", "uninferable", "def", "sort", "self", "return", "uninferable", "def", "squeeze", "self", "return", "uninferable", "def", "std", "self", "return", "uninferable", "def", "strides", "self", "return", "uninferable", "def", "sum", "self", "return", "uninferable", "def", "swapaxes", "self", "return", "uninferable", "def", "take", "self", "return", "uninferable", "def", "tobytes", "self", "return", "uninferable", "def", "tofile", "self", "return", "uninferable", "def", "tolist", "self", "return", "uninferable", "def", "tostring", "self", "return", "uninferable", "def", "trace", "self", "return", "uninferable", "def", "transpose", "self", "return", "uninferable", "def", "var", "self", "return", "uninferable", "def", "view", "self", "return", "uninferable", "if", "numpy_supports_type_hints", "generic_src", "classmethod", "def", "__class_getitem__", "cls", "value", "return", "cls", "return", "parse", "generic_src", "class", "dtype", "object", "def", "__init__", "self", "obj", "align", "false", "copy", "false", "self", "alignment", "none", "self", "base", "none", "self", "byteorder", "none", "self", "char", "none", "self", "descr", "none", "self", "fields", "none", "self", "flags", "none", "self", "hasobject", "none", "self", "isalignedstruct", "none", "self", "isbuiltin", "none", "self", "isnative", "none", "self", "itemsize", "none", "self", "kind", "none", "self", "metadata", "none", "self", "name", "none", "self", "names", "none", "self", "num", "none", "self", "shape", "none", "self", "str", "none", "self", "subdtype", "none", "self", "type", "none", "def", "newbyteorder", "self", "new_order", "s", "return", "uninferable", "def", "__neg__", "self", "return", "uninferable", "class", "busdaycalendar", "object", "def", "__init__", "self", "weekmask", "1111100", "holidays", "none", "self", "holidays", "none", "self", "weekmask", "none", "class", "flexible", "generic", "pass", "class", "bool_", "generic", "pass", "class", "number", "generic", "def", "__neg__", "self", "return", "uninferable", "class", "datetime64", "generic", "def", "__init__", "self", "nb", "unit", "none", "pass", "class", "void", "flexible", "def", "__init__", "self", "args", "kwargs", "self", "base", "none", "self", "dtype", "none", "self", "flags", "none", "def", "getfield", "self", "return", "uninferable", "def", "setfield", "self", "return", "uninferable", "class", "character", "flexible", "pass", "class", "integer", "number", "def", "__init__", "self", "value", "self", "denominator", "none", "self", "numerator", "none", "class", "inexact", "number", "pass", "class", "str_", "str", "character", "def", "maketrans", "self", "x", "y", "none", "z", "none", "return", "uninferable", "class", "bytes_", "bytes", "character", "def", "fromhex", "self", "string", "return", "uninferable", "def", "maketrans", "self", "frm", "to", "return", "uninferable", "class", "signedinteger", "integer", "pass", "class", "unsignedinteger", "integer", "pass", "class", "complexfloating", "inexact", "pass", "class", "floating", "inexact", "pass", "class", "float64", "floating", "float", "def", "fromhex", "self", "string", "return", "uninferable", "class", "uint64", "unsignedinteger", "pass", "class", "complex64", "complexfloating", "pass", "class", "int16", "signedinteger", "pass", "class", "float96", "floating", "pass", "class", "int8", "signedinteger", "pass", "class", "uint32", "unsignedinteger", "pass", "class", "uint8", "unsignedinteger", "pass", "class", "_typedict", "dict", "pass", "class", "complex192", "complexfloating", "pass", "class", "timedelta64", "signedinteger", "def", "__init__", "self", "nb", "unit", "none", "pass", "class", "int32", "signedinteger", "pass", "class", "uint16", "unsignedinteger", "pass", "class", "float32", "floating", "pass", "class", "complex128", "complexfloating", "complex", "pass", "class", "float16", "floating", "pass", "class", "int64", "signedinteger", "pass", "buffer_type", "memoryview", "bool8", "bool_", "byte", "int8", "bytes0", "bytes_", "cdouble", "complex128", "cfloat", "complex128", "clongdouble", "complex192", "clongfloat", "complex192", "complex_", "complex128", "csingle", "complex64", "double", "float64", "float_", "float64", "half", "float16", "int0", "int32", "int_", "int32", "intc", "int32", "intp", "int32", "long", "int32", "longcomplex", "complex192", "longdouble", "float96", "longfloat", "float96", "longlong", "int64", "object0", "object_", "object_", "object_", "short", "int16", "single", "float32", "singlecomplex", "complex64", "str0", "str_", "string_", "bytes_", "ubyte", "uint8", "uint", "uint32", "uint0", "uint32", "uintc", "uint32", "uintp", "uint32", "ulonglong", "uint64", "unicode", "str_", "unicode_", "str_", "ushort", "uint16", "void0", "void"], "doc_len": 851}
{"doc_id": "astroid/brain/brain_numpy_core_umath.py::numpy_core_umath_transform", "file_path": "astroid/brain/brain_numpy_core_umath.py", "class_name": null, "func_name": "numpy_core_umath_transform", "text": "文件路径: astroid/brain/brain_numpy_core_umath.py\ndef numpy_core_umath_transform():\n    ufunc_optional_keyword_arguments = (\n        \"\"\"out=None, where=True, casting='same_kind', order='K', \"\"\"\n        \"\"\"dtype=None, subok=True\"\"\"\n    )\n    return parse(\n        \"\"\"\n    class FakeUfunc:\n        def __init__(self):\n            self.__doc__ = str()\n            self.__name__ = str()\n            self.nin = 0\n            self.nout = 0\n            self.nargs = 0\n            self.ntypes = 0\n            self.types = None\n            self.identity = None\n            self.signature = None\n\n        @classmethod\n        def reduce(cls, a, axis=None, dtype=None, out=None):\n            return numpy.ndarray([0, 0])\n\n        @classmethod\n        def accumulate(cls, array, axis=None, dtype=None, out=None):\n            return numpy.ndarray([0, 0])\n\n        @classmethod\n        def reduceat(cls, a, indices, axis=None, dtype=None, out=None):\n            return numpy.ndarray([0, 0])\n\n        @classmethod\n        def outer(cls, A, B, **kwargs):\n            return numpy.ndarray([0, 0])\n\n        @classmethod\n        def at(cls, a, indices, b=None):\n            return numpy.ndarray([0, 0])\n\n    class FakeUfuncOneArg(FakeUfunc):\n        def __call__(self, x, {opt_args:s}):\n            return numpy.ndarray([0, 0])\n\n    class FakeUfuncOneArgBis(FakeUfunc):\n        def __call__(self, x, {opt_args:s}):\n            return numpy.ndarray([0, 0]), numpy.ndarray([0, 0])\n\n    class FakeUfuncTwoArgs(FakeUfunc):\n        def __call__(self, x1, x2, {opt_args:s}):\n            return numpy.ndarray([0, 0])\n\n    # Constants\n    e = 2.718281828459045\n    euler_gamma = 0.5772156649015329\n\n    # One arg functions with optional kwargs\n    arccos = FakeUfuncOneArg()\n    arccosh = FakeUfuncOneArg()\n    arcsin = FakeUfuncOneArg()\n    arcsinh = FakeUfuncOneArg()\n    arctan = FakeUfuncOneArg()\n    arctanh = FakeUfuncOneArg()\n    cbrt = FakeUfuncOneArg()\n    conj = FakeUfuncOneArg()\n    conjugate = FakeUfuncOneArg()\n    cosh = FakeUfuncOneArg()\n    deg2rad = FakeUfuncOneArg()\n    degrees = FakeUfuncOneArg()\n    exp2 = FakeUfuncOneArg()\n    expm1 = FakeUfuncOneArg()\n    fabs = FakeUfuncOneArg()\n    frexp = FakeUfuncOneArgBis()\n    isfinite = FakeUfuncOneArg()\n    isinf = FakeUfuncOneArg()\n    log = FakeUfuncOneArg()\n    log1p = FakeUfuncOneArg()\n    log2 = FakeUfuncOneArg()\n    logical_not = FakeUfuncOneArg()\n    modf = FakeUfuncOneArgBis()\n    negative = FakeUfuncOneArg()\n    positive = FakeUfuncOneArg()\n    rad2deg = FakeUfuncOneArg()\n    radians = FakeUfuncOneArg()\n    reciprocal = FakeUfuncOneArg()\n    rint = FakeUfuncOneArg()\n    sign = FakeUfuncOneArg()\n    signbit = FakeUfuncOneArg()\n    sinh = FakeUfuncOneArg()\n    spacing = FakeUfuncOneArg()\n    square = FakeUfuncOneArg()\n    tan = FakeUfuncOneArg()\n    tanh = FakeUfuncOneArg()\n    trunc = FakeUfuncOneArg()\n\n    # Two args functions with optional kwargs\n    add = FakeUfuncTwoArgs()\n    bitwise_and = FakeUfuncTwoArgs()\n    bitwise_or = FakeUfuncTwoArgs()\n    bitwise_xor = FakeUfuncTwoArgs()\n    copysign = FakeUfuncTwoArgs()\n    divide = FakeUfuncTwoArgs()\n    divmod = FakeUfuncTwoArgs()\n    equal = FakeUfuncTwoArgs()\n    float_power = FakeUfuncTwoArgs()\n    floor_divide = FakeUfuncTwoArgs()\n    fmax = FakeUfuncTwoArgs()\n    fmin = FakeUfuncTwoArgs()\n    fmod = FakeUfuncTwoArgs()\n    greater = FakeUfuncTwoArgs()\n    gcd = FakeUfuncTwoArgs()\n    hypot = FakeUfuncTwoArgs()\n    heaviside = FakeUfuncTwoArgs()\n    lcm = FakeUfuncTwoArgs()\n    ldexp = FakeUfuncTwoArgs()\n    left_shift = FakeUfuncTwoArgs()\n    less = FakeUfuncTwoArgs()\n    logaddexp = FakeUfuncTwoArgs()\n    logaddexp2 = FakeUfuncTwoArgs()\n    logical_and = FakeUfuncTwoArgs()\n    logical_or = FakeUfuncTwoArgs()\n    logical_xor = FakeUfuncTwoArgs()\n    maximum = FakeUfuncTwoArgs()\n    minimum = FakeUfuncTwoArgs()\n    multiply = FakeUfuncTwoArgs()\n    nextafter = FakeUfuncTwoArgs()\n    not_equal = FakeUfuncTwoArgs()\n    power = FakeUfuncTwoArgs()\n    remainder = FakeUfuncTwoArgs()\n    right_shift = FakeUfuncTwoArgs()\n    subtract = FakeUfuncTwoArgs()\n    true_divide = FakeUfuncTwoArgs()\n    \"\"\".format(\n            opt_args=ufunc_optional_keyword_arguments\n        )\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_core_umath", "py", "def", "numpy_core_umath_transform", "ufunc_optional_keyword_arguments", "out", "none", "where", "true", "casting", "same_kind", "order", "k", "dtype", "none", "subok", "true", "return", "parse", "class", "fakeufunc", "def", "__init__", "self", "self", "__doc__", "str", "self", "__name__", "str", "self", "nin", "0", "self", "nout", "0", "self", "nargs", "0", "self", "ntypes", "0", "self", "types", "none", "self", "identity", "none", "self", "signature", "none", "classmethod", "def", "reduce", "cls", "a", "axis", "none", "dtype", "none", "out", "none", "return", "numpy", "ndarray", "0", "0", "classmethod", "def", "accumulate", "cls", "array", "axis", "none", "dtype", "none", "out", "none", "return", "numpy", "ndarray", "0", "0", "classmethod", "def", "reduceat", "cls", "a", "indices", "axis", "none", "dtype", "none", "out", "none", "return", "numpy", "ndarray", "0", "0", "classmethod", "def", "outer", "cls", "a", "b", "kwargs", "return", "numpy", "ndarray", "0", "0", "classmethod", "def", "at", "cls", "a", "indices", "b", "none", "return", "numpy", "ndarray", "0", "0", "class", "fakeufunconearg", "fakeufunc", "def", "__call__", "self", "x", "opt_args", "s", "return", "numpy", "ndarray", "0", "0", "class", "fakeufunconeargbis", "fakeufunc", "def", "__call__", "self", "x", "opt_args", "s", "return", "numpy", "ndarray", "0", "0", "numpy", "ndarray", "0", "0", "class", "fakeufunctwoargs", "fakeufunc", "def", "__call__", "self", "x1", "x2", "opt_args", "s", "return", "numpy", "ndarray", "0", "0", "constants", "e", "2", "718281828459045", "euler_gamma", "0", "5772156649015329", "one", "arg", "functions", "with", "optional", "kwargs", "arccos", "fakeufunconearg", "arccosh", "fakeufunconearg", "arcsin", "fakeufunconearg", "arcsinh", "fakeufunconearg", "arctan", "fakeufunconearg", "arctanh", "fakeufunconearg", "cbrt", "fakeufunconearg", "conj", "fakeufunconearg", "conjugate", "fakeufunconearg", "cosh", "fakeufunconearg", "deg2rad", "fakeufunconearg", "degrees", "fakeufunconearg", "exp2", "fakeufunconearg", "expm1", "fakeufunconearg", "fabs", "fakeufunconearg", "frexp", "fakeufunconeargbis", "isfinite", "fakeufunconearg", "isinf", "fakeufunconearg", "log", "fakeufunconearg", "log1p", "fakeufunconearg", "log2", "fakeufunconearg", "logical_not", "fakeufunconearg", "modf", "fakeufunconeargbis", "negative", "fakeufunconearg", "positive", "fakeufunconearg", "rad2deg", "fakeufunconearg", "radians", "fakeufunconearg", "reciprocal", "fakeufunconearg", "rint", "fakeufunconearg", "sign", "fakeufunconearg", "signbit", "fakeufunconearg", "sinh", "fakeufunconearg", "spacing", "fakeufunconearg", "square", "fakeufunconearg", "tan", "fakeufunconearg", "tanh", "fakeufunconearg", "trunc", "fakeufunconearg", "two", "args", "functions", "with", "optional", "kwargs", "add", "fakeufunctwoargs", "bitwise_and", "fakeufunctwoargs", "bitwise_or", "fakeufunctwoargs", "bitwise_xor", "fakeufunctwoargs", "copysign", "fakeufunctwoargs", "divide", "fakeufunctwoargs", "divmod", "fakeufunctwoargs", "equal", "fakeufunctwoargs", "float_power", "fakeufunctwoargs", "floor_divide", "fakeufunctwoargs", "fmax", "fakeufunctwoargs", "fmin", "fakeufunctwoargs", "fmod", "fakeufunctwoargs", "greater", "fakeufunctwoargs", "gcd", "fakeufunctwoargs", "hypot", "fakeufunctwoargs", "heaviside", "fakeufunctwoargs", "lcm", "fakeufunctwoargs", "ldexp", "fakeufunctwoargs", "left_shift", "fakeufunctwoargs", "less", "fakeufunctwoargs", "logaddexp", "fakeufunctwoargs", "logaddexp2", "fakeufunctwoargs", "logical_and", "fakeufunctwoargs", "logical_or", "fakeufunctwoargs", "logical_xor", "fakeufunctwoargs", "maximum", "fakeufunctwoargs", "minimum", "fakeufunctwoargs", "multiply", "fakeufunctwoargs", "nextafter", "fakeufunctwoargs", "not_equal", "fakeufunctwoargs", "power", "fakeufunctwoargs", "remainder", "fakeufunctwoargs", "right_shift", "fakeufunctwoargs", "subtract", "fakeufunctwoargs", "true_divide", "fakeufunctwoargs", "format", "opt_args", "ufunc_optional_keyword_arguments"], "doc_len": 342}
{"doc_id": "astroid/brain/brain_numpy_ma.py::numpy_ma_transform", "file_path": "astroid/brain/brain_numpy_ma.py", "class_name": null, "func_name": "numpy_ma_transform", "text": "文件路径: astroid/brain/brain_numpy_ma.py\ndef numpy_ma_transform():\n    \"\"\"\n    Infer the call of the masked_where function\n\n    :param node: node to infer\n    :param context: inference context\n    \"\"\"\n    return parse(\n        \"\"\"\n    import numpy.ma\n    def masked_where(condition, a, copy=True):\n        return numpy.ma.masked_array(a, mask=[])\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_ma", "py", "def", "numpy_ma_transform", "infer", "the", "call", "of", "the", "masked_where", "function", "param", "node", "node", "to", "infer", "param", "context", "inference", "context", "return", "parse", "import", "numpy", "ma", "def", "masked_where", "condition", "a", "copy", "true", "return", "numpy", "ma", "masked_array", "a", "mask"], "doc_len": 39}
{"doc_id": "astroid/brain/brain_numpy_ndarray.py::infer_numpy_ndarray", "file_path": "astroid/brain/brain_numpy_ndarray.py", "class_name": null, "func_name": "infer_numpy_ndarray", "text": "文件路径: astroid/brain/brain_numpy_ndarray.py\ndef infer_numpy_ndarray(node, context=None):\n    ndarray = \"\"\"\n    class ndarray(object):\n        def __init__(self, shape, dtype=float, buffer=None, offset=0,\n                     strides=None, order=None):\n            self.T = numpy.ndarray([0, 0])\n            self.base = None\n            self.ctypes = None\n            self.data = None\n            self.dtype = None\n            self.flags = None\n            # Should be a numpy.flatiter instance but not available for now\n            # Putting an array instead so that iteration and indexing are authorized\n            self.flat = np.ndarray([0, 0])\n            self.imag = np.ndarray([0, 0])\n            self.itemsize = None\n            self.nbytes = None\n            self.ndim = None\n            self.real = np.ndarray([0, 0])\n            self.shape = numpy.ndarray([0, 0])\n            self.size = None\n            self.strides = None\n\n        def __abs__(self): return numpy.ndarray([0, 0])\n        def __add__(self, value): return numpy.ndarray([0, 0])\n        def __and__(self, value): return numpy.ndarray([0, 0])\n        def __array__(self, dtype=None): return numpy.ndarray([0, 0])\n        def __array_wrap__(self, obj): return numpy.ndarray([0, 0])\n        def __contains__(self, key): return True\n        def __copy__(self): return numpy.ndarray([0, 0])\n        def __deepcopy__(self, memo): return numpy.ndarray([0, 0])\n        def __divmod__(self, value): return (numpy.ndarray([0, 0]), numpy.ndarray([0, 0]))\n        def __eq__(self, value): return numpy.ndarray([0, 0])\n        def __float__(self): return 0.\n        def __floordiv__(self): return numpy.ndarray([0, 0])\n        def __ge__(self, value): return numpy.ndarray([0, 0])\n        def __getitem__(self, key): return uninferable\n        def __gt__(self, value): return numpy.ndarray([0, 0])\n        def __iadd__(self, value): return numpy.ndarray([0, 0])\n        def __iand__(self, value): return numpy.ndarray([0, 0])\n        def __ifloordiv__(self, value): return numpy.ndarray([0, 0])\n        def __ilshift__(self, value): return numpy.ndarray([0, 0])\n        def __imod__(self, value): return numpy.ndarray([0, 0])\n        def __imul__(self, value): return numpy.ndarray([0, 0])\n        def __int__(self): return 0\n        def __invert__(self): return numpy.ndarray([0, 0])\n        def __ior__(self, value): return numpy.ndarray([0, 0])\n        def __ipow__(self, value): return numpy.ndarray([0, 0])\n        def __irshift__(self, value): return numpy.ndarray([0, 0])\n        def __isub__(self, value): return numpy.ndarray([0, 0])\n        def __itruediv__(self, value): return numpy.ndarray([0, 0])\n        def __ixor__(self, value): return numpy.ndarray([0, 0])\n        def __le__(self, value): return numpy.ndarray([0, 0])\n        def __len__(self): return 1\n        def __lshift__(self, value): return numpy.ndarray([0, 0])\n        def __lt__(self, value): return numpy.ndarray([0, 0])\n        def __matmul__(self, value): return numpy.ndarray([0, 0])\n        def __mod__(self, value): return numpy.ndarray([0, 0])\n        def __mul__(self, value): return numpy.ndarray([0, 0])\n        def __ne__(self, value): return numpy.ndarray([0, 0])\n        def __neg__(self): return numpy.ndarray([0, 0])\n        def __or__(self, value): return numpy.ndarray([0, 0])\n        def __pos__(self): return numpy.ndarray([0, 0])\n        def __pow__(self): return numpy.ndarray([0, 0])\n        def __repr__(self): return str()\n        def __rshift__(self): return numpy.ndarray([0, 0])\n        def __setitem__(self, key, value): return uninferable\n        def __str__(self): return str()\n        def __sub__(self, value): return numpy.ndarray([0, 0])\n        def __truediv__(self, value): return numpy.ndarray([0, 0])\n        def __xor__(self, value): return numpy.ndarray([0, 0])\n        def all(self, axis=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def any(self, axis=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def argmax(self, axis=None, out=None): return np.ndarray([0, 0])\n        def argmin(self, axis=None, out=None): return np.ndarray([0, 0])\n        def argpartition(self, kth, axis=-1, kind='introselect', order=None): return np.ndarray([0, 0])\n        def argsort(self, axis=-1, kind='quicksort', order=None): return np.ndarray([0, 0])\n        def astype(self, dtype, order='K', casting='unsafe', subok=True, copy=True): return np.ndarray([0, 0])\n        def byteswap(self, inplace=False): return np.ndarray([0, 0])\n        def choose(self, choices, out=None, mode='raise'): return np.ndarray([0, 0])\n        def clip(self, min=None, max=None, out=None): return np.ndarray([0, 0])\n        def compress(self, condition, axis=None, out=None): return np.ndarray([0, 0])\n        def conj(self): return np.ndarray([0, 0])\n        def conjugate(self): return np.ndarray([0, 0])\n        def copy(self, order='C'): return np.ndarray([0, 0])\n        def cumprod(self, axis=None, dtype=None, out=None): return np.ndarray([0, 0])\n        def cumsum(self, axis=None, dtype=None, out=None): return np.ndarray([0, 0])\n        def diagonal(self, offset=0, axis1=0, axis2=1): return np.ndarray([0, 0])\n        def dot(self, b, out=None): return np.ndarray([0, 0])\n        def dump(self, file): return None\n        def dumps(self): return str()\n        def fill(self, value): return None\n        def flatten(self, order='C'): return np.ndarray([0, 0])\n        def getfield(self, dtype, offset=0): return np.ndarray([0, 0])\n        def item(self, *args): return uninferable\n        def itemset(self, *args): return None\n        def max(self, axis=None, out=None): return np.ndarray([0, 0])\n        def mean(self, axis=None, dtype=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def min(self, axis=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def newbyteorder(self, new_order='S'): return np.ndarray([0, 0])\n        def nonzero(self): return (1,)\n        def partition(self, kth, axis=-1, kind='introselect', order=None): return None\n        def prod(self, axis=None, dtype=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def ptp(self, axis=None, out=None): return np.ndarray([0, 0])\n        def put(self, indices, values, mode='raise'): return None\n        def ravel(self, order='C'): return np.ndarray([0, 0])\n        def repeat(self, repeats, axis=None): return np.ndarray([0, 0])\n        def reshape(self, shape, order='C'): return np.ndarray([0, 0])\n        def resize(self, new_shape, refcheck=True): return None\n        def round(self, decimals=0, out=None): return np.ndarray([0, 0])\n        def searchsorted(self, v, side='left', sorter=None): return np.ndarray([0, 0])\n        def setfield(self, val, dtype, offset=0): return None\n        def setflags(self, write=None, align=None, uic=None): return None\n        def sort(self, axis=-1, kind='quicksort', order=None): return None\n        def squeeze(self, axis=None): return np.ndarray([0, 0])\n        def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False): return np.ndarray([0, 0])\n        def sum(self, axis=None, dtype=None, out=None, keepdims=False): return np.ndarray([0, 0])\n        def swapaxes(self, axis1, axis2): return np.ndarray([0, 0])\n        def take(self, indices, axis=None, out=None, mode='raise'): return np.ndarray([0, 0])\n        def tobytes(self, order='C'): return b''\n        def tofile(self, fid, sep=\"\", format=\"%s\"): return None\n        def tolist(self, ): return []\n        def tostring(self, order='C'): return b''\n        def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None): return np.ndarray([0, 0])\n        def transpose(self, *axes): return np.ndarray([0, 0])\n        def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False): return np.ndarray([0, 0])\n        def view(self, dtype=None, type=None): return np.ndarray([0, 0])\n    \"\"\"\n    if numpy_supports_type_hints():\n        ndarray += \"\"\"\n        @classmethod\n        def __class_getitem__(cls, value):\n            return cls\n        \"\"\"\n    node = extract_node(ndarray)\n    return node.infer(context=context)\n", "tokens": ["astroid", "brain", "brain_numpy_ndarray", "py", "def", "infer_numpy_ndarray", "node", "context", "none", "ndarray", "class", "ndarray", "object", "def", "__init__", "self", "shape", "dtype", "float", "buffer", "none", "offset", "0", "strides", "none", "order", "none", "self", "t", "numpy", "ndarray", "0", "0", "self", "base", "none", "self", "ctypes", "none", "self", "data", "none", "self", "dtype", "none", "self", "flags", "none", "should", "be", "a", "numpy", "flatiter", "instance", "but", "not", "available", "for", "now", "putting", "an", "array", "instead", "so", "that", "iteration", "and", "indexing", "are", "authorized", "self", "flat", "np", "ndarray", "0", "0", "self", "imag", "np", "ndarray", "0", "0", "self", "itemsize", "none", "self", "nbytes", "none", "self", "ndim", "none", "self", "real", "np", "ndarray", "0", "0", "self", "shape", "numpy", "ndarray", "0", "0", "self", "size", "none", "self", "strides", "none", "def", "__abs__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__add__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__and__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__array__", "self", "dtype", "none", "return", "numpy", "ndarray", "0", "0", "def", "__array_wrap__", "self", "obj", "return", "numpy", "ndarray", "0", "0", "def", "__contains__", "self", "key", "return", "true", "def", "__copy__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__deepcopy__", "self", "memo", "return", "numpy", "ndarray", "0", "0", "def", "__divmod__", "self", "value", "return", "numpy", "ndarray", "0", "0", "numpy", "ndarray", "0", "0", "def", "__eq__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__float__", "self", "return", "0", "def", "__floordiv__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__ge__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__getitem__", "self", "key", "return", "uninferable", "def", "__gt__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__iadd__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__iand__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__ifloordiv__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__ilshift__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__imod__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__imul__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__int__", "self", "return", "0", "def", "__invert__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__ior__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__ipow__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__irshift__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__isub__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__itruediv__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__ixor__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__le__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__len__", "self", "return", "1", "def", "__lshift__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__lt__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__matmul__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__mod__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__mul__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__ne__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__neg__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__or__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__pos__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__pow__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__repr__", "self", "return", "str", "def", "__rshift__", "self", "return", "numpy", "ndarray", "0", "0", "def", "__setitem__", "self", "key", "value", "return", "uninferable", "def", "__str__", "self", "return", "str", "def", "__sub__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__truediv__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "__xor__", "self", "value", "return", "numpy", "ndarray", "0", "0", "def", "all", "self", "axis", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "any", "self", "axis", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "argmax", "self", "axis", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "argmin", "self", "axis", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "argpartition", "self", "kth", "axis", "1", "kind", "introselect", "order", "none", "return", "np", "ndarray", "0", "0", "def", "argsort", "self", "axis", "1", "kind", "quicksort", "order", "none", "return", "np", "ndarray", "0", "0", "def", "astype", "self", "dtype", "order", "k", "casting", "unsafe", "subok", "true", "copy", "true", "return", "np", "ndarray", "0", "0", "def", "byteswap", "self", "inplace", "false", "return", "np", "ndarray", "0", "0", "def", "choose", "self", "choices", "out", "none", "mode", "raise", "return", "np", "ndarray", "0", "0", "def", "clip", "self", "min", "none", "max", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "compress", "self", "condition", "axis", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "conj", "self", "return", "np", "ndarray", "0", "0", "def", "conjugate", "self", "return", "np", "ndarray", "0", "0", "def", "copy", "self", "order", "c", "return", "np", "ndarray", "0", "0", "def", "cumprod", "self", "axis", "none", "dtype", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "cumsum", "self", "axis", "none", "dtype", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "diagonal", "self", "offset", "0", "axis1", "0", "axis2", "1", "return", "np", "ndarray", "0", "0", "def", "dot", "self", "b", "out", "none", "return", "np", "ndarray", "0", "0", "def", "dump", "self", "file", "return", "none", "def", "dumps", "self", "return", "str", "def", "fill", "self", "value", "return", "none", "def", "flatten", "self", "order", "c", "return", "np", "ndarray", "0", "0", "def", "getfield", "self", "dtype", "offset", "0", "return", "np", "ndarray", "0", "0", "def", "item", "self", "args", "return", "uninferable", "def", "itemset", "self", "args", "return", "none", "def", "max", "self", "axis", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "mean", "self", "axis", "none", "dtype", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "min", "self", "axis", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "newbyteorder", "self", "new_order", "s", "return", "np", "ndarray", "0", "0", "def", "nonzero", "self", "return", "1", "def", "partition", "self", "kth", "axis", "1", "kind", "introselect", "order", "none", "return", "none", "def", "prod", "self", "axis", "none", "dtype", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "ptp", "self", "axis", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "put", "self", "indices", "values", "mode", "raise", "return", "none", "def", "ravel", "self", "order", "c", "return", "np", "ndarray", "0", "0", "def", "repeat", "self", "repeats", "axis", "none", "return", "np", "ndarray", "0", "0", "def", "reshape", "self", "shape", "order", "c", "return", "np", "ndarray", "0", "0", "def", "resize", "self", "new_shape", "refcheck", "true", "return", "none", "def", "round", "self", "decimals", "0", "out", "none", "return", "np", "ndarray", "0", "0", "def", "searchsorted", "self", "v", "side", "left", "sorter", "none", "return", "np", "ndarray", "0", "0", "def", "setfield", "self", "val", "dtype", "offset", "0", "return", "none", "def", "setflags", "self", "write", "none", "align", "none", "uic", "none", "return", "none", "def", "sort", "self", "axis", "1", "kind", "quicksort", "order", "none", "return", "none", "def", "squeeze", "self", "axis", "none", "return", "np", "ndarray", "0", "0", "def", "std", "self", "axis", "none", "dtype", "none", "out", "none", "ddof", "0", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "sum", "self", "axis", "none", "dtype", "none", "out", "none", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "swapaxes", "self", "axis1", "axis2", "return", "np", "ndarray", "0", "0", "def", "take", "self", "indices", "axis", "none", "out", "none", "mode", "raise", "return", "np", "ndarray", "0", "0", "def", "tobytes", "self", "order", "c", "return", "b", "def", "tofile", "self", "fid", "sep", "format", "s", "return", "none", "def", "tolist", "self", "return", "def", "tostring", "self", "order", "c", "return", "b", "def", "trace", "self", "offset", "0", "axis1", "0", "axis2", "1", "dtype", "none", "out", "none", "return", "np", "ndarray", "0", "0", "def", "transpose", "self", "axes", "return", "np", "ndarray", "0", "0", "def", "var", "self", "axis", "none", "dtype", "none", "out", "none", "ddof", "0", "keepdims", "false", "return", "np", "ndarray", "0", "0", "def", "view", "self", "dtype", "none", "type", "none", "return", "np", "ndarray", "0", "0", "if", "numpy_supports_type_hints", "ndarray", "classmethod", "def", "__class_getitem__", "cls", "value", "return", "cls", "node", "extract_node", "ndarray", "return", "node", "infer", "context", "context"], "doc_len": 1160}
{"doc_id": "astroid/brain/brain_numpy_ndarray.py::_looks_like_numpy_ndarray", "file_path": "astroid/brain/brain_numpy_ndarray.py", "class_name": null, "func_name": "_looks_like_numpy_ndarray", "text": "文件路径: astroid/brain/brain_numpy_ndarray.py\ndef _looks_like_numpy_ndarray(node):\n    return isinstance(node, Attribute) and node.attrname == \"ndarray\"\n", "tokens": ["astroid", "brain", "brain_numpy_ndarray", "py", "def", "_looks_like_numpy_ndarray", "node", "return", "isinstance", "node", "attribute", "and", "node", "attrname", "ndarray"], "doc_len": 15}
{"doc_id": "astroid/brain/brain_numpy_random_mtrand.py::numpy_random_mtrand_transform", "file_path": "astroid/brain/brain_numpy_random_mtrand.py", "class_name": null, "func_name": "numpy_random_mtrand_transform", "text": "文件路径: astroid/brain/brain_numpy_random_mtrand.py\ndef numpy_random_mtrand_transform():\n    return parse(\n        \"\"\"\n    def beta(a, b, size=None): return uninferable\n    def binomial(n, p, size=None): return uninferable\n    def bytes(length): return uninferable\n    def chisquare(df, size=None): return uninferable\n    def choice(a, size=None, replace=True, p=None): return uninferable\n    def dirichlet(alpha, size=None): return uninferable\n    def exponential(scale=1.0, size=None): return uninferable\n    def f(dfnum, dfden, size=None): return uninferable\n    def gamma(shape, scale=1.0, size=None): return uninferable\n    def geometric(p, size=None): return uninferable\n    def get_state(): return uninferable\n    def gumbel(loc=0.0, scale=1.0, size=None): return uninferable\n    def hypergeometric(ngood, nbad, nsample, size=None): return uninferable\n    def laplace(loc=0.0, scale=1.0, size=None): return uninferable\n    def logistic(loc=0.0, scale=1.0, size=None): return uninferable\n    def lognormal(mean=0.0, sigma=1.0, size=None): return uninferable\n    def logseries(p, size=None): return uninferable\n    def multinomial(n, pvals, size=None): return uninferable\n    def multivariate_normal(mean, cov, size=None): return uninferable\n    def negative_binomial(n, p, size=None): return uninferable\n    def noncentral_chisquare(df, nonc, size=None): return uninferable\n    def noncentral_f(dfnum, dfden, nonc, size=None): return uninferable\n    def normal(loc=0.0, scale=1.0, size=None): return uninferable\n    def pareto(a, size=None): return uninferable\n    def permutation(x): return uninferable\n    def poisson(lam=1.0, size=None): return uninferable\n    def power(a, size=None): return uninferable\n    def rand(*args): return uninferable\n    def randint(low, high=None, size=None, dtype='l'):\n        import numpy\n        return numpy.ndarray((1,1))\n    def randn(*args): return uninferable\n    def random(size=None): return uninferable\n    def random_integers(low, high=None, size=None): return uninferable\n    def random_sample(size=None): return uninferable\n    def rayleigh(scale=1.0, size=None): return uninferable\n    def seed(seed=None): return uninferable\n    def set_state(state): return uninferable\n    def shuffle(x): return uninferable\n    def standard_cauchy(size=None): return uninferable\n    def standard_exponential(size=None): return uninferable\n    def standard_gamma(shape, size=None): return uninferable\n    def standard_normal(size=None): return uninferable\n    def standard_t(df, size=None): return uninferable\n    def triangular(left, mode, right, size=None): return uninferable\n    def uniform(low=0.0, high=1.0, size=None): return uninferable\n    def vonmises(mu, kappa, size=None): return uninferable\n    def wald(mean, scale, size=None): return uninferable\n    def weibull(a, size=None): return uninferable\n    def zipf(a, size=None): return uninferable\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_random_mtrand", "py", "def", "numpy_random_mtrand_transform", "return", "parse", "def", "beta", "a", "b", "size", "none", "return", "uninferable", "def", "binomial", "n", "p", "size", "none", "return", "uninferable", "def", "bytes", "length", "return", "uninferable", "def", "chisquare", "df", "size", "none", "return", "uninferable", "def", "choice", "a", "size", "none", "replace", "true", "p", "none", "return", "uninferable", "def", "dirichlet", "alpha", "size", "none", "return", "uninferable", "def", "exponential", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "f", "dfnum", "dfden", "size", "none", "return", "uninferable", "def", "gamma", "shape", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "geometric", "p", "size", "none", "return", "uninferable", "def", "get_state", "return", "uninferable", "def", "gumbel", "loc", "0", "0", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "hypergeometric", "ngood", "nbad", "nsample", "size", "none", "return", "uninferable", "def", "laplace", "loc", "0", "0", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "logistic", "loc", "0", "0", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "lognormal", "mean", "0", "0", "sigma", "1", "0", "size", "none", "return", "uninferable", "def", "logseries", "p", "size", "none", "return", "uninferable", "def", "multinomial", "n", "pvals", "size", "none", "return", "uninferable", "def", "multivariate_normal", "mean", "cov", "size", "none", "return", "uninferable", "def", "negative_binomial", "n", "p", "size", "none", "return", "uninferable", "def", "noncentral_chisquare", "df", "nonc", "size", "none", "return", "uninferable", "def", "noncentral_f", "dfnum", "dfden", "nonc", "size", "none", "return", "uninferable", "def", "normal", "loc", "0", "0", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "pareto", "a", "size", "none", "return", "uninferable", "def", "permutation", "x", "return", "uninferable", "def", "poisson", "lam", "1", "0", "size", "none", "return", "uninferable", "def", "power", "a", "size", "none", "return", "uninferable", "def", "rand", "args", "return", "uninferable", "def", "randint", "low", "high", "none", "size", "none", "dtype", "l", "import", "numpy", "return", "numpy", "ndarray", "1", "1", "def", "randn", "args", "return", "uninferable", "def", "random", "size", "none", "return", "uninferable", "def", "random_integers", "low", "high", "none", "size", "none", "return", "uninferable", "def", "random_sample", "size", "none", "return", "uninferable", "def", "rayleigh", "scale", "1", "0", "size", "none", "return", "uninferable", "def", "seed", "seed", "none", "return", "uninferable", "def", "set_state", "state", "return", "uninferable", "def", "shuffle", "x", "return", "uninferable", "def", "standard_cauchy", "size", "none", "return", "uninferable", "def", "standard_exponential", "size", "none", "return", "uninferable", "def", "standard_gamma", "shape", "size", "none", "return", "uninferable", "def", "standard_normal", "size", "none", "return", "uninferable", "def", "standard_t", "df", "size", "none", "return", "uninferable", "def", "triangular", "left", "mode", "right", "size", "none", "return", "uninferable", "def", "uniform", "low", "0", "0", "high", "1", "0", "size", "none", "return", "uninferable", "def", "vonmises", "mu", "kappa", "size", "none", "return", "uninferable", "def", "wald", "mean", "scale", "size", "none", "return", "uninferable", "def", "weibull", "a", "size", "none", "return", "uninferable", "def", "zipf", "a", "size", "none", "return", "uninferable"], "doc_len": 392}
{"doc_id": "astroid/brain/brain_numpy_utils.py::numpy_supports_type_hints", "file_path": "astroid/brain/brain_numpy_utils.py", "class_name": null, "func_name": "numpy_supports_type_hints", "text": "文件路径: astroid/brain/brain_numpy_utils.py\ndef numpy_supports_type_hints() -> bool:\n    \"\"\"\n    Returns True if numpy supports type hints\n    \"\"\"\n    np_ver = _get_numpy_version()\n    return np_ver and np_ver > NUMPY_VERSION_TYPE_HINTS_SUPPORT\n", "tokens": ["astroid", "brain", "brain_numpy_utils", "py", "def", "numpy_supports_type_hints", "bool", "returns", "true", "if", "numpy", "supports", "type", "hints", "np_ver", "_get_numpy_version", "return", "np_ver", "and", "np_ver", "numpy_version_type_hints_support"], "doc_len": 21}
{"doc_id": "astroid/brain/brain_numpy_utils.py::_get_numpy_version", "file_path": "astroid/brain/brain_numpy_utils.py", "class_name": null, "func_name": "_get_numpy_version", "text": "文件路径: astroid/brain/brain_numpy_utils.py\ndef _get_numpy_version() -> Tuple[str, str, str]:\n    \"\"\"\n    Return the numpy version number if numpy can be imported. Otherwise returns\n    ('0', '0', '0')\n    \"\"\"\n    try:\n        import numpy  # pylint: disable=import-outside-toplevel\n\n        return tuple(numpy.version.version.split(\".\"))\n    except ImportError:\n        return (\"0\", \"0\", \"0\")\n", "tokens": ["astroid", "brain", "brain_numpy_utils", "py", "def", "_get_numpy_version", "tuple", "str", "str", "str", "return", "the", "numpy", "version", "number", "if", "numpy", "can", "be", "imported", "otherwise", "returns", "0", "0", "0", "try", "import", "numpy", "pylint", "disable", "import", "outside", "toplevel", "return", "tuple", "numpy", "version", "version", "split", "except", "importerror", "return", "0", "0", "0"], "doc_len": 45}
{"doc_id": "astroid/brain/brain_numpy_utils.py::infer_numpy_member", "file_path": "astroid/brain/brain_numpy_utils.py", "class_name": null, "func_name": "infer_numpy_member", "text": "文件路径: astroid/brain/brain_numpy_utils.py\ndef infer_numpy_member(src, node, context=None):\n    node = extract_node(src)\n    return node.infer(context=context)\n", "tokens": ["astroid", "brain", "brain_numpy_utils", "py", "def", "infer_numpy_member", "src", "node", "context", "none", "node", "extract_node", "src", "return", "node", "infer", "context", "context"], "doc_len": 18}
{"doc_id": "astroid/brain/brain_numpy_utils.py::_is_a_numpy_module", "file_path": "astroid/brain/brain_numpy_utils.py", "class_name": null, "func_name": "_is_a_numpy_module", "text": "文件路径: astroid/brain/brain_numpy_utils.py\ndef _is_a_numpy_module(node: Name) -> bool:\n    \"\"\"\n    Returns True if the node is a representation of a numpy module.\n\n    For example in :\n        import numpy as np\n        x = np.linspace(1, 2)\n    The node <Name.np> is a representation of the numpy module.\n\n    :param node: node to test\n    :return: True if the node is a representation of the numpy module.\n    \"\"\"\n    module_nickname = node.name\n    potential_import_target = [\n        x for x in node.lookup(module_nickname)[1] if isinstance(x, Import)\n    ]\n    return any(\n        (\"numpy\", module_nickname) in target.names or (\"numpy\", None) in target.names\n        for target in potential_import_target\n    )\n", "tokens": ["astroid", "brain", "brain_numpy_utils", "py", "def", "_is_a_numpy_module", "node", "name", "bool", "returns", "true", "if", "the", "node", "is", "a", "representation", "of", "a", "numpy", "module", "for", "example", "in", "import", "numpy", "as", "np", "x", "np", "linspace", "1", "2", "the", "node", "name", "np", "is", "a", "representation", "of", "the", "numpy", "module", "param", "node", "node", "to", "test", "return", "true", "if", "the", "node", "is", "a", "representation", "of", "the", "numpy", "module", "module_nickname", "node", "name", "potential_import_target", "x", "for", "x", "in", "node", "lookup", "module_nickname", "1", "if", "isinstance", "x", "import", "return", "any", "numpy", "module_nickname", "in", "target", "names", "or", "numpy", "none", "in", "target", "names", "for", "target", "in", "potential_import_target"], "doc_len": 94}
{"doc_id": "astroid/brain/brain_numpy_utils.py::looks_like_numpy_member", "file_path": "astroid/brain/brain_numpy_utils.py", "class_name": null, "func_name": "looks_like_numpy_member", "text": "文件路径: astroid/brain/brain_numpy_utils.py\ndef looks_like_numpy_member(member_name: str, node: NodeNG) -> bool:\n    \"\"\"\n    Returns True if the node is a member of numpy whose\n    name is member_name.\n\n    :param member_name: name of the member\n    :param node: node to test\n    :return: True if the node is a member of numpy\n    \"\"\"\n    if (\n        isinstance(node, Attribute)\n        and node.attrname == member_name\n        and isinstance(node.expr, Name)\n        and _is_a_numpy_module(node.expr)\n    ):\n        return True\n    if (\n        isinstance(node, Name)\n        and node.name == member_name\n        and node.root().name.startswith(\"numpy\")\n    ):\n        return True\n    return False\n", "tokens": ["astroid", "brain", "brain_numpy_utils", "py", "def", "looks_like_numpy_member", "member_name", "str", "node", "nodeng", "bool", "returns", "true", "if", "the", "node", "is", "a", "member", "of", "numpy", "whose", "name", "is", "member_name", "param", "member_name", "name", "of", "the", "member", "param", "node", "node", "to", "test", "return", "true", "if", "the", "node", "is", "a", "member", "of", "numpy", "if", "isinstance", "node", "attribute", "and", "node", "attrname", "member_name", "and", "isinstance", "node", "expr", "name", "and", "_is_a_numpy_module", "node", "expr", "return", "true", "if", "isinstance", "node", "name", "and", "node", "name", "member_name", "and", "node", "root", "name", "startswith", "numpy", "return", "true", "return", "false"], "doc_len": 83}
{"doc_id": "astroid/brain/brain_pkg_resources.py::pkg_resources_transform", "file_path": "astroid/brain/brain_pkg_resources.py", "class_name": null, "func_name": "pkg_resources_transform", "text": "文件路径: astroid/brain/brain_pkg_resources.py\ndef pkg_resources_transform():\n    return parse(\n        \"\"\"\ndef require(*requirements):\n    return pkg_resources.working_set.require(*requirements)\n\ndef run_script(requires, script_name):\n    return pkg_resources.working_set.run_script(requires, script_name)\n\ndef iter_entry_points(group, name=None):\n    return pkg_resources.working_set.iter_entry_points(group, name)\n\ndef resource_exists(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).has_resource(resource_name)\n\ndef resource_isdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_isdir(\n        resource_name)\n\ndef resource_filename(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_filename(\n        self, resource_name)\n\ndef resource_stream(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_stream(\n        self, resource_name)\n\ndef resource_string(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).get_resource_string(\n        self, resource_name)\n\ndef resource_listdir(package_or_requirement, resource_name):\n    return get_provider(package_or_requirement).resource_listdir(\n        resource_name)\n\ndef extraction_error():\n    pass\n\ndef get_cache_path(archive_name, names=()):\n    extract_path = self.extraction_path or get_default_cache()\n    target_path = os.path.join(extract_path, archive_name+'-tmp', *names)\n    return target_path\n\ndef postprocess(tempname, filename):\n    pass\n\ndef set_extraction_path(path):\n    pass\n\ndef cleanup_resources(force=False):\n    pass\n\ndef get_distribution(dist):\n    return Distribution(dist)\n\n_namespace_packages = {}\n\"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_pkg_resources", "py", "def", "pkg_resources_transform", "return", "parse", "def", "require", "requirements", "return", "pkg_resources", "working_set", "require", "requirements", "def", "run_script", "requires", "script_name", "return", "pkg_resources", "working_set", "run_script", "requires", "script_name", "def", "iter_entry_points", "group", "name", "none", "return", "pkg_resources", "working_set", "iter_entry_points", "group", "name", "def", "resource_exists", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "has_resource", "resource_name", "def", "resource_isdir", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "resource_isdir", "resource_name", "def", "resource_filename", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "get_resource_filename", "self", "resource_name", "def", "resource_stream", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "get_resource_stream", "self", "resource_name", "def", "resource_string", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "get_resource_string", "self", "resource_name", "def", "resource_listdir", "package_or_requirement", "resource_name", "return", "get_provider", "package_or_requirement", "resource_listdir", "resource_name", "def", "extraction_error", "pass", "def", "get_cache_path", "archive_name", "names", "extract_path", "self", "extraction_path", "or", "get_default_cache", "target_path", "os", "path", "join", "extract_path", "archive_name", "tmp", "names", "return", "target_path", "def", "postprocess", "tempname", "filename", "pass", "def", "set_extraction_path", "path", "pass", "def", "cleanup_resources", "force", "false", "pass", "def", "get_distribution", "dist", "return", "distribution", "dist", "_namespace_packages"], "doc_len": 137}
{"doc_id": "astroid/brain/brain_pytest.py::pytest_transform", "file_path": "astroid/brain/brain_pytest.py", "class_name": null, "func_name": "pytest_transform", "text": "文件路径: astroid/brain/brain_pytest.py\ndef pytest_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"\n\ntry:\n    import _pytest.mark\n    import _pytest.recwarn\n    import _pytest.runner\n    import _pytest.python\n    import _pytest.skipping\n    import _pytest.assertion\nexcept ImportError:\n    pass\nelse:\n    deprecated_call = _pytest.recwarn.deprecated_call\n    warns = _pytest.recwarn.warns\n\n    exit = _pytest.runner.exit\n    fail = _pytest.runner.fail\n    skip = _pytest.runner.skip\n    importorskip = _pytest.runner.importorskip\n\n    xfail = _pytest.skipping.xfail\n    mark = _pytest.mark.MarkGenerator()\n    raises = _pytest.python.raises\n\n    # New in pytest 3.0\n    try:\n        approx = _pytest.python.approx\n        register_assert_rewrite = _pytest.assertion.register_assert_rewrite\n    except AttributeError:\n        pass\n\n\n# Moved in pytest 3.0\n\ntry:\n    import _pytest.freeze_support\n    freeze_includes = _pytest.freeze_support.freeze_includes\nexcept ImportError:\n    try:\n        import _pytest.genscript\n        freeze_includes = _pytest.genscript.freeze_includes\n    except ImportError:\n        pass\n\ntry:\n    import _pytest.debugging\n    set_trace = _pytest.debugging.pytestPDB().set_trace\nexcept ImportError:\n    try:\n        import _pytest.pdb\n        set_trace = _pytest.pdb.pytestPDB().set_trace\n    except ImportError:\n        pass\n\ntry:\n    import _pytest.fixtures\n    fixture = _pytest.fixtures.fixture\n    yield_fixture = _pytest.fixtures.yield_fixture\nexcept ImportError:\n    try:\n        import _pytest.python\n        fixture = _pytest.python.fixture\n        yield_fixture = _pytest.python.yield_fixture\n    except ImportError:\n        pass\n\"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_pytest", "py", "def", "pytest_transform", "return", "astroidbuilder", "astroidmanager", "string_build", "try", "import", "_pytest", "mark", "import", "_pytest", "recwarn", "import", "_pytest", "runner", "import", "_pytest", "python", "import", "_pytest", "skipping", "import", "_pytest", "assertion", "except", "importerror", "pass", "else", "deprecated_call", "_pytest", "recwarn", "deprecated_call", "warns", "_pytest", "recwarn", "warns", "exit", "_pytest", "runner", "exit", "fail", "_pytest", "runner", "fail", "skip", "_pytest", "runner", "skip", "importorskip", "_pytest", "runner", "importorskip", "xfail", "_pytest", "skipping", "xfail", "mark", "_pytest", "mark", "markgenerator", "raises", "_pytest", "python", "raises", "new", "in", "pytest", "3", "0", "try", "approx", "_pytest", "python", "approx", "register_assert_rewrite", "_pytest", "assertion", "register_assert_rewrite", "except", "attributeerror", "pass", "moved", "in", "pytest", "3", "0", "try", "import", "_pytest", "freeze_support", "freeze_includes", "_pytest", "freeze_support", "freeze_includes", "except", "importerror", "try", "import", "_pytest", "genscript", "freeze_includes", "_pytest", "genscript", "freeze_includes", "except", "importerror", "pass", "try", "import", "_pytest", "debugging", "set_trace", "_pytest", "debugging", "pytestpdb", "set_trace", "except", "importerror", "try", "import", "_pytest", "pdb", "set_trace", "_pytest", "pdb", "pytestpdb", "set_trace", "except", "importerror", "pass", "try", "import", "_pytest", "fixtures", "fixture", "_pytest", "fixtures", "fixture", "yield_fixture", "_pytest", "fixtures", "yield_fixture", "except", "importerror", "try", "import", "_pytest", "python", "fixture", "_pytest", "python", "fixture", "yield_fixture", "_pytest", "python", "yield_fixture", "except", "importerror", "pass"], "doc_len": 164}
{"doc_id": "astroid/brain/brain_qt.py::_looks_like_signal", "file_path": "astroid/brain/brain_qt.py", "class_name": null, "func_name": "_looks_like_signal", "text": "文件路径: astroid/brain/brain_qt.py\ndef _looks_like_signal(node, signal_name=\"pyqtSignal\"):\n    if \"__class__\" in node.instance_attrs:\n        try:\n            cls = node.instance_attrs[\"__class__\"][0]\n            return cls.name == signal_name\n        except AttributeError:\n            # return False if the cls does not have a name attribute\n            pass\n    return False\n", "tokens": ["astroid", "brain", "brain_qt", "py", "def", "_looks_like_signal", "node", "signal_name", "pyqtsignal", "if", "__class__", "in", "node", "instance_attrs", "try", "cls", "node", "instance_attrs", "__class__", "0", "return", "cls", "name", "signal_name", "except", "attributeerror", "return", "false", "if", "the", "cls", "does", "not", "have", "a", "name", "attribute", "pass", "return", "false"], "doc_len": 40}
{"doc_id": "astroid/brain/brain_qt.py::transform_pyqt_signal", "file_path": "astroid/brain/brain_qt.py", "class_name": null, "func_name": "transform_pyqt_signal", "text": "文件路径: astroid/brain/brain_qt.py\ndef transform_pyqt_signal(node):\n    module = parse(\n        \"\"\"\n    class pyqtSignal(object):\n        def connect(self, slot, type=None, no_receiver_check=False):\n            pass\n        def disconnect(self, slot):\n            pass\n        def emit(self, *args):\n            pass\n    \"\"\"\n    )\n    signal_cls = module[\"pyqtSignal\"]\n    node.instance_attrs[\"emit\"] = signal_cls[\"emit\"]\n    node.instance_attrs[\"disconnect\"] = signal_cls[\"disconnect\"]\n    node.instance_attrs[\"connect\"] = signal_cls[\"connect\"]\n", "tokens": ["astroid", "brain", "brain_qt", "py", "def", "transform_pyqt_signal", "node", "module", "parse", "class", "pyqtsignal", "object", "def", "connect", "self", "slot", "type", "none", "no_receiver_check", "false", "pass", "def", "disconnect", "self", "slot", "pass", "def", "emit", "self", "args", "pass", "signal_cls", "module", "pyqtsignal", "node", "instance_attrs", "emit", "signal_cls", "emit", "node", "instance_attrs", "disconnect", "signal_cls", "disconnect", "node", "instance_attrs", "connect", "signal_cls", "connect"], "doc_len": 49}
{"doc_id": "astroid/brain/brain_qt.py::transform_pyside_signal", "file_path": "astroid/brain/brain_qt.py", "class_name": null, "func_name": "transform_pyside_signal", "text": "文件路径: astroid/brain/brain_qt.py\ndef transform_pyside_signal(node):\n    module = parse(\n        \"\"\"\n    class NotPySideSignal(object):\n        def connect(self, receiver, type=None):\n            pass\n        def disconnect(self, receiver):\n            pass\n        def emit(self, *args):\n            pass\n    \"\"\"\n    )\n    signal_cls = module[\"NotPySideSignal\"]\n    node.instance_attrs[\"connect\"] = signal_cls[\"connect\"]\n    node.instance_attrs[\"disconnect\"] = signal_cls[\"disconnect\"]\n    node.instance_attrs[\"emit\"] = signal_cls[\"emit\"]\n", "tokens": ["astroid", "brain", "brain_qt", "py", "def", "transform_pyside_signal", "node", "module", "parse", "class", "notpysidesignal", "object", "def", "connect", "self", "receiver", "type", "none", "pass", "def", "disconnect", "self", "receiver", "pass", "def", "emit", "self", "args", "pass", "signal_cls", "module", "notpysidesignal", "node", "instance_attrs", "connect", "signal_cls", "connect", "node", "instance_attrs", "disconnect", "signal_cls", "disconnect", "node", "instance_attrs", "emit", "signal_cls", "emit"], "doc_len": 47}
{"doc_id": "astroid/brain/brain_qt.py::pyqt4_qtcore_transform", "file_path": "astroid/brain/brain_qt.py", "class_name": null, "func_name": "pyqt4_qtcore_transform", "text": "文件路径: astroid/brain/brain_qt.py\ndef pyqt4_qtcore_transform():\n    return AstroidBuilder(AstroidManager()).string_build(\n        \"\"\"\n\ndef SIGNAL(signal_name): pass\n\nclass QObject(object):\n    def emit(self, signal): pass\n\"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_qt", "py", "def", "pyqt4_qtcore_transform", "return", "astroidbuilder", "astroidmanager", "string_build", "def", "signal", "signal_name", "pass", "class", "qobject", "object", "def", "emit", "self", "signal", "pass"], "doc_len": 22}
{"doc_id": "astroid/brain/brain_random.py::_clone_node_with_lineno", "file_path": "astroid/brain/brain_random.py", "class_name": null, "func_name": "_clone_node_with_lineno", "text": "文件路径: astroid/brain/brain_random.py\ndef _clone_node_with_lineno(node, parent, lineno):\n    if isinstance(node, EvaluatedObject):\n        node = node.original\n    cls = node.__class__\n    other_fields = node._other_fields\n    _astroid_fields = node._astroid_fields\n    init_params = {\"lineno\": lineno, \"col_offset\": node.col_offset, \"parent\": parent}\n    postinit_params = {param: getattr(node, param) for param in _astroid_fields}\n    if other_fields:\n        init_params.update({param: getattr(node, param) for param in other_fields})\n    new_node = cls(**init_params)\n    if hasattr(node, \"postinit\") and _astroid_fields:\n        new_node.postinit(**postinit_params)\n    return new_node\n", "tokens": ["astroid", "brain", "brain_random", "py", "def", "_clone_node_with_lineno", "node", "parent", "lineno", "if", "isinstance", "node", "evaluatedobject", "node", "node", "original", "cls", "node", "__class__", "other_fields", "node", "_other_fields", "_astroid_fields", "node", "_astroid_fields", "init_params", "lineno", "lineno", "col_offset", "node", "col_offset", "parent", "parent", "postinit_params", "param", "getattr", "node", "param", "for", "param", "in", "_astroid_fields", "if", "other_fields", "init_params", "update", "param", "getattr", "node", "param", "for", "param", "in", "other_fields", "new_node", "cls", "init_params", "if", "hasattr", "node", "postinit", "and", "_astroid_fields", "new_node", "postinit", "postinit_params", "return", "new_node"], "doc_len": 68}
{"doc_id": "astroid/brain/brain_random.py::infer_random_sample", "file_path": "astroid/brain/brain_random.py", "class_name": null, "func_name": "infer_random_sample", "text": "文件路径: astroid/brain/brain_random.py\ndef infer_random_sample(node, context=None):\n    if len(node.args) != 2:\n        raise UseInferenceDefault\n\n    length = node.args[1]\n    if not isinstance(length, Const):\n        raise UseInferenceDefault\n    if not isinstance(length.value, int):\n        raise UseInferenceDefault\n\n    inferred_sequence = helpers.safe_infer(node.args[0], context=context)\n    if not inferred_sequence:\n        raise UseInferenceDefault\n\n    if not isinstance(inferred_sequence, ACCEPTED_ITERABLES_FOR_SAMPLE):\n        raise UseInferenceDefault\n\n    if length.value > len(inferred_sequence.elts):\n        # In this case, this will raise a ValueError\n        raise UseInferenceDefault\n\n    try:\n        elts = random.sample(inferred_sequence.elts, length.value)\n    except ValueError as exc:\n        raise UseInferenceDefault from exc\n\n    new_node = List(lineno=node.lineno, col_offset=node.col_offset, parent=node.scope())\n    new_elts = [\n        _clone_node_with_lineno(elt, parent=new_node, lineno=new_node.lineno)\n        for elt in elts\n    ]\n    new_node.postinit(new_elts)\n    return iter((new_node,))\n", "tokens": ["astroid", "brain", "brain_random", "py", "def", "infer_random_sample", "node", "context", "none", "if", "len", "node", "args", "2", "raise", "useinferencedefault", "length", "node", "args", "1", "if", "not", "isinstance", "length", "const", "raise", "useinferencedefault", "if", "not", "isinstance", "length", "value", "int", "raise", "useinferencedefault", "inferred_sequence", "helpers", "safe_infer", "node", "args", "0", "context", "context", "if", "not", "inferred_sequence", "raise", "useinferencedefault", "if", "not", "isinstance", "inferred_sequence", "accepted_iterables_for_sample", "raise", "useinferencedefault", "if", "length", "value", "len", "inferred_sequence", "elts", "in", "this", "case", "this", "will", "raise", "a", "valueerror", "raise", "useinferencedefault", "try", "elts", "random", "sample", "inferred_sequence", "elts", "length", "value", "except", "valueerror", "as", "exc", "raise", "useinferencedefault", "from", "exc", "new_node", "list", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "node", "scope", "new_elts", "_clone_node_with_lineno", "elt", "parent", "new_node", "lineno", "new_node", "lineno", "for", "elt", "in", "elts", "new_node", "postinit", "new_elts", "return", "iter", "new_node"], "doc_len": 116}
{"doc_id": "astroid/brain/brain_random.py::_looks_like_random_sample", "file_path": "astroid/brain/brain_random.py", "class_name": null, "func_name": "_looks_like_random_sample", "text": "文件路径: astroid/brain/brain_random.py\ndef _looks_like_random_sample(node):\n    func = node.func\n    if isinstance(func, Attribute):\n        return func.attrname == \"sample\"\n    if isinstance(func, Name):\n        return func.name == \"sample\"\n    return False\n", "tokens": ["astroid", "brain", "brain_random", "py", "def", "_looks_like_random_sample", "node", "func", "node", "func", "if", "isinstance", "func", "attribute", "return", "func", "attrname", "sample", "if", "isinstance", "func", "name", "return", "func", "name", "sample", "return", "false"], "doc_len": 28}
{"doc_id": "astroid/brain/brain_re.py::_re_transform", "file_path": "astroid/brain/brain_re.py", "class_name": null, "func_name": "_re_transform", "text": "文件路径: astroid/brain/brain_re.py\ndef _re_transform():\n    # Since Python 3.6 there is the RegexFlag enum\n    # where every entry will be exposed via updating globals()\n    return parse(\n        \"\"\"\n    import sre_compile\n    ASCII = sre_compile.SRE_FLAG_ASCII\n    IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE\n    LOCALE = sre_compile.SRE_FLAG_LOCALE\n    UNICODE = sre_compile.SRE_FLAG_UNICODE\n    MULTILINE = sre_compile.SRE_FLAG_MULTILINE\n    DOTALL = sre_compile.SRE_FLAG_DOTALL\n    VERBOSE = sre_compile.SRE_FLAG_VERBOSE\n    A = ASCII\n    I = IGNORECASE\n    L = LOCALE\n    U = UNICODE\n    M = MULTILINE\n    S = DOTALL\n    X = VERBOSE\n    TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE\n    T = TEMPLATE\n    DEBUG = sre_compile.SRE_FLAG_DEBUG\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_re", "py", "def", "_re_transform", "since", "python", "3", "6", "there", "is", "the", "regexflag", "enum", "where", "every", "entry", "will", "be", "exposed", "via", "updating", "globals", "return", "parse", "import", "sre_compile", "ascii", "sre_compile", "sre_flag_ascii", "ignorecase", "sre_compile", "sre_flag_ignorecase", "locale", "sre_compile", "sre_flag_locale", "unicode", "sre_compile", "sre_flag_unicode", "multiline", "sre_compile", "sre_flag_multiline", "dotall", "sre_compile", "sre_flag_dotall", "verbose", "sre_compile", "sre_flag_verbose", "a", "ascii", "i", "ignorecase", "l", "locale", "u", "unicode", "m", "multiline", "s", "dotall", "x", "verbose", "template", "sre_compile", "sre_flag_template", "t", "template", "debug", "sre_compile", "sre_flag_debug"], "doc_len": 71}
{"doc_id": "astroid/brain/brain_re.py::_looks_like_pattern_or_match", "file_path": "astroid/brain/brain_re.py", "class_name": null, "func_name": "_looks_like_pattern_or_match", "text": "文件路径: astroid/brain/brain_re.py\ndef _looks_like_pattern_or_match(node: nodes.Call) -> bool:\n    \"\"\"Check for re.Pattern or re.Match call in stdlib.\n\n    Match these patterns from stdlib/re.py\n    ```py\n    Pattern = type(...)\n    Match = type(...)\n    ```\n    \"\"\"\n    return (\n        node.root().name == \"re\"\n        and isinstance(node.func, nodes.Name)\n        and node.func.name == \"type\"\n        and isinstance(node.parent, nodes.Assign)\n        and len(node.parent.targets) == 1\n        and isinstance(node.parent.targets[0], nodes.AssignName)\n        and node.parent.targets[0].name in {\"Pattern\", \"Match\"}\n    )\n", "tokens": ["astroid", "brain", "brain_re", "py", "def", "_looks_like_pattern_or_match", "node", "nodes", "call", "bool", "check", "for", "re", "pattern", "or", "re", "match", "call", "in", "stdlib", "match", "these", "patterns", "from", "stdlib", "re", "py", "py", "pattern", "type", "match", "type", "return", "node", "root", "name", "re", "and", "isinstance", "node", "func", "nodes", "name", "and", "node", "func", "name", "type", "and", "isinstance", "node", "parent", "nodes", "assign", "and", "len", "node", "parent", "targets", "1", "and", "isinstance", "node", "parent", "targets", "0", "nodes", "assignname", "and", "node", "parent", "targets", "0", "name", "in", "pattern", "match"], "doc_len": 77}
{"doc_id": "astroid/brain/brain_re.py::infer_pattern_match", "file_path": "astroid/brain/brain_re.py", "class_name": null, "func_name": "infer_pattern_match", "text": "文件路径: astroid/brain/brain_re.py\ndef infer_pattern_match(\n    node: nodes.Call, ctx: Optional[context.InferenceContext] = None\n):\n    \"\"\"Infer re.Pattern and re.Match as classes. For PY39+ add `__class_getitem__`.\"\"\"\n    class_def = nodes.ClassDef(\n        name=node.parent.targets[0].name,\n        lineno=node.lineno,\n        col_offset=node.col_offset,\n        parent=node.parent,\n    )\n    if PY39_PLUS:\n        func_to_add = extract_node(CLASS_GETITEM_TEMPLATE)\n        class_def.locals[\"__class_getitem__\"] = [func_to_add]\n    return iter([class_def])\n", "tokens": ["astroid", "brain", "brain_re", "py", "def", "infer_pattern_match", "node", "nodes", "call", "ctx", "optional", "context", "inferencecontext", "none", "infer", "re", "pattern", "and", "re", "match", "as", "classes", "for", "py39", "add", "__class_getitem__", "class_def", "nodes", "classdef", "name", "node", "parent", "targets", "0", "name", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "node", "parent", "if", "py39_plus", "func_to_add", "extract_node", "class_getitem_template", "class_def", "locals", "__class_getitem__", "func_to_add", "return", "iter", "class_def"], "doc_len": 56}
{"doc_id": "astroid/brain/brain_responses.py::responses_funcs", "file_path": "astroid/brain/brain_responses.py", "class_name": null, "func_name": "responses_funcs", "text": "文件路径: astroid/brain/brain_responses.py\ndef responses_funcs():\n    return parse(\n        \"\"\"\n        DELETE = \"DELETE\"\n        GET = \"GET\"\n        HEAD = \"HEAD\"\n        OPTIONS = \"OPTIONS\"\n        PATCH = \"PATCH\"\n        POST = \"POST\"\n        PUT = \"PUT\"\n        response_callback = None\n\n        def reset():\n            return\n\n        def add(\n            method=None,  # method or ``Response``\n            url=None,\n            body=\"\",\n            adding_headers=None,\n            *args,\n            **kwargs\n        ):\n            return\n\n        def add_passthru(prefix):\n            return\n\n        def remove(method_or_response=None, url=None):\n            return\n\n        def replace(method_or_response=None, url=None, body=\"\", *args, **kwargs):\n            return\n\n        def add_callback(\n            method, url, callback, match_querystring=False, content_type=\"text/plain\"\n        ):\n            return\n\n        calls = []\n\n        def __enter__():\n            return\n\n        def __exit__(type, value, traceback):\n            success = type is None\n            return success\n\n        def activate(func):\n            return func\n\n        def start():\n            return\n\n        def stop(allow_assert=True):\n            return\n        \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_responses", "py", "def", "responses_funcs", "return", "parse", "delete", "delete", "get", "get", "head", "head", "options", "options", "patch", "patch", "post", "post", "put", "put", "response_callback", "none", "def", "reset", "return", "def", "add", "method", "none", "method", "or", "response", "url", "none", "body", "adding_headers", "none", "args", "kwargs", "return", "def", "add_passthru", "prefix", "return", "def", "remove", "method_or_response", "none", "url", "none", "return", "def", "replace", "method_or_response", "none", "url", "none", "body", "args", "kwargs", "return", "def", "add_callback", "method", "url", "callback", "match_querystring", "false", "content_type", "text", "plain", "return", "calls", "def", "__enter__", "return", "def", "__exit__", "type", "value", "traceback", "success", "type", "is", "none", "return", "success", "def", "activate", "func", "return", "func", "def", "start", "return", "def", "stop", "allow_assert", "true", "return"], "doc_len": 102}
{"doc_id": "astroid/brain/brain_scipy_signal.py::scipy_signal", "file_path": "astroid/brain/brain_scipy_signal.py", "class_name": null, "func_name": "scipy_signal", "text": "文件路径: astroid/brain/brain_scipy_signal.py\ndef scipy_signal():\n    return parse(\n        \"\"\"\n    # different functions defined in scipy.signals\n\n    def barthann(M, sym=True):\n        return numpy.ndarray([0])\n\n    def bartlett(M, sym=True):\n        return numpy.ndarray([0])\n\n    def blackman(M, sym=True):\n        return numpy.ndarray([0])\n\n    def blackmanharris(M, sym=True):\n        return numpy.ndarray([0])\n\n    def bohman(M, sym=True):\n        return numpy.ndarray([0])\n\n    def boxcar(M, sym=True):\n        return numpy.ndarray([0])\n\n    def chebwin(M, at, sym=True):\n        return numpy.ndarray([0])\n\n    def cosine(M, sym=True):\n        return numpy.ndarray([0])\n\n    def exponential(M, center=None, tau=1.0, sym=True):\n        return numpy.ndarray([0])\n\n    def flattop(M, sym=True):\n        return numpy.ndarray([0])\n\n    def gaussian(M, std, sym=True):\n        return numpy.ndarray([0])\n\n    def general_gaussian(M, p, sig, sym=True):\n        return numpy.ndarray([0])\n\n    def hamming(M, sym=True):\n        return numpy.ndarray([0])\n\n    def hann(M, sym=True):\n        return numpy.ndarray([0])\n\n    def hanning(M, sym=True):\n        return numpy.ndarray([0])\n\n    def impulse2(system, X0=None, T=None, N=None, **kwargs):\n        return numpy.ndarray([0]), numpy.ndarray([0])\n\n    def kaiser(M, beta, sym=True):\n        return numpy.ndarray([0])\n\n    def nuttall(M, sym=True):\n        return numpy.ndarray([0])\n\n    def parzen(M, sym=True):\n        return numpy.ndarray([0])\n\n    def slepian(M, width, sym=True):\n        return numpy.ndarray([0])\n\n    def step2(system, X0=None, T=None, N=None, **kwargs):\n        return numpy.ndarray([0]), numpy.ndarray([0])\n\n    def triang(M, sym=True):\n        return numpy.ndarray([0])\n\n    def tukey(M, alpha=0.5, sym=True):\n        return numpy.ndarray([0])\n        \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_scipy_signal", "py", "def", "scipy_signal", "return", "parse", "different", "functions", "defined", "in", "scipy", "signals", "def", "barthann", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "bartlett", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "blackman", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "blackmanharris", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "bohman", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "boxcar", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "chebwin", "m", "at", "sym", "true", "return", "numpy", "ndarray", "0", "def", "cosine", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "exponential", "m", "center", "none", "tau", "1", "0", "sym", "true", "return", "numpy", "ndarray", "0", "def", "flattop", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "gaussian", "m", "std", "sym", "true", "return", "numpy", "ndarray", "0", "def", "general_gaussian", "m", "p", "sig", "sym", "true", "return", "numpy", "ndarray", "0", "def", "hamming", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "hann", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "hanning", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "impulse2", "system", "x0", "none", "t", "none", "n", "none", "kwargs", "return", "numpy", "ndarray", "0", "numpy", "ndarray", "0", "def", "kaiser", "m", "beta", "sym", "true", "return", "numpy", "ndarray", "0", "def", "nuttall", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "parzen", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "slepian", "m", "width", "sym", "true", "return", "numpy", "ndarray", "0", "def", "step2", "system", "x0", "none", "t", "none", "n", "none", "kwargs", "return", "numpy", "ndarray", "0", "numpy", "ndarray", "0", "def", "triang", "m", "sym", "true", "return", "numpy", "ndarray", "0", "def", "tukey", "m", "alpha", "0", "5", "sym", "true", "return", "numpy", "ndarray", "0"], "doc_len": 251}
{"doc_id": "astroid/brain/brain_signal.py::_signals_enums_transform", "file_path": "astroid/brain/brain_signal.py", "class_name": null, "func_name": "_signals_enums_transform", "text": "文件路径: astroid/brain/brain_signal.py\ndef _signals_enums_transform():\n    \"\"\"Generates the AST for 'Signals', 'Handlers' and 'Sigmasks' IntEnums.\"\"\"\n    return parse(_signals_enum() + _handlers_enum() + _sigmasks_enum())\n", "tokens": ["astroid", "brain", "brain_signal", "py", "def", "_signals_enums_transform", "generates", "the", "ast", "for", "signals", "handlers", "and", "sigmasks", "intenums", "return", "parse", "_signals_enum", "_handlers_enum", "_sigmasks_enum"], "doc_len": 20}
{"doc_id": "astroid/brain/brain_signal.py::_signals_enum", "file_path": "astroid/brain/brain_signal.py", "class_name": null, "func_name": "_signals_enum", "text": "文件路径: astroid/brain/brain_signal.py\ndef _signals_enum():\n    \"\"\"Generates the source code for the Signals int enum.\"\"\"\n    signals_enum = \"\"\"\n    import enum\n    class Signals(enum.IntEnum):\n        SIGABRT   = enum.auto()\n        SIGEMT    = enum.auto()\n        SIGFPE    = enum.auto()\n        SIGILL    = enum.auto()\n        SIGINFO   = enum.auto()\n        SIGINT    = enum.auto()\n        SIGSEGV   = enum.auto()\n        SIGTERM   = enum.auto()\n    \"\"\"\n    if sys.platform != \"win32\":\n        signals_enum += \"\"\"\n        SIGALRM   = enum.auto()\n        SIGBUS    = enum.auto()\n        SIGCHLD   = enum.auto()\n        SIGCONT   = enum.auto()\n        SIGHUP    = enum.auto()\n        SIGIO     = enum.auto()\n        SIGIOT    = enum.auto()\n        SIGKILL   = enum.auto()\n        SIGPIPE   = enum.auto()\n        SIGPROF   = enum.auto()\n        SIGQUIT   = enum.auto()\n        SIGSTOP   = enum.auto()\n        SIGSYS    = enum.auto()\n        SIGTRAP   = enum.auto()\n        SIGTSTP   = enum.auto()\n        SIGTTIN   = enum.auto()\n        SIGTTOU   = enum.auto()\n        SIGURG    = enum.auto()\n        SIGUSR1   = enum.auto()\n        SIGUSR2   = enum.auto()\n        SIGVTALRM = enum.auto()\n        SIGWINCH  = enum.auto()\n        SIGXCPU   = enum.auto()\n        SIGXFSZ   = enum.auto()\n        \"\"\"\n    if sys.platform == \"win32\":\n        signals_enum += \"\"\"\n        SIGBREAK  = enum.auto()\n        \"\"\"\n    if sys.platform not in (\"darwin\", \"win32\"):\n        signals_enum += \"\"\"\n        SIGCLD    = enum.auto()\n        SIGPOLL   = enum.auto()\n        SIGPWR    = enum.auto()\n        SIGRTMAX  = enum.auto()\n        SIGRTMIN  = enum.auto()\n        \"\"\"\n    return signals_enum\n", "tokens": ["astroid", "brain", "brain_signal", "py", "def", "_signals_enum", "generates", "the", "source", "code", "for", "the", "signals", "int", "enum", "signals_enum", "import", "enum", "class", "signals", "enum", "intenum", "sigabrt", "enum", "auto", "sigemt", "enum", "auto", "sigfpe", "enum", "auto", "sigill", "enum", "auto", "siginfo", "enum", "auto", "sigint", "enum", "auto", "sigsegv", "enum", "auto", "sigterm", "enum", "auto", "if", "sys", "platform", "win32", "signals_enum", "sigalrm", "enum", "auto", "sigbus", "enum", "auto", "sigchld", "enum", "auto", "sigcont", "enum", "auto", "sighup", "enum", "auto", "sigio", "enum", "auto", "sigiot", "enum", "auto", "sigkill", "enum", "auto", "sigpipe", "enum", "auto", "sigprof", "enum", "auto", "sigquit", "enum", "auto", "sigstop", "enum", "auto", "sigsys", "enum", "auto", "sigtrap", "enum", "auto", "sigtstp", "enum", "auto", "sigttin", "enum", "auto", "sigttou", "enum", "auto", "sigurg", "enum", "auto", "sigusr1", "enum", "auto", "sigusr2", "enum", "auto", "sigvtalrm", "enum", "auto", "sigwinch", "enum", "auto", "sigxcpu", "enum", "auto", "sigxfsz", "enum", "auto", "if", "sys", "platform", "win32", "signals_enum", "sigbreak", "enum", "auto", "if", "sys", "platform", "not", "in", "darwin", "win32", "signals_enum", "sigcld", "enum", "auto", "sigpoll", "enum", "auto", "sigpwr", "enum", "auto", "sigrtmax", "enum", "auto", "sigrtmin", "enum", "auto", "return", "signals_enum"], "doc_len": 156}
{"doc_id": "astroid/brain/brain_signal.py::_handlers_enum", "file_path": "astroid/brain/brain_signal.py", "class_name": null, "func_name": "_handlers_enum", "text": "文件路径: astroid/brain/brain_signal.py\ndef _handlers_enum():\n    \"\"\"Generates the source code for the Handlers int enum.\"\"\"\n    return \"\"\"\n    import enum\n    class Handlers(enum.IntEnum):\n        SIG_DFL = enum.auto()\n        SIG_IGN = eunm.auto()\n    \"\"\"\n", "tokens": ["astroid", "brain", "brain_signal", "py", "def", "_handlers_enum", "generates", "the", "source", "code", "for", "the", "handlers", "int", "enum", "return", "import", "enum", "class", "handlers", "enum", "intenum", "sig_dfl", "enum", "auto", "sig_ign", "eunm", "auto"], "doc_len": 28}
{"doc_id": "astroid/brain/brain_signal.py::_sigmasks_enum", "file_path": "astroid/brain/brain_signal.py", "class_name": null, "func_name": "_sigmasks_enum", "text": "文件路径: astroid/brain/brain_signal.py\ndef _sigmasks_enum():\n    \"\"\"Generates the source code for the Sigmasks int enum.\"\"\"\n    if sys.platform != \"win32\":\n        return \"\"\"\n    import enum\n    class Sigmasks(enum.IntEnum):\n        SIG_BLOCK   = enum.auto()\n        SIG_UNBLOCK = enum.auto()\n        SIG_SETMASK = enum.auto()\n        \"\"\"\n    return \"\"\n", "tokens": ["astroid", "brain", "brain_signal", "py", "def", "_sigmasks_enum", "generates", "the", "source", "code", "for", "the", "sigmasks", "int", "enum", "if", "sys", "platform", "win32", "return", "import", "enum", "class", "sigmasks", "enum", "intenum", "sig_block", "enum", "auto", "sig_unblock", "enum", "auto", "sig_setmask", "enum", "auto", "return"], "doc_len": 36}
{"doc_id": "astroid/brain/brain_six.py::default_predicate", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "default_predicate", "text": "文件路径: astroid/brain/brain_six.py\ndef default_predicate(line):\n    return line.strip()\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "default_predicate", "line", "return", "line", "strip"], "doc_len": 10}
{"doc_id": "astroid/brain/brain_six.py::_indent", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "_indent", "text": "文件路径: astroid/brain/brain_six.py\ndef _indent(text, prefix, predicate=default_predicate):\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"\n\n    def prefixed_lines():\n        for line in text.splitlines(True):\n            yield prefix + line if predicate(line) else line\n\n    return \"\".join(prefixed_lines())\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "_indent", "text", "prefix", "predicate", "default_predicate", "adds", "prefix", "to", "the", "beginning", "of", "selected", "lines", "in", "text", "if", "predicate", "is", "provided", "prefix", "will", "only", "be", "added", "to", "the", "lines", "where", "predicate", "line", "is", "true", "if", "predicate", "is", "not", "provided", "it", "will", "default", "to", "adding", "prefix", "to", "all", "non", "empty", "lines", "that", "do", "not", "consist", "solely", "of", "whitespace", "characters", "def", "prefixed_lines", "for", "line", "in", "text", "splitlines", "true", "yield", "prefix", "line", "if", "predicate", "line", "else", "line", "return", "join", "prefixed_lines"], "doc_len": 80}
{"doc_id": "astroid/brain/brain_six.py::six_moves_transform", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "six_moves_transform", "text": "文件路径: astroid/brain/brain_six.py\ndef six_moves_transform():\n    code = dedent(\n        \"\"\"\n    class Moves(object):\n    {}\n    moves = Moves()\n    \"\"\"\n    ).format(_indent(_IMPORTS, \"    \"))\n    module = AstroidBuilder(AstroidManager()).string_build(code)\n    module.name = \"six.moves\"\n    return module\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "six_moves_transform", "code", "dedent", "class", "moves", "object", "moves", "moves", "format", "_indent", "_imports", "module", "astroidbuilder", "astroidmanager", "string_build", "code", "module", "name", "six", "moves", "return", "module"], "doc_len": 27}
{"doc_id": "astroid/brain/brain_six.py::_six_fail_hook", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "_six_fail_hook", "text": "文件路径: astroid/brain/brain_six.py\ndef _six_fail_hook(modname):\n    \"\"\"Fix six.moves imports due to the dynamic nature of this\n    class.\n\n    Construct a pseudo-module which contains all the necessary imports\n    for six\n\n    :param modname: Name of failed module\n    :type modname: str\n\n    :return: An astroid module\n    :rtype: nodes.Module\n    \"\"\"\n\n    attribute_of = modname != \"six.moves\" and modname.startswith(\"six.moves\")\n    if modname != \"six.moves\" and not attribute_of:\n        raise AstroidBuildingError(modname=modname)\n    module = AstroidBuilder(AstroidManager()).string_build(_IMPORTS)\n    module.name = \"six.moves\"\n    if attribute_of:\n        # Facilitate import of submodules in Moves\n        start_index = len(module.name)\n        attribute = modname[start_index:].lstrip(\".\").replace(\".\", \"_\")\n        try:\n            import_attr = module.getattr(attribute)[0]\n        except AttributeInferenceError as exc:\n            raise AstroidBuildingError(modname=modname) from exc\n        if isinstance(import_attr, nodes.Import):\n            submodule = AstroidManager().ast_from_module_name(import_attr.names[0][0])\n            return submodule\n    # Let dummy submodule imports pass through\n    # This will cause an Uninferable result, which is okay\n    return module\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "_six_fail_hook", "modname", "fix", "six", "moves", "imports", "due", "to", "the", "dynamic", "nature", "of", "this", "class", "construct", "a", "pseudo", "module", "which", "contains", "all", "the", "necessary", "imports", "for", "six", "param", "modname", "name", "of", "failed", "module", "type", "modname", "str", "return", "an", "astroid", "module", "rtype", "nodes", "module", "attribute_of", "modname", "six", "moves", "and", "modname", "startswith", "six", "moves", "if", "modname", "six", "moves", "and", "not", "attribute_of", "raise", "astroidbuildingerror", "modname", "modname", "module", "astroidbuilder", "astroidmanager", "string_build", "_imports", "module", "name", "six", "moves", "if", "attribute_of", "facilitate", "import", "of", "submodules", "in", "moves", "start_index", "len", "module", "name", "attribute", "modname", "start_index", "lstrip", "replace", "_", "try", "import_attr", "module", "getattr", "attribute", "0", "except", "attributeinferenceerror", "as", "exc", "raise", "astroidbuildingerror", "modname", "modname", "from", "exc", "if", "isinstance", "import_attr", "nodes", "import", "submodule", "astroidmanager", "ast_from_module_name", "import_attr", "names", "0", "0", "return", "submodule", "let", "dummy", "submodule", "imports", "pass", "through", "this", "will", "cause", "an", "uninferable", "result", "which", "is", "okay", "return", "module"], "doc_len": 141}
{"doc_id": "astroid/brain/brain_six.py::_looks_like_decorated_with_six_add_metaclass", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "_looks_like_decorated_with_six_add_metaclass", "text": "文件路径: astroid/brain/brain_six.py\ndef _looks_like_decorated_with_six_add_metaclass(node):\n    if not node.decorators:\n        return False\n\n    for decorator in node.decorators.nodes:\n        if not isinstance(decorator, nodes.Call):\n            continue\n        if decorator.func.as_string() == SIX_ADD_METACLASS:\n            return True\n    return False\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "_looks_like_decorated_with_six_add_metaclass", "node", "if", "not", "node", "decorators", "return", "false", "for", "decorator", "in", "node", "decorators", "nodes", "if", "not", "isinstance", "decorator", "nodes", "call", "continue", "if", "decorator", "func", "as_string", "six_add_metaclass", "return", "true", "return", "false"], "doc_len": 35}
{"doc_id": "astroid/brain/brain_six.py::transform_six_add_metaclass", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "transform_six_add_metaclass", "text": "文件路径: astroid/brain/brain_six.py\ndef transform_six_add_metaclass(node):  # pylint: disable=inconsistent-return-statements\n    \"\"\"Check if the given class node is decorated with *six.add_metaclass*\n\n    If so, inject its argument as the metaclass of the underlying class.\n    \"\"\"\n    if not node.decorators:\n        return\n\n    for decorator in node.decorators.nodes:\n        if not isinstance(decorator, nodes.Call):\n            continue\n\n        try:\n            func = next(decorator.func.infer())\n        except (InferenceError, StopIteration):\n            continue\n        if func.qname() == SIX_ADD_METACLASS and decorator.args:\n            metaclass = decorator.args[0]\n            node._metaclass = metaclass\n            return node\n    return\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "transform_six_add_metaclass", "node", "pylint", "disable", "inconsistent", "return", "statements", "check", "if", "the", "given", "class", "node", "is", "decorated", "with", "six", "add_metaclass", "if", "so", "inject", "its", "argument", "as", "the", "metaclass", "of", "the", "underlying", "class", "if", "not", "node", "decorators", "return", "for", "decorator", "in", "node", "decorators", "nodes", "if", "not", "isinstance", "decorator", "nodes", "call", "continue", "try", "func", "next", "decorator", "func", "infer", "except", "inferenceerror", "stopiteration", "continue", "if", "func", "qname", "six_add_metaclass", "and", "decorator", "args", "metaclass", "decorator", "args", "0", "node", "_metaclass", "metaclass", "return", "node", "return"], "doc_len": 80}
{"doc_id": "astroid/brain/brain_six.py::_looks_like_nested_from_six_with_metaclass", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "_looks_like_nested_from_six_with_metaclass", "text": "文件路径: astroid/brain/brain_six.py\ndef _looks_like_nested_from_six_with_metaclass(node):\n    if len(node.bases) != 1:\n        return False\n    base = node.bases[0]\n    if not isinstance(base, nodes.Call):\n        return False\n    try:\n        if hasattr(base.func, \"expr\"):\n            # format when explicit 'six.with_metaclass' is used\n            mod = base.func.expr.name\n            func = base.func.attrname\n            func = f\"{mod}.{func}\"\n        else:\n            # format when 'with_metaclass' is used directly (local import from six)\n            # check reference module to avoid 'with_metaclass' name clashes\n            mod = base.parent.parent\n            import_from = mod.locals[\"with_metaclass\"][0]\n            func = f\"{import_from.modname}.{base.func.name}\"\n    except (AttributeError, KeyError, IndexError):\n        return False\n    return func == SIX_WITH_METACLASS\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "_looks_like_nested_from_six_with_metaclass", "node", "if", "len", "node", "bases", "1", "return", "false", "base", "node", "bases", "0", "if", "not", "isinstance", "base", "nodes", "call", "return", "false", "try", "if", "hasattr", "base", "func", "expr", "format", "when", "explicit", "six", "with_metaclass", "is", "used", "mod", "base", "func", "expr", "name", "func", "base", "func", "attrname", "func", "f", "mod", "func", "else", "format", "when", "with_metaclass", "is", "used", "directly", "local", "import", "from", "six", "check", "reference", "module", "to", "avoid", "with_metaclass", "name", "clashes", "mod", "base", "parent", "parent", "import_from", "mod", "locals", "with_metaclass", "0", "func", "f", "import_from", "modname", "base", "func", "name", "except", "attributeerror", "keyerror", "indexerror", "return", "false", "return", "func", "six_with_metaclass"], "doc_len": 96}
{"doc_id": "astroid/brain/brain_six.py::transform_six_with_metaclass", "file_path": "astroid/brain/brain_six.py", "class_name": null, "func_name": "transform_six_with_metaclass", "text": "文件路径: astroid/brain/brain_six.py\ndef transform_six_with_metaclass(node):\n    \"\"\"Check if the given class node is defined with *six.with_metaclass*\n\n    If so, inject its argument as the metaclass of the underlying class.\n    \"\"\"\n    call = node.bases[0]\n    node._metaclass = call.args[0]\n    return node\n", "tokens": ["astroid", "brain", "brain_six", "py", "def", "transform_six_with_metaclass", "node", "check", "if", "the", "given", "class", "node", "is", "defined", "with", "six", "with_metaclass", "if", "so", "inject", "its", "argument", "as", "the", "metaclass", "of", "the", "underlying", "class", "call", "node", "bases", "0", "node", "_metaclass", "call", "args", "0", "return", "node"], "doc_len": 41}
{"doc_id": "astroid/brain/brain_sqlalchemy.py::_session_transform", "file_path": "astroid/brain/brain_sqlalchemy.py", "class_name": null, "func_name": "_session_transform", "text": "文件路径: astroid/brain/brain_sqlalchemy.py\ndef _session_transform():\n    return parse(\n        \"\"\"\n    from sqlalchemy.orm.session import Session\n\n    class sessionmaker:\n        def __init__(\n            self,\n            bind=None,\n            class_=Session,\n            autoflush=True,\n            autocommit=False,\n            expire_on_commit=True,\n            info=None,\n            **kw\n        ):\n            return\n\n        def __call__(self, **local_kw):\n            return Session()\n\n        def configure(self, **new_kw):\n            return\n\n        return Session()\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_sqlalchemy", "py", "def", "_session_transform", "return", "parse", "from", "sqlalchemy", "orm", "session", "import", "session", "class", "sessionmaker", "def", "__init__", "self", "bind", "none", "class_", "session", "autoflush", "true", "autocommit", "false", "expire_on_commit", "true", "info", "none", "kw", "return", "def", "__call__", "self", "local_kw", "return", "session", "def", "configure", "self", "new_kw", "return", "return", "session"], "doc_len": 46}
{"doc_id": "astroid/brain/brain_ssl.py::ssl_transform", "file_path": "astroid/brain/brain_ssl.py", "class_name": null, "func_name": "ssl_transform", "text": "文件路径: astroid/brain/brain_ssl.py\ndef ssl_transform():\n    return parse(\n        \"\"\"\n    from _ssl import OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_INFO, OPENSSL_VERSION\n    from _ssl import _SSLContext, MemoryBIO\n    from _ssl import (\n        SSLError, SSLZeroReturnError, SSLWantReadError, SSLWantWriteError,\n        SSLSyscallError, SSLEOFError,\n        )\n    from _ssl import CERT_NONE, CERT_OPTIONAL, CERT_REQUIRED\n    from _ssl import txt2obj as _txt2obj, nid2obj as _nid2obj\n    from _ssl import RAND_status, RAND_add, RAND_bytes, RAND_pseudo_bytes\n    try:\n        from _ssl import RAND_egd\n    except ImportError:\n        # LibreSSL does not provide RAND_egd\n        pass\n    from _ssl import (OP_ALL, OP_CIPHER_SERVER_PREFERENCE,\n                      OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3,\n                      OP_NO_TLSv1, OP_NO_TLSv1_1, OP_NO_TLSv1_2,\n                      OP_SINGLE_DH_USE, OP_SINGLE_ECDH_USE)\n\n    from _ssl import (ALERT_DESCRIPTION_ACCESS_DENIED, ALERT_DESCRIPTION_BAD_CERTIFICATE,\n                      ALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE,\n                      ALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE,\n                      ALERT_DESCRIPTION_BAD_RECORD_MAC,\n                      ALERT_DESCRIPTION_CERTIFICATE_EXPIRED,\n                      ALERT_DESCRIPTION_CERTIFICATE_REVOKED,\n                      ALERT_DESCRIPTION_CERTIFICATE_UNKNOWN,\n                      ALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE,\n                      ALERT_DESCRIPTION_CLOSE_NOTIFY, ALERT_DESCRIPTION_DECODE_ERROR,\n                      ALERT_DESCRIPTION_DECOMPRESSION_FAILURE,\n                      ALERT_DESCRIPTION_DECRYPT_ERROR,\n                      ALERT_DESCRIPTION_HANDSHAKE_FAILURE,\n                      ALERT_DESCRIPTION_ILLEGAL_PARAMETER,\n                      ALERT_DESCRIPTION_INSUFFICIENT_SECURITY,\n                      ALERT_DESCRIPTION_INTERNAL_ERROR,\n                      ALERT_DESCRIPTION_NO_RENEGOTIATION,\n                      ALERT_DESCRIPTION_PROTOCOL_VERSION,\n                      ALERT_DESCRIPTION_RECORD_OVERFLOW,\n                      ALERT_DESCRIPTION_UNEXPECTED_MESSAGE,\n                      ALERT_DESCRIPTION_UNKNOWN_CA,\n                      ALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY,\n                      ALERT_DESCRIPTION_UNRECOGNIZED_NAME,\n                      ALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE,\n                      ALERT_DESCRIPTION_UNSUPPORTED_EXTENSION,\n                      ALERT_DESCRIPTION_USER_CANCELLED)\n    from _ssl import (SSL_ERROR_EOF, SSL_ERROR_INVALID_ERROR_CODE, SSL_ERROR_SSL,\n                      SSL_ERROR_SYSCALL, SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_READ,\n                      SSL_ERROR_WANT_WRITE, SSL_ERROR_WANT_X509_LOOKUP, SSL_ERROR_ZERO_RETURN)\n    from _ssl import VERIFY_CRL_CHECK_CHAIN, VERIFY_CRL_CHECK_LEAF, VERIFY_DEFAULT, VERIFY_X509_STRICT\n    from _ssl import HAS_SNI, HAS_ECDH, HAS_NPN, HAS_ALPN\n    from _ssl import _OPENSSL_API_VERSION\n    from _ssl import PROTOCOL_SSLv23, PROTOCOL_TLSv1, PROTOCOL_TLSv1_1, PROTOCOL_TLSv1_2\n    from _ssl import PROTOCOL_TLS, PROTOCOL_TLS_CLIENT, PROTOCOL_TLS_SERVER\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_ssl", "py", "def", "ssl_transform", "return", "parse", "from", "_ssl", "import", "openssl_version_number", "openssl_version_info", "openssl_version", "from", "_ssl", "import", "_sslcontext", "memorybio", "from", "_ssl", "import", "sslerror", "sslzeroreturnerror", "sslwantreaderror", "sslwantwriteerror", "sslsyscallerror", "ssleoferror", "from", "_ssl", "import", "cert_none", "cert_optional", "cert_required", "from", "_ssl", "import", "txt2obj", "as", "_txt2obj", "nid2obj", "as", "_nid2obj", "from", "_ssl", "import", "rand_status", "rand_add", "rand_bytes", "rand_pseudo_bytes", "try", "from", "_ssl", "import", "rand_egd", "except", "importerror", "libressl", "does", "not", "provide", "rand_egd", "pass", "from", "_ssl", "import", "op_all", "op_cipher_server_preference", "op_no_compression", "op_no_sslv2", "op_no_sslv3", "op_no_tlsv1", "op_no_tlsv1_1", "op_no_tlsv1_2", "op_single_dh_use", "op_single_ecdh_use", "from", "_ssl", "import", "alert_description_access_denied", "alert_description_bad_certificate", "alert_description_bad_certificate_hash_value", "alert_description_bad_certificate_status_response", "alert_description_bad_record_mac", "alert_description_certificate_expired", "alert_description_certificate_revoked", "alert_description_certificate_unknown", "alert_description_certificate_unobtainable", "alert_description_close_notify", "alert_description_decode_error", "alert_description_decompression_failure", "alert_description_decrypt_error", "alert_description_handshake_failure", "alert_description_illegal_parameter", "alert_description_insufficient_security", "alert_description_internal_error", "alert_description_no_renegotiation", "alert_description_protocol_version", "alert_description_record_overflow", "alert_description_unexpected_message", "alert_description_unknown_ca", "alert_description_unknown_psk_identity", "alert_description_unrecognized_name", "alert_description_unsupported_certificate", "alert_description_unsupported_extension", "alert_description_user_cancelled", "from", "_ssl", "import", "ssl_error_eof", "ssl_error_invalid_error_code", "ssl_error_ssl", "ssl_error_syscall", "ssl_error_want_connect", "ssl_error_want_read", "ssl_error_want_write", "ssl_error_want_x509_lookup", "ssl_error_zero_return", "from", "_ssl", "import", "verify_crl_check_chain", "verify_crl_check_leaf", "verify_default", "verify_x509_strict", "from", "_ssl", "import", "has_sni", "has_ecdh", "has_npn", "has_alpn", "from", "_ssl", "import", "_openssl_api_version", "from", "_ssl", "import", "protocol_sslv23", "protocol_tlsv1", "protocol_tlsv1_1", "protocol_tlsv1_2", "from", "_ssl", "import", "protocol_tls", "protocol_tls_client", "protocol_tls_server"], "doc_len": 149}
{"doc_id": "astroid/brain/brain_subprocess.py::_subprocess_transform", "file_path": "astroid/brain/brain_subprocess.py", "class_name": null, "func_name": "_subprocess_transform", "text": "文件路径: astroid/brain/brain_subprocess.py\ndef _subprocess_transform():\n    communicate = (bytes(\"string\", \"ascii\"), bytes(\"string\", \"ascii\"))\n    communicate_signature = \"def communicate(self, input=None, timeout=None)\"\n    args = \"\"\"\\\n        self, args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None,\n        preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None,\n        universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True,\n        start_new_session=False, pass_fds=(), *, encoding=None, errors=None\"\"\"\n    if PY37_PLUS:\n        args += \", text=None\"\n    init = f\"\"\"\n        def __init__({args}):\n            pass\"\"\"\n    wait_signature = \"def wait(self, timeout=None)\"\n    ctx_manager = \"\"\"\n        def __enter__(self): return self\n        def __exit__(self, *args): pass\n    \"\"\"\n    py3_args = \"args = []\"\n\n    if PY37_PLUS:\n        check_output_signature = \"\"\"\n        check_output(\n            args, *,\n            stdin=None,\n            stderr=None,\n            shell=False,\n            cwd=None,\n            encoding=None,\n            errors=None,\n            universal_newlines=False,\n            timeout=None,\n            env=None,\n            text=None,\n            restore_signals=True,\n            preexec_fn=None,\n            pass_fds=(),\n            input=None,\n            bufsize=0,\n            executable=None,\n            close_fds=False,\n            startupinfo=None,\n            creationflags=0,\n            start_new_session=False\n        ):\n        \"\"\".strip()\n    else:\n        check_output_signature = \"\"\"\n        check_output(\n            args, *,\n            stdin=None,\n            stderr=None,\n            shell=False,\n            cwd=None,\n            encoding=None,\n            errors=None,\n            universal_newlines=False,\n            timeout=None,\n            env=None,\n            restore_signals=True,\n            preexec_fn=None,\n            pass_fds=(),\n            input=None,\n            bufsize=0,\n            executable=None,\n            close_fds=False,\n            startupinfo=None,\n            creationflags=0,\n            start_new_session=False\n        ):\n        \"\"\".strip()\n\n    code = textwrap.dedent(\n        f\"\"\"\n    def {check_output_signature}\n        if universal_newlines:\n            return \"\"\n        return b\"\"\n\n    class Popen(object):\n        returncode = pid = 0\n        stdin = stdout = stderr = file()\n        {py3_args}\n\n        {communicate_signature}:\n            return {communicate!r}\n        {wait_signature}:\n            return self.returncode\n        def poll(self):\n            return self.returncode\n        def send_signal(self, signal):\n            pass\n        def terminate(self):\n            pass\n        def kill(self):\n            pass\n        {ctx_manager}\n       \"\"\"\n    )\n    if PY39_PLUS:\n        code += \"\"\"\n    @classmethod\n    def __class_getitem__(cls, item):\n        pass\n        \"\"\"\n\n    init_lines = textwrap.dedent(init).splitlines()\n    indented_init = \"\\n\".join(\" \" * 4 + line for line in init_lines)\n    code += indented_init\n    return parse(code)\n", "tokens": ["astroid", "brain", "brain_subprocess", "py", "def", "_subprocess_transform", "communicate", "bytes", "string", "ascii", "bytes", "string", "ascii", "communicate_signature", "def", "communicate", "self", "input", "none", "timeout", "none", "args", "self", "args", "bufsize", "0", "executable", "none", "stdin", "none", "stdout", "none", "stderr", "none", "preexec_fn", "none", "close_fds", "false", "shell", "false", "cwd", "none", "env", "none", "universal_newlines", "false", "startupinfo", "none", "creationflags", "0", "restore_signals", "true", "start_new_session", "false", "pass_fds", "encoding", "none", "errors", "none", "if", "py37_plus", "args", "text", "none", "init", "f", "def", "__init__", "args", "pass", "wait_signature", "def", "wait", "self", "timeout", "none", "ctx_manager", "def", "__enter__", "self", "return", "self", "def", "__exit__", "self", "args", "pass", "py3_args", "args", "if", "py37_plus", "check_output_signature", "check_output", "args", "stdin", "none", "stderr", "none", "shell", "false", "cwd", "none", "encoding", "none", "errors", "none", "universal_newlines", "false", "timeout", "none", "env", "none", "text", "none", "restore_signals", "true", "preexec_fn", "none", "pass_fds", "input", "none", "bufsize", "0", "executable", "none", "close_fds", "false", "startupinfo", "none", "creationflags", "0", "start_new_session", "false", "strip", "else", "check_output_signature", "check_output", "args", "stdin", "none", "stderr", "none", "shell", "false", "cwd", "none", "encoding", "none", "errors", "none", "universal_newlines", "false", "timeout", "none", "env", "none", "restore_signals", "true", "preexec_fn", "none", "pass_fds", "input", "none", "bufsize", "0", "executable", "none", "close_fds", "false", "startupinfo", "none", "creationflags", "0", "start_new_session", "false", "strip", "code", "textwrap", "dedent", "f", "def", "check_output_signature", "if", "universal_newlines", "return", "return", "b", "class", "popen", "object", "returncode", "pid", "0", "stdin", "stdout", "stderr", "file", "py3_args", "communicate_signature", "return", "communicate", "r", "wait_signature", "return", "self", "returncode", "def", "poll", "self", "return", "self", "returncode", "def", "send_signal", "self", "signal", "pass", "def", "terminate", "self", "pass", "def", "kill", "self", "pass", "ctx_manager", "if", "py39_plus", "code", "classmethod", "def", "__class_getitem__", "cls", "item", "pass", "init_lines", "textwrap", "dedent", "init", "splitlines", "indented_init", "n", "join", "4", "line", "for", "line", "in", "init_lines", "code", "indented_init", "return", "parse", "code"], "doc_len": 254}
{"doc_id": "astroid/brain/brain_threading.py::_thread_transform", "file_path": "astroid/brain/brain_threading.py", "class_name": null, "func_name": "_thread_transform", "text": "文件路径: astroid/brain/brain_threading.py\ndef _thread_transform():\n    return parse(\n        \"\"\"\n    class lock(object):\n        def acquire(self, blocking=True, timeout=-1):\n            return False\n        def release(self):\n            pass\n        def __enter__(self):\n            return True\n        def __exit__(self, *args):\n            pass\n        def locked(self):\n            return False\n\n    def Lock():\n        return lock()\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_threading", "py", "def", "_thread_transform", "return", "parse", "class", "lock", "object", "def", "acquire", "self", "blocking", "true", "timeout", "1", "return", "false", "def", "release", "self", "pass", "def", "__enter__", "self", "return", "true", "def", "__exit__", "self", "args", "pass", "def", "locked", "self", "return", "false", "def", "lock", "return", "lock"], "doc_len": 43}
{"doc_id": "astroid/brain/brain_type.py::_looks_like_type_subscript", "file_path": "astroid/brain/brain_type.py", "class_name": null, "func_name": "_looks_like_type_subscript", "text": "文件路径: astroid/brain/brain_type.py\ndef _looks_like_type_subscript(node):\n    \"\"\"\n    Try to figure out if a Name node is used inside a type related subscript\n\n    :param node: node to check\n    :type node: astroid.nodes.node_classes.NodeNG\n    :return: true if the node is a Name node inside a type related subscript\n    :rtype: bool\n    \"\"\"\n    if isinstance(node, nodes.Name) and isinstance(node.parent, nodes.Subscript):\n        return node.name == \"type\"\n    return False\n", "tokens": ["astroid", "brain", "brain_type", "py", "def", "_looks_like_type_subscript", "node", "try", "to", "figure", "out", "if", "a", "name", "node", "is", "used", "inside", "a", "type", "related", "subscript", "param", "node", "node", "to", "check", "type", "node", "astroid", "nodes", "node_classes", "nodeng", "return", "true", "if", "the", "node", "is", "a", "name", "node", "inside", "a", "type", "related", "subscript", "rtype", "bool", "if", "isinstance", "node", "nodes", "name", "and", "isinstance", "node", "parent", "nodes", "subscript", "return", "node", "name", "type", "return", "false"], "doc_len": 66}
{"doc_id": "astroid/brain/brain_type.py::infer_type_sub", "file_path": "astroid/brain/brain_type.py", "class_name": null, "func_name": "infer_type_sub", "text": "文件路径: astroid/brain/brain_type.py\ndef infer_type_sub(node, context=None):\n    \"\"\"\n    Infer a type[...] subscript\n\n    :param node: node to infer\n    :type node: astroid.nodes.node_classes.NodeNG\n    :param context: inference context\n    :type context: astroid.context.InferenceContext\n    :return: the inferred node\n    :rtype: nodes.NodeNG\n    \"\"\"\n    node_scope, _ = node.scope().lookup(\"type\")\n    if not isinstance(node_scope, nodes.Module) or node_scope.qname() != \"builtins\":\n        raise UseInferenceDefault()\n    class_src = \"\"\"\n    class type:\n        def __class_getitem__(cls, key):\n            return cls\n     \"\"\"\n    node = extract_node(class_src)\n    return node.infer(context=context)\n", "tokens": ["astroid", "brain", "brain_type", "py", "def", "infer_type_sub", "node", "context", "none", "infer", "a", "type", "subscript", "param", "node", "node", "to", "infer", "type", "node", "astroid", "nodes", "node_classes", "nodeng", "param", "context", "inference", "context", "type", "context", "astroid", "context", "inferencecontext", "return", "the", "inferred", "node", "rtype", "nodes", "nodeng", "node_scope", "_", "node", "scope", "lookup", "type", "if", "not", "isinstance", "node_scope", "nodes", "module", "or", "node_scope", "qname", "builtins", "raise", "useinferencedefault", "class_src", "class", "type", "def", "__class_getitem__", "cls", "key", "return", "cls", "node", "extract_node", "class_src", "return", "node", "infer", "context", "context"], "doc_len": 75}
{"doc_id": "astroid/brain/brain_typing.py::looks_like_typing_typevar_or_newtype", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "looks_like_typing_typevar_or_newtype", "text": "文件路径: astroid/brain/brain_typing.py\ndef looks_like_typing_typevar_or_newtype(node):\n    func = node.func\n    if isinstance(func, Attribute):\n        return func.attrname in TYPING_TYPEVARS\n    if isinstance(func, Name):\n        return func.name in TYPING_TYPEVARS\n    return False\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "looks_like_typing_typevar_or_newtype", "node", "func", "node", "func", "if", "isinstance", "func", "attribute", "return", "func", "attrname", "in", "typing_typevars", "if", "isinstance", "func", "name", "return", "func", "name", "in", "typing_typevars", "return", "false"], "doc_len": 30}
{"doc_id": "astroid/brain/brain_typing.py::infer_typing_typevar_or_newtype", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_typing_typevar_or_newtype", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_typing_typevar_or_newtype(node, context_itton=None):\n    \"\"\"Infer a typing.TypeVar(...) or typing.NewType(...) call\"\"\"\n    try:\n        func = next(node.func.infer(context=context_itton))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n\n    if func.qname() not in TYPING_TYPEVARS_QUALIFIED:\n        raise UseInferenceDefault\n    if not node.args:\n        raise UseInferenceDefault\n\n    typename = node.args[0].as_string().strip(\"'\")\n    node = extract_node(TYPING_TYPE_TEMPLATE.format(typename))\n    return node.infer(context=context_itton)\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_typing_typevar_or_newtype", "node", "context_itton", "none", "infer", "a", "typing", "typevar", "or", "typing", "newtype", "call", "try", "func", "next", "node", "func", "infer", "context", "context_itton", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "func", "qname", "not", "in", "typing_typevars_qualified", "raise", "useinferencedefault", "if", "not", "node", "args", "raise", "useinferencedefault", "typename", "node", "args", "0", "as_string", "strip", "node", "extract_node", "typing_type_template", "format", "typename", "return", "node", "infer", "context", "context_itton"], "doc_len": 64}
{"doc_id": "astroid/brain/brain_typing.py::_looks_like_typing_subscript", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_looks_like_typing_subscript", "text": "文件路径: astroid/brain/brain_typing.py\ndef _looks_like_typing_subscript(node):\n    \"\"\"Try to figure out if a Subscript node *might* be a typing-related subscript\"\"\"\n    if isinstance(node, Name):\n        return node.name in TYPING_MEMBERS\n    if isinstance(node, Attribute):\n        return node.attrname in TYPING_MEMBERS\n    if isinstance(node, Subscript):\n        return _looks_like_typing_subscript(node.value)\n    return False\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_looks_like_typing_subscript", "node", "try", "to", "figure", "out", "if", "a", "subscript", "node", "might", "be", "a", "typing", "related", "subscript", "if", "isinstance", "node", "name", "return", "node", "name", "in", "typing_members", "if", "isinstance", "node", "attribute", "return", "node", "attrname", "in", "typing_members", "if", "isinstance", "node", "subscript", "return", "_looks_like_typing_subscript", "node", "value", "return", "false"], "doc_len": 49}
{"doc_id": "astroid/brain/brain_typing.py::infer_typing_attr", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_typing_attr", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_typing_attr(\n    node: Subscript, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[ClassDef]:\n    \"\"\"Infer a typing.X[...] subscript\"\"\"\n    try:\n        value = next(node.value.infer())\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n\n    if (\n        not value.qname().startswith(\"typing.\")\n        or PY37_PLUS\n        and value.qname() in TYPING_ALIAS\n    ):\n        # If typing subscript belongs to an alias\n        # (PY37+) handle it separately.\n        raise UseInferenceDefault\n\n    if (\n        PY37_PLUS\n        and isinstance(value, ClassDef)\n        and value.qname()\n        in {\"typing.Generic\", \"typing.Annotated\", \"typing_extensions.Annotated\"}\n    ):\n        # With PY37+ typing.Generic and typing.Annotated (PY39) are subscriptable\n        # through __class_getitem__. Since astroid can't easily\n        # infer the native methods, replace them for an easy inference tip\n        func_to_add = extract_node(CLASS_GETITEM_TEMPLATE)\n        value.locals[\"__class_getitem__\"] = [func_to_add]\n        if (\n            isinstance(node.parent, ClassDef)\n            and node in node.parent.bases\n            and getattr(node.parent, \"__cache\", None)\n        ):\n            # node.parent.slots is evaluated and cached before the inference tip\n            # is first applied. Remove the last result to allow a recalculation of slots\n            cache = node.parent.__cache  # type: ignore[attr-defined] # Unrecognized getattr\n            if cache.get(node.parent.slots) is not None:\n                del cache[node.parent.slots]\n        return iter([value])\n\n    node = extract_node(TYPING_TYPE_TEMPLATE.format(value.qname().split(\".\")[-1]))\n    return node.infer(context=ctx)\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_typing_attr", "node", "subscript", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "classdef", "infer", "a", "typing", "x", "subscript", "try", "value", "next", "node", "value", "infer", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "not", "value", "qname", "startswith", "typing", "or", "py37_plus", "and", "value", "qname", "in", "typing_alias", "if", "typing", "subscript", "belongs", "to", "an", "alias", "py37", "handle", "it", "separately", "raise", "useinferencedefault", "if", "py37_plus", "and", "isinstance", "value", "classdef", "and", "value", "qname", "in", "typing", "generic", "typing", "annotated", "typing_extensions", "annotated", "with", "py37", "typing", "generic", "and", "typing", "annotated", "py39", "are", "subscriptable", "through", "__class_getitem__", "since", "astroid", "can", "t", "easily", "infer", "the", "native", "methods", "replace", "them", "for", "an", "easy", "inference", "tip", "func_to_add", "extract_node", "class_getitem_template", "value", "locals", "__class_getitem__", "func_to_add", "if", "isinstance", "node", "parent", "classdef", "and", "node", "in", "node", "parent", "bases", "and", "getattr", "node", "parent", "__cache", "none", "node", "parent", "slots", "is", "evaluated", "and", "cached", "before", "the", "inference", "tip", "is", "first", "applied", "remove", "the", "last", "result", "to", "allow", "a", "recalculation", "of", "slots", "cache", "node", "parent", "__cache", "type", "ignore", "attr", "defined", "unrecognized", "getattr", "if", "cache", "get", "node", "parent", "slots", "is", "not", "none", "del", "cache", "node", "parent", "slots", "return", "iter", "value", "node", "extract_node", "typing_type_template", "format", "value", "qname", "split", "1", "return", "node", "infer", "context", "ctx"], "doc_len": 195}
{"doc_id": "astroid/brain/brain_typing.py::_looks_like_typedDict", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_looks_like_typedDict", "text": "文件路径: astroid/brain/brain_typing.py\ndef _looks_like_typedDict(  # pylint: disable=invalid-name\n    node: typing.Union[FunctionDef, ClassDef],\n) -> bool:\n    \"\"\"Check if node is TypedDict FunctionDef.\"\"\"\n    return node.qname() in {\"typing.TypedDict\", \"typing_extensions.TypedDict\"}\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_looks_like_typeddict", "pylint", "disable", "invalid", "name", "node", "typing", "union", "functiondef", "classdef", "bool", "check", "if", "node", "is", "typeddict", "functiondef", "return", "node", "qname", "in", "typing", "typeddict", "typing_extensions", "typeddict"], "doc_len": 30}
{"doc_id": "astroid/brain/brain_typing.py::infer_old_typedDict", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_old_typedDict", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_old_typedDict(  # pylint: disable=invalid-name\n    node: ClassDef, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[ClassDef]:\n    func_to_add = extract_node(\"dict\")\n    node.locals[\"__call__\"] = [func_to_add]\n    return iter([node])\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_old_typeddict", "pylint", "disable", "invalid", "name", "node", "classdef", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "classdef", "func_to_add", "extract_node", "dict", "node", "locals", "__call__", "func_to_add", "return", "iter", "node"], "doc_len": 31}
{"doc_id": "astroid/brain/brain_typing.py::infer_typedDict", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_typedDict", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_typedDict(  # pylint: disable=invalid-name\n    node: FunctionDef, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[ClassDef]:\n    \"\"\"Replace TypedDict FunctionDef with ClassDef.\"\"\"\n    class_def = ClassDef(\n        name=\"TypedDict\",\n        lineno=node.lineno,\n        col_offset=node.col_offset,\n        parent=node.parent,\n    )\n    class_def.postinit(bases=[extract_node(\"dict\")], body=[], decorators=None)\n    func_to_add = extract_node(\"dict\")\n    class_def.locals[\"__call__\"] = [func_to_add]\n    return iter([class_def])\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_typeddict", "pylint", "disable", "invalid", "name", "node", "functiondef", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "classdef", "replace", "typeddict", "functiondef", "with", "classdef", "class_def", "classdef", "name", "typeddict", "lineno", "node", "lineno", "col_offset", "node", "col_offset", "parent", "node", "parent", "class_def", "postinit", "bases", "extract_node", "dict", "body", "decorators", "none", "func_to_add", "extract_node", "dict", "class_def", "locals", "__call__", "func_to_add", "return", "iter", "class_def"], "doc_len": 57}
{"doc_id": "astroid/brain/brain_typing.py::_looks_like_typing_alias", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_looks_like_typing_alias", "text": "文件路径: astroid/brain/brain_typing.py\ndef _looks_like_typing_alias(node: Call) -> bool:\n    \"\"\"\n    Returns True if the node corresponds to a call to _alias function.\n    For example :\n\n    MutableSet = _alias(collections.abc.MutableSet, T)\n\n    :param node: call node\n    \"\"\"\n    return (\n        isinstance(node.func, Name)\n        and node.func.name == \"_alias\"\n        and (\n            # _alias function works also for builtins object such as list and dict\n            isinstance(node.args[0], (Attribute, Name))\n        )\n    )\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_looks_like_typing_alias", "node", "call", "bool", "returns", "true", "if", "the", "node", "corresponds", "to", "a", "call", "to", "_alias", "function", "for", "example", "mutableset", "_alias", "collections", "abc", "mutableset", "t", "param", "node", "call", "node", "return", "isinstance", "node", "func", "name", "and", "node", "func", "name", "_alias", "and", "_alias", "function", "works", "also", "for", "builtins", "object", "such", "as", "list", "and", "dict", "isinstance", "node", "args", "0", "attribute", "name"], "doc_len": 62}
{"doc_id": "astroid/brain/brain_typing.py::_forbid_class_getitem_access", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_forbid_class_getitem_access", "text": "文件路径: astroid/brain/brain_typing.py\ndef _forbid_class_getitem_access(node: ClassDef) -> None:\n    \"\"\"\n    Disable the access to __class_getitem__ method for the node in parameters\n    \"\"\"\n\n    def full_raiser(origin_func, attr, *args, **kwargs):\n        \"\"\"\n        Raises an AttributeInferenceError in case of access to __class_getitem__ method.\n        Otherwise just call origin_func.\n        \"\"\"\n        if attr == \"__class_getitem__\":\n            raise AttributeInferenceError(\"__class_getitem__ access is not allowed\")\n        return origin_func(attr, *args, **kwargs)\n\n    try:\n        node.getattr(\"__class_getitem__\")\n        # If we are here, then we are sure to modify object that do have __class_getitem__ method (which origin is one the\n        # protocol defined in collections module) whereas the typing module consider it should not\n        # We do not want __class_getitem__ to be found in the classdef\n        partial_raiser = partial(full_raiser, node.getattr)\n        node.getattr = partial_raiser\n    except AttributeInferenceError:\n        pass\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_forbid_class_getitem_access", "node", "classdef", "none", "disable", "the", "access", "to", "__class_getitem__", "method", "for", "the", "node", "in", "parameters", "def", "full_raiser", "origin_func", "attr", "args", "kwargs", "raises", "an", "attributeinferenceerror", "in", "case", "of", "access", "to", "__class_getitem__", "method", "otherwise", "just", "call", "origin_func", "if", "attr", "__class_getitem__", "raise", "attributeinferenceerror", "__class_getitem__", "access", "is", "not", "allowed", "return", "origin_func", "attr", "args", "kwargs", "try", "node", "getattr", "__class_getitem__", "if", "we", "are", "here", "then", "we", "are", "sure", "to", "modify", "object", "that", "do", "have", "__class_getitem__", "method", "which", "origin", "is", "one", "the", "protocol", "defined", "in", "collections", "module", "whereas", "the", "typing", "module", "consider", "it", "should", "not", "we", "do", "not", "want", "__class_getitem__", "to", "be", "found", "in", "the", "classdef", "partial_raiser", "partial", "full_raiser", "node", "getattr", "node", "getattr", "partial_raiser", "except", "attributeinferenceerror", "pass"], "doc_len": 115}
{"doc_id": "astroid/brain/brain_typing.py::infer_typing_alias", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_typing_alias", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_typing_alias(\n    node: Call, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[ClassDef]:\n    \"\"\"\n    Infers the call to _alias function\n    Insert ClassDef, with same name as aliased class,\n    in mro to simulate _GenericAlias.\n\n    :param node: call node\n    :param context: inference context\n    \"\"\"\n    if (\n        not isinstance(node.parent, Assign)\n        or not len(node.parent.targets) == 1\n        or not isinstance(node.parent.targets[0], AssignName)\n    ):\n        raise UseInferenceDefault\n    try:\n        res = next(node.args[0].infer(context=ctx))\n    except StopIteration as e:\n        raise InferenceError(node=node.args[0], context=context) from e\n\n    assign_name = node.parent.targets[0]\n\n    class_def = ClassDef(\n        name=assign_name.name,\n        lineno=assign_name.lineno,\n        col_offset=assign_name.col_offset,\n        parent=node.parent,\n    )\n    if res != Uninferable and isinstance(res, ClassDef):\n        # Only add `res` as base if it's a `ClassDef`\n        # This isn't the case for `typing.Pattern` and `typing.Match`\n        class_def.postinit(bases=[res], body=[], decorators=None)\n\n    maybe_type_var = node.args[1]\n    if (\n        not PY39_PLUS\n        and not (isinstance(maybe_type_var, Tuple) and not maybe_type_var.elts)\n        or PY39_PLUS\n        and isinstance(maybe_type_var, Const)\n        and maybe_type_var.value > 0\n    ):\n        # If typing alias is subscriptable, add `__class_getitem__` to ClassDef\n        func_to_add = extract_node(CLASS_GETITEM_TEMPLATE)\n        class_def.locals[\"__class_getitem__\"] = [func_to_add]\n    else:\n        # If not, make sure that `__class_getitem__` access is forbidden.\n        # This is an issue in cases where the aliased class implements it,\n        # but the typing alias isn't subscriptable. E.g., `typing.ByteString` for PY39+\n        _forbid_class_getitem_access(class_def)\n    return iter([class_def])\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_typing_alias", "node", "call", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "classdef", "infers", "the", "call", "to", "_alias", "function", "insert", "classdef", "with", "same", "name", "as", "aliased", "class", "in", "mro", "to", "simulate", "_genericalias", "param", "node", "call", "node", "param", "context", "inference", "context", "if", "not", "isinstance", "node", "parent", "assign", "or", "not", "len", "node", "parent", "targets", "1", "or", "not", "isinstance", "node", "parent", "targets", "0", "assignname", "raise", "useinferencedefault", "try", "res", "next", "node", "args", "0", "infer", "context", "ctx", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "args", "0", "context", "context", "from", "e", "assign_name", "node", "parent", "targets", "0", "class_def", "classdef", "name", "assign_name", "name", "lineno", "assign_name", "lineno", "col_offset", "assign_name", "col_offset", "parent", "node", "parent", "if", "res", "uninferable", "and", "isinstance", "res", "classdef", "only", "add", "res", "as", "base", "if", "it", "s", "a", "classdef", "this", "isn", "t", "the", "case", "for", "typing", "pattern", "and", "typing", "match", "class_def", "postinit", "bases", "res", "body", "decorators", "none", "maybe_type_var", "node", "args", "1", "if", "not", "py39_plus", "and", "not", "isinstance", "maybe_type_var", "tuple", "and", "not", "maybe_type_var", "elts", "or", "py39_plus", "and", "isinstance", "maybe_type_var", "const", "and", "maybe_type_var", "value", "0", "if", "typing", "alias", "is", "subscriptable", "add", "__class_getitem__", "to", "classdef", "func_to_add", "extract_node", "class_getitem_template", "class_def", "locals", "__class_getitem__", "func_to_add", "else", "if", "not", "make", "sure", "that", "__class_getitem__", "access", "is", "forbidden", "this", "is", "an", "issue", "in", "cases", "where", "the", "aliased", "class", "implements", "it", "but", "the", "typing", "alias", "isn", "t", "subscriptable", "e", "g", "typing", "bytestring", "for", "py39", "_forbid_class_getitem_access", "class_def", "return", "iter", "class_def"], "doc_len": 226}
{"doc_id": "astroid/brain/brain_typing.py::_looks_like_special_alias", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_looks_like_special_alias", "text": "文件路径: astroid/brain/brain_typing.py\ndef _looks_like_special_alias(node: Call) -> bool:\n    \"\"\"Return True if call is for Tuple or Callable alias.\n\n    In PY37 and PY38 the call is to '_VariadicGenericAlias' with 'tuple' as\n    first argument. In PY39+ it is replaced by a call to '_TupleType'.\n\n    PY37: Tuple = _VariadicGenericAlias(tuple, (), inst=False, special=True)\n    PY39: Tuple = _TupleType(tuple, -1, inst=False, name='Tuple')\n\n\n    PY37: Callable = _VariadicGenericAlias(collections.abc.Callable, (), special=True)\n    PY39: Callable = _CallableType(collections.abc.Callable, 2)\n    \"\"\"\n    return isinstance(node.func, Name) and (\n        not PY39_PLUS\n        and node.func.name == \"_VariadicGenericAlias\"\n        and (\n            isinstance(node.args[0], Name)\n            and node.args[0].name == \"tuple\"\n            or isinstance(node.args[0], Attribute)\n            and node.args[0].as_string() == \"collections.abc.Callable\"\n        )\n        or PY39_PLUS\n        and (\n            node.func.name == \"_TupleType\"\n            and isinstance(node.args[0], Name)\n            and node.args[0].name == \"tuple\"\n            or node.func.name == \"_CallableType\"\n            and isinstance(node.args[0], Attribute)\n            and node.args[0].as_string() == \"collections.abc.Callable\"\n        )\n    )\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_looks_like_special_alias", "node", "call", "bool", "return", "true", "if", "call", "is", "for", "tuple", "or", "callable", "alias", "in", "py37", "and", "py38", "the", "call", "is", "to", "_variadicgenericalias", "with", "tuple", "as", "first", "argument", "in", "py39", "it", "is", "replaced", "by", "a", "call", "to", "_tupletype", "py37", "tuple", "_variadicgenericalias", "tuple", "inst", "false", "special", "true", "py39", "tuple", "_tupletype", "tuple", "1", "inst", "false", "name", "tuple", "py37", "callable", "_variadicgenericalias", "collections", "abc", "callable", "special", "true", "py39", "callable", "_callabletype", "collections", "abc", "callable", "2", "return", "isinstance", "node", "func", "name", "and", "not", "py39_plus", "and", "node", "func", "name", "_variadicgenericalias", "and", "isinstance", "node", "args", "0", "name", "and", "node", "args", "0", "name", "tuple", "or", "isinstance", "node", "args", "0", "attribute", "and", "node", "args", "0", "as_string", "collections", "abc", "callable", "or", "py39_plus", "and", "node", "func", "name", "_tupletype", "and", "isinstance", "node", "args", "0", "name", "and", "node", "args", "0", "name", "tuple", "or", "node", "func", "name", "_callabletype", "and", "isinstance", "node", "args", "0", "attribute", "and", "node", "args", "0", "as_string", "collections", "abc", "callable"], "doc_len": 152}
{"doc_id": "astroid/brain/brain_typing.py::infer_special_alias", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_special_alias", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_special_alias(\n    node: Call, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[ClassDef]:\n    \"\"\"Infer call to tuple alias as new subscriptable class typing.Tuple.\"\"\"\n    if not (\n        isinstance(node.parent, Assign)\n        and len(node.parent.targets) == 1\n        and isinstance(node.parent.targets[0], AssignName)\n    ):\n        raise UseInferenceDefault\n    try:\n        res = next(node.args[0].infer(context=ctx))\n    except StopIteration as e:\n        raise InferenceError(node=node.args[0], context=context) from e\n\n    assign_name = node.parent.targets[0]\n    class_def = ClassDef(\n        name=assign_name.name,\n        parent=node.parent,\n    )\n    class_def.postinit(bases=[res], body=[], decorators=None)\n    func_to_add = extract_node(CLASS_GETITEM_TEMPLATE)\n    class_def.locals[\"__class_getitem__\"] = [func_to_add]\n    return iter([class_def])\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_special_alias", "node", "call", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "classdef", "infer", "call", "to", "tuple", "alias", "as", "new", "subscriptable", "class", "typing", "tuple", "if", "not", "isinstance", "node", "parent", "assign", "and", "len", "node", "parent", "targets", "1", "and", "isinstance", "node", "parent", "targets", "0", "assignname", "raise", "useinferencedefault", "try", "res", "next", "node", "args", "0", "infer", "context", "ctx", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "node", "args", "0", "context", "context", "from", "e", "assign_name", "node", "parent", "targets", "0", "class_def", "classdef", "name", "assign_name", "name", "parent", "node", "parent", "class_def", "postinit", "bases", "res", "body", "decorators", "none", "func_to_add", "extract_node", "class_getitem_template", "class_def", "locals", "__class_getitem__", "func_to_add", "return", "iter", "class_def"], "doc_len": 102}
{"doc_id": "astroid/brain/brain_typing.py::_looks_like_typing_cast", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "_looks_like_typing_cast", "text": "文件路径: astroid/brain/brain_typing.py\ndef _looks_like_typing_cast(node: Call) -> bool:\n    return isinstance(node, Call) and (\n        isinstance(node.func, Name)\n        and node.func.name == \"cast\"\n        or isinstance(node.func, Attribute)\n        and node.func.attrname == \"cast\"\n    )\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "_looks_like_typing_cast", "node", "call", "bool", "return", "isinstance", "node", "call", "and", "isinstance", "node", "func", "name", "and", "node", "func", "name", "cast", "or", "isinstance", "node", "func", "attribute", "and", "node", "func", "attrname", "cast"], "doc_len": 33}
{"doc_id": "astroid/brain/brain_typing.py::infer_typing_cast", "file_path": "astroid/brain/brain_typing.py", "class_name": null, "func_name": "infer_typing_cast", "text": "文件路径: astroid/brain/brain_typing.py\ndef infer_typing_cast(\n    node: Call, ctx: typing.Optional[context.InferenceContext] = None\n) -> typing.Iterator[NodeNG]:\n    \"\"\"Infer call to cast() returning same type as casted-from var\"\"\"\n    if not isinstance(node.func, (Name, Attribute)):\n        raise UseInferenceDefault\n\n    try:\n        func = next(node.func.infer(context=ctx))\n    except (InferenceError, StopIteration) as exc:\n        raise UseInferenceDefault from exc\n    if (\n        not isinstance(func, FunctionDef)\n        or func.qname() != \"typing.cast\"\n        or len(node.args) != 2\n    ):\n        raise UseInferenceDefault\n\n    return node.args[1].infer(context=ctx)\n", "tokens": ["astroid", "brain", "brain_typing", "py", "def", "infer_typing_cast", "node", "call", "ctx", "typing", "optional", "context", "inferencecontext", "none", "typing", "iterator", "nodeng", "infer", "call", "to", "cast", "returning", "same", "type", "as", "casted", "from", "var", "if", "not", "isinstance", "node", "func", "name", "attribute", "raise", "useinferencedefault", "try", "func", "next", "node", "func", "infer", "context", "ctx", "except", "inferenceerror", "stopiteration", "as", "exc", "raise", "useinferencedefault", "from", "exc", "if", "not", "isinstance", "func", "functiondef", "or", "func", "qname", "typing", "cast", "or", "len", "node", "args", "2", "raise", "useinferencedefault", "return", "node", "args", "1", "infer", "context", "ctx"], "doc_len": 78}
{"doc_id": "astroid/brain/brain_unittest.py::IsolatedAsyncioTestCaseImport", "file_path": "astroid/brain/brain_unittest.py", "class_name": null, "func_name": "IsolatedAsyncioTestCaseImport", "text": "文件路径: astroid/brain/brain_unittest.py\ndef IsolatedAsyncioTestCaseImport():\n    \"\"\"\n    In the unittest package, the IsolatedAsyncioTestCase class is imported lazily, i.e only\n    when the __getattr__ method of the unittest module is called with 'IsolatedAsyncioTestCase' as\n    argument. Thus the IsolatedAsyncioTestCase is not imported statically (during import time).\n    This function mocks a classical static import of the IsolatedAsyncioTestCase.\n\n    (see https://github.com/PyCQA/pylint/issues/4060)\n    \"\"\"\n    return parse(\n        \"\"\"\n    from .async_case import IsolatedAsyncioTestCase\n    \"\"\"\n    )\n", "tokens": ["astroid", "brain", "brain_unittest", "py", "def", "isolatedasynciotestcaseimport", "in", "the", "unittest", "package", "the", "isolatedasynciotestcase", "class", "is", "imported", "lazily", "i", "e", "only", "when", "the", "__getattr__", "method", "of", "the", "unittest", "module", "is", "called", "with", "isolatedasynciotestcase", "as", "argument", "thus", "the", "isolatedasynciotestcase", "is", "not", "imported", "statically", "during", "import", "time", "this", "function", "mocks", "a", "classical", "static", "import", "of", "the", "isolatedasynciotestcase", "see", "https", "github", "com", "pycqa", "pylint", "issues", "4060", "return", "parse", "from", "async_case", "import", "isolatedasynciotestcase"], "doc_len": 67}
{"doc_id": "astroid/brain/brain_uuid.py::_patch_uuid_class", "file_path": "astroid/brain/brain_uuid.py", "class_name": null, "func_name": "_patch_uuid_class", "text": "文件路径: astroid/brain/brain_uuid.py\ndef _patch_uuid_class(node):\n    # The .int member is patched using __dict__\n    node.locals[\"int\"] = [Const(0, parent=node)]\n", "tokens": ["astroid", "brain", "brain_uuid", "py", "def", "_patch_uuid_class", "node", "the", "int", "member", "is", "patched", "using", "__dict__", "node", "locals", "int", "const", "0", "parent", "node"], "doc_len": 21}
{"doc_id": "astroid/brain/helpers.py::register_module_extender", "file_path": "astroid/brain/helpers.py", "class_name": null, "func_name": "register_module_extender", "text": "文件路径: astroid/brain/helpers.py\ndef register_module_extender(manager, module_name, get_extension_mod):\n    def transform(node):\n        extension_module = get_extension_mod()\n        for name, objs in extension_module.locals.items():\n            node.locals[name] = objs\n            for obj in objs:\n                if obj.parent is extension_module:\n                    obj.parent = node\n\n    manager.register_transform(Module, transform, lambda n: n.name == module_name)\n", "tokens": ["astroid", "brain", "helpers", "py", "def", "register_module_extender", "manager", "module_name", "get_extension_mod", "def", "transform", "node", "extension_module", "get_extension_mod", "for", "name", "objs", "in", "extension_module", "locals", "items", "node", "locals", "name", "objs", "for", "obj", "in", "objs", "if", "obj", "parent", "is", "extension_module", "obj", "parent", "node", "manager", "register_transform", "module", "transform", "lambda", "n", "n", "name", "module_name"], "doc_len": 46}
{"doc_id": "astroid/interpreter/dunder_lookup.py::_lookup_in_mro", "file_path": "astroid/interpreter/dunder_lookup.py", "class_name": null, "func_name": "_lookup_in_mro", "text": "文件路径: astroid/interpreter/dunder_lookup.py\ndef _lookup_in_mro(node, name):\n    attrs = node.locals.get(name, [])\n\n    nodes = itertools.chain.from_iterable(\n        ancestor.locals.get(name, []) for ancestor in node.ancestors(recurs=True)\n    )\n    values = list(itertools.chain(attrs, nodes))\n    if not values:\n        raise AttributeInferenceError(attribute=name, target=node)\n\n    return values\n", "tokens": ["astroid", "interpreter", "dunder_lookup", "py", "def", "_lookup_in_mro", "node", "name", "attrs", "node", "locals", "get", "name", "nodes", "itertools", "chain", "from_iterable", "ancestor", "locals", "get", "name", "for", "ancestor", "in", "node", "ancestors", "recurs", "true", "values", "list", "itertools", "chain", "attrs", "nodes", "if", "not", "values", "raise", "attributeinferenceerror", "attribute", "name", "target", "node", "return", "values"], "doc_len": 45}
{"doc_id": "astroid/interpreter/dunder_lookup.py::lookup", "file_path": "astroid/interpreter/dunder_lookup.py", "class_name": null, "func_name": "lookup", "text": "文件路径: astroid/interpreter/dunder_lookup.py\ndef lookup(node, name):\n    \"\"\"Lookup the given special method name in the given *node*\n\n    If the special method was found, then a list of attributes\n    will be returned. Otherwise, `astroid.AttributeInferenceError`\n    is going to be raised.\n    \"\"\"\n    if isinstance(\n        node, (astroid.List, astroid.Tuple, astroid.Const, astroid.Dict, astroid.Set)\n    ):\n        return _builtin_lookup(node, name)\n    if isinstance(node, astroid.Instance):\n        return _lookup_in_mro(node, name)\n    if isinstance(node, astroid.ClassDef):\n        return _class_lookup(node, name)\n\n    raise AttributeInferenceError(attribute=name, target=node)\n", "tokens": ["astroid", "interpreter", "dunder_lookup", "py", "def", "lookup", "node", "name", "lookup", "the", "given", "special", "method", "name", "in", "the", "given", "node", "if", "the", "special", "method", "was", "found", "then", "a", "list", "of", "attributes", "will", "be", "returned", "otherwise", "astroid", "attributeinferenceerror", "is", "going", "to", "be", "raised", "if", "isinstance", "node", "astroid", "list", "astroid", "tuple", "astroid", "const", "astroid", "dict", "astroid", "set", "return", "_builtin_lookup", "node", "name", "if", "isinstance", "node", "astroid", "instance", "return", "_lookup_in_mro", "node", "name", "if", "isinstance", "node", "astroid", "classdef", "return", "_class_lookup", "node", "name", "raise", "attributeinferenceerror", "attribute", "name", "target", "node"], "doc_len": 81}
{"doc_id": "astroid/interpreter/dunder_lookup.py::_class_lookup", "file_path": "astroid/interpreter/dunder_lookup.py", "class_name": null, "func_name": "_class_lookup", "text": "文件路径: astroid/interpreter/dunder_lookup.py\ndef _class_lookup(node, name):\n    metaclass = node.metaclass()\n    if metaclass is None:\n        raise AttributeInferenceError(attribute=name, target=node)\n\n    return _lookup_in_mro(metaclass, name)\n", "tokens": ["astroid", "interpreter", "dunder_lookup", "py", "def", "_class_lookup", "node", "name", "metaclass", "node", "metaclass", "if", "metaclass", "is", "none", "raise", "attributeinferenceerror", "attribute", "name", "target", "node", "return", "_lookup_in_mro", "metaclass", "name"], "doc_len": 25}
{"doc_id": "astroid/interpreter/dunder_lookup.py::_builtin_lookup", "file_path": "astroid/interpreter/dunder_lookup.py", "class_name": null, "func_name": "_builtin_lookup", "text": "文件路径: astroid/interpreter/dunder_lookup.py\ndef _builtin_lookup(node, name):\n    values = node.locals.get(name, [])\n    if not values:\n        raise AttributeInferenceError(attribute=name, target=node)\n\n    return values\n", "tokens": ["astroid", "interpreter", "dunder_lookup", "py", "def", "_builtin_lookup", "node", "name", "values", "node", "locals", "get", "name", "if", "not", "values", "raise", "attributeinferenceerror", "attribute", "name", "target", "node", "return", "values"], "doc_len": 24}
{"doc_id": "astroid/interpreter/objectmodel.py::_dunder_dict", "file_path": "astroid/interpreter/objectmodel.py", "class_name": null, "func_name": "_dunder_dict", "text": "文件路径: astroid/interpreter/objectmodel.py\ndef _dunder_dict(instance, attributes):\n    obj = node_classes.Dict(parent=instance)\n\n    # Convert the keys to node strings\n    keys = [\n        node_classes.Const(value=value, parent=obj) for value in list(attributes.keys())\n    ]\n\n    # The original attribute has a list of elements for each key,\n    # but that is not useful for retrieving the special attribute's value.\n    # In this case, we're picking the last value from each list.\n    values = [elem[-1] for elem in attributes.values()]\n\n    obj.postinit(list(zip(keys, values)))\n    return obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "def", "_dunder_dict", "instance", "attributes", "obj", "node_classes", "dict", "parent", "instance", "convert", "the", "keys", "to", "node", "strings", "keys", "node_classes", "const", "value", "value", "parent", "obj", "for", "value", "in", "list", "attributes", "keys", "the", "original", "attribute", "has", "a", "list", "of", "elements", "for", "each", "key", "but", "that", "is", "not", "useful", "for", "retrieving", "the", "special", "attribute", "s", "value", "in", "this", "case", "we", "re", "picking", "the", "last", "value", "from", "each", "list", "values", "elem", "1", "for", "elem", "in", "attributes", "values", "obj", "postinit", "list", "zip", "keys", "values", "return", "obj"], "doc_len": 83}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.__init__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "__init__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def __init__(self):\n        self._instance = None\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "__init__", "self", "self", "_instance", "none"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.__repr__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "__repr__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def __repr__(self):\n        result = []\n        cname = type(self).__name__\n        string = \"%(cname)s(%(fields)s)\"\n        alignment = len(cname) + 1\n        for field in sorted(self.attributes()):\n            width = 80 - len(field) - alignment\n            lines = pprint.pformat(field, indent=2, width=width).splitlines(True)\n\n            inner = [lines[0]]\n            for line in lines[1:]:\n                inner.append(\" \" * alignment + line)\n            result.append(field)\n\n        return string % {\n            \"cname\": cname,\n            \"fields\": (\",\\n\" + \" \" * alignment).join(result),\n        }\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "__repr__", "self", "result", "cname", "type", "self", "__name__", "string", "cname", "s", "fields", "s", "alignment", "len", "cname", "1", "for", "field", "in", "sorted", "self", "attributes", "width", "80", "len", "field", "alignment", "lines", "pprint", "pformat", "field", "indent", "2", "width", "width", "splitlines", "true", "inner", "lines", "0", "for", "line", "in", "lines", "1", "inner", "append", "alignment", "line", "result", "append", "field", "return", "string", "cname", "cname", "fields", "n", "alignment", "join", "result"], "doc_len": 67}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.__call__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "__call__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def __call__(self, instance):\n        self._instance = instance\n        return self\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "__call__", "self", "instance", "self", "_instance", "instance", "return", "self"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.__get__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "__get__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def __get__(self, instance, cls=None):\n        # ObjectModel needs to be a descriptor so that just doing\n        # `special_attributes = SomeObjectModel` should be enough in the body of a node.\n        # But at the same time, node.special_attributes should return an object\n        # which can be used for manipulating the special attributes. That's the reason\n        # we pass the instance through which it got accessed to ObjectModel.__call__,\n        # returning itself afterwards, so we can still have access to the\n        # underlying data model and to the instance for which it got accessed.\n        return self(instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "__get__", "self", "instance", "cls", "none", "objectmodel", "needs", "to", "be", "a", "descriptor", "so", "that", "just", "doing", "special_attributes", "someobjectmodel", "should", "be", "enough", "in", "the", "body", "of", "a", "node", "but", "at", "the", "same", "time", "node", "special_attributes", "should", "return", "an", "object", "which", "can", "be", "used", "for", "manipulating", "the", "special", "attributes", "that", "s", "the", "reason", "we", "pass", "the", "instance", "through", "which", "it", "got", "accessed", "to", "objectmodel", "__call__", "returning", "itself", "afterwards", "so", "we", "can", "still", "have", "access", "to", "the", "underlying", "data", "model", "and", "to", "the", "instance", "for", "which", "it", "got", "accessed", "return", "self", "instance"], "doc_len": 94}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.__contains__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "__contains__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def __contains__(self, name):\n        return name in self.attributes()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "__contains__", "self", "name", "return", "name", "in", "self", "attributes"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.attributes", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "attributes", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def attributes(self):\n        \"\"\"Get the attributes which are exported by this object model.\"\"\"\n        return [\n            obj[len(IMPL_PREFIX) :] for obj in dir(self) if obj.startswith(IMPL_PREFIX)\n        ]\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "attributes", "self", "get", "the", "attributes", "which", "are", "exported", "by", "this", "object", "model", "return", "obj", "len", "impl_prefix", "for", "obj", "in", "dir", "self", "if", "obj", "startswith", "impl_prefix"], "doc_len": 31}
{"doc_id": "astroid/interpreter/objectmodel.py::ObjectModel.lookup", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ObjectModel", "func_name": "lookup", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ObjectModel\n    def lookup(self, name):\n        \"\"\"Look up the given *name* in the current model\n\n        It should return an AST or an interpreter object,\n        but if the name is not found, then an AttributeInferenceError will be raised.\n        \"\"\"\n\n        if name in self.attributes():\n            return getattr(self, IMPL_PREFIX + name)\n        raise AttributeInferenceError(target=self._instance, attribute=name)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "objectmodel", "def", "lookup", "self", "name", "look", "up", "the", "given", "name", "in", "the", "current", "model", "it", "should", "return", "an", "ast", "or", "an", "interpreter", "object", "but", "if", "the", "name", "is", "not", "found", "then", "an", "attributeinferenceerror", "will", "be", "raised", "if", "name", "in", "self", "attributes", "return", "getattr", "self", "impl_prefix", "name", "raise", "attributeinferenceerror", "target", "self", "_instance", "attribute", "name"], "doc_len": 57}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel._builtins", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "_builtins", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def _builtins(self):\n        builtins_ast_module = AstroidManager().builtins_module\n        return builtins_ast_module.special_attributes.lookup(\"__dict__\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "_builtins", "self", "builtins_ast_module", "astroidmanager", "builtins_module", "return", "builtins_ast_module", "special_attributes", "lookup", "__dict__"], "doc_len": 16}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr_builtins", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr_builtins", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr_builtins(self):\n        return self._builtins()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr_builtins", "self", "return", "self", "_builtins"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___path__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___path__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___path__(self):\n        if not self._instance.package:\n            raise AttributeInferenceError(target=self._instance, attribute=\"__path__\")\n\n        path_objs = [\n            node_classes.Const(\n                value=path\n                if not path.endswith(\"__init__.py\")\n                else os.path.dirname(path),\n                parent=self._instance,\n            )\n            for path in self._instance.path\n        ]\n\n        container = node_classes.List(parent=self._instance)\n        container.postinit(path_objs)\n\n        return container\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___path__", "self", "if", "not", "self", "_instance", "package", "raise", "attributeinferenceerror", "target", "self", "_instance", "attribute", "__path__", "path_objs", "node_classes", "const", "value", "path", "if", "not", "path", "endswith", "__init__", "py", "else", "os", "path", "dirname", "path", "parent", "self", "_instance", "for", "path", "in", "self", "_instance", "path", "container", "node_classes", "list", "parent", "self", "_instance", "container", "postinit", "path_objs", "return", "container"], "doc_len": 56}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___name__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___name__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___name__(self):\n        return node_classes.Const(value=self._instance.name, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___name__", "self", "return", "node_classes", "const", "value", "self", "_instance", "name", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___doc__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___doc__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___doc__(self):\n        return node_classes.Const(value=self._instance.doc, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___doc__", "self", "return", "node_classes", "const", "value", "self", "_instance", "doc", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___file__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___file__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___file__(self):\n        return node_classes.Const(value=self._instance.file, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___file__", "self", "return", "node_classes", "const", "value", "self", "_instance", "file", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___dict__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___dict__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___dict__(self):\n        return _dunder_dict(self._instance, self._instance.globals)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___dict__", "self", "return", "_dunder_dict", "self", "_instance", "self", "_instance", "globals"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___package__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___package__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___package__(self):\n        if not self._instance.package:\n            value = \"\"\n        else:\n            value = self._instance.name\n\n        return node_classes.Const(value=value, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___package__", "self", "if", "not", "self", "_instance", "package", "value", "else", "value", "self", "_instance", "name", "return", "node_classes", "const", "value", "value", "parent", "self", "_instance"], "doc_len": 27}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___spec__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___spec__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___spec__(self):\n        # No handling for now.\n        return node_classes.Unknown()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___spec__", "self", "no", "handling", "for", "now", "return", "node_classes", "unknown"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___loader__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___loader__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___loader__(self):\n        # No handling for now.\n        return node_classes.Unknown()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___loader__", "self", "no", "handling", "for", "now", "return", "node_classes", "unknown"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::ModuleModel.attr___cached__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ModuleModel", "func_name": "attr___cached__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ModuleModel\n    def attr___cached__(self):\n        # No handling for now.\n        return node_classes.Unknown()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "modulemodel", "def", "attr___cached__", "self", "no", "handling", "for", "now", "return", "node_classes", "unknown"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___name__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___name__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___name__(self):\n        return node_classes.Const(value=self._instance.name, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___name__", "self", "return", "node_classes", "const", "value", "self", "_instance", "name", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___doc__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___doc__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___doc__(self):\n        return node_classes.Const(value=self._instance.doc, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___doc__", "self", "return", "node_classes", "const", "value", "self", "_instance", "doc", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___qualname__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___qualname__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___qualname__(self):\n        return node_classes.Const(value=self._instance.qname(), parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___qualname__", "self", "return", "node_classes", "const", "value", "self", "_instance", "qname", "parent", "self", "_instance"], "doc_len": 18}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___defaults__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___defaults__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___defaults__(self):\n        func = self._instance\n        if not func.args.defaults:\n            return node_classes.Const(value=None, parent=func)\n\n        defaults_obj = node_classes.Tuple(parent=func)\n        defaults_obj.postinit(func.args.defaults)\n        return defaults_obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___defaults__", "self", "func", "self", "_instance", "if", "not", "func", "args", "defaults", "return", "node_classes", "const", "value", "none", "parent", "func", "defaults_obj", "node_classes", "tuple", "parent", "func", "defaults_obj", "postinit", "func", "args", "defaults", "return", "defaults_obj"], "doc_len": 35}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___annotations__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___annotations__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___annotations__(self):\n        obj = node_classes.Dict(parent=self._instance)\n\n        if not self._instance.returns:\n            returns = None\n        else:\n            returns = self._instance.returns\n\n        args = self._instance.args\n        pair_annotations = itertools.chain(\n            zip(args.args or [], args.annotations),\n            zip(args.kwonlyargs, args.kwonlyargs_annotations),\n            zip(args.posonlyargs or [], args.posonlyargs_annotations),\n        )\n\n        annotations = {\n            arg.name: annotation for (arg, annotation) in pair_annotations if annotation\n        }\n        if args.varargannotation:\n            annotations[args.vararg] = args.varargannotation\n        if args.kwargannotation:\n            annotations[args.kwarg] = args.kwargannotation\n        if returns:\n            annotations[\"return\"] = returns\n\n        items = [\n            (node_classes.Const(key, parent=obj), value)\n            for (key, value) in annotations.items()\n        ]\n\n        obj.postinit(items)\n        return obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___annotations__", "self", "obj", "node_classes", "dict", "parent", "self", "_instance", "if", "not", "self", "_instance", "returns", "returns", "none", "else", "returns", "self", "_instance", "returns", "args", "self", "_instance", "args", "pair_annotations", "itertools", "chain", "zip", "args", "args", "or", "args", "annotations", "zip", "args", "kwonlyargs", "args", "kwonlyargs_annotations", "zip", "args", "posonlyargs", "or", "args", "posonlyargs_annotations", "annotations", "arg", "name", "annotation", "for", "arg", "annotation", "in", "pair_annotations", "if", "annotation", "if", "args", "varargannotation", "annotations", "args", "vararg", "args", "varargannotation", "if", "args", "kwargannotation", "annotations", "args", "kwarg", "args", "kwargannotation", "if", "returns", "annotations", "return", "returns", "items", "node_classes", "const", "key", "parent", "obj", "value", "for", "key", "value", "in", "annotations", "items", "obj", "postinit", "items", "return", "obj"], "doc_len": 100}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___dict__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___dict__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___dict__(self):\n        return node_classes.Dict(parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___dict__", "self", "return", "node_classes", "dict", "parent", "self", "_instance"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___kwdefaults__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___kwdefaults__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___kwdefaults__(self):\n        def _default_args(args, parent):\n            for arg in args.kwonlyargs:\n                try:\n                    default = args.default_value(arg.name)\n                except NoDefault:\n                    continue\n\n                name = node_classes.Const(arg.name, parent=parent)\n                yield name, default\n\n        args = self._instance.args\n        obj = node_classes.Dict(parent=self._instance)\n        defaults = dict(_default_args(args, obj))\n\n        obj.postinit(list(defaults.items()))\n        return obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___kwdefaults__", "self", "def", "_default_args", "args", "parent", "for", "arg", "in", "args", "kwonlyargs", "try", "default", "args", "default_value", "arg", "name", "except", "nodefault", "continue", "name", "node_classes", "const", "arg", "name", "parent", "parent", "yield", "name", "default", "args", "self", "_instance", "args", "obj", "node_classes", "dict", "parent", "self", "_instance", "defaults", "dict", "_default_args", "args", "obj", "obj", "postinit", "list", "defaults", "items", "return", "obj"], "doc_len": 58}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___module__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___module__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___module__(self):\n        return node_classes.Const(self._instance.root().qname())\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___module__", "self", "return", "node_classes", "const", "self", "_instance", "root", "qname"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___get__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___get__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___get__(self):\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import bases\n\n        func = self._instance\n\n        class DescriptorBoundMethod(bases.BoundMethod):\n            \"\"\"Bound method which knows how to understand calling descriptor binding.\"\"\"\n\n            def implicit_parameters(self):\n                # Different than BoundMethod since the signature\n                # is different.\n                return 0\n\n            def infer_call_result(self, caller, context=None):\n                if len(caller.args) > 2 or len(caller.args) < 1:\n                    raise InferenceError(\n                        \"Invalid arguments for descriptor binding\",\n                        target=self,\n                        context=context,\n                    )\n\n                context = copy_context(context)\n                try:\n                    cls = next(caller.args[0].infer(context=context))\n                except StopIteration as e:\n                    raise InferenceError(context=context, node=caller.args[0]) from e\n\n                if cls is astroid.Uninferable:\n                    raise InferenceError(\n                        \"Invalid class inferred\", target=self, context=context\n                    )\n\n                # For some reason func is a Node that the below\n                # code is not expecting\n                if isinstance(func, bases.BoundMethod):\n                    yield func\n                    return\n\n                # Rebuild the original value, but with the parent set as the\n                # class where it will be bound.\n                new_func = func.__class__(\n                    name=func.name,\n                    doc=func.doc,\n                    lineno=func.lineno,\n                    col_offset=func.col_offset,\n                    parent=func.parent,\n                )\n                # pylint: disable=no-member\n                new_func.postinit(func.args, func.body, func.decorators, func.returns)\n\n                # Build a proper bound method that points to our newly built function.\n                proxy = bases.UnboundMethod(new_func)\n                yield bases.BoundMethod(proxy=proxy, bound=cls)\n\n            @property\n            def args(self):\n                \"\"\"Overwrite the underlying args to match those of the underlying func\n\n                Usually the underlying *func* is a function/method, as in:\n\n                    def test(self):\n                        pass\n\n                This has only the *self* parameter but when we access test.__get__\n                we get a new object which has two parameters, *self* and *type*.\n                \"\"\"\n                nonlocal func\n                positional_or_keyword_params = func.args.args.copy()\n                positional_or_keyword_params.append(astroid.AssignName(name=\"type\"))\n\n                positional_only_params = func.args.posonlyargs.copy()\n\n                arguments = astroid.Arguments(parent=func.args.parent)\n                arguments.postinit(\n                    args=positional_or_keyword_params,\n                    posonlyargs=positional_only_params,\n                    defaults=[],\n                    kwonlyargs=[],\n                    kw_defaults=[],\n                    annotations=[],\n                )\n                return arguments\n\n        return DescriptorBoundMethod(proxy=self._instance, bound=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___get__", "self", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "import", "bases", "func", "self", "_instance", "class", "descriptorboundmethod", "bases", "boundmethod", "bound", "method", "which", "knows", "how", "to", "understand", "calling", "descriptor", "binding", "def", "implicit_parameters", "self", "different", "than", "boundmethod", "since", "the", "signature", "is", "different", "return", "0", "def", "infer_call_result", "self", "caller", "context", "none", "if", "len", "caller", "args", "2", "or", "len", "caller", "args", "1", "raise", "inferenceerror", "invalid", "arguments", "for", "descriptor", "binding", "target", "self", "context", "context", "context", "copy_context", "context", "try", "cls", "next", "caller", "args", "0", "infer", "context", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "context", "context", "node", "caller", "args", "0", "from", "e", "if", "cls", "is", "astroid", "uninferable", "raise", "inferenceerror", "invalid", "class", "inferred", "target", "self", "context", "context", "for", "some", "reason", "func", "is", "a", "node", "that", "the", "below", "code", "is", "not", "expecting", "if", "isinstance", "func", "bases", "boundmethod", "yield", "func", "return", "rebuild", "the", "original", "value", "but", "with", "the", "parent", "set", "as", "the", "class", "where", "it", "will", "be", "bound", "new_func", "func", "__class__", "name", "func", "name", "doc", "func", "doc", "lineno", "func", "lineno", "col_offset", "func", "col_offset", "parent", "func", "parent", "pylint", "disable", "no", "member", "new_func", "postinit", "func", "args", "func", "body", "func", "decorators", "func", "returns", "build", "a", "proper", "bound", "method", "that", "points", "to", "our", "newly", "built", "function", "proxy", "bases", "unboundmethod", "new_func", "yield", "bases", "boundmethod", "proxy", "proxy", "bound", "cls", "property", "def", "args", "self", "overwrite", "the", "underlying", "args", "to", "match", "those", "of", "the", "underlying", "func", "usually", "the", "underlying", "func", "is", "a", "function", "method", "as", "in", "def", "test", "self", "pass", "this", "has", "only", "the", "self", "parameter", "but", "when", "we", "access", "test", "__get__", "we", "get", "a", "new", "object", "which", "has", "two", "parameters", "self", "and", "type", "nonlocal", "func", "positional_or_keyword_params", "func", "args", "args", "copy", "positional_or_keyword_params", "append", "astroid", "assignname", "name", "type", "positional_only_params", "func", "args", "posonlyargs", "copy", "arguments", "astroid", "arguments", "parent", "func", "args", "parent", "arguments", "postinit", "args", "positional_or_keyword_params", "posonlyargs", "positional_only_params", "defaults", "kwonlyargs", "kw_defaults", "annotations", "return", "arguments", "return", "descriptorboundmethod", "proxy", "self", "_instance", "bound", "self", "_instance"], "doc_len": 308}
{"doc_id": "astroid/interpreter/objectmodel.py::FunctionModel.attr___ne__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "FunctionModel", "func_name": "attr___ne__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: FunctionModel\n    def attr___ne__(self):\n        return node_classes.Unknown()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "functionmodel", "def", "attr___ne__", "self", "return", "node_classes", "unknown"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.__init__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "__init__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def __init__(self):\n        # Add a context so that inferences called from an instance don't recurse endlessly\n        self.context = InferenceContext()\n\n        super().__init__()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "__init__", "self", "add", "a", "context", "so", "that", "inferences", "called", "from", "an", "instance", "don", "t", "recurse", "endlessly", "self", "context", "inferencecontext", "super", "__init__"], "doc_len": 27}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___module__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___module__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___module__(self):\n        return node_classes.Const(self._instance.root().qname())\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___module__", "self", "return", "node_classes", "const", "self", "_instance", "root", "qname"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___name__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___name__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___name__(self):\n        return node_classes.Const(self._instance.name)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___name__", "self", "return", "node_classes", "const", "self", "_instance", "name"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___qualname__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___qualname__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___qualname__(self):\n        return node_classes.Const(self._instance.qname())\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___qualname__", "self", "return", "node_classes", "const", "self", "_instance", "qname"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___doc__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___doc__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___doc__(self):\n        return node_classes.Const(self._instance.doc)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___doc__", "self", "return", "node_classes", "const", "self", "_instance", "doc"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___mro__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___mro__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___mro__(self):\n        if not self._instance.newstyle:\n            raise AttributeInferenceError(target=self._instance, attribute=\"__mro__\")\n\n        mro = self._instance.mro()\n        obj = node_classes.Tuple(parent=self._instance)\n        obj.postinit(mro)\n        return obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___mro__", "self", "if", "not", "self", "_instance", "newstyle", "raise", "attributeinferenceerror", "target", "self", "_instance", "attribute", "__mro__", "mro", "self", "_instance", "mro", "obj", "node_classes", "tuple", "parent", "self", "_instance", "obj", "postinit", "mro", "return", "obj"], "doc_len": 35}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr_mro", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr_mro", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr_mro(self):\n        if not self._instance.newstyle:\n            raise AttributeInferenceError(target=self._instance, attribute=\"mro\")\n\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import bases\n\n        other_self = self\n\n        # Cls.mro is a method and we need to return one in order to have a proper inference.\n        # The method we're returning is capable of inferring the underlying MRO though.\n        class MroBoundMethod(bases.BoundMethod):\n            def infer_call_result(self, caller, context=None):\n                yield other_self.attr___mro__\n\n        implicit_metaclass = self._instance.implicit_metaclass()\n        mro_method = implicit_metaclass.locals[\"mro\"][0]\n        return MroBoundMethod(proxy=mro_method, bound=implicit_metaclass)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr_mro", "self", "if", "not", "self", "_instance", "newstyle", "raise", "attributeinferenceerror", "target", "self", "_instance", "attribute", "mro", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "import", "bases", "other_self", "self", "cls", "mro", "is", "a", "method", "and", "we", "need", "to", "return", "one", "in", "order", "to", "have", "a", "proper", "inference", "the", "method", "we", "re", "returning", "is", "capable", "of", "inferring", "the", "underlying", "mro", "though", "class", "mroboundmethod", "bases", "boundmethod", "def", "infer_call_result", "self", "caller", "context", "none", "yield", "other_self", "attr___mro__", "implicit_metaclass", "self", "_instance", "implicit_metaclass", "mro_method", "implicit_metaclass", "locals", "mro", "0", "return", "mroboundmethod", "proxy", "mro_method", "bound", "implicit_metaclass"], "doc_len": 92}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___bases__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___bases__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___bases__(self):\n        obj = node_classes.Tuple()\n        context = InferenceContext()\n        elts = list(self._instance._inferred_bases(context))\n        obj.postinit(elts=elts)\n        return obj\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___bases__", "self", "obj", "node_classes", "tuple", "context", "inferencecontext", "elts", "list", "self", "_instance", "_inferred_bases", "context", "obj", "postinit", "elts", "elts", "return", "obj"], "doc_len": 25}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___class__(self):\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import helpers\n\n        return helpers.object_type(self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___class__", "self", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "import", "helpers", "return", "helpers", "object_type", "self", "_instance"], "doc_len": 24}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___subclasses__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___subclasses__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___subclasses__(self):\n        \"\"\"Get the subclasses of the underlying class\n\n        This looks only in the current module for retrieving the subclasses,\n        thus it might miss a couple of them.\n        \"\"\"\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import bases\n        from astroid.nodes import scoped_nodes\n\n        if not self._instance.newstyle:\n            raise AttributeInferenceError(\n                target=self._instance, attribute=\"__subclasses__\"\n            )\n\n        qname = self._instance.qname()\n        root = self._instance.root()\n        classes = [\n            cls\n            for cls in root.nodes_of_class(scoped_nodes.ClassDef)\n            if cls != self._instance and cls.is_subtype_of(qname, context=self.context)\n        ]\n\n        obj = node_classes.List(parent=self._instance)\n        obj.postinit(classes)\n\n        class SubclassesBoundMethod(bases.BoundMethod):\n            def infer_call_result(self, caller, context=None):\n                yield obj\n\n        implicit_metaclass = self._instance.implicit_metaclass()\n        subclasses_method = implicit_metaclass.locals[\"__subclasses__\"][0]\n        return SubclassesBoundMethod(proxy=subclasses_method, bound=implicit_metaclass)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___subclasses__", "self", "get", "the", "subclasses", "of", "the", "underlying", "class", "this", "looks", "only", "in", "the", "current", "module", "for", "retrieving", "the", "subclasses", "thus", "it", "might", "miss", "a", "couple", "of", "them", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "import", "bases", "from", "astroid", "nodes", "import", "scoped_nodes", "if", "not", "self", "_instance", "newstyle", "raise", "attributeinferenceerror", "target", "self", "_instance", "attribute", "__subclasses__", "qname", "self", "_instance", "qname", "root", "self", "_instance", "root", "classes", "cls", "for", "cls", "in", "root", "nodes_of_class", "scoped_nodes", "classdef", "if", "cls", "self", "_instance", "and", "cls", "is_subtype_of", "qname", "context", "self", "context", "obj", "node_classes", "list", "parent", "self", "_instance", "obj", "postinit", "classes", "class", "subclassesboundmethod", "bases", "boundmethod", "def", "infer_call_result", "self", "caller", "context", "none", "yield", "obj", "implicit_metaclass", "self", "_instance", "implicit_metaclass", "subclasses_method", "implicit_metaclass", "locals", "__subclasses__", "0", "return", "subclassesboundmethod", "proxy", "subclasses_method", "bound", "implicit_metaclass"], "doc_len": 126}
{"doc_id": "astroid/interpreter/objectmodel.py::ClassModel.attr___dict__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ClassModel", "func_name": "attr___dict__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ClassModel\n    def attr___dict__(self):\n        return node_classes.Dict(parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "classmodel", "def", "attr___dict__", "self", "return", "node_classes", "dict", "parent", "self", "_instance"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::SuperModel.attr___thisclass__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "SuperModel", "func_name": "attr___thisclass__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: SuperModel\n    def attr___thisclass__(self):\n        return self._instance.mro_pointer\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "supermodel", "def", "attr___thisclass__", "self", "return", "self", "_instance", "mro_pointer"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::SuperModel.attr___self_class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "SuperModel", "func_name": "attr___self_class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: SuperModel\n    def attr___self_class__(self):\n        return self._instance._self_class\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "supermodel", "def", "attr___self_class__", "self", "return", "self", "_instance", "_self_class"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::SuperModel.attr___self__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "SuperModel", "func_name": "attr___self__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: SuperModel\n    def attr___self__(self):\n        return self._instance.type\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "supermodel", "def", "attr___self__", "self", "return", "self", "_instance", "type"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::SuperModel.attr___class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "SuperModel", "func_name": "attr___class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: SuperModel\n    def attr___class__(self):\n        return self._instance._proxied\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "supermodel", "def", "attr___class__", "self", "return", "self", "_instance", "_proxied"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::UnboundMethodModel.attr___class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "UnboundMethodModel", "func_name": "attr___class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: UnboundMethodModel\n    def attr___class__(self):\n        # pylint: disable=import-outside-toplevel; circular import\n        from astroid import helpers\n\n        return helpers.object_type(self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "unboundmethodmodel", "def", "attr___class__", "self", "pylint", "disable", "import", "outside", "toplevel", "circular", "import", "from", "astroid", "import", "helpers", "return", "helpers", "object_type", "self", "_instance"], "doc_len": 24}
{"doc_id": "astroid/interpreter/objectmodel.py::UnboundMethodModel.attr___func__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "UnboundMethodModel", "func_name": "attr___func__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: UnboundMethodModel\n    def attr___func__(self):\n        return self._instance._proxied\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "unboundmethodmodel", "def", "attr___func__", "self", "return", "self", "_instance", "_proxied"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::UnboundMethodModel.attr___self__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "UnboundMethodModel", "func_name": "attr___self__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: UnboundMethodModel\n    def attr___self__(self):\n        return node_classes.Const(value=None, parent=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "unboundmethodmodel", "def", "attr___self__", "self", "return", "node_classes", "const", "value", "none", "parent", "self", "_instance"], "doc_len": 16}
{"doc_id": "astroid/interpreter/objectmodel.py::BoundMethodModel.attr___func__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "BoundMethodModel", "func_name": "attr___func__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: BoundMethodModel\n    def attr___func__(self):\n        return self._instance._proxied._proxied\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "boundmethodmodel", "def", "attr___func__", "self", "return", "self", "_instance", "_proxied", "_proxied"], "doc_len": 13}
{"doc_id": "astroid/interpreter/objectmodel.py::BoundMethodModel.attr___self__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "BoundMethodModel", "func_name": "attr___self__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: BoundMethodModel\n    def attr___self__(self):\n        return self._instance.bound\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "boundmethodmodel", "def", "attr___self__", "self", "return", "self", "_instance", "bound"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::GeneratorModel.__new__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "GeneratorModel", "func_name": "__new__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: GeneratorModel\n    def __new__(cls, *args, **kwargs):\n        # Append the values from the GeneratorType unto this object.\n        ret = super().__new__(cls, *args, **kwargs)\n        generator = AstroidManager().builtins_module[\"generator\"]\n        for name, values in generator.locals.items():\n            method = values[0]\n\n            def patched(cls, meth=method):\n                return meth\n\n            setattr(type(ret), IMPL_PREFIX + name, property(patched))\n\n        return ret\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "generatormodel", "def", "__new__", "cls", "args", "kwargs", "append", "the", "values", "from", "the", "generatortype", "unto", "this", "object", "ret", "super", "__new__", "cls", "args", "kwargs", "generator", "astroidmanager", "builtins_module", "generator", "for", "name", "values", "in", "generator", "locals", "items", "method", "values", "0", "def", "patched", "cls", "meth", "method", "return", "meth", "setattr", "type", "ret", "impl_prefix", "name", "property", "patched", "return", "ret"], "doc_len": 55}
{"doc_id": "astroid/interpreter/objectmodel.py::GeneratorModel.attr___name__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "GeneratorModel", "func_name": "attr___name__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: GeneratorModel\n    def attr___name__(self):\n        return node_classes.Const(\n            value=self._instance.parent.name, parent=self._instance\n        )\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "generatormodel", "def", "attr___name__", "self", "return", "node_classes", "const", "value", "self", "_instance", "parent", "name", "parent", "self", "_instance"], "doc_len": 19}
{"doc_id": "astroid/interpreter/objectmodel.py::GeneratorModel.attr___doc__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "GeneratorModel", "func_name": "attr___doc__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: GeneratorModel\n    def attr___doc__(self):\n        return node_classes.Const(\n            value=self._instance.parent.doc, parent=self._instance\n        )\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "generatormodel", "def", "attr___doc__", "self", "return", "node_classes", "const", "value", "self", "_instance", "parent", "doc", "parent", "self", "_instance"], "doc_len": 19}
{"doc_id": "astroid/interpreter/objectmodel.py::AsyncGeneratorModel.__new__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "AsyncGeneratorModel", "func_name": "__new__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: AsyncGeneratorModel\n    def __new__(cls, *args, **kwargs):\n        # Append the values from the AGeneratorType unto this object.\n        ret = super().__new__(cls, *args, **kwargs)\n        astroid_builtins = AstroidManager().builtins_module\n        generator = astroid_builtins.get(\"async_generator\")\n        if generator is None:\n            # Make it backward compatible.\n            generator = astroid_builtins.get(\"generator\")\n\n        for name, values in generator.locals.items():\n            method = values[0]\n\n            def patched(cls, meth=method):\n                return meth\n\n            setattr(type(ret), IMPL_PREFIX + name, property(patched))\n\n        return ret\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "asyncgeneratormodel", "def", "__new__", "cls", "args", "kwargs", "append", "the", "values", "from", "the", "ageneratortype", "unto", "this", "object", "ret", "super", "__new__", "cls", "args", "kwargs", "astroid_builtins", "astroidmanager", "builtins_module", "generator", "astroid_builtins", "get", "async_generator", "if", "generator", "is", "none", "make", "it", "backward", "compatible", "generator", "astroid_builtins", "get", "generator", "for", "name", "values", "in", "generator", "locals", "items", "method", "values", "0", "def", "patched", "cls", "meth", "method", "return", "meth", "setattr", "type", "ret", "impl_prefix", "name", "property", "patched", "return", "ret"], "doc_len": 70}
{"doc_id": "astroid/interpreter/objectmodel.py::InstanceModel.attr___class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "InstanceModel", "func_name": "attr___class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: InstanceModel\n    def attr___class__(self):\n        return self._instance._proxied\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "instancemodel", "def", "attr___class__", "self", "return", "self", "_instance", "_proxied"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::InstanceModel.attr___module__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "InstanceModel", "func_name": "attr___module__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: InstanceModel\n    def attr___module__(self):\n        return node_classes.Const(self._instance.root().qname())\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "instancemodel", "def", "attr___module__", "self", "return", "node_classes", "const", "self", "_instance", "root", "qname"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::InstanceModel.attr___doc__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "InstanceModel", "func_name": "attr___doc__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: InstanceModel\n    def attr___doc__(self):\n        return node_classes.Const(self._instance.doc)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "instancemodel", "def", "attr___doc__", "self", "return", "node_classes", "const", "self", "_instance", "doc"], "doc_len": 14}
{"doc_id": "astroid/interpreter/objectmodel.py::InstanceModel.attr___dict__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "InstanceModel", "func_name": "attr___dict__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: InstanceModel\n    def attr___dict__(self):\n        return _dunder_dict(self._instance, self._instance.instance_attrs)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "instancemodel", "def", "attr___dict__", "self", "return", "_dunder_dict", "self", "_instance", "self", "_instance", "instance_attrs"], "doc_len": 15}
{"doc_id": "astroid/interpreter/objectmodel.py::ExceptionInstanceModel.attr_args", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ExceptionInstanceModel", "func_name": "attr_args", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ExceptionInstanceModel\n    def attr_args(self):\n        message = node_classes.Const(\"\")\n        args = node_classes.Tuple(parent=self._instance)\n        args.postinit((message,))\n        return args\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "exceptioninstancemodel", "def", "attr_args", "self", "message", "node_classes", "const", "args", "node_classes", "tuple", "parent", "self", "_instance", "args", "postinit", "message", "return", "args"], "doc_len": 22}
{"doc_id": "astroid/interpreter/objectmodel.py::ExceptionInstanceModel.attr___traceback__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ExceptionInstanceModel", "func_name": "attr___traceback__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ExceptionInstanceModel\n    def attr___traceback__(self):\n        builtins_ast_module = AstroidManager().builtins_module\n        traceback_type = builtins_ast_module[types.TracebackType.__name__]\n        return traceback_type.instantiate_class()\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "exceptioninstancemodel", "def", "attr___traceback__", "self", "builtins_ast_module", "astroidmanager", "builtins_module", "traceback_type", "builtins_ast_module", "types", "tracebacktype", "__name__", "return", "traceback_type", "instantiate_class"], "doc_len": 19}
{"doc_id": "astroid/interpreter/objectmodel.py::SyntaxErrorInstanceModel.attr_text", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "SyntaxErrorInstanceModel", "func_name": "attr_text", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: SyntaxErrorInstanceModel\n    def attr_text(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "syntaxerrorinstancemodel", "def", "attr_text", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::OSErrorInstanceModel.attr_filename", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "OSErrorInstanceModel", "func_name": "attr_filename", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: OSErrorInstanceModel\n    def attr_filename(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "oserrorinstancemodel", "def", "attr_filename", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::OSErrorInstanceModel.attr_errno", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "OSErrorInstanceModel", "func_name": "attr_errno", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: OSErrorInstanceModel\n    def attr_errno(self):\n        return node_classes.Const(0)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "oserrorinstancemodel", "def", "attr_errno", "self", "return", "node_classes", "const", "0"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::OSErrorInstanceModel.attr_strerror", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "OSErrorInstanceModel", "func_name": "attr_strerror", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: OSErrorInstanceModel\n    def attr_strerror(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "oserrorinstancemodel", "def", "attr_strerror", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::ImportErrorInstanceModel.attr_name", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ImportErrorInstanceModel", "func_name": "attr_name", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ImportErrorInstanceModel\n    def attr_name(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "importerrorinstancemodel", "def", "attr_name", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::ImportErrorInstanceModel.attr_path", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "ImportErrorInstanceModel", "func_name": "attr_path", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: ImportErrorInstanceModel\n    def attr_path(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "importerrorinstancemodel", "def", "attr_path", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::UnicodeDecodeErrorInstanceModel.attr_object", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "UnicodeDecodeErrorInstanceModel", "func_name": "attr_object", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: UnicodeDecodeErrorInstanceModel\n    def attr_object(self):\n        return node_classes.Const(\"\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "unicodedecodeerrorinstancemodel", "def", "attr_object", "self", "return", "node_classes", "const"], "doc_len": 11}
{"doc_id": "astroid/interpreter/objectmodel.py::DictModel.attr___class__", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "DictModel", "func_name": "attr___class__", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: DictModel\n    def attr___class__(self):\n        return self._instance._proxied\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "dictmodel", "def", "attr___class__", "self", "return", "self", "_instance", "_proxied"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::DictModel._generic_dict_attribute", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "DictModel", "func_name": "_generic_dict_attribute", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: DictModel\n    def _generic_dict_attribute(self, obj, name):\n        \"\"\"Generate a bound method that can infer the given *obj*.\"\"\"\n\n        class DictMethodBoundMethod(astroid.BoundMethod):\n            def infer_call_result(self, caller, context=None):\n                yield obj\n\n        meth = next(self._instance._proxied.igetattr(name), None)\n        return DictMethodBoundMethod(proxy=meth, bound=self._instance)\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "dictmodel", "def", "_generic_dict_attribute", "self", "obj", "name", "generate", "a", "bound", "method", "that", "can", "infer", "the", "given", "obj", "class", "dictmethodboundmethod", "astroid", "boundmethod", "def", "infer_call_result", "self", "caller", "context", "none", "yield", "obj", "meth", "next", "self", "_instance", "_proxied", "igetattr", "name", "none", "return", "dictmethodboundmethod", "proxy", "meth", "bound", "self", "_instance"], "doc_len": 47}
{"doc_id": "astroid/interpreter/objectmodel.py::DictModel.attr_items", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "DictModel", "func_name": "attr_items", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: DictModel\n    def attr_items(self):\n        elems = []\n        obj = node_classes.List(parent=self._instance)\n        for key, value in self._instance.items:\n            elem = node_classes.Tuple(parent=obj)\n            elem.postinit((key, value))\n            elems.append(elem)\n        obj.postinit(elts=elems)\n\n        obj = objects.DictItems(obj)\n        return self._generic_dict_attribute(obj, \"items\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "dictmodel", "def", "attr_items", "self", "elems", "obj", "node_classes", "list", "parent", "self", "_instance", "for", "key", "value", "in", "self", "_instance", "items", "elem", "node_classes", "tuple", "parent", "obj", "elem", "postinit", "key", "value", "elems", "append", "elem", "obj", "postinit", "elts", "elems", "obj", "objects", "dictitems", "obj", "return", "self", "_generic_dict_attribute", "obj", "items"], "doc_len": 47}
{"doc_id": "astroid/interpreter/objectmodel.py::DictModel.attr_keys", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "DictModel", "func_name": "attr_keys", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: DictModel\n    def attr_keys(self):\n        keys = [key for (key, _) in self._instance.items]\n        obj = node_classes.List(parent=self._instance)\n        obj.postinit(elts=keys)\n\n        obj = objects.DictKeys(obj)\n        return self._generic_dict_attribute(obj, \"keys\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "dictmodel", "def", "attr_keys", "self", "keys", "key", "for", "key", "_", "in", "self", "_instance", "items", "obj", "node_classes", "list", "parent", "self", "_instance", "obj", "postinit", "elts", "keys", "obj", "objects", "dictkeys", "obj", "return", "self", "_generic_dict_attribute", "obj", "keys"], "doc_len": 36}
{"doc_id": "astroid/interpreter/objectmodel.py::DictModel.attr_values", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "DictModel", "func_name": "attr_values", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: DictModel\n    def attr_values(self):\n\n        values = [value for (_, value) in self._instance.items]\n        obj = node_classes.List(parent=self._instance)\n        obj.postinit(values)\n\n        obj = objects.DictValues(obj)\n        return self._generic_dict_attribute(obj, \"values\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "dictmodel", "def", "attr_values", "self", "values", "value", "for", "_", "value", "in", "self", "_instance", "items", "obj", "node_classes", "list", "parent", "self", "_instance", "obj", "postinit", "values", "obj", "objects", "dictvalues", "obj", "return", "self", "_generic_dict_attribute", "obj", "values"], "doc_len": 35}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel._init_function", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "_init_function", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def _init_function(self, name):\n        from astroid.nodes.node_classes import Arguments\n        from astroid.nodes.scoped_nodes import FunctionDef\n\n        args = Arguments()\n        args.postinit(\n            args=[],\n            defaults=[],\n            kwonlyargs=[],\n            kw_defaults=[],\n            annotations=[],\n            posonlyargs=[],\n            posonlyargs_annotations=[],\n            kwonlyargs_annotations=[],\n        )\n\n        function = FunctionDef(name=name, parent=self._instance)\n\n        function.postinit(args=args, body=[])\n        return function\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "_init_function", "self", "name", "from", "astroid", "nodes", "node_classes", "import", "arguments", "from", "astroid", "nodes", "scoped_nodes", "import", "functiondef", "args", "arguments", "args", "postinit", "args", "defaults", "kwonlyargs", "kw_defaults", "annotations", "posonlyargs", "posonlyargs_annotations", "kwonlyargs_annotations", "function", "functiondef", "name", "name", "parent", "self", "_instance", "function", "postinit", "args", "args", "body", "return", "function"], "doc_len": 47}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel.attr_fget", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "attr_fget", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def attr_fget(self):\n        from astroid.nodes.scoped_nodes import FunctionDef\n\n        func = self._instance\n\n        class PropertyFuncAccessor(FunctionDef):\n            def infer_call_result(self, caller=None, context=None):\n                nonlocal func\n                if caller and len(caller.args) != 1:\n                    raise InferenceError(\n                        \"fget() needs a single argument\", target=self, context=context\n                    )\n\n                yield from func.function.infer_call_result(\n                    caller=caller, context=context\n                )\n\n        property_accessor = PropertyFuncAccessor(name=\"fget\", parent=self._instance)\n        property_accessor.postinit(args=func.args, body=func.body)\n        return property_accessor\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "attr_fget", "self", "from", "astroid", "nodes", "scoped_nodes", "import", "functiondef", "func", "self", "_instance", "class", "propertyfuncaccessor", "functiondef", "def", "infer_call_result", "self", "caller", "none", "context", "none", "nonlocal", "func", "if", "caller", "and", "len", "caller", "args", "1", "raise", "inferenceerror", "fget", "needs", "a", "single", "argument", "target", "self", "context", "context", "yield", "from", "func", "function", "infer_call_result", "caller", "caller", "context", "context", "property_accessor", "propertyfuncaccessor", "name", "fget", "parent", "self", "_instance", "property_accessor", "postinit", "args", "func", "args", "body", "func", "body", "return", "property_accessor"], "doc_len": 73}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel.attr_fset", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "attr_fset", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def attr_fset(self):\n        from astroid.nodes.scoped_nodes import FunctionDef\n\n        func = self._instance\n\n        def find_setter(func: \"Property\") -> Optional[astroid.FunctionDef]:\n            \"\"\"\n            Given a property, find the corresponding setter function and returns it.\n\n            :param func: property for which the setter has to be found\n            :return: the setter function or None\n            \"\"\"\n            for target in [\n                t for t in func.parent.get_children() if t.name == func.function.name\n            ]:\n                for dec_name in target.decoratornames():\n                    if dec_name.endswith(func.function.name + \".setter\"):\n                        return target\n            return None\n\n        func_setter = find_setter(func)\n        if not func_setter:\n            raise InferenceError(\n                f\"Unable to find the setter of property {func.function.name}\"\n            )\n\n        class PropertyFuncAccessor(FunctionDef):\n            def infer_call_result(self, caller=None, context=None):\n                nonlocal func_setter\n                if caller and len(caller.args) != 2:\n                    raise InferenceError(\n                        \"fset() needs two arguments\", target=self, context=context\n                    )\n                yield from func_setter.infer_call_result(caller=caller, context=context)\n\n        property_accessor = PropertyFuncAccessor(name=\"fset\", parent=self._instance)\n        property_accessor.postinit(args=func_setter.args, body=func_setter.body)\n        return property_accessor\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "attr_fset", "self", "from", "astroid", "nodes", "scoped_nodes", "import", "functiondef", "func", "self", "_instance", "def", "find_setter", "func", "property", "optional", "astroid", "functiondef", "given", "a", "property", "find", "the", "corresponding", "setter", "function", "and", "returns", "it", "param", "func", "property", "for", "which", "the", "setter", "has", "to", "be", "found", "return", "the", "setter", "function", "or", "none", "for", "target", "in", "t", "for", "t", "in", "func", "parent", "get_children", "if", "t", "name", "func", "function", "name", "for", "dec_name", "in", "target", "decoratornames", "if", "dec_name", "endswith", "func", "function", "name", "setter", "return", "target", "return", "none", "func_setter", "find_setter", "func", "if", "not", "func_setter", "raise", "inferenceerror", "f", "unable", "to", "find", "the", "setter", "of", "property", "func", "function", "name", "class", "propertyfuncaccessor", "functiondef", "def", "infer_call_result", "self", "caller", "none", "context", "none", "nonlocal", "func_setter", "if", "caller", "and", "len", "caller", "args", "2", "raise", "inferenceerror", "fset", "needs", "two", "arguments", "target", "self", "context", "context", "yield", "from", "func_setter", "infer_call_result", "caller", "caller", "context", "context", "property_accessor", "propertyfuncaccessor", "name", "fset", "parent", "self", "_instance", "property_accessor", "postinit", "args", "func_setter", "args", "body", "func_setter", "body", "return", "property_accessor"], "doc_len": 157}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel.attr_setter", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "attr_setter", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def attr_setter(self):\n        return self._init_function(\"setter\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "attr_setter", "self", "return", "self", "_init_function", "setter"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel.attr_deleter", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "attr_deleter", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def attr_deleter(self):\n        return self._init_function(\"deleter\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "attr_deleter", "self", "return", "self", "_init_function", "deleter"], "doc_len": 12}
{"doc_id": "astroid/interpreter/objectmodel.py::PropertyModel.attr_getter", "file_path": "astroid/interpreter/objectmodel.py", "class_name": "PropertyModel", "func_name": "attr_getter", "text": "文件路径: astroid/interpreter/objectmodel.py, 类名: PropertyModel\n    def attr_getter(self):\n        return self._init_function(\"getter\")\n", "tokens": ["astroid", "interpreter", "objectmodel", "py", "propertymodel", "def", "attr_getter", "self", "return", "self", "_init_function", "getter"], "doc_len": 12}
{"doc_id": "astroid/interpreter/_import/spec.py::ModuleSpec.__new__", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ModuleSpec", "func_name": "__new__", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ModuleSpec\n    def __new__(\n        cls,\n        name,\n        module_type,\n        location=None,\n        origin=None,\n        submodule_search_locations=None,\n    ):\n        return _ModuleSpec.__new__(\n            cls,\n            name=name,\n            type=module_type,\n            location=location,\n            origin=origin,\n            submodule_search_locations=submodule_search_locations,\n        )\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "modulespec", "def", "__new__", "cls", "name", "module_type", "location", "none", "origin", "none", "submodule_search_locations", "none", "return", "_modulespec", "__new__", "cls", "name", "name", "type", "module_type", "location", "location", "origin", "origin", "submodule_search_locations", "submodule_search_locations"], "doc_len": 31}
{"doc_id": "astroid/interpreter/_import/spec.py::Finder.__init__", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "Finder", "func_name": "__init__", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: Finder\n    def __init__(self, path=None):\n        self._path = path or sys.path\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "finder", "def", "__init__", "self", "path", "none", "self", "_path", "path", "or", "sys", "path"], "doc_len": 17}
{"doc_id": "astroid/interpreter/_import/spec.py::Finder.find_module", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "Finder", "func_name": "find_module", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: Finder\n    def find_module(self, modname, module_parts, processed, submodule_path):\n        \"\"\"Find the given module\n\n        Each finder is responsible for each protocol of finding, as long as\n        they all return a ModuleSpec.\n\n        :param str modname: The module which needs to be searched.\n        :param list module_parts: It should be a list of strings,\n                                  where each part contributes to the module's\n                                  namespace.\n        :param list processed: What parts from the module parts were processed\n                               so far.\n        :param list submodule_path: A list of paths where the module\n                                    can be looked into.\n        :returns: A ModuleSpec, describing how and where the module was found,\n                  None, otherwise.\n        \"\"\"\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "finder", "def", "find_module", "self", "modname", "module_parts", "processed", "submodule_path", "find", "the", "given", "module", "each", "finder", "is", "responsible", "for", "each", "protocol", "of", "finding", "as", "long", "as", "they", "all", "return", "a", "modulespec", "param", "str", "modname", "the", "module", "which", "needs", "to", "be", "searched", "param", "list", "module_parts", "it", "should", "be", "a", "list", "of", "strings", "where", "each", "part", "contributes", "to", "the", "module", "s", "namespace", "param", "list", "processed", "what", "parts", "from", "the", "module", "parts", "were", "processed", "so", "far", "param", "list", "submodule_path", "a", "list", "of", "paths", "where", "the", "module", "can", "be", "looked", "into", "returns", "a", "modulespec", "describing", "how", "and", "where", "the", "module", "was", "found", "none", "otherwise"], "doc_len": 103}
{"doc_id": "astroid/interpreter/_import/spec.py::Finder.contribute_to_path", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "Finder", "func_name": "contribute_to_path", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: Finder\n    def contribute_to_path(self, spec, processed):\n        \"\"\"Get a list of extra paths where this finder can search.\"\"\"\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "finder", "def", "contribute_to_path", "self", "spec", "processed", "get", "a", "list", "of", "extra", "paths", "where", "this", "finder", "can", "search"], "doc_len": 22}
{"doc_id": "astroid/interpreter/_import/spec.py::ImportlibFinder.find_module", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ImportlibFinder", "func_name": "find_module", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ImportlibFinder\n    def find_module(self, modname, module_parts, processed, submodule_path):\n        if not isinstance(modname, str):\n            raise TypeError(f\"'modname' must be a str, not {type(modname)}\")\n        if submodule_path is not None:\n            submodule_path = list(submodule_path)\n        else:\n            try:\n                spec = importlib.util.find_spec(modname)\n                if spec:\n                    if spec.loader is importlib.machinery.BuiltinImporter:\n                        return ModuleSpec(\n                            name=modname,\n                            location=None,\n                            module_type=ModuleType.C_BUILTIN,\n                        )\n                    if spec.loader is importlib.machinery.FrozenImporter:\n                        return ModuleSpec(\n                            name=modname,\n                            location=None,\n                            module_type=ModuleType.PY_FROZEN,\n                        )\n            except ValueError:\n                pass\n            submodule_path = sys.path\n\n        for entry in submodule_path:\n            package_directory = os.path.join(entry, modname)\n            for suffix in (\".py\", importlib.machinery.BYTECODE_SUFFIXES[0]):\n                package_file_name = \"__init__\" + suffix\n                file_path = os.path.join(package_directory, package_file_name)\n                if os.path.isfile(file_path):\n                    return ModuleSpec(\n                        name=modname,\n                        location=package_directory,\n                        module_type=ModuleType.PKG_DIRECTORY,\n                    )\n            for suffix, type_ in ImportlibFinder._SUFFIXES:\n                file_name = modname + suffix\n                file_path = os.path.join(entry, file_name)\n                if os.path.isfile(file_path):\n                    return ModuleSpec(\n                        name=modname, location=file_path, module_type=type_\n                    )\n        return None\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "importlibfinder", "def", "find_module", "self", "modname", "module_parts", "processed", "submodule_path", "if", "not", "isinstance", "modname", "str", "raise", "typeerror", "f", "modname", "must", "be", "a", "str", "not", "type", "modname", "if", "submodule_path", "is", "not", "none", "submodule_path", "list", "submodule_path", "else", "try", "spec", "importlib", "util", "find_spec", "modname", "if", "spec", "if", "spec", "loader", "is", "importlib", "machinery", "builtinimporter", "return", "modulespec", "name", "modname", "location", "none", "module_type", "moduletype", "c_builtin", "if", "spec", "loader", "is", "importlib", "machinery", "frozenimporter", "return", "modulespec", "name", "modname", "location", "none", "module_type", "moduletype", "py_frozen", "except", "valueerror", "pass", "submodule_path", "sys", "path", "for", "entry", "in", "submodule_path", "package_directory", "os", "path", "join", "entry", "modname", "for", "suffix", "in", "py", "importlib", "machinery", "bytecode_suffixes", "0", "package_file_name", "__init__", "suffix", "file_path", "os", "path", "join", "package_directory", "package_file_name", "if", "os", "path", "isfile", "file_path", "return", "modulespec", "name", "modname", "location", "package_directory", "module_type", "moduletype", "pkg_directory", "for", "suffix", "type_", "in", "importlibfinder", "_suffixes", "file_name", "modname", "suffix", "file_path", "os", "path", "join", "entry", "file_name", "if", "os", "path", "isfile", "file_path", "return", "modulespec", "name", "modname", "location", "file_path", "module_type", "type_", "return", "none"], "doc_len": 155}
{"doc_id": "astroid/interpreter/_import/spec.py::ImportlibFinder.contribute_to_path", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ImportlibFinder", "func_name": "contribute_to_path", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ImportlibFinder\n    def contribute_to_path(self, spec, processed):\n        if spec.location is None:\n            # Builtin.\n            return None\n\n        if _is_setuptools_namespace(spec.location):\n            # extend_path is called, search sys.path for module/packages\n            # of this name see pkgutil.extend_path documentation\n            path = [\n                os.path.join(p, *processed)\n                for p in sys.path\n                if os.path.isdir(os.path.join(p, *processed))\n            ]\n        else:\n            path = [spec.location]\n        return path\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "importlibfinder", "def", "contribute_to_path", "self", "spec", "processed", "if", "spec", "location", "is", "none", "builtin", "return", "none", "if", "_is_setuptools_namespace", "spec", "location", "extend_path", "is", "called", "search", "sys", "path", "for", "module", "packages", "of", "this", "name", "see", "pkgutil", "extend_path", "documentation", "path", "os", "path", "join", "p", "processed", "for", "p", "in", "sys", "path", "if", "os", "path", "isdir", "os", "path", "join", "p", "processed", "else", "path", "spec", "location", "return", "path"], "doc_len": 65}
{"doc_id": "astroid/interpreter/_import/spec.py::ExplicitNamespacePackageFinder.find_module", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ExplicitNamespacePackageFinder", "func_name": "find_module", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ExplicitNamespacePackageFinder\n    def find_module(self, modname, module_parts, processed, submodule_path):\n        if processed:\n            modname = \".\".join(processed + [modname])\n        if util.is_namespace(modname) and modname in sys.modules:\n            submodule_path = sys.modules[modname].__path__\n            return ModuleSpec(\n                name=modname,\n                location=\"\",\n                origin=\"namespace\",\n                module_type=ModuleType.PY_NAMESPACE,\n                submodule_search_locations=submodule_path,\n            )\n        return None\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "explicitnamespacepackagefinder", "def", "find_module", "self", "modname", "module_parts", "processed", "submodule_path", "if", "processed", "modname", "join", "processed", "modname", "if", "util", "is_namespace", "modname", "and", "modname", "in", "sys", "modules", "submodule_path", "sys", "modules", "modname", "__path__", "return", "modulespec", "name", "modname", "location", "origin", "namespace", "module_type", "moduletype", "py_namespace", "submodule_search_locations", "submodule_path", "return", "none"], "doc_len": 47}
{"doc_id": "astroid/interpreter/_import/spec.py::ExplicitNamespacePackageFinder.contribute_to_path", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ExplicitNamespacePackageFinder", "func_name": "contribute_to_path", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ExplicitNamespacePackageFinder\n    def contribute_to_path(self, spec, processed):\n        return spec.submodule_search_locations\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "explicitnamespacepackagefinder", "def", "contribute_to_path", "self", "spec", "processed", "return", "spec", "submodule_search_locations"], "doc_len": 14}
{"doc_id": "astroid/interpreter/_import/spec.py::ZipFinder.__init__", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ZipFinder", "func_name": "__init__", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ZipFinder\n    def __init__(self, path):\n        super().__init__(path)\n        self._zipimporters = _precache_zipimporters(path)\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "zipfinder", "def", "__init__", "self", "path", "super", "__init__", "path", "self", "_zipimporters", "_precache_zipimporters", "path"], "doc_len": 17}
{"doc_id": "astroid/interpreter/_import/spec.py::ZipFinder.find_module", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "ZipFinder", "func_name": "find_module", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: ZipFinder\n    def find_module(self, modname, module_parts, processed, submodule_path):\n        try:\n            file_type, filename, path = _search_zip(module_parts, self._zipimporters)\n        except ImportError:\n            return None\n\n        return ModuleSpec(\n            name=modname,\n            location=filename,\n            origin=\"egg\",\n            module_type=file_type,\n            submodule_search_locations=path,\n        )\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "zipfinder", "def", "find_module", "self", "modname", "module_parts", "processed", "submodule_path", "try", "file_type", "filename", "path", "_search_zip", "module_parts", "self", "_zipimporters", "except", "importerror", "return", "none", "return", "modulespec", "name", "modname", "location", "filename", "origin", "egg", "module_type", "file_type", "submodule_search_locations", "path"], "doc_len": 37}
{"doc_id": "astroid/interpreter/_import/spec.py::PathSpecFinder.find_module", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "PathSpecFinder", "func_name": "find_module", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: PathSpecFinder\n    def find_module(self, modname, module_parts, processed, submodule_path):\n        spec = importlib.machinery.PathFinder.find_spec(modname, path=submodule_path)\n        if spec:\n            # origin can be either a string on older Python versions\n            # or None in case it is a namespace package:\n            # https://github.com/python/cpython/pull/5481\n            is_namespace_pkg = spec.origin in {\"namespace\", None}\n            location = spec.origin if not is_namespace_pkg else None\n            module_type = ModuleType.PY_NAMESPACE if is_namespace_pkg else None\n            spec = ModuleSpec(\n                name=spec.name,\n                location=location,\n                origin=spec.origin,\n                module_type=module_type,\n                submodule_search_locations=list(spec.submodule_search_locations or []),\n            )\n        return spec\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "pathspecfinder", "def", "find_module", "self", "modname", "module_parts", "processed", "submodule_path", "spec", "importlib", "machinery", "pathfinder", "find_spec", "modname", "path", "submodule_path", "if", "spec", "origin", "can", "be", "either", "a", "string", "on", "older", "python", "versions", "or", "none", "in", "case", "it", "is", "a", "namespace", "package", "https", "github", "com", "python", "cpython", "pull", "5481", "is_namespace_pkg", "spec", "origin", "in", "namespace", "none", "location", "spec", "origin", "if", "not", "is_namespace_pkg", "else", "none", "module_type", "moduletype", "py_namespace", "if", "is_namespace_pkg", "else", "none", "spec", "modulespec", "name", "spec", "name", "location", "location", "origin", "spec", "origin", "module_type", "module_type", "submodule_search_locations", "list", "spec", "submodule_search_locations", "or", "return", "spec"], "doc_len": 89}
{"doc_id": "astroid/interpreter/_import/spec.py::PathSpecFinder.contribute_to_path", "file_path": "astroid/interpreter/_import/spec.py", "class_name": "PathSpecFinder", "func_name": "contribute_to_path", "text": "文件路径: astroid/interpreter/_import/spec.py, 类名: PathSpecFinder\n    def contribute_to_path(self, spec, processed):\n        if spec.type == ModuleType.PY_NAMESPACE:\n            return spec.submodule_search_locations\n        return None\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "pathspecfinder", "def", "contribute_to_path", "self", "spec", "processed", "if", "spec", "type", "moduletype", "py_namespace", "return", "spec", "submodule_search_locations", "return", "none"], "doc_len": 21}
{"doc_id": "astroid/interpreter/_import/spec.py::_is_setuptools_namespace", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "_is_setuptools_namespace", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef _is_setuptools_namespace(location):\n    try:\n        with open(os.path.join(location, \"__init__.py\"), \"rb\") as stream:\n            data = stream.read(4096)\n    except OSError:\n        return None\n    else:\n        extend_path = b\"pkgutil\" in data and b\"extend_path\" in data\n        declare_namespace = (\n            b\"pkg_resources\" in data and b\"declare_namespace(__name__)\" in data\n        )\n        return extend_path or declare_namespace\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "_is_setuptools_namespace", "location", "try", "with", "open", "os", "path", "join", "location", "__init__", "py", "rb", "as", "stream", "data", "stream", "read", "4096", "except", "oserror", "return", "none", "else", "extend_path", "b", "pkgutil", "in", "data", "and", "b", "extend_path", "in", "data", "declare_namespace", "b", "pkg_resources", "in", "data", "and", "b", "declare_namespace", "__name__", "in", "data", "return", "extend_path", "or", "declare_namespace"], "doc_len": 54}
{"doc_id": "astroid/interpreter/_import/spec.py::_cached_set_diff", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "_cached_set_diff", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef _cached_set_diff(left, right):\n    result = set(left)\n    result.difference_update(right)\n    return result\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "_cached_set_diff", "left", "right", "result", "set", "left", "result", "difference_update", "right", "return", "result"], "doc_len": 17}
{"doc_id": "astroid/interpreter/_import/spec.py::_precache_zipimporters", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "_precache_zipimporters", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef _precache_zipimporters(path=None):\n    \"\"\"\n    For each path that has not been already cached\n    in the sys.path_importer_cache, create a new zipimporter\n    instance and add it into the cache.\n    Return a dict associating all paths, stored in the cache, to corresponding\n    zipimporter instances.\n\n    :param path: paths that has to be added into the cache\n    :return: association between paths stored in the cache and zipimporter instances\n    \"\"\"\n    pic = sys.path_importer_cache\n\n    # When measured, despite having the same complexity (O(n)),\n    # converting to tuples and then caching the conversion to sets\n    # and the set difference is faster than converting to sets\n    # and then only caching the set difference.\n\n    req_paths = tuple(path or sys.path)\n    cached_paths = tuple(pic)\n    new_paths = _cached_set_diff(req_paths, cached_paths)\n    # pylint: disable=no-member\n    for entry_path in new_paths:\n        try:\n            pic[entry_path] = zipimport.zipimporter(entry_path)\n        except zipimport.ZipImportError:\n            continue\n    return {\n        key: value\n        for key, value in pic.items()\n        if isinstance(value, zipimport.zipimporter)\n    }\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "_precache_zipimporters", "path", "none", "for", "each", "path", "that", "has", "not", "been", "already", "cached", "in", "the", "sys", "path_importer_cache", "create", "a", "new", "zipimporter", "instance", "and", "add", "it", "into", "the", "cache", "return", "a", "dict", "associating", "all", "paths", "stored", "in", "the", "cache", "to", "corresponding", "zipimporter", "instances", "param", "path", "paths", "that", "has", "to", "be", "added", "into", "the", "cache", "return", "association", "between", "paths", "stored", "in", "the", "cache", "and", "zipimporter", "instances", "pic", "sys", "path_importer_cache", "when", "measured", "despite", "having", "the", "same", "complexity", "o", "n", "converting", "to", "tuples", "and", "then", "caching", "the", "conversion", "to", "sets", "and", "the", "set", "difference", "is", "faster", "than", "converting", "to", "sets", "and", "then", "only", "caching", "the", "set", "difference", "req_paths", "tuple", "path", "or", "sys", "path", "cached_paths", "tuple", "pic", "new_paths", "_cached_set_diff", "req_paths", "cached_paths", "pylint", "disable", "no", "member", "for", "entry_path", "in", "new_paths", "try", "pic", "entry_path", "zipimport", "zipimporter", "entry_path", "except", "zipimport", "zipimporterror", "continue", "return", "key", "value", "for", "key", "value", "in", "pic", "items", "if", "isinstance", "value", "zipimport", "zipimporter"], "doc_len": 153}
{"doc_id": "astroid/interpreter/_import/spec.py::_search_zip", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "_search_zip", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef _search_zip(modpath, pic):\n    for filepath, importer in list(pic.items()):\n        if importer is not None:\n            found = importer.find_module(modpath[0])\n            if found:\n                if not importer.find_module(os.path.sep.join(modpath)):\n                    raise ImportError(\n                        \"No module named %s in %s/%s\"\n                        % (\".\".join(modpath[1:]), filepath, modpath)\n                    )\n                # import code; code.interact(local=locals())\n                return (\n                    ModuleType.PY_ZIPMODULE,\n                    os.path.abspath(filepath) + os.path.sep + os.path.sep.join(modpath),\n                    filepath,\n                )\n    raise ImportError(f\"No module named {'.'.join(modpath)}\")\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "_search_zip", "modpath", "pic", "for", "filepath", "importer", "in", "list", "pic", "items", "if", "importer", "is", "not", "none", "found", "importer", "find_module", "modpath", "0", "if", "found", "if", "not", "importer", "find_module", "os", "path", "sep", "join", "modpath", "raise", "importerror", "no", "module", "named", "s", "in", "s", "s", "join", "modpath", "1", "filepath", "modpath", "import", "code", "code", "interact", "local", "locals", "return", "moduletype", "py_zipmodule", "os", "path", "abspath", "filepath", "os", "path", "sep", "os", "path", "sep", "join", "modpath", "filepath", "raise", "importerror", "f", "no", "module", "named", "join", "modpath"], "doc_len": 81}
{"doc_id": "astroid/interpreter/_import/spec.py::_find_spec_with_path", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "_find_spec_with_path", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef _find_spec_with_path(search_path, modname, module_parts, processed, submodule_path):\n    finders = [finder(search_path) for finder in _SPEC_FINDERS]\n    for finder in finders:\n        spec = finder.find_module(modname, module_parts, processed, submodule_path)\n        if spec is None:\n            continue\n        return finder, spec\n\n    raise ImportError(f\"No module named {'.'.join(module_parts)}\")\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "_find_spec_with_path", "search_path", "modname", "module_parts", "processed", "submodule_path", "finders", "finder", "search_path", "for", "finder", "in", "_spec_finders", "for", "finder", "in", "finders", "spec", "finder", "find_module", "modname", "module_parts", "processed", "submodule_path", "if", "spec", "is", "none", "continue", "return", "finder", "spec", "raise", "importerror", "f", "no", "module", "named", "join", "module_parts"], "doc_len": 46}
{"doc_id": "astroid/interpreter/_import/spec.py::find_spec", "file_path": "astroid/interpreter/_import/spec.py", "class_name": null, "func_name": "find_spec", "text": "文件路径: astroid/interpreter/_import/spec.py\ndef find_spec(modpath, path=None):\n    \"\"\"Find a spec for the given module.\n\n    :type modpath: list or tuple\n    :param modpath:\n      split module's name (i.e name of a module or package split\n      on '.'), with leading empty strings for explicit relative import\n\n    :type path: list or None\n    :param path:\n      optional list of path where the module or package should be\n      searched (use sys.path if nothing or None is given)\n\n    :rtype: ModuleSpec\n    :return: A module spec, which describes how the module was\n             found and where.\n    \"\"\"\n    _path = path or sys.path\n\n    # Need a copy for not mutating the argument.\n    modpath = modpath[:]\n\n    submodule_path = None\n    module_parts = modpath[:]\n    processed = []\n\n    while modpath:\n        modname = modpath.pop(0)\n        finder, spec = _find_spec_with_path(\n            _path, modname, module_parts, processed, submodule_path or path\n        )\n        processed.append(modname)\n        if modpath:\n            submodule_path = finder.contribute_to_path(spec, processed)\n\n        if spec.type == ModuleType.PKG_DIRECTORY:\n            spec = spec._replace(submodule_search_locations=submodule_path)\n\n    return spec\n", "tokens": ["astroid", "interpreter", "_import", "spec", "py", "def", "find_spec", "modpath", "path", "none", "find", "a", "spec", "for", "the", "given", "module", "type", "modpath", "list", "or", "tuple", "param", "modpath", "split", "module", "s", "name", "i", "e", "name", "of", "a", "module", "or", "package", "split", "on", "with", "leading", "empty", "strings", "for", "explicit", "relative", "import", "type", "path", "list", "or", "none", "param", "path", "optional", "list", "of", "path", "where", "the", "module", "or", "package", "should", "be", "searched", "use", "sys", "path", "if", "nothing", "or", "none", "is", "given", "rtype", "modulespec", "return", "a", "module", "spec", "which", "describes", "how", "the", "module", "was", "found", "and", "where", "_path", "path", "or", "sys", "path", "need", "a", "copy", "for", "not", "mutating", "the", "argument", "modpath", "modpath", "submodule_path", "none", "module_parts", "modpath", "processed", "while", "modpath", "modname", "modpath", "pop", "0", "finder", "spec", "_find_spec_with_path", "_path", "modname", "module_parts", "processed", "submodule_path", "or", "path", "processed", "append", "modname", "if", "modpath", "submodule_path", "finder", "contribute_to_path", "spec", "processed", "if", "spec", "type", "moduletype", "pkg_directory", "spec", "spec", "_replace", "submodule_search_locations", "submodule_path", "return", "spec"], "doc_len": 147}
{"doc_id": "astroid/interpreter/_import/util.py::is_namespace", "file_path": "astroid/interpreter/_import/util.py", "class_name": null, "func_name": "is_namespace", "text": "文件路径: astroid/interpreter/_import/util.py\ndef is_namespace(modname):\n    return (\n        pkg_resources is not None\n        and hasattr(pkg_resources, \"_namespace_packages\")\n        and modname in pkg_resources._namespace_packages\n    )\n", "tokens": ["astroid", "interpreter", "_import", "util", "py", "def", "is_namespace", "modname", "return", "pkg_resources", "is", "not", "none", "and", "hasattr", "pkg_resources", "_namespace_packages", "and", "modname", "in", "pkg_resources", "_namespace_packages"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.__init__", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "__init__", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def __init__(self, indent=\"    \"):\n        self.indent = indent\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "__init__", "self", "indent", "self", "indent", "indent"], "doc_len": 12}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.__call__", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "__call__", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def __call__(self, node):\n        \"\"\"Makes this visitor behave as a simple function\"\"\"\n        return node.accept(self).replace(DOC_NEWLINE, \"\\n\")\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "__call__", "self", "node", "makes", "this", "visitor", "behave", "as", "a", "simple", "function", "return", "node", "accept", "self", "replace", "doc_newline", "n"], "doc_len": 24}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor._docs_dedent", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "_docs_dedent", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def _docs_dedent(self, doc):\n        \"\"\"Stop newlines in docs being indented by self._stmt_list\"\"\"\n        return '\\n{}\"\"\"{}\"\"\"'.format(self.indent, doc.replace(\"\\n\", DOC_NEWLINE))\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "_docs_dedent", "self", "doc", "stop", "newlines", "in", "docs", "being", "indented", "by", "self", "_stmt_list", "return", "n", "format", "self", "indent", "doc", "replace", "n", "doc_newline"], "doc_len": 27}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor._stmt_list", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "_stmt_list", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def _stmt_list(self, stmts, indent=True):\n        \"\"\"return a list of nodes to string\"\"\"\n        stmts = \"\\n\".join(nstr for nstr in [n.accept(self) for n in stmts] if nstr)\n        if indent:\n            return self.indent + stmts.replace(\"\\n\", \"\\n\" + self.indent)\n\n        return stmts\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "_stmt_list", "self", "stmts", "indent", "true", "return", "a", "list", "of", "nodes", "to", "string", "stmts", "n", "join", "nstr", "for", "nstr", "in", "n", "accept", "self", "for", "n", "in", "stmts", "if", "nstr", "if", "indent", "return", "self", "indent", "stmts", "replace", "n", "n", "self", "indent", "return", "stmts"], "doc_len": 47}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor._precedence_parens", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "_precedence_parens", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def _precedence_parens(self, node, child, is_left=True):\n        \"\"\"Wrap child in parens only if required to keep same semantics\"\"\"\n        if self._should_wrap(node, child, is_left):\n            return f\"({child.accept(self)})\"\n\n        return child.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "_precedence_parens", "self", "node", "child", "is_left", "true", "wrap", "child", "in", "parens", "only", "if", "required", "to", "keep", "same", "semantics", "if", "self", "_should_wrap", "node", "child", "is_left", "return", "f", "child", "accept", "self", "return", "child", "accept", "self"], "doc_len": 38}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor._should_wrap", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "_should_wrap", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def _should_wrap(self, node, child, is_left):\n        \"\"\"Wrap child if:\n        - it has lower precedence\n        - same precedence with position opposite to associativity direction\n        \"\"\"\n        node_precedence = node.op_precedence()\n        child_precedence = child.op_precedence()\n\n        if node_precedence > child_precedence:\n            # 3 * (4 + 5)\n            return True\n\n        if (\n            node_precedence == child_precedence\n            and is_left != node.op_left_associative()\n        ):\n            # 3 - (4 - 5)\n            # (2**3)**4\n            return True\n\n        return False\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "_should_wrap", "self", "node", "child", "is_left", "wrap", "child", "if", "it", "has", "lower", "precedence", "same", "precedence", "with", "position", "opposite", "to", "associativity", "direction", "node_precedence", "node", "op_precedence", "child_precedence", "child", "op_precedence", "if", "node_precedence", "child_precedence", "3", "4", "5", "return", "true", "if", "node_precedence", "child_precedence", "and", "is_left", "node", "op_left_associative", "3", "4", "5", "2", "3", "4", "return", "true", "return", "false"], "doc_len": 57}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_await", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_await", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_await(self, node):\n        return f\"await {node.value.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_await", "self", "node", "return", "f", "await", "node", "value", "accept", "self"], "doc_len": 16}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_asyncwith", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_asyncwith", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_asyncwith(self, node):\n        return f\"async {self.visit_with(node)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_asyncwith", "self", "node", "return", "f", "async", "self", "visit_with", "node"], "doc_len": 15}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_asyncfor", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_asyncfor", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_asyncfor(self, node):\n        return f\"async {self.visit_for(node)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_asyncfor", "self", "node", "return", "f", "async", "self", "visit_for", "node"], "doc_len": 15}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_arguments", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_arguments", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_arguments(self, node):\n        \"\"\"return an astroid.Function node as string\"\"\"\n        return node.format_args()\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_arguments", "self", "node", "return", "an", "astroid", "function", "node", "as", "string", "return", "node", "format_args"], "doc_len": 19}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_assignattr", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_assignattr", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_assignattr(self, node):\n        \"\"\"return an astroid.AssAttr node as string\"\"\"\n        return self.visit_attribute(node)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_assignattr", "self", "node", "return", "an", "astroid", "assattr", "node", "as", "string", "return", "self", "visit_attribute", "node"], "doc_len": 20}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_assert", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_assert", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_assert(self, node):\n        \"\"\"return an astroid.Assert node as string\"\"\"\n        if node.fail:\n            return f\"assert {node.test.accept(self)}, {node.fail.accept(self)}\"\n        return f\"assert {node.test.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_assert", "self", "node", "return", "an", "astroid", "assert", "node", "as", "string", "if", "node", "fail", "return", "f", "assert", "node", "test", "accept", "self", "node", "fail", "accept", "self", "return", "f", "assert", "node", "test", "accept", "self"], "doc_len": 37}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_assignname", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_assignname", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_assignname(self, node):\n        \"\"\"return an astroid.AssName node as string\"\"\"\n        return node.name\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_assignname", "self", "node", "return", "an", "astroid", "assname", "node", "as", "string", "return", "node", "name"], "doc_len": 19}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_assign", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_assign", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_assign(self, node):\n        \"\"\"return an astroid.Assign node as string\"\"\"\n        lhs = \" = \".join(n.accept(self) for n in node.targets)\n        return f\"{lhs} = {node.value.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_assign", "self", "node", "return", "an", "astroid", "assign", "node", "as", "string", "lhs", "join", "n", "accept", "self", "for", "n", "in", "node", "targets", "return", "f", "lhs", "node", "value", "accept", "self"], "doc_len": 33}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_augassign", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_augassign", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_augassign(self, node):\n        \"\"\"return an astroid.AugAssign node as string\"\"\"\n        return f\"{node.target.accept(self)} {node.op} {node.value.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_augassign", "self", "node", "return", "an", "astroid", "augassign", "node", "as", "string", "return", "f", "node", "target", "accept", "self", "node", "op", "node", "value", "accept", "self"], "doc_len": 28}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_annassign", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_annassign", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_annassign(self, node):\n        \"\"\"Return an astroid.AugAssign node as string\"\"\"\n\n        target = node.target.accept(self)\n        annotation = node.annotation.accept(self)\n        if node.value is None:\n            return f\"{target}: {annotation}\"\n        return f\"{target}: {annotation} = {node.value.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_annassign", "self", "node", "return", "an", "astroid", "augassign", "node", "as", "string", "target", "node", "target", "accept", "self", "annotation", "node", "annotation", "accept", "self", "if", "node", "value", "is", "none", "return", "f", "target", "annotation", "return", "f", "target", "annotation", "node", "value", "accept", "self"], "doc_len": 43}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_binop", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_binop", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_binop(self, node):\n        \"\"\"return an astroid.BinOp node as string\"\"\"\n        left = self._precedence_parens(node, node.left)\n        right = self._precedence_parens(node, node.right, is_left=False)\n        if node.op == \"**\":\n            return f\"{left}{node.op}{right}\"\n\n        return f\"{left} {node.op} {right}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_binop", "self", "node", "return", "an", "astroid", "binop", "node", "as", "string", "left", "self", "_precedence_parens", "node", "node", "left", "right", "self", "_precedence_parens", "node", "node", "right", "is_left", "false", "if", "node", "op", "return", "f", "left", "node", "op", "right", "return", "f", "left", "node", "op", "right"], "doc_len": 45}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_boolop", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_boolop", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_boolop(self, node):\n        \"\"\"return an astroid.BoolOp node as string\"\"\"\n        values = [f\"{self._precedence_parens(node, n)}\" for n in node.values]\n        return (f\" {node.op} \").join(values)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_boolop", "self", "node", "return", "an", "astroid", "boolop", "node", "as", "string", "values", "f", "self", "_precedence_parens", "node", "n", "for", "n", "in", "node", "values", "return", "f", "node", "op", "join", "values"], "doc_len": 33}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_break", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_break", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_break(self, node):\n        \"\"\"return an astroid.Break node as string\"\"\"\n        return \"break\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_break", "self", "node", "return", "an", "astroid", "break", "node", "as", "string", "return", "break"], "doc_len": 18}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_call", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_call", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_call(self, node):\n        \"\"\"return an astroid.Call node as string\"\"\"\n        expr_str = self._precedence_parens(node, node.func)\n        args = [arg.accept(self) for arg in node.args]\n        if node.keywords:\n            keywords = [kwarg.accept(self) for kwarg in node.keywords]\n        else:\n            keywords = []\n\n        args.extend(keywords)\n        return f\"{expr_str}({', '.join(args)})\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_call", "self", "node", "return", "an", "astroid", "call", "node", "as", "string", "expr_str", "self", "_precedence_parens", "node", "node", "func", "args", "arg", "accept", "self", "for", "arg", "in", "node", "args", "if", "node", "keywords", "keywords", "kwarg", "accept", "self", "for", "kwarg", "in", "node", "keywords", "else", "keywords", "args", "extend", "keywords", "return", "f", "expr_str", "join", "args"], "doc_len": 53}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_classdef", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_classdef", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_classdef(self, node):\n        \"\"\"return an astroid.ClassDef node as string\"\"\"\n        decorate = node.decorators.accept(self) if node.decorators else \"\"\n        args = [n.accept(self) for n in node.bases]\n        if node._metaclass and not node.has_metaclass_hack():\n            args.append(\"metaclass=\" + node._metaclass.accept(self))\n        args += [n.accept(self) for n in node.keywords]\n        args = f\"({', '.join(args)})\" if args else \"\"\n        docs = self._docs_dedent(node.doc) if node.doc else \"\"\n        return \"\\n\\n{}class {}{}:{}\\n{}\\n\".format(\n            decorate, node.name, args, docs, self._stmt_list(node.body)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_classdef", "self", "node", "return", "an", "astroid", "classdef", "node", "as", "string", "decorate", "node", "decorators", "accept", "self", "if", "node", "decorators", "else", "args", "n", "accept", "self", "for", "n", "in", "node", "bases", "if", "node", "_metaclass", "and", "not", "node", "has_metaclass_hack", "args", "append", "metaclass", "node", "_metaclass", "accept", "self", "args", "n", "accept", "self", "for", "n", "in", "node", "keywords", "args", "f", "join", "args", "if", "args", "else", "docs", "self", "_docs_dedent", "node", "doc", "if", "node", "doc", "else", "return", "n", "n", "class", "n", "n", "format", "decorate", "node", "name", "args", "docs", "self", "_stmt_list", "node", "body"], "doc_len": 89}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_compare", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_compare", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_compare(self, node):\n        \"\"\"return an astroid.Compare node as string\"\"\"\n        rhs_str = \" \".join(\n            f\"{op} {self._precedence_parens(node, expr, is_left=False)}\"\n            for op, expr in node.ops\n        )\n        return f\"{self._precedence_parens(node, node.left)} {rhs_str}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_compare", "self", "node", "return", "an", "astroid", "compare", "node", "as", "string", "rhs_str", "join", "f", "op", "self", "_precedence_parens", "node", "expr", "is_left", "false", "for", "op", "expr", "in", "node", "ops", "return", "f", "self", "_precedence_parens", "node", "node", "left", "rhs_str"], "doc_len": 40}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_comprehension", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_comprehension", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_comprehension(self, node):\n        \"\"\"return an astroid.Comprehension node as string\"\"\"\n        ifs = \"\".join(f\" if {n.accept(self)}\" for n in node.ifs)\n        generated = f\"for {node.target.accept(self)} in {node.iter.accept(self)}{ifs}\"\n        return f\"{'async ' if node.is_async else ''}{generated}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_comprehension", "self", "node", "return", "an", "astroid", "comprehension", "node", "as", "string", "ifs", "join", "f", "if", "n", "accept", "self", "for", "n", "in", "node", "ifs", "generated", "f", "for", "node", "target", "accept", "self", "in", "node", "iter", "accept", "self", "ifs", "return", "f", "async", "if", "node", "is_async", "else", "generated"], "doc_len": 49}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_const", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_const", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_const(self, node):\n        \"\"\"return an astroid.Const node as string\"\"\"\n        if node.value is Ellipsis:\n            return \"...\"\n        return repr(node.value)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_const", "self", "node", "return", "an", "astroid", "const", "node", "as", "string", "if", "node", "value", "is", "ellipsis", "return", "return", "repr", "node", "value"], "doc_len": 26}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_continue", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_continue", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_continue(self, node):\n        \"\"\"return an astroid.Continue node as string\"\"\"\n        return \"continue\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_continue", "self", "node", "return", "an", "astroid", "continue", "node", "as", "string", "return", "continue"], "doc_len": 18}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_delete", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_delete", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_delete(self, node):  # XXX check if correct\n        \"\"\"return an astroid.Delete node as string\"\"\"\n        return f\"del {', '.join(child.accept(self) for child in node.targets)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_delete", "self", "node", "xxx", "check", "if", "correct", "return", "an", "astroid", "delete", "node", "as", "string", "return", "f", "del", "join", "child", "accept", "self", "for", "child", "in", "node", "targets"], "doc_len": 32}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_delattr", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_delattr", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_delattr(self, node):\n        \"\"\"return an astroid.DelAttr node as string\"\"\"\n        return self.visit_attribute(node)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_delattr", "self", "node", "return", "an", "astroid", "delattr", "node", "as", "string", "return", "self", "visit_attribute", "node"], "doc_len": 20}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_delname", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_delname", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_delname(self, node):\n        \"\"\"return an astroid.DelName node as string\"\"\"\n        return node.name\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_delname", "self", "node", "return", "an", "astroid", "delname", "node", "as", "string", "return", "node", "name"], "doc_len": 19}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_decorators", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_decorators", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_decorators(self, node):\n        \"\"\"return an astroid.Decorators node as string\"\"\"\n        return \"@%s\\n\" % \"\\n@\".join(item.accept(self) for item in node.nodes)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_decorators", "self", "node", "return", "an", "astroid", "decorators", "node", "as", "string", "return", "s", "n", "n", "join", "item", "accept", "self", "for", "item", "in", "node", "nodes"], "doc_len": 29}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_dict", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_dict", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_dict(self, node):\n        \"\"\"return an astroid.Dict node as string\"\"\"\n        return \"{%s}\" % \", \".join(self._visit_dict(node))\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_dict", "self", "node", "return", "an", "astroid", "dict", "node", "as", "string", "return", "s", "join", "self", "_visit_dict", "node"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor._visit_dict", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "_visit_dict", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def _visit_dict(self, node):\n        for key, value in node.items:\n            key = key.accept(self)\n            value = value.accept(self)\n            if key == \"**\":\n                # It can only be a DictUnpack node.\n                yield key + value\n            else:\n                yield f\"{key}: {value}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "_visit_dict", "self", "node", "for", "key", "value", "in", "node", "items", "key", "key", "accept", "self", "value", "value", "accept", "self", "if", "key", "it", "can", "only", "be", "a", "dictunpack", "node", "yield", "key", "value", "else", "yield", "f", "key", "value"], "doc_len": 40}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_dictunpack", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_dictunpack", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_dictunpack(self, node):\n        return \"**\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_dictunpack", "self", "node", "return"], "doc_len": 10}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_dictcomp", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_dictcomp", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_dictcomp(self, node):\n        \"\"\"return an astroid.DictComp node as string\"\"\"\n        return \"{{{}: {} {}}}\".format(\n            node.key.accept(self),\n            node.value.accept(self),\n            \" \".join(n.accept(self) for n in node.generators),\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_dictcomp", "self", "node", "return", "an", "astroid", "dictcomp", "node", "as", "string", "return", "format", "node", "key", "accept", "self", "node", "value", "accept", "self", "join", "n", "accept", "self", "for", "n", "in", "node", "generators"], "doc_len": 35}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_expr", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_expr", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_expr(self, node):\n        \"\"\"return an astroid.Discard node as string\"\"\"\n        return node.value.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_expr", "self", "node", "return", "an", "astroid", "discard", "node", "as", "string", "return", "node", "value", "accept", "self"], "doc_len": 21}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_emptynode", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_emptynode", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_emptynode(self, node):\n        \"\"\"dummy method for visiting an Empty node\"\"\"\n        return \"\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_emptynode", "self", "node", "dummy", "method", "for", "visiting", "an", "empty", "node", "return"], "doc_len": 17}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_excepthandler", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_excepthandler", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_excepthandler(self, node):\n        if node.type:\n            if node.name:\n                excs = f\"except {node.type.accept(self)} as {node.name.accept(self)}\"\n            else:\n                excs = f\"except {node.type.accept(self)}\"\n        else:\n            excs = \"except\"\n        return f\"{excs}:\\n{self._stmt_list(node.body)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_excepthandler", "self", "node", "if", "node", "type", "if", "node", "name", "excs", "f", "except", "node", "type", "accept", "self", "as", "node", "name", "accept", "self", "else", "excs", "f", "except", "node", "type", "accept", "self", "else", "excs", "except", "return", "f", "excs", "n", "self", "_stmt_list", "node", "body"], "doc_len": 46}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_empty", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_empty", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_empty(self, node):\n        \"\"\"return an Empty node as string\"\"\"\n        return \"\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_empty", "self", "node", "return", "an", "empty", "node", "as", "string", "return"], "doc_len": 16}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_for", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_for", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_for(self, node):\n        \"\"\"return an astroid.For node as string\"\"\"\n        fors = \"for {} in {}:\\n{}\".format(\n            node.target.accept(self), node.iter.accept(self), self._stmt_list(node.body)\n        )\n        if node.orelse:\n            fors = f\"{fors}\\nelse:\\n{self._stmt_list(node.orelse)}\"\n        return fors\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_for", "self", "node", "return", "an", "astroid", "for", "node", "as", "string", "fors", "for", "in", "n", "format", "node", "target", "accept", "self", "node", "iter", "accept", "self", "self", "_stmt_list", "node", "body", "if", "node", "orelse", "fors", "f", "fors", "nelse", "n", "self", "_stmt_list", "node", "orelse", "return", "fors"], "doc_len": 47}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_importfrom", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_importfrom", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_importfrom(self, node):\n        \"\"\"return an astroid.ImportFrom node as string\"\"\"\n        return \"from {} import {}\".format(\n            \".\" * (node.level or 0) + node.modname, _import_string(node.names)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_importfrom", "self", "node", "return", "an", "astroid", "importfrom", "node", "as", "string", "return", "from", "import", "format", "node", "level", "or", "0", "node", "modname", "_import_string", "node", "names"], "doc_len": 29}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_joinedstr", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_joinedstr", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_joinedstr(self, node):\n        string = \"\".join(\n            # Use repr on the string literal parts\n            # to get proper escapes, e.g. \\n, \\\\, \\\"\n            # But strip the quotes off the ends\n            # (they will always be one character: ' or \")\n            repr(value.value)[1:-1]\n            # Literal braces must be doubled to escape them\n            .replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n            # Each value in values is either a string literal (Const)\n            # or a FormattedValue\n            if type(value).__name__ == \"Const\" else value.accept(self)\n            for value in node.values\n        )\n\n        # Try to find surrounding quotes that don't appear at all in the string.\n        # Because the formatted values inside {} can't contain backslash (\\)\n        # using a triple quote is sometimes necessary\n        for quote in (\"'\", '\"', '\"\"\"', \"'''\"):\n            if quote not in string:\n                break\n\n        return \"f\" + quote + string + quote\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_joinedstr", "self", "node", "string", "join", "use", "repr", "on", "the", "string", "literal", "parts", "to", "get", "proper", "escapes", "e", "g", "n", "but", "strip", "the", "quotes", "off", "the", "ends", "they", "will", "always", "be", "one", "character", "or", "repr", "value", "value", "1", "1", "literal", "braces", "must", "be", "doubled", "to", "escape", "them", "replace", "replace", "each", "value", "in", "values", "is", "either", "a", "string", "literal", "const", "or", "a", "formattedvalue", "if", "type", "value", "__name__", "const", "else", "value", "accept", "self", "for", "value", "in", "node", "values", "try", "to", "find", "surrounding", "quotes", "that", "don", "t", "appear", "at", "all", "in", "the", "string", "because", "the", "formatted", "values", "inside", "can", "t", "contain", "backslash", "using", "a", "triple", "quote", "is", "sometimes", "necessary", "for", "quote", "in", "if", "quote", "not", "in", "string", "break", "return", "f", "quote", "string", "quote"], "doc_len": 125}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_formattedvalue", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_formattedvalue", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_formattedvalue(self, node):\n        result = node.value.accept(self)\n        if node.conversion and node.conversion >= 0:\n            # e.g. if node.conversion == 114: result += \"!r\"\n            result += \"!\" + chr(node.conversion)\n        if node.format_spec:\n            # The format spec is itself a JoinedString, i.e. an f-string\n            # We strip the f and quotes of the ends\n            result += \":\" + node.format_spec.accept(self)[2:-1]\n        return \"{%s}\" % result\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_formattedvalue", "self", "node", "result", "node", "value", "accept", "self", "if", "node", "conversion", "and", "node", "conversion", "0", "e", "g", "if", "node", "conversion", "114", "result", "r", "result", "chr", "node", "conversion", "if", "node", "format_spec", "the", "format", "spec", "is", "itself", "a", "joinedstring", "i", "e", "an", "f", "string", "we", "strip", "the", "f", "and", "quotes", "of", "the", "ends", "result", "node", "format_spec", "accept", "self", "2", "1", "return", "s", "result"], "doc_len": 67}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.handle_functiondef", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "handle_functiondef", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def handle_functiondef(self, node, keyword):\n        \"\"\"return a (possibly async) function definition node as string\"\"\"\n        decorate = node.decorators.accept(self) if node.decorators else \"\"\n        docs = self._docs_dedent(node.doc) if node.doc else \"\"\n        trailer = \":\"\n        if node.returns:\n            return_annotation = \" -> \" + node.returns.as_string()\n            trailer = return_annotation + \":\"\n        def_format = \"\\n%s%s %s(%s)%s%s\\n%s\"\n        return def_format % (\n            decorate,\n            keyword,\n            node.name,\n            node.args.accept(self),\n            trailer,\n            docs,\n            self._stmt_list(node.body),\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "handle_functiondef", "self", "node", "keyword", "return", "a", "possibly", "async", "function", "definition", "node", "as", "string", "decorate", "node", "decorators", "accept", "self", "if", "node", "decorators", "else", "docs", "self", "_docs_dedent", "node", "doc", "if", "node", "doc", "else", "trailer", "if", "node", "returns", "return_annotation", "node", "returns", "as_string", "trailer", "return_annotation", "def_format", "n", "s", "s", "s", "s", "s", "s", "n", "s", "return", "def_format", "decorate", "keyword", "node", "name", "node", "args", "accept", "self", "trailer", "docs", "self", "_stmt_list", "node", "body"], "doc_len": 73}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_functiondef", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_functiondef", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_functiondef(self, node):\n        \"\"\"return an astroid.FunctionDef node as string\"\"\"\n        return self.handle_functiondef(node, \"def\")\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_functiondef", "self", "node", "return", "an", "astroid", "functiondef", "node", "as", "string", "return", "self", "handle_functiondef", "node", "def"], "doc_len": 21}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_asyncfunctiondef", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_asyncfunctiondef", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_asyncfunctiondef(self, node):\n        \"\"\"return an astroid.AsyncFunction node as string\"\"\"\n        return self.handle_functiondef(node, \"async def\")\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_asyncfunctiondef", "self", "node", "return", "an", "astroid", "asyncfunction", "node", "as", "string", "return", "self", "handle_functiondef", "node", "async", "def"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_generatorexp", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_generatorexp", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_generatorexp(self, node):\n        \"\"\"return an astroid.GeneratorExp node as string\"\"\"\n        return \"({} {})\".format(\n            node.elt.accept(self), \" \".join(n.accept(self) for n in node.generators)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_generatorexp", "self", "node", "return", "an", "astroid", "generatorexp", "node", "as", "string", "return", "format", "node", "elt", "accept", "self", "join", "n", "accept", "self", "for", "n", "in", "node", "generators"], "doc_len": 31}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_attribute", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_attribute", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_attribute(self, node):\n        \"\"\"return an astroid.Getattr node as string\"\"\"\n        left = self._precedence_parens(node, node.expr)\n        if left.isdigit():\n            left = f\"({left})\"\n        return f\"{left}.{node.attrname}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_attribute", "self", "node", "return", "an", "astroid", "getattr", "node", "as", "string", "left", "self", "_precedence_parens", "node", "node", "expr", "if", "left", "isdigit", "left", "f", "left", "return", "f", "left", "node", "attrname"], "doc_len": 33}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_global", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_global", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_global(self, node):\n        \"\"\"return an astroid.Global node as string\"\"\"\n        return f\"global {', '.join(node.names)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_global", "self", "node", "return", "an", "astroid", "global", "node", "as", "string", "return", "f", "global", "join", "node", "names"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_if", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_if", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_if(self, node):\n        \"\"\"return an astroid.If node as string\"\"\"\n        ifs = [f\"if {node.test.accept(self)}:\\n{self._stmt_list(node.body)}\"]\n        if node.has_elif_block():\n            ifs.append(f\"el{self._stmt_list(node.orelse, indent=False)}\")\n        elif node.orelse:\n            ifs.append(f\"else:\\n{self._stmt_list(node.orelse)}\")\n        return \"\\n\".join(ifs)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_if", "self", "node", "return", "an", "astroid", "if", "node", "as", "string", "ifs", "f", "if", "node", "test", "accept", "self", "n", "self", "_stmt_list", "node", "body", "if", "node", "has_elif_block", "ifs", "append", "f", "el", "self", "_stmt_list", "node", "orelse", "indent", "false", "elif", "node", "orelse", "ifs", "append", "f", "else", "n", "self", "_stmt_list", "node", "orelse", "return", "n", "join", "ifs"], "doc_len": 57}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_ifexp", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_ifexp", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_ifexp(self, node):\n        \"\"\"return an astroid.IfExp node as string\"\"\"\n        return \"{} if {} else {}\".format(\n            self._precedence_parens(node, node.body, is_left=True),\n            self._precedence_parens(node, node.test, is_left=True),\n            self._precedence_parens(node, node.orelse, is_left=False),\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_ifexp", "self", "node", "return", "an", "astroid", "ifexp", "node", "as", "string", "return", "if", "else", "format", "self", "_precedence_parens", "node", "node", "body", "is_left", "true", "self", "_precedence_parens", "node", "node", "test", "is_left", "true", "self", "_precedence_parens", "node", "node", "orelse", "is_left", "false"], "doc_len": 41}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_import", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_import", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_import(self, node):\n        \"\"\"return an astroid.Import node as string\"\"\"\n        return f\"import {_import_string(node.names)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_import", "self", "node", "return", "an", "astroid", "import", "node", "as", "string", "return", "f", "import", "_import_string", "node", "names"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_keyword", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_keyword", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_keyword(self, node):\n        \"\"\"return an astroid.Keyword node as string\"\"\"\n        if node.arg is None:\n            return f\"**{node.value.accept(self)}\"\n        return f\"{node.arg}={node.value.accept(self)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_keyword", "self", "node", "return", "an", "astroid", "keyword", "node", "as", "string", "if", "node", "arg", "is", "none", "return", "f", "node", "value", "accept", "self", "return", "f", "node", "arg", "node", "value", "accept", "self"], "doc_len": 35}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_lambda", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_lambda", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_lambda(self, node):\n        \"\"\"return an astroid.Lambda node as string\"\"\"\n        args = node.args.accept(self)\n        body = node.body.accept(self)\n        if args:\n            return f\"lambda {args}: {body}\"\n\n        return f\"lambda: {body}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_lambda", "self", "node", "return", "an", "astroid", "lambda", "node", "as", "string", "args", "node", "args", "accept", "self", "body", "node", "body", "accept", "self", "if", "args", "return", "f", "lambda", "args", "body", "return", "f", "lambda", "body"], "doc_len": 37}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_list", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_list", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_list(self, node):\n        \"\"\"return an astroid.List node as string\"\"\"\n        return f\"[{', '.join(child.accept(self) for child in node.elts)}]\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_list", "self", "node", "return", "an", "astroid", "list", "node", "as", "string", "return", "f", "join", "child", "accept", "self", "for", "child", "in", "node", "elts"], "doc_len": 27}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_listcomp", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_listcomp", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_listcomp(self, node):\n        \"\"\"return an astroid.ListComp node as string\"\"\"\n        return \"[{} {}]\".format(\n            node.elt.accept(self), \" \".join(n.accept(self) for n in node.generators)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_listcomp", "self", "node", "return", "an", "astroid", "listcomp", "node", "as", "string", "return", "format", "node", "elt", "accept", "self", "join", "n", "accept", "self", "for", "n", "in", "node", "generators"], "doc_len": 31}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_module", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_module", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_module(self, node):\n        \"\"\"return an astroid.Module node as string\"\"\"\n        docs = f'\"\"\"{node.doc}\"\"\"\\n\\n' if node.doc else \"\"\n        return docs + \"\\n\".join(n.accept(self) for n in node.body) + \"\\n\\n\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_module", "self", "node", "return", "an", "astroid", "module", "node", "as", "string", "docs", "f", "node", "doc", "n", "n", "if", "node", "doc", "else", "return", "docs", "n", "join", "n", "accept", "self", "for", "n", "in", "node", "body", "n", "n"], "doc_len": 40}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_name", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_name", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_name(self, node):\n        \"\"\"return an astroid.Name node as string\"\"\"\n        return node.name\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_name", "self", "node", "return", "an", "astroid", "name", "node", "as", "string", "return", "node", "name"], "doc_len": 19}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_namedexpr", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_namedexpr", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_namedexpr(self, node):\n        \"\"\"Return an assignment expression node as string\"\"\"\n        target = node.target.accept(self)\n        value = node.value.accept(self)\n        return f\"{target} := {value}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_namedexpr", "self", "node", "return", "an", "assignment", "expression", "node", "as", "string", "target", "node", "target", "accept", "self", "value", "node", "value", "accept", "self", "return", "f", "target", "value"], "doc_len": 30}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_nonlocal", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_nonlocal", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_nonlocal(self, node):\n        \"\"\"return an astroid.Nonlocal node as string\"\"\"\n        return f\"nonlocal {', '.join(node.names)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_nonlocal", "self", "node", "return", "an", "astroid", "nonlocal", "node", "as", "string", "return", "f", "nonlocal", "join", "node", "names"], "doc_len": 22}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_pass", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_pass", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_pass(self, node):\n        \"\"\"return an astroid.Pass node as string\"\"\"\n        return \"pass\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_pass", "self", "node", "return", "an", "astroid", "pass", "node", "as", "string", "return", "pass"], "doc_len": 18}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_raise", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_raise", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_raise(self, node):\n        \"\"\"return an astroid.Raise node as string\"\"\"\n        if node.exc:\n            if node.cause:\n                return f\"raise {node.exc.accept(self)} from {node.cause.accept(self)}\"\n            return f\"raise {node.exc.accept(self)}\"\n        return \"raise\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_raise", "self", "node", "return", "an", "astroid", "raise", "node", "as", "string", "if", "node", "exc", "if", "node", "cause", "return", "f", "raise", "node", "exc", "accept", "self", "from", "node", "cause", "accept", "self", "return", "f", "raise", "node", "exc", "accept", "self", "return", "raise"], "doc_len": 43}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_return", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_return", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_return(self, node):\n        \"\"\"return an astroid.Return node as string\"\"\"\n        if node.is_tuple_return() and len(node.value.elts) > 1:\n            elts = [child.accept(self) for child in node.value.elts]\n            return f\"return {', '.join(elts)}\"\n\n        if node.value:\n            return f\"return {node.value.accept(self)}\"\n\n        return \"return\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_return", "self", "node", "return", "an", "astroid", "return", "node", "as", "string", "if", "node", "is_tuple_return", "and", "len", "node", "value", "elts", "1", "elts", "child", "accept", "self", "for", "child", "in", "node", "value", "elts", "return", "f", "return", "join", "elts", "if", "node", "value", "return", "f", "return", "node", "value", "accept", "self", "return", "return"], "doc_len": 52}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_set", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_set", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_set(self, node):\n        \"\"\"return an astroid.Set node as string\"\"\"\n        return \"{%s}\" % \", \".join(child.accept(self) for child in node.elts)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_set", "self", "node", "return", "an", "astroid", "set", "node", "as", "string", "return", "s", "join", "child", "accept", "self", "for", "child", "in", "node", "elts"], "doc_len": 27}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_setcomp", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_setcomp", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_setcomp(self, node):\n        \"\"\"return an astroid.SetComp node as string\"\"\"\n        return \"{{{} {}}}\".format(\n            node.elt.accept(self), \" \".join(n.accept(self) for n in node.generators)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_setcomp", "self", "node", "return", "an", "astroid", "setcomp", "node", "as", "string", "return", "format", "node", "elt", "accept", "self", "join", "n", "accept", "self", "for", "n", "in", "node", "generators"], "doc_len": 31}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_slice", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_slice", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_slice(self, node):\n        \"\"\"return an astroid.Slice node as string\"\"\"\n        lower = node.lower.accept(self) if node.lower else \"\"\n        upper = node.upper.accept(self) if node.upper else \"\"\n        step = node.step.accept(self) if node.step else \"\"\n        if step:\n            return f\"{lower}:{upper}:{step}\"\n        return f\"{lower}:{upper}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_slice", "self", "node", "return", "an", "astroid", "slice", "node", "as", "string", "lower", "node", "lower", "accept", "self", "if", "node", "lower", "else", "upper", "node", "upper", "accept", "self", "if", "node", "upper", "else", "step", "node", "step", "accept", "self", "if", "node", "step", "else", "if", "step", "return", "f", "lower", "upper", "step", "return", "f", "lower", "upper"], "doc_len": 54}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_subscript", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_subscript", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_subscript(self, node):\n        \"\"\"return an astroid.Subscript node as string\"\"\"\n        idx = node.slice\n        if idx.__class__.__name__.lower() == \"index\":\n            idx = idx.value\n        idxstr = idx.accept(self)\n        if idx.__class__.__name__.lower() == \"tuple\" and idx.elts:\n            # Remove parenthesis in tuple and extended slice.\n            # a[(::1, 1:)] is not valid syntax.\n            idxstr = idxstr[1:-1]\n        return f\"{self._precedence_parens(node, node.value)}[{idxstr}]\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_subscript", "self", "node", "return", "an", "astroid", "subscript", "node", "as", "string", "idx", "node", "slice", "if", "idx", "__class__", "__name__", "lower", "index", "idx", "idx", "value", "idxstr", "idx", "accept", "self", "if", "idx", "__class__", "__name__", "lower", "tuple", "and", "idx", "elts", "remove", "parenthesis", "in", "tuple", "and", "extended", "slice", "a", "1", "1", "is", "not", "valid", "syntax", "idxstr", "idxstr", "1", "1", "return", "f", "self", "_precedence_parens", "node", "node", "value", "idxstr"], "doc_len": 67}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_tryexcept", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_tryexcept", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_tryexcept(self, node):\n        \"\"\"return an astroid.TryExcept node as string\"\"\"\n        trys = [f\"try:\\n{self._stmt_list(node.body)}\"]\n        for handler in node.handlers:\n            trys.append(handler.accept(self))\n        if node.orelse:\n            trys.append(f\"else:\\n{self._stmt_list(node.orelse)}\")\n        return \"\\n\".join(trys)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_tryexcept", "self", "node", "return", "an", "astroid", "tryexcept", "node", "as", "string", "trys", "f", "try", "n", "self", "_stmt_list", "node", "body", "for", "handler", "in", "node", "handlers", "trys", "append", "handler", "accept", "self", "if", "node", "orelse", "trys", "append", "f", "else", "n", "self", "_stmt_list", "node", "orelse", "return", "n", "join", "trys"], "doc_len": 50}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_tryfinally", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_tryfinally", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_tryfinally(self, node):\n        \"\"\"return an astroid.TryFinally node as string\"\"\"\n        return \"try:\\n{}\\nfinally:\\n{}\".format(\n            self._stmt_list(node.body), self._stmt_list(node.finalbody)\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_tryfinally", "self", "node", "return", "an", "astroid", "tryfinally", "node", "as", "string", "return", "try", "n", "nfinally", "n", "format", "self", "_stmt_list", "node", "body", "self", "_stmt_list", "node", "finalbody"], "doc_len": 30}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_tuple", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_tuple", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_tuple(self, node):\n        \"\"\"return an astroid.Tuple node as string\"\"\"\n        if len(node.elts) == 1:\n            return f\"({node.elts[0].accept(self)}, )\"\n        return f\"({', '.join(child.accept(self) for child in node.elts)})\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_tuple", "self", "node", "return", "an", "astroid", "tuple", "node", "as", "string", "if", "len", "node", "elts", "1", "return", "f", "node", "elts", "0", "accept", "self", "return", "f", "join", "child", "accept", "self", "for", "child", "in", "node", "elts"], "doc_len": 39}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_unaryop", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_unaryop", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_unaryop(self, node):\n        \"\"\"return an astroid.UnaryOp node as string\"\"\"\n        if node.op == \"not\":\n            operator = \"not \"\n        else:\n            operator = node.op\n        return f\"{operator}{self._precedence_parens(node, node.operand)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_unaryop", "self", "node", "return", "an", "astroid", "unaryop", "node", "as", "string", "if", "node", "op", "not", "operator", "not", "else", "operator", "node", "op", "return", "f", "operator", "self", "_precedence_parens", "node", "node", "operand"], "doc_len": 34}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_while", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_while", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_while(self, node):\n        \"\"\"return an astroid.While node as string\"\"\"\n        whiles = f\"while {node.test.accept(self)}:\\n{self._stmt_list(node.body)}\"\n        if node.orelse:\n            whiles = f\"{whiles}\\nelse:\\n{self._stmt_list(node.orelse)}\"\n        return whiles\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_while", "self", "node", "return", "an", "astroid", "while", "node", "as", "string", "whiles", "f", "while", "node", "test", "accept", "self", "n", "self", "_stmt_list", "node", "body", "if", "node", "orelse", "whiles", "f", "whiles", "nelse", "n", "self", "_stmt_list", "node", "orelse", "return", "whiles"], "doc_len": 42}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_with", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_with", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_with(self, node):  # 'with' without 'as' is possible\n        \"\"\"return an astroid.With node as string\"\"\"\n        items = \", \".join(\n            f\"{expr.accept(self)}\" + (v and f\" as {v.accept(self)}\" or \"\")\n            for expr, v in node.items\n        )\n        return f\"with {items}:\\n{self._stmt_list(node.body)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_with", "self", "node", "with", "without", "as", "is", "possible", "return", "an", "astroid", "with", "node", "as", "string", "items", "join", "f", "expr", "accept", "self", "v", "and", "f", "as", "v", "accept", "self", "or", "for", "expr", "v", "in", "node", "items", "return", "f", "with", "items", "n", "self", "_stmt_list", "node", "body"], "doc_len": 50}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_yield", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_yield", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_yield(self, node):\n        \"\"\"yield an ast.Yield node as string\"\"\"\n        yi_val = (\" \" + node.value.accept(self)) if node.value else \"\"\n        expr = \"yield\" + yi_val\n        if node.parent.is_statement:\n            return expr\n\n        return f\"({expr})\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_yield", "self", "node", "yield", "an", "ast", "yield", "node", "as", "string", "yi_val", "node", "value", "accept", "self", "if", "node", "value", "else", "expr", "yield", "yi_val", "if", "node", "parent", "is_statement", "return", "expr", "return", "f", "expr"], "doc_len": 37}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_yieldfrom", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_yieldfrom", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_yieldfrom(self, node):\n        \"\"\"Return an astroid.YieldFrom node as string.\"\"\"\n        yi_val = (\" \" + node.value.accept(self)) if node.value else \"\"\n        expr = \"yield from\" + yi_val\n        if node.parent.is_statement:\n            return expr\n\n        return f\"({expr})\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_yieldfrom", "self", "node", "return", "an", "astroid", "yieldfrom", "node", "as", "string", "yi_val", "node", "value", "accept", "self", "if", "node", "value", "else", "expr", "yield", "from", "yi_val", "if", "node", "parent", "is_statement", "return", "expr", "return", "f", "expr"], "doc_len": 38}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_starred", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_starred", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_starred(self, node):\n        \"\"\"return Starred node as string\"\"\"\n        return \"*\" + node.value.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_starred", "self", "node", "return", "starred", "node", "as", "string", "return", "node", "value", "accept", "self"], "doc_len": 19}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_match", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_match", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_match(self, node: \"Match\") -> str:\n        \"\"\"Return an astroid.Match node as string.\"\"\"\n        return f\"match {node.subject.accept(self)}:\\n{self._stmt_list(node.cases)}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_match", "self", "node", "match", "str", "return", "an", "astroid", "match", "node", "as", "string", "return", "f", "match", "node", "subject", "accept", "self", "n", "self", "_stmt_list", "node", "cases"], "doc_len": 30}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchcase", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchcase", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchcase(self, node: \"MatchCase\") -> str:\n        \"\"\"Return an astroid.MatchCase node as string.\"\"\"\n        guard_str = f\" if {node.guard.accept(self)}\" if node.guard else \"\"\n        return (\n            f\"case {node.pattern.accept(self)}{guard_str}:\\n\"\n            f\"{self._stmt_list(node.body)}\"\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchcase", "self", "node", "matchcase", "str", "return", "an", "astroid", "matchcase", "node", "as", "string", "guard_str", "f", "if", "node", "guard", "accept", "self", "if", "node", "guard", "else", "return", "f", "case", "node", "pattern", "accept", "self", "guard_str", "n", "f", "self", "_stmt_list", "node", "body"], "doc_len": 43}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchvalue", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchvalue", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchvalue(self, node: \"MatchValue\") -> str:\n        \"\"\"Return an astroid.MatchValue node as string.\"\"\"\n        return node.value.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchvalue", "self", "node", "matchvalue", "str", "return", "an", "astroid", "matchvalue", "node", "as", "string", "return", "node", "value", "accept", "self"], "doc_len": 23}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchsingleton", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchsingleton", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchsingleton(node: \"MatchSingleton\") -> str:\n        \"\"\"Return an astroid.MatchSingleton node as string.\"\"\"\n        return str(node.value)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchsingleton", "node", "matchsingleton", "str", "return", "an", "astroid", "matchsingleton", "node", "as", "string", "return", "str", "node", "value"], "doc_len": 21}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchsequence", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchsequence", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchsequence(self, node: \"MatchSequence\") -> str:\n        \"\"\"Return an astroid.MatchSequence node as string.\"\"\"\n        if node.patterns is None:\n            return \"[]\"\n        return f\"[{', '.join(p.accept(self) for p in node.patterns)}]\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchsequence", "self", "node", "matchsequence", "str", "return", "an", "astroid", "matchsequence", "node", "as", "string", "if", "node", "patterns", "is", "none", "return", "return", "f", "join", "p", "accept", "self", "for", "p", "in", "node", "patterns"], "doc_len": 35}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchmapping", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchmapping", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchmapping(self, node: \"MatchMapping\") -> str:\n        \"\"\"Return an astroid.MatchMapping node as string.\"\"\"\n        mapping_strings: List[str] = []\n        if node.keys and node.patterns:\n            mapping_strings.extend(\n                f\"{key.accept(self)}: {p.accept(self)}\"\n                for key, p in zip(node.keys, node.patterns)\n            )\n        if node.rest:\n            mapping_strings.append(f\"**{node.rest.accept(self)}\")\n        return f\"{'{'}{', '.join(mapping_strings)}{'}'}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchmapping", "self", "node", "matchmapping", "str", "return", "an", "astroid", "matchmapping", "node", "as", "string", "mapping_strings", "list", "str", "if", "node", "keys", "and", "node", "patterns", "mapping_strings", "extend", "f", "key", "accept", "self", "p", "accept", "self", "for", "key", "p", "in", "zip", "node", "keys", "node", "patterns", "if", "node", "rest", "mapping_strings", "append", "f", "node", "rest", "accept", "self", "return", "f", "join", "mapping_strings"], "doc_len": 59}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchclass", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchclass", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchclass(self, node: \"MatchClass\") -> str:\n        \"\"\"Return an astroid.MatchClass node as string.\"\"\"\n        if node.cls is None:\n            raise Exception(f\"{node} does not have a 'cls' node\")\n        class_strings: List[str] = []\n        if node.patterns:\n            class_strings.extend(p.accept(self) for p in node.patterns)\n        if node.kwd_attrs and node.kwd_patterns:\n            for attr, pattern in zip(node.kwd_attrs, node.kwd_patterns):\n                class_strings.append(f\"{attr}={pattern.accept(self)}\")\n        return f\"{node.cls.accept(self)}({', '.join(class_strings)})\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchclass", "self", "node", "matchclass", "str", "return", "an", "astroid", "matchclass", "node", "as", "string", "if", "node", "cls", "is", "none", "raise", "exception", "f", "node", "does", "not", "have", "a", "cls", "node", "class_strings", "list", "str", "if", "node", "patterns", "class_strings", "extend", "p", "accept", "self", "for", "p", "in", "node", "patterns", "if", "node", "kwd_attrs", "and", "node", "kwd_patterns", "for", "attr", "pattern", "in", "zip", "node", "kwd_attrs", "node", "kwd_patterns", "class_strings", "append", "f", "attr", "pattern", "accept", "self", "return", "f", "node", "cls", "accept", "self", "join", "class_strings"], "doc_len": 79}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchstar", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchstar", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchstar(self, node: \"MatchStar\") -> str:\n        \"\"\"Return an astroid.MatchStar node as string.\"\"\"\n        return f\"*{node.name.accept(self) if node.name else '_'}\"\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchstar", "self", "node", "matchstar", "str", "return", "an", "astroid", "matchstar", "node", "as", "string", "return", "f", "node", "name", "accept", "self", "if", "node", "name", "else", "_"], "doc_len": 29}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchas", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchas", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchas(self, node: \"MatchAs\") -> str:\n        \"\"\"Return an astroid.MatchAs node as string.\"\"\"\n        # pylint: disable=import-outside-toplevel\n        # Prevent circular dependency\n        from astroid.nodes.node_classes import MatchClass, MatchMapping, MatchSequence\n\n        if isinstance(node.parent, (MatchSequence, MatchMapping, MatchClass)):\n            return node.name.accept(self) if node.name else \"_\"\n        return (\n            f\"{node.pattern.accept(self) if node.pattern else '_'}\"\n            f\"{f' as {node.name.accept(self)}' if node.name else ''}\"\n        )\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchas", "self", "node", "matchas", "str", "return", "an", "astroid", "matchas", "node", "as", "string", "pylint", "disable", "import", "outside", "toplevel", "prevent", "circular", "dependency", "from", "astroid", "nodes", "node_classes", "import", "matchclass", "matchmapping", "matchsequence", "if", "isinstance", "node", "parent", "matchsequence", "matchmapping", "matchclass", "return", "node", "name", "accept", "self", "if", "node", "name", "else", "_", "return", "f", "node", "pattern", "accept", "self", "if", "node", "pattern", "else", "_", "f", "f", "as", "node", "name", "accept", "self", "if", "node", "name", "else"], "doc_len": 73}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_matchor", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_matchor", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_matchor(self, node: \"MatchOr\") -> str:\n        \"\"\"Return an astroid.MatchOr node as string.\"\"\"\n        if node.patterns is None:\n            raise Exception(f\"{node} does not have pattern nodes\")\n        return \" | \".join(p.accept(self) for p in node.patterns)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_matchor", "self", "node", "matchor", "str", "return", "an", "astroid", "matchor", "node", "as", "string", "if", "node", "patterns", "is", "none", "raise", "exception", "f", "node", "does", "not", "have", "pattern", "nodes", "return", "join", "p", "accept", "self", "for", "p", "in", "node", "patterns"], "doc_len": 42}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_frozenset", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_frozenset", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_frozenset(self, node):\n        return node.parent.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_frozenset", "self", "node", "return", "node", "parent", "accept", "self"], "doc_len": 14}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_super", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_super", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_super(self, node):\n        return node.parent.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_super", "self", "node", "return", "node", "parent", "accept", "self"], "doc_len": 14}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_uninferable", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_uninferable", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_uninferable(self, node):\n        return str(node)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_uninferable", "self", "node", "return", "str", "node"], "doc_len": 12}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_property", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_property", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_property(self, node):\n        return node.function.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_property", "self", "node", "return", "node", "function", "accept", "self"], "doc_len": 14}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_evaluatedobject", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_evaluatedobject", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_evaluatedobject(self, node):\n        return node.original.accept(self)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_evaluatedobject", "self", "node", "return", "node", "original", "accept", "self"], "doc_len": 14}
{"doc_id": "astroid/nodes/as_string.py::AsStringVisitor.visit_unknown", "file_path": "astroid/nodes/as_string.py", "class_name": "AsStringVisitor", "func_name": "visit_unknown", "text": "文件路径: astroid/nodes/as_string.py, 类名: AsStringVisitor\n    def visit_unknown(self, node: \"Unknown\") -> str:\n        return str(node)\n", "tokens": ["astroid", "nodes", "as_string", "py", "asstringvisitor", "def", "visit_unknown", "self", "node", "unknown", "str", "return", "str", "node"], "doc_len": 14}
{"doc_id": "astroid/nodes/as_string.py::_import_string", "file_path": "astroid/nodes/as_string.py", "class_name": null, "func_name": "_import_string", "text": "文件路径: astroid/nodes/as_string.py\ndef _import_string(names):\n    \"\"\"return a list of (name, asname) formatted as a string\"\"\"\n    _names = []\n    for name, asname in names:\n        if asname is not None:\n            _names.append(f\"{name} as {asname}\")\n        else:\n            _names.append(name)\n    return \", \".join(_names)\n", "tokens": ["astroid", "nodes", "as_string", "py", "def", "_import_string", "names", "return", "a", "list", "of", "name", "asname", "formatted", "as", "a", "string", "_names", "for", "name", "asname", "in", "names", "if", "asname", "is", "not", "none", "_names", "append", "f", "name", "as", "asname", "else", "_names", "append", "name", "return", "join", "_names"], "doc_len": 41}
{"doc_id": "astroid/nodes/node_classes.py::_is_const", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_is_const", "text": "文件路径: astroid/nodes/node_classes.py\ndef _is_const(value):\n    return isinstance(value, tuple(CONST_CLS))\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_is_const", "value", "return", "isinstance", "value", "tuple", "const_cls"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::unpack_infer", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "unpack_infer", "text": "文件路径: astroid/nodes/node_classes.py\ndef unpack_infer(stmt, context=None):\n    \"\"\"recursively generate nodes inferred by the given statement.\n    If the inferred value is a list or a tuple, recurse on the elements\n    \"\"\"\n    if isinstance(stmt, (List, Tuple)):\n        for elt in stmt.elts:\n            if elt is util.Uninferable:\n                yield elt\n                continue\n            yield from unpack_infer(elt, context)\n        return dict(node=stmt, context=context)\n    # if inferred is a final node, return it and stop\n    inferred = next(stmt.infer(context), util.Uninferable)\n    if inferred is stmt:\n        yield inferred\n        return dict(node=stmt, context=context)\n    # else, infer recursively, except Uninferable object that should be returned as is\n    for inferred in stmt.infer(context):\n        if inferred is util.Uninferable:\n            yield inferred\n        else:\n            yield from unpack_infer(inferred, context)\n\n    return dict(node=stmt, context=context)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "unpack_infer", "stmt", "context", "none", "recursively", "generate", "nodes", "inferred", "by", "the", "given", "statement", "if", "the", "inferred", "value", "is", "a", "list", "or", "a", "tuple", "recurse", "on", "the", "elements", "if", "isinstance", "stmt", "list", "tuple", "for", "elt", "in", "stmt", "elts", "if", "elt", "is", "util", "uninferable", "yield", "elt", "continue", "yield", "from", "unpack_infer", "elt", "context", "return", "dict", "node", "stmt", "context", "context", "if", "inferred", "is", "a", "final", "node", "return", "it", "and", "stop", "inferred", "next", "stmt", "infer", "context", "util", "uninferable", "if", "inferred", "is", "stmt", "yield", "inferred", "return", "dict", "node", "stmt", "context", "context", "else", "infer", "recursively", "except", "uninferable", "object", "that", "should", "be", "returned", "as", "is", "for", "inferred", "in", "stmt", "infer", "context", "if", "inferred", "is", "util", "uninferable", "yield", "inferred", "else", "yield", "from", "unpack_infer", "inferred", "context", "return", "dict", "node", "stmt", "context", "context"], "doc_len": 126}
{"doc_id": "astroid/nodes/node_classes.py::are_exclusive", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "are_exclusive", "text": "文件路径: astroid/nodes/node_classes.py\ndef are_exclusive(stmt1, stmt2, exceptions: Optional[typing.List[str]] = None) -> bool:\n    \"\"\"return true if the two given statements are mutually exclusive\n\n    `exceptions` may be a list of exception names. If specified, discard If\n    branches and check one of the statement is in an exception handler catching\n    one of the given exceptions.\n\n    algorithm :\n     1) index stmt1's parents\n     2) climb among stmt2's parents until we find a common parent\n     3) if the common parent is a If or TryExcept statement, look if nodes are\n        in exclusive branches\n    \"\"\"\n    # index stmt1's parents\n    stmt1_parents = {}\n    children = {}\n    previous = stmt1\n    for node in stmt1.node_ancestors():\n        stmt1_parents[node] = 1\n        children[node] = previous\n        previous = node\n    # climb among stmt2's parents until we find a common parent\n    previous = stmt2\n    for node in stmt2.node_ancestors():\n        if node in stmt1_parents:\n            # if the common parent is a If or TryExcept statement, look if\n            # nodes are in exclusive branches\n            if isinstance(node, If) and exceptions is None:\n                if (\n                    node.locate_child(previous)[1]\n                    is not node.locate_child(children[node])[1]\n                ):\n                    return True\n            elif isinstance(node, TryExcept):\n                c2attr, c2node = node.locate_child(previous)\n                c1attr, c1node = node.locate_child(children[node])\n                if c1node is not c2node:\n                    first_in_body_caught_by_handlers = (\n                        c2attr == \"handlers\"\n                        and c1attr == \"body\"\n                        and previous.catch(exceptions)\n                    )\n                    second_in_body_caught_by_handlers = (\n                        c2attr == \"body\"\n                        and c1attr == \"handlers\"\n                        and children[node].catch(exceptions)\n                    )\n                    first_in_else_other_in_handlers = (\n                        c2attr == \"handlers\" and c1attr == \"orelse\"\n                    )\n                    second_in_else_other_in_handlers = (\n                        c2attr == \"orelse\" and c1attr == \"handlers\"\n                    )\n                    if any(\n                        (\n                            first_in_body_caught_by_handlers,\n                            second_in_body_caught_by_handlers,\n                            first_in_else_other_in_handlers,\n                            second_in_else_other_in_handlers,\n                        )\n                    ):\n                        return True\n                elif c2attr == \"handlers\" and c1attr == \"handlers\":\n                    return previous is not children[node]\n            return False\n        previous = node\n    return False\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "are_exclusive", "stmt1", "stmt2", "exceptions", "optional", "typing", "list", "str", "none", "bool", "return", "true", "if", "the", "two", "given", "statements", "are", "mutually", "exclusive", "exceptions", "may", "be", "a", "list", "of", "exception", "names", "if", "specified", "discard", "if", "branches", "and", "check", "one", "of", "the", "statement", "is", "in", "an", "exception", "handler", "catching", "one", "of", "the", "given", "exceptions", "algorithm", "1", "index", "stmt1", "s", "parents", "2", "climb", "among", "stmt2", "s", "parents", "until", "we", "find", "a", "common", "parent", "3", "if", "the", "common", "parent", "is", "a", "if", "or", "tryexcept", "statement", "look", "if", "nodes", "are", "in", "exclusive", "branches", "index", "stmt1", "s", "parents", "stmt1_parents", "children", "previous", "stmt1", "for", "node", "in", "stmt1", "node_ancestors", "stmt1_parents", "node", "1", "children", "node", "previous", "previous", "node", "climb", "among", "stmt2", "s", "parents", "until", "we", "find", "a", "common", "parent", "previous", "stmt2", "for", "node", "in", "stmt2", "node_ancestors", "if", "node", "in", "stmt1_parents", "if", "the", "common", "parent", "is", "a", "if", "or", "tryexcept", "statement", "look", "if", "nodes", "are", "in", "exclusive", "branches", "if", "isinstance", "node", "if", "and", "exceptions", "is", "none", "if", "node", "locate_child", "previous", "1", "is", "not", "node", "locate_child", "children", "node", "1", "return", "true", "elif", "isinstance", "node", "tryexcept", "c2attr", "c2node", "node", "locate_child", "previous", "c1attr", "c1node", "node", "locate_child", "children", "node", "if", "c1node", "is", "not", "c2node", "first_in_body_caught_by_handlers", "c2attr", "handlers", "and", "c1attr", "body", "and", "previous", "catch", "exceptions", "second_in_body_caught_by_handlers", "c2attr", "body", "and", "c1attr", "handlers", "and", "children", "node", "catch", "exceptions", "first_in_else_other_in_handlers", "c2attr", "handlers", "and", "c1attr", "orelse", "second_in_else_other_in_handlers", "c2attr", "orelse", "and", "c1attr", "handlers", "if", "any", "first_in_body_caught_by_handlers", "second_in_body_caught_by_handlers", "first_in_else_other_in_handlers", "second_in_else_other_in_handlers", "return", "true", "elif", "c2attr", "handlers", "and", "c1attr", "handlers", "return", "previous", "is", "not", "children", "node", "return", "false", "previous", "node", "return", "false"], "doc_len": 252}
{"doc_id": "astroid/nodes/node_classes.py::_slice_value", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_slice_value", "text": "文件路径: astroid/nodes/node_classes.py\ndef _slice_value(index, context=None):\n    \"\"\"Get the value of the given slice index.\"\"\"\n\n    if isinstance(index, Const):\n        if isinstance(index.value, (int, type(None))):\n            return index.value\n    elif index is None:\n        return None\n    else:\n        # Try to infer what the index actually is.\n        # Since we can't return all the possible values,\n        # we'll stop at the first possible value.\n        try:\n            inferred = next(index.infer(context=context))\n        except (InferenceError, StopIteration):\n            pass\n        else:\n            if isinstance(inferred, Const):\n                if isinstance(inferred.value, (int, type(None))):\n                    return inferred.value\n\n    # Use a sentinel, because None can be a valid\n    # value that this function can return,\n    # as it is the case for unspecified bounds.\n    return _SLICE_SENTINEL\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_slice_value", "index", "context", "none", "get", "the", "value", "of", "the", "given", "slice", "index", "if", "isinstance", "index", "const", "if", "isinstance", "index", "value", "int", "type", "none", "return", "index", "value", "elif", "index", "is", "none", "return", "none", "else", "try", "to", "infer", "what", "the", "index", "actually", "is", "since", "we", "can", "t", "return", "all", "the", "possible", "values", "we", "ll", "stop", "at", "the", "first", "possible", "value", "try", "inferred", "next", "index", "infer", "context", "context", "except", "inferenceerror", "stopiteration", "pass", "else", "if", "isinstance", "inferred", "const", "if", "isinstance", "inferred", "value", "int", "type", "none", "return", "inferred", "value", "use", "a", "sentinel", "because", "none", "can", "be", "a", "valid", "value", "that", "this", "function", "can", "return", "as", "it", "is", "the", "case", "for", "unspecified", "bounds", "return", "_slice_sentinel"], "doc_len": 114}
{"doc_id": "astroid/nodes/node_classes.py::_infer_slice", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_infer_slice", "text": "文件路径: astroid/nodes/node_classes.py\ndef _infer_slice(node, context=None):\n    lower = _slice_value(node.lower, context)\n    upper = _slice_value(node.upper, context)\n    step = _slice_value(node.step, context)\n    if all(elem is not _SLICE_SENTINEL for elem in (lower, upper, step)):\n        return slice(lower, upper, step)\n\n    raise AstroidTypeError(\n        message=\"Could not infer slice used in subscript\",\n        node=node,\n        index=node.parent,\n        context=context,\n    )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_infer_slice", "node", "context", "none", "lower", "_slice_value", "node", "lower", "context", "upper", "_slice_value", "node", "upper", "context", "step", "_slice_value", "node", "step", "context", "if", "all", "elem", "is", "not", "_slice_sentinel", "for", "elem", "in", "lower", "upper", "step", "return", "slice", "lower", "upper", "step", "raise", "astroidtypeerror", "message", "could", "not", "infer", "slice", "used", "in", "subscript", "node", "node", "index", "node", "parent", "context", "context"], "doc_len": 58}
{"doc_id": "astroid/nodes/node_classes.py::_container_getitem", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_container_getitem", "text": "文件路径: astroid/nodes/node_classes.py\ndef _container_getitem(instance, elts, index, context=None):\n    \"\"\"Get a slice or an item, using the given *index*, for the given sequence.\"\"\"\n    try:\n        if isinstance(index, Slice):\n            index_slice = _infer_slice(index, context=context)\n            new_cls = instance.__class__()\n            new_cls.elts = elts[index_slice]\n            new_cls.parent = instance.parent\n            return new_cls\n        if isinstance(index, Const):\n            return elts[index.value]\n    except IndexError as exc:\n        raise AstroidIndexError(\n            message=\"Index {index!s} out of range\",\n            node=instance,\n            index=index,\n            context=context,\n        ) from exc\n    except TypeError as exc:\n        raise AstroidTypeError(\n            message=\"Type error {error!r}\", node=instance, index=index, context=context\n        ) from exc\n\n    raise AstroidTypeError(f\"Could not use {index} as subscript index\")\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_container_getitem", "instance", "elts", "index", "context", "none", "get", "a", "slice", "or", "an", "item", "using", "the", "given", "index", "for", "the", "given", "sequence", "try", "if", "isinstance", "index", "slice", "index_slice", "_infer_slice", "index", "context", "context", "new_cls", "instance", "__class__", "new_cls", "elts", "elts", "index_slice", "new_cls", "parent", "instance", "parent", "return", "new_cls", "if", "isinstance", "index", "const", "return", "elts", "index", "value", "except", "indexerror", "as", "exc", "raise", "astroidindexerror", "message", "index", "index", "s", "out", "of", "range", "node", "instance", "index", "index", "context", "context", "from", "exc", "except", "typeerror", "as", "exc", "raise", "astroidtypeerror", "message", "type", "error", "error", "r", "node", "instance", "index", "index", "context", "context", "from", "exc", "raise", "astroidtypeerror", "f", "could", "not", "use", "index", "as", "subscript", "index"], "doc_len": 106}
{"doc_id": "astroid/nodes/node_classes.py::Statement.next_sibling", "file_path": "astroid/nodes/node_classes.py", "class_name": "Statement", "func_name": "next_sibling", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Statement\n    def next_sibling(self):\n        \"\"\"The next sibling statement node.\n\n        :returns: The next sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n        stmts = self.parent.child_sequence(self)\n        index = stmts.index(self)\n        try:\n            return stmts[index + 1]\n        except IndexError:\n            return None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "statement", "def", "next_sibling", "self", "the", "next", "sibling", "statement", "node", "returns", "the", "next", "sibling", "statement", "node", "rtype", "nodeng", "or", "none", "stmts", "self", "parent", "child_sequence", "self", "index", "stmts", "index", "self", "try", "return", "stmts", "index", "1", "except", "indexerror", "return", "none"], "doc_len": 41}
{"doc_id": "astroid/nodes/node_classes.py::Statement.previous_sibling", "file_path": "astroid/nodes/node_classes.py", "class_name": "Statement", "func_name": "previous_sibling", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Statement\n    def previous_sibling(self):\n        \"\"\"The previous sibling statement.\n\n        :returns: The previous sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n        stmts = self.parent.child_sequence(self)\n        index = stmts.index(self)\n        if index >= 1:\n            return stmts[index - 1]\n        return None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "statement", "def", "previous_sibling", "self", "the", "previous", "sibling", "statement", "returns", "the", "previous", "sibling", "statement", "node", "rtype", "nodeng", "or", "none", "stmts", "self", "parent", "child_sequence", "self", "index", "stmts", "index", "self", "if", "index", "1", "return", "stmts", "index", "1", "return", "none"], "doc_len": 40}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.elts: typing.List[NodeNG] = []\n        \"\"\"The elements in the node.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "elts", "typing", "list", "nodeng", "the", "elements", "in", "the", "node", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 119}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def postinit(self, elts: typing.List[NodeNG]) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param elts: The list of elements the that node contains.\n        \"\"\"\n        self.elts = elts\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "postinit", "self", "elts", "typing", "list", "nodeng", "none", "do", "some", "setup", "after", "initialisation", "param", "elts", "the", "list", "of", "elements", "the", "that", "node", "contains", "self", "elts", "elts"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.from_elements", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "from_elements", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def from_elements(cls, elts=None):\n        \"\"\"Create a node of this type from the given list of elements.\n\n        :param elts: The list of elements that the node should contain.\n        :type elts: list(NodeNG)\n\n        :returns: A new node containing the given elements.\n        :rtype: NodeNG\n        \"\"\"\n        node = cls()\n        if elts is None:\n            node.elts = []\n        else:\n            node.elts = [const_factory(e) if _is_const(e) else e for e in elts]\n        return node\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "from_elements", "cls", "elts", "none", "create", "a", "node", "of", "this", "type", "from", "the", "given", "list", "of", "elements", "param", "elts", "the", "list", "of", "elements", "that", "the", "node", "should", "contain", "type", "elts", "list", "nodeng", "returns", "a", "new", "node", "containing", "the", "given", "elements", "rtype", "nodeng", "node", "cls", "if", "elts", "is", "none", "node", "elts", "else", "node", "elts", "const_factory", "e", "if", "_is_const", "e", "else", "e", "for", "e", "in", "elts", "return", "node"], "doc_len": 71}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.itered", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "itered", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return self.elts\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "itered", "self", "an", "iterator", "over", "the", "elements", "this", "node", "contains", "returns", "the", "contents", "of", "this", "node", "rtype", "iterable", "nodeng", "return", "self", "elts"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.bool_value", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "bool_value", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool or Uninferable\n        \"\"\"\n        return bool(self.elts)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "rtype", "bool", "or", "uninferable", "return", "bool", "self", "elts"], "doc_len": 32}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_classes.py::BaseContainer.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "BaseContainer", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BaseContainer\n    def get_children(self):\n        yield from self.elts\n", "tokens": ["astroid", "nodes", "node_classes", "py", "basecontainer", "def", "get_children", "self", "yield", "from", "self", "elts"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::LookupMixIn.lookup", "file_path": "astroid/nodes/node_classes.py", "class_name": "LookupMixIn", "func_name": "lookup", "text": "文件路径: astroid/nodes/node_classes.py, 类名: LookupMixIn\n    def lookup(self, name):\n        \"\"\"Lookup where the given variable is assigned.\n\n        The lookup starts from self's scope. If self is not a frame itself\n        and the name is found in the inner frame locals, statements will be\n        filtered to remove ignorable statements according to self's location.\n\n        :param name: The name of the variable to find assignments for.\n        :type name: str\n\n        :returns: The scope node and the list of assignments associated to the\n            given name according to the scope where it has been found (locals,\n            globals or builtin).\n        :rtype: tuple(str, list(NodeNG))\n        \"\"\"\n        return self.scope().scope_lookup(self, name)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "lookupmixin", "def", "lookup", "self", "name", "lookup", "where", "the", "given", "variable", "is", "assigned", "the", "lookup", "starts", "from", "self", "s", "scope", "if", "self", "is", "not", "a", "frame", "itself", "and", "the", "name", "is", "found", "in", "the", "inner", "frame", "locals", "statements", "will", "be", "filtered", "to", "remove", "ignorable", "statements", "according", "to", "self", "s", "location", "param", "name", "the", "name", "of", "the", "variable", "to", "find", "assignments", "for", "type", "name", "str", "returns", "the", "scope", "node", "and", "the", "list", "of", "assignments", "associated", "to", "the", "given", "name", "according", "to", "the", "scope", "where", "it", "has", "been", "found", "locals", "globals", "or", "builtin", "rtype", "tuple", "str", "list", "nodeng", "return", "self", "scope", "scope_lookup", "self", "name"], "doc_len": 105}
{"doc_id": "astroid/nodes/node_classes.py::LookupMixIn.ilookup", "file_path": "astroid/nodes/node_classes.py", "class_name": "LookupMixIn", "func_name": "ilookup", "text": "文件路径: astroid/nodes/node_classes.py, 类名: LookupMixIn\n    def ilookup(self, name):\n        \"\"\"Lookup the inferred values of the given variable.\n\n        :param name: The variable name to find values for.\n        :type name: str\n\n        :returns: The inferred values of the statements returned from\n            :meth:`lookup`.\n        :rtype: iterable\n        \"\"\"\n        frame, stmts = self.lookup(name)\n        context = InferenceContext()\n        return _infer_stmts(stmts, context, frame)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "lookupmixin", "def", "ilookup", "self", "name", "lookup", "the", "inferred", "values", "of", "the", "given", "variable", "param", "name", "the", "variable", "name", "to", "find", "values", "for", "type", "name", "str", "returns", "the", "inferred", "values", "of", "the", "statements", "returned", "from", "meth", "lookup", "rtype", "iterable", "frame", "stmts", "self", "lookup", "name", "context", "inferencecontext", "return", "_infer_stmts", "stmts", "context", "frame"], "doc_len": 54}
{"doc_id": "astroid/nodes/node_classes.py::AssignName.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "AssignName", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AssignName\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param name: The name that is assigned to.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.name: Optional[str] = name\n        \"\"\"The name that is assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assignname", "def", "__init__", "self", "name", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "name", "the", "name", "that", "is", "assigned", "to", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "name", "optional", "str", "name", "the", "name", "that", "is", "assigned", "to", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 132}
{"doc_id": "astroid/nodes/node_classes.py::DelName.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "DelName", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: DelName\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param name: The name that is being deleted.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.name: Optional[str] = name\n        \"\"\"The name that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delname", "def", "__init__", "self", "name", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "name", "the", "name", "that", "is", "being", "deleted", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "name", "optional", "str", "name", "the", "name", "that", "is", "being", "deleted", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 132}
{"doc_id": "astroid/nodes/node_classes.py::Name.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Name", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Name\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param name: The name that this node refers to.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.name: Optional[str] = name\n        \"\"\"The name that this node refers to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "name", "def", "__init__", "self", "name", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "name", "the", "name", "that", "this", "node", "refers", "to", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "name", "optional", "str", "name", "the", "name", "that", "this", "node", "refers", "to", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 134}
{"doc_id": "astroid/nodes/node_classes.py::Name._get_name_nodes", "file_path": "astroid/nodes/node_classes.py", "class_name": "Name", "func_name": "_get_name_nodes", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Name\n    def _get_name_nodes(self):\n        yield self\n\n        for child_node in self.get_children():\n            yield from child_node._get_name_nodes()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "name", "def", "_get_name_nodes", "self", "yield", "self", "for", "child_node", "in", "self", "get_children", "yield", "from", "child_node", "_get_name_nodes"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def __init__(\n        self,\n        vararg: Optional[str] = None,\n        kwarg: Optional[str] = None,\n        parent: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"\n        :param vararg: The name of the variable length arguments.\n\n        :param kwarg: The name of the variable length keyword arguments.\n\n        :param parent: The parent node in the syntax tree.\n        \"\"\"\n        super().__init__(parent=parent)\n\n        self.vararg: Optional[str] = vararg  # can be None\n        \"\"\"The name of the variable length arguments.\"\"\"\n\n        self.kwarg: Optional[str] = kwarg  # can be None\n        \"\"\"The name of the variable length keyword arguments.\"\"\"\n\n        self.args: typing.Optional[typing.List[AssignName]]\n        \"\"\"The names of the required arguments.\n\n        Can be None if the associated function does not have a retrievable\n        signature and the arguments are therefore unknown.\n        This happens with builtin functions implemented in C.\n        \"\"\"\n\n        self.defaults: typing.List[NodeNG]\n        \"\"\"The default values for arguments that can be passed positionally.\"\"\"\n\n        self.kwonlyargs: typing.List[AssignName]\n        \"\"\"The keyword arguments that cannot be passed positionally.\"\"\"\n\n        self.posonlyargs: typing.List[AssignName] = []\n        \"\"\"The arguments that can only be passed positionally.\"\"\"\n\n        self.kw_defaults: typing.List[Optional[NodeNG]]\n        \"\"\"The default values for keyword arguments that cannot be passed positionally.\"\"\"\n\n        self.annotations: typing.List[Optional[NodeNG]]\n        \"\"\"The type annotations of arguments that can be passed positionally.\"\"\"\n\n        self.posonlyargs_annotations: typing.List[Optional[NodeNG]] = []\n        \"\"\"The type annotations of arguments that can only be passed positionally.\"\"\"\n\n        self.kwonlyargs_annotations: typing.List[Optional[NodeNG]] = []\n        \"\"\"The type annotations of arguments that cannot be passed positionally.\"\"\"\n\n        self.type_comment_args: typing.List[Optional[NodeNG]] = []\n        \"\"\"The type annotation, passed by a type comment, of each argument.\n\n        If an argument does not have a type comment,\n        the value for that argument will be None.\n        \"\"\"\n\n        self.type_comment_kwonlyargs: typing.List[Optional[NodeNG]] = []\n        \"\"\"The type annotation, passed by a type comment, of each keyword only argument.\n\n        If an argument does not have a type comment,\n        the value for that argument will be None.\n        \"\"\"\n\n        self.type_comment_posonlyargs: typing.List[Optional[NodeNG]] = []\n        \"\"\"The type annotation, passed by a type comment, of each positional argument.\n\n        If an argument does not have a type comment,\n        the value for that argument will be None.\n        \"\"\"\n\n        self.varargannotation: Optional[NodeNG] = None  # can be None\n        \"\"\"The type annotation for the variable length arguments.\"\"\"\n\n        self.kwargannotation: Optional[NodeNG] = None  # can be None\n        \"\"\"The type annotation for the variable length keyword arguments.\"\"\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "__init__", "self", "vararg", "optional", "str", "none", "kwarg", "optional", "str", "none", "parent", "optional", "nodeng", "none", "none", "param", "vararg", "the", "name", "of", "the", "variable", "length", "arguments", "param", "kwarg", "the", "name", "of", "the", "variable", "length", "keyword", "arguments", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "super", "__init__", "parent", "parent", "self", "vararg", "optional", "str", "vararg", "can", "be", "none", "the", "name", "of", "the", "variable", "length", "arguments", "self", "kwarg", "optional", "str", "kwarg", "can", "be", "none", "the", "name", "of", "the", "variable", "length", "keyword", "arguments", "self", "args", "typing", "optional", "typing", "list", "assignname", "the", "names", "of", "the", "required", "arguments", "can", "be", "none", "if", "the", "associated", "function", "does", "not", "have", "a", "retrievable", "signature", "and", "the", "arguments", "are", "therefore", "unknown", "this", "happens", "with", "builtin", "functions", "implemented", "in", "c", "self", "defaults", "typing", "list", "nodeng", "the", "default", "values", "for", "arguments", "that", "can", "be", "passed", "positionally", "self", "kwonlyargs", "typing", "list", "assignname", "the", "keyword", "arguments", "that", "cannot", "be", "passed", "positionally", "self", "posonlyargs", "typing", "list", "assignname", "the", "arguments", "that", "can", "only", "be", "passed", "positionally", "self", "kw_defaults", "typing", "list", "optional", "nodeng", "the", "default", "values", "for", "keyword", "arguments", "that", "cannot", "be", "passed", "positionally", "self", "annotations", "typing", "list", "optional", "nodeng", "the", "type", "annotations", "of", "arguments", "that", "can", "be", "passed", "positionally", "self", "posonlyargs_annotations", "typing", "list", "optional", "nodeng", "the", "type", "annotations", "of", "arguments", "that", "can", "only", "be", "passed", "positionally", "self", "kwonlyargs_annotations", "typing", "list", "optional", "nodeng", "the", "type", "annotations", "of", "arguments", "that", "cannot", "be", "passed", "positionally", "self", "type_comment_args", "typing", "list", "optional", "nodeng", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "argument", "if", "an", "argument", "does", "not", "have", "a", "type", "comment", "the", "value", "for", "that", "argument", "will", "be", "none", "self", "type_comment_kwonlyargs", "typing", "list", "optional", "nodeng", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "keyword", "only", "argument", "if", "an", "argument", "does", "not", "have", "a", "type", "comment", "the", "value", "for", "that", "argument", "will", "be", "none", "self", "type_comment_posonlyargs", "typing", "list", "optional", "nodeng", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "positional", "argument", "if", "an", "argument", "does", "not", "have", "a", "type", "comment", "the", "value", "for", "that", "argument", "will", "be", "none", "self", "varargannotation", "optional", "nodeng", "none", "can", "be", "none", "the", "type", "annotation", "for", "the", "variable", "length", "arguments", "self", "kwargannotation", "optional", "nodeng", "none", "can", "be", "none", "the", "type", "annotation", "for", "the", "variable", "length", "keyword", "arguments"], "doc_len": 369}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def postinit(\n        self,\n        args: typing.List[AssignName],\n        defaults: typing.List[NodeNG],\n        kwonlyargs: typing.List[AssignName],\n        kw_defaults: typing.List[Optional[NodeNG]],\n        annotations: typing.List[Optional[NodeNG]],\n        posonlyargs: Optional[typing.List[AssignName]] = None,\n        kwonlyargs_annotations: Optional[typing.List[Optional[NodeNG]]] = None,\n        posonlyargs_annotations: Optional[typing.List[Optional[NodeNG]]] = None,\n        varargannotation: Optional[NodeNG] = None,\n        kwargannotation: Optional[NodeNG] = None,\n        type_comment_args: Optional[typing.List[Optional[NodeNG]]] = None,\n        type_comment_kwonlyargs: Optional[typing.List[Optional[NodeNG]]] = None,\n        type_comment_posonlyargs: Optional[typing.List[Optional[NodeNG]]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param args: The names of the required arguments.\n\n        :param defaults: The default values for arguments that can be passed\n            positionally.\n\n        :param kwonlyargs: The keyword arguments that cannot be passed\n            positionally.\n\n        :param posonlyargs: The arguments that can only be passed\n            positionally.\n\n        :param kw_defaults: The default values for keyword arguments that\n            cannot be passed positionally.\n\n        :param annotations: The type annotations of arguments that can be\n            passed positionally.\n\n        :param kwonlyargs_annotations: The type annotations of arguments that\n            cannot be passed positionally. This should always be passed in\n            Python 3.\n\n        :param posonlyargs_annotations: The type annotations of arguments that\n            can only be passed positionally. This should always be passed in\n            Python 3.\n\n        :param varargannotation: The type annotation for the variable length\n            arguments.\n\n        :param kwargannotation: The type annotation for the variable length\n            keyword arguments.\n\n        :param type_comment_args: The type annotation,\n            passed by a type comment, of each argument.\n\n        :param type_comment_args: The type annotation,\n            passed by a type comment, of each keyword only argument.\n\n        :param type_comment_args: The type annotation,\n            passed by a type comment, of each positional argument.\n        \"\"\"\n        self.args = args\n        self.defaults = defaults\n        self.kwonlyargs = kwonlyargs\n        if posonlyargs is not None:\n            self.posonlyargs = posonlyargs\n        self.kw_defaults = kw_defaults\n        self.annotations = annotations\n        if kwonlyargs_annotations is not None:\n            self.kwonlyargs_annotations = kwonlyargs_annotations\n        if posonlyargs_annotations is not None:\n            self.posonlyargs_annotations = posonlyargs_annotations\n        self.varargannotation = varargannotation\n        self.kwargannotation = kwargannotation\n        if type_comment_args is not None:\n            self.type_comment_args = type_comment_args\n        if type_comment_kwonlyargs is not None:\n            self.type_comment_kwonlyargs = type_comment_kwonlyargs\n        if type_comment_posonlyargs is not None:\n            self.type_comment_posonlyargs = type_comment_posonlyargs\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "postinit", "self", "args", "typing", "list", "assignname", "defaults", "typing", "list", "nodeng", "kwonlyargs", "typing", "list", "assignname", "kw_defaults", "typing", "list", "optional", "nodeng", "annotations", "typing", "list", "optional", "nodeng", "posonlyargs", "optional", "typing", "list", "assignname", "none", "kwonlyargs_annotations", "optional", "typing", "list", "optional", "nodeng", "none", "posonlyargs_annotations", "optional", "typing", "list", "optional", "nodeng", "none", "varargannotation", "optional", "nodeng", "none", "kwargannotation", "optional", "nodeng", "none", "type_comment_args", "optional", "typing", "list", "optional", "nodeng", "none", "type_comment_kwonlyargs", "optional", "typing", "list", "optional", "nodeng", "none", "type_comment_posonlyargs", "optional", "typing", "list", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "args", "the", "names", "of", "the", "required", "arguments", "param", "defaults", "the", "default", "values", "for", "arguments", "that", "can", "be", "passed", "positionally", "param", "kwonlyargs", "the", "keyword", "arguments", "that", "cannot", "be", "passed", "positionally", "param", "posonlyargs", "the", "arguments", "that", "can", "only", "be", "passed", "positionally", "param", "kw_defaults", "the", "default", "values", "for", "keyword", "arguments", "that", "cannot", "be", "passed", "positionally", "param", "annotations", "the", "type", "annotations", "of", "arguments", "that", "can", "be", "passed", "positionally", "param", "kwonlyargs_annotations", "the", "type", "annotations", "of", "arguments", "that", "cannot", "be", "passed", "positionally", "this", "should", "always", "be", "passed", "in", "python", "3", "param", "posonlyargs_annotations", "the", "type", "annotations", "of", "arguments", "that", "can", "only", "be", "passed", "positionally", "this", "should", "always", "be", "passed", "in", "python", "3", "param", "varargannotation", "the", "type", "annotation", "for", "the", "variable", "length", "arguments", "param", "kwargannotation", "the", "type", "annotation", "for", "the", "variable", "length", "keyword", "arguments", "param", "type_comment_args", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "argument", "param", "type_comment_args", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "keyword", "only", "argument", "param", "type_comment_args", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "of", "each", "positional", "argument", "self", "args", "args", "self", "defaults", "defaults", "self", "kwonlyargs", "kwonlyargs", "if", "posonlyargs", "is", "not", "none", "self", "posonlyargs", "posonlyargs", "self", "kw_defaults", "kw_defaults", "self", "annotations", "annotations", "if", "kwonlyargs_annotations", "is", "not", "none", "self", "kwonlyargs_annotations", "kwonlyargs_annotations", "if", "posonlyargs_annotations", "is", "not", "none", "self", "posonlyargs_annotations", "posonlyargs_annotations", "self", "varargannotation", "varargannotation", "self", "kwargannotation", "kwargannotation", "if", "type_comment_args", "is", "not", "none", "self", "type_comment_args", "type_comment_args", "if", "type_comment_kwonlyargs", "is", "not", "none", "self", "type_comment_kwonlyargs", "type_comment_kwonlyargs", "if", "type_comment_posonlyargs", "is", "not", "none", "self", "type_comment_posonlyargs", "type_comment_posonlyargs"], "doc_len": 323}
{"doc_id": "astroid/nodes/node_classes.py::Arguments._infer_name", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "_infer_name", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def _infer_name(self, frame, name):\n        if self.parent is frame:\n            return name\n        return None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "_infer_name", "self", "frame", "name", "if", "self", "parent", "is", "frame", "return", "name", "return", "none"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.fromlineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "fromlineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def fromlineno(self):\n        \"\"\"The first line that this node appears on in the source code.\n\n        :type: int or None\n        \"\"\"\n        lineno = super().fromlineno\n        return max(lineno, self.parent.fromlineno or 0)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "fromlineno", "self", "the", "first", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "int", "or", "none", "lineno", "super", "fromlineno", "return", "max", "lineno", "self", "parent", "fromlineno", "or", "0"], "doc_len": 35}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.arguments", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "arguments", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def arguments(self):\n        \"\"\"Get all the arguments for this node, including positional only and positional and keyword\"\"\"\n        return list(itertools.chain((self.posonlyargs or ()), self.args or ()))\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "arguments", "self", "get", "all", "the", "arguments", "for", "this", "node", "including", "positional", "only", "and", "positional", "and", "keyword", "return", "list", "itertools", "chain", "self", "posonlyargs", "or", "self", "args", "or"], "doc_len": 32}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.format_args", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "format_args", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def format_args(self):\n        \"\"\"Get the arguments formatted as string.\n\n        :returns: The formatted arguments.\n        :rtype: str\n        \"\"\"\n        result = []\n        positional_only_defaults = []\n        positional_or_keyword_defaults = self.defaults\n        if self.defaults:\n            args = self.args or []\n            positional_or_keyword_defaults = self.defaults[-len(args) :]\n            positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]\n\n        if self.posonlyargs:\n            result.append(\n                _format_args(\n                    self.posonlyargs,\n                    positional_only_defaults,\n                    self.posonlyargs_annotations,\n                )\n            )\n            result.append(\"/\")\n        if self.args:\n            result.append(\n                _format_args(\n                    self.args,\n                    positional_or_keyword_defaults,\n                    getattr(self, \"annotations\", None),\n                )\n            )\n        if self.vararg:\n            result.append(f\"*{self.vararg}\")\n        if self.kwonlyargs:\n            if not self.vararg:\n                result.append(\"*\")\n            result.append(\n                _format_args(\n                    self.kwonlyargs, self.kw_defaults, self.kwonlyargs_annotations\n                )\n            )\n        if self.kwarg:\n            result.append(f\"**{self.kwarg}\")\n        return \", \".join(result)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "format_args", "self", "get", "the", "arguments", "formatted", "as", "string", "returns", "the", "formatted", "arguments", "rtype", "str", "result", "positional_only_defaults", "positional_or_keyword_defaults", "self", "defaults", "if", "self", "defaults", "args", "self", "args", "or", "positional_or_keyword_defaults", "self", "defaults", "len", "args", "positional_only_defaults", "self", "defaults", "len", "self", "defaults", "len", "args", "if", "self", "posonlyargs", "result", "append", "_format_args", "self", "posonlyargs", "positional_only_defaults", "self", "posonlyargs_annotations", "result", "append", "if", "self", "args", "result", "append", "_format_args", "self", "args", "positional_or_keyword_defaults", "getattr", "self", "annotations", "none", "if", "self", "vararg", "result", "append", "f", "self", "vararg", "if", "self", "kwonlyargs", "if", "not", "self", "vararg", "result", "append", "result", "append", "_format_args", "self", "kwonlyargs", "self", "kw_defaults", "self", "kwonlyargs_annotations", "if", "self", "kwarg", "result", "append", "f", "self", "kwarg", "return", "join", "result"], "doc_len": 108}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.default_value", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "default_value", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def default_value(self, argname):\n        \"\"\"Get the default value for an argument.\n\n        :param argname: The name of the argument to get the default value for.\n        :type argname: str\n\n        :raises NoDefault: If there is no default value defined for the\n            given argument.\n        \"\"\"\n        args = self.arguments\n        index = _find_arg(argname, args)[0]\n        if index is not None:\n            idx = index - (len(args) - len(self.defaults))\n            if idx >= 0:\n                return self.defaults[idx]\n        index = _find_arg(argname, self.kwonlyargs)[0]\n        if index is not None and self.kw_defaults[index] is not None:\n            return self.kw_defaults[index]\n        raise NoDefault(func=self.parent, name=argname)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "default_value", "self", "argname", "get", "the", "default", "value", "for", "an", "argument", "param", "argname", "the", "name", "of", "the", "argument", "to", "get", "the", "default", "value", "for", "type", "argname", "str", "raises", "nodefault", "if", "there", "is", "no", "default", "value", "defined", "for", "the", "given", "argument", "args", "self", "arguments", "index", "_find_arg", "argname", "args", "0", "if", "index", "is", "not", "none", "idx", "index", "len", "args", "len", "self", "defaults", "if", "idx", "0", "return", "self", "defaults", "idx", "index", "_find_arg", "argname", "self", "kwonlyargs", "0", "if", "index", "is", "not", "none", "and", "self", "kw_defaults", "index", "is", "not", "none", "return", "self", "kw_defaults", "index", "raise", "nodefault", "func", "self", "parent", "name", "argname"], "doc_len": 101}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.is_argument", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "is_argument", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def is_argument(self, name):\n        \"\"\"Check if the given name is defined in the arguments.\n\n        :param name: The name to check for.\n        :type name: str\n\n        :returns: True if the given name is defined in the arguments,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        if name == self.vararg:\n            return True\n        if name == self.kwarg:\n            return True\n        return (\n            self.find_argname(name, rec=True)[1] is not None\n            or self.kwonlyargs\n            and _find_arg(name, self.kwonlyargs, rec=True)[1] is not None\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "is_argument", "self", "name", "check", "if", "the", "given", "name", "is", "defined", "in", "the", "arguments", "param", "name", "the", "name", "to", "check", "for", "type", "name", "str", "returns", "true", "if", "the", "given", "name", "is", "defined", "in", "the", "arguments", "false", "otherwise", "rtype", "bool", "if", "name", "self", "vararg", "return", "true", "if", "name", "self", "kwarg", "return", "true", "return", "self", "find_argname", "name", "rec", "true", "1", "is", "not", "none", "or", "self", "kwonlyargs", "and", "_find_arg", "name", "self", "kwonlyargs", "rec", "true", "1", "is", "not", "none"], "doc_len": 80}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.find_argname", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "find_argname", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def find_argname(self, argname, rec=False):\n        \"\"\"Get the index and :class:`AssignName` node for given name.\n\n        :param argname: The name of the argument to search for.\n        :type argname: str\n\n        :param rec: Whether or not to include arguments in unpacked tuples\n            in the search.\n        :type rec: bool\n\n        :returns: The index and node for the argument.\n        :rtype: tuple(str or None, AssignName or None)\n        \"\"\"\n        if self.arguments:\n            return _find_arg(argname, self.arguments, rec)\n        return None, None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "find_argname", "self", "argname", "rec", "false", "get", "the", "index", "and", "class", "assignname", "node", "for", "given", "name", "param", "argname", "the", "name", "of", "the", "argument", "to", "search", "for", "type", "argname", "str", "param", "rec", "whether", "or", "not", "to", "include", "arguments", "in", "unpacked", "tuples", "in", "the", "search", "type", "rec", "bool", "returns", "the", "index", "and", "node", "for", "the", "argument", "rtype", "tuple", "str", "or", "none", "assignname", "or", "none", "if", "self", "arguments", "return", "_find_arg", "argname", "self", "arguments", "rec", "return", "none", "none"], "doc_len": 79}
{"doc_id": "astroid/nodes/node_classes.py::Arguments.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Arguments", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Arguments\n    def get_children(self):\n        yield from self.posonlyargs or ()\n\n        for elt in self.posonlyargs_annotations:\n            if elt is not None:\n                yield elt\n\n        yield from self.args or ()\n\n        yield from self.defaults\n        yield from self.kwonlyargs\n\n        for elt in self.kw_defaults:\n            if elt is not None:\n                yield elt\n\n        for elt in self.annotations:\n            if elt is not None:\n                yield elt\n\n        if self.varargannotation is not None:\n            yield self.varargannotation\n\n        if self.kwargannotation is not None:\n            yield self.kwargannotation\n\n        for elt in self.kwonlyargs_annotations:\n            if elt is not None:\n                yield elt\n", "tokens": ["astroid", "nodes", "node_classes", "py", "arguments", "def", "get_children", "self", "yield", "from", "self", "posonlyargs", "or", "for", "elt", "in", "self", "posonlyargs_annotations", "if", "elt", "is", "not", "none", "yield", "elt", "yield", "from", "self", "args", "or", "yield", "from", "self", "defaults", "yield", "from", "self", "kwonlyargs", "for", "elt", "in", "self", "kw_defaults", "if", "elt", "is", "not", "none", "yield", "elt", "for", "elt", "in", "self", "annotations", "if", "elt", "is", "not", "none", "yield", "elt", "if", "self", "varargannotation", "is", "not", "none", "yield", "self", "varargannotation", "if", "self", "kwargannotation", "is", "not", "none", "yield", "self", "kwargannotation", "for", "elt", "in", "self", "kwonlyargs_annotations", "if", "elt", "is", "not", "none", "yield", "elt"], "doc_len": 92}
{"doc_id": "astroid/nodes/node_classes.py::_find_arg", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_find_arg", "text": "文件路径: astroid/nodes/node_classes.py\ndef _find_arg(argname, args, rec=False):\n    for i, arg in enumerate(args):\n        if isinstance(arg, Tuple):\n            if rec:\n                found = _find_arg(argname, arg.elts)\n                if found[0] is not None:\n                    return found\n        elif arg.name == argname:\n            return i, arg\n    return None, None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_find_arg", "argname", "args", "rec", "false", "for", "i", "arg", "in", "enumerate", "args", "if", "isinstance", "arg", "tuple", "if", "rec", "found", "_find_arg", "argname", "arg", "elts", "if", "found", "0", "is", "not", "none", "return", "found", "elif", "arg", "name", "argname", "return", "i", "arg", "return", "none", "none"], "doc_len": 45}
{"doc_id": "astroid/nodes/node_classes.py::_format_args", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_format_args", "text": "文件路径: astroid/nodes/node_classes.py\ndef _format_args(args, defaults=None, annotations=None):\n    values = []\n    if args is None:\n        return \"\"\n    if annotations is None:\n        annotations = []\n    if defaults is not None:\n        default_offset = len(args) - len(defaults)\n    packed = itertools.zip_longest(args, annotations)\n    for i, (arg, annotation) in enumerate(packed):\n        if isinstance(arg, Tuple):\n            values.append(f\"({_format_args(arg.elts)})\")\n        else:\n            argname = arg.name\n            default_sep = \"=\"\n            if annotation is not None:\n                argname += \": \" + annotation.as_string()\n                default_sep = \" = \"\n            values.append(argname)\n\n            if defaults is not None and i >= default_offset:\n                if defaults[i - default_offset] is not None:\n                    values[-1] += default_sep + defaults[i - default_offset].as_string()\n    return \", \".join(values)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_format_args", "args", "defaults", "none", "annotations", "none", "values", "if", "args", "is", "none", "return", "if", "annotations", "is", "none", "annotations", "if", "defaults", "is", "not", "none", "default_offset", "len", "args", "len", "defaults", "packed", "itertools", "zip_longest", "args", "annotations", "for", "i", "arg", "annotation", "in", "enumerate", "packed", "if", "isinstance", "arg", "tuple", "values", "append", "f", "_format_args", "arg", "elts", "else", "argname", "arg", "name", "default_sep", "if", "annotation", "is", "not", "none", "argname", "annotation", "as_string", "default_sep", "values", "append", "argname", "if", "defaults", "is", "not", "none", "and", "i", "default_offset", "if", "defaults", "i", "default_offset", "is", "not", "none", "values", "1", "default_sep", "defaults", "i", "default_offset", "as_string", "return", "join", "values"], "doc_len": 96}
{"doc_id": "astroid/nodes/node_classes.py::AssignAttr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "AssignAttr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AssignAttr\n    def __init__(\n        self,\n        attrname: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param attrname: The name of the attribute being assigned to.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.expr: Optional[NodeNG] = None\n        \"\"\"What has the attribute that is being assigned to.\"\"\"\n\n        self.attrname: Optional[str] = attrname\n        \"\"\"The name of the attribute being assigned to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assignattr", "def", "__init__", "self", "attrname", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "attrname", "the", "name", "of", "the", "attribute", "being", "assigned", "to", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "expr", "optional", "nodeng", "none", "what", "has", "the", "attribute", "that", "is", "being", "assigned", "to", "self", "attrname", "optional", "str", "attrname", "the", "name", "of", "the", "attribute", "being", "assigned", "to", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 150}
{"doc_id": "astroid/nodes/node_classes.py::AssignAttr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "AssignAttr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AssignAttr\n    def postinit(self, expr: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param expr: What has the attribute that is being assigned to.\n        \"\"\"\n        self.expr = expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assignattr", "def", "postinit", "self", "expr", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "expr", "what", "has", "the", "attribute", "that", "is", "being", "assigned", "to", "self", "expr", "expr"], "doc_len": 32}
{"doc_id": "astroid/nodes/node_classes.py::AssignAttr.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "AssignAttr", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AssignAttr\n    def get_children(self):\n        yield self.expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assignattr", "def", "get_children", "self", "yield", "self", "expr"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::Assert.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assert", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assert\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.test: Optional[NodeNG] = None\n        \"\"\"The test that passes or fails the assertion.\"\"\"\n\n        self.fail: Optional[NodeNG] = None  # can be None\n        \"\"\"The message shown when the assertion fails.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assert", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "test", "optional", "nodeng", "none", "the", "test", "that", "passes", "or", "fails", "the", "assertion", "self", "fail", "optional", "nodeng", "none", "can", "be", "none", "the", "message", "shown", "when", "the", "assertion", "fails", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 137}
{"doc_id": "astroid/nodes/node_classes.py::Assert.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assert", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assert\n    def postinit(\n        self, test: Optional[NodeNG] = None, fail: Optional[NodeNG] = None\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param test: The test that passes or fails the assertion.\n\n        :param fail: The message shown when the assertion fails.\n        \"\"\"\n        self.fail = fail\n        self.test = test\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assert", "def", "postinit", "self", "test", "optional", "nodeng", "none", "fail", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "test", "the", "test", "that", "passes", "or", "fails", "the", "assertion", "param", "fail", "the", "message", "shown", "when", "the", "assertion", "fails", "self", "fail", "fail", "self", "test", "test"], "doc_len": 47}
{"doc_id": "astroid/nodes/node_classes.py::Assert.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assert", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assert\n    def get_children(self):\n        yield self.test\n\n        if self.fail is not None:\n            yield self.fail\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assert", "def", "get_children", "self", "yield", "self", "test", "if", "self", "fail", "is", "not", "none", "yield", "self", "fail"], "doc_len": 20}
{"doc_id": "astroid/nodes/node_classes.py::Assign.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assign", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assign\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.targets: typing.List[NodeNG] = []\n        \"\"\"What is being assigned to.\"\"\"\n\n        self.value: Optional[NodeNG] = None\n        \"\"\"The value being assigned to the variables.\"\"\"\n\n        self.type_annotation: Optional[NodeNG] = None  # can be None\n        \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assign", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "targets", "typing", "list", "nodeng", "what", "is", "being", "assigned", "to", "self", "value", "optional", "nodeng", "none", "the", "value", "being", "assigned", "to", "the", "variables", "self", "type_annotation", "optional", "nodeng", "none", "can", "be", "none", "if", "present", "this", "will", "contain", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 152}
{"doc_id": "astroid/nodes/node_classes.py::Assign.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assign", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assign\n    def postinit(\n        self,\n        targets: Optional[typing.List[NodeNG]] = None,\n        value: Optional[NodeNG] = None,\n        type_annotation: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param targets: What is being assigned to.\n        :param value: The value being assigned to the variables.\n        :param type_annotation:\n        \"\"\"\n        if targets is not None:\n            self.targets = targets\n        self.value = value\n        self.type_annotation = type_annotation\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assign", "def", "postinit", "self", "targets", "optional", "typing", "list", "nodeng", "none", "value", "optional", "nodeng", "none", "type_annotation", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "targets", "what", "is", "being", "assigned", "to", "param", "value", "the", "value", "being", "assigned", "to", "the", "variables", "param", "type_annotation", "if", "targets", "is", "not", "none", "self", "targets", "targets", "self", "value", "value", "self", "type_annotation", "type_annotation"], "doc_len": 60}
{"doc_id": "astroid/nodes/node_classes.py::Assign.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assign", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assign\n    def get_children(self):\n        yield from self.targets\n\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assign", "def", "get_children", "self", "yield", "from", "self", "targets", "yield", "self", "value"], "doc_len": 15}
{"doc_id": "astroid/nodes/node_classes.py::Assign._get_assign_nodes", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assign", "func_name": "_get_assign_nodes", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assign\n    def _get_assign_nodes(self):\n        return [self] + list(self.value._get_assign_nodes())\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assign", "def", "_get_assign_nodes", "self", "return", "self", "list", "self", "value", "_get_assign_nodes"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::Assign._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "Assign", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Assign\n    def _get_yield_nodes_skip_lambdas(self):\n        yield from self.value._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "assign", "def", "_get_yield_nodes_skip_lambdas", "self", "yield", "from", "self", "value", "_get_yield_nodes_skip_lambdas"], "doc_len": 13}
{"doc_id": "astroid/nodes/node_classes.py::AnnAssign.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "AnnAssign", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AnnAssign\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: Optional[NodeNG] = None\n        \"\"\"What is being assigned to.\"\"\"\n\n        self.annotation: Optional[NodeNG] = None\n        \"\"\"The type annotation of what is being assigned to.\"\"\"\n\n        self.value: Optional[NodeNG] = None  # can be None\n        \"\"\"The value being assigned to the variables.\"\"\"\n\n        self.simple: Optional[int] = None\n        \"\"\"Whether :attr:`target` is a pure name or a complex statement.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "annassign", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "target", "optional", "nodeng", "none", "what", "is", "being", "assigned", "to", "self", "annotation", "optional", "nodeng", "none", "the", "type", "annotation", "of", "what", "is", "being", "assigned", "to", "self", "value", "optional", "nodeng", "none", "can", "be", "none", "the", "value", "being", "assigned", "to", "the", "variables", "self", "simple", "optional", "int", "none", "whether", "attr", "target", "is", "a", "pure", "name", "or", "a", "complex", "statement", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 164}
{"doc_id": "astroid/nodes/node_classes.py::AnnAssign.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "AnnAssign", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AnnAssign\n    def postinit(\n        self,\n        target: NodeNG,\n        annotation: NodeNG,\n        simple: int,\n        value: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param target: What is being assigned to.\n\n        :param annotation: The type annotation of what is being assigned to.\n\n        :param simple: Whether :attr:`target` is a pure name\n            or a complex statement.\n\n        :param value: The value being assigned to the variables.\n        \"\"\"\n        self.target = target\n        self.annotation = annotation\n        self.value = value\n        self.simple = simple\n", "tokens": ["astroid", "nodes", "node_classes", "py", "annassign", "def", "postinit", "self", "target", "nodeng", "annotation", "nodeng", "simple", "int", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "target", "what", "is", "being", "assigned", "to", "param", "annotation", "the", "type", "annotation", "of", "what", "is", "being", "assigned", "to", "param", "simple", "whether", "attr", "target", "is", "a", "pure", "name", "or", "a", "complex", "statement", "param", "value", "the", "value", "being", "assigned", "to", "the", "variables", "self", "target", "target", "self", "annotation", "annotation", "self", "value", "value", "self", "simple", "simple"], "doc_len": 76}
{"doc_id": "astroid/nodes/node_classes.py::AnnAssign.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "AnnAssign", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AnnAssign\n    def get_children(self):\n        yield self.target\n        yield self.annotation\n\n        if self.value is not None:\n            yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "annassign", "def", "get_children", "self", "yield", "self", "target", "yield", "self", "annotation", "if", "self", "value", "is", "not", "none", "yield", "self", "value"], "doc_len": 23}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def __init__(\n        self,\n        op: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator that is being combined with the assignment.\n            This includes the equals sign.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: Optional[NodeNG] = None\n        \"\"\"What is being assigned to.\"\"\"\n\n        self.op: Optional[str] = op\n        \"\"\"The operator that is being combined with the assignment.\n\n        This includes the equals sign.\n        \"\"\"\n\n        self.value: Optional[NodeNG] = None\n        \"\"\"The value being assigned to the variable.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "__init__", "self", "op", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "op", "the", "operator", "that", "is", "being", "combined", "with", "the", "assignment", "this", "includes", "the", "equals", "sign", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "target", "optional", "nodeng", "none", "what", "is", "being", "assigned", "to", "self", "op", "optional", "str", "op", "the", "operator", "that", "is", "being", "combined", "with", "the", "assignment", "this", "includes", "the", "equals", "sign", "self", "value", "optional", "nodeng", "none", "the", "value", "being", "assigned", "to", "the", "variable", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 170}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def postinit(\n        self, target: Optional[NodeNG] = None, value: Optional[NodeNG] = None\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param target: What is being assigned to.\n\n        :param value: The value being assigned to the variable.\n        \"\"\"\n        self.target = target\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "postinit", "self", "target", "optional", "nodeng", "none", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "target", "what", "is", "being", "assigned", "to", "param", "value", "the", "value", "being", "assigned", "to", "the", "variable", "self", "target", "target", "self", "value", "value"], "doc_len": 44}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign._infer_augassign", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "_infer_augassign", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def _infer_augassign(self, context=None):\n        raise NotImplementedError\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "_infer_augassign", "self", "context", "none", "raise", "notimplementederror"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign.type_errors", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "type_errors", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def type_errors(self, context=None):\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage` ,\n        which holds the original exception.\n\n        :returns: The list of possible type errors.\n        :rtype: list(BadBinaryOperationMessage)\n        \"\"\"\n        try:\n            results = self._infer_augassign(context=context)\n            return [\n                result\n                for result in results\n                if isinstance(result, util.BadBinaryOperationMessage)\n            ]\n        except InferenceError:\n            return []\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "type_errors", "self", "context", "none", "get", "a", "list", "of", "type", "errors", "which", "can", "occur", "during", "inference", "each", "typeerror", "is", "represented", "by", "a", "class", "badbinaryoperationmessage", "which", "holds", "the", "original", "exception", "returns", "the", "list", "of", "possible", "type", "errors", "rtype", "list", "badbinaryoperationmessage", "try", "results", "self", "_infer_augassign", "context", "context", "return", "result", "for", "result", "in", "results", "if", "isinstance", "result", "util", "badbinaryoperationmessage", "except", "inferenceerror", "return"], "doc_len": 64}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def get_children(self):\n        yield self.target\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "get_children", "self", "yield", "self", "target", "yield", "self", "value"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::AugAssign._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "AugAssign", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: AugAssign\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An AugAssign node can contain a Yield node in the value\"\"\"\n        yield from self.value._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "augassign", "def", "_get_yield_nodes_skip_lambdas", "self", "an", "augassign", "node", "can", "contain", "a", "yield", "node", "in", "the", "value", "yield", "from", "self", "value", "_get_yield_nodes_skip_lambdas", "yield", "from", "super", "_get_yield_nodes_skip_lambdas"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def __init__(\n        self,\n        op: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.left: Optional[NodeNG] = None\n        \"\"\"What is being applied to the operator on the left side.\"\"\"\n\n        self.op: Optional[str] = op\n        \"\"\"The operator.\"\"\"\n\n        self.right: Optional[NodeNG] = None\n        \"\"\"What is being applied to the operator on the right side.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "__init__", "self", "op", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "op", "the", "operator", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "left", "optional", "nodeng", "none", "what", "is", "being", "applied", "to", "the", "operator", "on", "the", "left", "side", "self", "op", "optional", "str", "op", "the", "operator", "self", "right", "optional", "nodeng", "none", "what", "is", "being", "applied", "to", "the", "operator", "on", "the", "right", "side", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 156}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def postinit(\n        self, left: Optional[NodeNG] = None, right: Optional[NodeNG] = None\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param left: What is being applied to the operator on the left side.\n\n        :param right: What is being applied to the operator on the right side.\n        \"\"\"\n        self.left = left\n        self.right = right\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "postinit", "self", "left", "optional", "nodeng", "none", "right", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "left", "what", "is", "being", "applied", "to", "the", "operator", "on", "the", "left", "side", "param", "right", "what", "is", "being", "applied", "to", "the", "operator", "on", "the", "right", "side", "self", "left", "left", "self", "right", "right"], "doc_len": 54}
{"doc_id": "astroid/nodes/node_classes.py::BinOp._infer_binop", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "_infer_binop", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def _infer_binop(self, context=None):\n        raise NotImplementedError\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "_infer_binop", "self", "context", "none", "raise", "notimplementederror"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.type_errors", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "type_errors", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def type_errors(self, context=None):\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n        which holds the original exception.\n\n        :returns: The list of possible type errors.\n        :rtype: list(BadBinaryOperationMessage)\n        \"\"\"\n        try:\n            results = self._infer_binop(context=context)\n            return [\n                result\n                for result in results\n                if isinstance(result, util.BadBinaryOperationMessage)\n            ]\n        except InferenceError:\n            return []\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "type_errors", "self", "context", "none", "get", "a", "list", "of", "type", "errors", "which", "can", "occur", "during", "inference", "each", "typeerror", "is", "represented", "by", "a", "class", "badbinaryoperationmessage", "which", "holds", "the", "original", "exception", "returns", "the", "list", "of", "possible", "type", "errors", "rtype", "list", "badbinaryoperationmessage", "try", "results", "self", "_infer_binop", "context", "context", "return", "result", "for", "result", "in", "results", "if", "isinstance", "result", "util", "badbinaryoperationmessage", "except", "inferenceerror", "return"], "doc_len": 64}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def get_children(self):\n        yield self.left\n        yield self.right\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "get_children", "self", "yield", "self", "left", "yield", "self", "right"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.op_precedence", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "op_precedence", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def op_precedence(self):\n        return OP_PRECEDENCE[self.op]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "op_precedence", "self", "return", "op_precedence", "self", "op"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::BinOp.op_left_associative", "file_path": "astroid/nodes/node_classes.py", "class_name": "BinOp", "func_name": "op_left_associative", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BinOp\n    def op_left_associative(self):\n        # 2**3**4 == 2**(3**4)\n        return self.op != \"**\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "binop", "def", "op_left_associative", "self", "2", "3", "4", "2", "3", "4", "return", "self", "op"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_classes.py::BoolOp.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "BoolOp", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BoolOp\n    def __init__(\n        self,\n        op: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.op: Optional[str] = op\n        \"\"\"The operator.\"\"\"\n\n        self.values: typing.List[NodeNG] = []\n        \"\"\"The values being applied to the operator.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "boolop", "def", "__init__", "self", "op", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "op", "the", "operator", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "op", "optional", "str", "op", "the", "operator", "self", "values", "typing", "list", "nodeng", "the", "values", "being", "applied", "to", "the", "operator", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 136}
{"doc_id": "astroid/nodes/node_classes.py::BoolOp.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "BoolOp", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BoolOp\n    def postinit(self, values: Optional[typing.List[NodeNG]] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param values: The values being applied to the operator.\n        \"\"\"\n        if values is not None:\n            self.values = values\n", "tokens": ["astroid", "nodes", "node_classes", "py", "boolop", "def", "postinit", "self", "values", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "values", "the", "values", "being", "applied", "to", "the", "operator", "if", "values", "is", "not", "none", "self", "values", "values"], "doc_len": 37}
{"doc_id": "astroid/nodes/node_classes.py::BoolOp.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "BoolOp", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BoolOp\n    def get_children(self):\n        yield from self.values\n", "tokens": ["astroid", "nodes", "node_classes", "py", "boolop", "def", "get_children", "self", "yield", "from", "self", "values"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::BoolOp.op_precedence", "file_path": "astroid/nodes/node_classes.py", "class_name": "BoolOp", "func_name": "op_precedence", "text": "文件路径: astroid/nodes/node_classes.py, 类名: BoolOp\n    def op_precedence(self):\n        return OP_PRECEDENCE[self.op]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "boolop", "def", "op_precedence", "self", "return", "op_precedence", "self", "op"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::Call.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Call", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Call\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.func: Optional[NodeNG] = None\n        \"\"\"What is being called.\"\"\"\n\n        self.args: typing.List[NodeNG] = []\n        \"\"\"The positional arguments being given to the call.\"\"\"\n\n        self.keywords: typing.List[\"Keyword\"] = []\n        \"\"\"The keyword arguments being given to the call.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "call", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "func", "optional", "nodeng", "none", "what", "is", "being", "called", "self", "args", "typing", "list", "nodeng", "the", "positional", "arguments", "being", "given", "to", "the", "call", "self", "keywords", "typing", "list", "keyword", "the", "keyword", "arguments", "being", "given", "to", "the", "call", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 144}
{"doc_id": "astroid/nodes/node_classes.py::Call.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Call", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Call\n    def postinit(\n        self,\n        func: Optional[NodeNG] = None,\n        args: Optional[typing.List[NodeNG]] = None,\n        keywords: Optional[typing.List[\"Keyword\"]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param func: What is being called.\n\n        :param args: The positional arguments being given to the call.\n\n        :param keywords: The keyword arguments being given to the call.\n        \"\"\"\n        self.func = func\n        if args is not None:\n            self.args = args\n        if keywords is not None:\n            self.keywords = keywords\n", "tokens": ["astroid", "nodes", "node_classes", "py", "call", "def", "postinit", "self", "func", "optional", "nodeng", "none", "args", "optional", "typing", "list", "nodeng", "none", "keywords", "optional", "typing", "list", "keyword", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "func", "what", "is", "being", "called", "param", "args", "the", "positional", "arguments", "being", "given", "to", "the", "call", "param", "keywords", "the", "keyword", "arguments", "being", "given", "to", "the", "call", "self", "func", "func", "if", "args", "is", "not", "none", "self", "args", "args", "if", "keywords", "is", "not", "none", "self", "keywords", "keywords"], "doc_len": 75}
{"doc_id": "astroid/nodes/node_classes.py::Call.starargs", "file_path": "astroid/nodes/node_classes.py", "class_name": "Call", "func_name": "starargs", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Call\n    def starargs(self) -> typing.List[\"Starred\"]:\n        \"\"\"The positional arguments that unpack something.\"\"\"\n        return [arg for arg in self.args if isinstance(arg, Starred)]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "call", "def", "starargs", "self", "typing", "list", "starred", "the", "positional", "arguments", "that", "unpack", "something", "return", "arg", "for", "arg", "in", "self", "args", "if", "isinstance", "arg", "starred"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_classes.py::Call.kwargs", "file_path": "astroid/nodes/node_classes.py", "class_name": "Call", "func_name": "kwargs", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Call\n    def kwargs(self) -> typing.List[\"Keyword\"]:\n        \"\"\"The keyword arguments that unpack something.\"\"\"\n        return [keyword for keyword in self.keywords if keyword.arg is None]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "call", "def", "kwargs", "self", "typing", "list", "keyword", "the", "keyword", "arguments", "that", "unpack", "something", "return", "keyword", "for", "keyword", "in", "self", "keywords", "if", "keyword", "arg", "is", "none"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::Call.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Call", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Call\n    def get_children(self):\n        yield self.func\n\n        yield from self.args\n\n        yield from self.keywords\n", "tokens": ["astroid", "nodes", "node_classes", "py", "call", "def", "get_children", "self", "yield", "self", "func", "yield", "from", "self", "args", "yield", "from", "self", "keywords"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::Compare.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Compare", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Compare\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.left: Optional[NodeNG] = None\n        \"\"\"The value at the left being applied to a comparison operator.\"\"\"\n\n        self.ops: typing.List[typing.Tuple[str, NodeNG]] = []\n        \"\"\"The remainder of the operators and their relevant right hand value.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "compare", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "left", "optional", "nodeng", "none", "the", "value", "at", "the", "left", "being", "applied", "to", "a", "comparison", "operator", "self", "ops", "typing", "list", "typing", "tuple", "str", "nodeng", "the", "remainder", "of", "the", "operators", "and", "their", "relevant", "right", "hand", "value", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 144}
{"doc_id": "astroid/nodes/node_classes.py::Compare.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Compare", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Compare\n    def postinit(\n        self,\n        left: Optional[NodeNG] = None,\n        ops: Optional[typing.List[typing.Tuple[str, NodeNG]]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param left: The value at the left being applied to a comparison\n            operator.\n\n        :param ops: The remainder of the operators\n            and their relevant right hand value.\n        \"\"\"\n        self.left = left\n        if ops is not None:\n            self.ops = ops\n", "tokens": ["astroid", "nodes", "node_classes", "py", "compare", "def", "postinit", "self", "left", "optional", "nodeng", "none", "ops", "optional", "typing", "list", "typing", "tuple", "str", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "left", "the", "value", "at", "the", "left", "being", "applied", "to", "a", "comparison", "operator", "param", "ops", "the", "remainder", "of", "the", "operators", "and", "their", "relevant", "right", "hand", "value", "self", "left", "left", "if", "ops", "is", "not", "none", "self", "ops", "ops"], "doc_len": 64}
{"doc_id": "astroid/nodes/node_classes.py::Compare.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Compare", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Compare\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        Overridden to handle the tuple fields and skip returning the operator\n        strings.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        yield self.left\n        for _, comparator in self.ops:\n            yield comparator  # we don't want the 'op'\n", "tokens": ["astroid", "nodes", "node_classes", "py", "compare", "def", "get_children", "self", "get", "the", "child", "nodes", "below", "this", "node", "overridden", "to", "handle", "the", "tuple", "fields", "and", "skip", "returning", "the", "operator", "strings", "returns", "the", "children", "rtype", "iterable", "nodeng", "yield", "self", "left", "for", "_", "comparator", "in", "self", "ops", "yield", "comparator", "we", "don", "t", "want", "the", "op"], "doc_len": 50}
{"doc_id": "astroid/nodes/node_classes.py::Compare.last_child", "file_path": "astroid/nodes/node_classes.py", "class_name": "Compare", "func_name": "last_child", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Compare\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child.\n        :rtype: NodeNG\n        \"\"\"\n        # XXX maybe if self.ops:\n        return self.ops[-1][1]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "compare", "def", "last_child", "self", "an", "optimized", "version", "of", "list", "get_children", "1", "returns", "the", "last", "child", "rtype", "nodeng", "xxx", "maybe", "if", "self", "ops", "return", "self", "ops", "1", "1"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_classes.py::Comprehension.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Comprehension", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Comprehension\n    def __init__(self, parent: Optional[NodeNG] = None) -> None:\n        \"\"\"\n        :param parent: The parent node in the syntax tree.\n        \"\"\"\n        self.target: Optional[NodeNG] = None\n        \"\"\"What is assigned to by the comprehension.\"\"\"\n\n        self.iter: Optional[NodeNG] = None\n        \"\"\"What is iterated over by the comprehension.\"\"\"\n\n        self.ifs: typing.List[NodeNG] = []\n        \"\"\"The contents of any if statements that filter the comprehension.\"\"\"\n\n        self.is_async: Optional[bool] = None\n        \"\"\"Whether this is an asynchronous comprehension or not.\"\"\"\n\n        super().__init__(parent=parent)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "comprehension", "def", "__init__", "self", "parent", "optional", "nodeng", "none", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "self", "target", "optional", "nodeng", "none", "what", "is", "assigned", "to", "by", "the", "comprehension", "self", "iter", "optional", "nodeng", "none", "what", "is", "iterated", "over", "by", "the", "comprehension", "self", "ifs", "typing", "list", "nodeng", "the", "contents", "of", "any", "if", "statements", "that", "filter", "the", "comprehension", "self", "is_async", "optional", "bool", "none", "whether", "this", "is", "an", "asynchronous", "comprehension", "or", "not", "super", "__init__", "parent", "parent"], "doc_len": 78}
{"doc_id": "astroid/nodes/node_classes.py::Comprehension.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Comprehension", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Comprehension\n    def postinit(\n        self,\n        target: Optional[NodeNG] = None,\n        iter: Optional[NodeNG] = None,\n        ifs: Optional[typing.List[NodeNG]] = None,\n        is_async: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param target: What is assigned to by the comprehension.\n\n        :param iter: What is iterated over by the comprehension.\n\n        :param ifs: The contents of any if statements that filter\n            the comprehension.\n\n        :param is_async: Whether this is an asynchronous comprehension or not.\n        \"\"\"\n        self.target = target\n        self.iter = iter\n        if ifs is not None:\n            self.ifs = ifs\n        self.is_async = is_async\n", "tokens": ["astroid", "nodes", "node_classes", "py", "comprehension", "def", "postinit", "self", "target", "optional", "nodeng", "none", "iter", "optional", "nodeng", "none", "ifs", "optional", "typing", "list", "nodeng", "none", "is_async", "optional", "bool", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "target", "what", "is", "assigned", "to", "by", "the", "comprehension", "param", "iter", "what", "is", "iterated", "over", "by", "the", "comprehension", "param", "ifs", "the", "contents", "of", "any", "if", "statements", "that", "filter", "the", "comprehension", "param", "is_async", "whether", "this", "is", "an", "asynchronous", "comprehension", "or", "not", "self", "target", "target", "self", "iter", "iter", "if", "ifs", "is", "not", "none", "self", "ifs", "ifs", "self", "is_async", "is_async"], "doc_len": 89}
{"doc_id": "astroid/nodes/node_classes.py::Comprehension.assign_type", "file_path": "astroid/nodes/node_classes.py", "class_name": "Comprehension", "func_name": "assign_type", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Comprehension\n    def assign_type(self):\n        \"\"\"The type of assignment that this node performs.\n\n        :returns: The assignment type.\n        :rtype: NodeNG\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "node_classes", "py", "comprehension", "def", "assign_type", "self", "the", "type", "of", "assignment", "that", "this", "node", "performs", "returns", "the", "assignment", "type", "rtype", "nodeng", "return", "self"], "doc_len": 24}
{"doc_id": "astroid/nodes/node_classes.py::Comprehension._get_filtered_stmts", "file_path": "astroid/nodes/node_classes.py", "class_name": "Comprehension", "func_name": "_get_filtered_stmts", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Comprehension\n    def _get_filtered_stmts(\n        self, lookup_node, node, stmts, mystmt: Optional[Statement]\n    ):\n        \"\"\"method used in filter_stmts\"\"\"\n        if self is mystmt:\n            if isinstance(lookup_node, (Const, Name)):\n                return [lookup_node], True\n\n        elif self.statement(future=True) is mystmt:\n            # original node's statement is the assignment, only keeps\n            # current node (gen exp, list comp)\n\n            return [node], True\n\n        return stmts, False\n", "tokens": ["astroid", "nodes", "node_classes", "py", "comprehension", "def", "_get_filtered_stmts", "self", "lookup_node", "node", "stmts", "mystmt", "optional", "statement", "method", "used", "in", "filter_stmts", "if", "self", "is", "mystmt", "if", "isinstance", "lookup_node", "const", "name", "return", "lookup_node", "true", "elif", "self", "statement", "future", "true", "is", "mystmt", "original", "node", "s", "statement", "is", "the", "assignment", "only", "keeps", "current", "node", "gen", "exp", "list", "comp", "return", "node", "true", "return", "stmts", "false"], "doc_len": 58}
{"doc_id": "astroid/nodes/node_classes.py::Comprehension.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Comprehension", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Comprehension\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.ifs\n", "tokens": ["astroid", "nodes", "node_classes", "py", "comprehension", "def", "get_children", "self", "yield", "self", "target", "yield", "self", "iter", "yield", "from", "self", "ifs"], "doc_len": 18}
{"doc_id": "astroid/nodes/node_classes.py::Const.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def __init__(\n        self,\n        value: typing.Any,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        kind: Optional[str] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param value: The value that the constant represents.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param kind: The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: typing.Any = value\n        \"\"\"The value that the constant represents.\"\"\"\n\n        self.kind: Optional[str] = kind  # can be None\n        \"\"\"\"The string prefix. \"u\" for u-prefixed strings and ``None`` otherwise. Python 3.8+ only.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "__init__", "self", "value", "typing", "any", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "kind", "optional", "str", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "value", "the", "value", "that", "the", "constant", "represents", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "kind", "the", "string", "prefix", "u", "for", "u", "prefixed", "strings", "and", "none", "otherwise", "python", "3", "8", "only", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "typing", "any", "value", "the", "value", "that", "the", "constant", "represents", "self", "kind", "optional", "str", "kind", "can", "be", "none", "the", "string", "prefix", "u", "for", "u", "prefixed", "strings", "and", "none", "otherwise", "python", "3", "8", "only", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 175}
{"doc_id": "astroid/nodes/node_classes.py::Const.__getattr__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "__getattr__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def __getattr__(self, name):\n        # This is needed because of Proxy's __getattr__ method.\n        # Calling object.__new__ on this class without calling\n        # __init__ would result in an infinite loop otherwise\n        # since __getattr__ is called when an attribute doesn't\n        # exist and self._proxied indirectly calls self.value\n        # and Proxy __getattr__ calls self.value\n        if name == \"value\":\n            raise AttributeError\n        return super().__getattr__(name)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "__getattr__", "self", "name", "this", "is", "needed", "because", "of", "proxy", "s", "__getattr__", "method", "calling", "object", "__new__", "on", "this", "class", "without", "calling", "__init__", "would", "result", "in", "an", "infinite", "loop", "otherwise", "since", "__getattr__", "is", "called", "when", "an", "attribute", "doesn", "t", "exist", "and", "self", "_proxied", "indirectly", "calls", "self", "value", "and", "proxy", "__getattr__", "calls", "self", "value", "if", "name", "value", "raise", "attributeerror", "return", "super", "__getattr__", "name"], "doc_len": 66}
{"doc_id": "astroid/nodes/node_classes.py::Const.getitem", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "getitem", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def getitem(self, index, context=None):\n        \"\"\"Get an item from this node if subscriptable.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        \"\"\"\n        if isinstance(index, Const):\n            index_value = index.value\n        elif isinstance(index, Slice):\n            index_value = _infer_slice(index, context=context)\n\n        else:\n            raise AstroidTypeError(\n                f\"Could not use type {type(index)} as subscript index\"\n            )\n\n        try:\n            if isinstance(self.value, (str, bytes)):\n                return Const(self.value[index_value])\n        except IndexError as exc:\n            raise AstroidIndexError(\n                message=\"Index {index!r} out of range\",\n                node=self,\n                index=index,\n                context=context,\n            ) from exc\n        except TypeError as exc:\n            raise AstroidTypeError(\n                message=\"Type error {error!r}\", node=self, index=index, context=context\n            ) from exc\n\n        raise AstroidTypeError(f\"{self!r} (value={self.value})\")\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "getitem", "self", "index", "context", "none", "get", "an", "item", "from", "this", "node", "if", "subscriptable", "param", "index", "the", "node", "to", "use", "as", "a", "subscript", "index", "type", "index", "const", "or", "slice", "raises", "astroidtypeerror", "when", "the", "given", "index", "cannot", "be", "used", "as", "a", "subscript", "index", "or", "if", "this", "node", "is", "not", "subscriptable", "if", "isinstance", "index", "const", "index_value", "index", "value", "elif", "isinstance", "index", "slice", "index_value", "_infer_slice", "index", "context", "context", "else", "raise", "astroidtypeerror", "f", "could", "not", "use", "type", "type", "index", "as", "subscript", "index", "try", "if", "isinstance", "self", "value", "str", "bytes", "return", "const", "self", "value", "index_value", "except", "indexerror", "as", "exc", "raise", "astroidindexerror", "message", "index", "index", "r", "out", "of", "range", "node", "self", "index", "index", "context", "context", "from", "exc", "except", "typeerror", "as", "exc", "raise", "astroidtypeerror", "message", "type", "error", "error", "r", "node", "self", "index", "index", "context", "context", "from", "exc", "raise", "astroidtypeerror", "f", "self", "r", "value", "self", "value"], "doc_len": 143}
{"doc_id": "astroid/nodes/node_classes.py::Const.has_dynamic_getattr", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "has_dynamic_getattr", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def has_dynamic_getattr(self):\n        \"\"\"Check if the node has a custom __getattr__ or __getattribute__.\n\n        :returns: True if the class has a custom\n            __getattr__ or __getattribute__, False otherwise.\n            For a :class:`Const` this is always ``False``.\n        :rtype: bool\n        \"\"\"\n        return False\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "has_dynamic_getattr", "self", "check", "if", "the", "node", "has", "a", "custom", "__getattr__", "or", "__getattribute__", "returns", "true", "if", "the", "class", "has", "a", "custom", "__getattr__", "or", "__getattribute__", "false", "otherwise", "for", "a", "class", "const", "this", "is", "always", "false", "rtype", "bool", "return", "false"], "doc_len": 43}
{"doc_id": "astroid/nodes/node_classes.py::Const.itered", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "itered", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def itered(self):\n        \"\"\"An iterator over the elements this node contains.\n\n        :returns: The contents of this node.\n        :rtype: iterable(Const)\n\n        :raises TypeError: If this node does not represent something that is iterable.\n        \"\"\"\n        if isinstance(self.value, str):\n            return [const_factory(elem) for elem in self.value]\n        raise TypeError(f\"Cannot iterate over type {type(self.value)!r}\")\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "itered", "self", "an", "iterator", "over", "the", "elements", "this", "node", "contains", "returns", "the", "contents", "of", "this", "node", "rtype", "iterable", "const", "raises", "typeerror", "if", "this", "node", "does", "not", "represent", "something", "that", "is", "iterable", "if", "isinstance", "self", "value", "str", "return", "const_factory", "elem", "for", "elem", "in", "self", "value", "raise", "typeerror", "f", "cannot", "iterate", "over", "type", "type", "self", "value", "r"], "doc_len": 61}
{"doc_id": "astroid/nodes/node_classes.py::Const.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return self._proxied.qname()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "self", "_proxied", "qname"], "doc_len": 30}
{"doc_id": "astroid/nodes/node_classes.py::Const.bool_value", "file_path": "astroid/nodes/node_classes.py", "class_name": "Const", "func_name": "bool_value", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Const\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.value)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "const", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "rtype", "bool", "return", "bool", "self", "value"], "doc_len": 30}
{"doc_id": "astroid/nodes/node_classes.py::Decorators.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Decorators", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Decorators\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.nodes: typing.List[NodeNG]\n        \"\"\"The decorators that this node contains.\n\n        :type: list(Name or Call) or None\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "decorators", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "nodes", "typing", "list", "nodeng", "the", "decorators", "that", "this", "node", "contains", "type", "list", "name", "or", "call", "or", "none", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 127}
{"doc_id": "astroid/nodes/node_classes.py::Decorators.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Decorators", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Decorators\n    def postinit(self, nodes: typing.List[NodeNG]) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param nodes: The decorators that this node contains.\n        :type nodes: list(Name or Call)\n        \"\"\"\n        self.nodes = nodes\n", "tokens": ["astroid", "nodes", "node_classes", "py", "decorators", "def", "postinit", "self", "nodes", "typing", "list", "nodeng", "none", "do", "some", "setup", "after", "initialisation", "param", "nodes", "the", "decorators", "that", "this", "node", "contains", "type", "nodes", "list", "name", "or", "call", "self", "nodes", "nodes"], "doc_len": 35}
{"doc_id": "astroid/nodes/node_classes.py::Decorators.scope", "file_path": "astroid/nodes/node_classes.py", "class_name": "Decorators", "func_name": "scope", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Decorators\n    def scope(self) -> \"LocalsDictNodeNG\":\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        # skip the function node to go directly to the upper level scope\n        if not self.parent:\n            raise ParentMissingError(target=self)\n        if not self.parent.parent:\n            raise ParentMissingError(target=self.parent)\n        return self.parent.parent.scope()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "decorators", "def", "scope", "self", "localsdictnodeng", "the", "first", "parent", "node", "defining", "a", "new", "scope", "these", "can", "be", "module", "functiondef", "classdef", "lambda", "or", "generatorexp", "nodes", "returns", "the", "first", "parent", "scope", "node", "skip", "the", "function", "node", "to", "go", "directly", "to", "the", "upper", "level", "scope", "if", "not", "self", "parent", "raise", "parentmissingerror", "target", "self", "if", "not", "self", "parent", "parent", "raise", "parentmissingerror", "target", "self", "parent", "return", "self", "parent", "parent", "scope"], "doc_len": 68}
{"doc_id": "astroid/nodes/node_classes.py::Decorators.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Decorators", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Decorators\n    def get_children(self):\n        yield from self.nodes\n", "tokens": ["astroid", "nodes", "node_classes", "py", "decorators", "def", "get_children", "self", "yield", "from", "self", "nodes"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::DelAttr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "DelAttr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: DelAttr\n    def __init__(\n        self,\n        attrname: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param attrname: The name of the attribute that is being deleted.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.expr: Optional[NodeNG] = None\n        \"\"\"The name that this node represents.\n\n        :type: Name or None\n        \"\"\"\n\n        self.attrname: Optional[str] = attrname\n        \"\"\"The name of the attribute that is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delattr", "def", "__init__", "self", "attrname", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "attrname", "the", "name", "of", "the", "attribute", "that", "is", "being", "deleted", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "expr", "optional", "nodeng", "none", "the", "name", "that", "this", "node", "represents", "type", "name", "or", "none", "self", "attrname", "optional", "str", "attrname", "the", "name", "of", "the", "attribute", "that", "is", "being", "deleted", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 153}
{"doc_id": "astroid/nodes/node_classes.py::DelAttr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "DelAttr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: DelAttr\n    def postinit(self, expr: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param expr: The name that this node represents.\n        :type expr: Name or None\n        \"\"\"\n        self.expr = expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delattr", "def", "postinit", "self", "expr", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "expr", "the", "name", "that", "this", "node", "represents", "type", "expr", "name", "or", "none", "self", "expr", "expr"], "doc_len": 34}
{"doc_id": "astroid/nodes/node_classes.py::DelAttr.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "DelAttr", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: DelAttr\n    def get_children(self):\n        yield self.expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delattr", "def", "get_children", "self", "yield", "self", "expr"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::Delete.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Delete", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Delete\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.targets: typing.List[NodeNG] = []\n        \"\"\"What is being deleted.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delete", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "targets", "typing", "list", "nodeng", "what", "is", "being", "deleted", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 118}
{"doc_id": "astroid/nodes/node_classes.py::Delete.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Delete", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Delete\n    def postinit(self, targets: Optional[typing.List[NodeNG]] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param targets: What is being deleted.\n        \"\"\"\n        if targets is not None:\n            self.targets = targets\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delete", "def", "postinit", "self", "targets", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "targets", "what", "is", "being", "deleted", "if", "targets", "is", "not", "none", "self", "targets", "targets"], "doc_len": 34}
{"doc_id": "astroid/nodes/node_classes.py::Delete.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Delete", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Delete\n    def get_children(self):\n        yield from self.targets\n", "tokens": ["astroid", "nodes", "node_classes", "py", "delete", "def", "get_children", "self", "yield", "from", "self", "targets"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::Dict.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.items: typing.List[typing.Tuple[NodeNG, NodeNG]] = []\n        \"\"\"The key-value pairs contained in the dictionary.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "items", "typing", "list", "typing", "tuple", "nodeng", "nodeng", "the", "key", "value", "pairs", "contained", "in", "the", "dictionary", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 125}
{"doc_id": "astroid/nodes/node_classes.py::Dict.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def postinit(self, items: typing.List[typing.Tuple[NodeNG, NodeNG]]) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The key-value pairs contained in the dictionary.\n        \"\"\"\n        self.items = items\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "postinit", "self", "items", "typing", "list", "typing", "tuple", "nodeng", "nodeng", "none", "do", "some", "setup", "after", "initialisation", "param", "items", "the", "key", "value", "pairs", "contained", "in", "the", "dictionary", "self", "items", "items"], "doc_len": 34}
{"doc_id": "astroid/nodes/node_classes.py::Dict.from_elements", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "from_elements", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def from_elements(cls, items=None):\n        \"\"\"Create a :class:`Dict` of constants from a live dictionary.\n\n        :param items: The items to store in the node.\n        :type items: dict\n\n        :returns: The created dictionary node.\n        :rtype: Dict\n        \"\"\"\n        node = cls()\n        if items is None:\n            node.items = []\n        else:\n            node.items = [\n                (const_factory(k), const_factory(v) if _is_const(v) else v)\n                for k, v in items.items()\n                # The keys need to be constants\n                if _is_const(k)\n            ]\n        return node\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "from_elements", "cls", "items", "none", "create", "a", "class", "dict", "of", "constants", "from", "a", "live", "dictionary", "param", "items", "the", "items", "to", "store", "in", "the", "node", "type", "items", "dict", "returns", "the", "created", "dictionary", "node", "rtype", "dict", "node", "cls", "if", "items", "is", "none", "node", "items", "else", "node", "items", "const_factory", "k", "const_factory", "v", "if", "_is_const", "v", "else", "v", "for", "k", "v", "in", "items", "items", "the", "keys", "need", "to", "be", "constants", "if", "_is_const", "k", "return", "node"], "doc_len": 76}
{"doc_id": "astroid/nodes/node_classes.py::Dict.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.dict\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "dict"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::Dict.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def get_children(self):\n        \"\"\"Get the key and value nodes below this node.\n\n        Children are returned in the order that they are defined in the source\n        code, key first then the value.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for key, value in self.items:\n            yield key\n            yield value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "get_children", "self", "get", "the", "key", "and", "value", "nodes", "below", "this", "node", "children", "are", "returned", "in", "the", "order", "that", "they", "are", "defined", "in", "the", "source", "code", "key", "first", "then", "the", "value", "returns", "the", "children", "rtype", "iterable", "nodeng", "for", "key", "value", "in", "self", "items", "yield", "key", "yield", "value"], "doc_len": 52}
{"doc_id": "astroid/nodes/node_classes.py::Dict.last_child", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "last_child", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def last_child(self):\n        \"\"\"An optimized version of list(get_children())[-1]\n\n        :returns: The last child, or None if no children exist.\n        :rtype: NodeNG or None\n        \"\"\"\n        if self.items:\n            return self.items[-1][1]\n        return None\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "last_child", "self", "an", "optimized", "version", "of", "list", "get_children", "1", "returns", "the", "last", "child", "or", "none", "if", "no", "children", "exist", "rtype", "nodeng", "or", "none", "if", "self", "items", "return", "self", "items", "1", "1", "return", "none"], "doc_len": 39}
{"doc_id": "astroid/nodes/node_classes.py::Dict.itered", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "itered", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def itered(self):\n        \"\"\"An iterator over the keys this node contains.\n\n        :returns: The keys of this node.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        return [key for (key, _) in self.items]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "itered", "self", "an", "iterator", "over", "the", "keys", "this", "node", "contains", "returns", "the", "keys", "of", "this", "node", "rtype", "iterable", "nodeng", "return", "key", "for", "key", "_", "in", "self", "items"], "doc_len": 33}
{"doc_id": "astroid/nodes/node_classes.py::Dict.getitem", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "getitem", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def getitem(self, index, context=None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n\n        :raises AstroidTypeError: When the given index cannot be used as a\n            subscript index, or if this node is not subscriptable.\n        :raises AstroidIndexError: If the given index does not exist in the\n            dictionary.\n        \"\"\"\n        for key, value in self.items:\n            # TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.\n            if isinstance(key, DictUnpack):\n                try:\n                    return value.getitem(index, context)\n                except (AstroidTypeError, AstroidIndexError):\n                    continue\n            for inferredkey in key.infer(context):\n                if inferredkey is util.Uninferable:\n                    continue\n                if isinstance(inferredkey, Const) and isinstance(index, Const):\n                    if inferredkey.value == index.value:\n                        return value\n\n        raise AstroidIndexError(index)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "getitem", "self", "index", "context", "none", "get", "an", "item", "from", "this", "node", "param", "index", "the", "node", "to", "use", "as", "a", "subscript", "index", "type", "index", "const", "or", "slice", "raises", "astroidtypeerror", "when", "the", "given", "index", "cannot", "be", "used", "as", "a", "subscript", "index", "or", "if", "this", "node", "is", "not", "subscriptable", "raises", "astroidindexerror", "if", "the", "given", "index", "does", "not", "exist", "in", "the", "dictionary", "for", "key", "value", "in", "self", "items", "todo", "cpopa", "no", "support", "for", "overriding", "yet", "1", "2", "1", "3", "if", "isinstance", "key", "dictunpack", "try", "return", "value", "getitem", "index", "context", "except", "astroidtypeerror", "astroidindexerror", "continue", "for", "inferredkey", "in", "key", "infer", "context", "if", "inferredkey", "is", "util", "uninferable", "continue", "if", "isinstance", "inferredkey", "const", "and", "isinstance", "index", "const", "if", "inferredkey", "value", "index", "value", "return", "value", "raise", "astroidindexerror", "index"], "doc_len": 125}
{"doc_id": "astroid/nodes/node_classes.py::Dict.bool_value", "file_path": "astroid/nodes/node_classes.py", "class_name": "Dict", "func_name": "bool_value", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Dict\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n        :rtype: bool\n        \"\"\"\n        return bool(self.items)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "dict", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "rtype", "bool", "return", "bool", "self", "items"], "doc_len": 30}
{"doc_id": "astroid/nodes/node_classes.py::Expr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Expr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Expr\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None\n        \"\"\"What the expression does.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "expr", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "what", "the", "expression", "does", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 118}
{"doc_id": "astroid/nodes/node_classes.py::Expr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Expr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Expr\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: What the expression does.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "expr", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "what", "the", "expression", "does", "self", "value", "value"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::Expr.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Expr", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Expr\n    def get_children(self):\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "expr", "def", "get_children", "self", "yield", "self", "value"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::Expr._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "Expr", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Expr\n    def _get_yield_nodes_skip_lambdas(self):\n        if not self.value.is_lambda:\n            yield from self.value._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "expr", "def", "_get_yield_nodes_skip_lambdas", "self", "if", "not", "self", "value", "is_lambda", "yield", "from", "self", "value", "_get_yield_nodes_skip_lambdas"], "doc_len": 18}
{"doc_id": "astroid/nodes/node_classes.py::ExceptHandler.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "ExceptHandler", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ExceptHandler\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.type: Optional[NodeNG] = None  # can be None\n        \"\"\"The types that the block handles.\n\n        :type: Tuple or NodeNG or None\n        \"\"\"\n\n        self.name: Optional[AssignName] = None  # can be None\n        \"\"\"The name that the caught exception is assigned to.\"\"\"\n\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "excepthandler", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "type", "optional", "nodeng", "none", "can", "be", "none", "the", "types", "that", "the", "block", "handles", "type", "tuple", "or", "nodeng", "or", "none", "self", "name", "optional", "assignname", "none", "can", "be", "none", "the", "name", "that", "the", "caught", "exception", "is", "assigned", "to", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "block", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 156}
{"doc_id": "astroid/nodes/node_classes.py::ExceptHandler.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "ExceptHandler", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ExceptHandler\n    def get_children(self):\n        if self.type is not None:\n            yield self.type\n\n        if self.name is not None:\n            yield self.name\n\n        yield from self.body\n", "tokens": ["astroid", "nodes", "node_classes", "py", "excepthandler", "def", "get_children", "self", "if", "self", "type", "is", "not", "none", "yield", "self", "type", "if", "self", "name", "is", "not", "none", "yield", "self", "name", "yield", "from", "self", "body"], "doc_len": 30}
{"doc_id": "astroid/nodes/node_classes.py::ExceptHandler.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "ExceptHandler", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ExceptHandler\n    def postinit(\n        self,\n        type: Optional[NodeNG] = None,\n        name: Optional[AssignName] = None,\n        body: Optional[typing.List[NodeNG]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param type: The types that the block handles.\n        :type type: Tuple or NodeNG or None\n\n        :param name: The name that the caught exception is assigned to.\n\n        :param body:The contents of the block.\n        \"\"\"\n        self.type = type\n        self.name = name\n        if body is not None:\n            self.body = body\n", "tokens": ["astroid", "nodes", "node_classes", "py", "excepthandler", "def", "postinit", "self", "type", "optional", "nodeng", "none", "name", "optional", "assignname", "none", "body", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "type", "the", "types", "that", "the", "block", "handles", "type", "type", "tuple", "or", "nodeng", "or", "none", "param", "name", "the", "name", "that", "the", "caught", "exception", "is", "assigned", "to", "param", "body", "the", "contents", "of", "the", "block", "self", "type", "type", "self", "name", "name", "if", "body", "is", "not", "none", "self", "body", "body"], "doc_len": 75}
{"doc_id": "astroid/nodes/node_classes.py::ExceptHandler.blockstart_tolineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "ExceptHandler", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ExceptHandler\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        if self.name:\n            return self.name.tolineno\n        if self.type:\n            return self.type.tolineno\n        return self.lineno\n", "tokens": ["astroid", "nodes", "node_classes", "py", "excepthandler", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "if", "self", "name", "return", "self", "name", "tolineno", "if", "self", "type", "return", "self", "type", "tolineno", "return", "self", "lineno"], "doc_len": 37}
{"doc_id": "astroid/nodes/node_classes.py::ExceptHandler.catch", "file_path": "astroid/nodes/node_classes.py", "class_name": "ExceptHandler", "func_name": "catch", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ExceptHandler\n    def catch(self, exceptions: Optional[typing.List[str]]) -> bool:\n        \"\"\"Check if this node handles any of the given\n\n        :param exceptions: The names of the exceptions to check for.\n        \"\"\"\n        if self.type is None or exceptions is None:\n            return True\n        return any(node.name in exceptions for node in self.type._get_name_nodes())\n", "tokens": ["astroid", "nodes", "node_classes", "py", "excepthandler", "def", "catch", "self", "exceptions", "optional", "typing", "list", "str", "bool", "check", "if", "this", "node", "handles", "any", "of", "the", "given", "param", "exceptions", "the", "names", "of", "the", "exceptions", "to", "check", "for", "if", "self", "type", "is", "none", "or", "exceptions", "is", "none", "return", "true", "return", "any", "node", "name", "in", "exceptions", "for", "node", "in", "self", "type", "_get_name_nodes"], "doc_len": 56}
{"doc_id": "astroid/nodes/node_classes.py::For.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "For", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: For\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: Optional[NodeNG] = None\n        \"\"\"What the loop assigns to.\"\"\"\n\n        self.iter: Optional[NodeNG] = None\n        \"\"\"What the loop iterates over.\"\"\"\n\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the body of the loop.\"\"\"\n\n        self.orelse: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``else`` block of the loop.\"\"\"\n\n        self.type_annotation: Optional[NodeNG] = None  # can be None\n        \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "for", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "target", "optional", "nodeng", "none", "what", "the", "loop", "assigns", "to", "self", "iter", "optional", "nodeng", "none", "what", "the", "loop", "iterates", "over", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "body", "of", "the", "loop", "self", "orelse", "typing", "list", "nodeng", "the", "contents", "of", "the", "else", "block", "of", "the", "loop", "self", "type_annotation", "optional", "nodeng", "none", "can", "be", "none", "if", "present", "this", "will", "contain", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 177}
{"doc_id": "astroid/nodes/node_classes.py::For.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "For", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: For\n    def postinit(\n        self,\n        target: Optional[NodeNG] = None,\n        iter: Optional[NodeNG] = None,\n        body: Optional[typing.List[NodeNG]] = None,\n        orelse: Optional[typing.List[NodeNG]] = None,\n        type_annotation: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param target: What the loop assigns to.\n\n        :param iter: What the loop iterates over.\n\n        :param body: The contents of the body of the loop.\n\n        :param orelse: The contents of the ``else`` block of the loop.\n        \"\"\"\n        self.target = target\n        self.iter = iter\n        if body is not None:\n            self.body = body\n        if orelse is not None:\n            self.orelse = orelse\n        self.type_annotation = type_annotation\n", "tokens": ["astroid", "nodes", "node_classes", "py", "for", "def", "postinit", "self", "target", "optional", "nodeng", "none", "iter", "optional", "nodeng", "none", "body", "optional", "typing", "list", "nodeng", "none", "orelse", "optional", "typing", "list", "nodeng", "none", "type_annotation", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "target", "what", "the", "loop", "assigns", "to", "param", "iter", "what", "the", "loop", "iterates", "over", "param", "body", "the", "contents", "of", "the", "body", "of", "the", "loop", "param", "orelse", "the", "contents", "of", "the", "else", "block", "of", "the", "loop", "self", "target", "target", "self", "iter", "iter", "if", "body", "is", "not", "none", "self", "body", "body", "if", "orelse", "is", "not", "none", "self", "orelse", "orelse", "self", "type_annotation", "type_annotation"], "doc_len": 98}
{"doc_id": "astroid/nodes/node_classes.py::For.blockstart_tolineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "For", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: For\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.iter.tolineno\n", "tokens": ["astroid", "nodes", "node_classes", "py", "for", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "return", "self", "iter", "tolineno"], "doc_len": 24}
{"doc_id": "astroid/nodes/node_classes.py::For.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "For", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: For\n    def get_children(self):\n        yield self.target\n        yield self.iter\n\n        yield from self.body\n        yield from self.orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "for", "def", "get_children", "self", "yield", "self", "target", "yield", "self", "iter", "yield", "from", "self", "body", "yield", "from", "self", "orelse"], "doc_len": 22}
{"doc_id": "astroid/nodes/node_classes.py::Await.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Await", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Await\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None\n        \"\"\"What to wait for.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "await", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "what", "to", "wait", "for", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 118}
{"doc_id": "astroid/nodes/node_classes.py::Await.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Await", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Await\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: What to wait for.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "await", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "what", "to", "wait", "for", "self", "value", "value"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::Await.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Await", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Await\n    def get_children(self):\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "await", "def", "get_children", "self", "yield", "self", "value"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::ImportFrom.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "ImportFrom", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: ImportFrom\n    def __init__(\n        self,\n        fromname: Optional[str],\n        names: typing.List[typing.Tuple[str, Optional[str]]],\n        level: Optional[int] = 0,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param fromname: The module that is being imported from.\n\n        :param names: What is being imported from the module.\n\n        :param level: The level of relative import.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.modname: Optional[str] = fromname  # can be None\n        \"\"\"The module that is being imported from.\n\n        This is ``None`` for relative imports.\n        \"\"\"\n\n        self.names: typing.List[typing.Tuple[str, Optional[str]]] = names\n        \"\"\"What is being imported from the module.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        # TODO When is 'level' None?\n        self.level: Optional[int] = level  # can be None\n        \"\"\"The level of relative import.\n\n        Essentially this is the number of dots in the import.\n        This is always 0 for absolute imports.\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "importfrom", "def", "__init__", "self", "fromname", "optional", "str", "names", "typing", "list", "typing", "tuple", "str", "optional", "str", "level", "optional", "int", "0", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "fromname", "the", "module", "that", "is", "being", "imported", "from", "param", "names", "what", "is", "being", "imported", "from", "the", "module", "param", "level", "the", "level", "of", "relative", "import", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "modname", "optional", "str", "fromname", "can", "be", "none", "the", "module", "that", "is", "being", "imported", "from", "this", "is", "none", "for", "relative", "imports", "self", "names", "typing", "list", "typing", "tuple", "str", "optional", "str", "names", "what", "is", "being", "imported", "from", "the", "module", "each", "entry", "is", "a", "class", "tuple", "of", "the", "name", "being", "imported", "and", "the", "alias", "that", "the", "name", "is", "assigned", "to", "if", "any", "todo", "when", "is", "level", "none", "self", "level", "optional", "int", "level", "can", "be", "none", "the", "level", "of", "relative", "import", "essentially", "this", "is", "the", "number", "of", "dots", "in", "the", "import", "this", "is", "always", "0", "for", "absolute", "imports", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 244}
{"doc_id": "astroid/nodes/node_classes.py::Attribute.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Attribute", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Attribute\n    def __init__(\n        self,\n        attrname: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param attrname: The name of the attribute.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.expr: Optional[NodeNG] = None\n        \"\"\"The name that this node represents.\n\n        :type: Name or None\n        \"\"\"\n\n        self.attrname: Optional[str] = attrname\n        \"\"\"The name of the attribute.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "attribute", "def", "__init__", "self", "attrname", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "attrname", "the", "name", "of", "the", "attribute", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "expr", "optional", "nodeng", "none", "the", "name", "that", "this", "node", "represents", "type", "name", "or", "none", "self", "attrname", "optional", "str", "attrname", "the", "name", "of", "the", "attribute", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 145}
{"doc_id": "astroid/nodes/node_classes.py::Attribute.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Attribute", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Attribute\n    def postinit(self, expr: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param expr: The name that this node represents.\n        :type expr: Name or None\n        \"\"\"\n        self.expr = expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "attribute", "def", "postinit", "self", "expr", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "expr", "the", "name", "that", "this", "node", "represents", "type", "expr", "name", "or", "none", "self", "expr", "expr"], "doc_len": 34}
{"doc_id": "astroid/nodes/node_classes.py::Attribute.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Attribute", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Attribute\n    def get_children(self):\n        yield self.expr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "attribute", "def", "get_children", "self", "yield", "self", "expr"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::Global.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Global", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Global\n    def __init__(\n        self,\n        names: typing.List[str],\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as global.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: typing.List[str] = names\n        \"\"\"The names being declared as global.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "global", "def", "__init__", "self", "names", "typing", "list", "str", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "names", "the", "names", "being", "declared", "as", "global", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "names", "typing", "list", "str", "names", "the", "names", "being", "declared", "as", "global", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 133}
{"doc_id": "astroid/nodes/node_classes.py::Global._infer_name", "file_path": "astroid/nodes/node_classes.py", "class_name": "Global", "func_name": "_infer_name", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Global\n    def _infer_name(self, frame, name):\n        return name\n", "tokens": ["astroid", "nodes", "node_classes", "py", "global", "def", "_infer_name", "self", "frame", "name", "return", "name"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::If.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.test: Optional[NodeNG] = None\n        \"\"\"The condition that the statement tests.\"\"\"\n\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the block.\"\"\"\n\n        self.orelse: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        self.is_orelse: bool = False\n        \"\"\"Whether the if-statement is the orelse-block of another if statement.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "test", "optional", "nodeng", "none", "the", "condition", "that", "the", "statement", "tests", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "block", "self", "orelse", "typing", "list", "nodeng", "the", "contents", "of", "the", "else", "block", "self", "is_orelse", "bool", "false", "whether", "the", "if", "statement", "is", "the", "orelse", "block", "of", "another", "if", "statement", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 157}
{"doc_id": "astroid/nodes/node_classes.py::If.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def postinit(\n        self,\n        test: Optional[NodeNG] = None,\n        body: Optional[typing.List[NodeNG]] = None,\n        orelse: Optional[typing.List[NodeNG]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param test: The condition that the statement tests.\n\n        :param body: The contents of the block.\n\n        :param orelse: The contents of the ``else`` block.\n        \"\"\"\n        self.test = test\n        if body is not None:\n            self.body = body\n        if orelse is not None:\n            self.orelse = orelse\n        if isinstance(self.parent, If) and self in self.parent.orelse:\n            self.is_orelse = True\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "postinit", "self", "test", "optional", "nodeng", "none", "body", "optional", "typing", "list", "nodeng", "none", "orelse", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "test", "the", "condition", "that", "the", "statement", "tests", "param", "body", "the", "contents", "of", "the", "block", "param", "orelse", "the", "contents", "of", "the", "else", "block", "self", "test", "test", "if", "body", "is", "not", "none", "self", "body", "body", "if", "orelse", "is", "not", "none", "self", "orelse", "orelse", "if", "isinstance", "self", "parent", "if", "and", "self", "in", "self", "parent", "orelse", "self", "is_orelse", "true"], "doc_len": 86}
{"doc_id": "astroid/nodes/node_classes.py::If.blockstart_tolineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "return", "self", "test", "tolineno"], "doc_len": 24}
{"doc_id": "astroid/nodes/node_classes.py::If.block_range", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "block_range", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        :rtype: tuple(int, int)\n        \"\"\"\n        if lineno == self.body[0].fromlineno:\n            return lineno, lineno\n        if lineno <= self.body[-1].tolineno:\n            return lineno, self.body[-1].tolineno\n        return self._elsed_block_range(lineno, self.orelse, self.body[0].fromlineno - 1)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "the", "line", "number", "to", "start", "the", "range", "at", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "starting", "at", "the", "given", "line", "number", "rtype", "tuple", "int", "int", "if", "lineno", "self", "body", "0", "fromlineno", "return", "lineno", "lineno", "if", "lineno", "self", "body", "1", "tolineno", "return", "lineno", "self", "body", "1", "tolineno", "return", "self", "_elsed_block_range", "lineno", "self", "orelse", "self", "body", "0", "fromlineno", "1"], "doc_len": 88}
{"doc_id": "astroid/nodes/node_classes.py::If.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "get_children", "self", "yield", "self", "test", "yield", "from", "self", "body", "yield", "from", "self", "orelse"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::If.has_elif_block", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "has_elif_block", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def has_elif_block(self):\n        return len(self.orelse) == 1 and isinstance(self.orelse[0], If)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "has_elif_block", "self", "return", "len", "self", "orelse", "1", "and", "isinstance", "self", "orelse", "0", "if"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::If._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"An If node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "_get_yield_nodes_skip_lambdas", "self", "an", "if", "node", "can", "contain", "a", "yield", "node", "in", "the", "test", "yield", "from", "self", "test", "_get_yield_nodes_skip_lambdas", "yield", "from", "super", "_get_yield_nodes_skip_lambdas"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_classes.py::If.is_sys_guard", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "is_sys_guard", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def is_sys_guard(self) -> bool:\n        \"\"\"Return True if IF stmt is a sys.version_info guard.\n\n        >>> import astroid\n        >>> node = astroid.extract_node('''\n        import sys\n        if sys.version_info > (3, 8):\n            from typing import Literal\n        else:\n            from typing_extensions import Literal\n        ''')\n        >>> node.is_sys_guard()\n        True\n        \"\"\"\n        warnings.warn(\n            \"The 'is_sys_guard' function is deprecated and will be removed in astroid 3.0.0 \"\n            \"It has been moved to pylint and can be imported from 'pylint.checkers.utils' \"\n            \"starting with pylint 2.12\",\n            DeprecationWarning,\n        )\n        if isinstance(self.test, Compare):\n            value = self.test.left\n            if isinstance(value, Subscript):\n                value = value.value\n            if isinstance(value, Attribute) and value.as_string() == \"sys.version_info\":\n                return True\n\n        return False\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "is_sys_guard", "self", "bool", "return", "true", "if", "if", "stmt", "is", "a", "sys", "version_info", "guard", "import", "astroid", "node", "astroid", "extract_node", "import", "sys", "if", "sys", "version_info", "3", "8", "from", "typing", "import", "literal", "else", "from", "typing_extensions", "import", "literal", "node", "is_sys_guard", "true", "warnings", "warn", "the", "is_sys_guard", "function", "is", "deprecated", "and", "will", "be", "removed", "in", "astroid", "3", "0", "0", "it", "has", "been", "moved", "to", "pylint", "and", "can", "be", "imported", "from", "pylint", "checkers", "utils", "starting", "with", "pylint", "2", "12", "deprecationwarning", "if", "isinstance", "self", "test", "compare", "value", "self", "test", "left", "if", "isinstance", "value", "subscript", "value", "value", "value", "if", "isinstance", "value", "attribute", "and", "value", "as_string", "sys", "version_info", "return", "true", "return", "false"], "doc_len": 108}
{"doc_id": "astroid/nodes/node_classes.py::If.is_typing_guard", "file_path": "astroid/nodes/node_classes.py", "class_name": "If", "func_name": "is_typing_guard", "text": "文件路径: astroid/nodes/node_classes.py, 类名: If\n    def is_typing_guard(self) -> bool:\n        \"\"\"Return True if IF stmt is a typing guard.\n\n        >>> import astroid\n        >>> node = astroid.extract_node('''\n        from typing import TYPE_CHECKING\n        if TYPE_CHECKING:\n            from xyz import a\n        ''')\n        >>> node.is_typing_guard()\n        True\n        \"\"\"\n        warnings.warn(\n            \"The 'is_typing_guard' function is deprecated and will be removed in astroid 3.0.0 \"\n            \"It has been moved to pylint and can be imported from 'pylint.checkers.utils' \"\n            \"starting with pylint 2.12\",\n            DeprecationWarning,\n        )\n        return isinstance(\n            self.test, (Name, Attribute)\n        ) and self.test.as_string().endswith(\"TYPE_CHECKING\")\n", "tokens": ["astroid", "nodes", "node_classes", "py", "if", "def", "is_typing_guard", "self", "bool", "return", "true", "if", "if", "stmt", "is", "a", "typing", "guard", "import", "astroid", "node", "astroid", "extract_node", "from", "typing", "import", "type_checking", "if", "type_checking", "from", "xyz", "import", "a", "node", "is_typing_guard", "true", "warnings", "warn", "the", "is_typing_guard", "function", "is", "deprecated", "and", "will", "be", "removed", "in", "astroid", "3", "0", "0", "it", "has", "been", "moved", "to", "pylint", "and", "can", "be", "imported", "from", "pylint", "checkers", "utils", "starting", "with", "pylint", "2", "12", "deprecationwarning", "return", "isinstance", "self", "test", "name", "attribute", "and", "self", "test", "as_string", "endswith", "type_checking"], "doc_len": 84}
{"doc_id": "astroid/nodes/node_classes.py::IfExp.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "IfExp", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: IfExp\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.test: Optional[NodeNG] = None\n        \"\"\"The condition that the statement tests.\"\"\"\n\n        self.body: Optional[NodeNG] = None\n        \"\"\"The contents of the block.\"\"\"\n\n        self.orelse: Optional[NodeNG] = None\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "ifexp", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "test", "optional", "nodeng", "none", "the", "condition", "that", "the", "statement", "tests", "self", "body", "optional", "nodeng", "none", "the", "contents", "of", "the", "block", "self", "orelse", "optional", "nodeng", "none", "the", "contents", "of", "the", "else", "block", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 141}
{"doc_id": "astroid/nodes/node_classes.py::IfExp.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "IfExp", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: IfExp\n    def postinit(\n        self,\n        test: Optional[NodeNG] = None,\n        body: Optional[NodeNG] = None,\n        orelse: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param test: The condition that the statement tests.\n\n        :param body: The contents of the block.\n\n        :param orelse: The contents of the ``else`` block.\n        \"\"\"\n        self.test = test\n        self.body = body\n        self.orelse = orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "ifexp", "def", "postinit", "self", "test", "optional", "nodeng", "none", "body", "optional", "nodeng", "none", "orelse", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "test", "the", "condition", "that", "the", "statement", "tests", "param", "body", "the", "contents", "of", "the", "block", "param", "orelse", "the", "contents", "of", "the", "else", "block", "self", "test", "test", "self", "body", "body", "self", "orelse", "orelse"], "doc_len": 58}
{"doc_id": "astroid/nodes/node_classes.py::IfExp.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "IfExp", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: IfExp\n    def get_children(self):\n        yield self.test\n        yield self.body\n        yield self.orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "ifexp", "def", "get_children", "self", "yield", "self", "test", "yield", "self", "body", "yield", "self", "orelse"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_classes.py::IfExp.op_left_associative", "file_path": "astroid/nodes/node_classes.py", "class_name": "IfExp", "func_name": "op_left_associative", "text": "文件路径: astroid/nodes/node_classes.py, 类名: IfExp\n    def op_left_associative(self):\n        # `1 if True else 2 if False else 3` is parsed as\n        # `1 if True else (2 if False else 3)`\n        return False\n", "tokens": ["astroid", "nodes", "node_classes", "py", "ifexp", "def", "op_left_associative", "self", "1", "if", "true", "else", "2", "if", "false", "else", "3", "is", "parsed", "as", "1", "if", "true", "else", "2", "if", "false", "else", "3", "return", "false"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_classes.py::Import.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Import", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Import\n    def __init__(\n        self,\n        names: Optional[typing.List[typing.Tuple[str, Optional[str]]]] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being imported.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: typing.List[typing.Tuple[str, Optional[str]]] = names or []\n        \"\"\"The names being imported.\n\n        Each entry is a :class:`tuple` of the name being imported,\n        and the alias that the name is assigned to (if any).\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "import", "def", "__init__", "self", "names", "optional", "typing", "list", "typing", "tuple", "str", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "names", "the", "names", "being", "imported", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "names", "typing", "list", "typing", "tuple", "str", "optional", "str", "names", "or", "the", "names", "being", "imported", "each", "entry", "is", "a", "class", "tuple", "of", "the", "name", "being", "imported", "and", "the", "alias", "that", "the", "name", "is", "assigned", "to", "if", "any", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 162}
{"doc_id": "astroid/nodes/node_classes.py::Keyword.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Keyword", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Keyword\n    def __init__(\n        self,\n        arg: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param arg: The argument being assigned to.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.arg: Optional[str] = arg  # can be None\n        \"\"\"The argument being assigned to.\"\"\"\n\n        self.value: Optional[NodeNG] = None\n        \"\"\"The value being assigned to the keyword argument.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "keyword", "def", "__init__", "self", "arg", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "arg", "the", "argument", "being", "assigned", "to", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "arg", "optional", "str", "arg", "can", "be", "none", "the", "argument", "being", "assigned", "to", "self", "value", "optional", "nodeng", "none", "the", "value", "being", "assigned", "to", "the", "keyword", "argument", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 146}
{"doc_id": "astroid/nodes/node_classes.py::Keyword.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Keyword", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Keyword\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value being assigned to the keyword argument.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "keyword", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "the", "value", "being", "assigned", "to", "the", "keyword", "argument", "self", "value", "value"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_classes.py::Keyword.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Keyword", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Keyword\n    def get_children(self):\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "keyword", "def", "get_children", "self", "yield", "self", "value"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::List.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "List", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: List\n    def __init__(\n        self,\n        ctx: Optional[Context] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the list is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Optional[Context] = ctx\n        \"\"\"Whether the list is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "list", "def", "__init__", "self", "ctx", "optional", "context", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "ctx", "whether", "the", "list", "is", "assigned", "to", "or", "loaded", "from", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "ctx", "optional", "context", "ctx", "whether", "the", "list", "is", "assigned", "to", "or", "loaded", "from", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 138}
{"doc_id": "astroid/nodes/node_classes.py::List.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "List", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: List\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.list\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "list", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "list"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::List.getitem", "file_path": "astroid/nodes/node_classes.py", "class_name": "List", "func_name": "getitem", "text": "文件路径: astroid/nodes/node_classes.py, 类名: List\n    def getitem(self, index, context=None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "list", "def", "getitem", "self", "index", "context", "none", "get", "an", "item", "from", "this", "node", "param", "index", "the", "node", "to", "use", "as", "a", "subscript", "index", "type", "index", "const", "or", "slice", "return", "_container_getitem", "self", "self", "elts", "index", "context", "context"], "doc_len": 40}
{"doc_id": "astroid/nodes/node_classes.py::Nonlocal.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Nonlocal", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Nonlocal\n    def __init__(\n        self,\n        names: typing.List[str],\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param names: The names being declared as not local.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.names: typing.List[str] = names\n        \"\"\"The names being declared as not local.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "nonlocal", "def", "__init__", "self", "names", "typing", "list", "str", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "names", "the", "names", "being", "declared", "as", "not", "local", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "names", "typing", "list", "str", "names", "the", "names", "being", "declared", "as", "not", "local", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 135}
{"doc_id": "astroid/nodes/node_classes.py::Nonlocal._infer_name", "file_path": "astroid/nodes/node_classes.py", "class_name": "Nonlocal", "func_name": "_infer_name", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Nonlocal\n    def _infer_name(self, frame, name):\n        return name\n", "tokens": ["astroid", "nodes", "node_classes", "py", "nonlocal", "def", "_infer_name", "self", "frame", "name", "return", "name"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::Raise.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Raise", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Raise\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.exc: Optional[NodeNG] = None  # can be None\n        \"\"\"What is being raised.\"\"\"\n\n        self.cause: Optional[NodeNG] = None  # can be None\n        \"\"\"The exception being used to raise this one.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "raise", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "exc", "optional", "nodeng", "none", "can", "be", "none", "what", "is", "being", "raised", "self", "cause", "optional", "nodeng", "none", "can", "be", "none", "the", "exception", "being", "used", "to", "raise", "this", "one", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 137}
{"doc_id": "astroid/nodes/node_classes.py::Raise.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Raise", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Raise\n    def postinit(\n        self,\n        exc: Optional[NodeNG] = None,\n        cause: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param exc: What is being raised.\n\n        :param cause: The exception being used to raise this one.\n        \"\"\"\n        self.exc = exc\n        self.cause = cause\n", "tokens": ["astroid", "nodes", "node_classes", "py", "raise", "def", "postinit", "self", "exc", "optional", "nodeng", "none", "cause", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "exc", "what", "is", "being", "raised", "param", "cause", "the", "exception", "being", "used", "to", "raise", "this", "one", "self", "exc", "exc", "self", "cause", "cause"], "doc_len": 44}
{"doc_id": "astroid/nodes/node_classes.py::Raise.raises_not_implemented", "file_path": "astroid/nodes/node_classes.py", "class_name": "Raise", "func_name": "raises_not_implemented", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Raise\n    def raises_not_implemented(self):\n        \"\"\"Check if this node raises a :class:`NotImplementedError`.\n\n        :returns: True if this node raises a :class:`NotImplementedError`,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        if not self.exc:\n            return False\n        return any(\n            name.name == \"NotImplementedError\" for name in self.exc._get_name_nodes()\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "raise", "def", "raises_not_implemented", "self", "check", "if", "this", "node", "raises", "a", "class", "notimplementederror", "returns", "true", "if", "this", "node", "raises", "a", "class", "notimplementederror", "false", "otherwise", "rtype", "bool", "if", "not", "self", "exc", "return", "false", "return", "any", "name", "name", "notimplementederror", "for", "name", "in", "self", "exc", "_get_name_nodes"], "doc_len": 46}
{"doc_id": "astroid/nodes/node_classes.py::Raise.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Raise", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Raise\n    def get_children(self):\n        if self.exc is not None:\n            yield self.exc\n\n        if self.cause is not None:\n            yield self.cause\n", "tokens": ["astroid", "nodes", "node_classes", "py", "raise", "def", "get_children", "self", "if", "self", "exc", "is", "not", "none", "yield", "self", "exc", "if", "self", "cause", "is", "not", "none", "yield", "self", "cause"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_classes.py::Return.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Return", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Return\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None  # can be None\n        \"\"\"The value being returned.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "return", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "can", "be", "none", "the", "value", "being", "returned", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 121}
{"doc_id": "astroid/nodes/node_classes.py::Return.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Return", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Return\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value being returned.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "return", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "the", "value", "being", "returned", "self", "value", "value"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::Return.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Return", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Return\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "return", "def", "get_children", "self", "if", "self", "value", "is", "not", "none", "yield", "self", "value"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_classes.py::Return.is_tuple_return", "file_path": "astroid/nodes/node_classes.py", "class_name": "Return", "func_name": "is_tuple_return", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Return\n    def is_tuple_return(self):\n        return isinstance(self.value, Tuple)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "return", "def", "is_tuple_return", "self", "return", "isinstance", "self", "value", "tuple"], "doc_len": 13}
{"doc_id": "astroid/nodes/node_classes.py::Return._get_return_nodes_skip_functions", "file_path": "astroid/nodes/node_classes.py", "class_name": "Return", "func_name": "_get_return_nodes_skip_functions", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Return\n    def _get_return_nodes_skip_functions(self):\n        yield self\n", "tokens": ["astroid", "nodes", "node_classes", "py", "return", "def", "_get_return_nodes_skip_functions", "self", "yield", "self"], "doc_len": 10}
{"doc_id": "astroid/nodes/node_classes.py::Set.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "Set", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Set\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.set\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "set", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "set"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::Slice.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.lower: Optional[NodeNG] = None  # can be None\n        \"\"\"The lower index in the slice.\"\"\"\n\n        self.upper: Optional[NodeNG] = None  # can be None\n        \"\"\"The upper index in the slice.\"\"\"\n\n        self.step: Optional[NodeNG] = None  # can be None\n        \"\"\"The step to take between indexes.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "lower", "optional", "nodeng", "none", "can", "be", "none", "the", "lower", "index", "in", "the", "slice", "self", "upper", "optional", "nodeng", "none", "can", "be", "none", "the", "upper", "index", "in", "the", "slice", "self", "step", "optional", "nodeng", "none", "can", "be", "none", "the", "step", "to", "take", "between", "indexes", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 151}
{"doc_id": "astroid/nodes/node_classes.py::Slice.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def postinit(\n        self,\n        lower: Optional[NodeNG] = None,\n        upper: Optional[NodeNG] = None,\n        step: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param lower: The lower index in the slice.\n\n        :param upper: The upper index in the slice.\n\n        :param step: The step to take between index.\n        \"\"\"\n        self.lower = lower\n        self.upper = upper\n        self.step = step\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "postinit", "self", "lower", "optional", "nodeng", "none", "upper", "optional", "nodeng", "none", "step", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "lower", "the", "lower", "index", "in", "the", "slice", "param", "upper", "the", "upper", "index", "in", "the", "slice", "param", "step", "the", "step", "to", "take", "between", "index", "self", "lower", "lower", "self", "upper", "upper", "self", "step", "step"], "doc_len": 59}
{"doc_id": "astroid/nodes/node_classes.py::Slice._wrap_attribute", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "_wrap_attribute", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def _wrap_attribute(self, attr):\n        \"\"\"Wrap the empty attributes of the Slice in a Const node.\"\"\"\n        if not attr:\n            const = const_factory(attr)\n            const.parent = self\n            return const\n        return attr\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "_wrap_attribute", "self", "attr", "wrap", "the", "empty", "attributes", "of", "the", "slice", "in", "a", "const", "node", "if", "not", "attr", "const", "const_factory", "attr", "const", "parent", "self", "return", "const", "return", "attr"], "doc_len": 33}
{"doc_id": "astroid/nodes/node_classes.py::Slice._proxied", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "_proxied", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def _proxied(self):\n        builtins = AstroidManager().builtins_module\n        return builtins.getattr(\"slice\")[0]\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "_proxied", "self", "builtins", "astroidmanager", "builtins_module", "return", "builtins", "getattr", "slice", "0"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_classes.py::Slice.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.slice\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "slice"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::Slice.igetattr", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "igetattr", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def igetattr(self, attrname, context=None):\n        \"\"\"Infer the possible values of the given attribute on the slice.\n\n        :param attrname: The name of the attribute to infer.\n        :type attrname: str\n\n        :returns: The inferred possible values.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        if attrname == \"start\":\n            yield self._wrap_attribute(self.lower)\n        elif attrname == \"stop\":\n            yield self._wrap_attribute(self.upper)\n        elif attrname == \"step\":\n            yield self._wrap_attribute(self.step)\n        else:\n            yield from self.getattr(attrname, context=context)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "igetattr", "self", "attrname", "context", "none", "infer", "the", "possible", "values", "of", "the", "given", "attribute", "on", "the", "slice", "param", "attrname", "the", "name", "of", "the", "attribute", "to", "infer", "type", "attrname", "str", "returns", "the", "inferred", "possible", "values", "rtype", "iterable", "nodeng", "if", "attrname", "start", "yield", "self", "_wrap_attribute", "self", "lower", "elif", "attrname", "stop", "yield", "self", "_wrap_attribute", "self", "upper", "elif", "attrname", "step", "yield", "self", "_wrap_attribute", "self", "step", "else", "yield", "from", "self", "getattr", "attrname", "context", "context"], "doc_len": 74}
{"doc_id": "astroid/nodes/node_classes.py::Slice.getattr", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "getattr", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def getattr(self, attrname, context=None):\n        return self._proxied.getattr(attrname, context)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "getattr", "self", "attrname", "context", "none", "return", "self", "_proxied", "getattr", "attrname", "context"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_classes.py::Slice.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Slice", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Slice\n    def get_children(self):\n        if self.lower is not None:\n            yield self.lower\n\n        if self.upper is not None:\n            yield self.upper\n\n        if self.step is not None:\n            yield self.step\n", "tokens": ["astroid", "nodes", "node_classes", "py", "slice", "def", "get_children", "self", "if", "self", "lower", "is", "not", "none", "yield", "self", "lower", "if", "self", "upper", "is", "not", "none", "yield", "self", "upper", "if", "self", "step", "is", "not", "none", "yield", "self", "step"], "doc_len": 35}
{"doc_id": "astroid/nodes/node_classes.py::Starred.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Starred", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Starred\n    def __init__(\n        self,\n        ctx: Optional[Context] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the list is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None\n        \"\"\"What is being unpacked.\"\"\"\n\n        self.ctx: Optional[Context] = ctx\n        \"\"\"Whether the starred item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "starred", "def", "__init__", "self", "ctx", "optional", "context", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "ctx", "whether", "the", "list", "is", "assigned", "to", "or", "loaded", "from", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "what", "is", "being", "unpacked", "self", "ctx", "optional", "context", "ctx", "whether", "the", "starred", "item", "is", "assigned", "to", "or", "loaded", "from", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 148}
{"doc_id": "astroid/nodes/node_classes.py::Starred.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Starred", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Starred\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: What is being unpacked.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "starred", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "what", "is", "being", "unpacked", "self", "value", "value"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::Starred.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Starred", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Starred\n    def get_children(self):\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "starred", "def", "get_children", "self", "yield", "self", "value"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::Subscript.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Subscript", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Subscript\n    def __init__(\n        self,\n        ctx: Optional[Context] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the subscripted item is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None\n        \"\"\"What is being indexed.\"\"\"\n\n        self.slice: Optional[NodeNG] = None\n        \"\"\"The slice being used to lookup.\"\"\"\n\n        self.ctx: Optional[Context] = ctx\n        \"\"\"Whether the subscripted item is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "subscript", "def", "__init__", "self", "ctx", "optional", "context", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "ctx", "whether", "the", "subscripted", "item", "is", "assigned", "to", "or", "loaded", "from", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "what", "is", "being", "indexed", "self", "slice", "optional", "nodeng", "none", "the", "slice", "being", "used", "to", "lookup", "self", "ctx", "optional", "context", "ctx", "whether", "the", "subscripted", "item", "is", "assigned", "to", "or", "loaded", "from", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 160}
{"doc_id": "astroid/nodes/node_classes.py::Subscript.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Subscript", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Subscript\n    def postinit(\n        self, value: Optional[NodeNG] = None, slice: Optional[NodeNG] = None\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: What is being indexed.\n\n        :param slice: The slice being used to lookup.\n        \"\"\"\n        self.value = value\n        self.slice = slice\n", "tokens": ["astroid", "nodes", "node_classes", "py", "subscript", "def", "postinit", "self", "value", "optional", "nodeng", "none", "slice", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "what", "is", "being", "indexed", "param", "slice", "the", "slice", "being", "used", "to", "lookup", "self", "value", "value", "self", "slice", "slice"], "doc_len": 42}
{"doc_id": "astroid/nodes/node_classes.py::Subscript.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Subscript", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Subscript\n    def get_children(self):\n        yield self.value\n        yield self.slice\n", "tokens": ["astroid", "nodes", "node_classes", "py", "subscript", "def", "get_children", "self", "yield", "self", "value", "yield", "self", "slice"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::TryExcept.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryExcept", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryExcept\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the block to catch exceptions from.\"\"\"\n\n        self.handlers: typing.List[ExceptHandler] = []\n        \"\"\"The exception handlers.\"\"\"\n\n        self.orelse: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryexcept", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "block", "to", "catch", "exceptions", "from", "self", "handlers", "typing", "list", "excepthandler", "the", "exception", "handlers", "self", "orelse", "typing", "list", "nodeng", "the", "contents", "of", "the", "else", "block", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 142}
{"doc_id": "astroid/nodes/node_classes.py::TryExcept.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryExcept", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryExcept\n    def postinit(\n        self,\n        body: Optional[typing.List[NodeNG]] = None,\n        handlers: Optional[typing.List[ExceptHandler]] = None,\n        orelse: Optional[typing.List[NodeNG]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param body: The contents of the block to catch exceptions from.\n\n        :param handlers: The exception handlers.\n\n        :param orelse: The contents of the ``else`` block.\n        \"\"\"\n        if body is not None:\n            self.body = body\n        if handlers is not None:\n            self.handlers = handlers\n        if orelse is not None:\n            self.orelse = orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryexcept", "def", "postinit", "self", "body", "optional", "typing", "list", "nodeng", "none", "handlers", "optional", "typing", "list", "excepthandler", "none", "orelse", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "body", "the", "contents", "of", "the", "block", "to", "catch", "exceptions", "from", "param", "handlers", "the", "exception", "handlers", "param", "orelse", "the", "contents", "of", "the", "else", "block", "if", "body", "is", "not", "none", "self", "body", "body", "if", "handlers", "is", "not", "none", "self", "handlers", "handlers", "if", "orelse", "is", "not", "none", "self", "orelse", "orelse"], "doc_len": 80}
{"doc_id": "astroid/nodes/node_classes.py::TryExcept._infer_name", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryExcept", "func_name": "_infer_name", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryExcept\n    def _infer_name(self, frame, name):\n        return name\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryexcept", "def", "_infer_name", "self", "frame", "name", "return", "name"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::TryExcept.block_range", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryExcept", "func_name": "block_range", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryExcept\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        :rtype: tuple(int, int)\n        \"\"\"\n        last = None\n        for exhandler in self.handlers:\n            if exhandler.type and lineno == exhandler.type.fromlineno:\n                return lineno, lineno\n            if exhandler.body[0].fromlineno <= lineno <= exhandler.body[-1].tolineno:\n                return lineno, exhandler.body[-1].tolineno\n            if last is None:\n                last = exhandler.body[0].fromlineno - 1\n        return self._elsed_block_range(lineno, self.orelse, last)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryexcept", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "the", "line", "number", "to", "start", "the", "range", "at", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "starting", "at", "the", "given", "line", "number", "rtype", "tuple", "int", "int", "last", "none", "for", "exhandler", "in", "self", "handlers", "if", "exhandler", "type", "and", "lineno", "exhandler", "type", "fromlineno", "return", "lineno", "lineno", "if", "exhandler", "body", "0", "fromlineno", "lineno", "exhandler", "body", "1", "tolineno", "return", "lineno", "exhandler", "body", "1", "tolineno", "if", "last", "is", "none", "last", "exhandler", "body", "0", "fromlineno", "1", "return", "self", "_elsed_block_range", "lineno", "self", "orelse", "last"], "doc_len": 107}
{"doc_id": "astroid/nodes/node_classes.py::TryExcept.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryExcept", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryExcept\n    def get_children(self):\n        yield from self.body\n\n        yield from self.handlers or ()\n        yield from self.orelse or ()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryexcept", "def", "get_children", "self", "yield", "from", "self", "body", "yield", "from", "self", "handlers", "or", "yield", "from", "self", "orelse", "or"], "doc_len": 22}
{"doc_id": "astroid/nodes/node_classes.py::TryFinally.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryFinally", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryFinally\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.body: typing.Union[typing.List[TryExcept], typing.List[NodeNG]] = []\n        \"\"\"The try-except that the finally is attached to.\"\"\"\n\n        self.finalbody: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``finally`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryfinally", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "body", "typing", "union", "typing", "list", "tryexcept", "typing", "list", "nodeng", "the", "try", "except", "that", "the", "finally", "is", "attached", "to", "self", "finalbody", "typing", "list", "nodeng", "the", "contents", "of", "the", "finally", "block", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 139}
{"doc_id": "astroid/nodes/node_classes.py::TryFinally.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryFinally", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryFinally\n    def postinit(\n        self,\n        body: typing.Union[typing.List[TryExcept], typing.List[NodeNG], None] = None,\n        finalbody: Optional[typing.List[NodeNG]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param body: The try-except that the finally is attached to.\n\n        :param finalbody: The contents of the ``finally`` block.\n        \"\"\"\n        if body is not None:\n            self.body = body\n        if finalbody is not None:\n            self.finalbody = finalbody\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryfinally", "def", "postinit", "self", "body", "typing", "union", "typing", "list", "tryexcept", "typing", "list", "nodeng", "none", "none", "finalbody", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "body", "the", "try", "except", "that", "the", "finally", "is", "attached", "to", "param", "finalbody", "the", "contents", "of", "the", "finally", "block", "if", "body", "is", "not", "none", "self", "body", "body", "if", "finalbody", "is", "not", "none", "self", "finalbody", "finalbody"], "doc_len": 66}
{"doc_id": "astroid/nodes/node_classes.py::TryFinally.block_range", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryFinally", "func_name": "block_range", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryFinally\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        :rtype: tuple(int, int)\n        \"\"\"\n        child = self.body[0]\n        # py2.5 try: except: finally:\n        if (\n            isinstance(child, TryExcept)\n            and child.fromlineno == self.fromlineno\n            and child.tolineno >= lineno > self.fromlineno\n        ):\n            return child.block_range(lineno)\n        return self._elsed_block_range(lineno, self.finalbody)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryfinally", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "the", "line", "number", "to", "start", "the", "range", "at", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "starting", "at", "the", "given", "line", "number", "rtype", "tuple", "int", "int", "child", "self", "body", "0", "py2", "5", "try", "except", "finally", "if", "isinstance", "child", "tryexcept", "and", "child", "fromlineno", "self", "fromlineno", "and", "child", "tolineno", "lineno", "self", "fromlineno", "return", "child", "block_range", "lineno", "return", "self", "_elsed_block_range", "lineno", "self", "finalbody"], "doc_len": 90}
{"doc_id": "astroid/nodes/node_classes.py::TryFinally.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "TryFinally", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: TryFinally\n    def get_children(self):\n        yield from self.body\n        yield from self.finalbody\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tryfinally", "def", "get_children", "self", "yield", "from", "self", "body", "yield", "from", "self", "finalbody"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_classes.py::Tuple.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Tuple", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Tuple\n    def __init__(\n        self,\n        ctx: Optional[Context] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param ctx: Whether the tuple is assigned to or loaded from.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.ctx: Optional[Context] = ctx\n        \"\"\"Whether the tuple is assigned to or loaded from.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tuple", "def", "__init__", "self", "ctx", "optional", "context", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "ctx", "whether", "the", "tuple", "is", "assigned", "to", "or", "loaded", "from", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "ctx", "optional", "context", "ctx", "whether", "the", "tuple", "is", "assigned", "to", "or", "loaded", "from", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 138}
{"doc_id": "astroid/nodes/node_classes.py::Tuple.pytype", "file_path": "astroid/nodes/node_classes.py", "class_name": "Tuple", "func_name": "pytype", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Tuple\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.tuple\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tuple", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "tuple"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::Tuple.getitem", "file_path": "astroid/nodes/node_classes.py", "class_name": "Tuple", "func_name": "getitem", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Tuple\n    def getitem(self, index, context=None):\n        \"\"\"Get an item from this node.\n\n        :param index: The node to use as a subscript index.\n        :type index: Const or Slice\n        \"\"\"\n        return _container_getitem(self, self.elts, index, context=context)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "tuple", "def", "getitem", "self", "index", "context", "none", "get", "an", "item", "from", "this", "node", "param", "index", "the", "node", "to", "use", "as", "a", "subscript", "index", "type", "index", "const", "or", "slice", "return", "_container_getitem", "self", "self", "elts", "index", "context", "context"], "doc_len": 40}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def __init__(\n        self,\n        op: Optional[str] = None,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param op: The operator.\n\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.op: Optional[str] = op\n        \"\"\"The operator.\"\"\"\n\n        self.operand: Optional[NodeNG] = None\n        \"\"\"What the unary operator is applied to.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "__init__", "self", "op", "optional", "str", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "op", "the", "operator", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "op", "optional", "str", "op", "the", "operator", "self", "operand", "optional", "nodeng", "none", "what", "the", "unary", "operator", "is", "applied", "to", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 136}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def postinit(self, operand: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param operand: What the unary operator is applied to.\n        \"\"\"\n        self.operand = operand\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "postinit", "self", "operand", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "operand", "what", "the", "unary", "operator", "is", "applied", "to", "self", "operand", "operand"], "doc_len": 30}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp._infer_unaryop", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "_infer_unaryop", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def _infer_unaryop(self, context=None):\n        raise NotImplementedError\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "_infer_unaryop", "self", "context", "none", "raise", "notimplementederror"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp.type_errors", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "type_errors", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def type_errors(self, context=None):\n        \"\"\"Get a list of type errors which can occur during inference.\n\n        Each TypeError is represented by a :class:`BadBinaryOperationMessage`,\n        which holds the original exception.\n\n        :returns: The list of possible type errors.\n        :rtype: list(BadBinaryOperationMessage)\n        \"\"\"\n        try:\n            results = self._infer_unaryop(context=context)\n            return [\n                result\n                for result in results\n                if isinstance(result, util.BadUnaryOperationMessage)\n            ]\n        except InferenceError:\n            return []\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "type_errors", "self", "context", "none", "get", "a", "list", "of", "type", "errors", "which", "can", "occur", "during", "inference", "each", "typeerror", "is", "represented", "by", "a", "class", "badbinaryoperationmessage", "which", "holds", "the", "original", "exception", "returns", "the", "list", "of", "possible", "type", "errors", "rtype", "list", "badbinaryoperationmessage", "try", "results", "self", "_infer_unaryop", "context", "context", "return", "result", "for", "result", "in", "results", "if", "isinstance", "result", "util", "badunaryoperationmessage", "except", "inferenceerror", "return"], "doc_len": 64}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def get_children(self):\n        yield self.operand\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "get_children", "self", "yield", "self", "operand"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_classes.py::UnaryOp.op_precedence", "file_path": "astroid/nodes/node_classes.py", "class_name": "UnaryOp", "func_name": "op_precedence", "text": "文件路径: astroid/nodes/node_classes.py, 类名: UnaryOp\n    def op_precedence(self):\n        if self.op == \"not\":\n            return OP_PRECEDENCE[self.op]\n\n        return super().op_precedence()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unaryop", "def", "op_precedence", "self", "if", "self", "op", "not", "return", "op_precedence", "self", "op", "return", "super", "op_precedence"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::While.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.test: Optional[NodeNG] = None\n        \"\"\"The condition that the loop tests.\"\"\"\n\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the loop.\"\"\"\n\n        self.orelse: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``else`` block.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "test", "optional", "nodeng", "none", "the", "condition", "that", "the", "loop", "tests", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "loop", "self", "orelse", "typing", "list", "nodeng", "the", "contents", "of", "the", "else", "block", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 141}
{"doc_id": "astroid/nodes/node_classes.py::While.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def postinit(\n        self,\n        test: Optional[NodeNG] = None,\n        body: Optional[typing.List[NodeNG]] = None,\n        orelse: Optional[typing.List[NodeNG]] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param test: The condition that the loop tests.\n\n        :param body: The contents of the loop.\n\n        :param orelse: The contents of the ``else`` block.\n        \"\"\"\n        self.test = test\n        if body is not None:\n            self.body = body\n        if orelse is not None:\n            self.orelse = orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "postinit", "self", "test", "optional", "nodeng", "none", "body", "optional", "typing", "list", "nodeng", "none", "orelse", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "test", "the", "condition", "that", "the", "loop", "tests", "param", "body", "the", "contents", "of", "the", "loop", "param", "orelse", "the", "contents", "of", "the", "else", "block", "self", "test", "test", "if", "body", "is", "not", "none", "self", "body", "body", "if", "orelse", "is", "not", "none", "self", "orelse", "orelse"], "doc_len": 72}
{"doc_id": "astroid/nodes/node_classes.py::While.blockstart_tolineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.test.tolineno\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "return", "self", "test", "tolineno"], "doc_len": 24}
{"doc_id": "astroid/nodes/node_classes.py::While.block_range", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "block_range", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        :rtype: tuple(int, int)\n        \"\"\"\n        return self._elsed_block_range(lineno, self.orelse)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "the", "line", "number", "to", "start", "the", "range", "at", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "starting", "at", "the", "given", "line", "number", "rtype", "tuple", "int", "int", "return", "self", "_elsed_block_range", "lineno", "self", "orelse"], "doc_len": 62}
{"doc_id": "astroid/nodes/node_classes.py::While.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def get_children(self):\n        yield self.test\n\n        yield from self.body\n        yield from self.orelse\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "get_children", "self", "yield", "self", "test", "yield", "from", "self", "body", "yield", "from", "self", "orelse"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::While._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "While", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: While\n    def _get_yield_nodes_skip_lambdas(self):\n        \"\"\"A While node can contain a Yield node in the test\"\"\"\n        yield from self.test._get_yield_nodes_skip_lambdas()\n        yield from super()._get_yield_nodes_skip_lambdas()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "while", "def", "_get_yield_nodes_skip_lambdas", "self", "a", "while", "node", "can", "contain", "a", "yield", "node", "in", "the", "test", "yield", "from", "self", "test", "_get_yield_nodes_skip_lambdas", "yield", "from", "super", "_get_yield_nodes_skip_lambdas"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_classes.py::With.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "With", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: With\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.items: typing.List[typing.Tuple[NodeNG, Optional[NodeNG]]] = []\n        \"\"\"The pairs of context managers and the names they are assigned to.\"\"\"\n\n        self.body: typing.List[NodeNG] = []\n        \"\"\"The contents of the ``with`` block.\"\"\"\n\n        self.type_annotation: Optional[NodeNG] = None  # can be None\n        \"\"\"If present, this will contain the type annotation passed by a type comment\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "with", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "items", "typing", "list", "typing", "tuple", "nodeng", "optional", "nodeng", "the", "pairs", "of", "context", "managers", "and", "the", "names", "they", "are", "assigned", "to", "self", "body", "typing", "list", "nodeng", "the", "contents", "of", "the", "with", "block", "self", "type_annotation", "optional", "nodeng", "none", "can", "be", "none", "if", "present", "this", "will", "contain", "the", "type", "annotation", "passed", "by", "a", "type", "comment", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 162}
{"doc_id": "astroid/nodes/node_classes.py::With.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "With", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: With\n    def postinit(\n        self,\n        items: Optional[typing.List[typing.Tuple[NodeNG, Optional[NodeNG]]]] = None,\n        body: Optional[typing.List[NodeNG]] = None,\n        type_annotation: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param items: The pairs of context managers and the names\n            they are assigned to.\n\n        :param body: The contents of the ``with`` block.\n        \"\"\"\n        if items is not None:\n            self.items = items\n        if body is not None:\n            self.body = body\n        self.type_annotation = type_annotation\n", "tokens": ["astroid", "nodes", "node_classes", "py", "with", "def", "postinit", "self", "items", "optional", "typing", "list", "typing", "tuple", "nodeng", "optional", "nodeng", "none", "body", "optional", "typing", "list", "nodeng", "none", "type_annotation", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "items", "the", "pairs", "of", "context", "managers", "and", "the", "names", "they", "are", "assigned", "to", "param", "body", "the", "contents", "of", "the", "with", "block", "if", "items", "is", "not", "none", "self", "items", "items", "if", "body", "is", "not", "none", "self", "body", "body", "self", "type_annotation", "type_annotation"], "doc_len": 75}
{"doc_id": "astroid/nodes/node_classes.py::With.blockstart_tolineno", "file_path": "astroid/nodes/node_classes.py", "class_name": "With", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/node_classes.py, 类名: With\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.items[-1][0].tolineno\n", "tokens": ["astroid", "nodes", "node_classes", "py", "with", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "return", "self", "items", "1", "0", "tolineno"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_classes.py::With.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "With", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: With\n    def get_children(self):\n        \"\"\"Get the child nodes below this node.\n\n        :returns: The children.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for expr, var in self.items:\n            yield expr\n            if var:\n                yield var\n        yield from self.body\n", "tokens": ["astroid", "nodes", "node_classes", "py", "with", "def", "get_children", "self", "get", "the", "child", "nodes", "below", "this", "node", "returns", "the", "children", "rtype", "iterable", "nodeng", "for", "expr", "var", "in", "self", "items", "yield", "expr", "if", "var", "yield", "var", "yield", "from", "self", "body"], "doc_len": 37}
{"doc_id": "astroid/nodes/node_classes.py::Yield.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Yield", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Yield\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: Optional[NodeNG] = None  # can be None\n        \"\"\"The value to yield.\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "yield", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "optional", "nodeng", "none", "can", "be", "none", "the", "value", "to", "yield", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 121}
{"doc_id": "astroid/nodes/node_classes.py::Yield.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Yield", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Yield\n    def postinit(self, value: Optional[NodeNG] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value to yield.\n        \"\"\"\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "yield", "def", "postinit", "self", "value", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "the", "value", "to", "yield", "self", "value", "value"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::Yield.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "Yield", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Yield\n    def get_children(self):\n        if self.value is not None:\n            yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "yield", "def", "get_children", "self", "if", "self", "value", "is", "not", "none", "yield", "self", "value"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_classes.py::Yield._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_classes.py", "class_name": "Yield", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Yield\n    def _get_yield_nodes_skip_lambdas(self):\n        yield self\n", "tokens": ["astroid", "nodes", "node_classes", "py", "yield", "def", "_get_yield_nodes_skip_lambdas", "self", "yield", "self"], "doc_len": 10}
{"doc_id": "astroid/nodes/node_classes.py::FormattedValue.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "FormattedValue", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: FormattedValue\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.value: NodeNG\n        \"\"\"The value to be formatted into the string.\"\"\"\n\n        self.conversion: Optional[int] = None  # can be None\n        \"\"\"The type of formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n        \"\"\"\n\n        self.format_spec: Optional[NodeNG] = None  # can be None\n        \"\"\"The formatting to be applied to the value.\n\n        .. seealso::\n            :class:`ast.FormattedValue`\n\n        :type: JoinedStr or None\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "formattedvalue", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "value", "nodeng", "the", "value", "to", "be", "formatted", "into", "the", "string", "self", "conversion", "optional", "int", "none", "can", "be", "none", "the", "type", "of", "formatting", "to", "be", "applied", "to", "the", "value", "seealso", "class", "ast", "formattedvalue", "self", "format_spec", "optional", "nodeng", "none", "can", "be", "none", "the", "formatting", "to", "be", "applied", "to", "the", "value", "seealso", "class", "ast", "formattedvalue", "type", "joinedstr", "or", "none", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 166}
{"doc_id": "astroid/nodes/node_classes.py::FormattedValue.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "FormattedValue", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: FormattedValue\n    def postinit(\n        self,\n        value: NodeNG,\n        conversion: Optional[int] = None,\n        format_spec: Optional[NodeNG] = None,\n    ) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The value to be formatted into the string.\n\n        :param conversion: The type of formatting to be applied to the value.\n\n        :param format_spec: The formatting to be applied to the value.\n        :type format_spec: JoinedStr or None\n        \"\"\"\n        self.value = value\n        self.conversion = conversion\n        self.format_spec = format_spec\n", "tokens": ["astroid", "nodes", "node_classes", "py", "formattedvalue", "def", "postinit", "self", "value", "nodeng", "conversion", "optional", "int", "none", "format_spec", "optional", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "the", "value", "to", "be", "formatted", "into", "the", "string", "param", "conversion", "the", "type", "of", "formatting", "to", "be", "applied", "to", "the", "value", "param", "format_spec", "the", "formatting", "to", "be", "applied", "to", "the", "value", "type", "format_spec", "joinedstr", "or", "none", "self", "value", "value", "self", "conversion", "conversion", "self", "format_spec", "format_spec"], "doc_len": 70}
{"doc_id": "astroid/nodes/node_classes.py::FormattedValue.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "FormattedValue", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: FormattedValue\n    def get_children(self):\n        yield self.value\n\n        if self.format_spec is not None:\n            yield self.format_spec\n", "tokens": ["astroid", "nodes", "node_classes", "py", "formattedvalue", "def", "get_children", "self", "yield", "self", "value", "if", "self", "format_spec", "is", "not", "none", "yield", "self", "format_spec"], "doc_len": 20}
{"doc_id": "astroid/nodes/node_classes.py::JoinedStr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "JoinedStr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: JoinedStr\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.values: typing.List[NodeNG] = []\n        \"\"\"The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "joinedstr", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "values", "typing", "list", "nodeng", "the", "string", "expressions", "to", "be", "joined", "type", "list", "formattedvalue", "or", "const", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 125}
{"doc_id": "astroid/nodes/node_classes.py::JoinedStr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "JoinedStr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: JoinedStr\n    def postinit(self, values: Optional[typing.List[NodeNG]] = None) -> None:\n        \"\"\"Do some setup after initialisation.\n\n        :param value: The string expressions to be joined.\n\n        :type: list(FormattedValue or Const)\n        \"\"\"\n        if values is not None:\n            self.values = values\n", "tokens": ["astroid", "nodes", "node_classes", "py", "joinedstr", "def", "postinit", "self", "values", "optional", "typing", "list", "nodeng", "none", "none", "do", "some", "setup", "after", "initialisation", "param", "value", "the", "string", "expressions", "to", "be", "joined", "type", "list", "formattedvalue", "or", "const", "if", "values", "is", "not", "none", "self", "values", "values"], "doc_len": 41}
{"doc_id": "astroid/nodes/node_classes.py::JoinedStr.get_children", "file_path": "astroid/nodes/node_classes.py", "class_name": "JoinedStr", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_classes.py, 类名: JoinedStr\n    def get_children(self):\n        yield from self.values\n", "tokens": ["astroid", "nodes", "node_classes", "py", "joinedstr", "def", "get_children", "self", "yield", "from", "self", "values"], "doc_len": 12}
{"doc_id": "astroid/nodes/node_classes.py::NamedExpr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "NamedExpr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: NamedExpr\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.target: NodeNG\n        \"\"\"The assignment target\n\n        :type: Name\n        \"\"\"\n\n        self.value: NodeNG\n        \"\"\"The value that gets assigned in the expression\"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "namedexpr", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "target", "nodeng", "the", "assignment", "target", "type", "name", "self", "value", "nodeng", "the", "value", "that", "gets", "assigned", "in", "the", "expression", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 128}
{"doc_id": "astroid/nodes/node_classes.py::NamedExpr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "NamedExpr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: NamedExpr\n    def postinit(self, target: NodeNG, value: NodeNG) -> None:\n        self.target = target\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "namedexpr", "def", "postinit", "self", "target", "nodeng", "value", "nodeng", "none", "self", "target", "target", "self", "value", "value"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_classes.py::NamedExpr.frame", "file_path": "astroid/nodes/node_classes.py", "class_name": "NamedExpr", "func_name": "frame", "text": "文件路径: astroid/nodes/node_classes.py, 类名: NamedExpr\n    def frame(\n        self, *, future: Literal[None, True] = None\n    ) -> Union[\"nodes.FunctionDef\", \"nodes.Module\", \"nodes.ClassDef\", \"nodes.Lambda\"]:\n        \"\"\"The first parent frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        or :class:`ClassDef`.\n\n        :returns: The first parent frame node.\n        \"\"\"\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.frame(future=True)\n\n        return self.parent.frame(future=True)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "namedexpr", "def", "frame", "self", "future", "literal", "none", "true", "none", "union", "nodes", "functiondef", "nodes", "module", "nodes", "classdef", "nodes", "lambda", "the", "first", "parent", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "or", "class", "classdef", "returns", "the", "first", "parent", "frame", "node", "if", "not", "self", "parent", "raise", "parentmissingerror", "target", "self", "for", "certain", "parents", "namedexpr", "evaluate", "to", "the", "scope", "of", "the", "parent", "if", "isinstance", "self", "parent", "arguments", "keyword", "comprehension", "if", "not", "self", "parent", "parent", "raise", "parentmissingerror", "target", "self", "parent", "if", "not", "self", "parent", "parent", "parent", "raise", "parentmissingerror", "target", "self", "parent", "parent", "return", "self", "parent", "parent", "parent", "frame", "future", "true", "return", "self", "parent", "frame", "future", "true"], "doc_len": 107}
{"doc_id": "astroid/nodes/node_classes.py::NamedExpr.scope", "file_path": "astroid/nodes/node_classes.py", "class_name": "NamedExpr", "func_name": "scope", "text": "文件路径: astroid/nodes/node_classes.py, 类名: NamedExpr\n    def scope(self) -> \"LocalsDictNodeNG\":\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        if not self.parent:\n            raise ParentMissingError(target=self)\n\n        # For certain parents NamedExpr evaluate to the scope of the parent\n        if isinstance(self.parent, (Arguments, Keyword, Comprehension)):\n            if not self.parent.parent:\n                raise ParentMissingError(target=self.parent)\n            if not self.parent.parent.parent:\n                raise ParentMissingError(target=self.parent.parent)\n            return self.parent.parent.parent.scope()\n\n        return self.parent.scope()\n", "tokens": ["astroid", "nodes", "node_classes", "py", "namedexpr", "def", "scope", "self", "localsdictnodeng", "the", "first", "parent", "node", "defining", "a", "new", "scope", "these", "can", "be", "module", "functiondef", "classdef", "lambda", "or", "generatorexp", "nodes", "returns", "the", "first", "parent", "scope", "node", "if", "not", "self", "parent", "raise", "parentmissingerror", "target", "self", "for", "certain", "parents", "namedexpr", "evaluate", "to", "the", "scope", "of", "the", "parent", "if", "isinstance", "self", "parent", "arguments", "keyword", "comprehension", "if", "not", "self", "parent", "parent", "raise", "parentmissingerror", "target", "self", "parent", "if", "not", "self", "parent", "parent", "parent", "raise", "parentmissingerror", "target", "self", "parent", "parent", "return", "self", "parent", "parent", "parent", "scope", "return", "self", "parent", "scope"], "doc_len": 91}
{"doc_id": "astroid/nodes/node_classes.py::NamedExpr.set_local", "file_path": "astroid/nodes/node_classes.py", "class_name": "NamedExpr", "func_name": "set_local", "text": "文件路径: astroid/nodes/node_classes.py, 类名: NamedExpr\n    def set_local(self, name: str, stmt: AssignName) -> None:\n        \"\"\"Define that the given name is declared in the given statement node.\n        NamedExpr's in Arguments, Keyword or Comprehension are evaluated in their\n        parent's parent scope. So we add to their frame's locals.\n\n        .. seealso:: :meth:`scope`\n\n        :param name: The name that is being defined.\n\n        :param stmt: The statement that defines the given name.\n        \"\"\"\n        self.frame(future=True).set_local(name, stmt)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "namedexpr", "def", "set_local", "self", "name", "str", "stmt", "assignname", "none", "define", "that", "the", "given", "name", "is", "declared", "in", "the", "given", "statement", "node", "namedexpr", "s", "in", "arguments", "keyword", "or", "comprehension", "are", "evaluated", "in", "their", "parent", "s", "parent", "scope", "so", "we", "add", "to", "their", "frame", "s", "locals", "seealso", "meth", "scope", "param", "name", "the", "name", "that", "is", "being", "defined", "param", "stmt", "the", "statement", "that", "defines", "the", "given", "name", "self", "frame", "future", "true", "set_local", "name", "stmt"], "doc_len": 75}
{"doc_id": "astroid/nodes/node_classes.py::Unknown.qname", "file_path": "astroid/nodes/node_classes.py", "class_name": "Unknown", "func_name": "qname", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Unknown\n    def qname(self):\n        return \"Unknown\"\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unknown", "def", "qname", "self", "return", "unknown"], "doc_len": 10}
{"doc_id": "astroid/nodes/node_classes.py::Unknown._infer", "file_path": "astroid/nodes/node_classes.py", "class_name": "Unknown", "func_name": "_infer", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Unknown\n    def _infer(self, context=None, **kwargs):\n        \"\"\"Inference on an Unknown node immediately terminates.\"\"\"\n        yield util.Uninferable\n", "tokens": ["astroid", "nodes", "node_classes", "py", "unknown", "def", "_infer", "self", "context", "none", "kwargs", "inference", "on", "an", "unknown", "node", "immediately", "terminates", "yield", "util", "uninferable"], "doc_len": 21}
{"doc_id": "astroid/nodes/node_classes.py::EvaluatedObject.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "EvaluatedObject", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: EvaluatedObject\n    def __init__(\n        self, original: NodeNG, value: typing.Union[NodeNG, util.Uninferable]\n    ) -> None:\n        self.original: NodeNG = original\n        \"\"\"The original node that has already been evaluated\"\"\"\n\n        self.value: typing.Union[NodeNG, util.Uninferable] = value\n        \"\"\"The inferred value\"\"\"\n\n        super().__init__(\n            lineno=self.original.lineno,\n            col_offset=self.original.col_offset,\n            parent=self.original.parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "evaluatedobject", "def", "__init__", "self", "original", "nodeng", "value", "typing", "union", "nodeng", "util", "uninferable", "none", "self", "original", "nodeng", "original", "the", "original", "node", "that", "has", "already", "been", "evaluated", "self", "value", "typing", "union", "nodeng", "util", "uninferable", "value", "the", "inferred", "value", "super", "__init__", "lineno", "self", "original", "lineno", "col_offset", "self", "original", "col_offset", "parent", "self", "original", "parent"], "doc_len": 54}
{"doc_id": "astroid/nodes/node_classes.py::EvaluatedObject.infer", "file_path": "astroid/nodes/node_classes.py", "class_name": "EvaluatedObject", "func_name": "infer", "text": "文件路径: astroid/nodes/node_classes.py, 类名: EvaluatedObject\n    def infer(self, context=None, **kwargs):\n        yield self.value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "evaluatedobject", "def", "infer", "self", "context", "none", "kwargs", "yield", "self", "value"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::Match.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "Match", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Match\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.subject: NodeNG\n        self.cases: typing.List[\"MatchCase\"]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "match", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "subject", "nodeng", "self", "cases", "typing", "list", "matchcase", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 49}
{"doc_id": "astroid/nodes/node_classes.py::Match.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "Match", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: Match\n    def postinit(\n        self,\n        *,\n        subject: NodeNG,\n        cases: typing.List[\"MatchCase\"],\n    ) -> None:\n        self.subject = subject\n        self.cases = cases\n", "tokens": ["astroid", "nodes", "node_classes", "py", "match", "def", "postinit", "self", "subject", "nodeng", "cases", "typing", "list", "matchcase", "none", "self", "subject", "subject", "self", "cases", "cases"], "doc_len": 21}
{"doc_id": "astroid/nodes/node_classes.py::MatchCase.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchCase", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchCase\n    def __init__(self, *, parent: Optional[NodeNG] = None) -> None:\n        self.pattern: Pattern\n        self.guard: Optional[NodeNG]\n        self.body: typing.List[NodeNG]\n        super().__init__(parent=parent)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchcase", "def", "__init__", "self", "parent", "optional", "nodeng", "none", "none", "self", "pattern", "pattern", "self", "guard", "optional", "nodeng", "self", "body", "typing", "list", "nodeng", "super", "__init__", "parent", "parent"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::MatchCase.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchCase", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchCase\n    def postinit(\n        self,\n        *,\n        pattern: Pattern,\n        guard: Optional[NodeNG],\n        body: typing.List[NodeNG],\n    ) -> None:\n        self.pattern = pattern\n        self.guard = guard\n        self.body = body\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchcase", "def", "postinit", "self", "pattern", "pattern", "guard", "optional", "nodeng", "body", "typing", "list", "nodeng", "none", "self", "pattern", "pattern", "self", "guard", "guard", "self", "body", "body"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_classes.py::MatchValue.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchValue", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchValue\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.value: NodeNG\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchvalue", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "value", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 44}
{"doc_id": "astroid/nodes/node_classes.py::MatchValue.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchValue", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchValue\n    def postinit(self, *, value: NodeNG) -> None:\n        self.value = value\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchvalue", "def", "postinit", "self", "value", "nodeng", "none", "self", "value", "value"], "doc_len": 14}
{"doc_id": "astroid/nodes/node_classes.py::MatchSingleton.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchSingleton", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchSingleton\n    def __init__(\n        self,\n        *,\n        value: Literal[True, False, None],\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n    ) -> None:\n        self.value = value\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchsingleton", "def", "__init__", "self", "value", "literal", "true", "false", "none", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "none", "self", "value", "value", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 49}
{"doc_id": "astroid/nodes/node_classes.py::MatchSequence.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchSequence", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchSequence\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.patterns: typing.List[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchsequence", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "patterns", "typing", "list", "pattern", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 46}
{"doc_id": "astroid/nodes/node_classes.py::MatchSequence.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchSequence", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchSequence\n    def postinit(self, *, patterns: typing.List[Pattern]) -> None:\n        self.patterns = patterns\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchsequence", "def", "postinit", "self", "patterns", "typing", "list", "pattern", "none", "self", "patterns", "patterns"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_classes.py::MatchMapping.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchMapping", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchMapping\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.keys: typing.List[NodeNG]\n        self.patterns: typing.List[Pattern]\n        self.rest: Optional[AssignName]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchmapping", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "keys", "typing", "list", "nodeng", "self", "patterns", "typing", "list", "pattern", "self", "rest", "optional", "assignname", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 55}
{"doc_id": "astroid/nodes/node_classes.py::MatchMapping.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchMapping", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchMapping\n    def postinit(\n        self,\n        *,\n        keys: typing.List[NodeNG],\n        patterns: typing.List[Pattern],\n        rest: Optional[AssignName],\n    ) -> None:\n        self.keys = keys\n        self.patterns = patterns\n        self.rest = rest\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchmapping", "def", "postinit", "self", "keys", "typing", "list", "nodeng", "patterns", "typing", "list", "pattern", "rest", "optional", "assignname", "none", "self", "keys", "keys", "self", "patterns", "patterns", "self", "rest", "rest"], "doc_len": 29}
{"doc_id": "astroid/nodes/node_classes.py::MatchClass.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchClass", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchClass\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.cls: NodeNG\n        self.patterns: typing.List[Pattern]\n        self.kwd_attrs: typing.List[str]\n        self.kwd_patterns: typing.List[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchclass", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "cls", "nodeng", "self", "patterns", "typing", "list", "pattern", "self", "kwd_attrs", "typing", "list", "str", "self", "kwd_patterns", "typing", "list", "pattern", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 59}
{"doc_id": "astroid/nodes/node_classes.py::MatchClass.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchClass", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchClass\n    def postinit(\n        self,\n        *,\n        cls: NodeNG,\n        patterns: typing.List[Pattern],\n        kwd_attrs: typing.List[str],\n        kwd_patterns: typing.List[Pattern],\n    ) -> None:\n        self.cls = cls\n        self.patterns = patterns\n        self.kwd_attrs = kwd_attrs\n        self.kwd_patterns = kwd_patterns\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchclass", "def", "postinit", "self", "cls", "nodeng", "patterns", "typing", "list", "pattern", "kwd_attrs", "typing", "list", "str", "kwd_patterns", "typing", "list", "pattern", "none", "self", "cls", "cls", "self", "patterns", "patterns", "self", "kwd_attrs", "kwd_attrs", "self", "kwd_patterns", "kwd_patterns"], "doc_len": 35}
{"doc_id": "astroid/nodes/node_classes.py::MatchStar.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchStar", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchStar\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.name: Optional[AssignName]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchstar", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "name", "optional", "assignname", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 45}
{"doc_id": "astroid/nodes/node_classes.py::MatchStar.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchStar", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchStar\n    def postinit(self, *, name: Optional[AssignName]) -> None:\n        self.name = name\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchstar", "def", "postinit", "self", "name", "optional", "assignname", "none", "self", "name", "name"], "doc_len": 15}
{"doc_id": "astroid/nodes/node_classes.py::MatchAs.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchAs", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchAs\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.pattern: Optional[Pattern]\n        self.name: Optional[AssignName]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchas", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "pattern", "optional", "pattern", "self", "name", "optional", "assignname", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 49}
{"doc_id": "astroid/nodes/node_classes.py::MatchAs.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchAs", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchAs\n    def postinit(\n        self,\n        *,\n        pattern: Optional[Pattern],\n        name: Optional[AssignName],\n    ) -> None:\n        self.pattern = pattern\n        self.name = name\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchas", "def", "postinit", "self", "pattern", "optional", "pattern", "name", "optional", "assignname", "none", "self", "pattern", "pattern", "self", "name", "name"], "doc_len": 21}
{"doc_id": "astroid/nodes/node_classes.py::MatchOr.__init__", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchOr", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchOr\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[NodeNG] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        self.patterns: typing.List[Pattern]\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchor", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "self", "patterns", "typing", "list", "pattern", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 46}
{"doc_id": "astroid/nodes/node_classes.py::MatchOr.postinit", "file_path": "astroid/nodes/node_classes.py", "class_name": "MatchOr", "func_name": "postinit", "text": "文件路径: astroid/nodes/node_classes.py, 类名: MatchOr\n    def postinit(self, *, patterns: typing.List[Pattern]) -> None:\n        self.patterns = patterns\n", "tokens": ["astroid", "nodes", "node_classes", "py", "matchor", "def", "postinit", "self", "patterns", "typing", "list", "pattern", "none", "self", "patterns", "patterns"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_classes.py::_update_const_classes", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_update_const_classes", "text": "文件路径: astroid/nodes/node_classes.py\ndef _update_const_classes():\n    \"\"\"update constant classes, so the keys of CONST_CLS can be reused\"\"\"\n    klasses = (bool, int, float, complex, str, bytes)\n    for kls in klasses:\n        CONST_CLS[kls] = Const\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_update_const_classes", "update", "constant", "classes", "so", "the", "keys", "of", "const_cls", "can", "be", "reused", "klasses", "bool", "int", "float", "complex", "str", "bytes", "for", "kls", "in", "klasses", "const_cls", "kls", "const"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_classes.py::_two_step_initialization", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_two_step_initialization", "text": "文件路径: astroid/nodes/node_classes.py\ndef _two_step_initialization(cls, value):\n    instance = cls()\n    instance.postinit(value)\n    return instance\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_two_step_initialization", "cls", "value", "instance", "cls", "instance", "postinit", "value", "return", "instance"], "doc_len": 15}
{"doc_id": "astroid/nodes/node_classes.py::_dict_initialization", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "_dict_initialization", "text": "文件路径: astroid/nodes/node_classes.py\ndef _dict_initialization(cls, value):\n    if isinstance(value, dict):\n        value = tuple(value.items())\n    return _two_step_initialization(cls, value)\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "_dict_initialization", "cls", "value", "if", "isinstance", "value", "dict", "value", "tuple", "value", "items", "return", "_two_step_initialization", "cls", "value"], "doc_len": 20}
{"doc_id": "astroid/nodes/node_classes.py::const_factory", "file_path": "astroid/nodes/node_classes.py", "class_name": null, "func_name": "const_factory", "text": "文件路径: astroid/nodes/node_classes.py\ndef const_factory(value):\n    \"\"\"return an astroid node for a python value\"\"\"\n    # XXX we should probably be stricter here and only consider stuff in\n    # CONST_CLS or do better treatment: in case where value is not in CONST_CLS,\n    # we should rather recall the builder on this value than returning an empty\n    # node (another option being that const_factory shouldn't be called with something\n    # not in CONST_CLS)\n    assert not isinstance(value, NodeNG)\n\n    # Hack for ignoring elements of a sequence\n    # or a mapping, in order to avoid transforming\n    # each element to an AST. This is fixed in 2.0\n    # and this approach is a temporary hack.\n    if isinstance(value, (list, set, tuple, dict)):\n        elts = []\n    else:\n        elts = value\n\n    try:\n        initializer_cls = CONST_CLS[value.__class__]\n        initializer = _CONST_CLS_CONSTRUCTORS[initializer_cls]\n        return initializer(initializer_cls, elts)\n    except (KeyError, AttributeError):\n        node = EmptyNode()\n        node.object = value\n        return node\n", "tokens": ["astroid", "nodes", "node_classes", "py", "def", "const_factory", "value", "return", "an", "astroid", "node", "for", "a", "python", "value", "xxx", "we", "should", "probably", "be", "stricter", "here", "and", "only", "consider", "stuff", "in", "const_cls", "or", "do", "better", "treatment", "in", "case", "where", "value", "is", "not", "in", "const_cls", "we", "should", "rather", "recall", "the", "builder", "on", "this", "value", "than", "returning", "an", "empty", "node", "another", "option", "being", "that", "const_factory", "shouldn", "t", "be", "called", "with", "something", "not", "in", "const_cls", "assert", "not", "isinstance", "value", "nodeng", "hack", "for", "ignoring", "elements", "of", "a", "sequence", "or", "a", "mapping", "in", "order", "to", "avoid", "transforming", "each", "element", "to", "an", "ast", "this", "is", "fixed", "in", "2", "0", "and", "this", "approach", "is", "a", "temporary", "hack", "if", "isinstance", "value", "list", "set", "tuple", "dict", "elts", "else", "elts", "value", "try", "initializer_cls", "const_cls", "value", "__class__", "initializer", "_const_cls_constructors", "initializer_cls", "return", "initializer", "initializer_cls", "elts", "except", "keyerror", "attributeerror", "node", "emptynode", "node", "object", "value", "return", "node"], "doc_len": 139}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.__init__", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "__init__", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def __init__(\n        self,\n        lineno: Optional[int] = None,\n        col_offset: Optional[int] = None,\n        parent: Optional[\"NodeNG\"] = None,\n        *,\n        end_lineno: Optional[int] = None,\n        end_col_offset: Optional[int] = None,\n    ) -> None:\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n\n        :param parent: The parent node in the syntax tree.\n\n        :param end_lineno: The last line this node appears on in the source code.\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        \"\"\"\n        self.lineno: Optional[int] = lineno\n        \"\"\"The line that this node appears on in the source code.\"\"\"\n\n        self.col_offset: Optional[int] = col_offset\n        \"\"\"The column that this node appears on in the source code.\"\"\"\n\n        self.parent: Optional[\"NodeNG\"] = parent\n        \"\"\"The parent node in the syntax tree.\"\"\"\n\n        self.end_lineno: Optional[int] = end_lineno\n        \"\"\"The last line this node appears on in the source code.\"\"\"\n\n        self.end_col_offset: Optional[int] = end_col_offset\n        \"\"\"The end column this node appears on in the source code.\n        Note: This is after the last symbol.\n        \"\"\"\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "__init__", "self", "lineno", "optional", "int", "none", "col_offset", "optional", "int", "none", "parent", "optional", "nodeng", "none", "end_lineno", "optional", "int", "none", "end_col_offset", "optional", "int", "none", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "self", "lineno", "optional", "int", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "self", "col_offset", "optional", "int", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "self", "parent", "optional", "nodeng", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "self", "end_lineno", "optional", "int", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "self", "end_col_offset", "optional", "int", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol"], "doc_len": 180}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.infer", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "infer", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def infer(self, context=None, **kwargs):\n        \"\"\"Get a generator of the inferred values.\n\n        This is the main entry point to the inference system.\n\n        .. seealso:: :ref:`inference`\n\n        If the instance has some explicit inference function set, it will be\n        called instead of the default interface.\n\n        :returns: The inferred values.\n        :rtype: iterable\n        \"\"\"\n        if context is not None:\n            context = context.extra_context.get(self, context)\n        if self._explicit_inference is not None:\n            # explicit_inference is not bound, give it self explicitly\n            try:\n                # pylint: disable=not-callable\n                results = list(self._explicit_inference(self, context, **kwargs))\n                if context is not None:\n                    context.nodes_inferred += len(results)\n                yield from results\n                return\n            except UseInferenceDefault:\n                pass\n\n        if not context:\n            # nodes_inferred?\n            yield from self._infer(context, **kwargs)\n            return\n\n        key = (self, context.lookupname, context.callcontext, context.boundnode)\n        if key in context.inferred:\n            yield from context.inferred[key]\n            return\n\n        generator = self._infer(context, **kwargs)\n        results = []\n\n        # Limit inference amount to help with performance issues with\n        # exponentially exploding possible results.\n        limit = AstroidManager().max_inferable_values\n        for i, result in enumerate(generator):\n            if i >= limit or (context.nodes_inferred > context.max_inferred):\n                yield util.Uninferable\n                break\n            results.append(result)\n            yield result\n            context.nodes_inferred += 1\n\n        # Cache generated results for subsequent inferences of the\n        # same node using the same context\n        context.inferred[key] = tuple(results)\n        return\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "infer", "self", "context", "none", "kwargs", "get", "a", "generator", "of", "the", "inferred", "values", "this", "is", "the", "main", "entry", "point", "to", "the", "inference", "system", "seealso", "ref", "inference", "if", "the", "instance", "has", "some", "explicit", "inference", "function", "set", "it", "will", "be", "called", "instead", "of", "the", "default", "interface", "returns", "the", "inferred", "values", "rtype", "iterable", "if", "context", "is", "not", "none", "context", "context", "extra_context", "get", "self", "context", "if", "self", "_explicit_inference", "is", "not", "none", "explicit_inference", "is", "not", "bound", "give", "it", "self", "explicitly", "try", "pylint", "disable", "not", "callable", "results", "list", "self", "_explicit_inference", "self", "context", "kwargs", "if", "context", "is", "not", "none", "context", "nodes_inferred", "len", "results", "yield", "from", "results", "return", "except", "useinferencedefault", "pass", "if", "not", "context", "nodes_inferred", "yield", "from", "self", "_infer", "context", "kwargs", "return", "key", "self", "context", "lookupname", "context", "callcontext", "context", "boundnode", "if", "key", "in", "context", "inferred", "yield", "from", "context", "inferred", "key", "return", "generator", "self", "_infer", "context", "kwargs", "results", "limit", "inference", "amount", "to", "help", "with", "performance", "issues", "with", "exponentially", "exploding", "possible", "results", "limit", "astroidmanager", "max_inferable_values", "for", "i", "result", "in", "enumerate", "generator", "if", "i", "limit", "or", "context", "nodes_inferred", "context", "max_inferred", "yield", "util", "uninferable", "break", "results", "append", "result", "yield", "result", "context", "nodes_inferred", "1", "cache", "generated", "results", "for", "subsequent", "inferences", "of", "the", "same", "node", "using", "the", "same", "context", "context", "inferred", "key", "tuple", "results", "return"], "doc_len": 206}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._repr_name", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_repr_name", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _repr_name(self):\n        \"\"\"Get a name for nice representation.\n\n        This is either :attr:`name`, :attr:`attrname`, or the empty string.\n\n        :returns: The nice name.\n        :rtype: str\n        \"\"\"\n        if all(name not in self._astroid_fields for name in (\"name\", \"attrname\")):\n            return getattr(self, \"name\", \"\") or getattr(self, \"attrname\", \"\")\n        return \"\"\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_repr_name", "self", "get", "a", "name", "for", "nice", "representation", "this", "is", "either", "attr", "name", "attr", "attrname", "or", "the", "empty", "string", "returns", "the", "nice", "name", "rtype", "str", "if", "all", "name", "not", "in", "self", "_astroid_fields", "for", "name", "in", "name", "attrname", "return", "getattr", "self", "name", "or", "getattr", "self", "attrname", "return"], "doc_len": 52}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.__str__", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "__str__", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def __str__(self):\n        rname = self._repr_name()\n        cname = type(self).__name__\n        if rname:\n            string = \"%(cname)s.%(rname)s(%(fields)s)\"\n            alignment = len(cname) + len(rname) + 2\n        else:\n            string = \"%(cname)s(%(fields)s)\"\n            alignment = len(cname) + 1\n        result = []\n        for field in self._other_fields + self._astroid_fields:\n            value = getattr(self, field)\n            width = 80 - len(field) - alignment\n            lines = pprint.pformat(value, indent=2, width=width).splitlines(True)\n\n            inner = [lines[0]]\n            for line in lines[1:]:\n                inner.append(\" \" * alignment + line)\n            result.append(f\"{field}={''.join(inner)}\")\n\n        return string % {\n            \"cname\": cname,\n            \"rname\": rname,\n            \"fields\": (\",\\n\" + \" \" * alignment).join(result),\n        }\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "__str__", "self", "rname", "self", "_repr_name", "cname", "type", "self", "__name__", "if", "rname", "string", "cname", "s", "rname", "s", "fields", "s", "alignment", "len", "cname", "len", "rname", "2", "else", "string", "cname", "s", "fields", "s", "alignment", "len", "cname", "1", "result", "for", "field", "in", "self", "_other_fields", "self", "_astroid_fields", "value", "getattr", "self", "field", "width", "80", "len", "field", "alignment", "lines", "pprint", "pformat", "value", "indent", "2", "width", "width", "splitlines", "true", "inner", "lines", "0", "for", "line", "in", "lines", "1", "inner", "append", "alignment", "line", "result", "append", "f", "field", "join", "inner", "return", "string", "cname", "cname", "rname", "rname", "fields", "n", "alignment", "join", "result"], "doc_len": 96}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.__repr__", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "__repr__", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def __repr__(self):\n        rname = self._repr_name()\n        if rname:\n            string = \"<%(cname)s.%(rname)s l.%(lineno)s at 0x%(id)x>\"\n        else:\n            string = \"<%(cname)s l.%(lineno)s at 0x%(id)x>\"\n        return string % {\n            \"cname\": type(self).__name__,\n            \"rname\": rname,\n            \"lineno\": self.fromlineno,\n            \"id\": id(self),\n        }\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "__repr__", "self", "rname", "self", "_repr_name", "if", "rname", "string", "cname", "s", "rname", "s", "l", "lineno", "s", "at", "0x", "id", "x", "else", "string", "cname", "s", "l", "lineno", "s", "at", "0x", "id", "x", "return", "string", "cname", "type", "self", "__name__", "rname", "rname", "lineno", "self", "fromlineno", "id", "id", "self"], "doc_len": 50}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.accept", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "accept", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def accept(self, visitor):\n        \"\"\"Visit this node using the given visitor.\"\"\"\n        func = getattr(visitor, \"visit_\" + self.__class__.__name__.lower())\n        return func(self)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "accept", "self", "visitor", "visit", "this", "node", "using", "the", "given", "visitor", "func", "getattr", "visitor", "visit_", "self", "__class__", "__name__", "lower", "return", "func", "self"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.get_children", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "get_children", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def get_children(self) -> Iterator[\"NodeNG\"]:\n        \"\"\"Get the child nodes below this node.\"\"\"\n        for field in self._astroid_fields:\n            attr = getattr(self, field)\n            if attr is None:\n                continue\n            if isinstance(attr, (list, tuple)):\n                yield from attr\n            else:\n                yield attr\n        yield from ()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "get_children", "self", "iterator", "nodeng", "get", "the", "child", "nodes", "below", "this", "node", "for", "field", "in", "self", "_astroid_fields", "attr", "getattr", "self", "field", "if", "attr", "is", "none", "continue", "if", "isinstance", "attr", "list", "tuple", "yield", "from", "attr", "else", "yield", "attr", "yield", "from"], "doc_len": 44}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.last_child", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "last_child", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def last_child(self) -> Optional[\"NodeNG\"]:\n        \"\"\"An optimized version of list(get_children())[-1]\"\"\"\n        for field in self._astroid_fields[::-1]:\n            attr = getattr(self, field)\n            if not attr:  # None or empty listy / tuple\n                continue\n            if isinstance(attr, (list, tuple)):\n                return attr[-1]\n            return attr\n        return None\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "last_child", "self", "optional", "nodeng", "an", "optimized", "version", "of", "list", "get_children", "1", "for", "field", "in", "self", "_astroid_fields", "1", "attr", "getattr", "self", "field", "if", "not", "attr", "none", "or", "empty", "listy", "tuple", "continue", "if", "isinstance", "attr", "list", "tuple", "return", "attr", "1", "return", "attr", "return", "none"], "doc_len": 48}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.node_ancestors", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "node_ancestors", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def node_ancestors(self) -> Iterator[\"NodeNG\"]:\n        \"\"\"Yield parent, grandparent, etc until there are no more.\"\"\"\n        parent = self.parent\n        while parent is not None:\n            yield parent\n            parent = parent.parent\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "node_ancestors", "self", "iterator", "nodeng", "yield", "parent", "grandparent", "etc", "until", "there", "are", "no", "more", "parent", "self", "parent", "while", "parent", "is", "not", "none", "yield", "parent", "parent", "parent", "parent"], "doc_len": 32}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.parent_of", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "parent_of", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def parent_of(self, node):\n        \"\"\"Check if this node is the parent of the given node.\n\n        :param node: The node to check if it is the child.\n        :type node: NodeNG\n\n        :returns: True if this node is the parent of the given node,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        return any(self is parent for parent in node.node_ancestors())\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "parent_of", "self", "node", "check", "if", "this", "node", "is", "the", "parent", "of", "the", "given", "node", "param", "node", "the", "node", "to", "check", "if", "it", "is", "the", "child", "type", "node", "nodeng", "returns", "true", "if", "this", "node", "is", "the", "parent", "of", "the", "given", "node", "false", "otherwise", "rtype", "bool", "return", "any", "self", "is", "parent", "for", "parent", "in", "node", "node_ancestors"], "doc_len": 60}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.statement", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "statement", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def statement(\n        self, *, future: Literal[None] = ...\n    ) -> Union[\"nodes.Statement\", \"nodes.Module\"]:\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "statement", "self", "future", "literal", "none", "union", "nodes", "statement", "nodes", "module"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.statement", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "statement", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def statement(self, *, future: Literal[True]) -> \"nodes.Statement\":\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "statement", "self", "future", "literal", "true", "nodes", "statement"], "doc_len": 13}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.statement", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "statement", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def statement(\n        self, *, future: Literal[None, True] = None\n    ) -> Union[\"nodes.Statement\", \"nodes.Module\"]:\n        \"\"\"The first parent node, including self, marked as statement node.\n\n        TODO: Deprecate the future parameter and only raise StatementMissing and return\n        nodes.Statement\n\n        :raises AttributeError: If self has no parent attribute\n        :raises StatementMissing: If self has no parent attribute and future is True\n        \"\"\"\n        if self.is_statement:\n            return cast(\"nodes.Statement\", self)\n        if not self.parent:\n            if future:\n                raise StatementMissing(target=self)\n            warnings.warn(\n                \"In astroid 3.0.0 NodeNG.statement() will return either a nodes.Statement \"\n                \"or raise a StatementMissing exception. AttributeError will no longer be raised. \"\n                \"This behaviour can already be triggered \"\n                \"by passing 'future=True' to a statement() call.\",\n                DeprecationWarning,\n            )\n            raise AttributeError(f\"{self} object has no attribute 'parent'\")\n        return self.parent.statement(future=future)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "statement", "self", "future", "literal", "none", "true", "none", "union", "nodes", "statement", "nodes", "module", "the", "first", "parent", "node", "including", "self", "marked", "as", "statement", "node", "todo", "deprecate", "the", "future", "parameter", "and", "only", "raise", "statementmissing", "and", "return", "nodes", "statement", "raises", "attributeerror", "if", "self", "has", "no", "parent", "attribute", "raises", "statementmissing", "if", "self", "has", "no", "parent", "attribute", "and", "future", "is", "true", "if", "self", "is_statement", "return", "cast", "nodes", "statement", "self", "if", "not", "self", "parent", "if", "future", "raise", "statementmissing", "target", "self", "warnings", "warn", "in", "astroid", "3", "0", "0", "nodeng", "statement", "will", "return", "either", "a", "nodes", "statement", "or", "raise", "a", "statementmissing", "exception", "attributeerror", "will", "no", "longer", "be", "raised", "this", "behaviour", "can", "already", "be", "triggered", "by", "passing", "future", "true", "to", "a", "statement", "call", "deprecationwarning", "raise", "attributeerror", "f", "self", "object", "has", "no", "attribute", "parent", "return", "self", "parent", "statement", "future", "future"], "doc_len": 135}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.frame", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "frame", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def frame(\n        self, *, future: Literal[None, True] = None\n    ) -> Union[\"nodes.FunctionDef\", \"nodes.Module\", \"nodes.ClassDef\", \"nodes.Lambda\"]:\n        \"\"\"The first parent frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        :class:`ClassDef` or :class:`Lambda`.\n\n        :returns: The first parent frame node.\n        \"\"\"\n        if self.parent is None:\n            if future:\n                raise ParentMissingError(target=self)\n            warnings.warn(\n                \"In astroid 3.0.0 NodeNG.frame() will return either a Frame node, \"\n                \"or raise ParentMissingError. AttributeError will no longer be raised. \"\n                \"This behaviour can already be triggered \"\n                \"by passing 'future=True' to a frame() call.\",\n                DeprecationWarning,\n            )\n            raise AttributeError(f\"{self} object has no attribute 'parent'\")\n\n        return self.parent.frame(future=future)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "frame", "self", "future", "literal", "none", "true", "none", "union", "nodes", "functiondef", "nodes", "module", "nodes", "classdef", "nodes", "lambda", "the", "first", "parent", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "class", "classdef", "or", "class", "lambda", "returns", "the", "first", "parent", "frame", "node", "if", "self", "parent", "is", "none", "if", "future", "raise", "parentmissingerror", "target", "self", "warnings", "warn", "in", "astroid", "3", "0", "0", "nodeng", "frame", "will", "return", "either", "a", "frame", "node", "or", "raise", "parentmissingerror", "attributeerror", "will", "no", "longer", "be", "raised", "this", "behaviour", "can", "already", "be", "triggered", "by", "passing", "future", "true", "to", "a", "frame", "call", "deprecationwarning", "raise", "attributeerror", "f", "self", "object", "has", "no", "attribute", "parent", "return", "self", "parent", "frame", "future", "future"], "doc_len": 112}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.scope", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "scope", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def scope(self) -> \"nodes.LocalsDictNodeNG\":\n        \"\"\"The first parent node defining a new scope.\n        These can be Module, FunctionDef, ClassDef, Lambda, or GeneratorExp nodes.\n\n        :returns: The first parent scope node.\n        \"\"\"\n        if not self.parent:\n            raise ParentMissingError(target=self)\n        return self.parent.scope()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "scope", "self", "nodes", "localsdictnodeng", "the", "first", "parent", "node", "defining", "a", "new", "scope", "these", "can", "be", "module", "functiondef", "classdef", "lambda", "or", "generatorexp", "nodes", "returns", "the", "first", "parent", "scope", "node", "if", "not", "self", "parent", "raise", "parentmissingerror", "target", "self", "return", "self", "parent", "scope"], "doc_len": 46}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.root", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "root", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def root(self):\n        \"\"\"Return the root node of the syntax tree.\n\n        :returns: The root node.\n        :rtype: Module\n        \"\"\"\n        if self.parent:\n            return self.parent.root()\n        return self\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "root", "self", "return", "the", "root", "node", "of", "the", "syntax", "tree", "returns", "the", "root", "node", "rtype", "module", "if", "self", "parent", "return", "self", "parent", "root", "return", "self"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.child_sequence", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "child_sequence", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def child_sequence(self, child):\n        \"\"\"Search for the sequence that contains this child.\n\n        :param child: The child node to search sequences for.\n        :type child: NodeNG\n\n        :returns: The sequence containing the given child node.\n        :rtype: iterable(NodeNG)\n\n        :raises AstroidError: If no sequence could be found that contains\n            the given child.\n        \"\"\"\n        for field in self._astroid_fields:\n            node_or_sequence = getattr(self, field)\n            if node_or_sequence is child:\n                return [node_or_sequence]\n            # /!\\ compiler.ast Nodes have an __iter__ walking over child nodes\n            if (\n                isinstance(node_or_sequence, (tuple, list))\n                and child in node_or_sequence\n            ):\n                return node_or_sequence\n\n        msg = \"Could not find %s in %s's children\"\n        raise AstroidError(msg % (repr(child), repr(self)))\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "child_sequence", "self", "child", "search", "for", "the", "sequence", "that", "contains", "this", "child", "param", "child", "the", "child", "node", "to", "search", "sequences", "for", "type", "child", "nodeng", "returns", "the", "sequence", "containing", "the", "given", "child", "node", "rtype", "iterable", "nodeng", "raises", "astroiderror", "if", "no", "sequence", "could", "be", "found", "that", "contains", "the", "given", "child", "for", "field", "in", "self", "_astroid_fields", "node_or_sequence", "getattr", "self", "field", "if", "node_or_sequence", "is", "child", "return", "node_or_sequence", "compiler", "ast", "nodes", "have", "an", "__iter__", "walking", "over", "child", "nodes", "if", "isinstance", "node_or_sequence", "tuple", "list", "and", "child", "in", "node_or_sequence", "return", "node_or_sequence", "msg", "could", "not", "find", "s", "in", "s", "s", "children", "raise", "astroiderror", "msg", "repr", "child", "repr", "self"], "doc_len": 105}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.locate_child", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "locate_child", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def locate_child(self, child):\n        \"\"\"Find the field of this node that contains the given child.\n\n        :param child: The child node to search fields for.\n        :type child: NodeNG\n\n        :returns: A tuple of the name of the field that contains the child,\n            and the sequence or node that contains the child node.\n        :rtype: tuple(str, iterable(NodeNG) or NodeNG)\n\n        :raises AstroidError: If no field could be found that contains\n            the given child.\n        \"\"\"\n        for field in self._astroid_fields:\n            node_or_sequence = getattr(self, field)\n            # /!\\ compiler.ast Nodes have an __iter__ walking over child nodes\n            if child is node_or_sequence:\n                return field, child\n            if (\n                isinstance(node_or_sequence, (tuple, list))\n                and child in node_or_sequence\n            ):\n                return field, node_or_sequence\n        msg = \"Could not find %s in %s's children\"\n        raise AstroidError(msg % (repr(child), repr(self)))\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "locate_child", "self", "child", "find", "the", "field", "of", "this", "node", "that", "contains", "the", "given", "child", "param", "child", "the", "child", "node", "to", "search", "fields", "for", "type", "child", "nodeng", "returns", "a", "tuple", "of", "the", "name", "of", "the", "field", "that", "contains", "the", "child", "and", "the", "sequence", "or", "node", "that", "contains", "the", "child", "node", "rtype", "tuple", "str", "iterable", "nodeng", "or", "nodeng", "raises", "astroiderror", "if", "no", "field", "could", "be", "found", "that", "contains", "the", "given", "child", "for", "field", "in", "self", "_astroid_fields", "node_or_sequence", "getattr", "self", "field", "compiler", "ast", "nodes", "have", "an", "__iter__", "walking", "over", "child", "nodes", "if", "child", "is", "node_or_sequence", "return", "field", "child", "if", "isinstance", "node_or_sequence", "tuple", "list", "and", "child", "in", "node_or_sequence", "return", "field", "node_or_sequence", "msg", "could", "not", "find", "s", "in", "s", "s", "children", "raise", "astroiderror", "msg", "repr", "child", "repr", "self"], "doc_len": 129}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.next_sibling", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "next_sibling", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def next_sibling(self):\n        \"\"\"The next sibling statement node.\n\n        :returns: The next sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n        return self.parent.next_sibling()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "next_sibling", "self", "the", "next", "sibling", "statement", "node", "returns", "the", "next", "sibling", "statement", "node", "rtype", "nodeng", "or", "none", "return", "self", "parent", "next_sibling"], "doc_len": 27}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.previous_sibling", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "previous_sibling", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def previous_sibling(self):\n        \"\"\"The previous sibling statement.\n\n        :returns: The previous sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n        return self.parent.previous_sibling()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "previous_sibling", "self", "the", "previous", "sibling", "statement", "returns", "the", "previous", "sibling", "statement", "node", "rtype", "nodeng", "or", "none", "return", "self", "parent", "previous_sibling"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.fromlineno", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "fromlineno", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def fromlineno(self) -> Optional[int]:\n        \"\"\"The first line that this node appears on in the source code.\"\"\"\n        if self.lineno is None:\n            return self._fixed_source_line()\n        return self.lineno\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "fromlineno", "self", "optional", "int", "the", "first", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "if", "self", "lineno", "is", "none", "return", "self", "_fixed_source_line", "return", "self", "lineno"], "doc_len": 33}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.tolineno", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "tolineno", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def tolineno(self) -> Optional[int]:\n        \"\"\"The last line that this node appears on in the source code.\"\"\"\n        if not self._astroid_fields:\n            # can't have children\n            last_child = None\n        else:\n            last_child = self.last_child()\n        if last_child is None:\n            return self.fromlineno\n        return last_child.tolineno\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "tolineno", "self", "optional", "int", "the", "last", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "if", "not", "self", "_astroid_fields", "can", "t", "have", "children", "last_child", "none", "else", "last_child", "self", "last_child", "if", "last_child", "is", "none", "return", "self", "fromlineno", "return", "last_child", "tolineno"], "doc_len": 46}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._fixed_source_line", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_fixed_source_line", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _fixed_source_line(self) -> Optional[int]:\n        \"\"\"Attempt to find the line that this node appears on.\n\n        We need this method since not all nodes have :attr:`lineno` set.\n        \"\"\"\n        line = self.lineno\n        _node: Optional[NodeNG] = self\n        try:\n            while line is None:\n                _node = next(_node.get_children())\n                line = _node.lineno\n        except StopIteration:\n            _node = self.parent\n            while _node and line is None:\n                line = _node.lineno\n                _node = _node.parent\n        return line\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_fixed_source_line", "self", "optional", "int", "attempt", "to", "find", "the", "line", "that", "this", "node", "appears", "on", "we", "need", "this", "method", "since", "not", "all", "nodes", "have", "attr", "lineno", "set", "line", "self", "lineno", "_node", "optional", "nodeng", "self", "try", "while", "line", "is", "none", "_node", "next", "_node", "get_children", "line", "_node", "lineno", "except", "stopiteration", "_node", "self", "parent", "while", "_node", "and", "line", "is", "none", "line", "_node", "lineno", "_node", "_node", "parent", "return", "line"], "doc_len": 70}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.block_range", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "block_range", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: The line number to start the range at.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n            starting at the given line number.\n        :rtype: tuple(int, int or None)\n        \"\"\"\n        return lineno, self.tolineno\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "the", "line", "number", "to", "start", "the", "range", "at", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "starting", "at", "the", "given", "line", "number", "rtype", "tuple", "int", "int", "or", "none", "return", "lineno", "self", "tolineno"], "doc_len": 62}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.set_local", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "set_local", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def set_local(self, name, stmt):\n        \"\"\"Define that the given name is declared in the given statement node.\n\n        This definition is stored on the parent scope node.\n\n        .. seealso:: :meth:`scope`\n\n        :param name: The name that is being defined.\n        :type name: str\n\n        :param stmt: The statement that defines the given name.\n        :type stmt: NodeNG\n        \"\"\"\n        self.parent.set_local(name, stmt)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "set_local", "self", "name", "stmt", "define", "that", "the", "given", "name", "is", "declared", "in", "the", "given", "statement", "node", "this", "definition", "is", "stored", "on", "the", "parent", "scope", "node", "seealso", "meth", "scope", "param", "name", "the", "name", "that", "is", "being", "defined", "type", "name", "str", "param", "stmt", "the", "statement", "that", "defines", "the", "given", "name", "type", "stmt", "nodeng", "self", "parent", "set_local", "name", "stmt"], "doc_len": 62}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.nodes_of_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "nodes_of_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def nodes_of_class(\n        self,\n        klass: Type[T_Nodes],\n        skip_klass: SkipKlassT = None,\n    ) -> Iterator[T_Nodes]:\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "nodes_of_class", "self", "klass", "type", "t_nodes", "skip_klass", "skipklasst", "none", "iterator", "t_nodes"], "doc_len": 16}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.nodes_of_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "nodes_of_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def nodes_of_class(\n        self,\n        klass: Tuple[Type[T_Nodes], Type[T_Nodes2]],\n        skip_klass: SkipKlassT = None,\n    ) -> Union[Iterator[T_Nodes], Iterator[T_Nodes2]]:\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "nodes_of_class", "self", "klass", "tuple", "type", "t_nodes", "type", "t_nodes2", "skip_klass", "skipklasst", "none", "union", "iterator", "t_nodes", "iterator", "t_nodes2"], "doc_len": 22}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.nodes_of_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "nodes_of_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def nodes_of_class(\n        self,\n        klass: Tuple[Type[T_Nodes], Type[T_Nodes2], Type[T_Nodes3]],\n        skip_klass: SkipKlassT = None,\n    ) -> Union[Iterator[T_Nodes], Iterator[T_Nodes2], Iterator[T_Nodes3]]:\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "nodes_of_class", "self", "klass", "tuple", "type", "t_nodes", "type", "t_nodes2", "type", "t_nodes3", "skip_klass", "skipklasst", "none", "union", "iterator", "t_nodes", "iterator", "t_nodes2", "iterator", "t_nodes3"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.nodes_of_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "nodes_of_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def nodes_of_class(\n        self,\n        klass: Tuple[Type[T_Nodes], ...],\n        skip_klass: SkipKlassT = None,\n    ) -> Iterator[T_Nodes]:\n        ...\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "nodes_of_class", "self", "klass", "tuple", "type", "t_nodes", "skip_klass", "skipklasst", "none", "iterator", "t_nodes"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.nodes_of_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "nodes_of_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def nodes_of_class(  # type: ignore[misc] # mypy doesn't correctly recognize the overloads\n        self,\n        klass: Union[\n            Type[T_Nodes],\n            Tuple[Type[T_Nodes], Type[T_Nodes2]],\n            Tuple[Type[T_Nodes], Type[T_Nodes2], Type[T_Nodes3]],\n            Tuple[Type[T_Nodes], ...],\n        ],\n        skip_klass: SkipKlassT = None,\n    ) -> Union[Iterator[T_Nodes], Iterator[T_Nodes2], Iterator[T_Nodes3]]:\n        \"\"\"Get the nodes (including this one or below) of the given types.\n\n        :param klass: The types of node to search for.\n\n        :param skip_klass: The types of node to ignore. This is useful to ignore\n            subclasses of :attr:`klass`.\n\n        :returns: The node of the given types.\n        \"\"\"\n        if isinstance(self, klass):\n            yield self\n\n        if skip_klass is None:\n            for child_node in self.get_children():\n                yield from child_node.nodes_of_class(klass, skip_klass)\n\n            return\n\n        for child_node in self.get_children():\n            if isinstance(child_node, skip_klass):\n                continue\n            yield from child_node.nodes_of_class(klass, skip_klass)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "nodes_of_class", "type", "ignore", "misc", "mypy", "doesn", "t", "correctly", "recognize", "the", "overloads", "self", "klass", "union", "type", "t_nodes", "tuple", "type", "t_nodes", "type", "t_nodes2", "tuple", "type", "t_nodes", "type", "t_nodes2", "type", "t_nodes3", "tuple", "type", "t_nodes", "skip_klass", "skipklasst", "none", "union", "iterator", "t_nodes", "iterator", "t_nodes2", "iterator", "t_nodes3", "get", "the", "nodes", "including", "this", "one", "or", "below", "of", "the", "given", "types", "param", "klass", "the", "types", "of", "node", "to", "search", "for", "param", "skip_klass", "the", "types", "of", "node", "to", "ignore", "this", "is", "useful", "to", "ignore", "subclasses", "of", "attr", "klass", "returns", "the", "node", "of", "the", "given", "types", "if", "isinstance", "self", "klass", "yield", "self", "if", "skip_klass", "is", "none", "for", "child_node", "in", "self", "get_children", "yield", "from", "child_node", "nodes_of_class", "klass", "skip_klass", "return", "for", "child_node", "in", "self", "get_children", "if", "isinstance", "child_node", "skip_klass", "continue", "yield", "from", "child_node", "nodes_of_class", "klass", "skip_klass"], "doc_len": 130}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._get_assign_nodes", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_get_assign_nodes", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _get_assign_nodes(self):\n        return []\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_get_assign_nodes", "self", "return"], "doc_len": 9}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._get_name_nodes", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_get_name_nodes", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _get_name_nodes(self):\n        for child_node in self.get_children():\n            yield from child_node._get_name_nodes()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_get_name_nodes", "self", "for", "child_node", "in", "self", "get_children", "yield", "from", "child_node", "_get_name_nodes"], "doc_len": 17}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._get_return_nodes_skip_functions", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_get_return_nodes_skip_functions", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _get_return_nodes_skip_functions(self):\n        yield from ()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_get_return_nodes_skip_functions", "self", "yield", "from"], "doc_len": 10}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._get_yield_nodes_skip_lambdas", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_get_yield_nodes_skip_lambdas", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _get_yield_nodes_skip_lambdas(self):\n        yield from ()\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_get_yield_nodes_skip_lambdas", "self", "yield", "from"], "doc_len": 10}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._infer_name", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_infer_name", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _infer_name(self, frame, name):\n        # overridden for ImportFrom, Import, Global, TryExcept and Arguments\n        pass\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_infer_name", "self", "frame", "name", "overridden", "for", "importfrom", "import", "global", "tryexcept", "and", "arguments", "pass"], "doc_len": 19}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG._infer", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "_infer", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def _infer(self, context=None):\n        \"\"\"we don't know how to resolve a statement by default\"\"\"\n        # this method is overridden by most concrete classes\n        raise InferenceError(\n            \"No inference function for {node!r}.\", node=self, context=context\n        )\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "_infer", "self", "context", "none", "we", "don", "t", "know", "how", "to", "resolve", "a", "statement", "by", "default", "this", "method", "is", "overridden", "by", "most", "concrete", "classes", "raise", "inferenceerror", "no", "inference", "function", "for", "node", "r", "node", "self", "context", "context"], "doc_len": 41}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.inferred", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "inferred", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def inferred(self):\n        \"\"\"Get a list of the inferred values.\n\n        .. seealso:: :ref:`inference`\n\n        :returns: The inferred values.\n        :rtype: list\n        \"\"\"\n        return list(self.infer())\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "inferred", "self", "get", "a", "list", "of", "the", "inferred", "values", "seealso", "ref", "inference", "returns", "the", "inferred", "values", "rtype", "list", "return", "list", "self", "infer"], "doc_len": 28}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.instantiate_class", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "instantiate_class", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def instantiate_class(self):\n        \"\"\"Instantiate an instance of the defined class.\n\n        .. note::\n\n            On anything other than a :class:`ClassDef` this will return self.\n\n        :returns: An instance of the defined class.\n        :rtype: object\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "instantiate_class", "self", "instantiate", "an", "instance", "of", "the", "defined", "class", "note", "on", "anything", "other", "than", "a", "class", "classdef", "this", "will", "return", "self", "returns", "an", "instance", "of", "the", "defined", "class", "rtype", "object", "return", "self"], "doc_len": 38}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.has_base", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "has_base", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def has_base(self, node):\n        \"\"\"Check if this node inherits from the given type.\n\n        :param node: The node defining the base to look for.\n            Usually this is a :class:`Name` node.\n        :type node: NodeNG\n        \"\"\"\n        return False\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "has_base", "self", "node", "check", "if", "this", "node", "inherits", "from", "the", "given", "type", "param", "node", "the", "node", "defining", "the", "base", "to", "look", "for", "usually", "this", "is", "a", "class", "name", "node", "type", "node", "nodeng", "return", "false"], "doc_len": 40}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.callable", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "callable", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def callable(self):\n        \"\"\"Whether this node defines something that is callable.\n\n        :returns: True if this defines something that is callable,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        return False\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "callable", "self", "whether", "this", "node", "defines", "something", "that", "is", "callable", "returns", "true", "if", "this", "defines", "something", "that", "is", "callable", "false", "otherwise", "rtype", "bool", "return", "false"], "doc_len": 31}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.eq", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "eq", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def eq(self, value):\n        return False\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "eq", "self", "value", "return", "false"], "doc_len": 11}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.as_string", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "as_string", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def as_string(self) -> str:\n        \"\"\"Get the source code that this node represents.\"\"\"\n        return AsStringVisitor()(self)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "as_string", "self", "str", "get", "the", "source", "code", "that", "this", "node", "represents", "return", "asstringvisitor", "self"], "doc_len": 20}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.repr_tree", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "repr_tree", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def repr_tree(\n        self,\n        ids=False,\n        include_linenos=False,\n        ast_state=False,\n        indent=\"   \",\n        max_depth=0,\n        max_width=80,\n    ) -> str:\n        \"\"\"Get a string representation of the AST from this node.\n\n        :param ids: If true, includes the ids with the node type names.\n        :type ids: bool\n\n        :param include_linenos: If true, includes the line numbers and\n            column offsets.\n        :type include_linenos: bool\n\n        :param ast_state: If true, includes information derived from\n            the whole AST like local and global variables.\n        :type ast_state: bool\n\n        :param indent: A string to use to indent the output string.\n        :type indent: str\n\n        :param max_depth: If set to a positive integer, won't return\n            nodes deeper than max_depth in the string.\n        :type max_depth: int\n\n        :param max_width: Attempt to format the output string to stay\n            within this number of characters, but can exceed it under some\n            circumstances. Only positive integer values are valid, the default is 80.\n        :type max_width: int\n\n        :returns: The string representation of the AST.\n        :rtype: str\n        \"\"\"\n\n        @_singledispatch\n        def _repr_tree(node, result, done, cur_indent=\"\", depth=1):\n            \"\"\"Outputs a representation of a non-tuple/list, non-node that's\n            contained within an AST, including strings.\n            \"\"\"\n            lines = pprint.pformat(\n                node, width=max(max_width - len(cur_indent), 1)\n            ).splitlines(True)\n            result.append(lines[0])\n            result.extend([cur_indent + line for line in lines[1:]])\n            return len(lines) != 1\n\n        # pylint: disable=unused-variable,useless-suppression; doesn't understand singledispatch\n        @_repr_tree.register(tuple)\n        @_repr_tree.register(list)\n        def _repr_seq(node, result, done, cur_indent=\"\", depth=1):\n            \"\"\"Outputs a representation of a sequence that's contained within an AST.\"\"\"\n            cur_indent += indent\n            result.append(\"[\")\n            if not node:\n                broken = False\n            elif len(node) == 1:\n                broken = _repr_tree(node[0], result, done, cur_indent, depth)\n            elif len(node) == 2:\n                broken = _repr_tree(node[0], result, done, cur_indent, depth)\n                if not broken:\n                    result.append(\", \")\n                else:\n                    result.append(\",\\n\")\n                    result.append(cur_indent)\n                broken = _repr_tree(node[1], result, done, cur_indent, depth) or broken\n            else:\n                result.append(\"\\n\")\n                result.append(cur_indent)\n                for child in node[:-1]:\n                    _repr_tree(child, result, done, cur_indent, depth)\n                    result.append(\",\\n\")\n                    result.append(cur_indent)\n                _repr_tree(node[-1], result, done, cur_indent, depth)\n                broken = True\n            result.append(\"]\")\n            return broken\n\n        # pylint: disable=unused-variable,useless-suppression; doesn't understand singledispatch\n        @_repr_tree.register(NodeNG)\n        def _repr_node(node, result, done, cur_indent=\"\", depth=1):\n            \"\"\"Outputs a strings representation of an astroid node.\"\"\"\n            if node in done:\n                result.append(\n                    indent + f\"<Recursion on {type(node).__name__} with id={id(node)}\"\n                )\n                return False\n            done.add(node)\n\n            if max_depth and depth > max_depth:\n                result.append(\"...\")\n                return False\n            depth += 1\n            cur_indent += indent\n            if ids:\n                result.append(f\"{type(node).__name__}<0x{id(node):x}>(\\n\")\n            else:\n                result.append(f\"{type(node).__name__}(\")\n            fields = []\n            if include_linenos:\n                fields.extend((\"lineno\", \"col_offset\"))\n            fields.extend(node._other_fields)\n            fields.extend(node._astroid_fields)\n            if ast_state:\n                fields.extend(node._other_other_fields)\n            if not fields:\n                broken = False\n            elif len(fields) == 1:\n                result.append(f\"{fields[0]}=\")\n                broken = _repr_tree(\n                    getattr(node, fields[0]), result, done, cur_indent, depth\n                )\n            else:\n                result.append(\"\\n\")\n                result.append(cur_indent)\n                for field in fields[:-1]:\n                    result.append(f\"{field}=\")\n                    _repr_tree(getattr(node, field), result, done, cur_indent, depth)\n                    result.append(\",\\n\")\n                    result.append(cur_indent)\n                result.append(f\"{fields[-1]}=\")\n                _repr_tree(getattr(node, fields[-1]), result, done, cur_indent, depth)\n                broken = True\n            result.append(\")\")\n            return broken\n\n        result: List[str] = []\n        _repr_tree(self, result, set())\n        return \"\".join(result)\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "repr_tree", "self", "ids", "false", "include_linenos", "false", "ast_state", "false", "indent", "max_depth", "0", "max_width", "80", "str", "get", "a", "string", "representation", "of", "the", "ast", "from", "this", "node", "param", "ids", "if", "true", "includes", "the", "ids", "with", "the", "node", "type", "names", "type", "ids", "bool", "param", "include_linenos", "if", "true", "includes", "the", "line", "numbers", "and", "column", "offsets", "type", "include_linenos", "bool", "param", "ast_state", "if", "true", "includes", "information", "derived", "from", "the", "whole", "ast", "like", "local", "and", "global", "variables", "type", "ast_state", "bool", "param", "indent", "a", "string", "to", "use", "to", "indent", "the", "output", "string", "type", "indent", "str", "param", "max_depth", "if", "set", "to", "a", "positive", "integer", "won", "t", "return", "nodes", "deeper", "than", "max_depth", "in", "the", "string", "type", "max_depth", "int", "param", "max_width", "attempt", "to", "format", "the", "output", "string", "to", "stay", "within", "this", "number", "of", "characters", "but", "can", "exceed", "it", "under", "some", "circumstances", "only", "positive", "integer", "values", "are", "valid", "the", "default", "is", "80", "type", "max_width", "int", "returns", "the", "string", "representation", "of", "the", "ast", "rtype", "str", "_singledispatch", "def", "_repr_tree", "node", "result", "done", "cur_indent", "depth", "1", "outputs", "a", "representation", "of", "a", "non", "tuple", "list", "non", "node", "that", "s", "contained", "within", "an", "ast", "including", "strings", "lines", "pprint", "pformat", "node", "width", "max", "max_width", "len", "cur_indent", "1", "splitlines", "true", "result", "append", "lines", "0", "result", "extend", "cur_indent", "line", "for", "line", "in", "lines", "1", "return", "len", "lines", "1", "pylint", "disable", "unused", "variable", "useless", "suppression", "doesn", "t", "understand", "singledispatch", "_repr_tree", "register", "tuple", "_repr_tree", "register", "list", "def", "_repr_seq", "node", "result", "done", "cur_indent", "depth", "1", "outputs", "a", "representation", "of", "a", "sequence", "that", "s", "contained", "within", "an", "ast", "cur_indent", "indent", "result", "append", "if", "not", "node", "broken", "false", "elif", "len", "node", "1", "broken", "_repr_tree", "node", "0", "result", "done", "cur_indent", "depth", "elif", "len", "node", "2", "broken", "_repr_tree", "node", "0", "result", "done", "cur_indent", "depth", "if", "not", "broken", "result", "append", "else", "result", "append", "n", "result", "append", "cur_indent", "broken", "_repr_tree", "node", "1", "result", "done", "cur_indent", "depth", "or", "broken", "else", "result", "append", "n", "result", "append", "cur_indent", "for", "child", "in", "node", "1", "_repr_tree", "child", "result", "done", "cur_indent", "depth", "result", "append", "n", "result", "append", "cur_indent", "_repr_tree", "node", "1", "result", "done", "cur_indent", "depth", "broken", "true", "result", "append", "return", "broken", "pylint", "disable", "unused", "variable", "useless", "suppression", "doesn", "t", "understand", "singledispatch", "_repr_tree", "register", "nodeng", "def", "_repr_node", "node", "result", "done", "cur_indent", "depth", "1", "outputs", "a", "strings", "representation", "of", "an", "astroid", "node", "if", "node", "in", "done", "result", "append", "indent", "f", "recursion", "on", "type", "node", "__name__", "with", "id", "id", "node", "return", "false", "done", "add", "node", "if", "max_depth", "and", "depth", "max_depth", "result", "append", "return", "false", "depth", "1", "cur_indent", "indent", "if", "ids", "result", "append", "f", "type", "node", "__name__", "0x", "id", "node", "x", "n", "else", "result", "append", "f", "type", "node", "__name__", "fields", "if", "include_linenos", "fields", "extend", "lineno", "col_offset", "fields", "extend", "node", "_other_fields", "fields", "extend", "node", "_astroid_fields", "if", "ast_state", "fields", "extend", "node", "_other_other_fields", "if", "not", "fields", "broken", "false", "elif", "len", "fields", "1", "result", "append", "f", "fields", "0", "broken", "_repr_tree", "getattr", "node", "fields", "0", "result", "done", "cur_indent", "depth", "else", "result", "append", "n", "result", "append", "cur_indent", "for", "field", "in", "fields", "1", "result", "append", "f", "field", "_repr_tree", "getattr", "node", "field", "result", "done", "cur_indent", "depth", "result", "append", "n", "result", "append", "cur_indent", "result", "append", "f", "fields", "1", "_repr_tree", "getattr", "node", "fields", "1", "result", "done", "cur_indent", "depth", "broken", "true", "result", "append", "return", "broken", "result", "list", "str", "_repr_tree", "self", "result", "set", "return", "join", "result"], "doc_len": 530}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.bool_value", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "bool_value", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        The boolean value of a node can have three\n        possible values:\n\n            * False: For instance, empty data structures,\n              False, empty strings, instances which return\n              explicitly False from the __nonzero__ / __bool__\n              method.\n            * True: Most of constructs are True by default:\n              classes, functions, modules etc\n            * Uninferable: The inference engine is uncertain of the\n              node's value.\n\n        :returns: The boolean value of this node.\n        :rtype: bool or Uninferable\n        \"\"\"\n        return util.Uninferable\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "the", "boolean", "value", "of", "a", "node", "can", "have", "three", "possible", "values", "false", "for", "instance", "empty", "data", "structures", "false", "empty", "strings", "instances", "which", "return", "explicitly", "false", "from", "the", "__nonzero__", "__bool__", "method", "true", "most", "of", "constructs", "are", "true", "by", "default", "classes", "functions", "modules", "etc", "uninferable", "the", "inference", "engine", "is", "uncertain", "of", "the", "node", "s", "value", "returns", "the", "boolean", "value", "of", "this", "node", "rtype", "bool", "or", "uninferable", "return", "util", "uninferable"], "doc_len": 84}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.op_precedence", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "op_precedence", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def op_precedence(self):\n        # Look up by class name or default to highest precedence\n        return OP_PRECEDENCE.get(self.__class__.__name__, len(OP_PRECEDENCE))\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "op_precedence", "self", "look", "up", "by", "class", "name", "or", "default", "to", "highest", "precedence", "return", "op_precedence", "get", "self", "__class__", "__name__", "len", "op_precedence"], "doc_len": 26}
{"doc_id": "astroid/nodes/node_ng.py::NodeNG.op_left_associative", "file_path": "astroid/nodes/node_ng.py", "class_name": "NodeNG", "func_name": "op_left_associative", "text": "文件路径: astroid/nodes/node_ng.py, 类名: NodeNG\n    def op_left_associative(self):\n        # Everything is left associative except `**` and IfExp\n        return True\n", "tokens": ["astroid", "nodes", "node_ng", "py", "nodeng", "def", "op_left_associative", "self", "everything", "is", "left", "associative", "except", "and", "ifexp", "return", "true"], "doc_len": 17}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_c3_merge", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "_c3_merge", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef _c3_merge(sequences, cls, context):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n\n    Adapted from http://www.python.org/download/releases/2.3/mro/.\n\n    \"\"\"\n    result = []\n    while True:\n        sequences = [s for s in sequences if s]  # purge empty sequences\n        if not sequences:\n            return result\n        for s1 in sequences:  # find merge candidates among seq heads\n            candidate = s1[0]\n            for s2 in sequences:\n                if candidate in s2[1:]:\n                    candidate = None\n                    break  # reject the current head, it appears later\n            else:\n                break\n        if not candidate:\n            # Show all the remaining bases, which were considered as\n            # candidates for the next mro sequence.\n            raise InconsistentMroError(\n                message=\"Cannot create a consistent method resolution order \"\n                \"for MROs {mros} of class {cls!r}.\",\n                mros=sequences,\n                cls=cls,\n                context=context,\n            )\n\n        result.append(candidate)\n        # remove the chosen candidate\n        for seq in sequences:\n            if seq[0] == candidate:\n                del seq[0]\n    return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "_c3_merge", "sequences", "cls", "context", "merges", "mros", "in", "sequences", "to", "a", "single", "mro", "using", "the", "c3", "algorithm", "adapted", "from", "http", "www", "python", "org", "download", "releases", "2", "3", "mro", "result", "while", "true", "sequences", "s", "for", "s", "in", "sequences", "if", "s", "purge", "empty", "sequences", "if", "not", "sequences", "return", "result", "for", "s1", "in", "sequences", "find", "merge", "candidates", "among", "seq", "heads", "candidate", "s1", "0", "for", "s2", "in", "sequences", "if", "candidate", "in", "s2", "1", "candidate", "none", "break", "reject", "the", "current", "head", "it", "appears", "later", "else", "break", "if", "not", "candidate", "show", "all", "the", "remaining", "bases", "which", "were", "considered", "as", "candidates", "for", "the", "next", "mro", "sequence", "raise", "inconsistentmroerror", "message", "cannot", "create", "a", "consistent", "method", "resolution", "order", "for", "mros", "mros", "of", "class", "cls", "r", "mros", "sequences", "cls", "cls", "context", "context", "result", "append", "candidate", "remove", "the", "chosen", "candidate", "for", "seq", "in", "sequences", "if", "seq", "0", "candidate", "del", "seq", "0", "return", "none"], "doc_len": 147}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::clean_typing_generic_mro", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "clean_typing_generic_mro", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef clean_typing_generic_mro(sequences: List[List[\"ClassDef\"]]) -> None:\n    \"\"\"A class can inherit from typing.Generic directly, as base,\n    and as base of bases. The merged MRO must however only contain the last entry.\n    To prepare for _c3_merge, remove some typing.Generic entries from\n    sequences if multiple are present.\n\n    This method will check if Generic is in inferred_bases and also\n    part of bases_mro. If true, remove it from inferred_bases\n    as well as its entry the bases_mro.\n\n    Format sequences: [[self]] + bases_mro + [inferred_bases]\n    \"\"\"\n    bases_mro = sequences[1:-1]\n    inferred_bases = sequences[-1]\n    # Check if Generic is part of inferred_bases\n    for i, base in enumerate(inferred_bases):\n        if base.qname() == \"typing.Generic\":\n            position_in_inferred_bases = i\n            break\n    else:\n        return\n    # Check if also part of bases_mro\n    # Ignore entry for typing.Generic\n    for i, seq in enumerate(bases_mro):\n        if i == position_in_inferred_bases:\n            continue\n        if any(base.qname() == \"typing.Generic\" for base in seq):\n            break\n    else:\n        return\n    # Found multiple Generics in mro, remove entry from inferred_bases\n    # and the corresponding one from bases_mro\n    inferred_bases.pop(position_in_inferred_bases)\n    bases_mro.pop(position_in_inferred_bases)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "clean_typing_generic_mro", "sequences", "list", "list", "classdef", "none", "a", "class", "can", "inherit", "from", "typing", "generic", "directly", "as", "base", "and", "as", "base", "of", "bases", "the", "merged", "mro", "must", "however", "only", "contain", "the", "last", "entry", "to", "prepare", "for", "_c3_merge", "remove", "some", "typing", "generic", "entries", "from", "sequences", "if", "multiple", "are", "present", "this", "method", "will", "check", "if", "generic", "is", "in", "inferred_bases", "and", "also", "part", "of", "bases_mro", "if", "true", "remove", "it", "from", "inferred_bases", "as", "well", "as", "its", "entry", "the", "bases_mro", "format", "sequences", "self", "bases_mro", "inferred_bases", "bases_mro", "sequences", "1", "1", "inferred_bases", "sequences", "1", "check", "if", "generic", "is", "part", "of", "inferred_bases", "for", "i", "base", "in", "enumerate", "inferred_bases", "if", "base", "qname", "typing", "generic", "position_in_inferred_bases", "i", "break", "else", "return", "check", "if", "also", "part", "of", "bases_mro", "ignore", "entry", "for", "typing", "generic", "for", "i", "seq", "in", "enumerate", "bases_mro", "if", "i", "position_in_inferred_bases", "continue", "if", "any", "base", "qname", "typing", "generic", "for", "base", "in", "seq", "break", "else", "return", "found", "multiple", "generics", "in", "mro", "remove", "entry", "from", "inferred_bases", "and", "the", "corresponding", "one", "from", "bases_mro", "inferred_bases", "pop", "position_in_inferred_bases", "bases_mro", "pop", "position_in_inferred_bases"], "doc_len": 169}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::clean_duplicates_mro", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "clean_duplicates_mro", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef clean_duplicates_mro(sequences, cls, context):\n    for sequence in sequences:\n        names = [\n            (node.lineno, node.qname()) if node.name else None for node in sequence\n        ]\n        last_index = dict(map(reversed, enumerate(names)))\n        if names and names[0] is not None and last_index[names[0]] != 0:\n            raise DuplicateBasesError(\n                message=\"Duplicates found in MROs {mros} for {cls!r}.\",\n                mros=sequences,\n                cls=cls,\n                context=context,\n            )\n        yield [\n            node\n            for i, (node, name) in enumerate(zip(sequence, names))\n            if name is None or last_index[name] == i\n        ]\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "clean_duplicates_mro", "sequences", "cls", "context", "for", "sequence", "in", "sequences", "names", "node", "lineno", "node", "qname", "if", "node", "name", "else", "none", "for", "node", "in", "sequence", "last_index", "dict", "map", "reversed", "enumerate", "names", "if", "names", "and", "names", "0", "is", "not", "none", "and", "last_index", "names", "0", "0", "raise", "duplicatebaseserror", "message", "duplicates", "found", "in", "mros", "mros", "for", "cls", "r", "mros", "sequences", "cls", "cls", "context", "context", "yield", "node", "for", "i", "node", "name", "in", "enumerate", "zip", "sequence", "names", "if", "name", "is", "none", "or", "last_index", "name", "i"], "doc_len": 83}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::function_to_method", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "function_to_method", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef function_to_method(n, klass):\n    if isinstance(n, FunctionDef):\n        if n.type == \"classmethod\":\n            return bases.BoundMethod(n, klass)\n        if n.type == \"property\":\n            return n\n        if n.type != \"staticmethod\":\n            return bases.UnboundMethod(n)\n    return n\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "function_to_method", "n", "klass", "if", "isinstance", "n", "functiondef", "if", "n", "type", "classmethod", "return", "bases", "boundmethod", "n", "klass", "if", "n", "type", "property", "return", "n", "if", "n", "type", "staticmethod", "return", "bases", "unboundmethod", "n", "return", "n"], "doc_len": 38}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::builtin_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "builtin_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef builtin_lookup(name):\n    \"\"\"lookup a name into the builtin module\n    return the list of matching statements and the astroid for the builtin\n    module\n    \"\"\"\n    builtin_astroid = AstroidManager().ast_from_module(builtins)\n    if name == \"__dict__\":\n        return builtin_astroid, ()\n    try:\n        stmts = builtin_astroid.locals[name]\n    except KeyError:\n        stmts = ()\n    return builtin_astroid, stmts\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "builtin_lookup", "name", "lookup", "a", "name", "into", "the", "builtin", "module", "return", "the", "list", "of", "matching", "statements", "and", "the", "astroid", "for", "the", "builtin", "module", "builtin_astroid", "astroidmanager", "ast_from_module", "builtins", "if", "name", "__dict__", "return", "builtin_astroid", "try", "stmts", "builtin_astroid", "locals", "name", "except", "keyerror", "stmts", "return", "builtin_astroid", "stmts"], "doc_len": 48}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.qname", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "qname", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def qname(self):\n        \"\"\"Get the 'qualified' name of the node.\n\n        For example: module.name, module.class.name ...\n\n        :returns: The qualified name.\n        :rtype: str\n        \"\"\"\n        # pylint: disable=no-member; github.com/pycqa/astroid/issues/278\n        if self.parent is None:\n            return self.name\n        return f\"{self.parent.frame(future=True).qname()}.{self.name}\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "qname", "self", "get", "the", "qualified", "name", "of", "the", "node", "for", "example", "module", "name", "module", "class", "name", "returns", "the", "qualified", "name", "rtype", "str", "pylint", "disable", "no", "member", "github", "com", "pycqa", "astroid", "issues", "278", "if", "self", "parent", "is", "none", "return", "self", "name", "return", "f", "self", "parent", "frame", "future", "true", "qname", "self", "name"], "doc_len": 57}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.scope", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "scope", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def scope(self: T) -> T:\n        \"\"\"The first parent node defining a new scope.\n\n        :returns: The first parent scope node.\n        :rtype: Module or FunctionDef or ClassDef or Lambda or GenExpr\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "scope", "self", "t", "t", "the", "first", "parent", "node", "defining", "a", "new", "scope", "returns", "the", "first", "parent", "scope", "node", "rtype", "module", "or", "functiondef", "or", "classdef", "or", "lambda", "or", "genexpr", "return", "self"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG._scope_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "_scope_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def _scope_lookup(self, node, name, offset=0):\n        \"\"\"XXX method for interfacing the scope lookup\"\"\"\n        try:\n            stmts = _filter_stmts(node, self.locals[name], self, offset)\n        except KeyError:\n            stmts = ()\n        if stmts:\n            return self, stmts\n\n        # Handle nested scopes: since class names do not extend to nested\n        # scopes (e.g., methods), we find the next enclosing non-class scope\n        pscope = self.parent and self.parent.scope()\n        while pscope is not None:\n            if not isinstance(pscope, ClassDef):\n                return pscope.scope_lookup(node, name)\n            pscope = pscope.parent and pscope.parent.scope()\n\n        # self is at the top level of a module, or is enclosed only by ClassDefs\n        return builtin_lookup(name)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "_scope_lookup", "self", "node", "name", "offset", "0", "xxx", "method", "for", "interfacing", "the", "scope", "lookup", "try", "stmts", "_filter_stmts", "node", "self", "locals", "name", "self", "offset", "except", "keyerror", "stmts", "if", "stmts", "return", "self", "stmts", "handle", "nested", "scopes", "since", "class", "names", "do", "not", "extend", "to", "nested", "scopes", "e", "g", "methods", "we", "find", "the", "next", "enclosing", "non", "class", "scope", "pscope", "self", "parent", "and", "self", "parent", "scope", "while", "pscope", "is", "not", "none", "if", "not", "isinstance", "pscope", "classdef", "return", "pscope", "scope_lookup", "node", "name", "pscope", "pscope", "parent", "and", "pscope", "parent", "scope", "self", "is", "at", "the", "top", "level", "of", "a", "module", "or", "is", "enclosed", "only", "by", "classdefs", "return", "builtin_lookup", "name"], "doc_len": 107}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.set_local", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "set_local", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def set_local(self, name, stmt):\n        \"\"\"Define that the given name is declared in the given statement node.\n\n        .. seealso:: :meth:`scope`\n\n        :param name: The name that is being defined.\n        :type name: str\n\n        :param stmt: The statement that defines the given name.\n        :type stmt: NodeNG\n        \"\"\"\n        # assert not stmt in self.locals.get(name, ()), (self, stmt)\n        self.locals.setdefault(name, []).append(stmt)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "set_local", "self", "name", "stmt", "define", "that", "the", "given", "name", "is", "declared", "in", "the", "given", "statement", "node", "seealso", "meth", "scope", "param", "name", "the", "name", "that", "is", "being", "defined", "type", "name", "str", "param", "stmt", "the", "statement", "that", "defines", "the", "given", "name", "type", "stmt", "nodeng", "assert", "not", "stmt", "in", "self", "locals", "get", "name", "self", "stmt", "self", "locals", "setdefault", "name", "append", "stmt"], "doc_len": 65}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG._append_node", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "_append_node", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def _append_node(self, child):\n        \"\"\"append a child, linking it in the tree\"\"\"\n        # pylint: disable=no-member; depending by the class\n        # which uses the current class as a mixin or base class.\n        # It's rewritten in 2.0, so it makes no sense for now\n        # to spend development time on it.\n        self.body.append(child)\n        child.parent = self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "_append_node", "self", "child", "append", "a", "child", "linking", "it", "in", "the", "tree", "pylint", "disable", "no", "member", "depending", "by", "the", "class", "which", "uses", "the", "current", "class", "as", "a", "mixin", "or", "base", "class", "it", "s", "rewritten", "in", "2", "0", "so", "it", "makes", "no", "sense", "for", "now", "to", "spend", "development", "time", "on", "it", "self", "body", "append", "child", "child", "parent", "self"], "doc_len": 63}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.add_local_node", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "add_local_node", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def add_local_node(self, child_node, name=None):\n        \"\"\"Append a child that should alter the locals of this scope node.\n\n        :param child_node: The child node that will alter locals.\n        :type child_node: NodeNG\n\n        :param name: The name of the local that will be altered by\n            the given child node.\n        :type name: str or None\n        \"\"\"\n        if name != \"__class__\":\n            # add __class__ node as a child will cause infinite recursion later!\n            self._append_node(child_node)\n        self.set_local(name or child_node.name, child_node)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "add_local_node", "self", "child_node", "name", "none", "append", "a", "child", "that", "should", "alter", "the", "locals", "of", "this", "scope", "node", "param", "child_node", "the", "child", "node", "that", "will", "alter", "locals", "type", "child_node", "nodeng", "param", "name", "the", "name", "of", "the", "local", "that", "will", "be", "altered", "by", "the", "given", "child", "node", "type", "name", "str", "or", "none", "if", "name", "__class__", "add", "__class__", "node", "as", "a", "child", "will", "cause", "infinite", "recursion", "later", "self", "_append_node", "child_node", "self", "set_local", "name", "or", "child_node", "name", "child_node"], "doc_len": 81}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.__getitem__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "__getitem__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def __getitem__(self, item):\n        \"\"\"The first node the defines the given local.\n\n        :param item: The name of the locally defined object.\n        :type item: str\n\n        :raises KeyError: If the name is not defined.\n        \"\"\"\n        return self.locals[item][0]\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "__getitem__", "self", "item", "the", "first", "node", "the", "defines", "the", "given", "local", "param", "item", "the", "name", "of", "the", "locally", "defined", "object", "type", "item", "str", "raises", "keyerror", "if", "the", "name", "is", "not", "defined", "return", "self", "locals", "item", "0"], "doc_len": 43}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.__iter__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "__iter__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def __iter__(self):\n        \"\"\"Iterate over the names of locals defined in this scoped node.\n\n        :returns: The names of the defined locals.\n        :rtype: iterable(str)\n        \"\"\"\n        return iter(self.keys())\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "__iter__", "self", "iterate", "over", "the", "names", "of", "locals", "defined", "in", "this", "scoped", "node", "returns", "the", "names", "of", "the", "defined", "locals", "rtype", "iterable", "str", "return", "iter", "self", "keys"], "doc_len": 34}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.keys", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "keys", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def keys(self):\n        \"\"\"The names of locals defined in this scoped node.\n\n        :returns: The names of the defined locals.\n        :rtype: list(str)\n        \"\"\"\n        return list(self.locals.keys())\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "keys", "self", "the", "names", "of", "locals", "defined", "in", "this", "scoped", "node", "returns", "the", "names", "of", "the", "defined", "locals", "rtype", "list", "str", "return", "list", "self", "locals", "keys"], "doc_len": 33}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.values", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "values", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def values(self):\n        \"\"\"The nodes that define the locals in this scoped node.\n\n        :returns: The nodes that define locals.\n        :rtype: list(NodeNG)\n        \"\"\"\n        # pylint: disable=consider-using-dict-items\n        # It look like this class override items/keys/values,\n        # probably not worth the headache\n        return [self[key] for key in self.keys()]\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "values", "self", "the", "nodes", "that", "define", "the", "locals", "in", "this", "scoped", "node", "returns", "the", "nodes", "that", "define", "locals", "rtype", "list", "nodeng", "pylint", "disable", "consider", "using", "dict", "items", "it", "look", "like", "this", "class", "override", "items", "keys", "values", "probably", "not", "worth", "the", "headache", "return", "self", "key", "for", "key", "in", "self", "keys"], "doc_len": 56}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.items", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "items", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def items(self):\n        \"\"\"Get the names of the locals and the node that defines the local.\n\n        :returns: The names of locals and their associated node.\n        :rtype: list(tuple(str, NodeNG))\n        \"\"\"\n        return list(zip(self.keys(), self.values()))\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "items", "self", "get", "the", "names", "of", "the", "locals", "and", "the", "node", "that", "defines", "the", "local", "returns", "the", "names", "of", "locals", "and", "their", "associated", "node", "rtype", "list", "tuple", "str", "nodeng", "return", "list", "zip", "self", "keys", "self", "values"], "doc_len": 43}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::LocalsDictNodeNG.__contains__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "LocalsDictNodeNG", "func_name": "__contains__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: LocalsDictNodeNG\n    def __contains__(self, name):\n        \"\"\"Check if a local is defined in this scope.\n\n        :param name: The name of the local to check for.\n        :type name: str\n\n        :returns: True if this node has a local of the given name,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        return name in self.locals\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "localsdictnodeng", "def", "__contains__", "self", "name", "check", "if", "a", "local", "is", "defined", "in", "this", "scope", "param", "name", "the", "name", "of", "the", "local", "to", "check", "for", "type", "name", "str", "returns", "true", "if", "this", "node", "has", "a", "local", "of", "the", "given", "name", "false", "otherwise", "rtype", "bool", "return", "name", "in", "self", "locals"], "doc_len": 53}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def __init__(\n        self,\n        name,\n        doc,\n        file=None,\n        path: Optional[List[str]] = None,\n        package=None,\n        parent=None,\n        pure_python=True,\n    ):\n        \"\"\"\n        :param name: The name of the module.\n        :type name: str\n\n        :param doc: The module docstring.\n        :type doc: str\n\n        :param file: The path to the file that this ast has been extracted from.\n        :type file: str or None\n\n        :param path:\n        :type path: Optional[List[str]]\n\n        :param package: Whether the node represents a package or a module.\n        :type package: bool or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param pure_python: Whether the ast was built from source.\n        :type pure_python: bool or None\n        \"\"\"\n        self.name = name\n        self.doc = doc\n        self.file = file\n        self.path = path\n        self.package = package\n        self.pure_python = pure_python\n        self.locals = self.globals = {}\n        \"\"\"A map of the name of a local variable to the node defining the local.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n        self.body = []\n        \"\"\"The contents of the module.\n\n        :type: list(NodeNG) or None\n        \"\"\"\n        self.future_imports = set()\n\n        super().__init__(lineno=0, parent=parent)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "__init__", "self", "name", "doc", "file", "none", "path", "optional", "list", "str", "none", "package", "none", "parent", "none", "pure_python", "true", "param", "name", "the", "name", "of", "the", "module", "type", "name", "str", "param", "doc", "the", "module", "docstring", "type", "doc", "str", "param", "file", "the", "path", "to", "the", "file", "that", "this", "ast", "has", "been", "extracted", "from", "type", "file", "str", "or", "none", "param", "path", "type", "path", "optional", "list", "str", "param", "package", "whether", "the", "node", "represents", "a", "package", "or", "a", "module", "type", "package", "bool", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "pure_python", "whether", "the", "ast", "was", "built", "from", "source", "type", "pure_python", "bool", "or", "none", "self", "name", "name", "self", "doc", "doc", "self", "file", "file", "self", "path", "path", "self", "package", "package", "self", "pure_python", "pure_python", "self", "locals", "self", "globals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "the", "local", "type", "dict", "str", "nodeng", "self", "body", "the", "contents", "of", "the", "module", "type", "list", "nodeng", "or", "none", "self", "future_imports", "set", "super", "__init__", "lineno", "0", "parent", "parent"], "doc_len": 174}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def postinit(self, body=None):\n        \"\"\"Do some setup after initialisation.\n\n        :param body: The contents of the module.\n        :type body: list(NodeNG) or None\n        \"\"\"\n        self.body = body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "postinit", "self", "body", "none", "do", "some", "setup", "after", "initialisation", "param", "body", "the", "contents", "of", "the", "module", "type", "body", "list", "nodeng", "or", "none", "self", "body", "body"], "doc_len": 32}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module._get_stream", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "_get_stream", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def _get_stream(self):\n        if self.file_bytes is not None:\n            return io.BytesIO(self.file_bytes)\n        if self.file is not None:\n            # pylint: disable=consider-using-with\n            stream = open(self.file, \"rb\")\n            return stream\n        return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "_get_stream", "self", "if", "self", "file_bytes", "is", "not", "none", "return", "io", "bytesio", "self", "file_bytes", "if", "self", "file", "is", "not", "none", "pylint", "disable", "consider", "using", "with", "stream", "open", "self", "file", "rb", "return", "stream", "return", "none"], "doc_len": 40}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.stream", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "stream", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def stream(self):\n        \"\"\"Get a stream to the underlying file or bytes.\n\n        :type: file or io.BytesIO or None\n        \"\"\"\n        return self._get_stream()\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "stream", "self", "get", "a", "stream", "to", "the", "underlying", "file", "or", "bytes", "type", "file", "or", "io", "bytesio", "or", "none", "return", "self", "_get_stream"], "doc_len": 28}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.block_range", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "block_range", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def block_range(self, lineno):\n        \"\"\"Get a range from where this node starts to where this node ends.\n\n        :param lineno: Unused.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to.\n        :rtype: tuple(int, int)\n        \"\"\"\n        return self.fromlineno, self.tolineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "where", "this", "node", "starts", "to", "where", "this", "node", "ends", "param", "lineno", "unused", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "rtype", "tuple", "int", "int", "return", "self", "fromlineno", "self", "tolineno"], "doc_len": 49}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.scope_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "scope_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def scope_lookup(self, node, name, offset=0):\n        \"\"\"Lookup where the given variable is assigned.\n\n        :param node: The node to look for assignments up to.\n            Any assignments after the given node are ignored.\n        :type node: NodeNG\n\n        :param name: The name of the variable to find assignments for.\n        :type name: str\n\n        :param offset: The line offset to filter statements up to.\n        :type offset: int\n\n        :returns: This scope node and the list of assignments associated to the\n            given name according to the scope where it has been found (locals,\n            globals or builtin).\n        :rtype: tuple(str, list(NodeNG))\n        \"\"\"\n        if name in self.scope_attrs and name not in self.locals:\n            try:\n                return self, self.getattr(name)\n            except AttributeInferenceError:\n                return self, ()\n        return self._scope_lookup(node, name, offset)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "scope_lookup", "self", "node", "name", "offset", "0", "lookup", "where", "the", "given", "variable", "is", "assigned", "param", "node", "the", "node", "to", "look", "for", "assignments", "up", "to", "any", "assignments", "after", "the", "given", "node", "are", "ignored", "type", "node", "nodeng", "param", "name", "the", "name", "of", "the", "variable", "to", "find", "assignments", "for", "type", "name", "str", "param", "offset", "the", "line", "offset", "to", "filter", "statements", "up", "to", "type", "offset", "int", "returns", "this", "scope", "node", "and", "the", "list", "of", "assignments", "associated", "to", "the", "given", "name", "according", "to", "the", "scope", "where", "it", "has", "been", "found", "locals", "globals", "or", "builtin", "rtype", "tuple", "str", "list", "nodeng", "if", "name", "in", "self", "scope_attrs", "and", "name", "not", "in", "self", "locals", "try", "return", "self", "self", "getattr", "name", "except", "attributeinferenceerror", "return", "self", "return", "self", "_scope_lookup", "node", "name", "offset"], "doc_len": 127}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.pytype", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "pytype", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        return \"builtins.module\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "return", "builtins", "module"], "doc_len": 30}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.display_type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "display_type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def display_type(self):\n        \"\"\"A human readable type of this node.\n\n        :returns: The type of this node.\n        :rtype: str\n        \"\"\"\n        return \"Module\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "display_type", "self", "a", "human", "readable", "type", "of", "this", "node", "returns", "the", "type", "of", "this", "node", "rtype", "str", "return", "module"], "doc_len": 26}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.getattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "getattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def getattr(self, name, context=None, ignore_locals=False):\n        if not name:\n            raise AttributeInferenceError(target=self, attribute=name, context=context)\n\n        result = []\n        name_in_locals = name in self.locals\n\n        if name in self.special_attributes and not ignore_locals and not name_in_locals:\n            result = [self.special_attributes.lookup(name)]\n        elif not ignore_locals and name_in_locals:\n            result = self.locals[name]\n        elif self.package:\n            try:\n                result = [self.import_module(name, relative_only=True)]\n            except (AstroidBuildingError, SyntaxError) as exc:\n                raise AttributeInferenceError(\n                    target=self, attribute=name, context=context\n                ) from exc\n        result = [n for n in result if not isinstance(n, node_classes.DelName)]\n        if result:\n            return result\n        raise AttributeInferenceError(target=self, attribute=name, context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "getattr", "self", "name", "context", "none", "ignore_locals", "false", "if", "not", "name", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "result", "name_in_locals", "name", "in", "self", "locals", "if", "name", "in", "self", "special_attributes", "and", "not", "ignore_locals", "and", "not", "name_in_locals", "result", "self", "special_attributes", "lookup", "name", "elif", "not", "ignore_locals", "and", "name_in_locals", "result", "self", "locals", "name", "elif", "self", "package", "try", "result", "self", "import_module", "name", "relative_only", "true", "except", "astroidbuildingerror", "syntaxerror", "as", "exc", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "from", "exc", "result", "n", "for", "n", "in", "result", "if", "not", "isinstance", "n", "node_classes", "delname", "if", "result", "return", "result", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context"], "doc_len": 105}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.igetattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "igetattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def igetattr(self, name, context=None):\n        \"\"\"Infer the possible values of the given variable.\n\n        :param name: The name of the variable to infer.\n        :type name: str\n\n        :returns: The inferred possible values.\n        :rtype: iterable(NodeNG) or None\n        \"\"\"\n        # set lookup name since this is necessary to infer on import nodes for\n        # instance\n        context = copy_context(context)\n        context.lookupname = name\n        try:\n            return bases._infer_stmts(self.getattr(name, context), context, frame=self)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=name, context=context\n            ) from error\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "igetattr", "self", "name", "context", "none", "infer", "the", "possible", "values", "of", "the", "given", "variable", "param", "name", "the", "name", "of", "the", "variable", "to", "infer", "type", "name", "str", "returns", "the", "inferred", "possible", "values", "rtype", "iterable", "nodeng", "or", "none", "set", "lookup", "name", "since", "this", "is", "necessary", "to", "infer", "on", "import", "nodes", "for", "instance", "context", "copy_context", "context", "context", "lookupname", "name", "try", "return", "bases", "_infer_stmts", "self", "getattr", "name", "context", "context", "frame", "self", "except", "attributeinferenceerror", "as", "error", "raise", "inferenceerror", "str", "error", "target", "self", "attribute", "name", "context", "context", "from", "error"], "doc_len": 89}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.fully_defined", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "fully_defined", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def fully_defined(self):\n        \"\"\"Check if this module has been build from a .py file.\n\n        If so, the module contains a complete representation,\n        including the code.\n\n        :returns: True if the module has been built from a .py file.\n        :rtype: bool\n        \"\"\"\n        return self.file is not None and self.file.endswith(\".py\")\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "fully_defined", "self", "check", "if", "this", "module", "has", "been", "build", "from", "a", "py", "file", "if", "so", "the", "module", "contains", "a", "complete", "representation", "including", "the", "code", "returns", "true", "if", "the", "module", "has", "been", "built", "from", "a", "py", "file", "rtype", "bool", "return", "self", "file", "is", "not", "none", "and", "self", "file", "endswith", "py"], "doc_len": 56}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.statement", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "statement", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def statement(self, *, future: Literal[None] = ...) -> \"Module\":\n        ...\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "statement", "self", "future", "literal", "none", "module"], "doc_len": 13}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.statement", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "statement", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def statement(self, *, future: Literal[True]) -> NoReturn:\n        ...\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "statement", "self", "future", "literal", "true", "noreturn"], "doc_len": 13}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.statement", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "statement", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def statement(\n        self, *, future: Literal[None, True] = None\n    ) -> Union[\"NoReturn\", \"Module\"]:\n        \"\"\"The first parent node, including self, marked as statement node.\n\n        When called on a :class:`Module` with the future parameter this raises an error.\n\n        TODO: Deprecate the future parameter and only raise StatementMissing\n\n        :raises StatementMissing: If no self has no parent attribute and future is True\n        \"\"\"\n        if future:\n            raise StatementMissing(target=self)\n        warnings.warn(\n            \"In astroid 3.0.0 NodeNG.statement() will return either a nodes.Statement \"\n            \"or raise a StatementMissing exception. nodes.Module will no longer be \"\n            \"considered a statement. This behaviour can already be triggered \"\n            \"by passing 'future=True' to a statement() call.\",\n            DeprecationWarning,\n        )\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "statement", "self", "future", "literal", "none", "true", "none", "union", "noreturn", "module", "the", "first", "parent", "node", "including", "self", "marked", "as", "statement", "node", "when", "called", "on", "a", "class", "module", "with", "the", "future", "parameter", "this", "raises", "an", "error", "todo", "deprecate", "the", "future", "parameter", "and", "only", "raise", "statementmissing", "raises", "statementmissing", "if", "no", "self", "has", "no", "parent", "attribute", "and", "future", "is", "true", "if", "future", "raise", "statementmissing", "target", "self", "warnings", "warn", "in", "astroid", "3", "0", "0", "nodeng", "statement", "will", "return", "either", "a", "nodes", "statement", "or", "raise", "a", "statementmissing", "exception", "nodes", "module", "will", "no", "longer", "be", "considered", "a", "statement", "this", "behaviour", "can", "already", "be", "triggered", "by", "passing", "future", "true", "to", "a", "statement", "call", "deprecationwarning", "return", "self"], "doc_len": 115}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.previous_sibling", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "previous_sibling", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def previous_sibling(self):\n        \"\"\"The previous sibling statement.\n\n        :returns: The previous sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "previous_sibling", "self", "the", "previous", "sibling", "statement", "returns", "the", "previous", "sibling", "statement", "node", "rtype", "nodeng", "or", "none"], "doc_len": 23}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.next_sibling", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "next_sibling", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def next_sibling(self):\n        \"\"\"The next sibling statement node.\n\n        :returns: The next sibling statement node.\n        :rtype: NodeNG or None\n        \"\"\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "next_sibling", "self", "the", "next", "sibling", "statement", "node", "returns", "the", "next", "sibling", "statement", "node", "rtype", "nodeng", "or", "none"], "doc_len": 24}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.absolute_import_activated", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "absolute_import_activated", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def absolute_import_activated(self):\n        \"\"\"Whether :pep:`328` absolute import behaviour has been enabled.\n\n        :returns: True if :pep:`328` has been enabled, False otherwise.\n        :rtype: bool\n        \"\"\"\n        return self._absolute_import_activated\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "absolute_import_activated", "self", "whether", "pep", "328", "absolute", "import", "behaviour", "has", "been", "enabled", "returns", "true", "if", "pep", "328", "has", "been", "enabled", "false", "otherwise", "rtype", "bool", "return", "self", "_absolute_import_activated"], "doc_len": 33}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.import_module", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "import_module", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def import_module(self, modname, relative_only=False, level=None):\n        \"\"\"Get the ast for a given module as if imported from this module.\n\n        :param modname: The name of the module to \"import\".\n        :type modname: str\n\n        :param relative_only: Whether to only consider relative imports.\n        :type relative_only: bool\n\n        :param level: The level of relative import.\n        :type level: int or None\n\n        :returns: The imported module ast.\n        :rtype: NodeNG\n        \"\"\"\n        if relative_only and level is None:\n            level = 0\n        absmodname = self.relative_to_absolute_name(modname, level)\n\n        try:\n            return AstroidManager().ast_from_module_name(absmodname)\n        except AstroidBuildingError:\n            # we only want to import a sub module or package of this module,\n            # skip here\n            if relative_only:\n                raise\n        return AstroidManager().ast_from_module_name(modname)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "import_module", "self", "modname", "relative_only", "false", "level", "none", "get", "the", "ast", "for", "a", "given", "module", "as", "if", "imported", "from", "this", "module", "param", "modname", "the", "name", "of", "the", "module", "to", "import", "type", "modname", "str", "param", "relative_only", "whether", "to", "only", "consider", "relative", "imports", "type", "relative_only", "bool", "param", "level", "the", "level", "of", "relative", "import", "type", "level", "int", "or", "none", "returns", "the", "imported", "module", "ast", "rtype", "nodeng", "if", "relative_only", "and", "level", "is", "none", "level", "0", "absmodname", "self", "relative_to_absolute_name", "modname", "level", "try", "return", "astroidmanager", "ast_from_module_name", "absmodname", "except", "astroidbuildingerror", "we", "only", "want", "to", "import", "a", "sub", "module", "or", "package", "of", "this", "module", "skip", "here", "if", "relative_only", "raise", "return", "astroidmanager", "ast_from_module_name", "modname"], "doc_len": 111}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.relative_to_absolute_name", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "relative_to_absolute_name", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def relative_to_absolute_name(self, modname: str, level: int) -> str:\n        \"\"\"Get the absolute module name for a relative import.\n\n        The relative import can be implicit or explicit.\n\n        :param modname: The module name to convert.\n\n        :param level: The level of relative import.\n\n        :returns: The absolute module name.\n\n        :raises TooManyLevelsError: When the relative import refers to a\n            module too far above this one.\n        \"\"\"\n        # XXX this returns non sens when called on an absolute import\n        # like 'pylint.checkers.astroid.utils'\n        # XXX doesn't return absolute name if self.name isn't absolute name\n        if self.absolute_import_activated() and level is None:\n            return modname\n        if level:\n            if self.package:\n                level = level - 1\n                package_name = self.name.rsplit(\".\", level)[0]\n            elif (\n                self.path\n                and not os.path.exists(os.path.dirname(self.path[0]) + \"/__init__.py\")\n                and os.path.exists(\n                    os.path.dirname(self.path[0]) + \"/\" + modname.split(\".\")[0]\n                )\n            ):\n                level = level - 1\n                package_name = \"\"\n            else:\n                package_name = self.name.rsplit(\".\", level)[0]\n            if level and self.name.count(\".\") < level:\n                raise TooManyLevelsError(level=level, name=self.name)\n\n        elif self.package:\n            package_name = self.name\n        else:\n            package_name = self.name.rsplit(\".\", 1)[0]\n\n        if package_name:\n            if not modname:\n                return package_name\n            return f\"{package_name}.{modname}\"\n        return modname\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "relative_to_absolute_name", "self", "modname", "str", "level", "int", "str", "get", "the", "absolute", "module", "name", "for", "a", "relative", "import", "the", "relative", "import", "can", "be", "implicit", "or", "explicit", "param", "modname", "the", "module", "name", "to", "convert", "param", "level", "the", "level", "of", "relative", "import", "returns", "the", "absolute", "module", "name", "raises", "toomanylevelserror", "when", "the", "relative", "import", "refers", "to", "a", "module", "too", "far", "above", "this", "one", "xxx", "this", "returns", "non", "sens", "when", "called", "on", "an", "absolute", "import", "like", "pylint", "checkers", "astroid", "utils", "xxx", "doesn", "t", "return", "absolute", "name", "if", "self", "name", "isn", "t", "absolute", "name", "if", "self", "absolute_import_activated", "and", "level", "is", "none", "return", "modname", "if", "level", "if", "self", "package", "level", "level", "1", "package_name", "self", "name", "rsplit", "level", "0", "elif", "self", "path", "and", "not", "os", "path", "exists", "os", "path", "dirname", "self", "path", "0", "__init__", "py", "and", "os", "path", "exists", "os", "path", "dirname", "self", "path", "0", "modname", "split", "0", "level", "level", "1", "package_name", "else", "package_name", "self", "name", "rsplit", "level", "0", "if", "level", "and", "self", "name", "count", "level", "raise", "toomanylevelserror", "level", "level", "name", "self", "name", "elif", "self", "package", "package_name", "self", "name", "else", "package_name", "self", "name", "rsplit", "1", "0", "if", "package_name", "if", "not", "modname", "return", "package_name", "return", "f", "package_name", "modname", "return", "modname"], "doc_len": 197}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.wildcard_import_names", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "wildcard_import_names", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def wildcard_import_names(self):\n        \"\"\"The list of imported names when this module is 'wildcard imported'.\n\n        It doesn't include the '__builtins__' name which is added by the\n        current CPython implementation of wildcard imports.\n\n        :returns: The list of imported names.\n        :rtype: list(str)\n        \"\"\"\n        # We separate the different steps of lookup in try/excepts\n        # to avoid catching too many Exceptions\n        default = [name for name in self.keys() if not name.startswith(\"_\")]\n        try:\n            all_values = self[\"__all__\"]\n        except KeyError:\n            return default\n\n        try:\n            explicit = next(all_values.assigned_stmts())\n        except (InferenceError, StopIteration):\n            return default\n        except AttributeError:\n            # not an assignment node\n            # XXX infer?\n            return default\n\n        # Try our best to detect the exported name.\n        inferred = []\n        try:\n            explicit = next(explicit.infer())\n        except (InferenceError, StopIteration):\n            return default\n        if not isinstance(explicit, (node_classes.Tuple, node_classes.List)):\n            return default\n\n        def str_const(node):\n            return isinstance(node, node_classes.Const) and isinstance(node.value, str)\n\n        for node in explicit.elts:\n            if str_const(node):\n                inferred.append(node.value)\n            else:\n                try:\n                    inferred_node = next(node.infer())\n                except (InferenceError, StopIteration):\n                    continue\n                if str_const(inferred_node):\n                    inferred.append(inferred_node.value)\n        return inferred\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "wildcard_import_names", "self", "the", "list", "of", "imported", "names", "when", "this", "module", "is", "wildcard", "imported", "it", "doesn", "t", "include", "the", "__builtins__", "name", "which", "is", "added", "by", "the", "current", "cpython", "implementation", "of", "wildcard", "imports", "returns", "the", "list", "of", "imported", "names", "rtype", "list", "str", "we", "separate", "the", "different", "steps", "of", "lookup", "in", "try", "excepts", "to", "avoid", "catching", "too", "many", "exceptions", "default", "name", "for", "name", "in", "self", "keys", "if", "not", "name", "startswith", "_", "try", "all_values", "self", "__all__", "except", "keyerror", "return", "default", "try", "explicit", "next", "all_values", "assigned_stmts", "except", "inferenceerror", "stopiteration", "return", "default", "except", "attributeerror", "not", "an", "assignment", "node", "xxx", "infer", "return", "default", "try", "our", "best", "to", "detect", "the", "exported", "name", "inferred", "try", "explicit", "next", "explicit", "infer", "except", "inferenceerror", "stopiteration", "return", "default", "if", "not", "isinstance", "explicit", "node_classes", "tuple", "node_classes", "list", "return", "default", "def", "str_const", "node", "return", "isinstance", "node", "node_classes", "const", "and", "isinstance", "node", "value", "str", "for", "node", "in", "explicit", "elts", "if", "str_const", "node", "inferred", "append", "node", "value", "else", "try", "inferred_node", "next", "node", "infer", "except", "inferenceerror", "stopiteration", "continue", "if", "str_const", "inferred_node", "inferred", "append", "inferred_node", "value", "return", "inferred"], "doc_len": 176}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.public_names", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "public_names", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def public_names(self):\n        \"\"\"The list of the names that are publicly available in this module.\n\n        :returns: The list of public names.\n        :rtype: list(str)\n        \"\"\"\n        return [name for name in self.keys() if not name.startswith(\"_\")]\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "public_names", "self", "the", "list", "of", "the", "names", "that", "are", "publicly", "available", "in", "this", "module", "returns", "the", "list", "of", "public", "names", "rtype", "list", "str", "return", "name", "for", "name", "in", "self", "keys", "if", "not", "name", "startswith", "_"], "doc_len": 42}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`Module` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "module", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def get_children(self):\n        yield from self.body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "get_children", "self", "yield", "from", "self", "body"], "doc_len": 13}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Module.frame", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Module", "func_name": "frame", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Module\n    def frame(self: T, *, future: Literal[None, True] = None) -> T:\n        \"\"\"The node's frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        :class:`ClassDef` or :class:`Lambda`.\n\n        :returns: The node itself.\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "module", "def", "frame", "self", "t", "future", "literal", "none", "true", "none", "t", "the", "node", "s", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "class", "classdef", "or", "class", "lambda", "returns", "the", "node", "itself", "return", "self"], "doc_len": 41}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::GeneratorExp.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "GeneratorExp", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: GeneratorExp\n    def __init__(\n        self,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining the local.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "generatorexp", "def", "__init__", "self", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "the", "local", "type", "dict", "str", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 143}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::GeneratorExp.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "GeneratorExp", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: GeneratorExp\n    def postinit(self, elt=None, generators=None):\n        \"\"\"Do some setup after initialisation.\n\n        :param elt: The element that forms the output of the expression.\n        :type elt: NodeNG or None\n\n        :param generators: The generators that are looped through.\n        :type generators: list(Comprehension) or None\n        \"\"\"\n        self.elt = elt\n        if generators is None:\n            self.generators = []\n        else:\n            self.generators = generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "generatorexp", "def", "postinit", "self", "elt", "none", "generators", "none", "do", "some", "setup", "after", "initialisation", "param", "elt", "the", "element", "that", "forms", "the", "output", "of", "the", "expression", "type", "elt", "nodeng", "or", "none", "param", "generators", "the", "generators", "that", "are", "looped", "through", "type", "generators", "list", "comprehension", "or", "none", "self", "elt", "elt", "if", "generators", "is", "none", "self", "generators", "else", "self", "generators", "generators"], "doc_len": 61}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::GeneratorExp.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "GeneratorExp", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: GeneratorExp\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`GeneratorExp` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "generatorexp", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "generatorexp", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::GeneratorExp.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "GeneratorExp", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: GeneratorExp\n    def get_children(self):\n        yield self.elt\n\n        yield from self.generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "generatorexp", "def", "get_children", "self", "yield", "self", "elt", "yield", "from", "self", "generators"], "doc_len": 16}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::DictComp.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "DictComp", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: DictComp\n    def __init__(\n        self,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining the local.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "dictcomp", "def", "__init__", "self", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "the", "local", "type", "dict", "str", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 143}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::DictComp.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "DictComp", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: DictComp\n    def postinit(self, key=None, value=None, generators=None):\n        \"\"\"Do some setup after initialisation.\n\n        :param key: What produces the keys.\n        :type key: NodeNG or None\n\n        :param value: What produces the values.\n        :type value: NodeNG or None\n\n        :param generators: The generators that are looped through.\n        :type generators: list(Comprehension) or None\n        \"\"\"\n        self.key = key\n        self.value = value\n        if generators is None:\n            self.generators = []\n        else:\n            self.generators = generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "dictcomp", "def", "postinit", "self", "key", "none", "value", "none", "generators", "none", "do", "some", "setup", "after", "initialisation", "param", "key", "what", "produces", "the", "keys", "type", "key", "nodeng", "or", "none", "param", "value", "what", "produces", "the", "values", "type", "value", "nodeng", "or", "none", "param", "generators", "the", "generators", "that", "are", "looped", "through", "type", "generators", "list", "comprehension", "or", "none", "self", "key", "key", "self", "value", "value", "if", "generators", "is", "none", "self", "generators", "else", "self", "generators", "generators"], "doc_len": 72}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::DictComp.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "DictComp", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: DictComp\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`DictComp` this is always :class:`Uninferable`.\n        :rtype: Uninferable\n        \"\"\"\n        return util.Uninferable\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "dictcomp", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "dictcomp", "this", "is", "always", "class", "uninferable", "rtype", "uninferable", "return", "util", "uninferable"], "doc_len": 39}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::DictComp.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "DictComp", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: DictComp\n    def get_children(self):\n        yield self.key\n        yield self.value\n\n        yield from self.generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "dictcomp", "def", "get_children", "self", "yield", "self", "key", "yield", "self", "value", "yield", "from", "self", "generators"], "doc_len": 19}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::SetComp.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "SetComp", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: SetComp\n    def __init__(\n        self,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining the local.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "setcomp", "def", "__init__", "self", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "the", "local", "type", "dict", "str", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 143}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::SetComp.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "SetComp", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: SetComp\n    def postinit(self, elt=None, generators=None):\n        \"\"\"Do some setup after initialisation.\n\n        :param elt: The element that forms the output of the expression.\n        :type elt: NodeNG or None\n\n        :param generators: The generators that are looped through.\n        :type generators: list(Comprehension) or None\n        \"\"\"\n        self.elt = elt\n        if generators is None:\n            self.generators = []\n        else:\n            self.generators = generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "setcomp", "def", "postinit", "self", "elt", "none", "generators", "none", "do", "some", "setup", "after", "initialisation", "param", "elt", "the", "element", "that", "forms", "the", "output", "of", "the", "expression", "type", "elt", "nodeng", "or", "none", "param", "generators", "the", "generators", "that", "are", "looped", "through", "type", "generators", "list", "comprehension", "or", "none", "self", "elt", "elt", "if", "generators", "is", "none", "self", "generators", "else", "self", "generators", "generators"], "doc_len": 61}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::SetComp.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "SetComp", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: SetComp\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`SetComp` this is always :class:`Uninferable`.\n        :rtype: Uninferable\n        \"\"\"\n        return util.Uninferable\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "setcomp", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "setcomp", "this", "is", "always", "class", "uninferable", "rtype", "uninferable", "return", "util", "uninferable"], "doc_len": 39}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::SetComp.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "SetComp", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: SetComp\n    def get_children(self):\n        yield self.elt\n\n        yield from self.generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "setcomp", "def", "get_children", "self", "yield", "self", "elt", "yield", "from", "self", "generators"], "doc_len": 16}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_ListComp.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "_ListComp", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: _ListComp\n    def postinit(self, elt=None, generators=None):\n        \"\"\"Do some setup after initialisation.\n\n        :param elt: The element that forms the output of the expression.\n        :type elt: NodeNG or None\n\n        :param generators: The generators that are looped through.\n        :type generators: list(Comprehension) or None\n        \"\"\"\n        self.elt = elt\n        self.generators = generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "_listcomp", "def", "postinit", "self", "elt", "none", "generators", "none", "do", "some", "setup", "after", "initialisation", "param", "elt", "the", "element", "that", "forms", "the", "output", "of", "the", "expression", "type", "elt", "nodeng", "or", "none", "param", "generators", "the", "generators", "that", "are", "looped", "through", "type", "generators", "list", "comprehension", "or", "none", "self", "elt", "elt", "self", "generators", "generators"], "doc_len": 54}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_ListComp.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "_ListComp", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: _ListComp\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`ListComp` this is always :class:`Uninferable`.\n        :rtype: Uninferable\n        \"\"\"\n        return util.Uninferable\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "_listcomp", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "listcomp", "this", "is", "always", "class", "uninferable", "rtype", "uninferable", "return", "util", "uninferable"], "doc_len": 39}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_ListComp.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "_ListComp", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: _ListComp\n    def get_children(self):\n        yield self.elt\n\n        yield from self.generators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "_listcomp", "def", "get_children", "self", "yield", "self", "elt", "yield", "from", "self", "generators"], "doc_len": 16}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ListComp.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ListComp", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ListComp\n    def __init__(\n        self,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining it.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "listcomp", "def", "__init__", "self", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "it", "type", "dict", "str", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 51}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_infer_decorator_callchain", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "_infer_decorator_callchain", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef _infer_decorator_callchain(node):\n    \"\"\"Detect decorator call chaining and see if the end result is a\n    static or a classmethod.\n    \"\"\"\n    if not isinstance(node, FunctionDef):\n        return None\n    if not node.parent:\n        return None\n    try:\n        result = next(node.infer_call_result(node.parent), None)\n    except InferenceError:\n        return None\n    if isinstance(result, bases.Instance):\n        result = result._proxied\n    if isinstance(result, ClassDef):\n        if result.is_subtype_of(\"builtins.classmethod\"):\n            return \"classmethod\"\n        if result.is_subtype_of(\"builtins.staticmethod\"):\n            return \"staticmethod\"\n    if isinstance(result, FunctionDef):\n        if not result.decorators:\n            return None\n        # Determine if this function is decorated with one of the builtin descriptors we want.\n        for decorator in result.decorators.nodes:\n            if isinstance(decorator, node_classes.Name):\n                if decorator.name in BUILTIN_DESCRIPTORS:\n                    return decorator.name\n            if (\n                isinstance(decorator, node_classes.Attribute)\n                and isinstance(decorator.expr, node_classes.Name)\n                and decorator.expr.name == \"builtins\"\n                and decorator.attrname in BUILTIN_DESCRIPTORS\n            ):\n                return decorator.attrname\n    return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "_infer_decorator_callchain", "node", "detect", "decorator", "call", "chaining", "and", "see", "if", "the", "end", "result", "is", "a", "static", "or", "a", "classmethod", "if", "not", "isinstance", "node", "functiondef", "return", "none", "if", "not", "node", "parent", "return", "none", "try", "result", "next", "node", "infer_call_result", "node", "parent", "none", "except", "inferenceerror", "return", "none", "if", "isinstance", "result", "bases", "instance", "result", "result", "_proxied", "if", "isinstance", "result", "classdef", "if", "result", "is_subtype_of", "builtins", "classmethod", "return", "classmethod", "if", "result", "is_subtype_of", "builtins", "staticmethod", "return", "staticmethod", "if", "isinstance", "result", "functiondef", "if", "not", "result", "decorators", "return", "none", "determine", "if", "this", "function", "is", "decorated", "with", "one", "of", "the", "builtin", "descriptors", "we", "want", "for", "decorator", "in", "result", "decorators", "nodes", "if", "isinstance", "decorator", "node_classes", "name", "if", "decorator", "name", "in", "builtin_descriptors", "return", "decorator", "name", "if", "isinstance", "decorator", "node_classes", "attribute", "and", "isinstance", "decorator", "expr", "node_classes", "name", "and", "decorator", "expr", "name", "builtins", "and", "decorator", "attrname", "in", "builtin_descriptors", "return", "decorator", "attrname", "return", "none"], "doc_len": 144}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.implicit_parameters", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "implicit_parameters", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def implicit_parameters(self):\n        return 0\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "implicit_parameters", "self", "return", "0"], "doc_len": 11}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def type(self):\n        \"\"\"Whether this is a method or function.\n\n        :returns: 'method' if this is a method, 'function' otherwise.\n        :rtype: str\n        \"\"\"\n        if self.args.arguments and self.args.arguments[0].name == \"self\":\n            if isinstance(self.parent.scope(), ClassDef):\n                return \"method\"\n        return \"function\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "type", "self", "whether", "this", "is", "a", "method", "or", "function", "returns", "method", "if", "this", "is", "a", "method", "function", "otherwise", "rtype", "str", "if", "self", "args", "arguments", "and", "self", "args", "arguments", "0", "name", "self", "if", "isinstance", "self", "parent", "scope", "classdef", "return", "method", "return", "function"], "doc_len": 48}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def __init__(\n        self,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining it.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        self.args: Arguments\n        \"\"\"The arguments that the function takes.\"\"\"\n\n        self.body = []\n        \"\"\"The contents of the function body.\n\n        :type: list(NodeNG)\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "__init__", "self", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "it", "type", "dict", "str", "nodeng", "self", "args", "arguments", "the", "arguments", "that", "the", "function", "takes", "self", "body", "the", "contents", "of", "the", "function", "body", "type", "list", "nodeng", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent"], "doc_len": 162}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def postinit(self, args: Arguments, body):\n        \"\"\"Do some setup after initialisation.\n\n        :param args: The arguments that the function takes.\n\n        :param body: The contents of the function body.\n        :type body: list(NodeNG)\n        \"\"\"\n        self.args = args\n        self.body = body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "postinit", "self", "args", "arguments", "body", "do", "some", "setup", "after", "initialisation", "param", "args", "the", "arguments", "that", "the", "function", "takes", "param", "body", "the", "contents", "of", "the", "function", "body", "type", "body", "list", "nodeng", "self", "args", "args", "self", "body", "body"], "doc_len": 43}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.pytype", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "pytype", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        if \"method\" in self.type:\n            return \"builtins.instancemethod\"\n        return \"builtins.function\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "if", "method", "in", "self", "type", "return", "builtins", "instancemethod", "return", "builtins", "function"], "doc_len": 38}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.display_type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "display_type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def display_type(self):\n        \"\"\"A human readable type of this node.\n\n        :returns: The type of this node.\n        :rtype: str\n        \"\"\"\n        if \"method\" in self.type:\n            return \"Method\"\n        return \"Function\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "display_type", "self", "a", "human", "readable", "type", "of", "this", "node", "returns", "the", "type", "of", "this", "node", "rtype", "str", "if", "method", "in", "self", "type", "return", "method", "return", "function"], "doc_len": 33}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.callable", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "callable", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def callable(self):\n        \"\"\"Whether this node defines something that is callable.\n\n        :returns: True if this defines something that is callable,\n            False otherwise.\n            For a :class:`Lambda` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "callable", "self", "whether", "this", "node", "defines", "something", "that", "is", "callable", "returns", "true", "if", "this", "defines", "something", "that", "is", "callable", "false", "otherwise", "for", "a", "class", "lambda", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 40}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.argnames", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "argnames", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def argnames(self):\n        \"\"\"Get the names of each of the arguments.\n\n        :returns: The names of the arguments.\n        :rtype: list(str)\n        \"\"\"\n        if self.args.arguments:  # maybe None with builtin functions\n            names = _rec_get_names(self.args.arguments)\n        else:\n            names = []\n        if self.args.vararg:\n            names.append(self.args.vararg)\n        if self.args.kwarg:\n            names.append(self.args.kwarg)\n        return names\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "argnames", "self", "get", "the", "names", "of", "each", "of", "the", "arguments", "returns", "the", "names", "of", "the", "arguments", "rtype", "list", "str", "if", "self", "args", "arguments", "maybe", "none", "with", "builtin", "functions", "names", "_rec_get_names", "self", "args", "arguments", "else", "names", "if", "self", "args", "vararg", "names", "append", "self", "args", "vararg", "if", "self", "args", "kwarg", "names", "append", "self", "args", "kwarg", "return", "names"], "doc_len": 62}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.infer_call_result", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "infer_call_result", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def infer_call_result(self, caller, context=None):\n        \"\"\"Infer what the function returns when called.\n\n        :param caller: Unused\n        :type caller: object\n        \"\"\"\n        # pylint: disable=no-member; github.com/pycqa/astroid/issues/291\n        # args is in fact redefined later on by postinit. Can't be changed\n        # to None due to a strong interaction between Lambda and FunctionDef.\n        return self.body.infer(context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "infer_call_result", "self", "caller", "context", "none", "infer", "what", "the", "function", "returns", "when", "called", "param", "caller", "unused", "type", "caller", "object", "pylint", "disable", "no", "member", "github", "com", "pycqa", "astroid", "issues", "291", "args", "is", "in", "fact", "redefined", "later", "on", "by", "postinit", "can", "t", "be", "changed", "to", "none", "due", "to", "a", "strong", "interaction", "between", "lambda", "and", "functiondef", "return", "self", "body", "infer", "context"], "doc_len": 64}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.scope_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "scope_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def scope_lookup(self, node, name, offset=0):\n        \"\"\"Lookup where the given names is assigned.\n\n        :param node: The node to look for assignments up to.\n            Any assignments after the given node are ignored.\n        :type node: NodeNG\n\n        :param name: The name to find assignments for.\n        :type name: str\n\n        :param offset: The line offset to filter statements up to.\n        :type offset: int\n\n        :returns: This scope node and the list of assignments associated to the\n            given name according to the scope where it has been found (locals,\n            globals or builtin).\n        :rtype: tuple(str, list(NodeNG))\n        \"\"\"\n        if node in self.args.defaults or node in self.args.kw_defaults:\n            frame = self.parent.frame(future=True)\n            # line offset to avoid that def func(f=func) resolve the default\n            # value to the defined function\n            offset = -1\n        else:\n            # check this is not used in function decorators\n            frame = self\n        return frame._scope_lookup(node, name, offset)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "scope_lookup", "self", "node", "name", "offset", "0", "lookup", "where", "the", "given", "names", "is", "assigned", "param", "node", "the", "node", "to", "look", "for", "assignments", "up", "to", "any", "assignments", "after", "the", "given", "node", "are", "ignored", "type", "node", "nodeng", "param", "name", "the", "name", "to", "find", "assignments", "for", "type", "name", "str", "param", "offset", "the", "line", "offset", "to", "filter", "statements", "up", "to", "type", "offset", "int", "returns", "this", "scope", "node", "and", "the", "list", "of", "assignments", "associated", "to", "the", "given", "name", "according", "to", "the", "scope", "where", "it", "has", "been", "found", "locals", "globals", "or", "builtin", "rtype", "tuple", "str", "list", "nodeng", "if", "node", "in", "self", "args", "defaults", "or", "node", "in", "self", "args", "kw_defaults", "frame", "self", "parent", "frame", "future", "true", "line", "offset", "to", "avoid", "that", "def", "func", "f", "func", "resolve", "the", "default", "value", "to", "the", "defined", "function", "offset", "1", "else", "check", "this", "is", "not", "used", "in", "function", "decorators", "frame", "self", "return", "frame", "_scope_lookup", "node", "name", "offset"], "doc_len": 151}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`Lambda` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "lambda", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def get_children(self):\n        yield self.args\n        yield self.body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "get_children", "self", "yield", "self", "args", "yield", "self", "body"], "doc_len": 15}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::Lambda.frame", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "Lambda", "func_name": "frame", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: Lambda\n    def frame(self: T, *, future: Literal[None, True] = None) -> T:\n        \"\"\"The node's frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        :class:`ClassDef` or :class:`Lambda`.\n\n        :returns: The node itself.\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "lambda", "def", "frame", "self", "t", "future", "literal", "none", "true", "none", "t", "the", "node", "s", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "class", "classdef", "or", "class", "lambda", "returns", "the", "node", "itself", "return", "self"], "doc_len": 41}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def __init__(\n        self,\n        name=None,\n        doc=None,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param name: The name of the function.\n        :type name: str or None\n\n        :param doc: The function's docstring.\n        :type doc: str or None\n\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.name = name\n        \"\"\"The name of the function.\n\n        :type name: str or None\n        \"\"\"\n\n        self.doc = doc\n        \"\"\"The function's docstring.\n\n        :type doc: str or None\n        \"\"\"\n\n        self.instance_attrs = {}\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n        if parent:\n            frame = parent.frame(future=True)\n            frame.set_local(name, self)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "__init__", "self", "name", "none", "doc", "none", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "name", "the", "name", "of", "the", "function", "type", "name", "str", "or", "none", "param", "doc", "the", "function", "s", "docstring", "type", "doc", "str", "or", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "name", "name", "the", "name", "of", "the", "function", "type", "name", "str", "or", "none", "self", "doc", "doc", "the", "function", "s", "docstring", "type", "doc", "str", "or", "none", "self", "instance_attrs", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent", "if", "parent", "frame", "parent", "frame", "future", "true", "frame", "set_local", "name", "self"], "doc_len": 187}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def postinit(\n        self,\n        args: Arguments,\n        body,\n        decorators=None,\n        returns=None,\n        type_comment_returns=None,\n        type_comment_args=None,\n    ):\n        \"\"\"Do some setup after initialisation.\n\n        :param args: The arguments that the function takes.\n\n        :param body: The contents of the function body.\n        :type body: list(NodeNG)\n\n        :param decorators: The decorators that are applied to this\n            method or function.\n        :type decorators: Decorators or None\n        :params type_comment_returns:\n            The return type annotation passed via a type comment.\n        :params type_comment_args:\n            The args type annotation passed via a type comment.\n        \"\"\"\n        self.args = args\n        self.body = body\n        self.decorators = decorators\n        self.returns = returns\n        self.type_comment_returns = type_comment_returns\n        self.type_comment_args = type_comment_args\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "postinit", "self", "args", "arguments", "body", "decorators", "none", "returns", "none", "type_comment_returns", "none", "type_comment_args", "none", "do", "some", "setup", "after", "initialisation", "param", "args", "the", "arguments", "that", "the", "function", "takes", "param", "body", "the", "contents", "of", "the", "function", "body", "type", "body", "list", "nodeng", "param", "decorators", "the", "decorators", "that", "are", "applied", "to", "this", "method", "or", "function", "type", "decorators", "decorators", "or", "none", "params", "type_comment_returns", "the", "return", "type", "annotation", "passed", "via", "a", "type", "comment", "params", "type_comment_args", "the", "args", "type", "annotation", "passed", "via", "a", "type", "comment", "self", "args", "args", "self", "body", "body", "self", "decorators", "decorators", "self", "returns", "returns", "self", "type_comment_returns", "type_comment_returns", "self", "type_comment_args", "type_comment_args"], "doc_len": 102}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.extra_decorators", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "extra_decorators", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def extra_decorators(self):\n        \"\"\"The extra decorators that this function can have.\n\n        Additional decorators are considered when they are used as\n        assignments, as in ``method = staticmethod(method)``.\n        The property will return all the callables that are used for\n        decoration.\n\n        :type: list(NodeNG)\n        \"\"\"\n        frame = self.parent.frame(future=True)\n        if not isinstance(frame, ClassDef):\n            return []\n\n        decorators = []\n        for assign in frame._get_assign_nodes():\n            if isinstance(assign.value, node_classes.Call) and isinstance(\n                assign.value.func, node_classes.Name\n            ):\n                for assign_node in assign.targets:\n                    if not isinstance(assign_node, node_classes.AssignName):\n                        # Support only `name = callable(name)`\n                        continue\n\n                    if assign_node.name != self.name:\n                        # Interested only in the assignment nodes that\n                        # decorates the current method.\n                        continue\n                    try:\n                        meth = frame[self.name]\n                    except KeyError:\n                        continue\n                    else:\n                        # Must be a function and in the same frame as the\n                        # original method.\n                        if (\n                            isinstance(meth, FunctionDef)\n                            and assign_node.frame(future=True) == frame\n                        ):\n                            decorators.append(assign.value)\n        return decorators\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "extra_decorators", "self", "the", "extra", "decorators", "that", "this", "function", "can", "have", "additional", "decorators", "are", "considered", "when", "they", "are", "used", "as", "assignments", "as", "in", "method", "staticmethod", "method", "the", "property", "will", "return", "all", "the", "callables", "that", "are", "used", "for", "decoration", "type", "list", "nodeng", "frame", "self", "parent", "frame", "future", "true", "if", "not", "isinstance", "frame", "classdef", "return", "decorators", "for", "assign", "in", "frame", "_get_assign_nodes", "if", "isinstance", "assign", "value", "node_classes", "call", "and", "isinstance", "assign", "value", "func", "node_classes", "name", "for", "assign_node", "in", "assign", "targets", "if", "not", "isinstance", "assign_node", "node_classes", "assignname", "support", "only", "name", "callable", "name", "continue", "if", "assign_node", "name", "self", "name", "interested", "only", "in", "the", "assignment", "nodes", "that", "decorates", "the", "current", "method", "continue", "try", "meth", "frame", "self", "name", "except", "keyerror", "continue", "else", "must", "be", "a", "function", "and", "in", "the", "same", "frame", "as", "the", "original", "method", "if", "isinstance", "meth", "functiondef", "and", "assign_node", "frame", "future", "true", "frame", "decorators", "append", "assign", "value", "return", "decorators"], "doc_len": 150}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def type(\n        self,\n    ):  # pylint: disable=invalid-overridden-method,too-many-return-statements\n        \"\"\"The function type for this node.\n\n        Possible values are: method, function, staticmethod, classmethod.\n\n        :type: str\n        \"\"\"\n        for decorator in self.extra_decorators:\n            if decorator.func.name in BUILTIN_DESCRIPTORS:\n                return decorator.func.name\n\n        frame = self.parent.frame(future=True)\n        type_name = \"function\"\n        if isinstance(frame, ClassDef):\n            if self.name == \"__new__\":\n                return \"classmethod\"\n            if self.name == \"__init_subclass__\":\n                return \"classmethod\"\n            if self.name == \"__class_getitem__\":\n                return \"classmethod\"\n\n            type_name = \"method\"\n\n        if not self.decorators:\n            return type_name\n\n        for node in self.decorators.nodes:\n            if isinstance(node, node_classes.Name):\n                if node.name in BUILTIN_DESCRIPTORS:\n                    return node.name\n            if (\n                isinstance(node, node_classes.Attribute)\n                and isinstance(node.expr, node_classes.Name)\n                and node.expr.name == \"builtins\"\n                and node.attrname in BUILTIN_DESCRIPTORS\n            ):\n                return node.attrname\n\n            if isinstance(node, node_classes.Call):\n                # Handle the following case:\n                # @some_decorator(arg1, arg2)\n                # def func(...)\n                #\n                try:\n                    current = next(node.func.infer())\n                except (InferenceError, StopIteration):\n                    continue\n                _type = _infer_decorator_callchain(current)\n                if _type is not None:\n                    return _type\n\n            try:\n                for inferred in node.infer():\n                    # Check to see if this returns a static or a class method.\n                    _type = _infer_decorator_callchain(inferred)\n                    if _type is not None:\n                        return _type\n\n                    if not isinstance(inferred, ClassDef):\n                        continue\n                    for ancestor in inferred.ancestors():\n                        if not isinstance(ancestor, ClassDef):\n                            continue\n                        if ancestor.is_subtype_of(\"builtins.classmethod\"):\n                            return \"classmethod\"\n                        if ancestor.is_subtype_of(\"builtins.staticmethod\"):\n                            return \"staticmethod\"\n            except InferenceError:\n                pass\n        return type_name\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "type", "self", "pylint", "disable", "invalid", "overridden", "method", "too", "many", "return", "statements", "the", "function", "type", "for", "this", "node", "possible", "values", "are", "method", "function", "staticmethod", "classmethod", "type", "str", "for", "decorator", "in", "self", "extra_decorators", "if", "decorator", "func", "name", "in", "builtin_descriptors", "return", "decorator", "func", "name", "frame", "self", "parent", "frame", "future", "true", "type_name", "function", "if", "isinstance", "frame", "classdef", "if", "self", "name", "__new__", "return", "classmethod", "if", "self", "name", "__init_subclass__", "return", "classmethod", "if", "self", "name", "__class_getitem__", "return", "classmethod", "type_name", "method", "if", "not", "self", "decorators", "return", "type_name", "for", "node", "in", "self", "decorators", "nodes", "if", "isinstance", "node", "node_classes", "name", "if", "node", "name", "in", "builtin_descriptors", "return", "node", "name", "if", "isinstance", "node", "node_classes", "attribute", "and", "isinstance", "node", "expr", "node_classes", "name", "and", "node", "expr", "name", "builtins", "and", "node", "attrname", "in", "builtin_descriptors", "return", "node", "attrname", "if", "isinstance", "node", "node_classes", "call", "handle", "the", "following", "case", "some_decorator", "arg1", "arg2", "def", "func", "try", "current", "next", "node", "func", "infer", "except", "inferenceerror", "stopiteration", "continue", "_type", "_infer_decorator_callchain", "current", "if", "_type", "is", "not", "none", "return", "_type", "try", "for", "inferred", "in", "node", "infer", "check", "to", "see", "if", "this", "returns", "a", "static", "or", "a", "class", "method", "_type", "_infer_decorator_callchain", "inferred", "if", "_type", "is", "not", "none", "return", "_type", "if", "not", "isinstance", "inferred", "classdef", "continue", "for", "ancestor", "in", "inferred", "ancestors", "if", "not", "isinstance", "ancestor", "classdef", "continue", "if", "ancestor", "is_subtype_of", "builtins", "classmethod", "return", "classmethod", "if", "ancestor", "is_subtype_of", "builtins", "staticmethod", "return", "staticmethod", "except", "inferenceerror", "pass", "return", "type_name"], "doc_len": 227}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.fromlineno", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "fromlineno", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def fromlineno(self):\n        \"\"\"The first line that this node appears on in the source code.\n\n        :type: int or None\n        \"\"\"\n        # lineno is the line number of the first decorator, we want the def\n        # statement lineno\n        lineno = self.lineno\n        if self.decorators is not None:\n            lineno += sum(\n                node.tolineno - node.lineno + 1 for node in self.decorators.nodes\n            )\n\n        return lineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "fromlineno", "self", "the", "first", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "int", "or", "none", "lineno", "is", "the", "line", "number", "of", "the", "first", "decorator", "we", "want", "the", "def", "statement", "lineno", "lineno", "self", "lineno", "if", "self", "decorators", "is", "not", "none", "lineno", "sum", "node", "tolineno", "node", "lineno", "1", "for", "node", "in", "self", "decorators", "nodes", "return", "lineno"], "doc_len": 64}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.blockstart_tolineno", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        return self.args.tolineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "return", "self", "args", "tolineno"], "doc_len": 25}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.block_range", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "block_range", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: Unused.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n        :rtype: tuple(int, int)\n        \"\"\"\n        return self.fromlineno, self.tolineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "unused", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "rtype", "tuple", "int", "int", "return", "self", "fromlineno", "self", "tolineno"], "doc_len": 49}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.getattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "getattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def getattr(self, name, context=None):\n        \"\"\"this method doesn't look in the instance_attrs dictionary since it's\n        done by an Instance proxy at inference time.\n        \"\"\"\n        if not name:\n            raise AttributeInferenceError(target=self, attribute=name, context=context)\n\n        found_attrs = []\n        if name in self.instance_attrs:\n            found_attrs = self.instance_attrs[name]\n        if name in self.special_attributes:\n            found_attrs.append(self.special_attributes.lookup(name))\n        if found_attrs:\n            return found_attrs\n        raise AttributeInferenceError(target=self, attribute=name)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "getattr", "self", "name", "context", "none", "this", "method", "doesn", "t", "look", "in", "the", "instance_attrs", "dictionary", "since", "it", "s", "done", "by", "an", "instance", "proxy", "at", "inference", "time", "if", "not", "name", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "found_attrs", "if", "name", "in", "self", "instance_attrs", "found_attrs", "self", "instance_attrs", "name", "if", "name", "in", "self", "special_attributes", "found_attrs", "append", "self", "special_attributes", "lookup", "name", "if", "found_attrs", "return", "found_attrs", "raise", "attributeinferenceerror", "target", "self", "attribute", "name"], "doc_len": 74}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.igetattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "igetattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def igetattr(self, name, context=None):\n        \"\"\"Inferred getattr, which returns an iterator of inferred statements.\"\"\"\n        try:\n            return bases._infer_stmts(self.getattr(name, context), context, frame=self)\n        except AttributeInferenceError as error:\n            raise InferenceError(\n                str(error), target=self, attribute=name, context=context\n            ) from error\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "igetattr", "self", "name", "context", "none", "inferred", "getattr", "which", "returns", "an", "iterator", "of", "inferred", "statements", "try", "return", "bases", "_infer_stmts", "self", "getattr", "name", "context", "context", "frame", "self", "except", "attributeinferenceerror", "as", "error", "raise", "inferenceerror", "str", "error", "target", "self", "attribute", "name", "context", "context", "from", "error"], "doc_len": 48}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.is_method", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "is_method", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def is_method(self):\n        \"\"\"Check if this function node represents a method.\n\n        :returns: True if this is a method, False otherwise.\n        :rtype: bool\n        \"\"\"\n        # check we are defined in a ClassDef, because this is usually expected\n        # (e.g. pylint...) when is_method() return True\n        return self.type != \"function\" and isinstance(\n            self.parent.frame(future=True), ClassDef\n        )\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "is_method", "self", "check", "if", "this", "function", "node", "represents", "a", "method", "returns", "true", "if", "this", "is", "a", "method", "false", "otherwise", "rtype", "bool", "check", "we", "are", "defined", "in", "a", "classdef", "because", "this", "is", "usually", "expected", "e", "g", "pylint", "when", "is_method", "return", "true", "return", "self", "type", "function", "and", "isinstance", "self", "parent", "frame", "future", "true", "classdef"], "doc_len": 59}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.decoratornames", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "decoratornames", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def decoratornames(self, context=None):\n        \"\"\"Get the qualified names of each of the decorators on this function.\n\n        :param context:\n            An inference context that can be passed to inference functions\n        :returns: The names of the decorators.\n        :rtype: set(str)\n        \"\"\"\n        result = set()\n        decoratornodes = []\n        if self.decorators is not None:\n            decoratornodes += self.decorators.nodes\n        decoratornodes += self.extra_decorators\n        for decnode in decoratornodes:\n            try:\n                for infnode in decnode.infer(context=context):\n                    result.add(infnode.qname())\n            except InferenceError:\n                continue\n        return result\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "decoratornames", "self", "context", "none", "get", "the", "qualified", "names", "of", "each", "of", "the", "decorators", "on", "this", "function", "param", "context", "an", "inference", "context", "that", "can", "be", "passed", "to", "inference", "functions", "returns", "the", "names", "of", "the", "decorators", "rtype", "set", "str", "result", "set", "decoratornodes", "if", "self", "decorators", "is", "not", "none", "decoratornodes", "self", "decorators", "nodes", "decoratornodes", "self", "extra_decorators", "for", "decnode", "in", "decoratornodes", "try", "for", "infnode", "in", "decnode", "infer", "context", "context", "result", "add", "infnode", "qname", "except", "inferenceerror", "continue", "return", "result"], "doc_len": 81}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.is_bound", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "is_bound", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def is_bound(self):\n        \"\"\"Check if the function is bound to an instance or class.\n\n        :returns: True if the function is bound to an instance or class,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        return self.type == \"classmethod\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "is_bound", "self", "check", "if", "the", "function", "is", "bound", "to", "an", "instance", "or", "class", "returns", "true", "if", "the", "function", "is", "bound", "to", "an", "instance", "or", "class", "false", "otherwise", "rtype", "bool", "return", "self", "type", "classmethod"], "doc_len": 40}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.is_abstract", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "is_abstract", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def is_abstract(self, pass_is_abstract=True, any_raise_is_abstract=False):\n        \"\"\"Check if the method is abstract.\n\n        A method is considered abstract if any of the following is true:\n        * The only statement is 'raise NotImplementedError'\n        * The only statement is 'raise <SomeException>' and any_raise_is_abstract is True\n        * The only statement is 'pass' and pass_is_abstract is True\n        * The method is annotated with abc.astractproperty/abc.abstractmethod\n\n        :returns: True if the method is abstract, False otherwise.\n        :rtype: bool\n        \"\"\"\n        if self.decorators:\n            for node in self.decorators.nodes:\n                try:\n                    inferred = next(node.infer())\n                except (InferenceError, StopIteration):\n                    continue\n                if inferred and inferred.qname() in {\n                    \"abc.abstractproperty\",\n                    \"abc.abstractmethod\",\n                }:\n                    return True\n\n        for child_node in self.body:\n            if isinstance(child_node, node_classes.Raise):\n                if any_raise_is_abstract:\n                    return True\n                if child_node.raises_not_implemented():\n                    return True\n            return pass_is_abstract and isinstance(child_node, node_classes.Pass)\n        # empty function is the same as function with a single \"pass\" statement\n        if pass_is_abstract:\n            return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "is_abstract", "self", "pass_is_abstract", "true", "any_raise_is_abstract", "false", "check", "if", "the", "method", "is", "abstract", "a", "method", "is", "considered", "abstract", "if", "any", "of", "the", "following", "is", "true", "the", "only", "statement", "is", "raise", "notimplementederror", "the", "only", "statement", "is", "raise", "someexception", "and", "any_raise_is_abstract", "is", "true", "the", "only", "statement", "is", "pass", "and", "pass_is_abstract", "is", "true", "the", "method", "is", "annotated", "with", "abc", "astractproperty", "abc", "abstractmethod", "returns", "true", "if", "the", "method", "is", "abstract", "false", "otherwise", "rtype", "bool", "if", "self", "decorators", "for", "node", "in", "self", "decorators", "nodes", "try", "inferred", "next", "node", "infer", "except", "inferenceerror", "stopiteration", "continue", "if", "inferred", "and", "inferred", "qname", "in", "abc", "abstractproperty", "abc", "abstractmethod", "return", "true", "for", "child_node", "in", "self", "body", "if", "isinstance", "child_node", "node_classes", "raise", "if", "any_raise_is_abstract", "return", "true", "if", "child_node", "raises_not_implemented", "return", "true", "return", "pass_is_abstract", "and", "isinstance", "child_node", "node_classes", "pass", "empty", "function", "is", "the", "same", "as", "function", "with", "a", "single", "pass", "statement", "if", "pass_is_abstract", "return", "true"], "doc_len": 148}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.is_generator", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "is_generator", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def is_generator(self):\n        \"\"\"Check if this is a generator function.\n\n        :returns: True is this is a generator function, False otherwise.\n        :rtype: bool\n        \"\"\"\n        return bool(next(self._get_yield_nodes_skip_lambdas(), False))\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "is_generator", "self", "check", "if", "this", "is", "a", "generator", "function", "returns", "true", "is", "this", "is", "a", "generator", "function", "false", "otherwise", "rtype", "bool", "return", "bool", "next", "self", "_get_yield_nodes_skip_lambdas", "false"], "doc_len": 34}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.infer_yield_result", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "infer_yield_result", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def infer_yield_result(self, context=None):\n        \"\"\"Infer what the function yields when called\n\n        :returns: What the function yields\n        :rtype: iterable(NodeNG or Uninferable) or None\n        \"\"\"\n        # pylint: disable=not-an-iterable\n        # https://github.com/PyCQA/astroid/issues/1015\n        for yield_ in self.nodes_of_class(node_classes.Yield):\n            if yield_.value is None:\n                const = node_classes.Const(None)\n                const.parent = yield_\n                const.lineno = yield_.lineno\n                yield const\n            elif yield_.scope() == self:\n                yield from yield_.value.infer(context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "infer_yield_result", "self", "context", "none", "infer", "what", "the", "function", "yields", "when", "called", "returns", "what", "the", "function", "yields", "rtype", "iterable", "nodeng", "or", "uninferable", "or", "none", "pylint", "disable", "not", "an", "iterable", "https", "github", "com", "pycqa", "astroid", "issues", "1015", "for", "yield_", "in", "self", "nodes_of_class", "node_classes", "yield", "if", "yield_", "value", "is", "none", "const", "node_classes", "const", "none", "const", "parent", "yield_", "const", "lineno", "yield_", "lineno", "yield", "const", "elif", "yield_", "scope", "self", "yield", "from", "yield_", "value", "infer", "context", "context"], "doc_len": 78}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.infer_call_result", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "infer_call_result", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def infer_call_result(self, caller=None, context=None):\n        \"\"\"Infer what the function returns when called.\n\n        :returns: What the function returns.\n        :rtype: iterable(NodeNG or Uninferable) or None\n        \"\"\"\n        if self.is_generator():\n            if isinstance(self, AsyncFunctionDef):\n                generator_cls = bases.AsyncGenerator\n            else:\n                generator_cls = bases.Generator\n            result = generator_cls(self, generator_initial_context=context)\n            yield result\n            return\n        # This is really a gigantic hack to work around metaclass generators\n        # that return transient class-generating functions. Pylint's AST structure\n        # cannot handle a base class object that is only used for calling __new__,\n        # but does not contribute to the inheritance structure itself. We inject\n        # a fake class into the hierarchy here for several well-known metaclass\n        # generators, and filter it out later.\n        if (\n            self.name == \"with_metaclass\"\n            and len(self.args.args) == 1\n            and self.args.vararg is not None\n        ):\n            metaclass = next(caller.args[0].infer(context), None)\n            if isinstance(metaclass, ClassDef):\n                try:\n                    class_bases = [next(arg.infer(context)) for arg in caller.args[1:]]\n                except StopIteration as e:\n                    raise InferenceError(node=caller.args[1:], context=context) from e\n                new_class = ClassDef(name=\"temporary_class\")\n                new_class.hide = True\n                new_class.parent = self\n                new_class.postinit(\n                    bases=[base for base in class_bases if base != util.Uninferable],\n                    body=[],\n                    decorators=[],\n                    metaclass=metaclass,\n                )\n                yield new_class\n                return\n        returns = self._get_return_nodes_skip_functions()\n\n        first_return = next(returns, None)\n        if not first_return:\n            if self.body:\n                if self.is_abstract(pass_is_abstract=True, any_raise_is_abstract=True):\n                    yield util.Uninferable\n                else:\n                    yield node_classes.Const(None)\n                return\n\n            raise InferenceError(\"The function does not have any return statements\")\n\n        for returnnode in itertools.chain((first_return,), returns):\n            if returnnode.value is None:\n                yield node_classes.Const(None)\n            else:\n                try:\n                    yield from returnnode.value.infer(context)\n                except InferenceError:\n                    yield util.Uninferable\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "infer_call_result", "self", "caller", "none", "context", "none", "infer", "what", "the", "function", "returns", "when", "called", "returns", "what", "the", "function", "returns", "rtype", "iterable", "nodeng", "or", "uninferable", "or", "none", "if", "self", "is_generator", "if", "isinstance", "self", "asyncfunctiondef", "generator_cls", "bases", "asyncgenerator", "else", "generator_cls", "bases", "generator", "result", "generator_cls", "self", "generator_initial_context", "context", "yield", "result", "return", "this", "is", "really", "a", "gigantic", "hack", "to", "work", "around", "metaclass", "generators", "that", "return", "transient", "class", "generating", "functions", "pylint", "s", "ast", "structure", "cannot", "handle", "a", "base", "class", "object", "that", "is", "only", "used", "for", "calling", "__new__", "but", "does", "not", "contribute", "to", "the", "inheritance", "structure", "itself", "we", "inject", "a", "fake", "class", "into", "the", "hierarchy", "here", "for", "several", "well", "known", "metaclass", "generators", "and", "filter", "it", "out", "later", "if", "self", "name", "with_metaclass", "and", "len", "self", "args", "args", "1", "and", "self", "args", "vararg", "is", "not", "none", "metaclass", "next", "caller", "args", "0", "infer", "context", "none", "if", "isinstance", "metaclass", "classdef", "try", "class_bases", "next", "arg", "infer", "context", "for", "arg", "in", "caller", "args", "1", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "caller", "args", "1", "context", "context", "from", "e", "new_class", "classdef", "name", "temporary_class", "new_class", "hide", "true", "new_class", "parent", "self", "new_class", "postinit", "bases", "base", "for", "base", "in", "class_bases", "if", "base", "util", "uninferable", "body", "decorators", "metaclass", "metaclass", "yield", "new_class", "return", "returns", "self", "_get_return_nodes_skip_functions", "first_return", "next", "returns", "none", "if", "not", "first_return", "if", "self", "body", "if", "self", "is_abstract", "pass_is_abstract", "true", "any_raise_is_abstract", "true", "yield", "util", "uninferable", "else", "yield", "node_classes", "const", "none", "return", "raise", "inferenceerror", "the", "function", "does", "not", "have", "any", "return", "statements", "for", "returnnode", "in", "itertools", "chain", "first_return", "returns", "if", "returnnode", "value", "is", "none", "yield", "node_classes", "const", "none", "else", "try", "yield", "from", "returnnode", "value", "infer", "context", "except", "inferenceerror", "yield", "util", "uninferable"], "doc_len": 269}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`FunctionDef` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "functiondef", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def get_children(self):\n        if self.decorators is not None:\n            yield self.decorators\n\n        yield self.args\n\n        if self.returns is not None:\n            yield self.returns\n\n        yield from self.body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "get_children", "self", "if", "self", "decorators", "is", "not", "none", "yield", "self", "decorators", "yield", "self", "args", "if", "self", "returns", "is", "not", "none", "yield", "self", "returns", "yield", "from", "self", "body"], "doc_len": 34}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.scope_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "scope_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def scope_lookup(self, node, name, offset=0):\n        \"\"\"Lookup where the given name is assigned.\"\"\"\n        if name == \"__class__\":\n            # __class__ is an implicit closure reference created by the compiler\n            # if any methods in a class body refer to either __class__ or super.\n            # In our case, we want to be able to look it up in the current scope\n            # when `__class__` is being used.\n            frame = self.parent.frame(future=True)\n            if isinstance(frame, ClassDef):\n                return self, [frame]\n        return super().scope_lookup(node, name, offset)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "scope_lookup", "self", "node", "name", "offset", "0", "lookup", "where", "the", "given", "name", "is", "assigned", "if", "name", "__class__", "__class__", "is", "an", "implicit", "closure", "reference", "created", "by", "the", "compiler", "if", "any", "methods", "in", "a", "class", "body", "refer", "to", "either", "__class__", "or", "super", "in", "our", "case", "we", "want", "to", "be", "able", "to", "look", "it", "up", "in", "the", "current", "scope", "when", "__class__", "is", "being", "used", "frame", "self", "parent", "frame", "future", "true", "if", "isinstance", "frame", "classdef", "return", "self", "frame", "return", "super", "scope_lookup", "node", "name", "offset"], "doc_len": 86}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::FunctionDef.frame", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "FunctionDef", "func_name": "frame", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: FunctionDef\n    def frame(self: T, *, future: Literal[None, True] = None) -> T:\n        \"\"\"The node's frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        :class:`ClassDef` or :class:`Lambda`.\n\n        :returns: The node itself.\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "functiondef", "def", "frame", "self", "t", "future", "literal", "none", "true", "none", "t", "the", "node", "s", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "class", "classdef", "or", "class", "lambda", "returns", "the", "node", "itself", "return", "self"], "doc_len": 41}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_rec_get_names", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "_rec_get_names", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef _rec_get_names(args, names=None):\n    \"\"\"return a list of all argument names\"\"\"\n    if names is None:\n        names = []\n    for arg in args:\n        if isinstance(arg, node_classes.Tuple):\n            _rec_get_names(arg.elts, names)\n        else:\n            names.append(arg.name)\n    return names\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "_rec_get_names", "args", "names", "none", "return", "a", "list", "of", "all", "argument", "names", "if", "names", "is", "none", "names", "for", "arg", "in", "args", "if", "isinstance", "arg", "node_classes", "tuple", "_rec_get_names", "arg", "elts", "names", "else", "names", "append", "arg", "name", "return", "names"], "doc_len": 42}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_is_metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "_is_metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef _is_metaclass(klass, seen=None):\n    \"\"\"Return if the given class can be\n    used as a metaclass.\n    \"\"\"\n    if klass.name == \"type\":\n        return True\n    if seen is None:\n        seen = set()\n    for base in klass.bases:\n        try:\n            for baseobj in base.infer():\n                baseobj_name = baseobj.qname()\n                if baseobj_name in seen:\n                    continue\n\n                seen.add(baseobj_name)\n                if isinstance(baseobj, bases.Instance):\n                    # not abstract\n                    return False\n                if baseobj is util.Uninferable:\n                    continue\n                if baseobj is klass:\n                    continue\n                if not isinstance(baseobj, ClassDef):\n                    continue\n                if baseobj._type == \"metaclass\":\n                    return True\n                if _is_metaclass(baseobj, seen):\n                    return True\n        except InferenceError:\n            continue\n    return False\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "_is_metaclass", "klass", "seen", "none", "return", "if", "the", "given", "class", "can", "be", "used", "as", "a", "metaclass", "if", "klass", "name", "type", "return", "true", "if", "seen", "is", "none", "seen", "set", "for", "base", "in", "klass", "bases", "try", "for", "baseobj", "in", "base", "infer", "baseobj_name", "baseobj", "qname", "if", "baseobj_name", "in", "seen", "continue", "seen", "add", "baseobj_name", "if", "isinstance", "baseobj", "bases", "instance", "not", "abstract", "return", "false", "if", "baseobj", "is", "util", "uninferable", "continue", "if", "baseobj", "is", "klass", "continue", "if", "not", "isinstance", "baseobj", "classdef", "continue", "if", "baseobj", "_type", "metaclass", "return", "true", "if", "_is_metaclass", "baseobj", "seen", "return", "true", "except", "inferenceerror", "continue", "return", "false"], "doc_len": 98}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::_class_type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "_class_type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef _class_type(klass, ancestors=None):\n    \"\"\"return a ClassDef node type to differ metaclass and exception\n    from 'regular' classes\n    \"\"\"\n    # XXX we have to store ancestors in case we have an ancestor loop\n    if klass._type is not None:\n        return klass._type\n    if _is_metaclass(klass):\n        klass._type = \"metaclass\"\n    elif klass.name.endswith(\"Exception\"):\n        klass._type = \"exception\"\n    else:\n        if ancestors is None:\n            ancestors = set()\n        klass_name = klass.qname()\n        if klass_name in ancestors:\n            # XXX we are in loop ancestors, and have found no type\n            klass._type = \"class\"\n            return \"class\"\n        ancestors.add(klass_name)\n        for base in klass.ancestors(recurs=False):\n            name = _class_type(base, ancestors)\n            if name != \"class\":\n                if name == \"metaclass\" and not _is_metaclass(klass):\n                    # don't propagate it if the current class\n                    # can't be a metaclass\n                    continue\n                klass._type = base.type\n                break\n    if klass._type is None:\n        klass._type = \"class\"\n    return klass._type\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "_class_type", "klass", "ancestors", "none", "return", "a", "classdef", "node", "type", "to", "differ", "metaclass", "and", "exception", "from", "regular", "classes", "xxx", "we", "have", "to", "store", "ancestors", "in", "case", "we", "have", "an", "ancestor", "loop", "if", "klass", "_type", "is", "not", "none", "return", "klass", "_type", "if", "_is_metaclass", "klass", "klass", "_type", "metaclass", "elif", "klass", "name", "endswith", "exception", "klass", "_type", "exception", "else", "if", "ancestors", "is", "none", "ancestors", "set", "klass_name", "klass", "qname", "if", "klass_name", "in", "ancestors", "xxx", "we", "are", "in", "loop", "ancestors", "and", "have", "found", "no", "type", "klass", "_type", "class", "return", "class", "ancestors", "add", "klass_name", "for", "base", "in", "klass", "ancestors", "recurs", "false", "name", "_class_type", "base", "ancestors", "if", "name", "class", "if", "name", "metaclass", "and", "not", "_is_metaclass", "klass", "don", "t", "propagate", "it", "if", "the", "current", "class", "can", "t", "be", "a", "metaclass", "continue", "klass", "_type", "base", "type", "break", "if", "klass", "_type", "is", "none", "klass", "_type", "class", "return", "klass", "_type"], "doc_len": 143}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::get_wrapping_class", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": null, "func_name": "get_wrapping_class", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py\ndef get_wrapping_class(node):\n    \"\"\"Get the class that wraps the given node.\n\n    We consider that a class wraps a node if the class\n    is a parent for the said node.\n\n    :returns: The class that wraps the given node\n    :rtype: ClassDef or None\n    \"\"\"\n\n    klass = node.frame(future=True)\n    while klass is not None and not isinstance(klass, ClassDef):\n        if klass.parent is None:\n            klass = None\n        else:\n            klass = klass.parent.frame(future=True)\n    return klass\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "def", "get_wrapping_class", "node", "get", "the", "class", "that", "wraps", "the", "given", "node", "we", "consider", "that", "a", "class", "wraps", "a", "node", "if", "the", "class", "is", "a", "parent", "for", "the", "said", "node", "returns", "the", "class", "that", "wraps", "the", "given", "node", "rtype", "classdef", "or", "none", "klass", "node", "frame", "future", "true", "while", "klass", "is", "not", "none", "and", "not", "isinstance", "klass", "classdef", "if", "klass", "parent", "is", "none", "klass", "none", "else", "klass", "klass", "parent", "frame", "future", "true", "return", "klass"], "doc_len": 77}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.__init__", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "__init__", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def __init__(\n        self,\n        name=None,\n        doc=None,\n        lineno=None,\n        col_offset=None,\n        parent=None,\n        *,\n        end_lineno=None,\n        end_col_offset=None,\n    ):\n        \"\"\"\n        :param name: The name of the class.\n        :type name: str or None\n\n        :param doc: The function's docstring.\n        :type doc: str or None\n\n        :param lineno: The line that this node appears on in the source code.\n        :type lineno: int or None\n\n        :param col_offset: The column that this node appears on in the\n            source code.\n        :type col_offset: int or None\n\n        :param parent: The parent node in the syntax tree.\n        :type parent: NodeNG or None\n\n        :param end_lineno: The last line this node appears on in the source code.\n        :type end_lineno: Optional[int]\n\n        :param end_col_offset: The end column this node appears on in the\n            source code. Note: This is after the last symbol.\n        :type end_col_offset: Optional[int]\n        \"\"\"\n        self.instance_attrs = {}\n        self.locals = {}\n        \"\"\"A map of the name of a local variable to the node defining it.\n\n        :type: dict(str, NodeNG)\n        \"\"\"\n\n        self.keywords = []\n        \"\"\"The keywords given to the class definition.\n\n        This is usually for :pep:`3115` style metaclass declaration.\n\n        :type: list(Keyword) or None\n        \"\"\"\n\n        self.bases = []\n        \"\"\"What the class inherits from.\n\n        :type: list(NodeNG)\n        \"\"\"\n\n        self.body = []\n        \"\"\"The contents of the class body.\n\n        :type: list(NodeNG)\n        \"\"\"\n\n        self.name = name\n        \"\"\"The name of the class.\n\n        :type name: str or None\n        \"\"\"\n\n        self.doc = doc\n        \"\"\"The class' docstring.\n\n        :type doc: str or None\n        \"\"\"\n\n        super().__init__(\n            lineno=lineno,\n            col_offset=col_offset,\n            end_lineno=end_lineno,\n            end_col_offset=end_col_offset,\n            parent=parent,\n        )\n        if parent is not None:\n            parent.frame(future=True).set_local(name, self)\n\n        for local_name, node in self.implicit_locals():\n            self.add_local_node(node, local_name)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "__init__", "self", "name", "none", "doc", "none", "lineno", "none", "col_offset", "none", "parent", "none", "end_lineno", "none", "end_col_offset", "none", "param", "name", "the", "name", "of", "the", "class", "type", "name", "str", "or", "none", "param", "doc", "the", "function", "s", "docstring", "type", "doc", "str", "or", "none", "param", "lineno", "the", "line", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "lineno", "int", "or", "none", "param", "col_offset", "the", "column", "that", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "col_offset", "int", "or", "none", "param", "parent", "the", "parent", "node", "in", "the", "syntax", "tree", "type", "parent", "nodeng", "or", "none", "param", "end_lineno", "the", "last", "line", "this", "node", "appears", "on", "in", "the", "source", "code", "type", "end_lineno", "optional", "int", "param", "end_col_offset", "the", "end", "column", "this", "node", "appears", "on", "in", "the", "source", "code", "note", "this", "is", "after", "the", "last", "symbol", "type", "end_col_offset", "optional", "int", "self", "instance_attrs", "self", "locals", "a", "map", "of", "the", "name", "of", "a", "local", "variable", "to", "the", "node", "defining", "it", "type", "dict", "str", "nodeng", "self", "keywords", "the", "keywords", "given", "to", "the", "class", "definition", "this", "is", "usually", "for", "pep", "3115", "style", "metaclass", "declaration", "type", "list", "keyword", "or", "none", "self", "bases", "what", "the", "class", "inherits", "from", "type", "list", "nodeng", "self", "body", "the", "contents", "of", "the", "class", "body", "type", "list", "nodeng", "self", "name", "name", "the", "name", "of", "the", "class", "type", "name", "str", "or", "none", "self", "doc", "doc", "the", "class", "docstring", "type", "doc", "str", "or", "none", "super", "__init__", "lineno", "lineno", "col_offset", "col_offset", "end_lineno", "end_lineno", "end_col_offset", "end_col_offset", "parent", "parent", "if", "parent", "is", "not", "none", "parent", "frame", "future", "true", "set_local", "name", "self", "for", "local_name", "node", "in", "self", "implicit_locals", "self", "add_local_node", "node", "local_name"], "doc_len": 261}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.implicit_parameters", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "implicit_parameters", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def implicit_parameters(self):\n        return 1\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "implicit_parameters", "self", "return", "1"], "doc_len": 11}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.implicit_locals", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "implicit_locals", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def implicit_locals(self):\n        \"\"\"Get implicitly defined class definition locals.\n\n        :returns: the the name and Const pair for each local\n        :rtype: tuple(tuple(str, node_classes.Const), ...)\n        \"\"\"\n        locals_ = ((\"__module__\", self.special_attributes.attr___module__),)\n        # __qualname__ is defined in PEP3155\n        locals_ += ((\"__qualname__\", self.special_attributes.attr___qualname__),)\n        return locals_\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "implicit_locals", "self", "get", "implicitly", "defined", "class", "definition", "locals", "returns", "the", "the", "name", "and", "const", "pair", "for", "each", "local", "rtype", "tuple", "tuple", "str", "node_classes", "const", "locals_", "__module__", "self", "special_attributes", "attr___module__", "__qualname__", "is", "defined", "in", "pep3155", "locals_", "__qualname__", "self", "special_attributes", "attr___qualname__", "return", "locals_"], "doc_len": 48}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.postinit", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "postinit", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def postinit(\n        self, bases, body, decorators, newstyle=None, metaclass=None, keywords=None\n    ):\n        \"\"\"Do some setup after initialisation.\n\n        :param bases: What the class inherits from.\n        :type bases: list(NodeNG)\n\n        :param body: The contents of the class body.\n        :type body: list(NodeNG)\n\n        :param decorators: The decorators that are applied to this class.\n        :type decorators: Decorators or None\n\n        :param newstyle: Whether this is a new style class or not.\n        :type newstyle: bool or None\n\n        :param metaclass: The metaclass of this class.\n        :type metaclass: NodeNG or None\n\n        :param keywords: The keywords given to the class definition.\n        :type keywords: list(Keyword) or None\n        \"\"\"\n        if keywords is not None:\n            self.keywords = keywords\n        self.bases = bases\n        self.body = body\n        self.decorators = decorators\n        if newstyle is not None:\n            self._newstyle = newstyle\n        if metaclass is not None:\n            self._metaclass = metaclass\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "postinit", "self", "bases", "body", "decorators", "newstyle", "none", "metaclass", "none", "keywords", "none", "do", "some", "setup", "after", "initialisation", "param", "bases", "what", "the", "class", "inherits", "from", "type", "bases", "list", "nodeng", "param", "body", "the", "contents", "of", "the", "class", "body", "type", "body", "list", "nodeng", "param", "decorators", "the", "decorators", "that", "are", "applied", "to", "this", "class", "type", "decorators", "decorators", "or", "none", "param", "newstyle", "whether", "this", "is", "a", "new", "style", "class", "or", "not", "type", "newstyle", "bool", "or", "none", "param", "metaclass", "the", "metaclass", "of", "this", "class", "type", "metaclass", "nodeng", "or", "none", "param", "keywords", "the", "keywords", "given", "to", "the", "class", "definition", "type", "keywords", "list", "keyword", "or", "none", "if", "keywords", "is", "not", "none", "self", "keywords", "keywords", "self", "bases", "bases", "self", "body", "body", "self", "decorators", "decorators", "if", "newstyle", "is", "not", "none", "self", "_newstyle", "newstyle", "if", "metaclass", "is", "not", "none", "self", "_metaclass", "metaclass"], "doc_len": 137}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._newstyle_impl", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_newstyle_impl", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _newstyle_impl(self, context=None):\n        if context is None:\n            context = InferenceContext()\n        if self._newstyle is not None:\n            return self._newstyle\n        for base in self.ancestors(recurs=False, context=context):\n            if base._newstyle_impl(context):\n                self._newstyle = True\n                break\n        klass = self.declared_metaclass()\n        # could be any callable, we'd need to infer the result of klass(name,\n        # bases, dict).  punt if it's not a class node.\n        if klass is not None and isinstance(klass, ClassDef):\n            self._newstyle = klass._newstyle_impl(context)\n        if self._newstyle is None:\n            self._newstyle = False\n        return self._newstyle\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_newstyle_impl", "self", "context", "none", "if", "context", "is", "none", "context", "inferencecontext", "if", "self", "_newstyle", "is", "not", "none", "return", "self", "_newstyle", "for", "base", "in", "self", "ancestors", "recurs", "false", "context", "context", "if", "base", "_newstyle_impl", "context", "self", "_newstyle", "true", "break", "klass", "self", "declared_metaclass", "could", "be", "any", "callable", "we", "d", "need", "to", "infer", "the", "result", "of", "klass", "name", "bases", "dict", "punt", "if", "it", "s", "not", "a", "class", "node", "if", "klass", "is", "not", "none", "and", "isinstance", "klass", "classdef", "self", "_newstyle", "klass", "_newstyle_impl", "context", "if", "self", "_newstyle", "is", "none", "self", "_newstyle", "false", "return", "self", "_newstyle"], "doc_len": 95}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.blockstart_tolineno", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "blockstart_tolineno", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def blockstart_tolineno(self):\n        \"\"\"The line on which the beginning of this block ends.\n\n        :type: int\n        \"\"\"\n        if self.bases:\n            return self.bases[-1].tolineno\n\n        return self.fromlineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "blockstart_tolineno", "self", "the", "line", "on", "which", "the", "beginning", "of", "this", "block", "ends", "type", "int", "if", "self", "bases", "return", "self", "bases", "1", "tolineno", "return", "self", "fromlineno"], "doc_len": 32}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.block_range", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "block_range", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def block_range(self, lineno):\n        \"\"\"Get a range from the given line number to where this node ends.\n\n        :param lineno: Unused.\n        :type lineno: int\n\n        :returns: The range of line numbers that this node belongs to,\n        :rtype: tuple(int, int)\n        \"\"\"\n        return self.fromlineno, self.tolineno\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "block_range", "self", "lineno", "get", "a", "range", "from", "the", "given", "line", "number", "to", "where", "this", "node", "ends", "param", "lineno", "unused", "type", "lineno", "int", "returns", "the", "range", "of", "line", "numbers", "that", "this", "node", "belongs", "to", "rtype", "tuple", "int", "int", "return", "self", "fromlineno", "self", "tolineno"], "doc_len": 49}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.pytype", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "pytype", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def pytype(self):\n        \"\"\"Get the name of the type that this node represents.\n\n        :returns: The name of the type.\n        :rtype: str\n        \"\"\"\n        if self.newstyle:\n            return \"builtins.type\"\n        return \"builtins.classobj\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "pytype", "self", "get", "the", "name", "of", "the", "type", "that", "this", "node", "represents", "returns", "the", "name", "of", "the", "type", "rtype", "str", "if", "self", "newstyle", "return", "builtins", "type", "return", "builtins", "classobj"], "doc_len": 36}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.display_type", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "display_type", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def display_type(self):\n        \"\"\"A human readable type of this node.\n\n        :returns: The type of this node.\n        :rtype: str\n        \"\"\"\n        return \"Class\"\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "display_type", "self", "a", "human", "readable", "type", "of", "this", "node", "returns", "the", "type", "of", "this", "node", "rtype", "str", "return", "class"], "doc_len": 26}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.callable", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "callable", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def callable(self):\n        \"\"\"Whether this node defines something that is callable.\n\n        :returns: True if this defines something that is callable,\n            False otherwise.\n            For a :class:`ClassDef` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "callable", "self", "whether", "this", "node", "defines", "something", "that", "is", "callable", "returns", "true", "if", "this", "defines", "something", "that", "is", "callable", "false", "otherwise", "for", "a", "class", "classdef", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 40}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.is_subtype_of", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "is_subtype_of", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def is_subtype_of(self, type_name, context=None):\n        \"\"\"Whether this class is a subtype of the given type.\n\n        :param type_name: The name of the type of check against.\n        :type type_name: str\n\n        :returns: True if this class is a subtype of the given type,\n            False otherwise.\n        :rtype: bool\n        \"\"\"\n        if self.qname() == type_name:\n            return True\n\n        return any(anc.qname() == type_name for anc in self.ancestors(context=context))\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "is_subtype_of", "self", "type_name", "context", "none", "whether", "this", "class", "is", "a", "subtype", "of", "the", "given", "type", "param", "type_name", "the", "name", "of", "the", "type", "of", "check", "against", "type", "type_name", "str", "returns", "true", "if", "this", "class", "is", "a", "subtype", "of", "the", "given", "type", "false", "otherwise", "rtype", "bool", "if", "self", "qname", "type_name", "return", "true", "return", "any", "anc", "qname", "type_name", "for", "anc", "in", "self", "ancestors", "context", "context"], "doc_len": 69}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._infer_type_call", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_infer_type_call", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _infer_type_call(self, caller, context):\n        try:\n            name_node = next(caller.args[0].infer(context))\n        except StopIteration as e:\n            raise InferenceError(node=caller.args[0], context=context) from e\n        if isinstance(name_node, node_classes.Const) and isinstance(\n            name_node.value, str\n        ):\n            name = name_node.value\n        else:\n            return util.Uninferable\n\n        result = ClassDef(name, None)\n\n        # Get the bases of the class.\n        try:\n            class_bases = next(caller.args[1].infer(context))\n        except StopIteration as e:\n            raise InferenceError(node=caller.args[1], context=context) from e\n        if isinstance(class_bases, (node_classes.Tuple, node_classes.List)):\n            bases = []\n            for base in class_bases.itered():\n                inferred = next(base.infer(context=context), None)\n                if inferred:\n                    bases.append(\n                        node_classes.EvaluatedObject(original=base, value=inferred)\n                    )\n            result.bases = bases\n        else:\n            # There is currently no AST node that can represent an 'unknown'\n            # node (Uninferable is not an AST node), therefore we simply return Uninferable here\n            # although we know at least the name of the class.\n            return util.Uninferable\n\n        # Get the members of the class\n        try:\n            members = next(caller.args[2].infer(context))\n        except (InferenceError, StopIteration):\n            members = None\n\n        if members and isinstance(members, node_classes.Dict):\n            for attr, value in members.items:\n                if isinstance(attr, node_classes.Const) and isinstance(attr.value, str):\n                    result.locals[attr.value] = [value]\n\n        result.parent = caller.parent\n        return result\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_infer_type_call", "self", "caller", "context", "try", "name_node", "next", "caller", "args", "0", "infer", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "caller", "args", "0", "context", "context", "from", "e", "if", "isinstance", "name_node", "node_classes", "const", "and", "isinstance", "name_node", "value", "str", "name", "name_node", "value", "else", "return", "util", "uninferable", "result", "classdef", "name", "none", "get", "the", "bases", "of", "the", "class", "try", "class_bases", "next", "caller", "args", "1", "infer", "context", "except", "stopiteration", "as", "e", "raise", "inferenceerror", "node", "caller", "args", "1", "context", "context", "from", "e", "if", "isinstance", "class_bases", "node_classes", "tuple", "node_classes", "list", "bases", "for", "base", "in", "class_bases", "itered", "inferred", "next", "base", "infer", "context", "context", "none", "if", "inferred", "bases", "append", "node_classes", "evaluatedobject", "original", "base", "value", "inferred", "result", "bases", "bases", "else", "there", "is", "currently", "no", "ast", "node", "that", "can", "represent", "an", "unknown", "node", "uninferable", "is", "not", "an", "ast", "node", "therefore", "we", "simply", "return", "uninferable", "here", "although", "we", "know", "at", "least", "the", "name", "of", "the", "class", "return", "util", "uninferable", "get", "the", "members", "of", "the", "class", "try", "members", "next", "caller", "args", "2", "infer", "context", "except", "inferenceerror", "stopiteration", "members", "none", "if", "members", "and", "isinstance", "members", "node_classes", "dict", "for", "attr", "value", "in", "members", "items", "if", "isinstance", "attr", "node_classes", "const", "and", "isinstance", "attr", "value", "str", "result", "locals", "attr", "value", "value", "result", "parent", "caller", "parent", "return", "result"], "doc_len": 206}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.infer_call_result", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "infer_call_result", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def infer_call_result(self, caller, context=None):\n        \"\"\"infer what a class is returning when called\"\"\"\n        if self.is_subtype_of(\"builtins.type\", context) and len(caller.args) == 3:\n            result = self._infer_type_call(caller, context)\n            yield result\n            return\n\n        dunder_call = None\n        try:\n            metaclass = self.metaclass(context=context)\n            if metaclass is not None:\n                dunder_call = next(metaclass.igetattr(\"__call__\", context))\n        except (AttributeInferenceError, StopIteration):\n            pass\n\n        if dunder_call and dunder_call.qname() != \"builtins.type.__call__\":\n            # Call type.__call__ if not set metaclass\n            # (since type is the default metaclass)\n            context = bind_context_to_node(context, self)\n            context.callcontext.callee = dunder_call\n            yield from dunder_call.infer_call_result(caller, context)\n        else:\n            yield self.instantiate_class()\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "infer_call_result", "self", "caller", "context", "none", "infer", "what", "a", "class", "is", "returning", "when", "called", "if", "self", "is_subtype_of", "builtins", "type", "context", "and", "len", "caller", "args", "3", "result", "self", "_infer_type_call", "caller", "context", "yield", "result", "return", "dunder_call", "none", "try", "metaclass", "self", "metaclass", "context", "context", "if", "metaclass", "is", "not", "none", "dunder_call", "next", "metaclass", "igetattr", "__call__", "context", "except", "attributeinferenceerror", "stopiteration", "pass", "if", "dunder_call", "and", "dunder_call", "qname", "builtins", "type", "__call__", "call", "type", "__call__", "if", "not", "set", "metaclass", "since", "type", "is", "the", "default", "metaclass", "context", "bind_context_to_node", "context", "self", "context", "callcontext", "callee", "dunder_call", "yield", "from", "dunder_call", "infer_call_result", "caller", "context", "else", "yield", "self", "instantiate_class"], "doc_len": 101}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.scope_lookup", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "scope_lookup", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def scope_lookup(self, node, name, offset=0):\n        \"\"\"Lookup where the given name is assigned.\n\n        :param node: The node to look for assignments up to.\n            Any assignments after the given node are ignored.\n        :type node: NodeNG\n\n        :param name: The name to find assignments for.\n        :type name: str\n\n        :param offset: The line offset to filter statements up to.\n        :type offset: int\n\n        :returns: This scope node and the list of assignments associated to the\n            given name according to the scope where it has been found (locals,\n            globals or builtin).\n        :rtype: tuple(str, list(NodeNG))\n        \"\"\"\n        # If the name looks like a builtin name, just try to look\n        # into the upper scope of this class. We might have a\n        # decorator that it's poorly named after a builtin object\n        # inside this class.\n        lookup_upper_frame = (\n            isinstance(node.parent, node_classes.Decorators)\n            and name in AstroidManager().builtins_module\n        )\n        if (\n            any(node == base or base.parent_of(node) for base in self.bases)\n            or lookup_upper_frame\n        ):\n            # Handle the case where we have either a name\n            # in the bases of a class, which exists before\n            # the actual definition or the case where we have\n            # a Getattr node, with that name.\n            #\n            # name = ...\n            # class A(name):\n            #     def name(self): ...\n            #\n            # import name\n            # class A(name.Name):\n            #     def name(self): ...\n\n            frame = self.parent.frame(future=True)\n            # line offset to avoid that class A(A) resolve the ancestor to\n            # the defined class\n            offset = -1\n        else:\n            frame = self\n        return frame._scope_lookup(node, name, offset)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "scope_lookup", "self", "node", "name", "offset", "0", "lookup", "where", "the", "given", "name", "is", "assigned", "param", "node", "the", "node", "to", "look", "for", "assignments", "up", "to", "any", "assignments", "after", "the", "given", "node", "are", "ignored", "type", "node", "nodeng", "param", "name", "the", "name", "to", "find", "assignments", "for", "type", "name", "str", "param", "offset", "the", "line", "offset", "to", "filter", "statements", "up", "to", "type", "offset", "int", "returns", "this", "scope", "node", "and", "the", "list", "of", "assignments", "associated", "to", "the", "given", "name", "according", "to", "the", "scope", "where", "it", "has", "been", "found", "locals", "globals", "or", "builtin", "rtype", "tuple", "str", "list", "nodeng", "if", "the", "name", "looks", "like", "a", "builtin", "name", "just", "try", "to", "look", "into", "the", "upper", "scope", "of", "this", "class", "we", "might", "have", "a", "decorator", "that", "it", "s", "poorly", "named", "after", "a", "builtin", "object", "inside", "this", "class", "lookup_upper_frame", "isinstance", "node", "parent", "node_classes", "decorators", "and", "name", "in", "astroidmanager", "builtins_module", "if", "any", "node", "base", "or", "base", "parent_of", "node", "for", "base", "in", "self", "bases", "or", "lookup_upper_frame", "handle", "the", "case", "where", "we", "have", "either", "a", "name", "in", "the", "bases", "of", "a", "class", "which", "exists", "before", "the", "actual", "definition", "or", "the", "case", "where", "we", "have", "a", "getattr", "node", "with", "that", "name", "name", "class", "a", "name", "def", "name", "self", "import", "name", "class", "a", "name", "name", "def", "name", "self", "frame", "self", "parent", "frame", "future", "true", "line", "offset", "to", "avoid", "that", "class", "a", "a", "resolve", "the", "ancestor", "to", "the", "defined", "class", "offset", "1", "else", "frame", "self", "return", "frame", "_scope_lookup", "node", "name", "offset"], "doc_len": 240}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.basenames", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "basenames", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def basenames(self):\n        \"\"\"The names of the parent classes\n\n        Names are given in the order they appear in the class definition.\n\n        :type: list(str)\n        \"\"\"\n        return [bnode.as_string() for bnode in self.bases]\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "basenames", "self", "the", "names", "of", "the", "parent", "classes", "names", "are", "given", "in", "the", "order", "they", "appear", "in", "the", "class", "definition", "type", "list", "str", "return", "bnode", "as_string", "for", "bnode", "in", "self", "bases"], "doc_len": 38}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.ancestors", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "ancestors", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def ancestors(self, recurs=True, context=None):\n        \"\"\"Iterate over the base classes in prefixed depth first order.\n\n        :param recurs: Whether to recurse or return direct ancestors only.\n        :type recurs: bool\n\n        :returns: The base classes\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        # FIXME: should be possible to choose the resolution order\n        # FIXME: inference make infinite loops possible here\n        yielded = {self}\n        if context is None:\n            context = InferenceContext()\n        if not self.bases and self.qname() != \"builtins.object\":\n            yield builtin_lookup(\"object\")[1][0]\n            return\n\n        for stmt in self.bases:\n            with context.restore_path():\n                try:\n                    for baseobj in stmt.infer(context):\n                        if not isinstance(baseobj, ClassDef):\n                            if isinstance(baseobj, bases.Instance):\n                                baseobj = baseobj._proxied\n                            else:\n                                continue\n                        if not baseobj.hide:\n                            if baseobj in yielded:\n                                continue\n                            yielded.add(baseobj)\n                            yield baseobj\n                        if not recurs:\n                            continue\n                        for grandpa in baseobj.ancestors(recurs=True, context=context):\n                            if grandpa is self:\n                                # This class is the ancestor of itself.\n                                break\n                            if grandpa in yielded:\n                                continue\n                            yielded.add(grandpa)\n                            yield grandpa\n                except InferenceError:\n                    continue\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "ancestors", "self", "recurs", "true", "context", "none", "iterate", "over", "the", "base", "classes", "in", "prefixed", "depth", "first", "order", "param", "recurs", "whether", "to", "recurse", "or", "return", "direct", "ancestors", "only", "type", "recurs", "bool", "returns", "the", "base", "classes", "rtype", "iterable", "nodeng", "fixme", "should", "be", "possible", "to", "choose", "the", "resolution", "order", "fixme", "inference", "make", "infinite", "loops", "possible", "here", "yielded", "self", "if", "context", "is", "none", "context", "inferencecontext", "if", "not", "self", "bases", "and", "self", "qname", "builtins", "object", "yield", "builtin_lookup", "object", "1", "0", "return", "for", "stmt", "in", "self", "bases", "with", "context", "restore_path", "try", "for", "baseobj", "in", "stmt", "infer", "context", "if", "not", "isinstance", "baseobj", "classdef", "if", "isinstance", "baseobj", "bases", "instance", "baseobj", "baseobj", "_proxied", "else", "continue", "if", "not", "baseobj", "hide", "if", "baseobj", "in", "yielded", "continue", "yielded", "add", "baseobj", "yield", "baseobj", "if", "not", "recurs", "continue", "for", "grandpa", "in", "baseobj", "ancestors", "recurs", "true", "context", "context", "if", "grandpa", "is", "self", "this", "class", "is", "the", "ancestor", "of", "itself", "break", "if", "grandpa", "in", "yielded", "continue", "yielded", "add", "grandpa", "yield", "grandpa", "except", "inferenceerror", "continue"], "doc_len": 164}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.local_attr_ancestors", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "local_attr_ancestors", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def local_attr_ancestors(self, name, context=None):\n        \"\"\"Iterate over the parents that define the given name.\n\n        :param name: The name to find definitions for.\n        :type name: str\n\n        :returns: The parents that define the given name.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        # Look up in the mro if we can. This will result in the\n        # attribute being looked up just as Python does it.\n        try:\n            ancestors = self.mro(context)[1:]\n        except MroError:\n            # Fallback to use ancestors, we can't determine\n            # a sane MRO.\n            ancestors = self.ancestors(context=context)\n        for astroid in ancestors:\n            if name in astroid:\n                yield astroid\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "local_attr_ancestors", "self", "name", "context", "none", "iterate", "over", "the", "parents", "that", "define", "the", "given", "name", "param", "name", "the", "name", "to", "find", "definitions", "for", "type", "name", "str", "returns", "the", "parents", "that", "define", "the", "given", "name", "rtype", "iterable", "nodeng", "look", "up", "in", "the", "mro", "if", "we", "can", "this", "will", "result", "in", "the", "attribute", "being", "looked", "up", "just", "as", "python", "does", "it", "try", "ancestors", "self", "mro", "context", "1", "except", "mroerror", "fallback", "to", "use", "ancestors", "we", "can", "t", "determine", "a", "sane", "mro", "ancestors", "self", "ancestors", "context", "context", "for", "astroid", "in", "ancestors", "if", "name", "in", "astroid", "yield", "astroid"], "doc_len": 99}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.instance_attr_ancestors", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "instance_attr_ancestors", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def instance_attr_ancestors(self, name, context=None):\n        \"\"\"Iterate over the parents that define the given name as an attribute.\n\n        :param name: The name to find definitions for.\n        :type name: str\n\n        :returns: The parents that define the given name as\n            an instance attribute.\n        :rtype: iterable(NodeNG)\n        \"\"\"\n        for astroid in self.ancestors(context=context):\n            if name in astroid.instance_attrs:\n                yield astroid\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "instance_attr_ancestors", "self", "name", "context", "none", "iterate", "over", "the", "parents", "that", "define", "the", "given", "name", "as", "an", "attribute", "param", "name", "the", "name", "to", "find", "definitions", "for", "type", "name", "str", "returns", "the", "parents", "that", "define", "the", "given", "name", "as", "an", "instance", "attribute", "rtype", "iterable", "nodeng", "for", "astroid", "in", "self", "ancestors", "context", "context", "if", "name", "in", "astroid", "instance_attrs", "yield", "astroid"], "doc_len": 64}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.has_base", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "has_base", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def has_base(self, node):\n        \"\"\"Whether this class directly inherits from the given node.\n\n        :param node: The node to check for.\n        :type node: NodeNG\n\n        :returns: True if this class directly inherits from the given node.\n        :rtype: bool\n        \"\"\"\n        return node in self.bases\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "has_base", "self", "node", "whether", "this", "class", "directly", "inherits", "from", "the", "given", "node", "param", "node", "the", "node", "to", "check", "for", "type", "node", "nodeng", "returns", "true", "if", "this", "class", "directly", "inherits", "from", "the", "given", "node", "rtype", "bool", "return", "node", "in", "self", "bases"], "doc_len": 47}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.local_attr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "local_attr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def local_attr(self, name, context=None):\n        \"\"\"Get the list of assign nodes associated to the given name.\n\n        Assignments are looked for in both this class and in parents.\n\n        :returns: The list of assignments to the given name.\n        :rtype: list(NodeNG)\n\n        :raises AttributeInferenceError: If no attribute with this name\n            can be found in this class or parent classes.\n        \"\"\"\n        result = []\n        if name in self.locals:\n            result = self.locals[name]\n        else:\n            class_node = next(self.local_attr_ancestors(name, context), None)\n            if class_node:\n                result = class_node.locals[name]\n        result = [n for n in result if not isinstance(n, node_classes.DelAttr)]\n        if result:\n            return result\n        raise AttributeInferenceError(target=self, attribute=name, context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "local_attr", "self", "name", "context", "none", "get", "the", "list", "of", "assign", "nodes", "associated", "to", "the", "given", "name", "assignments", "are", "looked", "for", "in", "both", "this", "class", "and", "in", "parents", "returns", "the", "list", "of", "assignments", "to", "the", "given", "name", "rtype", "list", "nodeng", "raises", "attributeinferenceerror", "if", "no", "attribute", "with", "this", "name", "can", "be", "found", "in", "this", "class", "or", "parent", "classes", "result", "if", "name", "in", "self", "locals", "result", "self", "locals", "name", "else", "class_node", "next", "self", "local_attr_ancestors", "name", "context", "none", "if", "class_node", "result", "class_node", "locals", "name", "result", "n", "for", "n", "in", "result", "if", "not", "isinstance", "n", "node_classes", "delattr", "if", "result", "return", "result", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context"], "doc_len": 111}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.instance_attr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "instance_attr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def instance_attr(self, name, context=None):\n        \"\"\"Get the list of nodes associated to the given attribute name.\n\n        Assignments are looked for in both this class and in parents.\n\n        :returns: The list of assignments to the given name.\n        :rtype: list(NodeNG)\n\n        :raises AttributeInferenceError: If no attribute with this name\n            can be found in this class or parent classes.\n        \"\"\"\n        # Return a copy, so we don't modify self.instance_attrs,\n        # which could lead to infinite loop.\n        values = list(self.instance_attrs.get(name, []))\n        # get all values from parents\n        for class_node in self.instance_attr_ancestors(name, context):\n            values += class_node.instance_attrs[name]\n        values = [n for n in values if not isinstance(n, node_classes.DelAttr)]\n        if values:\n            return values\n        raise AttributeInferenceError(target=self, attribute=name, context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "instance_attr", "self", "name", "context", "none", "get", "the", "list", "of", "nodes", "associated", "to", "the", "given", "attribute", "name", "assignments", "are", "looked", "for", "in", "both", "this", "class", "and", "in", "parents", "returns", "the", "list", "of", "assignments", "to", "the", "given", "name", "rtype", "list", "nodeng", "raises", "attributeinferenceerror", "if", "no", "attribute", "with", "this", "name", "can", "be", "found", "in", "this", "class", "or", "parent", "classes", "return", "a", "copy", "so", "we", "don", "t", "modify", "self", "instance_attrs", "which", "could", "lead", "to", "infinite", "loop", "values", "list", "self", "instance_attrs", "get", "name", "get", "all", "values", "from", "parents", "for", "class_node", "in", "self", "instance_attr_ancestors", "name", "context", "values", "class_node", "instance_attrs", "name", "values", "n", "for", "n", "in", "values", "if", "not", "isinstance", "n", "node_classes", "delattr", "if", "values", "return", "values", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context"], "doc_len": 125}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.instantiate_class", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "instantiate_class", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def instantiate_class(self):\n        \"\"\"Get an :class:`Instance` of the :class:`ClassDef` node.\n\n        :returns: An :class:`Instance` of the :class:`ClassDef` node,\n            or self if this is not possible.\n        :rtype: Instance or ClassDef\n        \"\"\"\n        try:\n            if any(cls.name in EXCEPTION_BASE_CLASSES for cls in self.mro()):\n                # Subclasses of exceptions can be exception instances\n                return objects.ExceptionInstance(self)\n        except MroError:\n            pass\n        return bases.Instance(self)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "instantiate_class", "self", "get", "an", "class", "instance", "of", "the", "class", "classdef", "node", "returns", "an", "class", "instance", "of", "the", "class", "classdef", "node", "or", "self", "if", "this", "is", "not", "possible", "rtype", "instance", "or", "classdef", "try", "if", "any", "cls", "name", "in", "exception_base_classes", "for", "cls", "in", "self", "mro", "subclasses", "of", "exceptions", "can", "be", "exception", "instances", "return", "objects", "exceptioninstance", "self", "except", "mroerror", "pass", "return", "bases", "instance", "self"], "doc_len": 68}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.getattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "getattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def getattr(self, name, context=None, class_context=True):\n        \"\"\"Get an attribute from this class, using Python's attribute semantic.\n\n        This method doesn't look in the :attr:`instance_attrs` dictionary\n        since it is done by an :class:`Instance` proxy at inference time.\n        It may return an :class:`Uninferable` object if\n        the attribute has not been\n        found, but a ``__getattr__`` or ``__getattribute__`` method is defined.\n        If ``class_context`` is given, then it is considered that the\n        attribute is accessed from a class context,\n        e.g. ClassDef.attribute, otherwise it might have been accessed\n        from an instance as well. If ``class_context`` is used in that\n        case, then a lookup in the implicit metaclass and the explicit\n        metaclass will be done.\n\n        :param name: The attribute to look for.\n        :type name: str\n\n        :param class_context: Whether the attribute can be accessed statically.\n        :type class_context: bool\n\n        :returns: The attribute.\n        :rtype: list(NodeNG)\n\n        :raises AttributeInferenceError: If the attribute cannot be inferred.\n        \"\"\"\n        if not name:\n            raise AttributeInferenceError(target=self, attribute=name, context=context)\n\n        values = self.locals.get(name, [])\n        if name in self.special_attributes and class_context and not values:\n            result = [self.special_attributes.lookup(name)]\n            if name == \"__bases__\":\n                # Need special treatment, since they are mutable\n                # and we need to return all the values.\n                result += values\n            return result\n\n        # don't modify the list in self.locals!\n        values = list(values)\n        for classnode in self.ancestors(recurs=True, context=context):\n            values += classnode.locals.get(name, [])\n\n        if class_context:\n            values += self._metaclass_lookup_attribute(name, context)\n\n        if not values:\n            raise AttributeInferenceError(target=self, attribute=name, context=context)\n\n        # Look for AnnAssigns, which are not attributes in the purest sense.\n        for value in values:\n            if isinstance(value, node_classes.AssignName):\n                stmt = value.statement(future=True)\n                if isinstance(stmt, node_classes.AnnAssign) and stmt.value is None:\n                    raise AttributeInferenceError(\n                        target=self, attribute=name, context=context\n                    )\n        return values\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "getattr", "self", "name", "context", "none", "class_context", "true", "get", "an", "attribute", "from", "this", "class", "using", "python", "s", "attribute", "semantic", "this", "method", "doesn", "t", "look", "in", "the", "attr", "instance_attrs", "dictionary", "since", "it", "is", "done", "by", "an", "class", "instance", "proxy", "at", "inference", "time", "it", "may", "return", "an", "class", "uninferable", "object", "if", "the", "attribute", "has", "not", "been", "found", "but", "a", "__getattr__", "or", "__getattribute__", "method", "is", "defined", "if", "class_context", "is", "given", "then", "it", "is", "considered", "that", "the", "attribute", "is", "accessed", "from", "a", "class", "context", "e", "g", "classdef", "attribute", "otherwise", "it", "might", "have", "been", "accessed", "from", "an", "instance", "as", "well", "if", "class_context", "is", "used", "in", "that", "case", "then", "a", "lookup", "in", "the", "implicit", "metaclass", "and", "the", "explicit", "metaclass", "will", "be", "done", "param", "name", "the", "attribute", "to", "look", "for", "type", "name", "str", "param", "class_context", "whether", "the", "attribute", "can", "be", "accessed", "statically", "type", "class_context", "bool", "returns", "the", "attribute", "rtype", "list", "nodeng", "raises", "attributeinferenceerror", "if", "the", "attribute", "cannot", "be", "inferred", "if", "not", "name", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "values", "self", "locals", "get", "name", "if", "name", "in", "self", "special_attributes", "and", "class_context", "and", "not", "values", "result", "self", "special_attributes", "lookup", "name", "if", "name", "__bases__", "need", "special", "treatment", "since", "they", "are", "mutable", "and", "we", "need", "to", "return", "all", "the", "values", "result", "values", "return", "result", "don", "t", "modify", "the", "list", "in", "self", "locals", "values", "list", "values", "for", "classnode", "in", "self", "ancestors", "recurs", "true", "context", "context", "values", "classnode", "locals", "get", "name", "if", "class_context", "values", "self", "_metaclass_lookup_attribute", "name", "context", "if", "not", "values", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "look", "for", "annassigns", "which", "are", "not", "attributes", "in", "the", "purest", "sense", "for", "value", "in", "values", "if", "isinstance", "value", "node_classes", "assignname", "stmt", "value", "statement", "future", "true", "if", "isinstance", "stmt", "node_classes", "annassign", "and", "stmt", "value", "is", "none", "raise", "attributeinferenceerror", "target", "self", "attribute", "name", "context", "context", "return", "values"], "doc_len": 299}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._metaclass_lookup_attribute", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_metaclass_lookup_attribute", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _metaclass_lookup_attribute(self, name, context):\n        \"\"\"Search the given name in the implicit and the explicit metaclass.\"\"\"\n        attrs = set()\n        implicit_meta = self.implicit_metaclass()\n        context = copy_context(context)\n        metaclass = self.metaclass(context=context)\n        for cls in (implicit_meta, metaclass):\n            if cls and cls != self and isinstance(cls, ClassDef):\n                cls_attributes = self._get_attribute_from_metaclass(cls, name, context)\n                attrs.update(set(cls_attributes))\n        return attrs\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_metaclass_lookup_attribute", "self", "name", "context", "search", "the", "given", "name", "in", "the", "implicit", "and", "the", "explicit", "metaclass", "attrs", "set", "implicit_meta", "self", "implicit_metaclass", "context", "copy_context", "context", "metaclass", "self", "metaclass", "context", "context", "for", "cls", "in", "implicit_meta", "metaclass", "if", "cls", "and", "cls", "self", "and", "isinstance", "cls", "classdef", "cls_attributes", "self", "_get_attribute_from_metaclass", "cls", "name", "context", "attrs", "update", "set", "cls_attributes", "return", "attrs"], "doc_len": 61}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._get_attribute_from_metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_get_attribute_from_metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _get_attribute_from_metaclass(self, cls, name, context):\n        try:\n            attrs = cls.getattr(name, context=context, class_context=True)\n        except AttributeInferenceError:\n            return\n\n        for attr in bases._infer_stmts(attrs, context, frame=cls):\n            if not isinstance(attr, FunctionDef):\n                yield attr\n                continue\n\n            if isinstance(attr, objects.Property):\n                yield attr\n                continue\n            if attr.type == \"classmethod\":\n                # If the method is a classmethod, then it will\n                # be bound to the metaclass, not to the class\n                # from where the attribute is retrieved.\n                # get_wrapping_class could return None, so just\n                # default to the current class.\n                frame = get_wrapping_class(attr) or self\n                yield bases.BoundMethod(attr, frame)\n            elif attr.type == \"staticmethod\":\n                yield attr\n            else:\n                yield bases.BoundMethod(attr, self)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_get_attribute_from_metaclass", "self", "cls", "name", "context", "try", "attrs", "cls", "getattr", "name", "context", "context", "class_context", "true", "except", "attributeinferenceerror", "return", "for", "attr", "in", "bases", "_infer_stmts", "attrs", "context", "frame", "cls", "if", "not", "isinstance", "attr", "functiondef", "yield", "attr", "continue", "if", "isinstance", "attr", "objects", "property", "yield", "attr", "continue", "if", "attr", "type", "classmethod", "if", "the", "method", "is", "a", "classmethod", "then", "it", "will", "be", "bound", "to", "the", "metaclass", "not", "to", "the", "class", "from", "where", "the", "attribute", "is", "retrieved", "get_wrapping_class", "could", "return", "none", "so", "just", "default", "to", "the", "current", "class", "frame", "get_wrapping_class", "attr", "or", "self", "yield", "bases", "boundmethod", "attr", "frame", "elif", "attr", "type", "staticmethod", "yield", "attr", "else", "yield", "bases", "boundmethod", "attr", "self"], "doc_len": 110}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.igetattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "igetattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def igetattr(self, name, context=None, class_context=True):\n        \"\"\"Infer the possible values of the given variable.\n\n        :param name: The name of the variable to infer.\n        :type name: str\n\n        :returns: The inferred possible values.\n        :rtype: iterable(NodeNG or Uninferable)\n        \"\"\"\n        # set lookup name since this is necessary to infer on import nodes for\n        # instance\n        context = copy_context(context)\n        context.lookupname = name\n\n        metaclass = self.metaclass(context=context)\n        try:\n            attributes = self.getattr(name, context, class_context=class_context)\n            # If we have more than one attribute, make sure that those starting from\n            # the second one are from the same scope. This is to account for modifications\n            # to the attribute happening *after* the attribute's definition (e.g. AugAssigns on lists)\n            if len(attributes) > 1:\n                first_attr, attributes = attributes[0], attributes[1:]\n                first_scope = first_attr.scope()\n                attributes = [first_attr] + [\n                    attr\n                    for attr in attributes\n                    if attr.parent and attr.parent.scope() == first_scope\n                ]\n\n            for inferred in bases._infer_stmts(attributes, context, frame=self):\n                # yield Uninferable object instead of descriptors when necessary\n                if not isinstance(inferred, node_classes.Const) and isinstance(\n                    inferred, bases.Instance\n                ):\n                    try:\n                        inferred._proxied.getattr(\"__get__\", context)\n                    except AttributeInferenceError:\n                        yield inferred\n                    else:\n                        yield util.Uninferable\n                elif isinstance(inferred, objects.Property):\n                    function = inferred.function\n                    if not class_context:\n                        # Through an instance so we can solve the property\n                        yield from function.infer_call_result(\n                            caller=self, context=context\n                        )\n                    # If we're in a class context, we need to determine if the property\n                    # was defined in the metaclass (a derived class must be a subclass of\n                    # the metaclass of all its bases), in which case we can resolve the\n                    # property. If not, i.e. the property is defined in some base class\n                    # instead, then we return the property object\n                    elif metaclass and function.parent.scope() is metaclass:\n                        # Resolve a property as long as it is not accessed through\n                        # the class itself.\n                        yield from function.infer_call_result(\n                            caller=self, context=context\n                        )\n                    else:\n                        yield inferred\n                else:\n                    yield function_to_method(inferred, self)\n        except AttributeInferenceError as error:\n            if not name.startswith(\"__\") and self.has_dynamic_getattr(context):\n                # class handle some dynamic attributes, return a Uninferable object\n                yield util.Uninferable\n            else:\n                raise InferenceError(\n                    str(error), target=self, attribute=name, context=context\n                ) from error\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "igetattr", "self", "name", "context", "none", "class_context", "true", "infer", "the", "possible", "values", "of", "the", "given", "variable", "param", "name", "the", "name", "of", "the", "variable", "to", "infer", "type", "name", "str", "returns", "the", "inferred", "possible", "values", "rtype", "iterable", "nodeng", "or", "uninferable", "set", "lookup", "name", "since", "this", "is", "necessary", "to", "infer", "on", "import", "nodes", "for", "instance", "context", "copy_context", "context", "context", "lookupname", "name", "metaclass", "self", "metaclass", "context", "context", "try", "attributes", "self", "getattr", "name", "context", "class_context", "class_context", "if", "we", "have", "more", "than", "one", "attribute", "make", "sure", "that", "those", "starting", "from", "the", "second", "one", "are", "from", "the", "same", "scope", "this", "is", "to", "account", "for", "modifications", "to", "the", "attribute", "happening", "after", "the", "attribute", "s", "definition", "e", "g", "augassigns", "on", "lists", "if", "len", "attributes", "1", "first_attr", "attributes", "attributes", "0", "attributes", "1", "first_scope", "first_attr", "scope", "attributes", "first_attr", "attr", "for", "attr", "in", "attributes", "if", "attr", "parent", "and", "attr", "parent", "scope", "first_scope", "for", "inferred", "in", "bases", "_infer_stmts", "attributes", "context", "frame", "self", "yield", "uninferable", "object", "instead", "of", "descriptors", "when", "necessary", "if", "not", "isinstance", "inferred", "node_classes", "const", "and", "isinstance", "inferred", "bases", "instance", "try", "inferred", "_proxied", "getattr", "__get__", "context", "except", "attributeinferenceerror", "yield", "inferred", "else", "yield", "util", "uninferable", "elif", "isinstance", "inferred", "objects", "property", "function", "inferred", "function", "if", "not", "class_context", "through", "an", "instance", "so", "we", "can", "solve", "the", "property", "yield", "from", "function", "infer_call_result", "caller", "self", "context", "context", "if", "we", "re", "in", "a", "class", "context", "we", "need", "to", "determine", "if", "the", "property", "was", "defined", "in", "the", "metaclass", "a", "derived", "class", "must", "be", "a", "subclass", "of", "the", "metaclass", "of", "all", "its", "bases", "in", "which", "case", "we", "can", "resolve", "the", "property", "if", "not", "i", "e", "the", "property", "is", "defined", "in", "some", "base", "class", "instead", "then", "we", "return", "the", "property", "object", "elif", "metaclass", "and", "function", "parent", "scope", "is", "metaclass", "resolve", "a", "property", "as", "long", "as", "it", "is", "not", "accessed", "through", "the", "class", "itself", "yield", "from", "function", "infer_call_result", "caller", "self", "context", "context", "else", "yield", "inferred", "else", "yield", "function_to_method", "inferred", "self", "except", "attributeinferenceerror", "as", "error", "if", "not", "name", "startswith", "__", "and", "self", "has_dynamic_getattr", "context", "class", "handle", "some", "dynamic", "attributes", "return", "a", "uninferable", "object", "yield", "util", "uninferable", "else", "raise", "inferenceerror", "str", "error", "target", "self", "attribute", "name", "context", "context", "from", "error"], "doc_len": 352}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.has_dynamic_getattr", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "has_dynamic_getattr", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def has_dynamic_getattr(self, context=None):\n        \"\"\"Check if the class has a custom __getattr__ or __getattribute__.\n\n        If any such method is found and it is not from\n        builtins, nor from an extension module, then the function\n        will return True.\n\n        :returns: True if the class has a custom\n            __getattr__ or __getattribute__, False otherwise.\n        :rtype: bool\n        \"\"\"\n\n        def _valid_getattr(node):\n            root = node.root()\n            return root.name != \"builtins\" and getattr(root, \"pure_python\", None)\n\n        try:\n            return _valid_getattr(self.getattr(\"__getattr__\", context)[0])\n        except AttributeInferenceError:\n            # if self.newstyle: XXX cause an infinite recursion error\n            try:\n                getattribute = self.getattr(\"__getattribute__\", context)[0]\n                return _valid_getattr(getattribute)\n            except AttributeInferenceError:\n                pass\n        return False\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "has_dynamic_getattr", "self", "context", "none", "check", "if", "the", "class", "has", "a", "custom", "__getattr__", "or", "__getattribute__", "if", "any", "such", "method", "is", "found", "and", "it", "is", "not", "from", "builtins", "nor", "from", "an", "extension", "module", "then", "the", "function", "will", "return", "true", "returns", "true", "if", "the", "class", "has", "a", "custom", "__getattr__", "or", "__getattribute__", "false", "otherwise", "rtype", "bool", "def", "_valid_getattr", "node", "root", "node", "root", "return", "root", "name", "builtins", "and", "getattr", "root", "pure_python", "none", "try", "return", "_valid_getattr", "self", "getattr", "__getattr__", "context", "0", "except", "attributeinferenceerror", "if", "self", "newstyle", "xxx", "cause", "an", "infinite", "recursion", "error", "try", "getattribute", "self", "getattr", "__getattribute__", "context", "0", "return", "_valid_getattr", "getattribute", "except", "attributeinferenceerror", "pass", "return", "false"], "doc_len": 108}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.getitem", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "getitem", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def getitem(self, index, context=None):\n        \"\"\"Return the inference of a subscript.\n\n        This is basically looking up the method in the metaclass and calling it.\n\n        :returns: The inferred value of a subscript to this class.\n        :rtype: NodeNG\n\n        :raises AstroidTypeError: If this class does not define a\n            ``__getitem__`` method.\n        \"\"\"\n        try:\n            methods = lookup(self, \"__getitem__\")\n        except AttributeInferenceError as exc:\n            if isinstance(self, ClassDef):\n                # subscripting a class definition may be\n                # achieved thanks to __class_getitem__ method\n                # which is a classmethod defined in the class\n                # that supports subscript and not in the metaclass\n                try:\n                    methods = self.getattr(\"__class_getitem__\")\n                    # Here it is assumed that the __class_getitem__ node is\n                    # a FunctionDef. One possible improvement would be to deal\n                    # with more generic inference.\n                except AttributeInferenceError:\n                    raise AstroidTypeError(node=self, context=context) from exc\n            else:\n                raise AstroidTypeError(node=self, context=context) from exc\n\n        method = methods[0]\n\n        # Create a new callcontext for providing index as an argument.\n        new_context = bind_context_to_node(context, self)\n        new_context.callcontext = CallContext(args=[index], callee=method)\n\n        try:\n            return next(method.infer_call_result(self, new_context), util.Uninferable)\n        except AttributeError:\n            # Starting with python3.9, builtin types list, dict etc...\n            # are subscriptable thanks to __class_getitem___ classmethod.\n            # However in such case the method is bound to an EmptyNode and\n            # EmptyNode doesn't have infer_call_result method yielding to\n            # AttributeError\n            if (\n                isinstance(method, node_classes.EmptyNode)\n                and self.name in {\"list\", \"dict\", \"set\", \"tuple\", \"frozenset\"}\n                and PY39_PLUS\n            ):\n                return self\n            raise\n        except InferenceError:\n            return util.Uninferable\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "getitem", "self", "index", "context", "none", "return", "the", "inference", "of", "a", "subscript", "this", "is", "basically", "looking", "up", "the", "method", "in", "the", "metaclass", "and", "calling", "it", "returns", "the", "inferred", "value", "of", "a", "subscript", "to", "this", "class", "rtype", "nodeng", "raises", "astroidtypeerror", "if", "this", "class", "does", "not", "define", "a", "__getitem__", "method", "try", "methods", "lookup", "self", "__getitem__", "except", "attributeinferenceerror", "as", "exc", "if", "isinstance", "self", "classdef", "subscripting", "a", "class", "definition", "may", "be", "achieved", "thanks", "to", "__class_getitem__", "method", "which", "is", "a", "classmethod", "defined", "in", "the", "class", "that", "supports", "subscript", "and", "not", "in", "the", "metaclass", "try", "methods", "self", "getattr", "__class_getitem__", "here", "it", "is", "assumed", "that", "the", "__class_getitem__", "node", "is", "a", "functiondef", "one", "possible", "improvement", "would", "be", "to", "deal", "with", "more", "generic", "inference", "except", "attributeinferenceerror", "raise", "astroidtypeerror", "node", "self", "context", "context", "from", "exc", "else", "raise", "astroidtypeerror", "node", "self", "context", "context", "from", "exc", "method", "methods", "0", "create", "a", "new", "callcontext", "for", "providing", "index", "as", "an", "argument", "new_context", "bind_context_to_node", "context", "self", "new_context", "callcontext", "callcontext", "args", "index", "callee", "method", "try", "return", "next", "method", "infer_call_result", "self", "new_context", "util", "uninferable", "except", "attributeerror", "starting", "with", "python3", "9", "builtin", "types", "list", "dict", "etc", "are", "subscriptable", "thanks", "to", "__class_getitem___", "classmethod", "however", "in", "such", "case", "the", "method", "is", "bound", "to", "an", "emptynode", "and", "emptynode", "doesn", "t", "have", "infer_call_result", "method", "yielding", "to", "attributeerror", "if", "isinstance", "method", "node_classes", "emptynode", "and", "self", "name", "in", "list", "dict", "set", "tuple", "frozenset", "and", "py39_plus", "return", "self", "raise", "except", "inferenceerror", "return", "util", "uninferable"], "doc_len": 235}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.methods", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "methods", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def methods(self):\n        \"\"\"Iterate over all of the method defined in this class and its parents.\n\n        :returns: The methods defined on the class.\n        :rtype: iterable(FunctionDef)\n        \"\"\"\n        done = {}\n        for astroid in itertools.chain(iter((self,)), self.ancestors()):\n            for meth in astroid.mymethods():\n                if meth.name in done:\n                    continue\n                done[meth.name] = None\n                yield meth\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "methods", "self", "iterate", "over", "all", "of", "the", "method", "defined", "in", "this", "class", "and", "its", "parents", "returns", "the", "methods", "defined", "on", "the", "class", "rtype", "iterable", "functiondef", "done", "for", "astroid", "in", "itertools", "chain", "iter", "self", "self", "ancestors", "for", "meth", "in", "astroid", "mymethods", "if", "meth", "name", "in", "done", "continue", "done", "meth", "name", "none", "yield", "meth"], "doc_len": 59}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.mymethods", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "mymethods", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def mymethods(self):\n        \"\"\"Iterate over all of the method defined in this class only.\n\n        :returns: The methods defined on the class.\n        :rtype: iterable(FunctionDef)\n        \"\"\"\n        for member in self.values():\n            if isinstance(member, FunctionDef):\n                yield member\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "mymethods", "self", "iterate", "over", "all", "of", "the", "method", "defined", "in", "this", "class", "only", "returns", "the", "methods", "defined", "on", "the", "class", "rtype", "iterable", "functiondef", "for", "member", "in", "self", "values", "if", "isinstance", "member", "functiondef", "yield", "member"], "doc_len": 41}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.implicit_metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "implicit_metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def implicit_metaclass(self):\n        \"\"\"Get the implicit metaclass of the current class.\n\n        For newstyle classes, this will return an instance of builtins.type.\n        For oldstyle classes, it will simply return None, since there's\n        no implicit metaclass there.\n\n        :returns: The metaclass.\n        :rtype: builtins.type or None\n        \"\"\"\n        if self.newstyle:\n            return builtin_lookup(\"type\")[1][0]\n        return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "implicit_metaclass", "self", "get", "the", "implicit", "metaclass", "of", "the", "current", "class", "for", "newstyle", "classes", "this", "will", "return", "an", "instance", "of", "builtins", "type", "for", "oldstyle", "classes", "it", "will", "simply", "return", "none", "since", "there", "s", "no", "implicit", "metaclass", "there", "returns", "the", "metaclass", "rtype", "builtins", "type", "or", "none", "if", "self", "newstyle", "return", "builtin_lookup", "type", "1", "0", "return", "none"], "doc_len": 61}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.declared_metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "declared_metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def declared_metaclass(self, context=None):\n        \"\"\"Return the explicit declared metaclass for the current class.\n\n        An explicit declared metaclass is defined\n        either by passing the ``metaclass`` keyword argument\n        in the class definition line (Python 3) or (Python 2) by\n        having a ``__metaclass__`` class attribute, or if there are\n        no explicit bases but there is a global ``__metaclass__`` variable.\n\n        :returns: The metaclass of this class,\n            or None if one could not be found.\n        :rtype: NodeNG or None\n        \"\"\"\n        for base in self.bases:\n            try:\n                for baseobj in base.infer(context=context):\n                    if isinstance(baseobj, ClassDef) and baseobj.hide:\n                        self._metaclass = baseobj._metaclass\n                        self._metaclass_hack = True\n                        break\n            except InferenceError:\n                pass\n\n        if self._metaclass:\n            # Expects this from Py3k TreeRebuilder\n            try:\n                return next(\n                    node\n                    for node in self._metaclass.infer(context=context)\n                    if node is not util.Uninferable\n                )\n            except (InferenceError, StopIteration):\n                return None\n\n        return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "declared_metaclass", "self", "context", "none", "return", "the", "explicit", "declared", "metaclass", "for", "the", "current", "class", "an", "explicit", "declared", "metaclass", "is", "defined", "either", "by", "passing", "the", "metaclass", "keyword", "argument", "in", "the", "class", "definition", "line", "python", "3", "or", "python", "2", "by", "having", "a", "__metaclass__", "class", "attribute", "or", "if", "there", "are", "no", "explicit", "bases", "but", "there", "is", "a", "global", "__metaclass__", "variable", "returns", "the", "metaclass", "of", "this", "class", "or", "none", "if", "one", "could", "not", "be", "found", "rtype", "nodeng", "or", "none", "for", "base", "in", "self", "bases", "try", "for", "baseobj", "in", "base", "infer", "context", "context", "if", "isinstance", "baseobj", "classdef", "and", "baseobj", "hide", "self", "_metaclass", "baseobj", "_metaclass", "self", "_metaclass_hack", "true", "break", "except", "inferenceerror", "pass", "if", "self", "_metaclass", "expects", "this", "from", "py3k", "treerebuilder", "try", "return", "next", "node", "for", "node", "in", "self", "_metaclass", "infer", "context", "context", "if", "node", "is", "not", "util", "uninferable", "except", "inferenceerror", "stopiteration", "return", "none", "return", "none"], "doc_len": 145}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._find_metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_find_metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _find_metaclass(self, seen=None, context=None):\n        if seen is None:\n            seen = set()\n        seen.add(self)\n\n        klass = self.declared_metaclass(context=context)\n        if klass is None:\n            for parent in self.ancestors(context=context):\n                if parent not in seen:\n                    klass = parent._find_metaclass(seen)\n                    if klass is not None:\n                        break\n        return klass\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_find_metaclass", "self", "seen", "none", "context", "none", "if", "seen", "is", "none", "seen", "set", "seen", "add", "self", "klass", "self", "declared_metaclass", "context", "context", "if", "klass", "is", "none", "for", "parent", "in", "self", "ancestors", "context", "context", "if", "parent", "not", "in", "seen", "klass", "parent", "_find_metaclass", "seen", "if", "klass", "is", "not", "none", "break", "return", "klass"], "doc_len": 55}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.metaclass", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "metaclass", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def metaclass(self, context=None):\n        \"\"\"Get the metaclass of this class.\n\n        If this class does not define explicitly a metaclass,\n        then the first defined metaclass in ancestors will be used\n        instead.\n\n        :returns: The metaclass of this class.\n        :rtype: NodeNG or None\n        \"\"\"\n        return self._find_metaclass(context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "metaclass", "self", "context", "none", "get", "the", "metaclass", "of", "this", "class", "if", "this", "class", "does", "not", "define", "explicitly", "a", "metaclass", "then", "the", "first", "defined", "metaclass", "in", "ancestors", "will", "be", "used", "instead", "returns", "the", "metaclass", "of", "this", "class", "rtype", "nodeng", "or", "none", "return", "self", "_find_metaclass", "context", "context"], "doc_len": 52}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.has_metaclass_hack", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "has_metaclass_hack", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def has_metaclass_hack(self):\n        return self._metaclass_hack\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "has_metaclass_hack", "self", "return", "self", "_metaclass_hack"], "doc_len": 12}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._islots", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_islots", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _islots(self):\n        \"\"\"Return an iterator with the inferred slots.\"\"\"\n        if \"__slots__\" not in self.locals:\n            return None\n        for slots in self.igetattr(\"__slots__\"):\n            # check if __slots__ is a valid type\n            for meth in ITER_METHODS:\n                try:\n                    slots.getattr(meth)\n                    break\n                except AttributeInferenceError:\n                    continue\n            else:\n                continue\n\n            if isinstance(slots, node_classes.Const):\n                # a string. Ignore the following checks,\n                # but yield the node, only if it has a value\n                if slots.value:\n                    yield slots\n                continue\n            if not hasattr(slots, \"itered\"):\n                # we can't obtain the values, maybe a .deque?\n                continue\n\n            if isinstance(slots, node_classes.Dict):\n                values = [item[0] for item in slots.items]\n            else:\n                values = slots.itered()\n            if values is util.Uninferable:\n                continue\n            if not values:\n                # Stop the iteration, because the class\n                # has an empty list of slots.\n                return values\n\n            for elt in values:\n                try:\n                    for inferred in elt.infer():\n                        if inferred is util.Uninferable:\n                            continue\n                        if not isinstance(\n                            inferred, node_classes.Const\n                        ) or not isinstance(inferred.value, str):\n                            continue\n                        if not inferred.value:\n                            continue\n                        yield inferred\n                except InferenceError:\n                    continue\n\n        return None\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_islots", "self", "return", "an", "iterator", "with", "the", "inferred", "slots", "if", "__slots__", "not", "in", "self", "locals", "return", "none", "for", "slots", "in", "self", "igetattr", "__slots__", "check", "if", "__slots__", "is", "a", "valid", "type", "for", "meth", "in", "iter_methods", "try", "slots", "getattr", "meth", "break", "except", "attributeinferenceerror", "continue", "else", "continue", "if", "isinstance", "slots", "node_classes", "const", "a", "string", "ignore", "the", "following", "checks", "but", "yield", "the", "node", "only", "if", "it", "has", "a", "value", "if", "slots", "value", "yield", "slots", "continue", "if", "not", "hasattr", "slots", "itered", "we", "can", "t", "obtain", "the", "values", "maybe", "a", "deque", "continue", "if", "isinstance", "slots", "node_classes", "dict", "values", "item", "0", "for", "item", "in", "slots", "items", "else", "values", "slots", "itered", "if", "values", "is", "util", "uninferable", "continue", "if", "not", "values", "stop", "the", "iteration", "because", "the", "class", "has", "an", "empty", "list", "of", "slots", "return", "values", "for", "elt", "in", "values", "try", "for", "inferred", "in", "elt", "infer", "if", "inferred", "is", "util", "uninferable", "continue", "if", "not", "isinstance", "inferred", "node_classes", "const", "or", "not", "isinstance", "inferred", "value", "str", "continue", "if", "not", "inferred", "value", "continue", "yield", "inferred", "except", "inferenceerror", "continue", "return", "none"], "doc_len": 174}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._slots", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_slots", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _slots(self):\n        if not self.newstyle:\n            raise NotImplementedError(\n                \"The concept of slots is undefined for old-style classes.\"\n            )\n\n        slots = self._islots()\n        try:\n            first = next(slots)\n        except StopIteration as exc:\n            # The class doesn't have a __slots__ definition or empty slots.\n            if exc.args and exc.args[0] not in (\"\", None):\n                return exc.args[0]\n            return None\n        return [first] + list(slots)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_slots", "self", "if", "not", "self", "newstyle", "raise", "notimplementederror", "the", "concept", "of", "slots", "is", "undefined", "for", "old", "style", "classes", "slots", "self", "_islots", "try", "first", "next", "slots", "except", "stopiteration", "as", "exc", "the", "class", "doesn", "t", "have", "a", "__slots__", "definition", "or", "empty", "slots", "if", "exc", "args", "and", "exc", "args", "0", "not", "in", "none", "return", "exc", "args", "0", "return", "none", "return", "first", "list", "slots"], "doc_len": 67}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.slots", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "slots", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def slots(self):\n        \"\"\"Get all the slots for this node.\n\n        :returns: The names of slots for this class.\n            If the class doesn't define any slot, through the ``__slots__``\n            variable, then this function will return a None.\n            Also, it will return None in the case the slots were not inferred.\n        :rtype: list(str) or None\n        \"\"\"\n\n        def grouped_slots(\n            mro: List[\"ClassDef\"],\n        ) -> typing.Iterator[Optional[node_classes.NodeNG]]:\n            # Not interested in object, since it can't have slots.\n            for cls in mro[:-1]:\n                try:\n                    cls_slots = cls._slots()\n                except NotImplementedError:\n                    continue\n                if cls_slots is not None:\n                    yield from cls_slots\n                else:\n                    yield None\n\n        if not self.newstyle:\n            raise NotImplementedError(\n                \"The concept of slots is undefined for old-style classes.\"\n            )\n\n        try:\n            mro = self.mro()\n        except MroError as e:\n            raise NotImplementedError(\n                \"Cannot get slots while parsing mro fails.\"\n            ) from e\n\n        slots = list(grouped_slots(mro))\n        if not all(slot is not None for slot in slots):\n            return None\n\n        return sorted(set(slots), key=lambda item: item.value)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "slots", "self", "get", "all", "the", "slots", "for", "this", "node", "returns", "the", "names", "of", "slots", "for", "this", "class", "if", "the", "class", "doesn", "t", "define", "any", "slot", "through", "the", "__slots__", "variable", "then", "this", "function", "will", "return", "a", "none", "also", "it", "will", "return", "none", "in", "the", "case", "the", "slots", "were", "not", "inferred", "rtype", "list", "str", "or", "none", "def", "grouped_slots", "mro", "list", "classdef", "typing", "iterator", "optional", "node_classes", "nodeng", "not", "interested", "in", "object", "since", "it", "can", "t", "have", "slots", "for", "cls", "in", "mro", "1", "try", "cls_slots", "cls", "_slots", "except", "notimplementederror", "continue", "if", "cls_slots", "is", "not", "none", "yield", "from", "cls_slots", "else", "yield", "none", "if", "not", "self", "newstyle", "raise", "notimplementederror", "the", "concept", "of", "slots", "is", "undefined", "for", "old", "style", "classes", "try", "mro", "self", "mro", "except", "mroerror", "as", "e", "raise", "notimplementederror", "cannot", "get", "slots", "while", "parsing", "mro", "fails", "from", "e", "slots", "list", "grouped_slots", "mro", "if", "not", "all", "slot", "is", "not", "none", "for", "slot", "in", "slots", "return", "none", "return", "sorted", "set", "slots", "key", "lambda", "item", "item", "value"], "doc_len": 165}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._inferred_bases", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_inferred_bases", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _inferred_bases(self, context=None):\n        # Similar with .ancestors, but the difference is when one base is inferred,\n        # only the first object is wanted. That's because\n        # we aren't interested in superclasses, as in the following\n        # example:\n        #\n        # class SomeSuperClass(object): pass\n        # class SomeClass(SomeSuperClass): pass\n        # class Test(SomeClass): pass\n        #\n        # Inferring SomeClass from the Test's bases will give\n        # us both SomeClass and SomeSuperClass, but we are interested\n        # only in SomeClass.\n\n        if context is None:\n            context = InferenceContext()\n        if not self.bases and self.qname() != \"builtins.object\":\n            yield builtin_lookup(\"object\")[1][0]\n            return\n\n        for stmt in self.bases:\n            try:\n                # Find the first non-None inferred base value\n                baseobj = next(\n                    b\n                    for b in stmt.infer(context=context.clone())\n                    if not (isinstance(b, Const) and b.value is None)\n                )\n            except (InferenceError, StopIteration):\n                continue\n            if isinstance(baseobj, bases.Instance):\n                baseobj = baseobj._proxied\n            if not isinstance(baseobj, ClassDef):\n                continue\n            if not baseobj.hide:\n                yield baseobj\n            else:\n                yield from baseobj.bases\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_inferred_bases", "self", "context", "none", "similar", "with", "ancestors", "but", "the", "difference", "is", "when", "one", "base", "is", "inferred", "only", "the", "first", "object", "is", "wanted", "that", "s", "because", "we", "aren", "t", "interested", "in", "superclasses", "as", "in", "the", "following", "example", "class", "somesuperclass", "object", "pass", "class", "someclass", "somesuperclass", "pass", "class", "test", "someclass", "pass", "inferring", "someclass", "from", "the", "test", "s", "bases", "will", "give", "us", "both", "someclass", "and", "somesuperclass", "but", "we", "are", "interested", "only", "in", "someclass", "if", "context", "is", "none", "context", "inferencecontext", "if", "not", "self", "bases", "and", "self", "qname", "builtins", "object", "yield", "builtin_lookup", "object", "1", "0", "return", "for", "stmt", "in", "self", "bases", "try", "find", "the", "first", "non", "none", "inferred", "base", "value", "baseobj", "next", "b", "for", "b", "in", "stmt", "infer", "context", "context", "clone", "if", "not", "isinstance", "b", "const", "and", "b", "value", "is", "none", "except", "inferenceerror", "stopiteration", "continue", "if", "isinstance", "baseobj", "bases", "instance", "baseobj", "baseobj", "_proxied", "if", "not", "isinstance", "baseobj", "classdef", "continue", "if", "not", "baseobj", "hide", "yield", "baseobj", "else", "yield", "from", "baseobj", "bases"], "doc_len": 161}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._compute_mro", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_compute_mro", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _compute_mro(self, context=None):\n        inferred_bases = list(self._inferred_bases(context=context))\n        bases_mro = []\n        for base in inferred_bases:\n            if base is self:\n                continue\n\n            try:\n                mro = base._compute_mro(context=context)\n                bases_mro.append(mro)\n            except NotImplementedError:\n                # Some classes have in their ancestors both newstyle and\n                # old style classes. For these we can't retrieve the .mro,\n                # although in Python it's possible, since the class we are\n                # currently working is in fact new style.\n                # So, we fallback to ancestors here.\n                ancestors = list(base.ancestors(context=context))\n                bases_mro.append(ancestors)\n\n        unmerged_mro = [[self]] + bases_mro + [inferred_bases]\n        unmerged_mro = list(clean_duplicates_mro(unmerged_mro, self, context))\n        clean_typing_generic_mro(unmerged_mro)\n        return _c3_merge(unmerged_mro, self, context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_compute_mro", "self", "context", "none", "inferred_bases", "list", "self", "_inferred_bases", "context", "context", "bases_mro", "for", "base", "in", "inferred_bases", "if", "base", "is", "self", "continue", "try", "mro", "base", "_compute_mro", "context", "context", "bases_mro", "append", "mro", "except", "notimplementederror", "some", "classes", "have", "in", "their", "ancestors", "both", "newstyle", "and", "old", "style", "classes", "for", "these", "we", "can", "t", "retrieve", "the", "mro", "although", "in", "python", "it", "s", "possible", "since", "the", "class", "we", "are", "currently", "working", "is", "in", "fact", "new", "style", "so", "we", "fallback", "to", "ancestors", "here", "ancestors", "list", "base", "ancestors", "context", "context", "bases_mro", "append", "ancestors", "unmerged_mro", "self", "bases_mro", "inferred_bases", "unmerged_mro", "list", "clean_duplicates_mro", "unmerged_mro", "self", "context", "clean_typing_generic_mro", "unmerged_mro", "return", "_c3_merge", "unmerged_mro", "self", "context"], "doc_len": 108}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.mro", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "mro", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def mro(self, context=None) -> List[\"ClassDef\"]:\n        \"\"\"Get the method resolution order, using C3 linearization.\n\n        :returns: The list of ancestors, sorted by the mro.\n        :rtype: list(NodeNG)\n        :raises DuplicateBasesError: Duplicate bases in the same class base\n        :raises InconsistentMroError: A class' MRO is inconsistent\n        \"\"\"\n        return self._compute_mro(context=context)\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "mro", "self", "context", "none", "list", "classdef", "get", "the", "method", "resolution", "order", "using", "c3", "linearization", "returns", "the", "list", "of", "ancestors", "sorted", "by", "the", "mro", "rtype", "list", "nodeng", "raises", "duplicatebaseserror", "duplicate", "bases", "in", "the", "same", "class", "base", "raises", "inconsistentmroerror", "a", "class", "mro", "is", "inconsistent", "return", "self", "_compute_mro", "context", "context"], "doc_len": 54}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.bool_value", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "bool_value", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def bool_value(self, context=None):\n        \"\"\"Determine the boolean value of this node.\n\n        :returns: The boolean value of this node.\n            For a :class:`ClassDef` this is always ``True``.\n        :rtype: bool\n        \"\"\"\n        return True\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "bool_value", "self", "context", "none", "determine", "the", "boolean", "value", "of", "this", "node", "returns", "the", "boolean", "value", "of", "this", "node", "for", "a", "class", "classdef", "this", "is", "always", "true", "rtype", "bool", "return", "true"], "doc_len": 37}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.get_children", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "get_children", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def get_children(self):\n        if self.decorators is not None:\n            yield self.decorators\n\n        yield from self.bases\n        if self.keywords is not None:\n            yield from self.keywords\n        yield from self.body\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "get_children", "self", "if", "self", "decorators", "is", "not", "none", "yield", "self", "decorators", "yield", "from", "self", "bases", "if", "self", "keywords", "is", "not", "none", "yield", "from", "self", "keywords", "yield", "from", "self", "body"], "doc_len": 36}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef._get_assign_nodes", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "_get_assign_nodes", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def _get_assign_nodes(self):\n        children_assign_nodes = (\n            child_node._get_assign_nodes() for child_node in self.body\n        )\n        return list(itertools.chain.from_iterable(children_assign_nodes))\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "_get_assign_nodes", "self", "children_assign_nodes", "child_node", "_get_assign_nodes", "for", "child_node", "in", "self", "body", "return", "list", "itertools", "chain", "from_iterable", "children_assign_nodes"], "doc_len": 23}
{"doc_id": "astroid/nodes/scoped_nodes/scoped_nodes.py::ClassDef.frame", "file_path": "astroid/nodes/scoped_nodes/scoped_nodes.py", "class_name": "ClassDef", "func_name": "frame", "text": "文件路径: astroid/nodes/scoped_nodes/scoped_nodes.py, 类名: ClassDef\n    def frame(self: T, *, future: Literal[None, True] = None) -> T:\n        \"\"\"The node's frame node.\n\n        A frame node is a :class:`Module`, :class:`FunctionDef`,\n        :class:`ClassDef` or :class:`Lambda`.\n\n        :returns: The node itself.\n        \"\"\"\n        return self\n", "tokens": ["astroid", "nodes", "scoped_nodes", "scoped_nodes", "py", "classdef", "def", "frame", "self", "t", "future", "literal", "none", "true", "none", "t", "the", "node", "s", "frame", "node", "a", "frame", "node", "is", "a", "class", "module", "class", "functiondef", "class", "classdef", "or", "class", "lambda", "returns", "the", "node", "itself", "return", "self"], "doc_len": 41}
{"doc_id": "script/bump_changelog.py::main", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "main", "text": "文件路径: script/bump_changelog.py\ndef main() -> None:\n    parser = argparse.ArgumentParser(__doc__)\n    parser.add_argument(\"version\", help=\"The version we want to release\")\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", default=False, help=\"Logging or not\"\n    )\n    args = parser.parse_args()\n    if args.verbose:\n        logging.basicConfig(level=logging.DEBUG)\n    logging.debug(f\"Launching bump_changelog with args: {args}\")\n    if \"dev\" in args.version:\n        return\n    with open(DEFAULT_CHANGELOG_PATH, encoding=\"utf-8\") as f:\n        content = f.read()\n    content = transform_content(content, args.version)\n    with open(DEFAULT_CHANGELOG_PATH, \"w\", encoding=\"utf8\") as f:\n        f.write(content)\n", "tokens": ["script", "bump_changelog", "py", "def", "main", "none", "parser", "argparse", "argumentparser", "__doc__", "parser", "add_argument", "version", "help", "the", "version", "we", "want", "to", "release", "parser", "add_argument", "v", "verbose", "action", "store_true", "default", "false", "help", "logging", "or", "not", "args", "parser", "parse_args", "if", "args", "verbose", "logging", "basicconfig", "level", "logging", "debug", "logging", "debug", "f", "launching", "bump_changelog", "with", "args", "args", "if", "dev", "in", "args", "version", "return", "with", "open", "default_changelog_path", "encoding", "utf", "8", "as", "f", "content", "f", "read", "content", "transform_content", "content", "args", "version", "with", "open", "default_changelog_path", "w", "encoding", "utf8", "as", "f", "f", "write", "content"], "doc_len": 84}
{"doc_id": "script/bump_changelog.py::get_next_version", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "get_next_version", "text": "文件路径: script/bump_changelog.py\ndef get_next_version(version: str, version_type: VersionType) -> str:\n    new_version = version.split(\".\")\n    part_to_increase = new_version[version_type.value]\n    if \"-\" in part_to_increase:\n        part_to_increase = part_to_increase.split(\"-\")[0]\n    for i in range(version_type.value, 3):\n        new_version[i] = \"0\"\n    new_version[version_type.value] = str(int(part_to_increase) + 1)\n    return \".\".join(new_version)\n", "tokens": ["script", "bump_changelog", "py", "def", "get_next_version", "version", "str", "version_type", "versiontype", "str", "new_version", "version", "split", "part_to_increase", "new_version", "version_type", "value", "if", "in", "part_to_increase", "part_to_increase", "part_to_increase", "split", "0", "for", "i", "in", "range", "version_type", "value", "3", "new_version", "i", "0", "new_version", "version_type", "value", "str", "int", "part_to_increase", "1", "return", "join", "new_version"], "doc_len": 44}
{"doc_id": "script/bump_changelog.py::get_next_versions", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "get_next_versions", "text": "文件路径: script/bump_changelog.py\ndef get_next_versions(version: str, version_type: VersionType) -> List[str]:\n    if version_type == VersionType.PATCH:\n        # \"2.6.1\" => [\"2.6.2\"]\n        return [get_next_version(version, VersionType.PATCH)]\n    if version_type == VersionType.MINOR:\n        # \"2.6.0\" => [\"2.7.0\", \"2.6.1\"]\n        assert version.endswith(\".0\"), f\"{version} does not look like a minor version\"\n    else:\n        # \"3.0.0\" => [\"3.1.0\", \"3.0.1\"]\n        assert version.endswith(\".0.0\"), f\"{version} does not look like a major version\"\n    next_minor_version = get_next_version(version, VersionType.MINOR)\n    next_patch_version = get_next_version(version, VersionType.PATCH)\n    logging.debug(f\"Getting the new version for {version} - {version_type.name}\")\n    return [next_minor_version, next_patch_version]\n", "tokens": ["script", "bump_changelog", "py", "def", "get_next_versions", "version", "str", "version_type", "versiontype", "list", "str", "if", "version_type", "versiontype", "patch", "2", "6", "1", "2", "6", "2", "return", "get_next_version", "version", "versiontype", "patch", "if", "version_type", "versiontype", "minor", "2", "6", "0", "2", "7", "0", "2", "6", "1", "assert", "version", "endswith", "0", "f", "version", "does", "not", "look", "like", "a", "minor", "version", "else", "3", "0", "0", "3", "1", "0", "3", "0", "1", "assert", "version", "endswith", "0", "0", "f", "version", "does", "not", "look", "like", "a", "major", "version", "next_minor_version", "get_next_version", "version", "versiontype", "minor", "next_patch_version", "get_next_version", "version", "versiontype", "patch", "logging", "debug", "f", "getting", "the", "new", "version", "for", "version", "version_type", "name", "return", "next_minor_version", "next_patch_version"], "doc_len": 100}
{"doc_id": "script/bump_changelog.py::get_version_type", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "get_version_type", "text": "文件路径: script/bump_changelog.py\ndef get_version_type(version: str) -> VersionType:\n    if version.endswith(\".0.0\"):\n        version_type = VersionType.MAJOR\n    elif version.endswith(\".0\"):\n        version_type = VersionType.MINOR\n    else:\n        version_type = VersionType.PATCH\n    return version_type\n", "tokens": ["script", "bump_changelog", "py", "def", "get_version_type", "version", "str", "versiontype", "if", "version", "endswith", "0", "0", "version_type", "versiontype", "major", "elif", "version", "endswith", "0", "version_type", "versiontype", "minor", "else", "version_type", "versiontype", "patch", "return", "version_type"], "doc_len": 29}
{"doc_id": "script/bump_changelog.py::get_whats_new", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "get_whats_new", "text": "文件路径: script/bump_changelog.py\ndef get_whats_new(\n    version: str, add_date: bool = False, change_date: bool = False\n) -> str:\n    whats_new_text = FULL_WHATS_NEW_TEXT.format(version=version)\n    result = [whats_new_text, \"=\" * len(whats_new_text)]\n    if add_date and change_date:\n        result += [NEW_RELEASE_DATE_MESSAGE]\n    elif add_date:\n        result += [RELEASE_DATE_TEXT]\n    elif change_date:\n        raise ValueError(\"Can't use change_date=True with add_date=False\")\n    logging.debug(\n        f\"version='{version}', add_date='{add_date}', change_date='{change_date}': {result}\"\n    )\n    return \"\\n\".join(result)\n", "tokens": ["script", "bump_changelog", "py", "def", "get_whats_new", "version", "str", "add_date", "bool", "false", "change_date", "bool", "false", "str", "whats_new_text", "full_whats_new_text", "format", "version", "version", "result", "whats_new_text", "len", "whats_new_text", "if", "add_date", "and", "change_date", "result", "new_release_date_message", "elif", "add_date", "result", "release_date_text", "elif", "change_date", "raise", "valueerror", "can", "t", "use", "change_date", "true", "with", "add_date", "false", "logging", "debug", "f", "version", "version", "add_date", "add_date", "change_date", "change_date", "result", "return", "n", "join", "result"], "doc_len": 59}
{"doc_id": "script/bump_changelog.py::get_all_whats_new", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "get_all_whats_new", "text": "文件路径: script/bump_changelog.py\ndef get_all_whats_new(version: str, version_type: VersionType) -> str:\n    result = \"\"\n    for version_ in get_next_versions(version, version_type=version_type):\n        result += get_whats_new(version_, add_date=True) + \"\\n\" * 4\n    return result\n", "tokens": ["script", "bump_changelog", "py", "def", "get_all_whats_new", "version", "str", "version_type", "versiontype", "str", "result", "for", "version_", "in", "get_next_versions", "version", "version_type", "version_type", "result", "get_whats_new", "version_", "add_date", "true", "n", "4", "return", "result"], "doc_len": 27}
{"doc_id": "script/bump_changelog.py::transform_content", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "transform_content", "text": "文件路径: script/bump_changelog.py\ndef transform_content(content: str, version: str) -> str:\n    version_type = get_version_type(version)\n    next_version = get_next_version(version, version_type)\n    old_date = get_whats_new(version, add_date=True)\n    new_date = get_whats_new(version, add_date=True, change_date=True)\n    next_version_with_date = get_all_whats_new(version, version_type)\n    do_checks(content, next_version, version, version_type)\n    index = content.find(old_date)\n    logging.debug(f\"Replacing\\n'{old_date}'\\nby\\n'{new_date}'\\n\")\n    content = content.replace(old_date, new_date)\n    end_content = content[index:]\n    content = content[:index]\n    logging.debug(f\"Adding:\\n'{next_version_with_date}'\\n\")\n    content += next_version_with_date + end_content\n    return content\n", "tokens": ["script", "bump_changelog", "py", "def", "transform_content", "content", "str", "version", "str", "str", "version_type", "get_version_type", "version", "next_version", "get_next_version", "version", "version_type", "old_date", "get_whats_new", "version", "add_date", "true", "new_date", "get_whats_new", "version", "add_date", "true", "change_date", "true", "next_version_with_date", "get_all_whats_new", "version", "version_type", "do_checks", "content", "next_version", "version", "version_type", "index", "content", "find", "old_date", "logging", "debug", "f", "replacing", "n", "old_date", "nby", "n", "new_date", "n", "content", "content", "replace", "old_date", "new_date", "end_content", "content", "index", "content", "content", "index", "logging", "debug", "f", "adding", "n", "next_version_with_date", "n", "content", "next_version_with_date", "end_content", "return", "content"], "doc_len": 75}
{"doc_id": "script/bump_changelog.py::do_checks", "file_path": "script/bump_changelog.py", "class_name": null, "func_name": "do_checks", "text": "文件路径: script/bump_changelog.py\ndef do_checks(content, next_version, version, version_type):\n    err = \"in the changelog, fix that first!\"\n    NEW_VERSION_ERROR_MSG = (\n        \"The text for this version '{version}' did not exists %s\" % err\n    )\n    NEXT_VERSION_ERROR_MSG = (\n        \"The text for the next version '{version}' already exists %s\" % err\n    )\n    wn_next_version = get_whats_new(next_version)\n    wn_this_version = get_whats_new(version)\n    # There is only one field where the release date is TBA\n    if version_type in [VersionType.MAJOR, VersionType.MINOR]:\n        assert (\n            content.count(RELEASE_DATE_TEXT) <= 1\n        ), f\"There should be only one release date 'TBA' ({version}) {err}\"\n    else:\n        next_minor_version = get_next_version(version, VersionType.MINOR)\n        assert (\n            content.count(RELEASE_DATE_TEXT) <= 2\n        ), f\"There should be only two release dates 'TBA' ({version} and {next_minor_version}) {err}\"\n    # There is already a release note for the version we want to release\n    assert content.count(wn_this_version) == 1, NEW_VERSION_ERROR_MSG.format(\n        version=version\n    )\n    # There is no release notes for the next version\n    assert content.count(wn_next_version) == 0, NEXT_VERSION_ERROR_MSG.format(\n        version=next_version\n    )\n", "tokens": ["script", "bump_changelog", "py", "def", "do_checks", "content", "next_version", "version", "version_type", "err", "in", "the", "changelog", "fix", "that", "first", "new_version_error_msg", "the", "text", "for", "this", "version", "version", "did", "not", "exists", "s", "err", "next_version_error_msg", "the", "text", "for", "the", "next", "version", "version", "already", "exists", "s", "err", "wn_next_version", "get_whats_new", "next_version", "wn_this_version", "get_whats_new", "version", "there", "is", "only", "one", "field", "where", "the", "release", "date", "is", "tba", "if", "version_type", "in", "versiontype", "major", "versiontype", "minor", "assert", "content", "count", "release_date_text", "1", "f", "there", "should", "be", "only", "one", "release", "date", "tba", "version", "err", "else", "next_minor_version", "get_next_version", "version", "versiontype", "minor", "assert", "content", "count", "release_date_text", "2", "f", "there", "should", "be", "only", "two", "release", "dates", "tba", "version", "and", "next_minor_version", "err", "there", "is", "already", "a", "release", "note", "for", "the", "version", "we", "want", "to", "release", "assert", "content", "count", "wn_this_version", "1", "new_version_error_msg", "format", "version", "version", "there", "is", "no", "release", "notes", "for", "the", "next", "version", "assert", "content", "count", "wn_next_version", "0", "next_version_error_msg", "format", "version", "next_version"], "doc_len": 144}
{"doc_id": "script/test_bump_changelog.py::test_get_next_version", "file_path": "script/test_bump_changelog.py", "class_name": null, "func_name": "test_get_next_version", "text": "文件路径: script/test_bump_changelog.py\ndef test_get_next_version(version, version_type, expected_version, expected_versions):\n    assert get_next_version(version, version_type) == expected_version\n    if (\n        version_type == VersionType.PATCH\n        or version_type == VersionType.MINOR\n        and version.endswith(\".0\")\n    ):\n        assert get_next_versions(version, version_type) == expected_versions\n", "tokens": ["script", "test_bump_changelog", "py", "def", "test_get_next_version", "version", "version_type", "expected_version", "expected_versions", "assert", "get_next_version", "version", "version_type", "expected_version", "if", "version_type", "versiontype", "patch", "or", "version_type", "versiontype", "minor", "and", "version", "endswith", "0", "assert", "get_next_versions", "version", "version_type", "expected_versions"], "doc_len": 31}
{"doc_id": "script/test_bump_changelog.py::test_update_content_error", "file_path": "script/test_bump_changelog.py", "class_name": null, "func_name": "test_update_content_error", "text": "文件路径: script/test_bump_changelog.py\ndef test_update_content_error(old_content, version, expected_error, caplog):\n    caplog.set_level(logging.DEBUG)\n    with pytest.raises(AssertionError, match=expected_error):\n        transform_content(old_content, version)\n", "tokens": ["script", "test_bump_changelog", "py", "def", "test_update_content_error", "old_content", "version", "expected_error", "caplog", "caplog", "set_level", "logging", "debug", "with", "pytest", "raises", "assertionerror", "match", "expected_error", "transform_content", "old_content", "version"], "doc_len": 22}
{"doc_id": "script/test_bump_changelog.py::test_update_content", "file_path": "script/test_bump_changelog.py", "class_name": null, "func_name": "test_update_content", "text": "文件路径: script/test_bump_changelog.py\ndef test_update_content(caplog):\n    caplog.set_level(logging.DEBUG)\n    old_content = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 2.6.1?\n============================\nRelease date: TBA\n\"\"\"\n    expected_beginning = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 2.6.2?\n============================\nRelease date: TBA\n\n\n\nWhat's New in astroid 2.6.1?\n============================\nRelease date: 20\"\"\"\n\n    new_content = transform_content(old_content, \"2.6.1\")\n    assert new_content[: len(expected_beginning)] == expected_beginning\n", "tokens": ["script", "test_bump_changelog", "py", "def", "test_update_content", "caplog", "caplog", "set_level", "logging", "debug", "old_content", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "2", "6", "1", "release", "date", "tba", "expected_beginning", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "2", "6", "2", "release", "date", "tba", "what", "s", "new", "in", "astroid", "2", "6", "1", "release", "date", "20", "new_content", "transform_content", "old_content", "2", "6", "1", "assert", "new_content", "len", "expected_beginning", "expected_beginning"], "doc_len": 62}
{"doc_id": "script/test_bump_changelog.py::test_update_content_minor", "file_path": "script/test_bump_changelog.py", "class_name": null, "func_name": "test_update_content_minor", "text": "文件路径: script/test_bump_changelog.py\ndef test_update_content_minor():\n    old_content = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 2.7.0?\n============================\nRelease date: TBA\n\"\"\"\n    expected_beginning = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 2.8.0?\n============================\nRelease date: TBA\n\n\n\nWhat's New in astroid 2.7.1?\n============================\nRelease date: TBA\n\n\n\nWhat's New in astroid 2.7.0?\n============================\nRelease date: 20\"\"\"\n\n    new_content = transform_content(old_content, \"2.7.0\")\n    assert new_content[: len(expected_beginning)] == expected_beginning\n", "tokens": ["script", "test_bump_changelog", "py", "def", "test_update_content_minor", "old_content", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "2", "7", "0", "release", "date", "tba", "expected_beginning", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "2", "8", "0", "release", "date", "tba", "what", "s", "new", "in", "astroid", "2", "7", "1", "release", "date", "tba", "what", "s", "new", "in", "astroid", "2", "7", "0", "release", "date", "20", "new_content", "transform_content", "old_content", "2", "7", "0", "assert", "new_content", "len", "expected_beginning", "expected_beginning"], "doc_len": 68}
{"doc_id": "script/test_bump_changelog.py::test_update_content_major", "file_path": "script/test_bump_changelog.py", "class_name": null, "func_name": "test_update_content_major", "text": "文件路径: script/test_bump_changelog.py\ndef test_update_content_major(caplog):\n    caplog.set_level(logging.DEBUG)\n    old_content = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 3.0.0?\n============================\nRelease date: TBA\n\nWhat's New in astroid 2.7.1?\n============================\nRelease date: 2020-04-03\n\nWhat's New in astroid 2.7.0?\n============================\nRelease date: 2020-04-01\n\"\"\"\n    expected_beginning = \"\"\"\n===================\nastroid's ChangeLog\n===================\n\nWhat's New in astroid 3.1.0?\n============================\nRelease date: TBA\n\n\n\nWhat's New in astroid 3.0.1?\n============================\nRelease date: TBA\n\n\n\nWhat's New in astroid 3.0.0?\n============================\nRelease date: 20\"\"\"\n    new_content = transform_content(old_content, \"3.0.0\")\n    assert new_content[: len(expected_beginning)] == expected_beginning\n", "tokens": ["script", "test_bump_changelog", "py", "def", "test_update_content_major", "caplog", "caplog", "set_level", "logging", "debug", "old_content", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "3", "0", "0", "release", "date", "tba", "what", "s", "new", "in", "astroid", "2", "7", "1", "release", "date", "2020", "04", "03", "what", "s", "new", "in", "astroid", "2", "7", "0", "release", "date", "2020", "04", "01", "expected_beginning", "astroid", "s", "changelog", "what", "s", "new", "in", "astroid", "3", "1", "0", "release", "date", "tba", "what", "s", "new", "in", "astroid", "3", "0", "1", "release", "date", "tba", "what", "s", "new", "in", "astroid", "3", "0", "0", "release", "date", "20", "new_content", "transform_content", "old_content", "3", "0", "0", "assert", "new_content", "len", "expected_beginning", "expected_beginning"], "doc_len": 99}
{"doc_id": "tests/resources.py::find", "file_path": "tests/resources.py", "class_name": null, "func_name": "find", "text": "文件路径: tests/resources.py\ndef find(name: str) -> str:\n    return os.path.normpath(os.path.join(os.path.dirname(__file__), DATA_DIR, name))\n", "tokens": ["tests", "resources", "py", "def", "find", "name", "str", "str", "return", "os", "path", "normpath", "os", "path", "join", "os", "path", "dirname", "__file__", "data_dir", "name"], "doc_len": 21}
{"doc_id": "tests/resources.py::build_file", "file_path": "tests/resources.py", "class_name": null, "func_name": "build_file", "text": "文件路径: tests/resources.py\ndef build_file(path: str, modname: Optional[str] = None) -> Module:\n    return builder.AstroidBuilder().file_build(find(path), modname)\n", "tokens": ["tests", "resources", "py", "def", "build_file", "path", "str", "modname", "optional", "str", "none", "module", "return", "builder", "astroidbuilder", "file_build", "find", "path", "modname"], "doc_len": 19}
{"doc_id": "tests/resources.py::SysPathSetup.setUp", "file_path": "tests/resources.py", "class_name": "SysPathSetup", "func_name": "setUp", "text": "文件路径: tests/resources.py, 类名: SysPathSetup\n    def setUp(self) -> None:\n        sys.path.insert(0, find(\"\"))\n", "tokens": ["tests", "resources", "py", "syspathsetup", "def", "setup", "self", "none", "sys", "path", "insert", "0", "find"], "doc_len": 13}
{"doc_id": "tests/resources.py::SysPathSetup.tearDown", "file_path": "tests/resources.py", "class_name": "SysPathSetup", "func_name": "tearDown", "text": "文件路径: tests/resources.py, 类名: SysPathSetup\n    def tearDown(self) -> None:\n        del sys.path[0]\n        datadir = find(\"\")\n        for key in list(sys.path_importer_cache):\n            if key.startswith(datadir):\n                del sys.path_importer_cache[key]\n", "tokens": ["tests", "resources", "py", "syspathsetup", "def", "teardown", "self", "none", "del", "sys", "path", "0", "datadir", "find", "for", "key", "in", "list", "sys", "path_importer_cache", "if", "key", "startswith", "datadir", "del", "sys", "path_importer_cache", "key"], "doc_len": 28}
{"doc_id": "tests/resources.py::AstroidCacheSetupMixin.setup_class", "file_path": "tests/resources.py", "class_name": "AstroidCacheSetupMixin", "func_name": "setup_class", "text": "文件路径: tests/resources.py, 类名: AstroidCacheSetupMixin\n    def setup_class(cls):\n        cls._builtins = AstroidManager().astroid_cache.get(\"builtins\")\n", "tokens": ["tests", "resources", "py", "astroidcachesetupmixin", "def", "setup_class", "cls", "cls", "_builtins", "astroidmanager", "astroid_cache", "get", "builtins"], "doc_len": 13}
{"doc_id": "tests/resources.py::AstroidCacheSetupMixin.teardown_class", "file_path": "tests/resources.py", "class_name": "AstroidCacheSetupMixin", "func_name": "teardown_class", "text": "文件路径: tests/resources.py, 类名: AstroidCacheSetupMixin\n    def teardown_class(cls):\n        if cls._builtins:\n            AstroidManager().astroid_cache[\"builtins\"] = cls._builtins\n", "tokens": ["tests", "resources", "py", "astroidcachesetupmixin", "def", "teardown_class", "cls", "if", "cls", "_builtins", "astroidmanager", "astroid_cache", "builtins", "cls", "_builtins"], "doc_len": 15}
{"doc_id": "tests/unittest_brain.py::assertEqualMro", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "assertEqualMro", "text": "文件路径: tests/unittest_brain.py\ndef assertEqualMro(klass: ClassDef, expected_mro: List[str]) -> None:\n    \"\"\"Check mro names.\"\"\"\n    assert [member.qname() for member in klass.mro()] == expected_mro\n", "tokens": ["tests", "unittest_brain", "py", "def", "assertequalmro", "klass", "classdef", "expected_mro", "list", "str", "none", "check", "mro", "names", "assert", "member", "qname", "for", "member", "in", "klass", "mro", "expected_mro"], "doc_len": 23}
{"doc_id": "tests/unittest_brain.py::HashlibTest._assert_hashlib_class", "file_path": "tests/unittest_brain.py", "class_name": "HashlibTest", "func_name": "_assert_hashlib_class", "text": "文件路径: tests/unittest_brain.py, 类名: HashlibTest\n    def _assert_hashlib_class(self, class_obj: ClassDef) -> None:\n        self.assertIn(\"update\", class_obj)\n        self.assertIn(\"digest\", class_obj)\n        self.assertIn(\"hexdigest\", class_obj)\n        self.assertIn(\"block_size\", class_obj)\n        self.assertIn(\"digest_size\", class_obj)\n        self.assertEqual(len(class_obj[\"__init__\"].args.args), 2)\n        self.assertEqual(len(class_obj[\"__init__\"].args.defaults), 1)\n        self.assertEqual(len(class_obj[\"update\"].args.args), 2)\n        self.assertEqual(len(class_obj[\"digest\"].args.args), 1)\n        self.assertEqual(len(class_obj[\"hexdigest\"].args.args), 1)\n", "tokens": ["tests", "unittest_brain", "py", "hashlibtest", "def", "_assert_hashlib_class", "self", "class_obj", "classdef", "none", "self", "assertin", "update", "class_obj", "self", "assertin", "digest", "class_obj", "self", "assertin", "hexdigest", "class_obj", "self", "assertin", "block_size", "class_obj", "self", "assertin", "digest_size", "class_obj", "self", "assertequal", "len", "class_obj", "__init__", "args", "args", "2", "self", "assertequal", "len", "class_obj", "__init__", "args", "defaults", "1", "self", "assertequal", "len", "class_obj", "update", "args", "args", "2", "self", "assertequal", "len", "class_obj", "digest", "args", "args", "1", "self", "assertequal", "len", "class_obj", "hexdigest", "args", "args", "1"], "doc_len": 70}
{"doc_id": "tests/unittest_brain.py::HashlibTest.test_hashlib", "file_path": "tests/unittest_brain.py", "class_name": "HashlibTest", "func_name": "test_hashlib", "text": "文件路径: tests/unittest_brain.py, 类名: HashlibTest\n    def test_hashlib(self) -> None:\n        \"\"\"Tests that brain extensions for hashlib work.\"\"\"\n        hashlib_module = MANAGER.ast_from_module_name(\"hashlib\")\n        for class_name in (\"md5\", \"sha1\"):\n            class_obj = hashlib_module[class_name]\n            self._assert_hashlib_class(class_obj)\n", "tokens": ["tests", "unittest_brain", "py", "hashlibtest", "def", "test_hashlib", "self", "none", "tests", "that", "brain", "extensions", "for", "hashlib", "work", "hashlib_module", "manager", "ast_from_module_name", "hashlib", "for", "class_name", "in", "md5", "sha1", "class_obj", "hashlib_module", "class_name", "self", "_assert_hashlib_class", "class_obj"], "doc_len": 30}
{"doc_id": "tests/unittest_brain.py::HashlibTest.test_hashlib_py36", "file_path": "tests/unittest_brain.py", "class_name": "HashlibTest", "func_name": "test_hashlib_py36", "text": "文件路径: tests/unittest_brain.py, 类名: HashlibTest\n    def test_hashlib_py36(self) -> None:\n        hashlib_module = MANAGER.ast_from_module_name(\"hashlib\")\n        for class_name in (\"sha3_224\", \"sha3_512\", \"shake_128\"):\n            class_obj = hashlib_module[class_name]\n            self._assert_hashlib_class(class_obj)\n        for class_name in (\"blake2b\", \"blake2s\"):\n            class_obj = hashlib_module[class_name]\n            self.assertEqual(len(class_obj[\"__init__\"].args.args), 2)\n", "tokens": ["tests", "unittest_brain", "py", "hashlibtest", "def", "test_hashlib_py36", "self", "none", "hashlib_module", "manager", "ast_from_module_name", "hashlib", "for", "class_name", "in", "sha3_224", "sha3_512", "shake_128", "class_obj", "hashlib_module", "class_name", "self", "_assert_hashlib_class", "class_obj", "for", "class_name", "in", "blake2b", "blake2s", "class_obj", "hashlib_module", "class_name", "self", "assertequal", "len", "class_obj", "__init__", "args", "args", "2"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::CollectionsDequeTests._inferred_queue_instance", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsDequeTests", "func_name": "_inferred_queue_instance", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsDequeTests\n    def _inferred_queue_instance(self) -> Instance:\n        node = builder.extract_node(\n            \"\"\"\n        import collections\n        q = collections.deque([])\n        q\n        \"\"\"\n        )\n        return next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "collectionsdequetests", "def", "_inferred_queue_instance", "self", "instance", "node", "builder", "extract_node", "import", "collections", "q", "collections", "deque", "q", "return", "next", "node", "infer"], "doc_len": 21}
{"doc_id": "tests/unittest_brain.py::CollectionsDequeTests.test_deque", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsDequeTests", "func_name": "test_deque", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsDequeTests\n    def test_deque(self) -> None:\n        inferred = self._inferred_queue_instance()\n        self.assertTrue(inferred.getattr(\"__len__\"))\n", "tokens": ["tests", "unittest_brain", "py", "collectionsdequetests", "def", "test_deque", "self", "none", "inferred", "self", "_inferred_queue_instance", "self", "asserttrue", "inferred", "getattr", "__len__"], "doc_len": 16}
{"doc_id": "tests/unittest_brain.py::CollectionsDequeTests.test_deque_py35methods", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsDequeTests", "func_name": "test_deque_py35methods", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsDequeTests\n    def test_deque_py35methods(self) -> None:\n        inferred = self._inferred_queue_instance()\n        self.assertIn(\"copy\", inferred.locals)\n        self.assertIn(\"insert\", inferred.locals)\n        self.assertIn(\"index\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "collectionsdequetests", "def", "test_deque_py35methods", "self", "none", "inferred", "self", "_inferred_queue_instance", "self", "assertin", "copy", "inferred", "locals", "self", "assertin", "insert", "inferred", "locals", "self", "assertin", "index", "inferred", "locals"], "doc_len": 26}
{"doc_id": "tests/unittest_brain.py::CollectionsDequeTests.test_deque_not_py39methods", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsDequeTests", "func_name": "test_deque_not_py39methods", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsDequeTests\n    def test_deque_not_py39methods(self):\n        inferred = self._inferred_queue_instance()\n        with self.assertRaises(AttributeInferenceError):\n            inferred.getattr(\"__class_getitem__\")\n", "tokens": ["tests", "unittest_brain", "py", "collectionsdequetests", "def", "test_deque_not_py39methods", "self", "inferred", "self", "_inferred_queue_instance", "with", "self", "assertraises", "attributeinferenceerror", "inferred", "getattr", "__class_getitem__"], "doc_len": 17}
{"doc_id": "tests/unittest_brain.py::CollectionsDequeTests.test_deque_py39methods", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsDequeTests", "func_name": "test_deque_py39methods", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsDequeTests\n    def test_deque_py39methods(self):\n        inferred = self._inferred_queue_instance()\n        self.assertTrue(inferred.getattr(\"__class_getitem__\"))\n", "tokens": ["tests", "unittest_brain", "py", "collectionsdequetests", "def", "test_deque_py39methods", "self", "inferred", "self", "_inferred_queue_instance", "self", "asserttrue", "inferred", "getattr", "__class_getitem__"], "doc_len": 15}
{"doc_id": "tests/unittest_brain.py::OrderedDictTest._inferred_ordered_dict_instance", "file_path": "tests/unittest_brain.py", "class_name": "OrderedDictTest", "func_name": "_inferred_ordered_dict_instance", "text": "文件路径: tests/unittest_brain.py, 类名: OrderedDictTest\n    def _inferred_ordered_dict_instance(self) -> Instance:\n        node = builder.extract_node(\n            \"\"\"\n        import collections\n        d = collections.OrderedDict()\n        d\n        \"\"\"\n        )\n        return next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "ordereddicttest", "def", "_inferred_ordered_dict_instance", "self", "instance", "node", "builder", "extract_node", "import", "collections", "d", "collections", "ordereddict", "d", "return", "next", "node", "infer"], "doc_len": 21}
{"doc_id": "tests/unittest_brain.py::OrderedDictTest.test_ordered_dict_py34method", "file_path": "tests/unittest_brain.py", "class_name": "OrderedDictTest", "func_name": "test_ordered_dict_py34method", "text": "文件路径: tests/unittest_brain.py, 类名: OrderedDictTest\n    def test_ordered_dict_py34method(self) -> None:\n        inferred = self._inferred_ordered_dict_instance()\n        self.assertIn(\"move_to_end\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "ordereddicttest", "def", "test_ordered_dict_py34method", "self", "none", "inferred", "self", "_inferred_ordered_dict_instance", "self", "assertin", "move_to_end", "inferred", "locals"], "doc_len": 16}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_base", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_base", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_base(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n\n        class X(namedtuple(\"X\", [\"a\", \"b\", \"c\"])):\n           pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        self.assertEqual(\n            [anc.name for anc in klass.ancestors()], [\"X\", \"tuple\", \"object\"]\n        )\n        for anc in klass.ancestors():\n            self.assertFalse(anc.parent is None)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_base", "self", "none", "klass", "builder", "extract_node", "from", "collections", "import", "namedtuple", "class", "x", "namedtuple", "x", "a", "b", "c", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "self", "assertequal", "anc", "name", "for", "anc", "in", "klass", "ancestors", "x", "tuple", "object", "for", "anc", "in", "klass", "ancestors", "self", "assertfalse", "anc", "parent", "is", "none"], "doc_len": 51}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_inference(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n\n        name = \"X\"\n        fields = [\"a\", \"b\", \"c\"]\n        class X(namedtuple(name, fields)):\n           pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        base = next(base for base in klass.ancestors() if base.name == \"X\")\n        self.assertSetEqual({\"a\", \"b\", \"c\"}, set(base.instance_attrs))\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_inference", "self", "none", "klass", "builder", "extract_node", "from", "collections", "import", "namedtuple", "name", "x", "fields", "a", "b", "c", "class", "x", "namedtuple", "name", "fields", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "base", "next", "base", "for", "base", "in", "klass", "ancestors", "if", "base", "name", "x", "self", "assertsetequal", "a", "b", "c", "set", "base", "instance_attrs"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_inference_failure", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_inference_failure", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_inference_failure(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n\n        def foo(fields):\n           return __(namedtuple(\"foo\", fields))\n        \"\"\"\n        )\n        self.assertIs(util.Uninferable, next(klass.infer()))\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_inference_failure", "self", "none", "klass", "builder", "extract_node", "from", "collections", "import", "namedtuple", "def", "foo", "fields", "return", "__", "namedtuple", "foo", "fields", "self", "assertis", "util", "uninferable", "next", "klass", "infer"], "doc_len": 30}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_advanced_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_advanced_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_advanced_inference(self) -> None:\n        # urlparse return an object of class ParseResult, which has a\n        # namedtuple call and a mixin as base classes\n        result = builder.extract_node(\n            \"\"\"\n        from urllib.parse import urlparse\n\n        result = __(urlparse('gopher://'))\n        \"\"\"\n        )\n        instance = next(result.infer())\n        self.assertGreaterEqual(len(instance.getattr(\"scheme\")), 1)\n        self.assertGreaterEqual(len(instance.getattr(\"port\")), 1)\n        with self.assertRaises(AttributeInferenceError):\n            instance.getattr(\"foo\")\n        self.assertGreaterEqual(len(instance.getattr(\"geturl\")), 1)\n        self.assertEqual(instance.name, \"ParseResult\")\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_advanced_inference", "self", "none", "urlparse", "return", "an", "object", "of", "class", "parseresult", "which", "has", "a", "namedtuple", "call", "and", "a", "mixin", "as", "base", "classes", "result", "builder", "extract_node", "from", "urllib", "parse", "import", "urlparse", "result", "__", "urlparse", "gopher", "instance", "next", "result", "infer", "self", "assertgreaterequal", "len", "instance", "getattr", "scheme", "1", "self", "assertgreaterequal", "len", "instance", "getattr", "port", "1", "with", "self", "assertraises", "attributeinferenceerror", "instance", "getattr", "foo", "self", "assertgreaterequal", "len", "instance", "getattr", "geturl", "1", "self", "assertequal", "instance", "name", "parseresult"], "doc_len": 75}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_instance_attrs", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_instance_attrs", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_instance_attrs(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        namedtuple('a', 'a b c')(1, 2, 3) #@\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        for name, attr in inferred.instance_attrs.items():\n            self.assertEqual(attr[0].attrname, name)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_instance_attrs", "self", "none", "result", "builder", "extract_node", "from", "collections", "import", "namedtuple", "namedtuple", "a", "a", "b", "c", "1", "2", "3", "inferred", "next", "result", "infer", "for", "name", "attr", "in", "inferred", "instance_attrs", "items", "self", "assertequal", "attr", "0", "attrname", "name"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_uninferable_fields", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_uninferable_fields", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_uninferable_fields(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        x = [A] * 2\n        from collections import namedtuple\n        l = namedtuple('a', x)\n        l(1)\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_uninferable_fields", "self", "none", "node", "builder", "extract_node", "x", "a", "2", "from", "collections", "import", "namedtuple", "l", "namedtuple", "a", "x", "l", "1", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred"], "doc_len": 33}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_access_class_fields", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_access_class_fields", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_access_class_fields(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"field other\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIn(\"field\", inferred.locals)\n        self.assertIn(\"other\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_access_class_fields", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "field", "other", "tuple", "inferred", "next", "node", "infer", "self", "assertin", "field", "inferred", "locals", "self", "assertin", "other", "inferred", "locals"], "doc_len": 35}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_rename_keywords", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_rename_keywords", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_rename_keywords(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"abc def\", rename=True)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIn(\"abc\", inferred.locals)\n        self.assertIn(\"_1\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_rename_keywords", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "abc", "def", "rename", "true", "tuple", "inferred", "next", "node", "infer", "self", "assertin", "abc", "inferred", "locals", "self", "assertin", "_1", "inferred", "locals"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_rename_duplicates", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_rename_duplicates", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_rename_duplicates(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"abc abc abc\", rename=True)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIn(\"abc\", inferred.locals)\n        self.assertIn(\"_1\", inferred.locals)\n        self.assertIn(\"_2\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_rename_duplicates", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "abc", "abc", "abc", "rename", "true", "tuple", "inferred", "next", "node", "infer", "self", "assertin", "abc", "inferred", "locals", "self", "assertin", "_1", "inferred", "locals", "self", "assertin", "_2", "inferred", "locals"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_rename_uninferable", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_rename_uninferable", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_rename_uninferable(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"a b c\", rename=UNINFERABLE)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIn(\"a\", inferred.locals)\n        self.assertIn(\"b\", inferred.locals)\n        self.assertIn(\"c\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_rename_uninferable", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "a", "b", "c", "rename", "uninferable", "tuple", "inferred", "next", "node", "infer", "self", "assertin", "a", "inferred", "locals", "self", "assertin", "b", "inferred", "locals", "self", "assertin", "c", "inferred", "locals"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_func_form", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_func_form", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_func_form(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(typename=\"Tuple\", field_names=\"a b c\", rename=UNINFERABLE)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred.name, \"Tuple\")\n        self.assertIn(\"a\", inferred.locals)\n        self.assertIn(\"b\", inferred.locals)\n        self.assertIn(\"c\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_func_form", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "typename", "tuple", "field_names", "a", "b", "c", "rename", "uninferable", "tuple", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "name", "tuple", "self", "assertin", "a", "inferred", "locals", "self", "assertin", "b", "inferred", "locals", "self", "assertin", "c", "inferred", "locals"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_func_form_args_and_kwargs", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_func_form_args_and_kwargs", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_func_form_args_and_kwargs(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", field_names=\"a b c\", rename=UNINFERABLE)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred.name, \"Tuple\")\n        self.assertIn(\"a\", inferred.locals)\n        self.assertIn(\"b\", inferred.locals)\n        self.assertIn(\"c\", inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_func_form_args_and_kwargs", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "field_names", "a", "b", "c", "rename", "uninferable", "tuple", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "name", "tuple", "self", "assertin", "a", "inferred", "locals", "self", "assertin", "b", "inferred", "locals", "self", "assertin", "c", "inferred", "locals"], "doc_len": 49}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_namedtuple_bases_are_actually_names_not_nodes", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_namedtuple_bases_are_actually_names_not_nodes", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_namedtuple_bases_are_actually_names_not_nodes(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", field_names=\"a b c\", rename=UNINFERABLE)\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, astroid.ClassDef)\n        self.assertIsInstance(inferred.bases[0], astroid.Name)\n        self.assertEqual(inferred.bases[0].name, \"tuple\")\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_namedtuple_bases_are_actually_names_not_nodes", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "field_names", "a", "b", "c", "rename", "uninferable", "tuple", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "classdef", "self", "assertisinstance", "inferred", "bases", "0", "astroid", "name", "self", "assertequal", "inferred", "bases", "0", "name", "tuple"], "doc_len": 48}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_invalid_label_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_invalid_label_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_invalid_label_does_not_crash_inference(self) -> None:\n        code = \"\"\"\n        import collections\n        a = collections.namedtuple( 'a', ['b c'] )\n        a\n        \"\"\"\n        node = builder.extract_node(code)\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.ClassDef)\n        assert \"b\" not in inferred.locals\n        assert \"c\" not in inferred.locals\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_invalid_label_does_not_crash_inference", "self", "none", "code", "import", "collections", "a", "collections", "namedtuple", "a", "b", "c", "a", "node", "builder", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "classdef", "assert", "b", "not", "in", "inferred", "locals", "assert", "c", "not", "in", "inferred", "locals"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_no_rename_duplicates_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_no_rename_duplicates_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_no_rename_duplicates_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"abc abc\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_no_rename_duplicates_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "abc", "abc", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 33}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_no_rename_keywords_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_no_rename_keywords_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_no_rename_keywords_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"abc def\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_no_rename_keywords_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "abc", "def", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 33}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_no_rename_nonident_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_no_rename_nonident_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_no_rename_nonident_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"123 456\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_no_rename_nonident_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "123", "456", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 33}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_no_rename_underscore_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_no_rename_underscore_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_no_rename_underscore_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", \"_1\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_no_rename_underscore_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "_1", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_invalid_typename_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_invalid_typename_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_invalid_typename_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"123\", \"abc\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_invalid_typename_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "123", "abc", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_keyword_typename_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_keyword_typename_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_keyword_typename_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"while\", \"abc\")\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)  # would raise ValueError\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_keyword_typename_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "while", "abc", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred", "would", "raise", "valueerror"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_typeerror_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_typeerror_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_typeerror_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        Tuple = namedtuple(\"Tuple\", [123, 456])\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        # namedtuple converts all arguments to strings so these should be too\n        # and catch on the isidentifier() check\n        self.assertIs(util.Uninferable, inferred)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_typeerror_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "tuple", "namedtuple", "tuple", "123", "456", "tuple", "inferred", "next", "node", "infer", "namedtuple", "converts", "all", "arguments", "to", "strings", "so", "these", "should", "be", "too", "and", "catch", "on", "the", "isidentifier", "check", "self", "assertis", "util", "uninferable", "inferred"], "doc_len": 47}
{"doc_id": "tests/unittest_brain.py::NamedTupleTest.test_pathological_str_does_not_crash_inference", "file_path": "tests/unittest_brain.py", "class_name": "NamedTupleTest", "func_name": "test_pathological_str_does_not_crash_inference", "text": "文件路径: tests/unittest_brain.py, 类名: NamedTupleTest\n    def test_pathological_str_does_not_crash_inference(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import namedtuple\n        class Invalid:\n            def __str__(self):\n                return 123  # will raise TypeError\n        Tuple = namedtuple(\"Tuple\", [Invalid()])\n        Tuple #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)\n", "tokens": ["tests", "unittest_brain", "py", "namedtupletest", "def", "test_pathological_str_does_not_crash_inference", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "namedtuple", "class", "invalid", "def", "__str__", "self", "return", "123", "will", "raise", "typeerror", "tuple", "namedtuple", "tuple", "invalid", "tuple", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred"], "doc_len": 39}
{"doc_id": "tests/unittest_brain.py::DefaultDictTest.test_1", "file_path": "tests/unittest_brain.py", "class_name": "DefaultDictTest", "func_name": "test_1", "text": "文件路径: tests/unittest_brain.py, 类名: DefaultDictTest\n    def test_1(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from collections import defaultdict\n\n        X = defaultdict(int)\n        X[0]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(util.Uninferable, inferred)\n", "tokens": ["tests", "unittest_brain", "py", "defaultdicttest", "def", "test_1", "self", "none", "node", "builder", "extract_node", "from", "collections", "import", "defaultdict", "x", "defaultdict", "int", "x", "0", "inferred", "next", "node", "infer", "self", "assertis", "util", "uninferable", "inferred"], "doc_len": 29}
{"doc_id": "tests/unittest_brain.py::ModuleExtenderTest.test_extension_modules", "file_path": "tests/unittest_brain.py", "class_name": "ModuleExtenderTest", "func_name": "test_extension_modules", "text": "文件路径: tests/unittest_brain.py, 类名: ModuleExtenderTest\n    def test_extension_modules(self) -> None:\n        transformer = MANAGER._transform\n        for extender, _ in transformer.transforms[nodes.Module]:\n            n = nodes.Module(\"__main__\", None)\n            extender(n)\n", "tokens": ["tests", "unittest_brain", "py", "moduleextendertest", "def", "test_extension_modules", "self", "none", "transformer", "manager", "_transform", "for", "extender", "_", "in", "transformer", "transforms", "nodes", "module", "n", "nodes", "module", "__main__", "none", "extender", "n"], "doc_len": 26}
{"doc_id": "tests/unittest_brain.py::NoseBrainTest.test_nose_tools", "file_path": "tests/unittest_brain.py", "class_name": "NoseBrainTest", "func_name": "test_nose_tools", "text": "文件路径: tests/unittest_brain.py, 类名: NoseBrainTest\n    def test_nose_tools(self):\n        methods = builder.extract_node(\n            \"\"\"\n        from nose.tools import assert_equal\n        from nose.tools import assert_equals\n        from nose.tools import assert_true\n        assert_equal = assert_equal #@\n        assert_true = assert_true #@\n        assert_equals = assert_equals #@\n        \"\"\"\n        )\n        assert isinstance(methods, list)\n        assert_equal = next(methods[0].value.infer())\n        assert_true = next(methods[1].value.infer())\n        assert_equals = next(methods[2].value.infer())\n\n        self.assertIsInstance(assert_equal, astroid.BoundMethod)\n        self.assertIsInstance(assert_true, astroid.BoundMethod)\n        self.assertIsInstance(assert_equals, astroid.BoundMethod)\n        self.assertEqual(assert_equal.qname(), \"unittest.case.TestCase.assertEqual\")\n        self.assertEqual(assert_true.qname(), \"unittest.case.TestCase.assertTrue\")\n        self.assertEqual(assert_equals.qname(), \"unittest.case.TestCase.assertEqual\")\n", "tokens": ["tests", "unittest_brain", "py", "nosebraintest", "def", "test_nose_tools", "self", "methods", "builder", "extract_node", "from", "nose", "tools", "import", "assert_equal", "from", "nose", "tools", "import", "assert_equals", "from", "nose", "tools", "import", "assert_true", "assert_equal", "assert_equal", "assert_true", "assert_true", "assert_equals", "assert_equals", "assert", "isinstance", "methods", "list", "assert_equal", "next", "methods", "0", "value", "infer", "assert_true", "next", "methods", "1", "value", "infer", "assert_equals", "next", "methods", "2", "value", "infer", "self", "assertisinstance", "assert_equal", "astroid", "boundmethod", "self", "assertisinstance", "assert_true", "astroid", "boundmethod", "self", "assertisinstance", "assert_equals", "astroid", "boundmethod", "self", "assertequal", "assert_equal", "qname", "unittest", "case", "testcase", "assertequal", "self", "assertequal", "assert_true", "qname", "unittest", "case", "testcase", "asserttrue", "self", "assertequal", "assert_equals", "qname", "unittest", "case", "testcase", "assertequal"], "doc_len": 92}
{"doc_id": "tests/unittest_brain.py::SixBrainTest.test_attribute_access", "file_path": "tests/unittest_brain.py", "class_name": "SixBrainTest", "func_name": "test_attribute_access", "text": "文件路径: tests/unittest_brain.py, 类名: SixBrainTest\n    def test_attribute_access(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        import six\n        six.moves.http_client #@\n        six.moves.urllib_parse #@\n        six.moves.urllib_error #@\n        six.moves.urllib.request #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        http_client = next(ast_nodes[0].infer())\n        self.assertIsInstance(http_client, nodes.Module)\n        self.assertEqual(http_client.name, \"http.client\")\n\n        urllib_parse = next(ast_nodes[1].infer())\n        self.assertIsInstance(urllib_parse, nodes.Module)\n        self.assertEqual(urllib_parse.name, \"urllib.parse\")\n        urljoin = next(urllib_parse.igetattr(\"urljoin\"))\n        urlencode = next(urllib_parse.igetattr(\"urlencode\"))\n        self.assertIsInstance(urljoin, nodes.FunctionDef)\n        self.assertEqual(urljoin.qname(), \"urllib.parse.urljoin\")\n        self.assertIsInstance(urlencode, nodes.FunctionDef)\n        self.assertEqual(urlencode.qname(), \"urllib.parse.urlencode\")\n\n        urllib_error = next(ast_nodes[2].infer())\n        self.assertIsInstance(urllib_error, nodes.Module)\n        self.assertEqual(urllib_error.name, \"urllib.error\")\n        urlerror = next(urllib_error.igetattr(\"URLError\"))\n        self.assertIsInstance(urlerror, nodes.ClassDef)\n        content_too_short = next(urllib_error.igetattr(\"ContentTooShortError\"))\n        self.assertIsInstance(content_too_short, nodes.ClassDef)\n\n        urllib_request = next(ast_nodes[3].infer())\n        self.assertIsInstance(urllib_request, nodes.Module)\n        self.assertEqual(urllib_request.name, \"urllib.request\")\n        urlopen = next(urllib_request.igetattr(\"urlopen\"))\n        urlretrieve = next(urllib_request.igetattr(\"urlretrieve\"))\n        self.assertIsInstance(urlopen, nodes.FunctionDef)\n        self.assertEqual(urlopen.qname(), \"urllib.request.urlopen\")\n        self.assertIsInstance(urlretrieve, nodes.FunctionDef)\n        self.assertEqual(urlretrieve.qname(), \"urllib.request.urlretrieve\")\n", "tokens": ["tests", "unittest_brain", "py", "sixbraintest", "def", "test_attribute_access", "self", "none", "ast_nodes", "builder", "extract_node", "import", "six", "six", "moves", "http_client", "six", "moves", "urllib_parse", "six", "moves", "urllib_error", "six", "moves", "urllib", "request", "assert", "isinstance", "ast_nodes", "list", "http_client", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "http_client", "nodes", "module", "self", "assertequal", "http_client", "name", "http", "client", "urllib_parse", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "urllib_parse", "nodes", "module", "self", "assertequal", "urllib_parse", "name", "urllib", "parse", "urljoin", "next", "urllib_parse", "igetattr", "urljoin", "urlencode", "next", "urllib_parse", "igetattr", "urlencode", "self", "assertisinstance", "urljoin", "nodes", "functiondef", "self", "assertequal", "urljoin", "qname", "urllib", "parse", "urljoin", "self", "assertisinstance", "urlencode", "nodes", "functiondef", "self", "assertequal", "urlencode", "qname", "urllib", "parse", "urlencode", "urllib_error", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "urllib_error", "nodes", "module", "self", "assertequal", "urllib_error", "name", "urllib", "error", "urlerror", "next", "urllib_error", "igetattr", "urlerror", "self", "assertisinstance", "urlerror", "nodes", "classdef", "content_too_short", "next", "urllib_error", "igetattr", "contenttooshorterror", "self", "assertisinstance", "content_too_short", "nodes", "classdef", "urllib_request", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "urllib_request", "nodes", "module", "self", "assertequal", "urllib_request", "name", "urllib", "request", "urlopen", "next", "urllib_request", "igetattr", "urlopen", "urlretrieve", "next", "urllib_request", "igetattr", "urlretrieve", "self", "assertisinstance", "urlopen", "nodes", "functiondef", "self", "assertequal", "urlopen", "qname", "urllib", "request", "urlopen", "self", "assertisinstance", "urlretrieve", "nodes", "functiondef", "self", "assertequal", "urlretrieve", "qname", "urllib", "request", "urlretrieve"], "doc_len": 182}
{"doc_id": "tests/unittest_brain.py::SixBrainTest.test_from_imports", "file_path": "tests/unittest_brain.py", "class_name": "SixBrainTest", "func_name": "test_from_imports", "text": "文件路径: tests/unittest_brain.py, 类名: SixBrainTest\n    def test_from_imports(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        from six.moves import http_client\n        http_client.HTTPSConnection #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        qname = \"http.client.HTTPSConnection\"\n        self.assertEqual(inferred.qname(), qname)\n", "tokens": ["tests", "unittest_brain", "py", "sixbraintest", "def", "test_from_imports", "self", "none", "ast_node", "builder", "extract_node", "from", "six", "moves", "import", "http_client", "http_client", "httpsconnection", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "qname", "http", "client", "httpsconnection", "self", "assertequal", "inferred", "qname", "qname"], "doc_len": 36}
{"doc_id": "tests/unittest_brain.py::SixBrainTest.test_from_submodule_imports", "file_path": "tests/unittest_brain.py", "class_name": "SixBrainTest", "func_name": "test_from_submodule_imports", "text": "文件路径: tests/unittest_brain.py, 类名: SixBrainTest\n    def test_from_submodule_imports(self) -> None:\n        \"\"\"Make sure ulrlib submodules can be imported from\n\n        See PyCQA/pylint#1640 for relevant issue\n        \"\"\"\n        ast_node = builder.extract_node(\n            \"\"\"\n        from six.moves.urllib.parse import urlparse\n        urlparse #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "sixbraintest", "def", "test_from_submodule_imports", "self", "none", "make", "sure", "ulrlib", "submodules", "can", "be", "imported", "from", "see", "pycqa", "pylint", "1640", "for", "relevant", "issue", "ast_node", "builder", "extract_node", "from", "six", "moves", "urllib", "parse", "import", "urlparse", "urlparse", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "functiondef"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::SixBrainTest.test_with_metaclass_subclasses_inheritance", "file_path": "tests/unittest_brain.py", "class_name": "SixBrainTest", "func_name": "test_with_metaclass_subclasses_inheritance", "text": "文件路径: tests/unittest_brain.py, 类名: SixBrainTest\n    def test_with_metaclass_subclasses_inheritance(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class A(type):\n            def test(cls):\n                return cls\n\n        class C:\n            pass\n\n        import six\n        class B(six.with_metaclass(A, C)):\n            pass\n\n        B #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"B\")\n        self.assertIsInstance(inferred.bases[0], nodes.Call)\n        ancestors = tuple(inferred.ancestors())\n        self.assertIsInstance(ancestors[0], nodes.ClassDef)\n        self.assertEqual(ancestors[0].name, \"C\")\n        self.assertIsInstance(ancestors[1], nodes.ClassDef)\n        self.assertEqual(ancestors[1].name, \"object\")\n", "tokens": ["tests", "unittest_brain", "py", "sixbraintest", "def", "test_with_metaclass_subclasses_inheritance", "self", "none", "ast_node", "builder", "extract_node", "class", "a", "type", "def", "test", "cls", "return", "cls", "class", "c", "pass", "import", "six", "class", "b", "six", "with_metaclass", "a", "c", "pass", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "b", "self", "assertisinstance", "inferred", "bases", "0", "nodes", "call", "ancestors", "tuple", "inferred", "ancestors", "self", "assertisinstance", "ancestors", "0", "nodes", "classdef", "self", "assertequal", "ancestors", "0", "name", "c", "self", "assertisinstance", "ancestors", "1", "nodes", "classdef", "self", "assertequal", "ancestors", "1", "name", "object"], "doc_len": 81}
{"doc_id": "tests/unittest_brain.py::SixBrainTest.test_six_with_metaclass_with_additional_transform", "file_path": "tests/unittest_brain.py", "class_name": "SixBrainTest", "func_name": "test_six_with_metaclass_with_additional_transform", "text": "文件路径: tests/unittest_brain.py, 类名: SixBrainTest\n    def test_six_with_metaclass_with_additional_transform(self) -> None:\n        def transform_class(cls: Any) -> ClassDef:\n            if cls.name == \"A\":\n                cls._test_transform = 314\n            return cls\n\n        MANAGER.register_transform(nodes.ClassDef, transform_class)\n        try:\n            ast_node = builder.extract_node(\n                \"\"\"\n                import six\n                class A(six.with_metaclass(type, object)):\n                    pass\n\n                A #@\n            \"\"\"\n            )\n            inferred = next(ast_node.infer())\n            assert getattr(inferred, \"_test_transform\", None) == 314\n        finally:\n            MANAGER.unregister_transform(nodes.ClassDef, transform_class)\n", "tokens": ["tests", "unittest_brain", "py", "sixbraintest", "def", "test_six_with_metaclass_with_additional_transform", "self", "none", "def", "transform_class", "cls", "any", "classdef", "if", "cls", "name", "a", "cls", "_test_transform", "314", "return", "cls", "manager", "register_transform", "nodes", "classdef", "transform_class", "try", "ast_node", "builder", "extract_node", "import", "six", "class", "a", "six", "with_metaclass", "type", "object", "pass", "a", "inferred", "next", "ast_node", "infer", "assert", "getattr", "inferred", "_test_transform", "none", "314", "finally", "manager", "unregister_transform", "nodes", "classdef", "transform_class"], "doc_len": 57}
{"doc_id": "tests/unittest_brain.py::MultiprocessingBrainTest.test_multiprocessing_module_attributes", "file_path": "tests/unittest_brain.py", "class_name": "MultiprocessingBrainTest", "func_name": "test_multiprocessing_module_attributes", "text": "文件路径: tests/unittest_brain.py, 类名: MultiprocessingBrainTest\n    def test_multiprocessing_module_attributes(self) -> None:\n        # Test that module attributes are working,\n        # especially on Python 3.4+, where they are obtained\n        # from a context.\n        module = builder.extract_node(\n            \"\"\"\n        import multiprocessing\n        \"\"\"\n        )\n        assert isinstance(module, nodes.Import)\n        module = module.do_import_module(\"multiprocessing\")\n        cpu_count = next(module.igetattr(\"cpu_count\"))\n        self.assertIsInstance(cpu_count, astroid.BoundMethod)\n", "tokens": ["tests", "unittest_brain", "py", "multiprocessingbraintest", "def", "test_multiprocessing_module_attributes", "self", "none", "test", "that", "module", "attributes", "are", "working", "especially", "on", "python", "3", "4", "where", "they", "are", "obtained", "from", "a", "context", "module", "builder", "extract_node", "import", "multiprocessing", "assert", "isinstance", "module", "nodes", "import", "module", "module", "do_import_module", "multiprocessing", "cpu_count", "next", "module", "igetattr", "cpu_count", "self", "assertisinstance", "cpu_count", "astroid", "boundmethod"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::MultiprocessingBrainTest.test_module_name", "file_path": "tests/unittest_brain.py", "class_name": "MultiprocessingBrainTest", "func_name": "test_module_name", "text": "文件路径: tests/unittest_brain.py, 类名: MultiprocessingBrainTest\n    def test_module_name(self) -> None:\n        module = builder.extract_node(\n            \"\"\"\n        import multiprocessing\n        multiprocessing.SyncManager()\n        \"\"\"\n        )\n        inferred_sync_mgr = next(module.infer())\n        module = inferred_sync_mgr.root()\n        self.assertEqual(module.name, \"multiprocessing.managers\")\n", "tokens": ["tests", "unittest_brain", "py", "multiprocessingbraintest", "def", "test_module_name", "self", "none", "module", "builder", "extract_node", "import", "multiprocessing", "multiprocessing", "syncmanager", "inferred_sync_mgr", "next", "module", "infer", "module", "inferred_sync_mgr", "root", "self", "assertequal", "module", "name", "multiprocessing", "managers"], "doc_len": 28}
{"doc_id": "tests/unittest_brain.py::MultiprocessingBrainTest.test_multiprocessing_manager", "file_path": "tests/unittest_brain.py", "class_name": "MultiprocessingBrainTest", "func_name": "test_multiprocessing_manager", "text": "文件路径: tests/unittest_brain.py, 类名: MultiprocessingBrainTest\n    def test_multiprocessing_manager(self) -> None:\n        # Test that we have the proper attributes\n        # for a multiprocessing.managers.SyncManager\n        module = builder.parse(\n            \"\"\"\n        import multiprocessing\n        manager = multiprocessing.Manager()\n        queue = manager.Queue()\n        joinable_queue = manager.JoinableQueue()\n        event = manager.Event()\n        rlock = manager.RLock()\n        bounded_semaphore = manager.BoundedSemaphore()\n        condition = manager.Condition()\n        barrier = manager.Barrier()\n        pool = manager.Pool()\n        list = manager.list()\n        dict = manager.dict()\n        value = manager.Value()\n        array = manager.Array()\n        namespace = manager.Namespace()\n        \"\"\"\n        )\n        ast_queue = next(module[\"queue\"].infer())\n        self.assertEqual(ast_queue.qname(), f\"{queue.__name__}.Queue\")\n\n        joinable_queue = next(module[\"joinable_queue\"].infer())\n        self.assertEqual(joinable_queue.qname(), f\"{queue.__name__}.Queue\")\n\n        event = next(module[\"event\"].infer())\n        event_name = \"threading.Event\"\n        self.assertEqual(event.qname(), event_name)\n\n        rlock = next(module[\"rlock\"].infer())\n        rlock_name = \"threading._RLock\"\n        self.assertEqual(rlock.qname(), rlock_name)\n\n        bounded_semaphore = next(module[\"bounded_semaphore\"].infer())\n        semaphore_name = \"threading.BoundedSemaphore\"\n        self.assertEqual(bounded_semaphore.qname(), semaphore_name)\n\n        pool = next(module[\"pool\"].infer())\n        pool_name = \"multiprocessing.pool.Pool\"\n        self.assertEqual(pool.qname(), pool_name)\n\n        for attr in (\"list\", \"dict\"):\n            obj = next(module[attr].infer())\n            self.assertEqual(obj.qname(), f\"builtins.{attr}\")\n\n        # pypy's implementation of array.__spec__ return None. This causes problems for this inference.\n        if not hasattr(sys, \"pypy_version_info\"):\n            array = next(module[\"array\"].infer())\n            self.assertEqual(array.qname(), \"array.array\")\n\n        manager = next(module[\"manager\"].infer())\n        # Verify that we have these attributes\n        self.assertTrue(manager.getattr(\"start\"))\n        self.assertTrue(manager.getattr(\"shutdown\"))\n", "tokens": ["tests", "unittest_brain", "py", "multiprocessingbraintest", "def", "test_multiprocessing_manager", "self", "none", "test", "that", "we", "have", "the", "proper", "attributes", "for", "a", "multiprocessing", "managers", "syncmanager", "module", "builder", "parse", "import", "multiprocessing", "manager", "multiprocessing", "manager", "queue", "manager", "queue", "joinable_queue", "manager", "joinablequeue", "event", "manager", "event", "rlock", "manager", "rlock", "bounded_semaphore", "manager", "boundedsemaphore", "condition", "manager", "condition", "barrier", "manager", "barrier", "pool", "manager", "pool", "list", "manager", "list", "dict", "manager", "dict", "value", "manager", "value", "array", "manager", "array", "namespace", "manager", "namespace", "ast_queue", "next", "module", "queue", "infer", "self", "assertequal", "ast_queue", "qname", "f", "queue", "__name__", "queue", "joinable_queue", "next", "module", "joinable_queue", "infer", "self", "assertequal", "joinable_queue", "qname", "f", "queue", "__name__", "queue", "event", "next", "module", "event", "infer", "event_name", "threading", "event", "self", "assertequal", "event", "qname", "event_name", "rlock", "next", "module", "rlock", "infer", "rlock_name", "threading", "_rlock", "self", "assertequal", "rlock", "qname", "rlock_name", "bounded_semaphore", "next", "module", "bounded_semaphore", "infer", "semaphore_name", "threading", "boundedsemaphore", "self", "assertequal", "bounded_semaphore", "qname", "semaphore_name", "pool", "next", "module", "pool", "infer", "pool_name", "multiprocessing", "pool", "pool", "self", "assertequal", "pool", "qname", "pool_name", "for", "attr", "in", "list", "dict", "obj", "next", "module", "attr", "infer", "self", "assertequal", "obj", "qname", "f", "builtins", "attr", "pypy", "s", "implementation", "of", "array", "__spec__", "return", "none", "this", "causes", "problems", "for", "this", "inference", "if", "not", "hasattr", "sys", "pypy_version_info", "array", "next", "module", "array", "infer", "self", "assertequal", "array", "qname", "array", "array", "manager", "next", "module", "manager", "infer", "verify", "that", "we", "have", "these", "attributes", "self", "asserttrue", "manager", "getattr", "start", "self", "asserttrue", "manager", "getattr", "shutdown"], "doc_len": 214}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest.test_lock", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "test_lock", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def test_lock(self) -> None:\n        lock_instance = builder.extract_node(\n            \"\"\"\n        import threading\n        threading.Lock()\n        \"\"\"\n        )\n        inferred = next(lock_instance.infer())\n        self.assert_is_valid_lock(inferred)\n\n        acquire_method = inferred.getattr(\"acquire\")[0]\n        parameters = [param.name for param in acquire_method.args.args[1:]]\n        assert parameters == [\"blocking\", \"timeout\"]\n\n        assert inferred.getattr(\"locked\")\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "test_lock", "self", "none", "lock_instance", "builder", "extract_node", "import", "threading", "threading", "lock", "inferred", "next", "lock_instance", "infer", "self", "assert_is_valid_lock", "inferred", "acquire_method", "inferred", "getattr", "acquire", "0", "parameters", "param", "name", "for", "param", "in", "acquire_method", "args", "args", "1", "assert", "parameters", "blocking", "timeout", "assert", "inferred", "getattr", "locked"], "doc_len": 45}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest.test_rlock", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "test_rlock", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def test_rlock(self) -> None:\n        self._test_lock_object(\"RLock\")\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "test_rlock", "self", "none", "self", "_test_lock_object", "rlock"], "doc_len": 11}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest.test_semaphore", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "test_semaphore", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def test_semaphore(self) -> None:\n        self._test_lock_object(\"Semaphore\")\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "test_semaphore", "self", "none", "self", "_test_lock_object", "semaphore"], "doc_len": 11}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest.test_boundedsemaphore", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "test_boundedsemaphore", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def test_boundedsemaphore(self) -> None:\n        self._test_lock_object(\"BoundedSemaphore\")\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "test_boundedsemaphore", "self", "none", "self", "_test_lock_object", "boundedsemaphore"], "doc_len": 11}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest._test_lock_object", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "_test_lock_object", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def _test_lock_object(self, object_name: str) -> None:\n        lock_instance = builder.extract_node(\n            f\"\"\"\n        import threading\n        threading.{object_name}()\n        \"\"\"\n        )\n        inferred = next(lock_instance.infer())\n        self.assert_is_valid_lock(inferred)\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "_test_lock_object", "self", "object_name", "str", "none", "lock_instance", "builder", "extract_node", "f", "import", "threading", "threading", "object_name", "inferred", "next", "lock_instance", "infer", "self", "assert_is_valid_lock", "inferred"], "doc_len": 25}
{"doc_id": "tests/unittest_brain.py::ThreadingBrainTest.assert_is_valid_lock", "file_path": "tests/unittest_brain.py", "class_name": "ThreadingBrainTest", "func_name": "assert_is_valid_lock", "text": "文件路径: tests/unittest_brain.py, 类名: ThreadingBrainTest\n    def assert_is_valid_lock(self, inferred: Instance) -> None:\n        self.assertIsInstance(inferred, astroid.Instance)\n        self.assertEqual(inferred.root().name, \"threading\")\n        for method in (\"acquire\", \"release\", \"__enter__\", \"__exit__\"):\n            self.assertIsInstance(next(inferred.igetattr(method)), astroid.BoundMethod)\n", "tokens": ["tests", "unittest_brain", "py", "threadingbraintest", "def", "assert_is_valid_lock", "self", "inferred", "instance", "none", "self", "assertisinstance", "inferred", "astroid", "instance", "self", "assertequal", "inferred", "root", "name", "threading", "for", "method", "in", "acquire", "release", "__enter__", "__exit__", "self", "assertisinstance", "next", "inferred", "igetattr", "method", "astroid", "boundmethod"], "doc_len": 36}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_simple_enum", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_simple_enum", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_simple_enum(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        import enum\n\n        class MyEnum(enum.Enum):\n            one = \"one\"\n            two = \"two\"\n\n            def mymethod(self, x):\n                return 5\n\n        \"\"\"\n        )\n\n        enumeration = next(module[\"MyEnum\"].infer())\n        one = enumeration[\"one\"]\n        self.assertEqual(one.pytype(), \".MyEnum.one\")\n\n        for propname in (\"name\", \"value\"):\n            prop = next(iter(one.getattr(propname)))\n            self.assertIn(\"builtins.property\", prop.decoratornames())\n\n        meth = one.getattr(\"mymethod\")[0]\n        self.assertIsInstance(meth, astroid.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_simple_enum", "self", "none", "module", "builder", "parse", "import", "enum", "class", "myenum", "enum", "enum", "one", "one", "two", "two", "def", "mymethod", "self", "x", "return", "5", "enumeration", "next", "module", "myenum", "infer", "one", "enumeration", "one", "self", "assertequal", "one", "pytype", "myenum", "one", "for", "propname", "in", "name", "value", "prop", "next", "iter", "one", "getattr", "propname", "self", "assertin", "builtins", "property", "prop", "decoratornames", "meth", "one", "getattr", "mymethod", "0", "self", "assertisinstance", "meth", "astroid", "functiondef"], "doc_len": 68}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_looks_like_enum_false_positive", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_looks_like_enum_false_positive", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_looks_like_enum_false_positive(self) -> None:\n        # Test that a class named Enumeration is not considered a builtin enum.\n        module = builder.parse(\n            \"\"\"\n        class Enumeration(object):\n            def __init__(self, name, enum_list):\n                pass\n            test = 42\n        \"\"\"\n        )\n        enumeration = module[\"Enumeration\"]\n        test = next(enumeration.igetattr(\"test\"))\n        self.assertEqual(test.value, 42)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_looks_like_enum_false_positive", "self", "none", "test", "that", "a", "class", "named", "enumeration", "is", "not", "considered", "a", "builtin", "enum", "module", "builder", "parse", "class", "enumeration", "object", "def", "__init__", "self", "name", "enum_list", "pass", "test", "42", "enumeration", "module", "enumeration", "test", "next", "enumeration", "igetattr", "test", "self", "assertequal", "test", "value", "42"], "doc_len": 47}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_user_enum_false_positive", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_user_enum_false_positive", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_user_enum_false_positive(self) -> None:\n        # Test that a user-defined class named Enum is not considered a builtin enum.\n        ast_node = astroid.extract_node(\n            \"\"\"\n        class Enum:\n            pass\n\n        class Color(Enum):\n            red = 1\n\n        Color.red #@\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.NodeNG)\n        inferred = ast_node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], astroid.Const)\n        self.assertEqual(inferred[0].value, 1)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_user_enum_false_positive", "self", "none", "test", "that", "a", "user", "defined", "class", "named", "enum", "is", "not", "considered", "a", "builtin", "enum", "ast_node", "astroid", "extract_node", "class", "enum", "pass", "class", "color", "enum", "red", "1", "color", "red", "assert", "isinstance", "ast_node", "nodes", "nodeng", "inferred", "ast_node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "astroid", "const", "self", "assertequal", "inferred", "0", "value", "1"], "doc_len": 60}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_ignores_with_nodes_from_body_of_enum", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_ignores_with_nodes_from_body_of_enum", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_ignores_with_nodes_from_body_of_enum(self) -> None:\n        code = \"\"\"\n        import enum\n\n        class Error(enum.Enum):\n            Foo = \"foo\"\n            Bar = \"bar\"\n            with \"error\" as err:\n                pass\n        \"\"\"\n        node = builder.extract_node(code)\n        inferred = next(node.infer())\n        assert \"err\" in inferred.locals\n        assert len(inferred.locals[\"err\"]) == 1\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_ignores_with_nodes_from_body_of_enum", "self", "none", "code", "import", "enum", "class", "error", "enum", "enum", "foo", "foo", "bar", "bar", "with", "error", "as", "err", "pass", "node", "builder", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "err", "in", "inferred", "locals", "assert", "len", "inferred", "locals", "err", "1"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_multiple_base_classes", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_multiple_base_classes", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_multiple_base_classes(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        import enum\n\n        class Mixin:\n            pass\n\n        class MyEnum(Mixin, enum.Enum):\n            one = 1\n        \"\"\"\n        )\n        enumeration = next(module[\"MyEnum\"].infer())\n        one = enumeration[\"one\"]\n\n        clazz = one.getattr(\"__class__\")[0]\n        self.assertTrue(\n            clazz.is_subtype_of(\".Mixin\"),\n            \"Enum instance should share base classes with generating class\",\n        )\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_multiple_base_classes", "self", "none", "module", "builder", "parse", "import", "enum", "class", "mixin", "pass", "class", "myenum", "mixin", "enum", "enum", "one", "1", "enumeration", "next", "module", "myenum", "infer", "one", "enumeration", "one", "clazz", "one", "getattr", "__class__", "0", "self", "asserttrue", "clazz", "is_subtype_of", "mixin", "enum", "instance", "should", "share", "base", "classes", "with", "generating", "class"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_int_enum", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_int_enum", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_int_enum(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        import enum\n\n        class MyEnum(enum.IntEnum):\n            one = 1\n        \"\"\"\n        )\n\n        enumeration = next(module[\"MyEnum\"].infer())\n        one = enumeration[\"one\"]\n\n        clazz = one.getattr(\"__class__\")[0]\n        self.assertTrue(\n            clazz.is_subtype_of(\"builtins.int\"),\n            \"IntEnum based enums should be a subtype of int\",\n        )\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_int_enum", "self", "none", "module", "builder", "parse", "import", "enum", "class", "myenum", "enum", "intenum", "one", "1", "enumeration", "next", "module", "myenum", "infer", "one", "enumeration", "one", "clazz", "one", "getattr", "__class__", "0", "self", "asserttrue", "clazz", "is_subtype_of", "builtins", "int", "intenum", "based", "enums", "should", "be", "a", "subtype", "of", "int"], "doc_len": 47}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_func_form_is_class_not_instance", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_func_form_is_class_not_instance", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_func_form_is_class_not_instance(self) -> None:\n        cls, instance = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        f = Enum('Audience', ['a', 'b', 'c'])\n        f #@\n        f(1) #@\n        \"\"\"\n        )\n        inferred_cls = next(cls.infer())\n        self.assertIsInstance(inferred_cls, bases.Instance)\n        inferred_instance = next(instance.infer())\n        self.assertIsInstance(inferred_instance, bases.Instance)\n        self.assertIsInstance(next(inferred_instance.igetattr(\"name\")), nodes.Const)\n        self.assertIsInstance(next(inferred_instance.igetattr(\"value\")), nodes.Const)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_func_form_is_class_not_instance", "self", "none", "cls", "instance", "builder", "extract_node", "from", "enum", "import", "enum", "f", "enum", "audience", "a", "b", "c", "f", "f", "1", "inferred_cls", "next", "cls", "infer", "self", "assertisinstance", "inferred_cls", "bases", "instance", "inferred_instance", "next", "instance", "infer", "self", "assertisinstance", "inferred_instance", "bases", "instance", "self", "assertisinstance", "next", "inferred_instance", "igetattr", "name", "nodes", "const", "self", "assertisinstance", "next", "inferred_instance", "igetattr", "value", "nodes", "const"], "doc_len": 59}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_func_form_iterable", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_func_form_iterable", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_func_form_iterable(self) -> None:\n        instance = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        Animal = Enum('Animal', 'ant bee cat dog')\n        Animal\n        \"\"\"\n        )\n        inferred = next(instance.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n        self.assertTrue(inferred.getattr(\"__iter__\"))\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_func_form_iterable", "self", "none", "instance", "builder", "extract_node", "from", "enum", "import", "enum", "animal", "enum", "animal", "ant", "bee", "cat", "dog", "animal", "inferred", "next", "instance", "infer", "self", "assertisinstance", "inferred", "astroid", "instance", "self", "asserttrue", "inferred", "getattr", "__iter__"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_func_form_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_func_form_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_func_form_subscriptable(self) -> None:\n        instance, name = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        Animal = Enum('Animal', 'ant bee cat dog')\n        Animal['ant'] #@\n        Animal['ant'].name #@\n        \"\"\"\n        )\n        instance = next(instance.infer())\n        self.assertIsInstance(instance, astroid.Instance)\n\n        inferred = next(name.infer())\n        self.assertIsInstance(inferred, astroid.Const)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_func_form_subscriptable", "self", "none", "instance", "name", "builder", "extract_node", "from", "enum", "import", "enum", "animal", "enum", "animal", "ant", "bee", "cat", "dog", "animal", "ant", "animal", "ant", "name", "instance", "next", "instance", "infer", "self", "assertisinstance", "instance", "astroid", "instance", "inferred", "next", "name", "infer", "self", "assertisinstance", "inferred", "astroid", "const"], "doc_len": 46}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_func_form_has_dunder_members", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_func_form_has_dunder_members", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_func_form_has_dunder_members(self) -> None:\n        instance = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        Animal = Enum('Animal', 'ant bee cat dog')\n        for i in Animal.__members__:\n            i #@\n        \"\"\"\n        )\n        instance = next(instance.infer())\n        self.assertIsInstance(instance, astroid.Const)\n        self.assertIsInstance(instance.value, str)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_func_form_has_dunder_members", "self", "none", "instance", "builder", "extract_node", "from", "enum", "import", "enum", "animal", "enum", "animal", "ant", "bee", "cat", "dog", "for", "i", "in", "animal", "__members__", "i", "instance", "next", "instance", "infer", "self", "assertisinstance", "instance", "astroid", "const", "self", "assertisinstance", "instance", "value", "str"], "doc_len": 42}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_infer_enum_value_as_the_right_type", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_infer_enum_value_as_the_right_type", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_infer_enum_value_as_the_right_type(self) -> None:\n        string_value, int_value = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        class A(Enum):\n            a = 'a'\n            b = 1\n        A.a.value #@\n        A.b.value #@\n        \"\"\"\n        )\n        inferred_string = string_value.inferred()\n        assert any(\n            isinstance(elem, astroid.Const) and elem.value == \"a\"\n            for elem in inferred_string\n        )\n\n        inferred_int = int_value.inferred()\n        assert any(\n            isinstance(elem, astroid.Const) and elem.value == 1 for elem in inferred_int\n        )\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_infer_enum_value_as_the_right_type", "self", "none", "string_value", "int_value", "builder", "extract_node", "from", "enum", "import", "enum", "class", "a", "enum", "a", "a", "b", "1", "a", "a", "value", "a", "b", "value", "inferred_string", "string_value", "inferred", "assert", "any", "isinstance", "elem", "astroid", "const", "and", "elem", "value", "a", "for", "elem", "in", "inferred_string", "inferred_int", "int_value", "inferred", "assert", "any", "isinstance", "elem", "astroid", "const", "and", "elem", "value", "1", "for", "elem", "in", "inferred_int"], "doc_len": 63}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_mingled_single_and_double_quotes_does_not_crash", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_mingled_single_and_double_quotes_does_not_crash", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_mingled_single_and_double_quotes_does_not_crash(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        class A(Enum):\n            a = 'x\"y\"'\n        A.a.value #@\n        \"\"\"\n        )\n        inferred_string = next(node.infer())\n        assert inferred_string.value == 'x\"y\"'\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_mingled_single_and_double_quotes_does_not_crash", "self", "none", "node", "builder", "extract_node", "from", "enum", "import", "enum", "class", "a", "enum", "a", "x", "y", "a", "a", "value", "inferred_string", "next", "node", "infer", "assert", "inferred_string", "value", "x", "y"], "doc_len": 33}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_special_characters_does_not_crash", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_special_characters_does_not_crash", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_special_characters_does_not_crash(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        import enum\n        class Example(enum.Enum):\n            NULL = '\\\\N{NULL}'\n        Example.NULL.value\n        \"\"\"\n        )\n        inferred_string = next(node.infer())\n        assert inferred_string.value == \"\\N{NULL}\"\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_special_characters_does_not_crash", "self", "none", "node", "builder", "extract_node", "import", "enum", "class", "example", "enum", "enum", "null", "n", "null", "example", "null", "value", "inferred_string", "next", "node", "infer", "assert", "inferred_string", "value", "n", "null"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_dont_crash_on_for_loops_in_body", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_dont_crash_on_for_loops_in_body", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_dont_crash_on_for_loops_in_body(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n\n        class Commands(IntEnum):\n            _ignore_ = 'Commands index'\n            _init_ = 'value string'\n\n            BEL = 0x07, 'Bell'\n            Commands = vars()\n            for index in range(4):\n                Commands[f'DC{index + 1}'] = 0x11 + index, f'Device Control {index + 1}'\n\n        Commands\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.ClassDef)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_dont_crash_on_for_loops_in_body", "self", "none", "node", "builder", "extract_node", "class", "commands", "intenum", "_ignore_", "commands", "index", "_init_", "value", "string", "bel", "0x07", "bell", "commands", "vars", "for", "index", "in", "range", "4", "commands", "f", "dc", "index", "1", "0x11", "index", "f", "device", "control", "index", "1", "commands", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "classdef"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_tuple_list_values", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_tuple_list_values", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_tuple_list_values(self) -> None:\n        tuple_node, list_node = builder.extract_node(\n            \"\"\"\n        import enum\n\n        class MyEnum(enum.Enum):\n            a = (1, 2)\n            b = [2, 4]\n        MyEnum.a.value #@\n        MyEnum.b.value #@\n        \"\"\"\n        )\n        inferred_tuple_node = next(tuple_node.infer())\n        inferred_list_node = next(list_node.infer())\n        assert isinstance(inferred_tuple_node, astroid.Tuple)\n        assert isinstance(inferred_list_node, astroid.List)\n        assert inferred_tuple_node.as_string() == \"(1, 2)\"\n        assert inferred_list_node.as_string() == \"[2, 4]\"\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_tuple_list_values", "self", "none", "tuple_node", "list_node", "builder", "extract_node", "import", "enum", "class", "myenum", "enum", "enum", "a", "1", "2", "b", "2", "4", "myenum", "a", "value", "myenum", "b", "value", "inferred_tuple_node", "next", "tuple_node", "infer", "inferred_list_node", "next", "list_node", "infer", "assert", "isinstance", "inferred_tuple_node", "astroid", "tuple", "assert", "isinstance", "inferred_list_node", "astroid", "list", "assert", "inferred_tuple_node", "as_string", "1", "2", "assert", "inferred_list_node", "as_string", "2", "4"], "doc_len": 58}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_starred_is_skipped", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_starred_is_skipped", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_starred_is_skipped(self) -> None:\n        code = \"\"\"\n        from enum import Enum\n        class ContentType(Enum):\n            TEXT, PHOTO, VIDEO, GIF, YOUTUBE, *_ = [1, 2, 3, 4, 5, 6]\n        ContentType.TEXT #@\n        \"\"\"\n        node = astroid.extract_node(code)\n        next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_starred_is_skipped", "self", "none", "code", "from", "enum", "import", "enum", "class", "contenttype", "enum", "text", "photo", "video", "gif", "youtube", "_", "1", "2", "3", "4", "5", "6", "contenttype", "text", "node", "astroid", "extract_node", "code", "next", "node", "infer"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_name_is_str_on_self", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_name_is_str_on_self", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_name_is_str_on_self(self) -> None:\n        code = \"\"\"\n        from enum import Enum\n        class TestEnum(Enum):\n            def func(self):\n                self.name #@\n                self.value #@\n        TestEnum.name #@\n        TestEnum.value #@\n        \"\"\"\n        i_name, i_value, c_name, c_value = astroid.extract_node(code)\n\n        # <instance>.name should be a string, <class>.name should be a property (that\n        # forwards the lookup to __getattr__)\n        inferred = next(i_name.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.pytype() == \"builtins.str\"\n        inferred = next(c_name.infer())\n        assert isinstance(inferred, objects.Property)\n\n        # Inferring .value should not raise InferenceError. It is probably Uninferable\n        # but we don't particularly care\n        next(i_value.infer())\n        next(c_value.infer())\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_name_is_str_on_self", "self", "none", "code", "from", "enum", "import", "enum", "class", "testenum", "enum", "def", "func", "self", "self", "name", "self", "value", "testenum", "name", "testenum", "value", "i_name", "i_value", "c_name", "c_value", "astroid", "extract_node", "code", "instance", "name", "should", "be", "a", "string", "class", "name", "should", "be", "a", "property", "that", "forwards", "the", "lookup", "to", "__getattr__", "inferred", "next", "i_name", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "pytype", "builtins", "str", "inferred", "next", "c_name", "infer", "assert", "isinstance", "inferred", "objects", "property", "inferring", "value", "should", "not", "raise", "inferenceerror", "it", "is", "probably", "uninferable", "but", "we", "don", "t", "particularly", "care", "next", "i_value", "infer", "next", "c_value", "infer"], "doc_len": 97}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_name_and_value_members_override_dynamicclassattr", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_name_and_value_members_override_dynamicclassattr", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_name_and_value_members_override_dynamicclassattr(self) -> None:\n        code = \"\"\"\n        from enum import Enum\n        class TrickyEnum(Enum):\n            name = 1\n            value = 2\n\n            def func(self):\n                self.name #@\n                self.value #@\n        TrickyEnum.name #@\n        TrickyEnum.value #@\n        \"\"\"\n        i_name, i_value, c_name, c_value = astroid.extract_node(code)\n\n        # All of these cases should be inferred as enum members\n        inferred = next(i_name.infer())\n        assert isinstance(inferred, bases.Instance)\n        assert inferred.pytype() == \".TrickyEnum.name\"\n        inferred = next(c_name.infer())\n        assert isinstance(inferred, bases.Instance)\n        assert inferred.pytype() == \".TrickyEnum.name\"\n        inferred = next(i_value.infer())\n        assert isinstance(inferred, bases.Instance)\n        assert inferred.pytype() == \".TrickyEnum.value\"\n        inferred = next(c_value.infer())\n        assert isinstance(inferred, bases.Instance)\n        assert inferred.pytype() == \".TrickyEnum.value\"\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_name_and_value_members_override_dynamicclassattr", "self", "none", "code", "from", "enum", "import", "enum", "class", "trickyenum", "enum", "name", "1", "value", "2", "def", "func", "self", "self", "name", "self", "value", "trickyenum", "name", "trickyenum", "value", "i_name", "i_value", "c_name", "c_value", "astroid", "extract_node", "code", "all", "of", "these", "cases", "should", "be", "inferred", "as", "enum", "members", "inferred", "next", "i_name", "infer", "assert", "isinstance", "inferred", "bases", "instance", "assert", "inferred", "pytype", "trickyenum", "name", "inferred", "next", "c_name", "infer", "assert", "isinstance", "inferred", "bases", "instance", "assert", "inferred", "pytype", "trickyenum", "name", "inferred", "next", "i_value", "infer", "assert", "isinstance", "inferred", "bases", "instance", "assert", "inferred", "pytype", "trickyenum", "value", "inferred", "next", "c_value", "infer", "assert", "isinstance", "inferred", "bases", "instance", "assert", "inferred", "pytype", "trickyenum", "value"], "doc_len": 104}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_subclass_member_name", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_subclass_member_name", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_subclass_member_name(self) -> None:\n        ast_node = astroid.extract_node(\n            \"\"\"\n        from enum import Enum\n\n        class EnumSubclass(Enum):\n            pass\n\n        class Color(EnumSubclass):\n            red = 1\n\n        Color.red.name #@\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.NodeNG)\n        inferred = ast_node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], astroid.Const)\n        self.assertEqual(inferred[0].value, \"red\")\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_subclass_member_name", "self", "none", "ast_node", "astroid", "extract_node", "from", "enum", "import", "enum", "class", "enumsubclass", "enum", "pass", "class", "color", "enumsubclass", "red", "1", "color", "red", "name", "assert", "isinstance", "ast_node", "nodes", "nodeng", "inferred", "ast_node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "astroid", "const", "self", "assertequal", "inferred", "0", "value", "red"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_subclass_member_value", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_subclass_member_value", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_subclass_member_value(self) -> None:\n        ast_node = astroid.extract_node(\n            \"\"\"\n        from enum import Enum\n\n        class EnumSubclass(Enum):\n            pass\n\n        class Color(EnumSubclass):\n            red = 1\n\n        Color.red.value #@\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.NodeNG)\n        inferred = ast_node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], astroid.Const)\n        self.assertEqual(inferred[0].value, 1)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_subclass_member_value", "self", "none", "ast_node", "astroid", "extract_node", "from", "enum", "import", "enum", "class", "enumsubclass", "enum", "pass", "class", "color", "enumsubclass", "red", "1", "color", "red", "value", "assert", "isinstance", "ast_node", "nodes", "nodeng", "inferred", "ast_node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "astroid", "const", "self", "assertequal", "inferred", "0", "value", "1"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_subclass_member_method", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_subclass_member_method", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_subclass_member_method(self) -> None:\n        # See Pylint issue #2626\n        ast_node = astroid.extract_node(\n            \"\"\"\n        from enum import Enum\n\n        class EnumSubclass(Enum):\n            def hello_pylint(self) -> str:\n                return self.name\n\n        class Color(EnumSubclass):\n            red = 1\n\n        Color.red.hello_pylint()  #@\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.NodeNG)\n        inferred = ast_node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], astroid.Const)\n        self.assertEqual(inferred[0].value, \"red\")\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_subclass_member_method", "self", "none", "see", "pylint", "issue", "2626", "ast_node", "astroid", "extract_node", "from", "enum", "import", "enum", "class", "enumsubclass", "enum", "def", "hello_pylint", "self", "str", "return", "self", "name", "class", "color", "enumsubclass", "red", "1", "color", "red", "hello_pylint", "assert", "isinstance", "ast_node", "nodes", "nodeng", "inferred", "ast_node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "astroid", "const", "self", "assertequal", "inferred", "0", "value", "red"], "doc_len": 62}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_enum_subclass_different_modules", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_enum_subclass_different_modules", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_enum_subclass_different_modules(self) -> None:\n        # See Pylint issue #2626\n        astroid.extract_node(\n            \"\"\"\n        from enum import Enum\n\n        class EnumSubclass(Enum):\n            pass\n        \"\"\",\n            \"a\",\n        )\n        ast_node = astroid.extract_node(\n            \"\"\"\n        from a import EnumSubclass\n\n        class Color(EnumSubclass):\n            red = 1\n\n        Color.red.value #@\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.NodeNG)\n        inferred = ast_node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], astroid.Const)\n        self.assertEqual(inferred[0].value, 1)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_enum_subclass_different_modules", "self", "none", "see", "pylint", "issue", "2626", "astroid", "extract_node", "from", "enum", "import", "enum", "class", "enumsubclass", "enum", "pass", "a", "ast_node", "astroid", "extract_node", "from", "a", "import", "enumsubclass", "class", "color", "enumsubclass", "red", "1", "color", "red", "value", "assert", "isinstance", "ast_node", "nodes", "nodeng", "inferred", "ast_node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "astroid", "const", "self", "assertequal", "inferred", "0", "value", "1"], "doc_len": 63}
{"doc_id": "tests/unittest_brain.py::EnumBrainTest.test_members_member_ignored", "file_path": "tests/unittest_brain.py", "class_name": "EnumBrainTest", "func_name": "test_members_member_ignored", "text": "文件路径: tests/unittest_brain.py, 类名: EnumBrainTest\n    def test_members_member_ignored(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        class Animal(Enum):\n            a = 1\n            __members__ = {}\n        Animal.__members__ #@\n        \"\"\"\n        )\n\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, astroid.Dict)\n        self.assertTrue(inferred.locals)\n", "tokens": ["tests", "unittest_brain", "py", "enumbraintest", "def", "test_members_member_ignored", "self", "none", "ast_node", "builder", "extract_node", "from", "enum", "import", "enum", "class", "animal", "enum", "a", "1", "__members__", "animal", "__members__", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "astroid", "dict", "self", "asserttrue", "inferred", "locals"], "doc_len": 36}
{"doc_id": "tests/unittest_brain.py::DateutilBrainTest.test_parser", "file_path": "tests/unittest_brain.py", "class_name": "DateutilBrainTest", "func_name": "test_parser", "text": "文件路径: tests/unittest_brain.py, 类名: DateutilBrainTest\n    def test_parser(self):\n        module = builder.parse(\n            \"\"\"\n        from dateutil.parser import parse\n        d = parse('2000-01-01')\n        \"\"\"\n        )\n        d_type = next(module[\"d\"].infer())\n        self.assertEqual(d_type.qname(), \"datetime.datetime\")\n", "tokens": ["tests", "unittest_brain", "py", "dateutilbraintest", "def", "test_parser", "self", "module", "builder", "parse", "from", "dateutil", "parser", "import", "parse", "d", "parse", "2000", "01", "01", "d_type", "next", "module", "d", "infer", "self", "assertequal", "d_type", "qname", "datetime", "datetime"], "doc_len": 31}
{"doc_id": "tests/unittest_brain.py::PytestBrainTest.test_pytest", "file_path": "tests/unittest_brain.py", "class_name": "PytestBrainTest", "func_name": "test_pytest", "text": "文件路径: tests/unittest_brain.py, 类名: PytestBrainTest\n    def test_pytest(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        import pytest\n        pytest #@\n        \"\"\"\n        )\n        module = next(ast_node.infer())\n        attrs = [\n            \"deprecated_call\",\n            \"warns\",\n            \"exit\",\n            \"fail\",\n            \"skip\",\n            \"importorskip\",\n            \"xfail\",\n            \"mark\",\n            \"raises\",\n            \"freeze_includes\",\n            \"set_trace\",\n            \"fixture\",\n            \"yield_fixture\",\n        ]\n        for attr in attrs:\n            self.assertIn(attr, module)\n", "tokens": ["tests", "unittest_brain", "py", "pytestbraintest", "def", "test_pytest", "self", "none", "ast_node", "builder", "extract_node", "import", "pytest", "pytest", "module", "next", "ast_node", "infer", "attrs", "deprecated_call", "warns", "exit", "fail", "skip", "importorskip", "xfail", "mark", "raises", "freeze_includes", "set_trace", "fixture", "yield_fixture", "for", "attr", "in", "attrs", "self", "assertin", "attr", "module"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::streams_are_fine", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "streams_are_fine", "text": "文件路径: tests/unittest_brain.py\ndef streams_are_fine():\n    \"\"\"Check if streams are being overwritten,\n    for example, by pytest\n\n    stream inference will not work if they are overwritten\n\n    PY3 only\n    \"\"\"\n    return all(isinstance(s, io.IOBase) for s in (sys.stdout, sys.stderr, sys.stdin))\n", "tokens": ["tests", "unittest_brain", "py", "def", "streams_are_fine", "check", "if", "streams", "are", "being", "overwritten", "for", "example", "by", "pytest", "stream", "inference", "will", "not", "work", "if", "they", "are", "overwritten", "py3", "only", "return", "all", "isinstance", "s", "io", "iobase", "for", "s", "in", "sys", "stdout", "sys", "stderr", "sys", "stdin"], "doc_len": 41}
{"doc_id": "tests/unittest_brain.py::IOBrainTest.test_sys_streams", "file_path": "tests/unittest_brain.py", "class_name": "IOBrainTest", "func_name": "test_sys_streams", "text": "文件路径: tests/unittest_brain.py, 类名: IOBrainTest\n    def test_sys_streams(self):\n        for name in (\"stdout\", \"stderr\", \"stdin\"):\n            node = astroid.extract_node(\n                f\"\"\"\n            import sys\n            sys.{name}\n            \"\"\"\n            )\n            inferred = next(node.infer())\n            buffer_attr = next(inferred.igetattr(\"buffer\"))\n            self.assertIsInstance(buffer_attr, astroid.Instance)\n            self.assertEqual(buffer_attr.name, \"BufferedWriter\")\n            raw = next(buffer_attr.igetattr(\"raw\"))\n            self.assertIsInstance(raw, astroid.Instance)\n            self.assertEqual(raw.name, \"FileIO\")\n", "tokens": ["tests", "unittest_brain", "py", "iobraintest", "def", "test_sys_streams", "self", "for", "name", "in", "stdout", "stderr", "stdin", "node", "astroid", "extract_node", "f", "import", "sys", "sys", "name", "inferred", "next", "node", "infer", "buffer_attr", "next", "inferred", "igetattr", "buffer", "self", "assertisinstance", "buffer_attr", "astroid", "instance", "self", "assertequal", "buffer_attr", "name", "bufferedwriter", "raw", "next", "buffer_attr", "igetattr", "raw", "self", "assertisinstance", "raw", "astroid", "instance", "self", "assertequal", "raw", "name", "fileio"], "doc_len": 55}
{"doc_id": "tests/unittest_brain.py::TypeBrain.test_type_subscript", "file_path": "tests/unittest_brain.py", "class_name": "TypeBrain", "func_name": "test_type_subscript", "text": "文件路径: tests/unittest_brain.py, 类名: TypeBrain\n    def test_type_subscript(self):\n        \"\"\"\n        Check that type object has the __class_getitem__ method\n        when it is used as a subscript\n        \"\"\"\n        src = builder.extract_node(\n            \"\"\"\n            a: type[int] = int\n            \"\"\"\n        )\n        val_inf = src.annotation.value.inferred()[0]\n        self.assertIsInstance(val_inf, astroid.ClassDef)\n        self.assertEqual(val_inf.name, \"type\")\n        meth_inf = val_inf.getattr(\"__class_getitem__\")[0]\n        self.assertIsInstance(meth_inf, astroid.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "typebrain", "def", "test_type_subscript", "self", "check", "that", "type", "object", "has", "the", "__class_getitem__", "method", "when", "it", "is", "used", "as", "a", "subscript", "src", "builder", "extract_node", "a", "type", "int", "int", "val_inf", "src", "annotation", "value", "inferred", "0", "self", "assertisinstance", "val_inf", "astroid", "classdef", "self", "assertequal", "val_inf", "name", "type", "meth_inf", "val_inf", "getattr", "__class_getitem__", "0", "self", "assertisinstance", "meth_inf", "astroid", "functiondef"], "doc_len": 55}
{"doc_id": "tests/unittest_brain.py::TypeBrain.test_invalid_type_subscript", "file_path": "tests/unittest_brain.py", "class_name": "TypeBrain", "func_name": "test_invalid_type_subscript", "text": "文件路径: tests/unittest_brain.py, 类名: TypeBrain\n    def test_invalid_type_subscript(self):\n        \"\"\"\n        Check that a type (str for example) that inherits\n        from type does not have __class_getitem__ method even\n        when it is used as a subscript\n        \"\"\"\n        src = builder.extract_node(\n            \"\"\"\n            a: str[int] = \"abc\"\n            \"\"\"\n        )\n        val_inf = src.annotation.value.inferred()[0]\n        self.assertIsInstance(val_inf, astroid.ClassDef)\n        self.assertEqual(val_inf.name, \"str\")\n        with self.assertRaises(AttributeInferenceError):\n            # pylint: disable=expression-not-assigned\n            # noinspection PyStatementEffect\n            val_inf.getattr(\"__class_getitem__\")[0]\n", "tokens": ["tests", "unittest_brain", "py", "typebrain", "def", "test_invalid_type_subscript", "self", "check", "that", "a", "type", "str", "for", "example", "that", "inherits", "from", "type", "does", "not", "have", "__class_getitem__", "method", "even", "when", "it", "is", "used", "as", "a", "subscript", "src", "builder", "extract_node", "a", "str", "int", "abc", "val_inf", "src", "annotation", "value", "inferred", "0", "self", "assertisinstance", "val_inf", "astroid", "classdef", "self", "assertequal", "val_inf", "name", "str", "with", "self", "assertraises", "attributeinferenceerror", "pylint", "disable", "expression", "not", "assigned", "noinspection", "pystatementeffect", "val_inf", "getattr", "__class_getitem__", "0"], "doc_len": 69}
{"doc_id": "tests/unittest_brain.py::TypeBrain.test_builtin_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypeBrain", "func_name": "test_builtin_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypeBrain\n    def test_builtin_subscriptable(self):\n        \"\"\"\n        Starting with python3.9 builtin type such as list are subscriptable\n        \"\"\"\n        for typename in (\"tuple\", \"list\", \"dict\", \"set\", \"frozenset\"):\n            src = f\"\"\"\n            {typename:s}[int]\n            \"\"\"\n            right_node = builder.extract_node(src)\n            inferred = next(right_node.infer())\n            self.assertIsInstance(inferred, nodes.ClassDef)\n            self.assertIsInstance(inferred.getattr(\"__iter__\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "typebrain", "def", "test_builtin_subscriptable", "self", "starting", "with", "python3", "9", "builtin", "type", "such", "as", "list", "are", "subscriptable", "for", "typename", "in", "tuple", "list", "dict", "set", "frozenset", "src", "f", "typename", "s", "int", "right_node", "builder", "extract_node", "src", "inferred", "next", "right_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertisinstance", "inferred", "getattr", "__iter__", "0", "nodes", "functiondef"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::check_metaclass_is_abc", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "check_metaclass_is_abc", "text": "文件路径: tests/unittest_brain.py\ndef check_metaclass_is_abc(node: nodes.ClassDef):\n    meta = node.metaclass()\n    assert isinstance(meta, nodes.ClassDef)\n    assert meta.name == \"ABCMeta\"\n", "tokens": ["tests", "unittest_brain", "py", "def", "check_metaclass_is_abc", "node", "nodes", "classdef", "meta", "node", "metaclass", "assert", "isinstance", "meta", "nodes", "classdef", "assert", "meta", "name", "abcmeta"], "doc_len": 20}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_not_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_not_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_not_subscriptable(self) -> None:\n        \"\"\"\n        Test that unsubscriptable types are detected\n        Hashable is not subscriptable even with python39\n        \"\"\"\n        wrong_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.Hashable[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(wrong_node.infer())\n        right_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.Hashable\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        check_metaclass_is_abc(inferred)\n        assertEqualMro(\n            inferred,\n            [\n                \"_collections_abc.Hashable\",\n                \"builtins.object\",\n            ],\n        )\n        with self.assertRaises(AttributeInferenceError):\n            inferred.getattr(\"__class_getitem__\")\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_not_subscriptable", "self", "none", "test", "that", "unsubscriptable", "types", "are", "detected", "hashable", "is", "not", "subscriptable", "even", "with", "python39", "wrong_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "hashable", "int", "with", "self", "assertraises", "inferenceerror", "next", "wrong_node", "infer", "right_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "hashable", "inferred", "next", "right_node", "infer", "check_metaclass_is_abc", "inferred", "assertequalmro", "inferred", "_collections_abc", "hashable", "builtins", "object", "with", "self", "assertraises", "attributeinferenceerror", "inferred", "getattr", "__class_getitem__"], "doc_len": 66}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_subscriptable(self):\n        \"\"\"Starting with python39 some object of collections module are subscriptable. Test one of them\"\"\"\n        right_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.MutableSet[int]\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        check_metaclass_is_abc(inferred)\n        assertEqualMro(\n            inferred,\n            [\n                \"_collections_abc.MutableSet\",\n                \"_collections_abc.Set\",\n                \"_collections_abc.Collection\",\n                \"_collections_abc.Sized\",\n                \"_collections_abc.Iterable\",\n                \"_collections_abc.Container\",\n                \"builtins.object\",\n            ],\n        )\n        self.assertIsInstance(\n            inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n        )\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_subscriptable", "self", "starting", "with", "python39", "some", "object", "of", "collections", "module", "are", "subscriptable", "test", "one", "of", "them", "right_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "mutableset", "int", "inferred", "next", "right_node", "infer", "check_metaclass_is_abc", "inferred", "assertequalmro", "inferred", "_collections_abc", "mutableset", "_collections_abc", "set", "_collections_abc", "collection", "_collections_abc", "sized", "_collections_abc", "iterable", "_collections_abc", "container", "builtins", "object", "self", "assertisinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 61}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_not_yet_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_not_yet_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_not_yet_subscriptable(self):\n        \"\"\"\n        Test that unsubscriptable types are detected as such.\n        Until python39 MutableSet of the collections module is not subscriptable.\n        \"\"\"\n        wrong_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.MutableSet[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(wrong_node.infer())\n        right_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.MutableSet\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        check_metaclass_is_abc(inferred)\n        assertEqualMro(\n            inferred,\n            [\n                \"_collections_abc.MutableSet\",\n                \"_collections_abc.Set\",\n                \"_collections_abc.Collection\",\n                \"_collections_abc.Sized\",\n                \"_collections_abc.Iterable\",\n                \"_collections_abc.Container\",\n                \"builtins.object\",\n            ],\n        )\n        with self.assertRaises(AttributeInferenceError):\n            inferred.getattr(\"__class_getitem__\")\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_not_yet_subscriptable", "self", "test", "that", "unsubscriptable", "types", "are", "detected", "as", "such", "until", "python39", "mutableset", "of", "the", "collections", "module", "is", "not", "subscriptable", "wrong_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "mutableset", "int", "with", "self", "assertraises", "inferenceerror", "next", "wrong_node", "infer", "right_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "mutableset", "inferred", "next", "right_node", "infer", "check_metaclass_is_abc", "inferred", "assertequalmro", "inferred", "_collections_abc", "mutableset", "_collections_abc", "set", "_collections_abc", "collection", "_collections_abc", "sized", "_collections_abc", "iterable", "_collections_abc", "container", "builtins", "object", "with", "self", "assertraises", "attributeinferenceerror", "inferred", "getattr", "__class_getitem__"], "doc_len": 80}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_subscriptable_2", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_subscriptable_2", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_subscriptable_2(self):\n        \"\"\"Starting with python39 Iterator in the collection.abc module is subscriptable\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        class Derived(collections.abc.Iterator[int]):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        check_metaclass_is_abc(inferred)\n        assertEqualMro(\n            inferred,\n            [\n                \".Derived\",\n                \"_collections_abc.Iterator\",\n                \"_collections_abc.Iterable\",\n                \"builtins.object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_subscriptable_2", "self", "starting", "with", "python39", "iterator", "in", "the", "collection", "abc", "module", "is", "subscriptable", "node", "builder", "extract_node", "import", "collections", "abc", "class", "derived", "collections", "abc", "iterator", "int", "pass", "inferred", "next", "node", "infer", "check_metaclass_is_abc", "inferred", "assertequalmro", "inferred", "derived", "_collections_abc", "iterator", "_collections_abc", "iterable", "builtins", "object"], "doc_len": 46}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_not_yet_subscriptable_2", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_not_yet_subscriptable_2", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_not_yet_subscriptable_2(self):\n        \"\"\"Before python39 Iterator in the collection.abc module is not subscriptable\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.Iterator[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_not_yet_subscriptable_2", "self", "before", "python39", "iterator", "in", "the", "collection", "abc", "module", "is", "not", "subscriptable", "node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "iterator", "int", "with", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 35}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_subscriptable_3", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_subscriptable_3", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_subscriptable_3(self):\n        \"\"\"With python39 ByteString class of the colletions module is subscritable (but not the same class from typing module)\"\"\"\n        right_node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        collections.abc.ByteString[int]\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        check_metaclass_is_abc(inferred)\n        self.assertIsInstance(\n            inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n        )\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_subscriptable_3", "self", "with", "python39", "bytestring", "class", "of", "the", "colletions", "module", "is", "subscritable", "but", "not", "the", "same", "class", "from", "typing", "module", "right_node", "builder", "extract_node", "import", "collections", "abc", "collections", "abc", "bytestring", "int", "inferred", "next", "right_node", "infer", "check_metaclass_is_abc", "inferred", "self", "assertisinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 49}
{"doc_id": "tests/unittest_brain.py::CollectionsBrain.test_collections_object_subscriptable_4", "file_path": "tests/unittest_brain.py", "class_name": "CollectionsBrain", "func_name": "test_collections_object_subscriptable_4", "text": "文件路径: tests/unittest_brain.py, 类名: CollectionsBrain\n    def test_collections_object_subscriptable_4(self):\n        \"\"\"Multiple inheritance with subscriptable collection class\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import collections.abc\n        class Derived(collections.abc.Hashable, collections.abc.Iterator[int]):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \".Derived\",\n                \"_collections_abc.Hashable\",\n                \"_collections_abc.Iterator\",\n                \"_collections_abc.Iterable\",\n                \"builtins.object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_brain", "py", "collectionsbrain", "def", "test_collections_object_subscriptable_4", "self", "multiple", "inheritance", "with", "subscriptable", "collection", "class", "node", "builder", "extract_node", "import", "collections", "abc", "class", "derived", "collections", "abc", "hashable", "collections", "abc", "iterator", "int", "pass", "inferred", "next", "node", "infer", "assertequalmro", "inferred", "derived", "_collections_abc", "hashable", "_collections_abc", "iterator", "_collections_abc", "iterable", "builtins", "object"], "doc_len": 44}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_base", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_base", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_base(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        class X(NamedTuple(\"X\", [(\"a\", int), (\"b\", str), (\"c\", bytes)])):\n           pass\n        \"\"\"\n        )\n        self.assertEqual(\n            [anc.name for anc in klass.ancestors()], [\"X\", \"tuple\", \"object\"]\n        )\n        for anc in klass.ancestors():\n            self.assertFalse(anc.parent is None)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_base", "self", "none", "klass", "builder", "extract_node", "from", "typing", "import", "namedtuple", "class", "x", "namedtuple", "x", "a", "int", "b", "str", "c", "bytes", "pass", "self", "assertequal", "anc", "name", "for", "anc", "in", "klass", "ancestors", "x", "tuple", "object", "for", "anc", "in", "klass", "ancestors", "self", "assertfalse", "anc", "parent", "is", "none"], "doc_len": 49}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_can_correctly_access_methods", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_can_correctly_access_methods", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_can_correctly_access_methods(self) -> None:\n        klass, called = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        class X(NamedTuple): #@\n            a: int\n            b: int\n            def as_string(self):\n                return '%s' % self.a\n            def as_integer(self):\n                return 2 + 3\n        X().as_integer() #@\n        \"\"\"\n        )\n        self.assertEqual(len(klass.getattr(\"as_string\")), 1)\n        inferred = next(called.infer())\n        self.assertIsInstance(inferred, astroid.Const)\n        self.assertEqual(inferred.value, 5)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_can_correctly_access_methods", "self", "none", "klass", "called", "builder", "extract_node", "from", "typing", "import", "namedtuple", "class", "x", "namedtuple", "a", "int", "b", "int", "def", "as_string", "self", "return", "s", "self", "a", "def", "as_integer", "self", "return", "2", "3", "x", "as_integer", "self", "assertequal", "len", "klass", "getattr", "as_string", "1", "inferred", "next", "called", "infer", "self", "assertisinstance", "inferred", "astroid", "const", "self", "assertequal", "inferred", "value", "5"], "doc_len": 59}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_inference", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_inference", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_inference(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        class X(NamedTuple(\"X\", [(\"a\", int), (\"b\", str), (\"c\", bytes)])):\n           pass\n        \"\"\"\n        )\n        base = next(base for base in klass.ancestors() if base.name == \"X\")\n        self.assertSetEqual({\"a\", \"b\", \"c\"}, set(base.instance_attrs))\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_inference", "self", "none", "klass", "builder", "extract_node", "from", "typing", "import", "namedtuple", "class", "x", "namedtuple", "x", "a", "int", "b", "str", "c", "bytes", "pass", "base", "next", "base", "for", "base", "in", "klass", "ancestors", "if", "base", "name", "x", "self", "assertsetequal", "a", "b", "c", "set", "base", "instance_attrs"], "doc_len": 46}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_inference_nonliteral", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_inference_nonliteral", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_inference_nonliteral(self) -> None:\n        # Note: NamedTuples in mypy only work with literals.\n        klass = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        name = \"X\"\n        fields = [(\"a\", int), (\"b\", str), (\"c\", bytes)]\n        NamedTuple(name, fields)\n        \"\"\"\n        )\n        inferred = next(klass.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n        self.assertEqual(inferred.qname(), \"typing.NamedTuple\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_inference_nonliteral", "self", "none", "note", "namedtuples", "in", "mypy", "only", "work", "with", "literals", "klass", "builder", "extract_node", "from", "typing", "import", "namedtuple", "name", "x", "fields", "a", "int", "b", "str", "c", "bytes", "namedtuple", "name", "fields", "inferred", "next", "klass", "infer", "self", "assertisinstance", "inferred", "astroid", "instance", "self", "assertequal", "inferred", "qname", "typing", "namedtuple"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_instance_attrs", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_instance_attrs", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_instance_attrs(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n        NamedTuple(\"A\", [(\"a\", int), (\"b\", str), (\"c\", bytes)])(1, 2, 3) #@\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        for name, attr in inferred.instance_attrs.items():\n            self.assertEqual(attr[0].attrname, name)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_instance_attrs", "self", "none", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "namedtuple", "a", "a", "int", "b", "str", "c", "bytes", "1", "2", "3", "inferred", "next", "result", "infer", "for", "name", "attr", "in", "inferred", "instance_attrs", "items", "self", "assertequal", "attr", "0", "attrname", "name"], "doc_len": 43}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_simple", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_simple", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_simple(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n        NamedTuple(\"A\", [(\"a\", int), (\"b\", str), (\"c\", bytes)])\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertSetEqual({\"a\", \"b\", \"c\"}, set(inferred.instance_attrs))\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_simple", "self", "none", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "namedtuple", "a", "a", "int", "b", "str", "c", "bytes", "inferred", "next", "result", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertsetequal", "a", "b", "c", "set", "inferred", "instance_attrs"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_few_args", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_few_args", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_few_args(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n        NamedTuple(\"A\")\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n        self.assertEqual(inferred.qname(), \"typing.NamedTuple\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_few_args", "self", "none", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "namedtuple", "a", "inferred", "next", "result", "infer", "self", "assertisinstance", "inferred", "astroid", "instance", "self", "assertequal", "inferred", "qname", "typing", "namedtuple"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_few_fields", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_few_fields", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_few_fields(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n        NamedTuple(\"A\", [(\"a\",), (\"b\", str), (\"c\", bytes)])\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n        self.assertEqual(inferred.qname(), \"typing.NamedTuple\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_few_fields", "self", "none", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "namedtuple", "a", "a", "b", "str", "c", "bytes", "inferred", "next", "result", "infer", "self", "assertisinstance", "inferred", "astroid", "instance", "self", "assertequal", "inferred", "qname", "typing", "namedtuple"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_class_form", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_class_form", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_class_form(self) -> None:\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        class Example(NamedTuple):\n            CLASS_ATTR = \"class_attr\"\n            mything: int\n\n        Example(mything=1)\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n\n        class_attr = inferred.getattr(\"CLASS_ATTR\")[0]\n        self.assertIsInstance(class_attr, astroid.AssignName)\n        const = next(class_attr.infer())\n        self.assertEqual(const.value, \"class_attr\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_class_form", "self", "none", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "class", "example", "namedtuple", "class_attr", "class_attr", "mything", "int", "example", "mything", "1", "inferred", "next", "result", "infer", "self", "assertisinstance", "inferred", "astroid", "instance", "class_attr", "inferred", "getattr", "class_attr", "0", "self", "assertisinstance", "class_attr", "astroid", "assignname", "const", "next", "class_attr", "infer", "self", "assertequal", "const", "value", "class_attr"], "doc_len": 53}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_inferred_as_class", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_inferred_as_class", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_inferred_as_class(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n        NamedTuple\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert inferred.name == \"NamedTuple\"\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_inferred_as_class", "self", "none", "node", "builder", "extract_node", "from", "typing", "import", "namedtuple", "namedtuple", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "inferred", "name", "namedtuple"], "doc_len": 29}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_bug_pylint_4383", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_bug_pylint_4383", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_bug_pylint_4383(self) -> None:\n        \"\"\"Inference of 'NamedTuple' function shouldn't cause InferenceError.\n\n        https://github.com/PyCQA/pylint/issues/4383\n        \"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        if True:\n            def NamedTuple():\n                pass\n        NamedTuple\n        \"\"\"\n        )\n        next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_bug_pylint_4383", "self", "none", "inference", "of", "namedtuple", "function", "shouldn", "t", "cause", "inferenceerror", "https", "github", "com", "pycqa", "pylint", "issues", "4383", "node", "builder", "extract_node", "if", "true", "def", "namedtuple", "pass", "namedtuple", "next", "node", "infer"], "doc_len": 35}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_types", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_types", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_types(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        from typing import TypeVar, Iterable, Tuple, NewType, Dict, Union\n        TypeVar('MyTypeVar', int, float, complex) #@\n        Iterable[Tuple[MyTypeVar, MyTypeVar]] #@\n        TypeVar('AnyStr', str, bytes) #@\n        NewType('UserId', str) #@\n        Dict[str, str] #@\n        Union[int, str] #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.ClassDef, node.as_string())\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_types", "self", "none", "ast_nodes", "builder", "extract_node", "from", "typing", "import", "typevar", "iterable", "tuple", "newtype", "dict", "union", "typevar", "mytypevar", "int", "float", "complex", "iterable", "tuple", "mytypevar", "mytypevar", "typevar", "anystr", "str", "bytes", "newtype", "userid", "str", "dict", "str", "str", "union", "int", "str", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "node", "as_string"], "doc_len": 57}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_namedtuple_nested_class", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_namedtuple_nested_class", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_namedtuple_nested_class(self):\n        result = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        class Example(NamedTuple):\n            class Foo:\n                bar = \"bar\"\n\n        Example\n        \"\"\"\n        )\n        inferred = next(result.infer())\n        self.assertIsInstance(inferred, astroid.ClassDef)\n\n        class_def_attr = inferred.getattr(\"Foo\")[0]\n        self.assertIsInstance(class_def_attr, astroid.ClassDef)\n        attr_def = class_def_attr.getattr(\"bar\")[0]\n        attr = next(attr_def.infer())\n        self.assertEqual(attr.value, \"bar\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_namedtuple_nested_class", "self", "result", "builder", "extract_node", "from", "typing", "import", "namedtuple", "class", "example", "namedtuple", "class", "foo", "bar", "bar", "example", "inferred", "next", "result", "infer", "self", "assertisinstance", "inferred", "astroid", "classdef", "class_def_attr", "inferred", "getattr", "foo", "0", "self", "assertisinstance", "class_def_attr", "astroid", "classdef", "attr_def", "class_def_attr", "getattr", "bar", "0", "attr", "next", "attr_def", "infer", "self", "assertequal", "attr", "value", "bar"], "doc_len": 55}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_tuple_type", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_tuple_type", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_tuple_type(self):\n        node = builder.extract_node(\n            \"\"\"\n        from typing import Tuple\n        Tuple[int, int]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert isinstance(inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n        assert inferred.qname() == \"typing.Tuple\"\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_tuple_type", "self", "node", "builder", "extract_node", "from", "typing", "import", "tuple", "tuple", "int", "int", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "isinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "assert", "inferred", "qname", "typing", "tuple"], "doc_len": 39}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_callable_type", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_callable_type", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_callable_type(self):\n        node = builder.extract_node(\n            \"\"\"\n        from typing import Callable, Any\n        Callable[..., Any]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert isinstance(inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n        assert inferred.qname() == \"typing.Callable\"\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_callable_type", "self", "node", "builder", "extract_node", "from", "typing", "import", "callable", "any", "callable", "any", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "isinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "assert", "inferred", "qname", "typing", "callable"], "doc_len": 39}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_generic_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_generic_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_generic_subscriptable(self):\n        \"\"\"Test typing.Generic is subscriptable with __class_getitem__ (added in PY37)\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        Generic[T]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert isinstance(inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_generic_subscriptable", "self", "test", "typing", "generic", "is", "subscriptable", "with", "__class_getitem__", "added", "in", "py37", "node", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "generic", "t", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "isinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 47}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_annotated_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_annotated_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_annotated_subscriptable(self):\n        \"\"\"Test typing.Annotated is subscriptable with __class_getitem__\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import typing\n        typing.Annotated[str, \"data\"]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert isinstance(inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_annotated_subscriptable", "self", "test", "typing", "annotated", "is", "subscriptable", "with", "__class_getitem__", "node", "builder", "extract_node", "import", "typing", "typing", "annotated", "str", "data", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "isinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_generic_slots", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_generic_slots", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_generic_slots(self):\n        \"\"\"Test slots for Generic subclass.\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A(Generic[T]):\n            __slots__ = ['value']\n            def __init__(self, value):\n                self.value = value\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        slots = inferred.slots()\n        assert len(slots) == 1\n        assert isinstance(slots[0], nodes.Const)\n        assert slots[0].value == \"value\"\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_generic_slots", "self", "test", "slots", "for", "generic", "subclass", "node", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "generic", "t", "__slots__", "value", "def", "__init__", "self", "value", "self", "value", "value", "inferred", "next", "node", "infer", "slots", "inferred", "slots", "assert", "len", "slots", "1", "assert", "isinstance", "slots", "0", "nodes", "const", "assert", "slots", "0", "value", "value"], "doc_len": 58}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_has_dunder_args", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_has_dunder_args", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_has_dunder_args(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        from typing import Union\n        NumericTypes = Union[int, float]\n        NumericTypes.__args__ #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        assert isinstance(inferred, nodes.Tuple)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_has_dunder_args", "self", "none", "ast_node", "builder", "extract_node", "from", "typing", "import", "union", "numerictypes", "union", "int", "float", "numerictypes", "__args__", "inferred", "next", "ast_node", "infer", "assert", "isinstance", "inferred", "nodes", "tuple"], "doc_len": 30}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_namedtuple_dont_crash_on_no_fields", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_namedtuple_dont_crash_on_no_fields", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_namedtuple_dont_crash_on_no_fields(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from typing import NamedTuple\n\n        Bar = NamedTuple(\"bar\", [])\n\n        Bar()\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, astroid.Instance)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_namedtuple_dont_crash_on_no_fields", "self", "none", "node", "builder", "extract_node", "from", "typing", "import", "namedtuple", "bar", "namedtuple", "bar", "bar", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "instance"], "doc_len": 28}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typed_dict", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typed_dict", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typed_dict(self):\n        code = builder.extract_node(\n            \"\"\"\n        from typing import TypedDict\n        class CustomTD(TypedDict):  #@\n            var: int\n        CustomTD(var=1)  #@\n        \"\"\"\n        )\n        inferred_base = next(code[0].bases[0].infer())\n        assert isinstance(inferred_base, nodes.ClassDef)\n        assert inferred_base.qname() == \"typing.TypedDict\"\n        typedDict_base = next(inferred_base.bases[0].infer())\n        assert typedDict_base.qname() == \"builtins.dict\"\n\n        # Test TypedDict has `__call__` method\n        local_call = inferred_base.locals.get(\"__call__\", None)\n        assert local_call and len(local_call) == 1\n        assert isinstance(local_call[0], nodes.Name) and local_call[0].name == \"dict\"\n\n        # Test TypedDict instance is callable\n        assert next(code[1].infer()).callable() is True\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typed_dict", "self", "code", "builder", "extract_node", "from", "typing", "import", "typeddict", "class", "customtd", "typeddict", "var", "int", "customtd", "var", "1", "inferred_base", "next", "code", "0", "bases", "0", "infer", "assert", "isinstance", "inferred_base", "nodes", "classdef", "assert", "inferred_base", "qname", "typing", "typeddict", "typeddict_base", "next", "inferred_base", "bases", "0", "infer", "assert", "typeddict_base", "qname", "builtins", "dict", "test", "typeddict", "has", "__call__", "method", "local_call", "inferred_base", "locals", "get", "__call__", "none", "assert", "local_call", "and", "len", "local_call", "1", "assert", "isinstance", "local_call", "0", "nodes", "name", "and", "local_call", "0", "name", "dict", "test", "typeddict", "instance", "is", "callable", "assert", "next", "code", "1", "infer", "callable", "is", "true"], "doc_len": 91}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_alias_type", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_alias_type", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_alias_type(self):\n        \"\"\"\n        Test that the type aliased thanks to typing._alias function are\n        correctly inferred.\n        typing_alias function is introduced with python37\n        \"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        from typing import TypeVar, MutableSet\n\n        T = TypeVar(\"T\")\n        MutableSet[T]\n\n        class Derived1(MutableSet[T]):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \".Derived1\",\n                \"typing.MutableSet\",\n                \"_collections_abc.MutableSet\",\n                \"_collections_abc.Set\",\n                \"_collections_abc.Collection\",\n                \"_collections_abc.Sized\",\n                \"_collections_abc.Iterable\",\n                \"_collections_abc.Container\",\n                \"builtins.object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_alias_type", "self", "test", "that", "the", "type", "aliased", "thanks", "to", "typing", "_alias", "function", "are", "correctly", "inferred", "typing_alias", "function", "is", "introduced", "with", "python37", "node", "builder", "extract_node", "from", "typing", "import", "typevar", "mutableset", "t", "typevar", "t", "mutableset", "t", "class", "derived1", "mutableset", "t", "pass", "inferred", "next", "node", "infer", "assertequalmro", "inferred", "derived1", "typing", "mutableset", "_collections_abc", "mutableset", "_collections_abc", "set", "_collections_abc", "collection", "_collections_abc", "sized", "_collections_abc", "iterable", "_collections_abc", "container", "builtins", "object"], "doc_len": 67}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_alias_type_2", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_alias_type_2", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_alias_type_2(self):\n        \"\"\"\n        Test that the type aliased thanks to typing._alias function are\n        correctly inferred.\n        typing_alias function is introduced with python37.\n        OrderedDict in the typing module appears only with python 3.7.2\n        \"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import typing\n        class Derived2(typing.OrderedDict[int, str]):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \".Derived2\",\n                \"typing.OrderedDict\",\n                \"collections.OrderedDict\",\n                \"builtins.dict\",\n                \"builtins.object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_alias_type_2", "self", "test", "that", "the", "type", "aliased", "thanks", "to", "typing", "_alias", "function", "are", "correctly", "inferred", "typing_alias", "function", "is", "introduced", "with", "python37", "ordereddict", "in", "the", "typing", "module", "appears", "only", "with", "python", "3", "7", "2", "node", "builder", "extract_node", "import", "typing", "class", "derived2", "typing", "ordereddict", "int", "str", "pass", "inferred", "next", "node", "infer", "assertequalmro", "inferred", "derived2", "typing", "ordereddict", "collections", "ordereddict", "builtins", "dict", "builtins", "object"], "doc_len": 65}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_object_not_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_object_not_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_object_not_subscriptable(self):\n        \"\"\"Hashable is not subscriptable\"\"\"\n        wrong_node = builder.extract_node(\n            \"\"\"\n        import typing\n        typing.Hashable[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(wrong_node.infer())\n        right_node = builder.extract_node(\n            \"\"\"\n        import typing\n        typing.Hashable\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \"typing.Hashable\",\n                \"_collections_abc.Hashable\",\n                \"builtins.object\",\n            ],\n        )\n        with self.assertRaises(AttributeInferenceError):\n            inferred.getattr(\"__class_getitem__\")\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_object_not_subscriptable", "self", "hashable", "is", "not", "subscriptable", "wrong_node", "builder", "extract_node", "import", "typing", "typing", "hashable", "int", "with", "self", "assertraises", "inferenceerror", "next", "wrong_node", "infer", "right_node", "builder", "extract_node", "import", "typing", "typing", "hashable", "inferred", "next", "right_node", "infer", "assertequalmro", "inferred", "typing", "hashable", "_collections_abc", "hashable", "builtins", "object", "with", "self", "assertraises", "attributeinferenceerror", "inferred", "getattr", "__class_getitem__"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_object_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_object_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_object_subscriptable(self):\n        \"\"\"Test that MutableSet is subscriptable\"\"\"\n        right_node = builder.extract_node(\n            \"\"\"\n        import typing\n        typing.MutableSet[int]\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \"typing.MutableSet\",\n                \"_collections_abc.MutableSet\",\n                \"_collections_abc.Set\",\n                \"_collections_abc.Collection\",\n                \"_collections_abc.Sized\",\n                \"_collections_abc.Iterable\",\n                \"_collections_abc.Container\",\n                \"builtins.object\",\n            ],\n        )\n        self.assertIsInstance(\n            inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n        )\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_object_subscriptable", "self", "test", "that", "mutableset", "is", "subscriptable", "right_node", "builder", "extract_node", "import", "typing", "typing", "mutableset", "int", "inferred", "next", "right_node", "infer", "assertequalmro", "inferred", "typing", "mutableset", "_collections_abc", "mutableset", "_collections_abc", "set", "_collections_abc", "collection", "_collections_abc", "sized", "_collections_abc", "iterable", "_collections_abc", "container", "builtins", "object", "self", "assertisinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_object_subscriptable_2", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_object_subscriptable_2", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_object_subscriptable_2(self):\n        \"\"\"Multiple inheritance with subscriptable typing alias\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import typing\n        class Derived(typing.Hashable, typing.Iterator[int]):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assertEqualMro(\n            inferred,\n            [\n                \".Derived\",\n                \"typing.Hashable\",\n                \"_collections_abc.Hashable\",\n                \"typing.Iterator\",\n                \"_collections_abc.Iterator\",\n                \"_collections_abc.Iterable\",\n                \"builtins.object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_object_subscriptable_2", "self", "multiple", "inheritance", "with", "subscriptable", "typing", "alias", "node", "builder", "extract_node", "import", "typing", "class", "derived", "typing", "hashable", "typing", "iterator", "int", "pass", "inferred", "next", "node", "infer", "assertequalmro", "inferred", "derived", "typing", "hashable", "_collections_abc", "hashable", "typing", "iterator", "_collections_abc", "iterator", "_collections_abc", "iterable", "builtins", "object"], "doc_len": 45}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_object_notsubscriptable_3", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_object_notsubscriptable_3", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_object_notsubscriptable_3(self):\n        \"\"\"Until python39 ByteString class of the typing module is not subscritable (whereas it is in the collections module)\"\"\"\n        right_node = builder.extract_node(\n            \"\"\"\n        import typing\n        typing.ByteString\n        \"\"\"\n        )\n        inferred = next(right_node.infer())\n        check_metaclass_is_abc(inferred)\n        with self.assertRaises(AttributeInferenceError):\n            self.assertIsInstance(\n                inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n            )\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_object_notsubscriptable_3", "self", "until", "python39", "bytestring", "class", "of", "the", "typing", "module", "is", "not", "subscritable", "whereas", "it", "is", "in", "the", "collections", "module", "right_node", "builder", "extract_node", "import", "typing", "typing", "bytestring", "inferred", "next", "right_node", "infer", "check_metaclass_is_abc", "inferred", "with", "self", "assertraises", "attributeinferenceerror", "self", "assertisinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 50}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_object_builtin_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_object_builtin_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_object_builtin_subscriptable(self):\n        \"\"\"\n        Test that builtins alias, such as typing.List, are subscriptable\n        \"\"\"\n        for typename in (\"List\", \"Dict\", \"Set\", \"FrozenSet\", \"Tuple\"):\n            src = f\"\"\"\n            import typing\n            typing.{typename:s}[int]\n            \"\"\"\n            right_node = builder.extract_node(src)\n            inferred = next(right_node.infer())\n            self.assertIsInstance(inferred, nodes.ClassDef)\n            self.assertIsInstance(inferred.getattr(\"__iter__\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_object_builtin_subscriptable", "self", "test", "that", "builtins", "alias", "such", "as", "typing", "list", "are", "subscriptable", "for", "typename", "in", "list", "dict", "set", "frozenset", "tuple", "src", "f", "import", "typing", "typing", "typename", "s", "int", "right_node", "builder", "extract_node", "src", "inferred", "next", "right_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertisinstance", "inferred", "getattr", "__iter__", "0", "nodes", "functiondef"], "doc_len": 54}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_type_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_type_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_type_subscriptable():\n        node = builder.extract_node(\n            \"\"\"\n        from typing import Type\n        Type[int]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.ClassDef)\n        assert isinstance(inferred.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n        assert inferred.qname() == \"typing.Type\"\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_type_subscriptable", "node", "builder", "extract_node", "from", "typing", "import", "type", "type", "int", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "isinstance", "inferred", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "assert", "inferred", "qname", "typing", "type"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_cast", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_cast", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_cast(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from typing import cast\n        class A:\n            pass\n\n        b = 42\n        a = cast(A, b)\n        a\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 42\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_cast", "self", "none", "node", "builder", "extract_node", "from", "typing", "import", "cast", "class", "a", "pass", "b", "42", "a", "cast", "a", "b", "a", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42"], "doc_len": 38}
{"doc_id": "tests/unittest_brain.py::TypingBrain.test_typing_cast_attribute", "file_path": "tests/unittest_brain.py", "class_name": "TypingBrain", "func_name": "test_typing_cast_attribute", "text": "文件路径: tests/unittest_brain.py, 类名: TypingBrain\n    def test_typing_cast_attribute(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        import typing\n        class A:\n            pass\n\n        b = 42\n        a = typing.cast(A, b)\n        a\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 42\n", "tokens": ["tests", "unittest_brain", "py", "typingbrain", "def", "test_typing_cast_attribute", "self", "none", "node", "builder", "extract_node", "import", "typing", "class", "a", "pass", "b", "42", "a", "typing", "cast", "a", "b", "a", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::ReBrainTest.test_regex_flags", "file_path": "tests/unittest_brain.py", "class_name": "ReBrainTest", "func_name": "test_regex_flags", "text": "文件路径: tests/unittest_brain.py, 类名: ReBrainTest\n    def test_regex_flags(self) -> None:\n        names = [name for name in dir(re) if name.isupper()]\n        re_ast = MANAGER.ast_from_module_name(\"re\")\n        for name in names:\n            self.assertIn(name, re_ast)\n            self.assertEqual(next(re_ast[name].infer()).value, getattr(re, name))\n", "tokens": ["tests", "unittest_brain", "py", "rebraintest", "def", "test_regex_flags", "self", "none", "names", "name", "for", "name", "in", "dir", "re", "if", "name", "isupper", "re_ast", "manager", "ast_from_module_name", "re", "for", "name", "in", "names", "self", "assertin", "name", "re_ast", "self", "assertequal", "next", "re_ast", "name", "infer", "value", "getattr", "re", "name"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::ReBrainTest.test_re_pattern_unsubscriptable", "file_path": "tests/unittest_brain.py", "class_name": "ReBrainTest", "func_name": "test_re_pattern_unsubscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: ReBrainTest\n    def test_re_pattern_unsubscriptable(self):\n        \"\"\"\n        re.Pattern and re.Match are unsubscriptable until PY39.\n        re.Pattern and re.Match were added in PY37.\n        \"\"\"\n        right_node1 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Pattern\n        \"\"\"\n        )\n        inferred1 = next(right_node1.infer())\n        assert isinstance(inferred1, nodes.ClassDef)\n        with self.assertRaises(AttributeInferenceError):\n            assert isinstance(\n                inferred1.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n            )\n\n        right_node2 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Pattern\n        \"\"\"\n        )\n        inferred2 = next(right_node2.infer())\n        assert isinstance(inferred2, nodes.ClassDef)\n        with self.assertRaises(AttributeInferenceError):\n            assert isinstance(\n                inferred2.getattr(\"__class_getitem__\")[0], nodes.FunctionDef\n            )\n\n        wrong_node1 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Pattern[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(wrong_node1.infer())\n\n        wrong_node2 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Match[int]\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(wrong_node2.infer())\n", "tokens": ["tests", "unittest_brain", "py", "rebraintest", "def", "test_re_pattern_unsubscriptable", "self", "re", "pattern", "and", "re", "match", "are", "unsubscriptable", "until", "py39", "re", "pattern", "and", "re", "match", "were", "added", "in", "py37", "right_node1", "builder", "extract_node", "import", "re", "re", "pattern", "inferred1", "next", "right_node1", "infer", "assert", "isinstance", "inferred1", "nodes", "classdef", "with", "self", "assertraises", "attributeinferenceerror", "assert", "isinstance", "inferred1", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "right_node2", "builder", "extract_node", "import", "re", "re", "pattern", "inferred2", "next", "right_node2", "infer", "assert", "isinstance", "inferred2", "nodes", "classdef", "with", "self", "assertraises", "attributeinferenceerror", "assert", "isinstance", "inferred2", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "wrong_node1", "builder", "extract_node", "import", "re", "re", "pattern", "int", "with", "self", "assertraises", "inferenceerror", "next", "wrong_node1", "infer", "wrong_node2", "builder", "extract_node", "import", "re", "re", "match", "int", "with", "self", "assertraises", "inferenceerror", "next", "wrong_node2", "infer"], "doc_len": 111}
{"doc_id": "tests/unittest_brain.py::ReBrainTest.test_re_pattern_subscriptable", "file_path": "tests/unittest_brain.py", "class_name": "ReBrainTest", "func_name": "test_re_pattern_subscriptable", "text": "文件路径: tests/unittest_brain.py, 类名: ReBrainTest\n    def test_re_pattern_subscriptable(self):\n        \"\"\"Test re.Pattern and re.Match are subscriptable in PY39+\"\"\"\n        node1 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Pattern[str]\n        \"\"\"\n        )\n        inferred1 = next(node1.infer())\n        assert isinstance(inferred1, nodes.ClassDef)\n        assert isinstance(inferred1.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n\n        node2 = builder.extract_node(\n            \"\"\"\n        import re\n        re.Match[str]\n        \"\"\"\n        )\n        inferred2 = next(node2.infer())\n        assert isinstance(inferred2, nodes.ClassDef)\n        assert isinstance(inferred2.getattr(\"__class_getitem__\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain", "py", "rebraintest", "def", "test_re_pattern_subscriptable", "self", "test", "re", "pattern", "and", "re", "match", "are", "subscriptable", "in", "py39", "node1", "builder", "extract_node", "import", "re", "re", "pattern", "str", "inferred1", "next", "node1", "infer", "assert", "isinstance", "inferred1", "nodes", "classdef", "assert", "isinstance", "inferred1", "getattr", "__class_getitem__", "0", "nodes", "functiondef", "node2", "builder", "extract_node", "import", "re", "re", "match", "str", "inferred2", "next", "node2", "infer", "assert", "isinstance", "inferred2", "nodes", "classdef", "assert", "isinstance", "inferred2", "getattr", "__class_getitem__", "0", "nodes", "functiondef"], "doc_len": 67}
{"doc_id": "tests/unittest_brain.py::BrainFStrings.test_no_crash_on_const_reconstruction", "file_path": "tests/unittest_brain.py", "class_name": "BrainFStrings", "func_name": "test_no_crash_on_const_reconstruction", "text": "文件路径: tests/unittest_brain.py, 类名: BrainFStrings\n    def test_no_crash_on_const_reconstruction(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        max_width = 10\n\n        test1 = f'{\" \":{max_width+4}}'\n        print(f'\"{test1}\"')\n\n        test2 = f'[{\"7\":>{max_width}}:0]'\n        test2\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_brain", "py", "brainfstrings", "def", "test_no_crash_on_const_reconstruction", "self", "none", "node", "builder", "extract_node", "max_width", "10", "test1", "f", "max_width", "4", "print", "f", "test1", "test2", "f", "7", "max_width", "0", "test2", "inferred", "next", "node", "infer", "self", "assertis", "inferred", "util", "uninferable"], "doc_len": 35}
{"doc_id": "tests/unittest_brain.py::BrainNamedtupleAnnAssignTest.test_no_crash_on_ann_assign_in_namedtuple", "file_path": "tests/unittest_brain.py", "class_name": "BrainNamedtupleAnnAssignTest", "func_name": "test_no_crash_on_ann_assign_in_namedtuple", "text": "文件路径: tests/unittest_brain.py, 类名: BrainNamedtupleAnnAssignTest\n    def test_no_crash_on_ann_assign_in_namedtuple(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from enum import Enum\n        from typing import Optional\n\n        class A(Enum):\n            B: str = 'B'\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n", "tokens": ["tests", "unittest_brain", "py", "brainnamedtupleannassigntest", "def", "test_no_crash_on_ann_assign_in_namedtuple", "self", "none", "node", "builder", "extract_node", "from", "enum", "import", "enum", "from", "typing", "import", "optional", "class", "a", "enum", "b", "str", "b", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef"], "doc_len": 34}
{"doc_id": "tests/unittest_brain.py::BrainUUIDTest.test_uuid_has_int_member", "file_path": "tests/unittest_brain.py", "class_name": "BrainUUIDTest", "func_name": "test_uuid_has_int_member", "text": "文件路径: tests/unittest_brain.py, 类名: BrainUUIDTest\n    def test_uuid_has_int_member(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        import uuid\n        u = uuid.UUID('{12345678-1234-5678-1234-567812345678}')\n        u.int\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n", "tokens": ["tests", "unittest_brain", "py", "brainuuidtest", "def", "test_uuid_has_int_member", "self", "none", "node", "builder", "extract_node", "import", "uuid", "u", "uuid", "uuid", "12345678", "1234", "5678", "1234", "567812345678", "u", "int", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::AttrsTest.test_attr_transform", "file_path": "tests/unittest_brain.py", "class_name": "AttrsTest", "func_name": "test_attr_transform", "text": "文件路径: tests/unittest_brain.py, 类名: AttrsTest\n    def test_attr_transform(self) -> None:\n        module = astroid.parse(\n            \"\"\"\n        import attr\n        from attr import attrs, attrib, field\n\n        @attr.s\n        class Foo:\n\n            d = attr.ib(attr.Factory(dict))\n\n        f = Foo()\n        f.d['answer'] = 42\n\n        @attr.s(slots=True)\n        class Bar:\n            d = attr.ib(attr.Factory(dict))\n\n        g = Bar()\n        g.d['answer'] = 42\n\n        @attrs\n        class Bah:\n            d = attrib(attr.Factory(dict))\n\n        h = Bah()\n        h.d['answer'] = 42\n\n        @attr.attrs\n        class Bai:\n            d = attr.attrib(attr.Factory(dict))\n\n        i = Bai()\n        i.d['answer'] = 42\n\n        @attr.define\n        class Spam:\n            d = field(default=attr.Factory(dict))\n\n        j = Spam(d=1)\n        j.d['answer'] = 42\n\n        @attr.mutable\n        class Eggs:\n            d = attr.field(default=attr.Factory(dict))\n\n        k = Eggs(d=1)\n        k.d['answer'] = 42\n\n        @attr.frozen\n        class Eggs:\n            d = attr.field(default=attr.Factory(dict))\n\n        l = Eggs(d=1)\n        l.d['answer'] = 42\n        \"\"\"\n        )\n\n        for name in (\"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"):\n            should_be_unknown = next(module.getattr(name)[0].infer()).getattr(\"d\")[0]\n            self.assertIsInstance(should_be_unknown, astroid.Unknown)\n", "tokens": ["tests", "unittest_brain", "py", "attrstest", "def", "test_attr_transform", "self", "none", "module", "astroid", "parse", "import", "attr", "from", "attr", "import", "attrs", "attrib", "field", "attr", "s", "class", "foo", "d", "attr", "ib", "attr", "factory", "dict", "f", "foo", "f", "d", "answer", "42", "attr", "s", "slots", "true", "class", "bar", "d", "attr", "ib", "attr", "factory", "dict", "g", "bar", "g", "d", "answer", "42", "attrs", "class", "bah", "d", "attrib", "attr", "factory", "dict", "h", "bah", "h", "d", "answer", "42", "attr", "attrs", "class", "bai", "d", "attr", "attrib", "attr", "factory", "dict", "i", "bai", "i", "d", "answer", "42", "attr", "define", "class", "spam", "d", "field", "default", "attr", "factory", "dict", "j", "spam", "d", "1", "j", "d", "answer", "42", "attr", "mutable", "class", "eggs", "d", "attr", "field", "default", "attr", "factory", "dict", "k", "eggs", "d", "1", "k", "d", "answer", "42", "attr", "frozen", "class", "eggs", "d", "attr", "field", "default", "attr", "factory", "dict", "l", "eggs", "d", "1", "l", "d", "answer", "42", "for", "name", "in", "f", "g", "h", "i", "j", "k", "l", "should_be_unknown", "next", "module", "getattr", "name", "0", "infer", "getattr", "d", "0", "self", "assertisinstance", "should_be_unknown", "astroid", "unknown"], "doc_len": 164}
{"doc_id": "tests/unittest_brain.py::AttrsTest.test_special_attributes", "file_path": "tests/unittest_brain.py", "class_name": "AttrsTest", "func_name": "test_special_attributes", "text": "文件路径: tests/unittest_brain.py, 类名: AttrsTest\n    def test_special_attributes(self) -> None:\n        \"\"\"Make sure special attrs attributes exist\"\"\"\n\n        code = \"\"\"\n        import attr\n\n        @attr.s\n        class Foo:\n            pass\n        Foo()\n        \"\"\"\n        foo_inst = next(astroid.extract_node(code).infer())\n        [attr_node] = foo_inst.getattr(\"__attrs_attrs__\")\n        # Prevents https://github.com/PyCQA/pylint/issues/1884\n        assert isinstance(attr_node, nodes.Unknown)\n", "tokens": ["tests", "unittest_brain", "py", "attrstest", "def", "test_special_attributes", "self", "none", "make", "sure", "special", "attrs", "attributes", "exist", "code", "import", "attr", "attr", "s", "class", "foo", "pass", "foo", "foo_inst", "next", "astroid", "extract_node", "code", "infer", "attr_node", "foo_inst", "getattr", "__attrs_attrs__", "prevents", "https", "github", "com", "pycqa", "pylint", "issues", "1884", "assert", "isinstance", "attr_node", "nodes", "unknown"], "doc_len": 46}
{"doc_id": "tests/unittest_brain.py::AttrsTest.test_dont_consider_assignments_but_without_attrs", "file_path": "tests/unittest_brain.py", "class_name": "AttrsTest", "func_name": "test_dont_consider_assignments_but_without_attrs", "text": "文件路径: tests/unittest_brain.py, 类名: AttrsTest\n    def test_dont_consider_assignments_but_without_attrs(self) -> None:\n        code = \"\"\"\n        import attr\n\n        class Cls: pass\n        @attr.s\n        class Foo:\n            temp = Cls()\n            temp.prop = 5\n            bar_thing = attr.ib(default=temp)\n        Foo()\n        \"\"\"\n        next(astroid.extract_node(code).infer())\n", "tokens": ["tests", "unittest_brain", "py", "attrstest", "def", "test_dont_consider_assignments_but_without_attrs", "self", "none", "code", "import", "attr", "class", "cls", "pass", "attr", "s", "class", "foo", "temp", "cls", "temp", "prop", "5", "bar_thing", "attr", "ib", "default", "temp", "foo", "next", "astroid", "extract_node", "code", "infer"], "doc_len": 34}
{"doc_id": "tests/unittest_brain.py::AttrsTest.test_attrs_with_annotation", "file_path": "tests/unittest_brain.py", "class_name": "AttrsTest", "func_name": "test_attrs_with_annotation", "text": "文件路径: tests/unittest_brain.py, 类名: AttrsTest\n    def test_attrs_with_annotation(self) -> None:\n        code = \"\"\"\n        import attr\n\n        @attr.s\n        class Foo:\n            bar: int = attr.ib(default=5)\n        Foo()\n        \"\"\"\n        should_be_unknown = next(astroid.extract_node(code).infer()).getattr(\"bar\")[0]\n        self.assertIsInstance(should_be_unknown, astroid.Unknown)\n", "tokens": ["tests", "unittest_brain", "py", "attrstest", "def", "test_attrs_with_annotation", "self", "none", "code", "import", "attr", "attr", "s", "class", "foo", "bar", "int", "attr", "ib", "default", "5", "foo", "should_be_unknown", "next", "astroid", "extract_node", "code", "infer", "getattr", "bar", "0", "self", "assertisinstance", "should_be_unknown", "astroid", "unknown"], "doc_len": 36}
{"doc_id": "tests/unittest_brain.py::RandomSampleTest.test_inferred_successfully", "file_path": "tests/unittest_brain.py", "class_name": "RandomSampleTest", "func_name": "test_inferred_successfully", "text": "文件路径: tests/unittest_brain.py, 类名: RandomSampleTest\n    def test_inferred_successfully(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        import random\n        random.sample([1, 2], 2) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, astroid.List)\n        elems = sorted(elem.value for elem in inferred.elts)\n        self.assertEqual(elems, [1, 2])\n", "tokens": ["tests", "unittest_brain", "py", "randomsampletest", "def", "test_inferred_successfully", "self", "none", "node", "astroid", "extract_node", "import", "random", "random", "sample", "1", "2", "2", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "list", "elems", "sorted", "elem", "value", "for", "elem", "in", "inferred", "elts", "self", "assertequal", "elems", "1", "2"], "doc_len": 41}
{"doc_id": "tests/unittest_brain.py::RandomSampleTest.test_no_crash_on_evaluatedobject", "file_path": "tests/unittest_brain.py", "class_name": "RandomSampleTest", "func_name": "test_no_crash_on_evaluatedobject", "text": "文件路径: tests/unittest_brain.py, 类名: RandomSampleTest\n    def test_no_crash_on_evaluatedobject(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        from random import sample\n        class A: pass\n        sample(list({1: A()}.values()), 1)\"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.List)\n        assert len(inferred.elts) == 1\n        assert isinstance(inferred.elts[0], nodes.Call)\n", "tokens": ["tests", "unittest_brain", "py", "randomsampletest", "def", "test_no_crash_on_evaluatedobject", "self", "none", "node", "astroid", "extract_node", "from", "random", "import", "sample", "class", "a", "pass", "sample", "list", "1", "a", "values", "1", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "list", "assert", "len", "inferred", "elts", "1", "assert", "isinstance", "inferred", "elts", "0", "nodes", "call"], "doc_len": 45}
{"doc_id": "tests/unittest_brain.py::SubprocessTest.test_subprocess_args", "file_path": "tests/unittest_brain.py", "class_name": "SubprocessTest", "func_name": "test_subprocess_args", "text": "文件路径: tests/unittest_brain.py, 类名: SubprocessTest\n    def test_subprocess_args(self) -> None:\n        \"\"\"Make sure the args attribute exists for Popen\n\n        Test for https://github.com/PyCQA/pylint/issues/1860\"\"\"\n        name = astroid.extract_node(\n            \"\"\"\n        import subprocess\n        p = subprocess.Popen(['ls'])\n        p #@\n        \"\"\"\n        )\n        [inst] = name.inferred()\n        self.assertIsInstance(next(inst.igetattr(\"args\")), nodes.List)\n", "tokens": ["tests", "unittest_brain", "py", "subprocesstest", "def", "test_subprocess_args", "self", "none", "make", "sure", "the", "args", "attribute", "exists", "for", "popen", "test", "for", "https", "github", "com", "pycqa", "pylint", "issues", "1860", "name", "astroid", "extract_node", "import", "subprocess", "p", "subprocess", "popen", "ls", "p", "inst", "name", "inferred", "self", "assertisinstance", "next", "inst", "igetattr", "args", "nodes", "list"], "doc_len": 46}
{"doc_id": "tests/unittest_brain.py::SubprocessTest.test_subprcess_check_output", "file_path": "tests/unittest_brain.py", "class_name": "SubprocessTest", "func_name": "test_subprcess_check_output", "text": "文件路径: tests/unittest_brain.py, 类名: SubprocessTest\n    def test_subprcess_check_output(self) -> None:\n        code = \"\"\"\n        import subprocess\n\n        subprocess.check_output(['echo', 'hello']);\n        \"\"\"\n        node = astroid.extract_node(code)\n        inferred = next(node.infer())\n        # Can be either str or bytes\n        assert isinstance(inferred, astroid.Const)\n        assert isinstance(inferred.value, (str, bytes))\n", "tokens": ["tests", "unittest_brain", "py", "subprocesstest", "def", "test_subprcess_check_output", "self", "none", "code", "import", "subprocess", "subprocess", "check_output", "echo", "hello", "node", "astroid", "extract_node", "code", "inferred", "next", "node", "infer", "can", "be", "either", "str", "or", "bytes", "assert", "isinstance", "inferred", "astroid", "const", "assert", "isinstance", "inferred", "value", "str", "bytes"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::SubprocessTest.test_popen_does_not_have_class_getitem", "file_path": "tests/unittest_brain.py", "class_name": "SubprocessTest", "func_name": "test_popen_does_not_have_class_getitem", "text": "文件路径: tests/unittest_brain.py, 类名: SubprocessTest\n    def test_popen_does_not_have_class_getitem(self):\n        code = \"\"\"import subprocess; subprocess.Popen\"\"\"\n        node = astroid.extract_node(code)\n        inferred = next(node.infer())\n        assert \"__class_getitem__\" in inferred\n", "tokens": ["tests", "unittest_brain", "py", "subprocesstest", "def", "test_popen_does_not_have_class_getitem", "self", "code", "import", "subprocess", "subprocess", "popen", "node", "astroid", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "__class_getitem__", "in", "inferred"], "doc_len": 24}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_type_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_type_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_type_type(self) -> None:\n        assert _get_result(\"isinstance(type, type)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_type_type", "self", "none", "assert", "_get_result", "isinstance", "type", "type", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_object_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_object_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_object_type(self) -> None:\n        assert _get_result(\"isinstance(object, type)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_object_type", "self", "none", "assert", "_get_result", "isinstance", "object", "type", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_type_object", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_type_object", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_type_object(self) -> None:\n        assert _get_result(\"isinstance(type, object)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_type_object", "self", "none", "assert", "_get_result", "isinstance", "type", "object", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_int_true", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_int_true", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_int_true(self) -> None:\n        \"\"\"Make sure isinstance can check builtin int types\"\"\"\n        assert _get_result(\"isinstance(1, int)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_int_true", "self", "none", "make", "sure", "isinstance", "can", "check", "builtin", "int", "types", "assert", "_get_result", "isinstance", "1", "int", "true"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_int_false", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_int_false", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_int_false(self) -> None:\n        assert _get_result(\"isinstance('a', int)\") == \"False\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_int_false", "self", "none", "assert", "_get_result", "isinstance", "a", "int", "false"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_object_true", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_object_true", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_object_true(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        isinstance(Bar(), object)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_object_true", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "isinstance", "bar", "object", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_object_true3", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_object_true3", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_object_true3(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        isinstance(Bar(), Bar)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_object_true3", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "isinstance", "bar", "bar", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_class_false", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_class_false", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_class_false(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Foo(object):\n            pass\n        class Bar(object):\n            pass\n        isinstance(Bar(), Foo)\n        \"\"\"\n            )\n            == \"False\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_class_false", "self", "none", "assert", "_get_result", "class", "foo", "object", "pass", "class", "bar", "object", "pass", "isinstance", "bar", "foo", "false"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_type_false", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_type_false", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_type_false(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        isinstance(Bar(), type)\n        \"\"\"\n            )\n            == \"False\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_type_false", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "isinstance", "bar", "type", "false"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_str_true", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_str_true", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_str_true(self) -> None:\n        \"\"\"Make sure isinstance can check builtin str types\"\"\"\n        assert _get_result(\"isinstance('a', str)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_str_true", "self", "none", "make", "sure", "isinstance", "can", "check", "builtin", "str", "types", "assert", "_get_result", "isinstance", "a", "str", "true"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_str_false", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_str_false", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_str_false(self) -> None:\n        assert _get_result(\"isinstance(1, str)\") == \"False\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_str_false", "self", "none", "assert", "_get_result", "isinstance", "1", "str", "false"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_tuple_argument", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_tuple_argument", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_tuple_argument(self) -> None:\n        \"\"\"obj just has to be an instance of ANY class/type on the right\"\"\"\n        assert _get_result(\"isinstance(1, (str, int))\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_tuple_argument", "self", "none", "obj", "just", "has", "to", "be", "an", "instance", "of", "any", "class", "type", "on", "the", "right", "assert", "_get_result", "isinstance", "1", "str", "int", "true"], "doc_len": 29}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_type_false2", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_type_false2", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_type_false2(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        isinstance(1, type)\n        \"\"\"\n            )\n            == \"False\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_type_false2", "self", "none", "assert", "_get_result", "isinstance", "1", "type", "false"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_object_true2", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_object_true2", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_object_true2(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(type):\n            pass\n        mainbar = Bar(\"Bar\", tuple(), {})\n        isinstance(mainbar, object)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_object_true2", "self", "none", "assert", "_get_result", "class", "bar", "type", "pass", "mainbar", "bar", "bar", "tuple", "isinstance", "mainbar", "object", "true"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_type_true", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_type_true", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_type_true(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(type):\n            pass\n        mainbar = Bar(\"Bar\", tuple(), {})\n        isinstance(mainbar, type)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_type_true", "self", "none", "assert", "_get_result", "class", "bar", "type", "pass", "mainbar", "bar", "bar", "tuple", "isinstance", "mainbar", "type", "true"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_isinstance_edge_case", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_isinstance_edge_case", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_isinstance_edge_case(self) -> None:\n        \"\"\"isinstance allows bad type short-circuting\"\"\"\n        assert _get_result(\"isinstance(1, (int, 1))\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_isinstance_edge_case", "self", "none", "isinstance", "allows", "bad", "type", "short", "circuting", "assert", "_get_result", "isinstance", "1", "int", "1", "true"], "doc_len": 21}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_uninferable_bad_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_uninferable_bad_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_uninferable_bad_type(self) -> None:\n        \"\"\"The second argument must be a class or a tuple of classes\"\"\"\n        with pytest.raises(InferenceError):\n            _get_result_node(\"isinstance(int, 1)\")\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_uninferable_bad_type", "self", "none", "the", "second", "argument", "must", "be", "a", "class", "or", "a", "tuple", "of", "classes", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "isinstance", "int", "1"], "doc_len": 28}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_uninferable_keywords", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_uninferable_keywords", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_uninferable_keywords(self) -> None:\n        \"\"\"isinstance does not allow keywords\"\"\"\n        with pytest.raises(InferenceError):\n            _get_result_node(\"isinstance(1, class_or_tuple=int)\")\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_uninferable_keywords", "self", "none", "isinstance", "does", "not", "allow", "keywords", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "isinstance", "1", "class_or_tuple", "int"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_too_many_args", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_too_many_args", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_too_many_args(self) -> None:\n        \"\"\"isinstance must have two arguments\"\"\"\n        with pytest.raises(InferenceError):\n            _get_result_node(\"isinstance(1, int, str)\")\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_too_many_args", "self", "none", "isinstance", "must", "have", "two", "arguments", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "isinstance", "1", "int", "str"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIsinstanceInference.test_first_param_is_uninferable", "file_path": "tests/unittest_brain.py", "class_name": "TestIsinstanceInference", "func_name": "test_first_param_is_uninferable", "text": "文件路径: tests/unittest_brain.py, 类名: TestIsinstanceInference\n    def test_first_param_is_uninferable(self) -> None:\n        with pytest.raises(InferenceError):\n            _get_result_node(\"isinstance(something, int)\")\n", "tokens": ["tests", "unittest_brain", "py", "testisinstanceinference", "def", "test_first_param_is_uninferable", "self", "none", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "isinstance", "something", "int"], "doc_len": 16}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_type_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_type_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_type_type(self) -> None:\n        assert _get_result(\"issubclass(type, type)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_type_type", "self", "none", "assert", "_get_result", "issubclass", "type", "type", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_object_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_object_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_object_type(self) -> None:\n        assert _get_result(\"issubclass(object, type)\") == \"False\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_object_type", "self", "none", "assert", "_get_result", "issubclass", "object", "type", "false"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_type_object", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_type_object", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_type_object(self) -> None:\n        assert _get_result(\"issubclass(type, object)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_type_object", "self", "none", "assert", "_get_result", "issubclass", "type", "object", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_same_class", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_same_class", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_same_class(self) -> None:\n        assert _get_result(\"issubclass(int, int)\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_same_class", "self", "none", "assert", "_get_result", "issubclass", "int", "int", "true"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_not_the_same_class", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_not_the_same_class", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_not_the_same_class(self) -> None:\n        assert _get_result(\"issubclass(str, int)\") == \"False\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_not_the_same_class", "self", "none", "assert", "_get_result", "issubclass", "str", "int", "false"], "doc_len": 14}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_object_true", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_object_true", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_object_true(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        issubclass(Bar, object)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_object_true", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "issubclass", "bar", "object", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_same_user_defined_class", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_same_user_defined_class", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_same_user_defined_class(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        issubclass(Bar, Bar)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_same_user_defined_class", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "issubclass", "bar", "bar", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_different_user_defined_classes", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_different_user_defined_classes", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_different_user_defined_classes(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Foo(object):\n            pass\n        class Bar(object):\n            pass\n        issubclass(Bar, Foo)\n        \"\"\"\n            )\n            == \"False\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_different_user_defined_classes", "self", "none", "assert", "_get_result", "class", "foo", "object", "pass", "class", "bar", "object", "pass", "issubclass", "bar", "foo", "false"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_type_false", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_type_false", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_type_false(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(object):\n            pass\n        issubclass(Bar, type)\n        \"\"\"\n            )\n            == \"False\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_type_false", "self", "none", "assert", "_get_result", "class", "bar", "object", "pass", "issubclass", "bar", "type", "false"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_isinstance_tuple_argument", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_isinstance_tuple_argument", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_isinstance_tuple_argument(self) -> None:\n        \"\"\"obj just has to be a subclass of ANY class/type on the right\"\"\"\n        assert _get_result(\"issubclass(int, (str, int))\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_isinstance_tuple_argument", "self", "none", "obj", "just", "has", "to", "be", "a", "subclass", "of", "any", "class", "type", "on", "the", "right", "assert", "_get_result", "issubclass", "int", "str", "int", "true"], "doc_len": 29}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_isinstance_object_true2", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_isinstance_object_true2", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_isinstance_object_true2(self) -> None:\n        assert (\n            _get_result(\n                \"\"\"\n        class Bar(type):\n            pass\n        issubclass(Bar, object)\n        \"\"\"\n            )\n            == \"True\"\n        )\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_isinstance_object_true2", "self", "none", "assert", "_get_result", "class", "bar", "type", "pass", "issubclass", "bar", "object", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_issubclass_short_circuit", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_issubclass_short_circuit", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_issubclass_short_circuit(self) -> None:\n        \"\"\"issubclasss allows bad type short-circuting\"\"\"\n        assert _get_result(\"issubclass(int, (int, 1))\") == \"True\"\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_issubclass_short_circuit", "self", "none", "issubclasss", "allows", "bad", "type", "short", "circuting", "assert", "_get_result", "issubclass", "int", "int", "1", "true"], "doc_len": 21}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_uninferable_bad_type", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_uninferable_bad_type", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_uninferable_bad_type(self) -> None:\n        \"\"\"The second argument must be a class or a tuple of classes\"\"\"\n        # Should I subclass\n        with pytest.raises(InferenceError):\n            _get_result_node(\"issubclass(int, 1)\")\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_uninferable_bad_type", "self", "none", "the", "second", "argument", "must", "be", "a", "class", "or", "a", "tuple", "of", "classes", "should", "i", "subclass", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "issubclass", "int", "1"], "doc_len": 31}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_uninferable_keywords", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_uninferable_keywords", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_uninferable_keywords(self) -> None:\n        \"\"\"issubclass does not allow keywords\"\"\"\n        with pytest.raises(InferenceError):\n            _get_result_node(\"issubclass(int, class_or_tuple=int)\")\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_uninferable_keywords", "self", "none", "issubclass", "does", "not", "allow", "keywords", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "issubclass", "int", "class_or_tuple", "int"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::TestIssubclassBrain.test_too_many_args", "file_path": "tests/unittest_brain.py", "class_name": "TestIssubclassBrain", "func_name": "test_too_many_args", "text": "文件路径: tests/unittest_brain.py, 类名: TestIssubclassBrain\n    def test_too_many_args(self) -> None:\n        \"\"\"issubclass must have two arguments\"\"\"\n        with pytest.raises(InferenceError):\n            _get_result_node(\"issubclass(int, int, str)\")\n", "tokens": ["tests", "unittest_brain", "py", "testissubclassbrain", "def", "test_too_many_args", "self", "none", "issubclass", "must", "have", "two", "arguments", "with", "pytest", "raises", "inferenceerror", "_get_result_node", "issubclass", "int", "int", "str"], "doc_len": 22}
{"doc_id": "tests/unittest_brain.py::_get_result_node", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "_get_result_node", "text": "文件路径: tests/unittest_brain.py\ndef _get_result_node(code: str) -> Const:\n    node = next(astroid.extract_node(code).infer())\n    return node\n", "tokens": ["tests", "unittest_brain", "py", "def", "_get_result_node", "code", "str", "const", "node", "next", "astroid", "extract_node", "code", "infer", "return", "node"], "doc_len": 16}
{"doc_id": "tests/unittest_brain.py::_get_result", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "_get_result", "text": "文件路径: tests/unittest_brain.py\ndef _get_result(code: str) -> str:\n    return _get_result_node(code).as_string()\n", "tokens": ["tests", "unittest_brain", "py", "def", "_get_result", "code", "str", "str", "return", "_get_result_node", "code", "as_string"], "doc_len": 12}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_list", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_list", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_list(self) -> None:\n        # Uses .elts\n        node = astroid.extract_node(\n            \"\"\"\n        len(['a','b','c'])\n        \"\"\"\n        )\n        node = next(node.infer())\n        assert node.as_string() == \"3\"\n        assert isinstance(node, nodes.Const)\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_list", "self", "none", "uses", "elts", "node", "astroid", "extract_node", "len", "a", "b", "c", "node", "next", "node", "infer", "assert", "node", "as_string", "3", "assert", "isinstance", "node", "nodes", "const"], "doc_len": 30}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_tuple", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_tuple", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_tuple(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        len(('a','b','c'))\n        \"\"\"\n        )\n        node = next(node.infer())\n        assert node.as_string() == \"3\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_tuple", "self", "none", "node", "astroid", "extract_node", "len", "a", "b", "c", "node", "next", "node", "infer", "assert", "node", "as_string", "3"], "doc_len": 23}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_var", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_var", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_var(self) -> None:\n        # Make sure argument is inferred\n        node = astroid.extract_node(\n            \"\"\"\n        a = [1,2,'a','b','c']\n        len(a)\n        \"\"\"\n        )\n        node = next(node.infer())\n        assert node.as_string() == \"5\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_var", "self", "none", "make", "sure", "argument", "is", "inferred", "node", "astroid", "extract_node", "a", "1", "2", "a", "b", "c", "len", "a", "node", "next", "node", "infer", "assert", "node", "as_string", "5"], "doc_len": 32}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_dict", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_dict", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_dict(self) -> None:\n        # Uses .items\n        node = astroid.extract_node(\n            \"\"\"\n        a = {'a': 1, 'b': 2}\n        len(a)\n        \"\"\"\n        )\n        node = next(node.infer())\n        assert node.as_string() == \"2\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_dict", "self", "none", "uses", "items", "node", "astroid", "extract_node", "a", "a", "1", "b", "2", "len", "a", "node", "next", "node", "infer", "assert", "node", "as_string", "2"], "doc_len": 28}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_set", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_set", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_set(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        len({'a'})\n        \"\"\"\n        )\n        inferred_node = next(node.infer())\n        assert inferred_node.as_string() == \"1\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_set", "self", "none", "node", "astroid", "extract_node", "len", "a", "inferred_node", "next", "node", "infer", "assert", "inferred_node", "as_string", "1"], "doc_len": 21}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_object", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_object", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_object(self) -> None:\n        \"\"\"Test len with objects that implement the len protocol\"\"\"\n        node = astroid.extract_node(\n            \"\"\"\n        class A:\n            def __len__(self):\n                return 57\n        len(A())\n        \"\"\"\n        )\n        inferred_node = next(node.infer())\n        assert inferred_node.as_string() == \"57\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_object", "self", "none", "test", "len", "with", "objects", "that", "implement", "the", "len", "protocol", "node", "astroid", "extract_node", "class", "a", "def", "__len__", "self", "return", "57", "len", "a", "inferred_node", "next", "node", "infer", "assert", "inferred_node", "as_string", "57"], "doc_len": 37}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_class_with_metaclass", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_class_with_metaclass", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_class_with_metaclass(self) -> None:\n        \"\"\"Make sure proper len method is located\"\"\"\n        cls_node, inst_node = astroid.extract_node(\n            \"\"\"\n        class F2(type):\n            def __new__(cls, name, bases, attrs):\n                return super().__new__(cls, name, bases, {})\n            def __len__(self):\n                return 57\n        class F(metaclass=F2):\n            def __len__(self):\n                return 4\n        len(F) #@\n        len(F()) #@\n        \"\"\"\n        )\n        assert next(cls_node.infer()).as_string() == \"57\"\n        assert next(inst_node.infer()).as_string() == \"4\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_class_with_metaclass", "self", "none", "make", "sure", "proper", "len", "method", "is", "located", "cls_node", "inst_node", "astroid", "extract_node", "class", "f2", "type", "def", "__new__", "cls", "name", "bases", "attrs", "return", "super", "__new__", "cls", "name", "bases", "def", "__len__", "self", "return", "57", "class", "f", "metaclass", "f2", "def", "__len__", "self", "return", "4", "len", "f", "len", "f", "assert", "next", "cls_node", "infer", "as_string", "57", "assert", "next", "inst_node", "infer", "as_string", "4"], "doc_len": 64}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_object_failure", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_object_failure", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_object_failure(self) -> None:\n        \"\"\"If taking the length of a class, do not use an instance method\"\"\"\n        node = astroid.extract_node(\n            \"\"\"\n        class F:\n            def __len__(self):\n                return 57\n        len(F)\n        \"\"\"\n        )\n        with pytest.raises(InferenceError):\n            next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_object_failure", "self", "none", "if", "taking", "the", "length", "of", "a", "class", "do", "not", "use", "an", "instance", "method", "node", "astroid", "extract_node", "class", "f", "def", "__len__", "self", "return", "57", "len", "f", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_string", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_string", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_string(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        len(\"uwu\")\n        \"\"\"\n        )\n        assert next(node.infer()).as_string() == \"3\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_string", "self", "none", "node", "astroid", "extract_node", "len", "uwu", "assert", "next", "node", "infer", "as_string", "3"], "doc_len": 19}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_generator_failure", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_generator_failure", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_generator_failure(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        def gen():\n            yield 'a'\n            yield 'b'\n        len(gen())\n        \"\"\"\n        )\n        with pytest.raises(InferenceError):\n            next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_generator_failure", "self", "none", "node", "astroid", "extract_node", "def", "gen", "yield", "a", "yield", "b", "len", "gen", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 26}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_failure_missing_variable", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_failure_missing_variable", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_failure_missing_variable(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        len(a)\n        \"\"\"\n        )\n        with pytest.raises(InferenceError):\n            next(node.infer())\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_failure_missing_variable", "self", "none", "node", "astroid", "extract_node", "len", "a", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 20}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_bytes", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_bytes", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_bytes(self) -> None:\n        node = astroid.extract_node(\n            \"\"\"\n        len(b'uwu')\n        \"\"\"\n        )\n        assert next(node.infer()).as_string() == \"3\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_bytes", "self", "none", "node", "astroid", "extract_node", "len", "b", "uwu", "assert", "next", "node", "infer", "as_string", "3"], "doc_len": 20}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_int_subclass_result", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_int_subclass_result", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_int_subclass_result(self) -> None:\n        \"\"\"Check that a subclass of an int can still be inferred\n\n        This test does not properly infer the value passed to the\n        int subclass (5) but still returns a proper integer as we\n        fake the result of the `len()` call.\n        \"\"\"\n        node = astroid.extract_node(\n            \"\"\"\n        class IntSubclass(int):\n            pass\n\n        class F:\n            def __len__(self):\n                return IntSubclass(5)\n        len(F())\n        \"\"\"\n        )\n        assert next(node.infer()).as_string() == \"0\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_int_subclass_result", "self", "none", "check", "that", "a", "subclass", "of", "an", "int", "can", "still", "be", "inferred", "this", "test", "does", "not", "properly", "infer", "the", "value", "passed", "to", "the", "int", "subclass", "5", "but", "still", "returns", "a", "proper", "integer", "as", "we", "fake", "the", "result", "of", "the", "len", "call", "node", "astroid", "extract_node", "class", "intsubclass", "int", "pass", "class", "f", "def", "__len__", "self", "return", "intsubclass", "5", "len", "f", "assert", "next", "node", "infer", "as_string", "0"], "doc_len": 71}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_int_subclass_argument", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_int_subclass_argument", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_int_subclass_argument(self):\n        \"\"\"I am unable to access the length of an object which\n        subclasses list\"\"\"\n        node = astroid.extract_node(\n            \"\"\"\n        class ListSubclass(list):\n            pass\n        len(ListSubclass([1,2,3,4,4]))\n        \"\"\"\n        )\n        assert next(node.infer()).as_string() == \"5\"\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_int_subclass_argument", "self", "i", "am", "unable", "to", "access", "the", "length", "of", "an", "object", "which", "subclasses", "list", "node", "astroid", "extract_node", "class", "listsubclass", "list", "pass", "len", "listsubclass", "1", "2", "3", "4", "4", "assert", "next", "node", "infer", "as_string", "5"], "doc_len": 40}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_builtin_inference_attribute_error_str", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_builtin_inference_attribute_error_str", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_builtin_inference_attribute_error_str(self) -> None:\n        \"\"\"Make sure len builtin doesn't raise an AttributeError\n        on instances of str or bytes\n\n        See https://github.com/PyCQA/pylint/issues/1942\n        \"\"\"\n        code = 'len(str(\"F\"))'\n        try:\n            next(astroid.extract_node(code).infer())\n        except InferenceError:\n            pass\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_builtin_inference_attribute_error_str", "self", "none", "make", "sure", "len", "builtin", "doesn", "t", "raise", "an", "attributeerror", "on", "instances", "of", "str", "or", "bytes", "see", "https", "github", "com", "pycqa", "pylint", "issues", "1942", "code", "len", "str", "f", "try", "next", "astroid", "extract_node", "code", "infer", "except", "inferenceerror", "pass"], "doc_len": 44}
{"doc_id": "tests/unittest_brain.py::TestLenBuiltinInference.test_len_builtin_inference_recursion_error_self_referential_attribute", "file_path": "tests/unittest_brain.py", "class_name": "TestLenBuiltinInference", "func_name": "test_len_builtin_inference_recursion_error_self_referential_attribute", "text": "文件路径: tests/unittest_brain.py, 类名: TestLenBuiltinInference\n    def test_len_builtin_inference_recursion_error_self_referential_attribute(\n        self,\n    ) -> None:\n        \"\"\"Make sure len calls do not trigger\n        recursion errors for self referential assignment\n\n        See https://github.com/PyCQA/pylint/issues/2734\n        \"\"\"\n        code = \"\"\"\n        class Data:\n            def __init__(self):\n                self.shape = []\n\n        data = Data()\n        data.shape = len(data.shape)\n        data.shape #@\n        \"\"\"\n        try:\n            astroid.extract_node(code).inferred()\n        except RecursionError:\n            pytest.fail(\"Inference call should not trigger a recursion error\")\n", "tokens": ["tests", "unittest_brain", "py", "testlenbuiltininference", "def", "test_len_builtin_inference_recursion_error_self_referential_attribute", "self", "none", "make", "sure", "len", "calls", "do", "not", "trigger", "recursion", "errors", "for", "self", "referential", "assignment", "see", "https", "github", "com", "pycqa", "pylint", "issues", "2734", "code", "class", "data", "def", "__init__", "self", "self", "shape", "data", "data", "data", "shape", "len", "data", "shape", "data", "shape", "try", "astroid", "extract_node", "code", "inferred", "except", "recursionerror", "pytest", "fail", "inference", "call", "should", "not", "trigger", "a", "recursion", "error"], "doc_len": 63}
{"doc_id": "tests/unittest_brain.py::test_infer_str", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_infer_str", "text": "文件路径: tests/unittest_brain.py\ndef test_infer_str() -> None:\n    ast_nodes = astroid.extract_node(\n        \"\"\"\n    str(s) #@\n    str('a') #@\n    str(some_object()) #@\n    \"\"\"\n    )\n    for node in ast_nodes:\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Const)\n\n    node = astroid.extract_node(\n        \"\"\"\n    str(s='') #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, astroid.Instance)\n    assert inferred.qname() == \"builtins.str\"\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_infer_str", "none", "ast_nodes", "astroid", "extract_node", "str", "s", "str", "a", "str", "some_object", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const", "node", "astroid", "extract_node", "str", "s", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "instance", "assert", "inferred", "qname", "builtins", "str"], "doc_len": 47}
{"doc_id": "tests/unittest_brain.py::test_infer_int", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_infer_int", "text": "文件路径: tests/unittest_brain.py\ndef test_infer_int() -> None:\n    ast_nodes = astroid.extract_node(\n        \"\"\"\n    int(0) #@\n    int('1') #@\n    \"\"\"\n    )\n    for node in ast_nodes:\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Const)\n\n    ast_nodes = astroid.extract_node(\n        \"\"\"\n    int(s='') #@\n    int('2.5') #@\n    int('something else') #@\n    int(unknown) #@\n    int(b'a') #@\n    \"\"\"\n    )\n    for node in ast_nodes:\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Instance)\n        assert inferred.qname() == \"builtins.int\"\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_infer_int", "none", "ast_nodes", "astroid", "extract_node", "int", "0", "int", "1", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const", "ast_nodes", "astroid", "extract_node", "int", "s", "int", "2", "5", "int", "something", "else", "int", "unknown", "int", "b", "a", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "instance", "assert", "inferred", "qname", "builtins", "int"], "doc_len": 60}
{"doc_id": "tests/unittest_brain.py::test_infer_dict_from_keys", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_infer_dict_from_keys", "text": "文件路径: tests/unittest_brain.py\ndef test_infer_dict_from_keys() -> None:\n    bad_nodes = astroid.extract_node(\n        \"\"\"\n    dict.fromkeys() #@\n    dict.fromkeys(1, 2, 3) #@\n    dict.fromkeys(a=1) #@\n    \"\"\"\n    )\n    for node in bad_nodes:\n        with pytest.raises(InferenceError):\n            next(node.infer())\n\n    # Test uninferable values\n    good_nodes = astroid.extract_node(\n        \"\"\"\n    from unknown import Unknown\n    dict.fromkeys(some_value) #@\n    dict.fromkeys(some_other_value) #@\n    dict.fromkeys([Unknown(), Unknown()]) #@\n    dict.fromkeys([Unknown(), Unknown()]) #@\n    \"\"\"\n    )\n    for node in good_nodes:\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Dict)\n        assert inferred.items == []\n\n    # Test inferable values\n\n    # from a dictionary's keys\n    from_dict = astroid.extract_node(\n        \"\"\"\n    dict.fromkeys({'a':2, 'b': 3, 'c': 3}) #@\n    \"\"\"\n    )\n    inferred = next(from_dict.infer())\n    assert isinstance(inferred, astroid.Dict)\n    itered = inferred.itered()\n    assert all(isinstance(elem, astroid.Const) for elem in itered)\n    actual_values = [elem.value for elem in itered]\n    assert sorted(actual_values) == [\"a\", \"b\", \"c\"]\n\n    # from a string\n    from_string = astroid.extract_node(\n        \"\"\"\n    dict.fromkeys('abc')\n    \"\"\"\n    )\n    inferred = next(from_string.infer())\n    assert isinstance(inferred, astroid.Dict)\n    itered = inferred.itered()\n    assert all(isinstance(elem, astroid.Const) for elem in itered)\n    actual_values = [elem.value for elem in itered]\n    assert sorted(actual_values) == [\"a\", \"b\", \"c\"]\n\n    # from bytes\n    from_bytes = astroid.extract_node(\n        \"\"\"\n    dict.fromkeys(b'abc')\n    \"\"\"\n    )\n    inferred = next(from_bytes.infer())\n    assert isinstance(inferred, astroid.Dict)\n    itered = inferred.itered()\n    assert all(isinstance(elem, astroid.Const) for elem in itered)\n    actual_values = [elem.value for elem in itered]\n    assert sorted(actual_values) == [97, 98, 99]\n\n    # From list/set/tuple\n    from_others = astroid.extract_node(\n        \"\"\"\n    dict.fromkeys(('a', 'b', 'c')) #@\n    dict.fromkeys(['a', 'b', 'c']) #@\n    dict.fromkeys({'a', 'b', 'c'}) #@\n    \"\"\"\n    )\n    for node in from_others:\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Dict)\n        itered = inferred.itered()\n        assert all(isinstance(elem, astroid.Const) for elem in itered)\n        actual_values = [elem.value for elem in itered]\n        assert sorted(actual_values) == [\"a\", \"b\", \"c\"]\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_infer_dict_from_keys", "none", "bad_nodes", "astroid", "extract_node", "dict", "fromkeys", "dict", "fromkeys", "1", "2", "3", "dict", "fromkeys", "a", "1", "for", "node", "in", "bad_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer", "test", "uninferable", "values", "good_nodes", "astroid", "extract_node", "from", "unknown", "import", "unknown", "dict", "fromkeys", "some_value", "dict", "fromkeys", "some_other_value", "dict", "fromkeys", "unknown", "unknown", "dict", "fromkeys", "unknown", "unknown", "for", "node", "in", "good_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "dict", "assert", "inferred", "items", "test", "inferable", "values", "from", "a", "dictionary", "s", "keys", "from_dict", "astroid", "extract_node", "dict", "fromkeys", "a", "2", "b", "3", "c", "3", "inferred", "next", "from_dict", "infer", "assert", "isinstance", "inferred", "astroid", "dict", "itered", "inferred", "itered", "assert", "all", "isinstance", "elem", "astroid", "const", "for", "elem", "in", "itered", "actual_values", "elem", "value", "for", "elem", "in", "itered", "assert", "sorted", "actual_values", "a", "b", "c", "from", "a", "string", "from_string", "astroid", "extract_node", "dict", "fromkeys", "abc", "inferred", "next", "from_string", "infer", "assert", "isinstance", "inferred", "astroid", "dict", "itered", "inferred", "itered", "assert", "all", "isinstance", "elem", "astroid", "const", "for", "elem", "in", "itered", "actual_values", "elem", "value", "for", "elem", "in", "itered", "assert", "sorted", "actual_values", "a", "b", "c", "from", "bytes", "from_bytes", "astroid", "extract_node", "dict", "fromkeys", "b", "abc", "inferred", "next", "from_bytes", "infer", "assert", "isinstance", "inferred", "astroid", "dict", "itered", "inferred", "itered", "assert", "all", "isinstance", "elem", "astroid", "const", "for", "elem", "in", "itered", "actual_values", "elem", "value", "for", "elem", "in", "itered", "assert", "sorted", "actual_values", "97", "98", "99", "from", "list", "set", "tuple", "from_others", "astroid", "extract_node", "dict", "fromkeys", "a", "b", "c", "dict", "fromkeys", "a", "b", "c", "dict", "fromkeys", "a", "b", "c", "for", "node", "in", "from_others", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "dict", "itered", "inferred", "itered", "assert", "all", "isinstance", "elem", "astroid", "const", "for", "elem", "in", "itered", "actual_values", "elem", "value", "for", "elem", "in", "itered", "assert", "sorted", "actual_values", "a", "b", "c"], "doc_len": 274}
{"doc_id": "tests/unittest_brain.py::TestFunctoolsPartial.test_invalid_functools_partial_calls", "file_path": "tests/unittest_brain.py", "class_name": "TestFunctoolsPartial", "func_name": "test_invalid_functools_partial_calls", "text": "文件路径: tests/unittest_brain.py, 类名: TestFunctoolsPartial\n    def test_invalid_functools_partial_calls(self) -> None:\n        ast_nodes = astroid.extract_node(\n            \"\"\"\n        from functools import partial\n        from unknown import Unknown\n\n        def test(a, b, c):\n            return a + b + c\n\n        partial() #@\n        partial(test) #@\n        partial(func=test) #@\n        partial(some_func, a=1) #@\n        partial(Unknown, a=1) #@\n        partial(2, a=1) #@\n        partial(test, unknown=1) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            assert isinstance(inferred, (astroid.FunctionDef, astroid.Instance))\n            assert inferred.qname() in {\n                \"functools.partial\",\n                \"functools.partial.newfunc\",\n            }\n", "tokens": ["tests", "unittest_brain", "py", "testfunctoolspartial", "def", "test_invalid_functools_partial_calls", "self", "none", "ast_nodes", "astroid", "extract_node", "from", "functools", "import", "partial", "from", "unknown", "import", "unknown", "def", "test", "a", "b", "c", "return", "a", "b", "c", "partial", "partial", "test", "partial", "func", "test", "partial", "some_func", "a", "1", "partial", "unknown", "a", "1", "partial", "2", "a", "1", "partial", "test", "unknown", "1", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "functiondef", "astroid", "instance", "assert", "inferred", "qname", "in", "functools", "partial", "functools", "partial", "newfunc"], "doc_len": 74}
{"doc_id": "tests/unittest_brain.py::TestFunctoolsPartial.test_inferred_partial_function_calls", "file_path": "tests/unittest_brain.py", "class_name": "TestFunctoolsPartial", "func_name": "test_inferred_partial_function_calls", "text": "文件路径: tests/unittest_brain.py, 类名: TestFunctoolsPartial\n    def test_inferred_partial_function_calls(self) -> None:\n        ast_nodes = astroid.extract_node(\n            \"\"\"\n        from functools import partial\n        def test(a, b):\n            return a + b\n        partial(test, 1)(3) #@\n        partial(test, b=4)(3) #@\n        partial(test, b=4)(a=3) #@\n        def other_test(a, b, *, c=1):\n            return (a + b) * c\n\n        partial(other_test, 1, 2)() #@\n        partial(other_test, 1, 2)(c=4) #@\n        partial(other_test, c=4)(1, 3) #@\n        partial(other_test, 4, c=4)(4) #@\n        partial(other_test, 4, c=4)(b=5) #@\n        test(1, 2) #@\n        partial(other_test, 1, 2)(c=3) #@\n        partial(test, b=4)(a=3) #@\n        \"\"\"\n        )\n        expected_values = [4, 7, 7, 3, 12, 16, 32, 36, 3, 9, 7]\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            assert isinstance(inferred, astroid.Const)\n            assert inferred.value == expected_value\n", "tokens": ["tests", "unittest_brain", "py", "testfunctoolspartial", "def", "test_inferred_partial_function_calls", "self", "none", "ast_nodes", "astroid", "extract_node", "from", "functools", "import", "partial", "def", "test", "a", "b", "return", "a", "b", "partial", "test", "1", "3", "partial", "test", "b", "4", "3", "partial", "test", "b", "4", "a", "3", "def", "other_test", "a", "b", "c", "1", "return", "a", "b", "c", "partial", "other_test", "1", "2", "partial", "other_test", "1", "2", "c", "4", "partial", "other_test", "c", "4", "1", "3", "partial", "other_test", "4", "c", "4", "4", "partial", "other_test", "4", "c", "4", "b", "5", "test", "1", "2", "partial", "other_test", "1", "2", "c", "3", "partial", "test", "b", "4", "a", "3", "expected_values", "4", "7", "7", "3", "12", "16", "32", "36", "3", "9", "7", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const", "assert", "inferred", "value", "expected_value"], "doc_len": 123}
{"doc_id": "tests/unittest_brain.py::TestFunctoolsPartial.test_partial_assignment", "file_path": "tests/unittest_brain.py", "class_name": "TestFunctoolsPartial", "func_name": "test_partial_assignment", "text": "文件路径: tests/unittest_brain.py, 类名: TestFunctoolsPartial\n    def test_partial_assignment(self) -> None:\n        \"\"\"Make sure partials are not assigned to original scope.\"\"\"\n        ast_nodes = astroid.extract_node(\n            \"\"\"\n        from functools import partial\n        def test(a, b): #@\n            return a + b\n        test2 = partial(test, 1)\n        test2 #@\n        def test3_scope(a):\n            test3 = partial(test, a)\n            test3 #@\n        \"\"\"\n        )\n        func1, func2, func3 = ast_nodes\n        assert func1.parent.scope() == func2.parent.scope()\n        assert func1.parent.scope() != func3.parent.scope()\n        partial_func3 = next(func3.infer())\n        # use scope of parent, so that it doesn't just refer to self\n        scope = partial_func3.parent.scope()\n        assert scope.name == \"test3_scope\", \"parented by closure\"\n", "tokens": ["tests", "unittest_brain", "py", "testfunctoolspartial", "def", "test_partial_assignment", "self", "none", "make", "sure", "partials", "are", "not", "assigned", "to", "original", "scope", "ast_nodes", "astroid", "extract_node", "from", "functools", "import", "partial", "def", "test", "a", "b", "return", "a", "b", "test2", "partial", "test", "1", "test2", "def", "test3_scope", "a", "test3", "partial", "test", "a", "test3", "func1", "func2", "func3", "ast_nodes", "assert", "func1", "parent", "scope", "func2", "parent", "scope", "assert", "func1", "parent", "scope", "func3", "parent", "scope", "partial_func3", "next", "func3", "infer", "use", "scope", "of", "parent", "so", "that", "it", "doesn", "t", "just", "refer", "to", "self", "scope", "partial_func3", "parent", "scope", "assert", "scope", "name", "test3_scope", "parented", "by", "closure"], "doc_len": 90}
{"doc_id": "tests/unittest_brain.py::TestFunctoolsPartial.test_partial_does_not_affect_scope", "file_path": "tests/unittest_brain.py", "class_name": "TestFunctoolsPartial", "func_name": "test_partial_does_not_affect_scope", "text": "文件路径: tests/unittest_brain.py, 类名: TestFunctoolsPartial\n    def test_partial_does_not_affect_scope(self) -> None:\n        \"\"\"Make sure partials are not automatically assigned.\"\"\"\n        ast_nodes = astroid.extract_node(\n            \"\"\"\n        from functools import partial\n        def test(a, b):\n            return a + b\n        def scope():\n            test2 = partial(test, 1)\n            test2 #@\n        \"\"\"\n        )\n        test2 = next(ast_nodes.infer())\n        mod_scope = test2.root()\n        scope = test2.parent.scope()\n        assert set(mod_scope) == {\"test\", \"scope\", \"partial\"}\n        assert set(scope) == {\"test2\"}\n", "tokens": ["tests", "unittest_brain", "py", "testfunctoolspartial", "def", "test_partial_does_not_affect_scope", "self", "none", "make", "sure", "partials", "are", "not", "automatically", "assigned", "ast_nodes", "astroid", "extract_node", "from", "functools", "import", "partial", "def", "test", "a", "b", "return", "a", "b", "def", "scope", "test2", "partial", "test", "1", "test2", "test2", "next", "ast_nodes", "infer", "mod_scope", "test2", "root", "scope", "test2", "parent", "scope", "assert", "set", "mod_scope", "test", "scope", "partial", "assert", "set", "scope", "test2"], "doc_len": 57}
{"doc_id": "tests/unittest_brain.py::TestFunctoolsPartial.test_multiple_partial_args", "file_path": "tests/unittest_brain.py", "class_name": "TestFunctoolsPartial", "func_name": "test_multiple_partial_args", "text": "文件路径: tests/unittest_brain.py, 类名: TestFunctoolsPartial\n    def test_multiple_partial_args(self) -> None:\n        \"Make sure partials remember locked-in args.\"\n        ast_node = astroid.extract_node(\n            \"\"\"\n        from functools import partial\n        def test(a, b, c, d, e=5):\n            return a + b + c + d + e\n        test1 = partial(test, 1)\n        test2 = partial(test1, 2)\n        test3 = partial(test2, 3)\n        test3(4, e=6) #@\n        \"\"\"\n        )\n        expected_args = [1, 2, 3, 4]\n        expected_keywords = {\"e\": 6}\n\n        call_site = astroid.arguments.CallSite.from_call(ast_node)\n        called_func = next(ast_node.func.infer())\n        called_args = called_func.filled_args + call_site.positional_arguments\n        called_keywords = {**called_func.filled_keywords, **call_site.keyword_arguments}\n        assert len(called_args) == len(expected_args)\n        assert [arg.value for arg in called_args] == expected_args\n        assert len(called_keywords) == len(expected_keywords)\n\n        for keyword, value in expected_keywords.items():\n            assert keyword in called_keywords\n            assert called_keywords[keyword].value == value\n", "tokens": ["tests", "unittest_brain", "py", "testfunctoolspartial", "def", "test_multiple_partial_args", "self", "none", "make", "sure", "partials", "remember", "locked", "in", "args", "ast_node", "astroid", "extract_node", "from", "functools", "import", "partial", "def", "test", "a", "b", "c", "d", "e", "5", "return", "a", "b", "c", "d", "e", "test1", "partial", "test", "1", "test2", "partial", "test1", "2", "test3", "partial", "test2", "3", "test3", "4", "e", "6", "expected_args", "1", "2", "3", "4", "expected_keywords", "e", "6", "call_site", "astroid", "arguments", "callsite", "from_call", "ast_node", "called_func", "next", "ast_node", "func", "infer", "called_args", "called_func", "filled_args", "call_site", "positional_arguments", "called_keywords", "called_func", "filled_keywords", "call_site", "keyword_arguments", "assert", "len", "called_args", "len", "expected_args", "assert", "arg", "value", "for", "arg", "in", "called_args", "expected_args", "assert", "len", "called_keywords", "len", "expected_keywords", "for", "keyword", "value", "in", "expected_keywords", "items", "assert", "keyword", "in", "called_keywords", "assert", "called_keywords", "keyword", "value", "value"], "doc_len": 114}
{"doc_id": "tests/unittest_brain.py::test_http_client_brain", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_http_client_brain", "text": "文件路径: tests/unittest_brain.py\ndef test_http_client_brain() -> None:\n    node = astroid.extract_node(\n        \"\"\"\n    from http.client import OK\n    OK\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, astroid.Instance)\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_http_client_brain", "none", "node", "astroid", "extract_node", "from", "http", "client", "import", "ok", "ok", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "instance"], "doc_len": 24}
{"doc_id": "tests/unittest_brain.py::test_http_status_brain", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_http_status_brain", "text": "文件路径: tests/unittest_brain.py\ndef test_http_status_brain() -> None:\n    node = astroid.extract_node(\n        \"\"\"\n    import http\n    http.HTTPStatus.CONTINUE.phrase\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    # Cannot infer the exact value but the field is there.\n    assert inferred is util.Uninferable\n\n    node = astroid.extract_node(\n        \"\"\"\n    import http\n    http.HTTPStatus(200).phrase\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, astroid.Const)\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_http_status_brain", "none", "node", "astroid", "extract_node", "import", "http", "http", "httpstatus", "continue", "phrase", "inferred", "next", "node", "infer", "cannot", "infer", "the", "exact", "value", "but", "the", "field", "is", "there", "assert", "inferred", "is", "util", "uninferable", "node", "astroid", "extract_node", "import", "http", "http", "httpstatus", "200", "phrase", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const"], "doc_len": 52}
{"doc_id": "tests/unittest_brain.py::test_oserror_model", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_oserror_model", "text": "文件路径: tests/unittest_brain.py\ndef test_oserror_model() -> None:\n    node = astroid.extract_node(\n        \"\"\"\n    try:\n        1/0\n    except OSError as exc:\n        exc #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    strerror = next(inferred.igetattr(\"strerror\"))\n    assert isinstance(strerror, astroid.Const)\n    assert strerror.value == \"\"\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_oserror_model", "none", "node", "astroid", "extract_node", "try", "1", "0", "except", "oserror", "as", "exc", "exc", "inferred", "next", "node", "infer", "strerror", "next", "inferred", "igetattr", "strerror", "assert", "isinstance", "strerror", "astroid", "const", "assert", "strerror", "value"], "doc_len": 34}
{"doc_id": "tests/unittest_brain.py::test_crypt_brain", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_crypt_brain", "text": "文件路径: tests/unittest_brain.py\ndef test_crypt_brain() -> None:\n    module = MANAGER.ast_from_module_name(\"crypt\")\n    dynamic_attrs = [\n        \"METHOD_SHA512\",\n        \"METHOD_SHA256\",\n        \"METHOD_BLOWFISH\",\n        \"METHOD_MD5\",\n        \"METHOD_CRYPT\",\n    ]\n    for attr in dynamic_attrs:\n        assert attr in module\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_crypt_brain", "none", "module", "manager", "ast_from_module_name", "crypt", "dynamic_attrs", "method_sha512", "method_sha256", "method_blowfish", "method_md5", "method_crypt", "for", "attr", "in", "dynamic_attrs", "assert", "attr", "in", "module"], "doc_len": 24}
{"doc_id": "tests/unittest_brain.py::test_str_and_bytes", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_str_and_bytes", "text": "文件路径: tests/unittest_brain.py\ndef test_str_and_bytes(code, expected_class, expected_value):\n    node = astroid.extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, expected_class)\n    assert inferred.value == expected_value\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_str_and_bytes", "code", "expected_class", "expected_value", "node", "astroid", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "expected_class", "assert", "inferred", "value", "expected_value"], "doc_len": 24}
{"doc_id": "tests/unittest_brain.py::test_no_recursionerror_on_self_referential_length_check", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_no_recursionerror_on_self_referential_length_check", "text": "文件路径: tests/unittest_brain.py\ndef test_no_recursionerror_on_self_referential_length_check() -> None:\n    \"\"\"\n    Regression test for https://github.com/PyCQA/astroid/issues/777\n\n    This test should only raise an InferenceError and no RecursionError.\n    \"\"\"\n    with pytest.raises(InferenceError):\n        node = astroid.extract_node(\n            \"\"\"\n        class Crash:\n            def __len__(self) -> int:\n                return len(self)\n        len(Crash()) #@\n        \"\"\"\n        )\n        assert isinstance(node, nodes.NodeNG)\n        node.inferred()\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_no_recursionerror_on_self_referential_length_check", "none", "regression", "test", "for", "https", "github", "com", "pycqa", "astroid", "issues", "777", "this", "test", "should", "only", "raise", "an", "inferenceerror", "and", "no", "recursionerror", "with", "pytest", "raises", "inferenceerror", "node", "astroid", "extract_node", "class", "crash", "def", "__len__", "self", "int", "return", "len", "self", "len", "crash", "assert", "isinstance", "node", "nodes", "nodeng", "node", "inferred"], "doc_len": 51}
{"doc_id": "tests/unittest_brain.py::test_inference_on_outer_referential_length_check", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_inference_on_outer_referential_length_check", "text": "文件路径: tests/unittest_brain.py\ndef test_inference_on_outer_referential_length_check() -> None:\n    \"\"\"\n    Regression test for https://github.com/PyCQA/pylint/issues/5244\n    See also https://github.com/PyCQA/astroid/pull/1234\n\n    This test should succeed without any error.\n    \"\"\"\n    node = astroid.extract_node(\n        \"\"\"\n    class A:\n        def __len__(self) -> int:\n            return 42\n\n    class Crash:\n        def __len__(self) -> int:\n            a = A()\n            return len(a)\n\n    len(Crash()) #@\n    \"\"\"\n    )\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 42\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_inference_on_outer_referential_length_check", "none", "regression", "test", "for", "https", "github", "com", "pycqa", "pylint", "issues", "5244", "see", "also", "https", "github", "com", "pycqa", "astroid", "pull", "1234", "this", "test", "should", "succeed", "without", "any", "error", "node", "astroid", "extract_node", "class", "a", "def", "__len__", "self", "int", "return", "42", "class", "crash", "def", "__len__", "self", "int", "a", "a", "return", "len", "a", "len", "crash", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "42"], "doc_len": 74}
{"doc_id": "tests/unittest_brain.py::test_no_attributeerror_on_self_referential_length_check", "file_path": "tests/unittest_brain.py", "class_name": null, "func_name": "test_no_attributeerror_on_self_referential_length_check", "text": "文件路径: tests/unittest_brain.py\ndef test_no_attributeerror_on_self_referential_length_check() -> None:\n    \"\"\"\n    Regression test for https://github.com/PyCQA/pylint/issues/5244\n    See also https://github.com/PyCQA/astroid/pull/1234\n\n    This test should only raise an InferenceError and no AttributeError.\n    \"\"\"\n    with pytest.raises(InferenceError):\n        node = astroid.extract_node(\n            \"\"\"\n        class MyClass:\n            def some_func(self):\n                return lambda: 42\n\n            def __len__(self):\n                return len(self.some_func())\n\n        len(MyClass()) #@\n        \"\"\"\n        )\n        assert isinstance(node, nodes.NodeNG)\n        node.inferred()\n", "tokens": ["tests", "unittest_brain", "py", "def", "test_no_attributeerror_on_self_referential_length_check", "none", "regression", "test", "for", "https", "github", "com", "pycqa", "pylint", "issues", "5244", "see", "also", "https", "github", "com", "pycqa", "astroid", "pull", "1234", "this", "test", "should", "only", "raise", "an", "inferenceerror", "and", "no", "attributeerror", "with", "pytest", "raises", "inferenceerror", "node", "astroid", "extract_node", "class", "myclass", "def", "some_func", "self", "return", "lambda", "42", "def", "__len__", "self", "return", "len", "self", "some_func", "len", "myclass", "assert", "isinstance", "node", "nodes", "nodeng", "node", "inferred"], "doc_len": 66}
{"doc_id": "tests/unittest_brain_ctypes.py::test_ctypes_redefined_types_members", "file_path": "tests/unittest_brain_ctypes.py", "class_name": null, "func_name": "test_ctypes_redefined_types_members", "text": "文件路径: tests/unittest_brain_ctypes.py\ndef test_ctypes_redefined_types_members(c_type, builtin_type, type_code):\n    \"\"\"\n    Test that the \"value\" and \"_type_\" member of each redefined types are correct\n    \"\"\"\n    src = f\"\"\"\n    import ctypes\n    x=ctypes.{c_type}(\"toto\")\n    x.value\n    \"\"\"\n    node = extract_node(src)\n    assert isinstance(node, nodes.NodeNG)\n    node_inf = node.inferred()[0]\n    assert node_inf.pytype() == f\"builtins.{builtin_type}\"\n\n    src = f\"\"\"\n    import ctypes\n    x=ctypes.{c_type}(\"toto\")\n    x._type_\n    \"\"\"\n    node = extract_node(src)\n    assert isinstance(node, nodes.NodeNG)\n    node_inf = node.inferred()[0]\n    assert isinstance(node_inf, nodes.Const)\n    assert node_inf.value == type_code\n", "tokens": ["tests", "unittest_brain_ctypes", "py", "def", "test_ctypes_redefined_types_members", "c_type", "builtin_type", "type_code", "test", "that", "the", "value", "and", "_type_", "member", "of", "each", "redefined", "types", "are", "correct", "src", "f", "import", "ctypes", "x", "ctypes", "c_type", "toto", "x", "value", "node", "extract_node", "src", "assert", "isinstance", "node", "nodes", "nodeng", "node_inf", "node", "inferred", "0", "assert", "node_inf", "pytype", "f", "builtins", "builtin_type", "src", "f", "import", "ctypes", "x", "ctypes", "c_type", "toto", "x", "_type_", "node", "extract_node", "src", "assert", "isinstance", "node", "nodes", "nodeng", "node_inf", "node", "inferred", "0", "assert", "isinstance", "node_inf", "nodes", "const", "assert", "node_inf", "value", "type_code"], "doc_len": 80}
{"doc_id": "tests/unittest_brain_ctypes.py::test_cdata_member_access", "file_path": "tests/unittest_brain_ctypes.py", "class_name": null, "func_name": "test_cdata_member_access", "text": "文件路径: tests/unittest_brain_ctypes.py\ndef test_cdata_member_access() -> None:\n    \"\"\"\n    Test that the base members are still accessible. Each redefined ctypes type inherits from _SimpleCData which itself\n    inherits from _CData. Checks that _CData members are accessibles\n    \"\"\"\n    src = \"\"\"\n    import ctypes\n    x=ctypes.c_float(1.0)\n    x._objects\n    \"\"\"\n    node = extract_node(src)\n    assert isinstance(node, nodes.NodeNG)\n    node_inf = node.inferred()[0]\n    assert node_inf.display_type() == \"Class\"\n    assert node_inf.qname() == \"_ctypes._SimpleCData._objects\"\n", "tokens": ["tests", "unittest_brain_ctypes", "py", "def", "test_cdata_member_access", "none", "test", "that", "the", "base", "members", "are", "still", "accessible", "each", "redefined", "ctypes", "type", "inherits", "from", "_simplecdata", "which", "itself", "inherits", "from", "_cdata", "checks", "that", "_cdata", "members", "are", "accessibles", "src", "import", "ctypes", "x", "ctypes", "c_float", "1", "0", "x", "_objects", "node", "extract_node", "src", "assert", "isinstance", "node", "nodes", "nodeng", "node_inf", "node", "inferred", "0", "assert", "node_inf", "display_type", "class", "assert", "node_inf", "qname", "_ctypes", "_simplecdata", "_objects"], "doc_len": 64}
{"doc_id": "tests/unittest_brain_ctypes.py::test_other_ctypes_member_untouched", "file_path": "tests/unittest_brain_ctypes.py", "class_name": null, "func_name": "test_other_ctypes_member_untouched", "text": "文件路径: tests/unittest_brain_ctypes.py\ndef test_other_ctypes_member_untouched() -> None:\n    \"\"\"\n    Test that other ctypes members, which are not touched by the brain, are correctly inferred\n    \"\"\"\n    src = \"\"\"\n    import ctypes\n    ctypes.ARRAY(3, 2)\n    \"\"\"\n    node = extract_node(src)\n    assert isinstance(node, nodes.NodeNG)\n    node_inf = node.inferred()[0]\n    assert isinstance(node_inf, nodes.Const)\n    assert node_inf.value == 6\n", "tokens": ["tests", "unittest_brain_ctypes", "py", "def", "test_other_ctypes_member_untouched", "none", "test", "that", "other", "ctypes", "members", "which", "are", "not", "touched", "by", "the", "brain", "are", "correctly", "inferred", "src", "import", "ctypes", "ctypes", "array", "3", "2", "node", "extract_node", "src", "assert", "isinstance", "node", "nodes", "nodeng", "node_inf", "node", "inferred", "0", "assert", "isinstance", "node_inf", "nodes", "const", "assert", "node_inf", "value", "6"], "doc_len": 49}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_attribute_no_default", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_attribute_no_default", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_attribute_no_default(module: str):\n    \"\"\"Test inference of dataclass attribute with no default.\n\n    Note that the argument to the constructor is ignored by the inference.\n    \"\"\"\n    klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        name: str\n\n    A.name  #@\n    A('hi').name  #@\n    \"\"\"\n    )\n    with pytest.raises(InferenceError):\n        klass.inferred()\n\n    inferred = instance.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], bases.Instance)\n    assert inferred[0].name == \"str\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_attribute_no_default", "module", "str", "test", "inference", "of", "dataclass", "attribute", "with", "no", "default", "note", "that", "the", "argument", "to", "the", "constructor", "is", "ignored", "by", "the", "inference", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "name", "str", "a", "name", "a", "hi", "name", "with", "pytest", "raises", "inferenceerror", "klass", "inferred", "inferred", "instance", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "bases", "instance", "assert", "inferred", "0", "name", "str"], "doc_len": 70}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_non_field_default", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_non_field_default", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_non_field_default(module: str):\n    \"\"\"Test inference of dataclass attribute with a non-field default.\"\"\"\n    klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        name: str = 'hi'\n\n    A.name  #@\n    A().name  #@\n    \"\"\"\n    )\n    inferred = klass.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n\n    inferred = instance.inferred()\n    assert len(inferred) == 2\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n\n    assert isinstance(inferred[1], bases.Instance)\n    assert inferred[1].name == \"str\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_non_field_default", "module", "str", "test", "inference", "of", "dataclass", "attribute", "with", "a", "non", "field", "default", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "name", "str", "hi", "a", "name", "a", "name", "inferred", "klass", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "inferred", "instance", "inferred", "assert", "len", "inferred", "2", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "assert", "isinstance", "inferred", "1", "bases", "instance", "assert", "inferred", "1", "name", "str"], "doc_len": 83}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_field_default", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_field_default", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_field_default(module: str):\n    \"\"\"Test inference of dataclass attribute with a field call default\n    (default keyword argument given).\"\"\"\n    klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import field\n\n    @dataclass\n    class A:\n        name: str = field(default='hi')\n\n    A.name  #@\n    A().name  #@\n    \"\"\"\n    )\n    inferred = klass.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n\n    inferred = instance.inferred()\n    assert len(inferred) == 2\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n\n    assert isinstance(inferred[1], bases.Instance)\n    assert inferred[1].name == \"str\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_field_default", "module", "str", "test", "inference", "of", "dataclass", "attribute", "with", "a", "field", "call", "default", "default", "keyword", "argument", "given", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "dataclass", "class", "a", "name", "str", "field", "default", "hi", "a", "name", "a", "name", "inferred", "klass", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "inferred", "instance", "inferred", "assert", "len", "inferred", "2", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "assert", "isinstance", "inferred", "1", "bases", "instance", "assert", "inferred", "1", "name", "str"], "doc_len": 93}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_field_default_factory", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_field_default_factory", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_field_default_factory(module: str):\n    \"\"\"Test inference of dataclass attribute with a field call default\n    (default_factory keyword argument given).\"\"\"\n    klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import field\n\n    @dataclass\n    class A:\n        name: list = field(default_factory=list)\n\n    A.name  #@\n    A().name  #@\n    \"\"\"\n    )\n    inferred = klass.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.List)\n    assert inferred[0].elts == []\n\n    inferred = instance.inferred()\n    assert len(inferred) == 2\n    assert isinstance(inferred[0], nodes.List)\n    assert inferred[0].elts == []\n\n    assert isinstance(inferred[1], bases.Instance)\n    assert inferred[1].name == \"list\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_field_default_factory", "module", "str", "test", "inference", "of", "dataclass", "attribute", "with", "a", "field", "call", "default", "default_factory", "keyword", "argument", "given", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "dataclass", "class", "a", "name", "list", "field", "default_factory", "list", "a", "name", "a", "name", "inferred", "klass", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "list", "assert", "inferred", "0", "elts", "inferred", "instance", "inferred", "assert", "len", "inferred", "2", "assert", "isinstance", "inferred", "0", "nodes", "list", "assert", "inferred", "0", "elts", "assert", "isinstance", "inferred", "1", "bases", "instance", "assert", "inferred", "1", "name", "list"], "doc_len": 91}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_method", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_method", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_method(module: str):\n    \"\"\"Test inference of dataclass attribute within a method,\n    with a default_factory field.\n\n    Based on https://github.com/PyCQA/pylint/issues/2600\n    \"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from typing import Dict\n    from {module} import dataclass\n    from dataclasses import field\n\n    @dataclass\n    class TestClass:\n        foo: str\n        bar: str\n        baz_dict: Dict[str, str] = field(default_factory=dict)\n\n        def some_func(self) -> None:\n            f = self.baz_dict.items  #@\n            for key, value in f():\n                print(key)\n                print(value)\n    \"\"\"\n    )\n    inferred = next(node.value.infer())\n    assert isinstance(inferred, bases.BoundMethod)\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_method", "module", "str", "test", "inference", "of", "dataclass", "attribute", "within", "a", "method", "with", "a", "default_factory", "field", "based", "on", "https", "github", "com", "pycqa", "pylint", "issues", "2600", "node", "astroid", "extract_node", "f", "from", "typing", "import", "dict", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "dataclass", "class", "testclass", "foo", "str", "bar", "str", "baz_dict", "dict", "str", "str", "field", "default_factory", "dict", "def", "some_func", "self", "none", "f", "self", "baz_dict", "items", "for", "key", "value", "in", "f", "print", "key", "print", "value", "inferred", "next", "node", "value", "infer", "assert", "isinstance", "inferred", "bases", "boundmethod"], "doc_len": 85}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_no_annotation", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_no_annotation", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_no_annotation(module: str):\n    \"\"\"Test that class variables without type annotations are not\n    turned into instance attributes.\n    \"\"\"\n    class_def, klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        name = 'hi'\n\n    A  #@\n    A.name  #@\n    A().name #@\n    \"\"\"\n    )\n    inferred = next(class_def.infer())\n    assert isinstance(inferred, nodes.ClassDef)\n    assert inferred.instance_attrs == {}\n\n    # Both the class and instance can still access the attribute\n    for node in (klass, instance):\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const)\n        assert inferred[0].value == \"hi\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_no_annotation", "module", "str", "test", "that", "class", "variables", "without", "type", "annotations", "are", "not", "turned", "into", "instance", "attributes", "class_def", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "name", "hi", "a", "a", "name", "a", "name", "inferred", "next", "class_def", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "inferred", "instance_attrs", "both", "the", "class", "and", "instance", "can", "still", "access", "the", "attribute", "for", "node", "in", "klass", "instance", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi"], "doc_len": 90}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_class_var", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_class_var", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_class_var(module: str):\n    \"\"\"Test that class variables with a ClassVar type annotations are not\n    turned into instance attributes.\n    \"\"\"\n    class_def, klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from typing import ClassVar\n\n    @dataclass\n    class A:\n        name: ClassVar[str] = 'hi'\n\n    A #@\n    A.name  #@\n    A().name #@\n    \"\"\"\n    )\n    inferred = next(class_def.infer())\n    assert isinstance(inferred, nodes.ClassDef)\n    assert inferred.instance_attrs == {}\n\n    # Both the class and instance can still access the attribute\n    for node in (klass, instance):\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const)\n        assert inferred[0].value == \"hi\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_class_var", "module", "str", "test", "that", "class", "variables", "with", "a", "classvar", "type", "annotations", "are", "not", "turned", "into", "instance", "attributes", "class_def", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing", "import", "classvar", "dataclass", "class", "a", "name", "classvar", "str", "hi", "a", "a", "name", "a", "name", "inferred", "next", "class_def", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "inferred", "instance_attrs", "both", "the", "class", "and", "instance", "can", "still", "access", "the", "attribute", "for", "node", "in", "klass", "instance", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi"], "doc_len": 98}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_init_var", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_init_var", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_init_var(module: str):\n    \"\"\"Test that class variables with InitVar type annotations are not\n    turned into instance attributes.\n    \"\"\"\n    class_def, klass, instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import InitVar\n\n    @dataclass\n    class A:\n        name: InitVar[str] = 'hi'\n\n    A  #@\n    A.name  #@\n    A().name #@\n    \"\"\"\n    )\n    inferred = next(class_def.infer())\n    assert isinstance(inferred, nodes.ClassDef)\n    assert inferred.instance_attrs == {}\n\n    # Both the class and instance can still access the attribute\n    for node in (klass, instance):\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const)\n        assert inferred[0].value == \"hi\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_init_var", "module", "str", "test", "that", "class", "variables", "with", "initvar", "type", "annotations", "are", "not", "turned", "into", "instance", "attributes", "class_def", "klass", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "initvar", "dataclass", "class", "a", "name", "initvar", "str", "hi", "a", "a", "name", "a", "name", "inferred", "next", "class_def", "infer", "assert", "isinstance", "inferred", "nodes", "classdef", "assert", "inferred", "instance_attrs", "both", "the", "class", "and", "instance", "can", "still", "access", "the", "attribute", "for", "node", "in", "klass", "instance", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi"], "doc_len": 97}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_generic_collection_attribute", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_generic_collection_attribute", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_generic_collection_attribute(module: str):\n    \"\"\"Test that an attribute with a generic collection type from the\n    typing module is inferred correctly.\n    \"\"\"\n    attr_nodes = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import field\n    import typing\n\n    @dataclass\n    class A:\n        dict_prop: typing.Dict[str, str]\n        frozenset_prop: typing.FrozenSet[str]\n        list_prop: typing.List[str]\n        set_prop: typing.Set[str]\n        tuple_prop: typing.Tuple[int, str]\n\n    a = A({{}}, frozenset(), [], set(), (1, 'hi'))\n    a.dict_prop       #@\n    a.frozenset_prop  #@\n    a.list_prop       #@\n    a.set_prop        #@\n    a.tuple_prop      #@\n    \"\"\"\n    )\n    names = (\n        \"Dict\",\n        \"FrozenSet\",\n        \"List\",\n        \"Set\",\n        \"Tuple\",\n    )\n    for node, name in zip(attr_nodes, names):\n        inferred = next(node.infer())\n        assert isinstance(inferred, bases.Instance)\n        assert inferred.name == name\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_generic_collection_attribute", "module", "str", "test", "that", "an", "attribute", "with", "a", "generic", "collection", "type", "from", "the", "typing", "module", "is", "inferred", "correctly", "attr_nodes", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "import", "typing", "dataclass", "class", "a", "dict_prop", "typing", "dict", "str", "str", "frozenset_prop", "typing", "frozenset", "str", "list_prop", "typing", "list", "str", "set_prop", "typing", "set", "str", "tuple_prop", "typing", "tuple", "int", "str", "a", "a", "frozenset", "set", "1", "hi", "a", "dict_prop", "a", "frozenset_prop", "a", "list_prop", "a", "set_prop", "a", "tuple_prop", "names", "dict", "frozenset", "list", "set", "tuple", "for", "node", "name", "in", "zip", "attr_nodes", "names", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "bases", "instance", "assert", "inferred", "name", "name"], "doc_len": 104}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_callable_attribute", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_callable_attribute", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_callable_attribute(module: str, typing_module: str):\n    \"\"\"Test that an attribute with a Callable annotation is inferred as Uninferable.\n\n    See issue #1129 and PyCQA/pylint#4895\n    \"\"\"\n    instance = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from {typing_module} import Any, Callable\n\n    @dataclass\n    class A:\n        enabled: Callable[[Any], bool]\n\n    A(lambda x: x == 42).enabled  #@\n    \"\"\"\n    )\n    inferred = next(instance.infer())\n    assert inferred is Uninferable\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_callable_attribute", "module", "str", "typing_module", "str", "test", "that", "an", "attribute", "with", "a", "callable", "annotation", "is", "inferred", "as", "uninferable", "see", "issue", "1129", "and", "pycqa", "pylint", "4895", "instance", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing_module", "import", "any", "callable", "dataclass", "class", "a", "enabled", "callable", "any", "bool", "a", "lambda", "x", "x", "42", "enabled", "inferred", "next", "instance", "infer", "assert", "inferred", "is", "uninferable"], "doc_len": 62}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_inference_inherited", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_inference_inherited", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_inference_inherited(module: str):\n    \"\"\"Test that an attribute is inherited from a superclass dataclass.\"\"\"\n    klass1, instance1, klass2, instance2 = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        value: int\n        name: str = \"hi\"\n\n    @dataclass\n    class B(A):\n        new_attr: bool = True\n\n    B.value  #@\n    B(1).value  #@\n    B.name  #@\n    B(1).name  #@\n    \"\"\"\n    )\n    with pytest.raises(InferenceError):  # B.value is not defined\n        klass1.inferred()\n\n    inferred = instance1.inferred()\n    assert isinstance(inferred[0], bases.Instance)\n    assert inferred[0].name == \"int\"\n\n    inferred = klass2.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n\n    inferred = instance2.inferred()\n    assert len(inferred) == 2\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hi\"\n    assert isinstance(inferred[1], bases.Instance)\n    assert inferred[1].name == \"str\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_inference_inherited", "module", "str", "test", "that", "an", "attribute", "is", "inherited", "from", "a", "superclass", "dataclass", "klass1", "instance1", "klass2", "instance2", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "value", "int", "name", "str", "hi", "dataclass", "class", "b", "a", "new_attr", "bool", "true", "b", "value", "b", "1", "value", "b", "name", "b", "1", "name", "with", "pytest", "raises", "inferenceerror", "b", "value", "is", "not", "defined", "klass1", "inferred", "inferred", "instance1", "inferred", "assert", "isinstance", "inferred", "0", "bases", "instance", "assert", "inferred", "0", "name", "int", "inferred", "klass2", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "inferred", "instance2", "inferred", "assert", "len", "inferred", "2", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hi", "assert", "isinstance", "inferred", "1", "bases", "instance", "assert", "inferred", "1", "name", "str"], "doc_len": 125}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_pydantic_field", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_pydantic_field", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_pydantic_field() -> None:\n    \"\"\"Test that pydantic.Field attributes are currently Uninferable.\n\n    (Eventually, we can extend the brain to support pydantic.Field)\n    \"\"\"\n    klass, instance = astroid.extract_node(\n        \"\"\"\n    from pydantic import Field\n    from pydantic.dataclasses import dataclass\n\n    @dataclass\n    class A:\n        name: str = Field(\"hi\")\n\n    A.name  #@\n    A().name #@\n    \"\"\"\n    )\n\n    inferred = klass.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n\n    inferred = instance.inferred()\n    assert len(inferred) == 2\n    assert inferred[0] is Uninferable\n    assert isinstance(inferred[1], bases.Instance)\n    assert inferred[1].name == \"str\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_pydantic_field", "none", "test", "that", "pydantic", "field", "attributes", "are", "currently", "uninferable", "eventually", "we", "can", "extend", "the", "brain", "to", "support", "pydantic", "field", "klass", "instance", "astroid", "extract_node", "from", "pydantic", "import", "field", "from", "pydantic", "dataclasses", "import", "dataclass", "dataclass", "class", "a", "name", "str", "field", "hi", "a", "name", "a", "name", "inferred", "klass", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable", "inferred", "instance", "inferred", "assert", "len", "inferred", "2", "assert", "inferred", "0", "is", "uninferable", "assert", "isinstance", "inferred", "1", "bases", "instance", "assert", "inferred", "1", "name", "str"], "doc_len": 83}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_empty", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_empty", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_empty(module: str):\n    \"\"\"Test init for a dataclass with no attributes\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        pass\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\"]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_empty", "module", "str", "test", "init", "for", "a", "dataclass", "with", "no", "attributes", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "pass", "a", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self"], "doc_len": 43}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_no_defaults", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_no_defaults", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_no_defaults(module: str):\n    \"\"\"Test init for a dataclass with attributes and no defaults\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from typing import List\n\n    @dataclass\n    class A:\n        x: int\n        y: str\n        z: List[bool]\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"x\", \"y\", \"z\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"int\",\n        \"str\",\n        \"List[bool]\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_no_defaults", "module", "str", "test", "init", "for", "a", "dataclass", "with", "attributes", "and", "no", "defaults", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing", "import", "list", "dataclass", "class", "a", "x", "int", "y", "str", "z", "list", "bool", "a", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "x", "y", "z", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "int", "str", "list", "bool"], "doc_len": 76}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_defaults", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_defaults", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_defaults(module: str):\n    \"\"\"Test init for a dataclass with attributes and some defaults\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import field\n    from typing import List\n\n    @dataclass\n    class A:\n        w: int\n        x: int = 10\n        y: str = field(default=\"hi\")\n        z: List[bool] = field(default_factory=list)\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"w\", \"x\", \"y\", \"z\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"int\",\n        \"int\",\n        \"str\",\n        \"List[bool]\",\n    ]\n    assert [a.as_string() if a else None for a in init.args.defaults] == [\n        \"10\",\n        \"'hi'\",\n        \"_HAS_DEFAULT_FACTORY\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_defaults", "module", "str", "test", "init", "for", "a", "dataclass", "with", "attributes", "and", "some", "defaults", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "from", "typing", "import", "list", "dataclass", "class", "a", "w", "int", "x", "int", "10", "y", "str", "field", "default", "hi", "z", "list", "bool", "field", "default_factory", "list", "a", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "w", "x", "y", "z", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "int", "int", "str", "list", "bool", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "defaults", "10", "hi", "_has_default_factory"], "doc_len": 107}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_initvar", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_initvar", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_initvar(module: str):\n    \"\"\"Test init for a dataclass with attributes and an InitVar\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import InitVar\n    from typing import List\n\n    @dataclass\n    class A:\n        x: int\n        y: str\n        init_var: InitVar[int]\n        z: List[bool]\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"x\", \"y\", \"init_var\", \"z\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"int\",\n        \"str\",\n        \"int\",\n        \"List[bool]\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_initvar", "module", "str", "test", "init", "for", "a", "dataclass", "with", "attributes", "and", "an", "initvar", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "initvar", "from", "typing", "import", "list", "dataclass", "class", "a", "x", "int", "y", "str", "init_var", "initvar", "int", "z", "list", "bool", "a", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "x", "y", "init_var", "z", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "int", "str", "int", "list", "bool"], "doc_len": 85}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_decorator_init_false", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_decorator_init_false", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_decorator_init_false(module: str):\n    \"\"\"Test that no init is generated when init=False is passed to\n    dataclass decorator.\n    \"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from typing import List\n\n    @dataclass(init=False)\n    class A:\n        x: int\n        y: str\n        z: List[bool]\n\n    A.__init__ #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert init._proxied.parent.name == \"object\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_decorator_init_false", "module", "str", "test", "that", "no", "init", "is", "generated", "when", "init", "false", "is", "passed", "to", "dataclass", "decorator", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing", "import", "list", "dataclass", "init", "false", "class", "a", "x", "int", "y", "str", "z", "list", "bool", "a", "__init__", "init", "next", "node", "infer", "assert", "init", "_proxied", "parent", "name", "object"], "doc_len": 57}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_field_init_false", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_field_init_false", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_field_init_false(module: str):\n    \"\"\"Test init for a dataclass with attributes with a field value where init=False\n    (these attributes should not be included in the initializer).\n    \"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from dataclasses import field\n    from typing import List\n\n    @dataclass\n    class A:\n        x: int\n        y: str\n        z: List[bool] = field(init=False)\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"x\", \"y\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"int\",\n        \"str\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_field_init_false", "module", "str", "test", "init", "for", "a", "dataclass", "with", "attributes", "with", "a", "field", "value", "where", "init", "false", "these", "attributes", "should", "not", "be", "included", "in", "the", "initializer", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "dataclasses", "import", "field", "from", "typing", "import", "list", "dataclass", "class", "a", "x", "int", "y", "str", "z", "list", "bool", "field", "init", "false", "a", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "x", "y", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "int", "str"], "doc_len": 93}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_override", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_override", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_override(module: str):\n    \"\"\"Test init for a dataclass overrides a superclass initializer.\n\n    Based on https://github.com/PyCQA/pylint/issues/3201\n    \"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from typing import List\n\n    class A:\n        arg0: str = None\n\n        def __init__(self, arg0):\n            raise NotImplementedError\n\n    @dataclass\n    class B(A):\n        arg1: int = None\n        arg2: str = None\n\n    B.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"arg1\", \"arg2\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"int\",\n        \"str\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_override", "module", "str", "test", "init", "for", "a", "dataclass", "overrides", "a", "superclass", "initializer", "based", "on", "https", "github", "com", "pycqa", "pylint", "issues", "3201", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing", "import", "list", "class", "a", "arg0", "str", "none", "def", "__init__", "self", "arg0", "raise", "notimplementederror", "dataclass", "class", "b", "a", "arg1", "int", "none", "arg2", "str", "none", "b", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "arg1", "arg2", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "int", "str"], "doc_len": 92}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_init_attributes_from_superclasses", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_init_attributes_from_superclasses", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_init_attributes_from_superclasses(module: str):\n    \"\"\"Test init for a dataclass that inherits and overrides attributes from superclasses.\n\n    Based on https://github.com/PyCQA/pylint/issues/3201\n    \"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n    from typing import List\n\n    @dataclass\n    class A:\n        arg0: float\n        arg2: str\n\n    @dataclass\n    class B(A):\n        arg1: int\n        arg2: list  # Overrides arg2 from A\n\n    B.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert [a.name for a in init.args.args] == [\"self\", \"arg0\", \"arg2\", \"arg1\"]\n    assert [a.as_string() if a else None for a in init.args.annotations] == [\n        None,\n        \"float\",\n        \"list\",  # not str\n        \"int\",\n    ]\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_init_attributes_from_superclasses", "module", "str", "test", "init", "for", "a", "dataclass", "that", "inherits", "and", "overrides", "attributes", "from", "superclasses", "based", "on", "https", "github", "com", "pycqa", "pylint", "issues", "3201", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "from", "typing", "import", "list", "dataclass", "class", "a", "arg0", "float", "arg2", "str", "dataclass", "class", "b", "a", "arg1", "int", "arg2", "list", "overrides", "arg2", "from", "a", "b", "__init__", "init", "next", "node", "infer", "assert", "a", "name", "for", "a", "in", "init", "args", "args", "self", "arg0", "arg2", "arg1", "assert", "a", "as_string", "if", "a", "else", "none", "for", "a", "in", "init", "args", "annotations", "none", "float", "list", "not", "str", "int"], "doc_len": 97}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_invalid_init", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_invalid_init", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_invalid_init(module: str):\n    \"\"\"Test that astroid doesn't generate an initializer when attribute order is invalid.\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass\n\n    @dataclass\n    class A:\n        arg1: float = 0.0\n        arg2: str\n\n    A.__init__  #@\n    \"\"\"\n    )\n    init = next(node.infer())\n    assert init._proxied.parent.name == \"object\"\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_invalid_init", "module", "str", "test", "that", "astroid", "doesn", "t", "generate", "an", "initializer", "when", "attribute", "order", "is", "invalid", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "dataclass", "class", "a", "arg1", "float", "0", "0", "arg2", "str", "a", "__init__", "init", "next", "node", "infer", "assert", "init", "_proxied", "parent", "name", "object"], "doc_len": 49}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_annotated_enclosed_field_call", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_annotated_enclosed_field_call", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_annotated_enclosed_field_call(module: str):\n    \"\"\"Test inference of dataclass attribute with a field call in another function call\"\"\"\n    node = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass, field\n    from typing import cast\n\n    @dataclass\n    class A:\n        attribute: int = cast(int, field(default_factory=dict))\n    \"\"\"\n    )\n    inferred = node.inferred()\n    assert len(inferred) == 1 and isinstance(inferred[0], nodes.ClassDef)\n    assert \"attribute\" in inferred[0].instance_attrs\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_annotated_enclosed_field_call", "module", "str", "test", "inference", "of", "dataclass", "attribute", "with", "a", "field", "call", "in", "another", "function", "call", "node", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "field", "from", "typing", "import", "cast", "dataclass", "class", "a", "attribute", "int", "cast", "int", "field", "default_factory", "dict", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "and", "isinstance", "inferred", "0", "nodes", "classdef", "assert", "attribute", "in", "inferred", "0", "instance_attrs"], "doc_len": 62}
{"doc_id": "tests/unittest_brain_dataclasses.py::test_invalid_field_call", "file_path": "tests/unittest_brain_dataclasses.py", "class_name": null, "func_name": "test_invalid_field_call", "text": "文件路径: tests/unittest_brain_dataclasses.py\ndef test_invalid_field_call(module: str) -> None:\n    \"\"\"Test inference of invalid field call doesn't crash.\"\"\"\n    code = astroid.extract_node(\n        f\"\"\"\n    from {module} import dataclass, field\n\n    @dataclass\n    class A:\n        val: field()\n    \"\"\"\n    )\n    inferred = code.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.ClassDef)\n", "tokens": ["tests", "unittest_brain_dataclasses", "py", "def", "test_invalid_field_call", "module", "str", "none", "test", "inference", "of", "invalid", "field", "call", "doesn", "t", "crash", "code", "astroid", "extract_node", "f", "from", "module", "import", "dataclass", "field", "dataclass", "class", "a", "val", "field", "inferred", "code", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "classdef"], "doc_len": 44}
{"doc_id": "tests/unittest_brain_numpy_core_fromnumeric.py::BrainNumpyCoreFromNumericTest._inferred_numpy_func_call", "file_path": "tests/unittest_brain_numpy_core_fromnumeric.py", "class_name": "BrainNumpyCoreFromNumericTest", "func_name": "_inferred_numpy_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_fromnumeric.py, 类名: BrainNumpyCoreFromNumericTest\n    def _inferred_numpy_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        func = np.{func_name:s}\n        func({','.join(func_args):s})\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_fromnumeric", "py", "brainnumpycorefromnumerictest", "def", "_inferred_numpy_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "func", "np", "func_name", "s", "func", "join", "func_args", "s", "return", "node", "infer"], "doc_len": 28}
{"doc_id": "tests/unittest_brain_numpy_core_fromnumeric.py::BrainNumpyCoreFromNumericTest.test_numpy_function_calls_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_core_fromnumeric.py", "class_name": "BrainNumpyCoreFromNumericTest", "func_name": "test_numpy_function_calls_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_core_fromnumeric.py, 类名: BrainNumpyCoreFromNumericTest\n    def test_numpy_function_calls_inferred_as_ndarray(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as numpy.ndarray\n        \"\"\"\n        licit_array_types = (\".ndarray\",)\n        for func_ in self.numpy_functions:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_numpy_func_call(*func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred value for {func_[0]:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() in licit_array_types,\n                    msg=f\"Illicit type for {func_[0]:s} ({inferred_values[-1].pytype()})\",\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_fromnumeric", "py", "brainnumpycorefromnumerictest", "def", "test_numpy_function_calls_inferred_as_ndarray", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "ndarray", "licit_array_types", "ndarray", "for", "func_", "in", "self", "numpy_functions", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_numpy_func_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "value", "for", "func_", "0", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "f", "illicit", "type", "for", "func_", "0", "s", "inferred_values", "1", "pytype"], "doc_len": 68}
{"doc_id": "tests/unittest_brain_numpy_core_function_base.py::BrainNumpyCoreFunctionBaseTest._inferred_numpy_func_call", "file_path": "tests/unittest_brain_numpy_core_function_base.py", "class_name": "BrainNumpyCoreFunctionBaseTest", "func_name": "_inferred_numpy_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_function_base.py, 类名: BrainNumpyCoreFunctionBaseTest\n    def _inferred_numpy_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        func = np.{func_name:s}\n        func({','.join(func_args):s})\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_function_base", "py", "brainnumpycorefunctionbasetest", "def", "_inferred_numpy_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "func", "np", "func_name", "s", "func", "join", "func_args", "s", "return", "node", "infer"], "doc_len": 28}
{"doc_id": "tests/unittest_brain_numpy_core_function_base.py::BrainNumpyCoreFunctionBaseTest.test_numpy_function_calls_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_core_function_base.py", "class_name": "BrainNumpyCoreFunctionBaseTest", "func_name": "test_numpy_function_calls_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_core_function_base.py, 类名: BrainNumpyCoreFunctionBaseTest\n    def test_numpy_function_calls_inferred_as_ndarray(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as numpy.ndarray\n        \"\"\"\n        licit_array_types = (\".ndarray\",)\n        for func_ in self.numpy_functions:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_numpy_func_call(*func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred value for {func_[0]:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() in licit_array_types,\n                    msg=\"Illicit type for {:s} ({})\".format(\n                        func_[0], inferred_values[-1].pytype()\n                    ),\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_function_base", "py", "brainnumpycorefunctionbasetest", "def", "test_numpy_function_calls_inferred_as_ndarray", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "ndarray", "licit_array_types", "ndarray", "for", "func_", "in", "self", "numpy_functions", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_numpy_func_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "value", "for", "func_", "0", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 68}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest._inferred_numpy_func_call", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "_inferred_numpy_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def _inferred_numpy_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        func = np.{func_name:s}\n        func({','.join(func_args):s})\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "_inferred_numpy_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "func", "np", "func_name", "s", "func", "join", "func_args", "s", "return", "node", "infer"], "doc_len": 28}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest._inferred_numpy_no_alias_func_call", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "_inferred_numpy_no_alias_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def _inferred_numpy_no_alias_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy\n        func = numpy.{func_name:s}\n        func({','.join(func_args):s})\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "_inferred_numpy_no_alias_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "func", "numpy", "func_name", "s", "func", "join", "func_args", "s", "return", "node", "infer"], "doc_len": 26}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest.test_numpy_function_calls_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "test_numpy_function_calls_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def test_numpy_function_calls_inferred_as_ndarray(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as numpy.ndarray\n        \"\"\"\n        for infer_wrapper in (\n            self._inferred_numpy_func_call,\n            self._inferred_numpy_no_alias_func_call,\n        ):\n            for func_ in self.numpy_functions_returning_array:\n                with self.subTest(typ=func_):\n                    inferred_values = list(infer_wrapper(*func_))\n                    self.assertTrue(\n                        len(inferred_values) == 1,\n                        msg=\"Too much inferred values ({}) for {:s}\".format(\n                            inferred_values, func_[0]\n                        ),\n                    )\n                    self.assertTrue(\n                        inferred_values[-1].pytype() == \".ndarray\",\n                        msg=\"Illicit type for {:s} ({})\".format(\n                            func_[0], inferred_values[-1].pytype()\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "test_numpy_function_calls_inferred_as_ndarray", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "ndarray", "for", "infer_wrapper", "in", "self", "_inferred_numpy_func_call", "self", "_inferred_numpy_no_alias_func_call", "for", "func_", "in", "self", "numpy_functions_returning_array", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "infer_wrapper", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "func_", "0", "self", "asserttrue", "inferred_values", "1", "pytype", "ndarray", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 72}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest.test_numpy_function_calls_inferred_as_bool", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "test_numpy_function_calls_inferred_as_bool", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def test_numpy_function_calls_inferred_as_bool(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as bool\n        \"\"\"\n        for infer_wrapper in (\n            self._inferred_numpy_func_call,\n            self._inferred_numpy_no_alias_func_call,\n        ):\n            for func_ in self.numpy_functions_returning_bool:\n                with self.subTest(typ=func_):\n                    inferred_values = list(infer_wrapper(*func_))\n                    self.assertTrue(\n                        len(inferred_values) == 1,\n                        msg=\"Too much inferred values ({}) for {:s}\".format(\n                            inferred_values, func_[0]\n                        ),\n                    )\n                    self.assertTrue(\n                        inferred_values[-1].pytype() == \"builtins.bool\",\n                        msg=\"Illicit type for {:s} ({})\".format(\n                            func_[0], inferred_values[-1].pytype()\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "test_numpy_function_calls_inferred_as_bool", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "bool", "for", "infer_wrapper", "in", "self", "_inferred_numpy_func_call", "self", "_inferred_numpy_no_alias_func_call", "for", "func_", "in", "self", "numpy_functions_returning_bool", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "infer_wrapper", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "func_", "0", "self", "asserttrue", "inferred_values", "1", "pytype", "builtins", "bool", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 72}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest.test_numpy_function_calls_inferred_as_dtype", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "test_numpy_function_calls_inferred_as_dtype", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def test_numpy_function_calls_inferred_as_dtype(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as numpy.dtype\n        \"\"\"\n        for infer_wrapper in (\n            self._inferred_numpy_func_call,\n            self._inferred_numpy_no_alias_func_call,\n        ):\n            for func_ in self.numpy_functions_returning_dtype:\n                with self.subTest(typ=func_):\n                    inferred_values = list(infer_wrapper(*func_))\n                    self.assertTrue(\n                        len(inferred_values) == 1,\n                        msg=\"Too much inferred values ({}) for {:s}\".format(\n                            inferred_values, func_[0]\n                        ),\n                    )\n                    self.assertTrue(\n                        inferred_values[-1].pytype() == \"numpy.dtype\",\n                        msg=\"Illicit type for {:s} ({})\".format(\n                            func_[0], inferred_values[-1].pytype()\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "test_numpy_function_calls_inferred_as_dtype", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "dtype", "for", "infer_wrapper", "in", "self", "_inferred_numpy_func_call", "self", "_inferred_numpy_no_alias_func_call", "for", "func_", "in", "self", "numpy_functions_returning_dtype", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "infer_wrapper", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "func_", "0", "self", "asserttrue", "inferred_values", "1", "pytype", "numpy", "dtype", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 73}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest.test_numpy_function_calls_inferred_as_none", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "test_numpy_function_calls_inferred_as_none", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def test_numpy_function_calls_inferred_as_none(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as None\n        \"\"\"\n        for infer_wrapper in (\n            self._inferred_numpy_func_call,\n            self._inferred_numpy_no_alias_func_call,\n        ):\n            for func_ in self.numpy_functions_returning_none:\n                with self.subTest(typ=func_):\n                    inferred_values = list(infer_wrapper(*func_))\n                    self.assertTrue(\n                        len(inferred_values) == 1,\n                        msg=\"Too much inferred values ({}) for {:s}\".format(\n                            inferred_values, func_[0]\n                        ),\n                    )\n                    self.assertTrue(\n                        inferred_values[-1].pytype() == \"builtins.NoneType\",\n                        msg=\"Illicit type for {:s} ({})\".format(\n                            func_[0], inferred_values[-1].pytype()\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "test_numpy_function_calls_inferred_as_none", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "none", "for", "infer_wrapper", "in", "self", "_inferred_numpy_func_call", "self", "_inferred_numpy_no_alias_func_call", "for", "func_", "in", "self", "numpy_functions_returning_none", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "infer_wrapper", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "func_", "0", "self", "asserttrue", "inferred_values", "1", "pytype", "builtins", "nonetype", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 72}
{"doc_id": "tests/unittest_brain_numpy_core_multiarray.py::BrainNumpyCoreMultiarrayTest.test_numpy_function_calls_inferred_as_tuple", "file_path": "tests/unittest_brain_numpy_core_multiarray.py", "class_name": "BrainNumpyCoreMultiarrayTest", "func_name": "test_numpy_function_calls_inferred_as_tuple", "text": "文件路径: tests/unittest_brain_numpy_core_multiarray.py, 类名: BrainNumpyCoreMultiarrayTest\n    def test_numpy_function_calls_inferred_as_tuple(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as tuple\n        \"\"\"\n        for infer_wrapper in (\n            self._inferred_numpy_func_call,\n            self._inferred_numpy_no_alias_func_call,\n        ):\n            for func_ in self.numpy_functions_returning_tuple:\n                with self.subTest(typ=func_):\n                    inferred_values = list(infer_wrapper(*func_))\n                    self.assertTrue(\n                        len(inferred_values) == 1,\n                        msg=\"Too much inferred values ({}) for {:s}\".format(\n                            inferred_values, func_[0]\n                        ),\n                    )\n                    self.assertTrue(\n                        inferred_values[-1].pytype() == \"builtins.tuple\",\n                        msg=\"Illicit type for {:s} ({})\".format(\n                            func_[0], inferred_values[-1].pytype()\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_multiarray", "py", "brainnumpycoremultiarraytest", "def", "test_numpy_function_calls_inferred_as_tuple", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "tuple", "for", "infer_wrapper", "in", "self", "_inferred_numpy_func_call", "self", "_inferred_numpy_no_alias_func_call", "for", "func_", "in", "self", "numpy_functions_returning_tuple", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "infer_wrapper", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "func_", "0", "self", "asserttrue", "inferred_values", "1", "pytype", "builtins", "tuple", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 72}
{"doc_id": "tests/unittest_brain_numpy_core_numeric.py::BrainNumpyCoreNumericTest._inferred_numpy_func_call", "file_path": "tests/unittest_brain_numpy_core_numeric.py", "class_name": "BrainNumpyCoreNumericTest", "func_name": "_inferred_numpy_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_numeric.py, 类名: BrainNumpyCoreNumericTest\n    def _inferred_numpy_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        func = np.{func_name:s}\n        func({','.join(func_args):s})\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_numeric", "py", "brainnumpycorenumerictest", "def", "_inferred_numpy_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "func", "np", "func_name", "s", "func", "join", "func_args", "s", "return", "node", "infer"], "doc_len": 28}
{"doc_id": "tests/unittest_brain_numpy_core_numeric.py::BrainNumpyCoreNumericTest.test_numpy_function_calls_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_core_numeric.py", "class_name": "BrainNumpyCoreNumericTest", "func_name": "test_numpy_function_calls_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_core_numeric.py, 类名: BrainNumpyCoreNumericTest\n    def test_numpy_function_calls_inferred_as_ndarray(self):\n        \"\"\"\n        Test that calls to numpy functions are inferred as numpy.ndarray\n        \"\"\"\n        licit_array_types = (\".ndarray\",)\n        for func_ in self.numpy_functions:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_numpy_func_call(*func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred value for {func_[0]:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() in licit_array_types,\n                    msg=\"Illicit type for {:s} ({})\".format(\n                        func_[0], inferred_values[-1].pytype()\n                    ),\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_numeric", "py", "brainnumpycorenumerictest", "def", "test_numpy_function_calls_inferred_as_ndarray", "self", "test", "that", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "ndarray", "licit_array_types", "ndarray", "for", "func_", "in", "self", "numpy_functions", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_numpy_func_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "value", "for", "func_", "0", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "illicit", "type", "for", "s", "format", "func_", "0", "inferred_values", "1", "pytype"], "doc_len": 68}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest._inferred_numpy_attribute", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "_inferred_numpy_attribute", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def _inferred_numpy_attribute(self, attrib):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy.core.numerictypes as tested_module\n        missing_type = tested_module.{attrib:s}\"\"\"\n        )\n        return next(node.value.infer())\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "_inferred_numpy_attribute", "self", "attrib", "node", "builder", "extract_node", "f", "import", "numpy", "core", "numerictypes", "as", "tested_module", "missing_type", "tested_module", "attrib", "s", "return", "next", "node", "value", "infer"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_numpy_core_types", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_numpy_core_types", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_numpy_core_types(self):\n        \"\"\"\n        Test that all defined types have ClassDef type.\n        \"\"\"\n        for typ in self.all_types:\n            with self.subTest(typ=typ):\n                inferred = self._inferred_numpy_attribute(typ)\n                self.assertIsInstance(inferred, nodes.ClassDef)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_numpy_core_types", "self", "test", "that", "all", "defined", "types", "have", "classdef", "type", "for", "typ", "in", "self", "all_types", "with", "self", "subtest", "typ", "typ", "inferred", "self", "_inferred_numpy_attribute", "typ", "self", "assertisinstance", "inferred", "nodes", "classdef"], "doc_len": 34}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_generic_types_have_methods", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_generic_types_have_methods", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_generic_types_have_methods(self):\n        \"\"\"\n        Test that all generic derived types have specified methods\n        \"\"\"\n        generic_methods = [\n            \"all\",\n            \"any\",\n            \"argmax\",\n            \"argmin\",\n            \"argsort\",\n            \"astype\",\n            \"base\",\n            \"byteswap\",\n            \"choose\",\n            \"clip\",\n            \"compress\",\n            \"conj\",\n            \"conjugate\",\n            \"copy\",\n            \"cumprod\",\n            \"cumsum\",\n            \"data\",\n            \"diagonal\",\n            \"dtype\",\n            \"dump\",\n            \"dumps\",\n            \"fill\",\n            \"flags\",\n            \"flat\",\n            \"flatten\",\n            \"getfield\",\n            \"imag\",\n            \"item\",\n            \"itemset\",\n            \"itemsize\",\n            \"max\",\n            \"mean\",\n            \"min\",\n            \"nbytes\",\n            \"ndim\",\n            \"newbyteorder\",\n            \"nonzero\",\n            \"prod\",\n            \"ptp\",\n            \"put\",\n            \"ravel\",\n            \"real\",\n            \"repeat\",\n            \"reshape\",\n            \"resize\",\n            \"round\",\n            \"searchsorted\",\n            \"setfield\",\n            \"setflags\",\n            \"shape\",\n            \"size\",\n            \"sort\",\n            \"squeeze\",\n            \"std\",\n            \"strides\",\n            \"sum\",\n            \"swapaxes\",\n            \"take\",\n            \"tobytes\",\n            \"tofile\",\n            \"tolist\",\n            \"tostring\",\n            \"trace\",\n            \"transpose\",\n            \"var\",\n            \"view\",\n        ]\n\n        for type_ in (\n            \"bool_\",\n            \"bytes_\",\n            \"character\",\n            \"complex128\",\n            \"complex192\",\n            \"complex64\",\n            \"complexfloating\",\n            \"datetime64\",\n            \"flexible\",\n            \"float16\",\n            \"float32\",\n            \"float64\",\n            \"float96\",\n            \"floating\",\n            \"generic\",\n            \"inexact\",\n            \"int16\",\n            \"int32\",\n            \"int32\",\n            \"int64\",\n            \"int8\",\n            \"integer\",\n            \"number\",\n            \"signedinteger\",\n            \"str_\",\n            \"timedelta64\",\n            \"uint16\",\n            \"uint32\",\n            \"uint32\",\n            \"uint64\",\n            \"uint8\",\n            \"unsignedinteger\",\n            \"void\",\n        ):\n            with self.subTest(typ=type_):\n                inferred = self._inferred_numpy_attribute(type_)\n                for meth in generic_methods:\n                    with self.subTest(meth=meth):\n                        self.assertTrue(meth in {m.name for m in inferred.methods()})\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_generic_types_have_methods", "self", "test", "that", "all", "generic", "derived", "types", "have", "specified", "methods", "generic_methods", "all", "any", "argmax", "argmin", "argsort", "astype", "base", "byteswap", "choose", "clip", "compress", "conj", "conjugate", "copy", "cumprod", "cumsum", "data", "diagonal", "dtype", "dump", "dumps", "fill", "flags", "flat", "flatten", "getfield", "imag", "item", "itemset", "itemsize", "max", "mean", "min", "nbytes", "ndim", "newbyteorder", "nonzero", "prod", "ptp", "put", "ravel", "real", "repeat", "reshape", "resize", "round", "searchsorted", "setfield", "setflags", "shape", "size", "sort", "squeeze", "std", "strides", "sum", "swapaxes", "take", "tobytes", "tofile", "tolist", "tostring", "trace", "transpose", "var", "view", "for", "type_", "in", "bool_", "bytes_", "character", "complex128", "complex192", "complex64", "complexfloating", "datetime64", "flexible", "float16", "float32", "float64", "float96", "floating", "generic", "inexact", "int16", "int32", "int32", "int64", "int8", "integer", "number", "signedinteger", "str_", "timedelta64", "uint16", "uint32", "uint32", "uint64", "uint8", "unsignedinteger", "void", "with", "self", "subtest", "typ", "type_", "inferred", "self", "_inferred_numpy_attribute", "type_", "for", "meth", "in", "generic_methods", "with", "self", "subtest", "meth", "meth", "self", "asserttrue", "meth", "in", "m", "name", "for", "m", "in", "inferred", "methods"], "doc_len": 148}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_generic_types_have_attributes", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_generic_types_have_attributes", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_generic_types_have_attributes(self):\n        \"\"\"\n        Test that all generic derived types have specified attributes\n        \"\"\"\n        generic_attr = [\n            \"base\",\n            \"data\",\n            \"dtype\",\n            \"flags\",\n            \"flat\",\n            \"imag\",\n            \"itemsize\",\n            \"nbytes\",\n            \"ndim\",\n            \"real\",\n            \"size\",\n            \"strides\",\n        ]\n\n        for type_ in (\n            \"bool_\",\n            \"bytes_\",\n            \"character\",\n            \"complex128\",\n            \"complex192\",\n            \"complex64\",\n            \"complexfloating\",\n            \"datetime64\",\n            \"flexible\",\n            \"float16\",\n            \"float32\",\n            \"float64\",\n            \"float96\",\n            \"floating\",\n            \"generic\",\n            \"inexact\",\n            \"int16\",\n            \"int32\",\n            \"int32\",\n            \"int64\",\n            \"int8\",\n            \"integer\",\n            \"number\",\n            \"signedinteger\",\n            \"str_\",\n            \"timedelta64\",\n            \"uint16\",\n            \"uint32\",\n            \"uint32\",\n            \"uint64\",\n            \"uint8\",\n            \"unsignedinteger\",\n            \"void\",\n        ):\n            with self.subTest(typ=type_):\n                inferred = self._inferred_numpy_attribute(type_)\n                for attr in generic_attr:\n                    with self.subTest(attr=attr):\n                        self.assertNotEqual(len(inferred.getattr(attr)), 0)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_generic_types_have_attributes", "self", "test", "that", "all", "generic", "derived", "types", "have", "specified", "attributes", "generic_attr", "base", "data", "dtype", "flags", "flat", "imag", "itemsize", "nbytes", "ndim", "real", "size", "strides", "for", "type_", "in", "bool_", "bytes_", "character", "complex128", "complex192", "complex64", "complexfloating", "datetime64", "flexible", "float16", "float32", "float64", "float96", "floating", "generic", "inexact", "int16", "int32", "int32", "int64", "int8", "integer", "number", "signedinteger", "str_", "timedelta64", "uint16", "uint32", "uint32", "uint64", "uint8", "unsignedinteger", "void", "with", "self", "subtest", "typ", "type_", "inferred", "self", "_inferred_numpy_attribute", "type_", "for", "attr", "in", "generic_attr", "with", "self", "subtest", "attr", "attr", "self", "assertnotequal", "len", "inferred", "getattr", "attr", "0"], "doc_len": 90}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_number_types_have_unary_operators", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_number_types_have_unary_operators", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_number_types_have_unary_operators(self):\n        \"\"\"\n        Test that number types have unary operators\n        \"\"\"\n        unary_ops = (\"__neg__\",)\n\n        for type_ in (\n            \"float64\",\n            \"float96\",\n            \"floating\",\n            \"int16\",\n            \"int32\",\n            \"int32\",\n            \"int64\",\n            \"int8\",\n            \"integer\",\n            \"number\",\n            \"signedinteger\",\n            \"uint16\",\n            \"uint32\",\n            \"uint32\",\n            \"uint64\",\n            \"uint8\",\n            \"unsignedinteger\",\n        ):\n            with self.subTest(typ=type_):\n                inferred = self._inferred_numpy_attribute(type_)\n                for attr in unary_ops:\n                    with self.subTest(attr=attr):\n                        self.assertNotEqual(len(inferred.getattr(attr)), 0)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_number_types_have_unary_operators", "self", "test", "that", "number", "types", "have", "unary", "operators", "unary_ops", "__neg__", "for", "type_", "in", "float64", "float96", "floating", "int16", "int32", "int32", "int64", "int8", "integer", "number", "signedinteger", "uint16", "uint32", "uint32", "uint64", "uint8", "unsignedinteger", "with", "self", "subtest", "typ", "type_", "inferred", "self", "_inferred_numpy_attribute", "type_", "for", "attr", "in", "unary_ops", "with", "self", "subtest", "attr", "attr", "self", "assertnotequal", "len", "inferred", "getattr", "attr", "0"], "doc_len": 61}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_array_types_have_unary_operators", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_array_types_have_unary_operators", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_array_types_have_unary_operators(self):\n        \"\"\"\n        Test that array types have unary operators\n        \"\"\"\n        unary_ops = (\"__neg__\", \"__invert__\")\n\n        for type_ in (\"ndarray\",):\n            with self.subTest(typ=type_):\n                inferred = self._inferred_numpy_attribute(type_)\n                for attr in unary_ops:\n                    with self.subTest(attr=attr):\n                        self.assertNotEqual(len(inferred.getattr(attr)), 0)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_array_types_have_unary_operators", "self", "test", "that", "array", "types", "have", "unary", "operators", "unary_ops", "__neg__", "__invert__", "for", "type_", "in", "ndarray", "with", "self", "subtest", "typ", "type_", "inferred", "self", "_inferred_numpy_attribute", "type_", "for", "attr", "in", "unary_ops", "with", "self", "subtest", "attr", "attr", "self", "assertnotequal", "len", "inferred", "getattr", "attr", "0"], "doc_len": 46}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_datetime_astype_return", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_datetime_astype_return", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_datetime_astype_return(self):\n        \"\"\"\n        Test that the return of astype method of the datetime object\n        is inferred as a ndarray.\n\n        PyCQA/pylint#3332\n        \"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        import numpy as np\n        import datetime\n        test_array = np.datetime64(1, 'us')\n        test_array.astype(datetime.datetime)\n        \"\"\"\n        )\n        licit_array_types = \".ndarray\"\n        inferred_values = list(node.infer())\n        self.assertTrue(\n            len(inferred_values) == 1,\n            msg=\"Too much inferred value for datetime64.astype\",\n        )\n        self.assertTrue(\n            inferred_values[-1].pytype() in licit_array_types,\n            msg=\"Illicit type for {:s} ({})\".format(\n                \"datetime64.astype\", inferred_values[-1].pytype()\n            ),\n        )\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_datetime_astype_return", "self", "test", "that", "the", "return", "of", "astype", "method", "of", "the", "datetime", "object", "is", "inferred", "as", "a", "ndarray", "pycqa", "pylint", "3332", "node", "builder", "extract_node", "import", "numpy", "as", "np", "import", "datetime", "test_array", "np", "datetime64", "1", "us", "test_array", "astype", "datetime", "datetime", "licit_array_types", "ndarray", "inferred_values", "list", "node", "infer", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "value", "for", "datetime64", "astype", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "illicit", "type", "for", "s", "format", "datetime64", "astype", "inferred_values", "1", "pytype"], "doc_len": 81}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainCoreNumericTypesTest.test_generic_types_are_subscriptables", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainCoreNumericTypesTest", "func_name": "test_generic_types_are_subscriptables", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainCoreNumericTypesTest\n    def test_generic_types_are_subscriptables(self):\n        \"\"\"\n        Test that all types deriving from generic are subscriptables\n        \"\"\"\n        for type_ in (\n            \"bool_\",\n            \"bytes_\",\n            \"character\",\n            \"complex128\",\n            \"complex192\",\n            \"complex64\",\n            \"complexfloating\",\n            \"datetime64\",\n            \"flexible\",\n            \"float16\",\n            \"float32\",\n            \"float64\",\n            \"float96\",\n            \"floating\",\n            \"generic\",\n            \"inexact\",\n            \"int16\",\n            \"int32\",\n            \"int32\",\n            \"int64\",\n            \"int8\",\n            \"integer\",\n            \"number\",\n            \"signedinteger\",\n            \"str_\",\n            \"timedelta64\",\n            \"uint16\",\n            \"uint32\",\n            \"uint32\",\n            \"uint64\",\n            \"uint8\",\n            \"unsignedinteger\",\n            \"void\",\n        ):\n            with self.subTest(type_=type_):\n                src = f\"\"\"\n                import numpy as np\n                np.{type_}[int]\n                \"\"\"\n                node = builder.extract_node(src)\n                cls_node = node.inferred()[0]\n                self.assertIsInstance(cls_node, nodes.ClassDef)\n                self.assertEqual(cls_node.name, type_)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybraincorenumerictypestest", "def", "test_generic_types_are_subscriptables", "self", "test", "that", "all", "types", "deriving", "from", "generic", "are", "subscriptables", "for", "type_", "in", "bool_", "bytes_", "character", "complex128", "complex192", "complex64", "complexfloating", "datetime64", "flexible", "float16", "float32", "float64", "float96", "floating", "generic", "inexact", "int16", "int32", "int32", "int64", "int8", "integer", "number", "signedinteger", "str_", "timedelta64", "uint16", "uint32", "uint32", "uint64", "uint8", "unsignedinteger", "void", "with", "self", "subtest", "type_", "type_", "src", "f", "import", "numpy", "as", "np", "np", "type_", "int", "node", "builder", "extract_node", "src", "cls_node", "node", "inferred", "0", "self", "assertisinstance", "cls_node", "nodes", "classdef", "self", "assertequal", "cls_node", "name", "type_"], "doc_len": 84}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainUtilsTest.test_get_numpy_version_do_not_crash", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainUtilsTest", "func_name": "test_get_numpy_version_do_not_crash", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainUtilsTest\n    def test_get_numpy_version_do_not_crash(self):\n        \"\"\"\n        Test that the function _get_numpy_version doesn't crash even if numpy is not installed\n        \"\"\"\n        self.assertEqual(_get_numpy_version(), (\"0\", \"0\", \"0\"))\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybrainutilstest", "def", "test_get_numpy_version_do_not_crash", "self", "test", "that", "the", "function", "_get_numpy_version", "doesn", "t", "crash", "even", "if", "numpy", "is", "not", "installed", "self", "assertequal", "_get_numpy_version", "0", "0", "0"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_core_numerictypes.py::NumpyBrainUtilsTest.test_numpy_object_uninferable", "file_path": "tests/unittest_brain_numpy_core_numerictypes.py", "class_name": "NumpyBrainUtilsTest", "func_name": "test_numpy_object_uninferable", "text": "文件路径: tests/unittest_brain_numpy_core_numerictypes.py, 类名: NumpyBrainUtilsTest\n    def test_numpy_object_uninferable(self):\n        \"\"\"\n        Test that in case numpy is not available, then a numpy object is uninferable\n        but the inference doesn't lead to a crash\n        \"\"\"\n        src = \"\"\"\n        import numpy as np\n        np.number[int]\n        \"\"\"\n        node = builder.extract_node(src)\n        cls_node = node.inferred()[0]\n        self.assertIs(cls_node, Uninferable)\n", "tokens": ["tests", "unittest_brain_numpy_core_numerictypes", "py", "numpybrainutilstest", "def", "test_numpy_object_uninferable", "self", "test", "that", "in", "case", "numpy", "is", "not", "available", "then", "a", "numpy", "object", "is", "uninferable", "but", "the", "inference", "doesn", "t", "lead", "to", "a", "crash", "src", "import", "numpy", "as", "np", "np", "number", "int", "node", "builder", "extract_node", "src", "cls_node", "node", "inferred", "0", "self", "assertis", "cls_node", "uninferable"], "doc_len": 50}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest._inferred_numpy_attribute", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "_inferred_numpy_attribute", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def _inferred_numpy_attribute(self, func_name):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy.core.umath as tested_module\n        func = tested_module.{func_name:s}\n        func\"\"\"\n        )\n        return next(node.infer())\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "_inferred_numpy_attribute", "self", "func_name", "node", "builder", "extract_node", "f", "import", "numpy", "core", "umath", "as", "tested_module", "func", "tested_module", "func_name", "s", "func", "return", "next", "node", "infer"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_constants", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_constants", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_constants(self):\n        \"\"\"\n        Test that constants have Const type.\n        \"\"\"\n        for const in self.constants:\n            with self.subTest(const=const):\n                inferred = self._inferred_numpy_attribute(const)\n                self.assertIsInstance(inferred, nodes.Const)\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_constants", "self", "test", "that", "constants", "have", "const", "type", "for", "const", "in", "self", "constants", "with", "self", "subtest", "const", "const", "inferred", "self", "_inferred_numpy_attribute", "const", "self", "assertisinstance", "inferred", "nodes", "const"], "doc_len": 32}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_constants_values", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_constants_values", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_constants_values(self):\n        \"\"\"\n        Test the values of the constants.\n        \"\"\"\n        exact_values = {\"e\": 2.718281828459045, \"euler_gamma\": 0.5772156649015329}\n        for const in self.constants:\n            with self.subTest(const=const):\n                inferred = self._inferred_numpy_attribute(const)\n                self.assertEqual(inferred.value, exact_values[const])\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_constants_values", "self", "test", "the", "values", "of", "the", "constants", "exact_values", "e", "2", "718281828459045", "euler_gamma", "0", "5772156649015329", "for", "const", "in", "self", "constants", "with", "self", "subtest", "const", "const", "inferred", "self", "_inferred_numpy_attribute", "const", "self", "assertequal", "inferred", "value", "exact_values", "const"], "doc_len": 40}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions(self):\n        \"\"\"\n        Test that functions have FunctionDef type.\n        \"\"\"\n        for func in self.all_ufunc:\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                self.assertIsInstance(inferred, bases.Instance)\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions", "self", "test", "that", "functions", "have", "functiondef", "type", "for", "func", "in", "self", "all_ufunc", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "self", "assertisinstance", "inferred", "bases", "instance"], "doc_len": 32}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions_one_arg", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions_one_arg", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions_one_arg(self):\n        \"\"\"\n        Test the arguments names of functions.\n        \"\"\"\n        exact_arg_names = [\n            \"self\",\n            \"x\",\n            \"out\",\n            \"where\",\n            \"casting\",\n            \"order\",\n            \"dtype\",\n            \"subok\",\n        ]\n        for func in self.one_arg_ufunc:\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                self.assertEqual(\n                    inferred.getattr(\"__call__\")[0].argnames(), exact_arg_names\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions_one_arg", "self", "test", "the", "arguments", "names", "of", "functions", "exact_arg_names", "self", "x", "out", "where", "casting", "order", "dtype", "subok", "for", "func", "in", "self", "one_arg_ufunc", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "self", "assertequal", "inferred", "getattr", "__call__", "0", "argnames", "exact_arg_names"], "doc_len": 44}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions_two_args", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions_two_args", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions_two_args(self):\n        \"\"\"\n        Test the arguments names of functions.\n        \"\"\"\n        exact_arg_names = [\n            \"self\",\n            \"x1\",\n            \"x2\",\n            \"out\",\n            \"where\",\n            \"casting\",\n            \"order\",\n            \"dtype\",\n            \"subok\",\n        ]\n        for func in self.two_args_ufunc:\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                self.assertEqual(\n                    inferred.getattr(\"__call__\")[0].argnames(), exact_arg_names\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions_two_args", "self", "test", "the", "arguments", "names", "of", "functions", "exact_arg_names", "self", "x1", "x2", "out", "where", "casting", "order", "dtype", "subok", "for", "func", "in", "self", "two_args_ufunc", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "self", "assertequal", "inferred", "getattr", "__call__", "0", "argnames", "exact_arg_names"], "doc_len": 45}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions_kwargs_default_values", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions_kwargs_default_values", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions_kwargs_default_values(self):\n        \"\"\"\n        Test the default values for keyword arguments.\n        \"\"\"\n        exact_kwargs_default_values = [None, True, \"same_kind\", \"K\", None, True]\n        for func in self.one_arg_ufunc + self.two_args_ufunc:\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                default_args_values = [\n                    default.value\n                    for default in inferred.getattr(\"__call__\")[0].args.defaults\n                ]\n                self.assertEqual(default_args_values, exact_kwargs_default_values)\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions_kwargs_default_values", "self", "test", "the", "default", "values", "for", "keyword", "arguments", "exact_kwargs_default_values", "none", "true", "same_kind", "k", "none", "true", "for", "func", "in", "self", "one_arg_ufunc", "self", "two_args_ufunc", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "default_args_values", "default", "value", "for", "default", "in", "inferred", "getattr", "__call__", "0", "args", "defaults", "self", "assertequal", "default_args_values", "exact_kwargs_default_values"], "doc_len": 53}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest._inferred_numpy_func_call", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "_inferred_numpy_func_call", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def _inferred_numpy_func_call(self, func_name, *func_args):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        func = np.{func_name:s}\n        func()\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "_inferred_numpy_func_call", "self", "func_name", "func_args", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "func", "np", "func_name", "s", "func", "return", "node", "infer"], "doc_len": 25}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions_return_type", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions_return_type", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions_return_type(self):\n        \"\"\"\n        Test that functions which should return a ndarray do return it\n        \"\"\"\n        ndarray_returning_func = [\n            f for f in self.all_ufunc if f not in (\"frexp\", \"modf\")\n        ]\n        for func_ in ndarray_returning_func:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_numpy_func_call(func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=\"Too much inferred values ({}) for {:s}\".format(\n                        inferred_values[-1].pytype(), func_\n                    ),\n                )\n                self.assertTrue(\n                    inferred_values[0].pytype() == \".ndarray\",\n                    msg=f\"Illicit type for {func_:s} ({inferred_values[-1].pytype()})\",\n                )\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions_return_type", "self", "test", "that", "functions", "which", "should", "return", "a", "ndarray", "do", "return", "it", "ndarray_returning_func", "f", "for", "f", "in", "self", "all_ufunc", "if", "f", "not", "in", "frexp", "modf", "for", "func_", "in", "ndarray_returning_func", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_numpy_func_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "too", "much", "inferred", "values", "for", "s", "format", "inferred_values", "1", "pytype", "func_", "self", "asserttrue", "inferred_values", "0", "pytype", "ndarray", "msg", "f", "illicit", "type", "for", "func_", "s", "inferred_values", "1", "pytype"], "doc_len": 78}
{"doc_id": "tests/unittest_brain_numpy_core_umath.py::NumpyBrainCoreUmathTest.test_numpy_core_umath_functions_return_type_tuple", "file_path": "tests/unittest_brain_numpy_core_umath.py", "class_name": "NumpyBrainCoreUmathTest", "func_name": "test_numpy_core_umath_functions_return_type_tuple", "text": "文件路径: tests/unittest_brain_numpy_core_umath.py, 类名: NumpyBrainCoreUmathTest\n    def test_numpy_core_umath_functions_return_type_tuple(self):\n        \"\"\"\n        Test that functions which should return a pair of ndarray do return it\n        \"\"\"\n        ndarray_returning_func = (\"frexp\", \"modf\")\n\n        for func_ in ndarray_returning_func:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_numpy_func_call(func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred values ({inferred_values}) for {func_:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() == \"builtins.tuple\",\n                    msg=f\"Illicit type for {func_:s} ({inferred_values[-1].pytype()})\",\n                )\n                self.assertTrue(\n                    len(inferred_values[0].elts) == 2,\n                    msg=f\"{func_} should return a pair of values. That's not the case.\",\n                )\n                for array in inferred_values[-1].elts:\n                    effective_infer = [m.pytype() for m in array.inferred()]\n                    self.assertTrue(\n                        \".ndarray\" in effective_infer,\n                        msg=(\n                            f\"Each item in the return of {func_} should be inferred\"\n                            f\" as a ndarray and not as {effective_infer}\"\n                        ),\n                    )\n", "tokens": ["tests", "unittest_brain_numpy_core_umath", "py", "numpybraincoreumathtest", "def", "test_numpy_core_umath_functions_return_type_tuple", "self", "test", "that", "functions", "which", "should", "return", "a", "pair", "of", "ndarray", "do", "return", "it", "ndarray_returning_func", "frexp", "modf", "for", "func_", "in", "ndarray_returning_func", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_numpy_func_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "values", "inferred_values", "for", "func_", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "builtins", "tuple", "msg", "f", "illicit", "type", "for", "func_", "s", "inferred_values", "1", "pytype", "self", "asserttrue", "len", "inferred_values", "0", "elts", "2", "msg", "f", "func_", "should", "return", "a", "pair", "of", "values", "that", "s", "not", "the", "case", "for", "array", "in", "inferred_values", "1", "elts", "effective_infer", "m", "pytype", "for", "m", "in", "array", "inferred", "self", "asserttrue", "ndarray", "in", "effective_infer", "msg", "f", "each", "item", "in", "the", "return", "of", "func_", "should", "be", "inferred", "f", "as", "a", "ndarray", "and", "not", "as", "effective_infer"], "doc_len": 129}
{"doc_id": "tests/unittest_brain_numpy_ma.py::TestBrainNumpyMa.test_numpy_ma_masked_where_returns_maskedarray", "file_path": "tests/unittest_brain_numpy_ma.py", "class_name": "TestBrainNumpyMa", "func_name": "test_numpy_ma_masked_where_returns_maskedarray", "text": "文件路径: tests/unittest_brain_numpy_ma.py, 类名: TestBrainNumpyMa\n    def test_numpy_ma_masked_where_returns_maskedarray():\n        \"\"\"\n        Test that calls to numpy ma masked_where returns a MaskedArray object.\n\n        The \"masked_where\" node is an Attribute\n        \"\"\"\n        src = \"\"\"\n        import numpy as np\n        data = np.ndarray((1,2))\n        np.ma.masked_where([1, 0, 0], data)\n        \"\"\"\n        node = builder.extract_node(src)\n        cls_node = node.inferred()[0]\n        assert cls_node.pytype() == \"numpy.ma.core.MaskedArray\"\n", "tokens": ["tests", "unittest_brain_numpy_ma", "py", "testbrainnumpyma", "def", "test_numpy_ma_masked_where_returns_maskedarray", "test", "that", "calls", "to", "numpy", "ma", "masked_where", "returns", "a", "maskedarray", "object", "the", "masked_where", "node", "is", "an", "attribute", "src", "import", "numpy", "as", "np", "data", "np", "ndarray", "1", "2", "np", "ma", "masked_where", "1", "0", "0", "data", "node", "builder", "extract_node", "src", "cls_node", "node", "inferred", "0", "assert", "cls_node", "pytype", "numpy", "ma", "core", "maskedarray"], "doc_len": 55}
{"doc_id": "tests/unittest_brain_numpy_ma.py::TestBrainNumpyMa.test_numpy_ma_masked_where_returns_maskedarray_bis", "file_path": "tests/unittest_brain_numpy_ma.py", "class_name": "TestBrainNumpyMa", "func_name": "test_numpy_ma_masked_where_returns_maskedarray_bis", "text": "文件路径: tests/unittest_brain_numpy_ma.py, 类名: TestBrainNumpyMa\n    def test_numpy_ma_masked_where_returns_maskedarray_bis():\n        \"\"\"\n        Test that calls to numpy ma masked_where returns a MaskedArray object\n\n        The \"masked_where\" node is a Name\n        \"\"\"\n        src = \"\"\"\n        from numpy.ma import masked_where\n        data = np.ndarray((1,2))\n        masked_where([1, 0, 0], data)\n        \"\"\"\n        node = builder.extract_node(src)\n        cls_node = node.inferred()[0]\n        assert cls_node.pytype() == \"numpy.ma.core.MaskedArray\"\n", "tokens": ["tests", "unittest_brain_numpy_ma", "py", "testbrainnumpyma", "def", "test_numpy_ma_masked_where_returns_maskedarray_bis", "test", "that", "calls", "to", "numpy", "ma", "masked_where", "returns", "a", "maskedarray", "object", "the", "masked_where", "node", "is", "a", "name", "src", "from", "numpy", "ma", "import", "masked_where", "data", "np", "ndarray", "1", "2", "masked_where", "1", "0", "0", "data", "node", "builder", "extract_node", "src", "cls_node", "node", "inferred", "0", "assert", "cls_node", "pytype", "numpy", "ma", "core", "maskedarray"], "doc_len": 54}
{"doc_id": "tests/unittest_brain_numpy_ndarray.py::NumpyBrainNdarrayTest._inferred_ndarray_method_call", "file_path": "tests/unittest_brain_numpy_ndarray.py", "class_name": "NumpyBrainNdarrayTest", "func_name": "_inferred_ndarray_method_call", "text": "文件路径: tests/unittest_brain_numpy_ndarray.py, 类名: NumpyBrainNdarrayTest\n    def _inferred_ndarray_method_call(self, func_name):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        test_array = np.ndarray((2, 2))\n        test_array.{func_name:s}()\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_ndarray", "py", "numpybrainndarraytest", "def", "_inferred_ndarray_method_call", "self", "func_name", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "test_array", "np", "ndarray", "2", "2", "test_array", "func_name", "s", "return", "node", "infer"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_ndarray.py::NumpyBrainNdarrayTest._inferred_ndarray_attribute", "file_path": "tests/unittest_brain_numpy_ndarray.py", "class_name": "NumpyBrainNdarrayTest", "func_name": "_inferred_ndarray_attribute", "text": "文件路径: tests/unittest_brain_numpy_ndarray.py, 类名: NumpyBrainNdarrayTest\n    def _inferred_ndarray_attribute(self, attr_name):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy as np\n        test_array = np.ndarray((2, 2))\n        test_array.{attr_name:s}\n        \"\"\"\n        )\n        return node.infer()\n", "tokens": ["tests", "unittest_brain_numpy_ndarray", "py", "numpybrainndarraytest", "def", "_inferred_ndarray_attribute", "self", "attr_name", "node", "builder", "extract_node", "f", "import", "numpy", "as", "np", "test_array", "np", "ndarray", "2", "2", "test_array", "attr_name", "s", "return", "node", "infer"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_ndarray.py::NumpyBrainNdarrayTest.test_numpy_function_calls_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_ndarray.py", "class_name": "NumpyBrainNdarrayTest", "func_name": "test_numpy_function_calls_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_ndarray.py, 类名: NumpyBrainNdarrayTest\n    def test_numpy_function_calls_inferred_as_ndarray(self):\n        \"\"\"\n        Test that some calls to numpy functions are inferred as numpy.ndarray\n        \"\"\"\n        licit_array_types = \".ndarray\"\n        for func_ in self.ndarray_returning_ndarray_methods:\n            with self.subTest(typ=func_):\n                inferred_values = list(self._inferred_ndarray_method_call(func_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred value for {func_:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() in licit_array_types,\n                    msg=f\"Illicit type for {func_:s} ({inferred_values[-1].pytype()})\",\n                )\n", "tokens": ["tests", "unittest_brain_numpy_ndarray", "py", "numpybrainndarraytest", "def", "test_numpy_function_calls_inferred_as_ndarray", "self", "test", "that", "some", "calls", "to", "numpy", "functions", "are", "inferred", "as", "numpy", "ndarray", "licit_array_types", "ndarray", "for", "func_", "in", "self", "ndarray_returning_ndarray_methods", "with", "self", "subtest", "typ", "func_", "inferred_values", "list", "self", "_inferred_ndarray_method_call", "func_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "value", "for", "func_", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "f", "illicit", "type", "for", "func_", "s", "inferred_values", "1", "pytype"], "doc_len": 67}
{"doc_id": "tests/unittest_brain_numpy_ndarray.py::NumpyBrainNdarrayTest.test_numpy_ndarray_attribute_inferred_as_ndarray", "file_path": "tests/unittest_brain_numpy_ndarray.py", "class_name": "NumpyBrainNdarrayTest", "func_name": "test_numpy_ndarray_attribute_inferred_as_ndarray", "text": "文件路径: tests/unittest_brain_numpy_ndarray.py, 类名: NumpyBrainNdarrayTest\n    def test_numpy_ndarray_attribute_inferred_as_ndarray(self):\n        \"\"\"\n        Test that some numpy ndarray attributes are inferred as numpy.ndarray\n        \"\"\"\n        licit_array_types = \".ndarray\"\n        for attr_ in (\"real\", \"imag\", \"shape\", \"T\"):\n            with self.subTest(typ=attr_):\n                inferred_values = list(self._inferred_ndarray_attribute(attr_))\n                self.assertTrue(\n                    len(inferred_values) == 1,\n                    msg=f\"Too much inferred value for {attr_:s}\",\n                )\n                self.assertTrue(\n                    inferred_values[-1].pytype() in licit_array_types,\n                    msg=f\"Illicit type for {attr_:s} ({inferred_values[-1].pytype()})\",\n                )\n", "tokens": ["tests", "unittest_brain_numpy_ndarray", "py", "numpybrainndarraytest", "def", "test_numpy_ndarray_attribute_inferred_as_ndarray", "self", "test", "that", "some", "numpy", "ndarray", "attributes", "are", "inferred", "as", "numpy", "ndarray", "licit_array_types", "ndarray", "for", "attr_", "in", "real", "imag", "shape", "t", "with", "self", "subtest", "typ", "attr_", "inferred_values", "list", "self", "_inferred_ndarray_attribute", "attr_", "self", "asserttrue", "len", "inferred_values", "1", "msg", "f", "too", "much", "inferred", "value", "for", "attr_", "s", "self", "asserttrue", "inferred_values", "1", "pytype", "in", "licit_array_types", "msg", "f", "illicit", "type", "for", "attr_", "s", "inferred_values", "1", "pytype"], "doc_len": 68}
{"doc_id": "tests/unittest_brain_numpy_ndarray.py::NumpyBrainNdarrayTest.test_numpy_ndarray_class_support_type_indexing", "file_path": "tests/unittest_brain_numpy_ndarray.py", "class_name": "NumpyBrainNdarrayTest", "func_name": "test_numpy_ndarray_class_support_type_indexing", "text": "文件路径: tests/unittest_brain_numpy_ndarray.py, 类名: NumpyBrainNdarrayTest\n    def test_numpy_ndarray_class_support_type_indexing(self):\n        \"\"\"\n        Test that numpy ndarray class can be subscripted (type hints)\n        \"\"\"\n        src = \"\"\"\n        import numpy as np\n        np.ndarray[int]\n        \"\"\"\n        node = builder.extract_node(src)\n        cls_node = node.inferred()[0]\n        self.assertIsInstance(cls_node, nodes.ClassDef)\n        self.assertEqual(cls_node.name, \"ndarray\")\n", "tokens": ["tests", "unittest_brain_numpy_ndarray", "py", "numpybrainndarraytest", "def", "test_numpy_ndarray_class_support_type_indexing", "self", "test", "that", "numpy", "ndarray", "class", "can", "be", "subscripted", "type", "hints", "src", "import", "numpy", "as", "np", "np", "ndarray", "int", "node", "builder", "extract_node", "src", "cls_node", "node", "inferred", "0", "self", "assertisinstance", "cls_node", "nodes", "classdef", "self", "assertequal", "cls_node", "name", "ndarray"], "doc_len": 43}
{"doc_id": "tests/unittest_brain_numpy_random_mtrand.py::NumpyBrainRandomMtrandTest._inferred_numpy_attribute", "file_path": "tests/unittest_brain_numpy_random_mtrand.py", "class_name": "NumpyBrainRandomMtrandTest", "func_name": "_inferred_numpy_attribute", "text": "文件路径: tests/unittest_brain_numpy_random_mtrand.py, 类名: NumpyBrainRandomMtrandTest\n    def _inferred_numpy_attribute(self, func_name):\n        node = builder.extract_node(\n            f\"\"\"\n        import numpy.random.mtrand as tested_module\n        func = tested_module.{func_name:s}\n        func\"\"\"\n        )\n        return next(node.infer())\n", "tokens": ["tests", "unittest_brain_numpy_random_mtrand", "py", "numpybrainrandommtrandtest", "def", "_inferred_numpy_attribute", "self", "func_name", "node", "builder", "extract_node", "f", "import", "numpy", "random", "mtrand", "as", "tested_module", "func", "tested_module", "func_name", "s", "func", "return", "next", "node", "infer"], "doc_len": 27}
{"doc_id": "tests/unittest_brain_numpy_random_mtrand.py::NumpyBrainRandomMtrandTest.test_numpy_random_mtrand_functions", "file_path": "tests/unittest_brain_numpy_random_mtrand.py", "class_name": "NumpyBrainRandomMtrandTest", "func_name": "test_numpy_random_mtrand_functions", "text": "文件路径: tests/unittest_brain_numpy_random_mtrand.py, 类名: NumpyBrainRandomMtrandTest\n    def test_numpy_random_mtrand_functions(self):\n        \"\"\"\n        Test that all functions have FunctionDef type.\n        \"\"\"\n        for func in self.all_mtrand:\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                self.assertIsInstance(inferred, nodes.FunctionDef)\n", "tokens": ["tests", "unittest_brain_numpy_random_mtrand", "py", "numpybrainrandommtrandtest", "def", "test_numpy_random_mtrand_functions", "self", "test", "that", "all", "functions", "have", "functiondef", "type", "for", "func", "in", "self", "all_mtrand", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "self", "assertisinstance", "inferred", "nodes", "functiondef"], "doc_len": 33}
{"doc_id": "tests/unittest_brain_numpy_random_mtrand.py::NumpyBrainRandomMtrandTest.test_numpy_random_mtrand_functions_signature", "file_path": "tests/unittest_brain_numpy_random_mtrand.py", "class_name": "NumpyBrainRandomMtrandTest", "func_name": "test_numpy_random_mtrand_functions_signature", "text": "文件路径: tests/unittest_brain_numpy_random_mtrand.py, 类名: NumpyBrainRandomMtrandTest\n    def test_numpy_random_mtrand_functions_signature(self):\n        \"\"\"\n        Test the arguments names and default values.\n        \"\"\"\n        for (\n            func,\n            (exact_arg_names, exact_kwargs_default_values),\n        ) in self.all_mtrand.items():\n            with self.subTest(func=func):\n                inferred = self._inferred_numpy_attribute(func)\n                self.assertEqual(inferred.argnames(), exact_arg_names)\n                default_args_values = [\n                    default.value for default in inferred.args.defaults\n                ]\n                self.assertEqual(default_args_values, exact_kwargs_default_values)\n", "tokens": ["tests", "unittest_brain_numpy_random_mtrand", "py", "numpybrainrandommtrandtest", "def", "test_numpy_random_mtrand_functions_signature", "self", "test", "the", "arguments", "names", "and", "default", "values", "for", "func", "exact_arg_names", "exact_kwargs_default_values", "in", "self", "all_mtrand", "items", "with", "self", "subtest", "func", "func", "inferred", "self", "_inferred_numpy_attribute", "func", "self", "assertequal", "inferred", "argnames", "exact_arg_names", "default_args_values", "default", "value", "for", "default", "in", "inferred", "args", "defaults", "self", "assertequal", "default_args_values", "exact_kwargs_default_values"], "doc_len": 49}
{"doc_id": "tests/unittest_brain_signal.py::test_enum", "file_path": "tests/unittest_brain_signal.py", "class_name": null, "func_name": "test_enum", "text": "文件路径: tests/unittest_brain_signal.py\ndef test_enum(enum_name):\n    \"\"\"Tests that the signal module enums are handled by the brain.\"\"\"\n    # Extract node for signal module enum from code\n    node = builder.extract_node(\n        f\"\"\"\n        import signal\n        signal.{enum_name}\n        \"\"\"\n    )\n\n    # Check the extracted node\n    assert isinstance(node, nodes.NodeNG)\n    node_inf = node.inferred()[0]\n    assert isinstance(node_inf, nodes.ClassDef)\n    assert node_inf.display_type() == \"Class\"\n    assert node_inf.is_subtype_of(\"enum.IntEnum\")\n    assert node_inf.qname() == f\"signal.{enum_name}\"\n\n    # Check enum members\n    for member in node_inf.body:\n        assert isinstance(member, nodes.Assign)\n        for target in member.targets:\n            assert isinstance(target, nodes.AssignName)\n", "tokens": ["tests", "unittest_brain_signal", "py", "def", "test_enum", "enum_name", "tests", "that", "the", "signal", "module", "enums", "are", "handled", "by", "the", "brain", "extract", "node", "for", "signal", "module", "enum", "from", "code", "node", "builder", "extract_node", "f", "import", "signal", "signal", "enum_name", "check", "the", "extracted", "node", "assert", "isinstance", "node", "nodes", "nodeng", "node_inf", "node", "inferred", "0", "assert", "isinstance", "node_inf", "nodes", "classdef", "assert", "node_inf", "display_type", "class", "assert", "node_inf", "is_subtype_of", "enum", "intenum", "assert", "node_inf", "qname", "f", "signal", "enum_name", "check", "enum", "members", "for", "member", "in", "node_inf", "body", "assert", "isinstance", "member", "nodes", "assign", "for", "target", "in", "member", "targets", "assert", "isinstance", "target", "nodes", "assignname"], "doc_len": 89}
{"doc_id": "tests/unittest_brain_unittest.py::UnittestTest.test_isolatedasynciotestcase", "file_path": "tests/unittest_brain_unittest.py", "class_name": "UnittestTest", "func_name": "test_isolatedasynciotestcase", "text": "文件路径: tests/unittest_brain_unittest.py, 类名: UnittestTest\n    def test_isolatedasynciotestcase(self):\n        \"\"\"\n        Tests that the IsolatedAsyncioTestCase class is statically imported\n        thanks to the brain_unittest module.\n        \"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        from unittest import IsolatedAsyncioTestCase\n\n        class TestClass(IsolatedAsyncioTestCase):\n            pass\n        \"\"\"\n        )\n        assert [n.qname() for n in node.ancestors()] == [\n            \"unittest.async_case.IsolatedAsyncioTestCase\",\n            \"unittest.case.TestCase\",\n            \"builtins.object\",\n        ]\n", "tokens": ["tests", "unittest_brain_unittest", "py", "unittesttest", "def", "test_isolatedasynciotestcase", "self", "tests", "that", "the", "isolatedasynciotestcase", "class", "is", "statically", "imported", "thanks", "to", "the", "brain_unittest", "module", "node", "builder", "extract_node", "from", "unittest", "import", "isolatedasynciotestcase", "class", "testclass", "isolatedasynciotestcase", "pass", "assert", "n", "qname", "for", "n", "in", "node", "ancestors", "unittest", "async_case", "isolatedasynciotestcase", "unittest", "case", "testcase", "builtins", "object"], "doc_len": 47}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.setUp", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "setUp", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def setUp(self) -> None:\n        self.astroid = resources.build_file(\"data/format.py\")\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "setup", "self", "none", "self", "astroid", "resources", "build_file", "data", "format", "py"], "doc_len": 15}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_callfunc_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_callfunc_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_callfunc_lineno(self) -> None:\n        stmts = self.astroid.body\n        # on line 4:\n        #    function('aeozrijz\\\n        #    earzer', hop)\n        discard = stmts[0]\n        self.assertIsInstance(discard, nodes.Expr)\n        self.assertEqual(discard.fromlineno, 4)\n        self.assertEqual(discard.tolineno, 5)\n        callfunc = discard.value\n        self.assertIsInstance(callfunc, nodes.Call)\n        self.assertEqual(callfunc.fromlineno, 4)\n        self.assertEqual(callfunc.tolineno, 5)\n        name = callfunc.func\n        self.assertIsInstance(name, nodes.Name)\n        self.assertEqual(name.fromlineno, 4)\n        self.assertEqual(name.tolineno, 4)\n        strarg = callfunc.args[0]\n        self.assertIsInstance(strarg, nodes.Const)\n        if hasattr(sys, \"pypy_version_info\"):\n            lineno = 4\n        else:\n            lineno = 5 if not PY38_PLUS else 4\n        self.assertEqual(strarg.fromlineno, lineno)\n        self.assertEqual(strarg.tolineno, lineno)\n        namearg = callfunc.args[1]\n        self.assertIsInstance(namearg, nodes.Name)\n        self.assertEqual(namearg.fromlineno, 5)\n        self.assertEqual(namearg.tolineno, 5)\n        # on line 10:\n        #    fonction(1,\n        #             2,\n        #             3,\n        #             4)\n        discard = stmts[2]\n        self.assertIsInstance(discard, nodes.Expr)\n        self.assertEqual(discard.fromlineno, 10)\n        self.assertEqual(discard.tolineno, 13)\n        callfunc = discard.value\n        self.assertIsInstance(callfunc, nodes.Call)\n        self.assertEqual(callfunc.fromlineno, 10)\n        self.assertEqual(callfunc.tolineno, 13)\n        name = callfunc.func\n        self.assertIsInstance(name, nodes.Name)\n        self.assertEqual(name.fromlineno, 10)\n        self.assertEqual(name.tolineno, 10)\n        for i, arg in enumerate(callfunc.args):\n            self.assertIsInstance(arg, nodes.Const)\n            self.assertEqual(arg.fromlineno, 10 + i)\n            self.assertEqual(arg.tolineno, 10 + i)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_callfunc_lineno", "self", "none", "stmts", "self", "astroid", "body", "on", "line", "4", "function", "aeozrijz", "earzer", "hop", "discard", "stmts", "0", "self", "assertisinstance", "discard", "nodes", "expr", "self", "assertequal", "discard", "fromlineno", "4", "self", "assertequal", "discard", "tolineno", "5", "callfunc", "discard", "value", "self", "assertisinstance", "callfunc", "nodes", "call", "self", "assertequal", "callfunc", "fromlineno", "4", "self", "assertequal", "callfunc", "tolineno", "5", "name", "callfunc", "func", "self", "assertisinstance", "name", "nodes", "name", "self", "assertequal", "name", "fromlineno", "4", "self", "assertequal", "name", "tolineno", "4", "strarg", "callfunc", "args", "0", "self", "assertisinstance", "strarg", "nodes", "const", "if", "hasattr", "sys", "pypy_version_info", "lineno", "4", "else", "lineno", "5", "if", "not", "py38_plus", "else", "4", "self", "assertequal", "strarg", "fromlineno", "lineno", "self", "assertequal", "strarg", "tolineno", "lineno", "namearg", "callfunc", "args", "1", "self", "assertisinstance", "namearg", "nodes", "name", "self", "assertequal", "namearg", "fromlineno", "5", "self", "assertequal", "namearg", "tolineno", "5", "on", "line", "10", "fonction", "1", "2", "3", "4", "discard", "stmts", "2", "self", "assertisinstance", "discard", "nodes", "expr", "self", "assertequal", "discard", "fromlineno", "10", "self", "assertequal", "discard", "tolineno", "13", "callfunc", "discard", "value", "self", "assertisinstance", "callfunc", "nodes", "call", "self", "assertequal", "callfunc", "fromlineno", "10", "self", "assertequal", "callfunc", "tolineno", "13", "name", "callfunc", "func", "self", "assertisinstance", "name", "nodes", "name", "self", "assertequal", "name", "fromlineno", "10", "self", "assertequal", "name", "tolineno", "10", "for", "i", "arg", "in", "enumerate", "callfunc", "args", "self", "assertisinstance", "arg", "nodes", "const", "self", "assertequal", "arg", "fromlineno", "10", "i", "self", "assertequal", "arg", "tolineno", "10", "i"], "doc_len": 211}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_function_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_function_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_function_lineno(self) -> None:\n        stmts = self.astroid.body\n        # on line 15:\n        #    def definition(a,\n        #                   b,\n        #                   c):\n        #        return a + b + c\n        function = stmts[3]\n        self.assertIsInstance(function, nodes.FunctionDef)\n        self.assertEqual(function.fromlineno, 15)\n        self.assertEqual(function.tolineno, 18)\n        return_ = function.body[0]\n        self.assertIsInstance(return_, nodes.Return)\n        self.assertEqual(return_.fromlineno, 18)\n        self.assertEqual(return_.tolineno, 18)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_function_lineno", "self", "none", "stmts", "self", "astroid", "body", "on", "line", "15", "def", "definition", "a", "b", "c", "return", "a", "b", "c", "function", "stmts", "3", "self", "assertisinstance", "function", "nodes", "functiondef", "self", "assertequal", "function", "fromlineno", "15", "self", "assertequal", "function", "tolineno", "18", "return_", "function", "body", "0", "self", "assertisinstance", "return_", "nodes", "return", "self", "assertequal", "return_", "fromlineno", "18", "self", "assertequal", "return_", "tolineno", "18"], "doc_len": 61}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_decorated_function_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_decorated_function_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_decorated_function_lineno(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            @decorator\n            def function(\n                arg):\n                print (arg)\n            \"\"\",\n            __name__,\n        )\n        function = astroid[\"function\"]\n        # XXX discussable, but that's what is expected by pylint right now\n        self.assertEqual(function.fromlineno, 3)\n        self.assertEqual(function.tolineno, 5)\n        self.assertEqual(function.decorators.fromlineno, 2)\n        self.assertEqual(function.decorators.tolineno, 2)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_decorated_function_lineno", "self", "none", "astroid", "builder", "parse", "decorator", "def", "function", "arg", "print", "arg", "__name__", "function", "astroid", "function", "xxx", "discussable", "but", "that", "s", "what", "is", "expected", "by", "pylint", "right", "now", "self", "assertequal", "function", "fromlineno", "3", "self", "assertequal", "function", "tolineno", "5", "self", "assertequal", "function", "decorators", "fromlineno", "2", "self", "assertequal", "function", "decorators", "tolineno", "2"], "doc_len": 55}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_class_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_class_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_class_lineno(self) -> None:\n        stmts = self.astroid.body\n        # on line 20:\n        #    class debile(dict,\n        #                 object):\n        #       pass\n        class_ = stmts[4]\n        self.assertIsInstance(class_, nodes.ClassDef)\n        self.assertEqual(class_.fromlineno, 20)\n        self.assertEqual(class_.tolineno, 22)\n        self.assertEqual(class_.blockstart_tolineno, 21)\n        pass_ = class_.body[0]\n        self.assertIsInstance(pass_, nodes.Pass)\n        self.assertEqual(pass_.fromlineno, 22)\n        self.assertEqual(pass_.tolineno, 22)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_class_lineno", "self", "none", "stmts", "self", "astroid", "body", "on", "line", "20", "class", "debile", "dict", "object", "pass", "class_", "stmts", "4", "self", "assertisinstance", "class_", "nodes", "classdef", "self", "assertequal", "class_", "fromlineno", "20", "self", "assertequal", "class_", "tolineno", "22", "self", "assertequal", "class_", "blockstart_tolineno", "21", "pass_", "class_", "body", "0", "self", "assertisinstance", "pass_", "nodes", "pass", "self", "assertequal", "pass_", "fromlineno", "22", "self", "assertequal", "pass_", "tolineno", "22"], "doc_len": 62}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_if_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_if_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_if_lineno(self) -> None:\n        stmts = self.astroid.body\n        # on line 20:\n        #    if aaaa: pass\n        #    else:\n        #        aaaa,bbbb = 1,2\n        #        aaaa,bbbb = bbbb,aaaa\n        if_ = stmts[5]\n        self.assertIsInstance(if_, nodes.If)\n        self.assertEqual(if_.fromlineno, 24)\n        self.assertEqual(if_.tolineno, 27)\n        self.assertEqual(if_.blockstart_tolineno, 24)\n        self.assertEqual(if_.orelse[0].fromlineno, 26)\n        self.assertEqual(if_.orelse[1].tolineno, 27)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_if_lineno", "self", "none", "stmts", "self", "astroid", "body", "on", "line", "20", "if", "aaaa", "pass", "else", "aaaa", "bbbb", "1", "2", "aaaa", "bbbb", "bbbb", "aaaa", "if_", "stmts", "5", "self", "assertisinstance", "if_", "nodes", "if", "self", "assertequal", "if_", "fromlineno", "24", "self", "assertequal", "if_", "tolineno", "27", "self", "assertequal", "if_", "blockstart_tolineno", "24", "self", "assertequal", "if_", "orelse", "0", "fromlineno", "26", "self", "assertequal", "if_", "orelse", "1", "tolineno", "27"], "doc_len": 64}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_for_while_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_for_while_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_for_while_lineno(self) -> None:\n        for code in (\n            \"\"\"\n            for a in range(4):\n              print (a)\n              break\n            else:\n              print (\"bouh\")\n            \"\"\",\n            \"\"\"\n            while a:\n              print (a)\n              break\n            else:\n              print (\"bouh\")\n            \"\"\",\n        ):\n            astroid = builder.parse(code, __name__)\n            stmt = astroid.body[0]\n            self.assertEqual(stmt.fromlineno, 2)\n            self.assertEqual(stmt.tolineno, 6)\n            self.assertEqual(stmt.blockstart_tolineno, 2)\n            self.assertEqual(stmt.orelse[0].fromlineno, 6)  # XXX\n            self.assertEqual(stmt.orelse[0].tolineno, 6)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_for_while_lineno", "self", "none", "for", "code", "in", "for", "a", "in", "range", "4", "print", "a", "break", "else", "print", "bouh", "while", "a", "print", "a", "break", "else", "print", "bouh", "astroid", "builder", "parse", "code", "__name__", "stmt", "astroid", "body", "0", "self", "assertequal", "stmt", "fromlineno", "2", "self", "assertequal", "stmt", "tolineno", "6", "self", "assertequal", "stmt", "blockstart_tolineno", "2", "self", "assertequal", "stmt", "orelse", "0", "fromlineno", "6", "xxx", "self", "assertequal", "stmt", "orelse", "0", "tolineno", "6"], "doc_len": 69}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_try_except_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_try_except_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_try_except_lineno(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            try:\n              print (a)\n            except:\n              pass\n            else:\n              print (\"bouh\")\n            \"\"\",\n            __name__,\n        )\n        try_ = astroid.body[0]\n        self.assertEqual(try_.fromlineno, 2)\n        self.assertEqual(try_.tolineno, 7)\n        self.assertEqual(try_.blockstart_tolineno, 2)\n        self.assertEqual(try_.orelse[0].fromlineno, 7)  # XXX\n        self.assertEqual(try_.orelse[0].tolineno, 7)\n        hdlr = try_.handlers[0]\n        self.assertEqual(hdlr.fromlineno, 4)\n        self.assertEqual(hdlr.tolineno, 5)\n        self.assertEqual(hdlr.blockstart_tolineno, 4)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_try_except_lineno", "self", "none", "astroid", "builder", "parse", "try", "print", "a", "except", "pass", "else", "print", "bouh", "__name__", "try_", "astroid", "body", "0", "self", "assertequal", "try_", "fromlineno", "2", "self", "assertequal", "try_", "tolineno", "7", "self", "assertequal", "try_", "blockstart_tolineno", "2", "self", "assertequal", "try_", "orelse", "0", "fromlineno", "7", "xxx", "self", "assertequal", "try_", "orelse", "0", "tolineno", "7", "hdlr", "try_", "handlers", "0", "self", "assertequal", "hdlr", "fromlineno", "4", "self", "assertequal", "hdlr", "tolineno", "5", "self", "assertequal", "hdlr", "blockstart_tolineno", "4"], "doc_len": 73}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_try_finally_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_try_finally_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_try_finally_lineno(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            try:\n              print (a)\n            finally:\n              print (\"bouh\")\n            \"\"\",\n            __name__,\n        )\n        try_ = astroid.body[0]\n        self.assertEqual(try_.fromlineno, 2)\n        self.assertEqual(try_.tolineno, 5)\n        self.assertEqual(try_.blockstart_tolineno, 2)\n        self.assertEqual(try_.finalbody[0].fromlineno, 5)  # XXX\n        self.assertEqual(try_.finalbody[0].tolineno, 5)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_try_finally_lineno", "self", "none", "astroid", "builder", "parse", "try", "print", "a", "finally", "print", "bouh", "__name__", "try_", "astroid", "body", "0", "self", "assertequal", "try_", "fromlineno", "2", "self", "assertequal", "try_", "tolineno", "5", "self", "assertequal", "try_", "blockstart_tolineno", "2", "self", "assertequal", "try_", "finalbody", "0", "fromlineno", "5", "xxx", "self", "assertequal", "try_", "finalbody", "0", "tolineno", "5"], "doc_len": 52}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_try_finally_25_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_try_finally_25_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_try_finally_25_lineno(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            try:\n              print (a)\n            except:\n              pass\n            finally:\n              print (\"bouh\")\n            \"\"\",\n            __name__,\n        )\n        try_ = astroid.body[0]\n        self.assertEqual(try_.fromlineno, 2)\n        self.assertEqual(try_.tolineno, 7)\n        self.assertEqual(try_.blockstart_tolineno, 2)\n        self.assertEqual(try_.finalbody[0].fromlineno, 7)  # XXX\n        self.assertEqual(try_.finalbody[0].tolineno, 7)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_try_finally_25_lineno", "self", "none", "astroid", "builder", "parse", "try", "print", "a", "except", "pass", "finally", "print", "bouh", "__name__", "try_", "astroid", "body", "0", "self", "assertequal", "try_", "fromlineno", "2", "self", "assertequal", "try_", "tolineno", "7", "self", "assertequal", "try_", "blockstart_tolineno", "2", "self", "assertequal", "try_", "finalbody", "0", "fromlineno", "7", "xxx", "self", "assertequal", "try_", "finalbody", "0", "tolineno", "7"], "doc_len": 54}
{"doc_id": "tests/unittest_builder.py::FromToLineNoTest.test_with_lineno", "file_path": "tests/unittest_builder.py", "class_name": "FromToLineNoTest", "func_name": "test_with_lineno", "text": "文件路径: tests/unittest_builder.py, 类名: FromToLineNoTest\n    def test_with_lineno(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            from __future__ import with_statement\n            with file(\"/tmp/pouet\") as f:\n                print (f)\n            \"\"\",\n            __name__,\n        )\n        with_ = astroid.body[1]\n        self.assertEqual(with_.fromlineno, 3)\n        self.assertEqual(with_.tolineno, 4)\n        self.assertEqual(with_.blockstart_tolineno, 3)\n", "tokens": ["tests", "unittest_builder", "py", "fromtolinenotest", "def", "test_with_lineno", "self", "none", "astroid", "builder", "parse", "from", "__future__", "import", "with_statement", "with", "file", "tmp", "pouet", "as", "f", "print", "f", "__name__", "with_", "astroid", "body", "1", "self", "assertequal", "with_", "fromlineno", "3", "self", "assertequal", "with_", "tolineno", "4", "self", "assertequal", "with_", "blockstart_tolineno", "3"], "doc_len": 43}
{"doc_id": "tests/unittest_builder.py::BuilderTest.setUp", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "setUp", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def setUp(self) -> None:\n        self.manager = test_utils.brainless_manager()\n        self.builder = builder.AstroidBuilder(self.manager)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "setup", "self", "none", "self", "manager", "test_utils", "brainless_manager", "self", "builder", "builder", "astroidbuilder", "self", "manager"], "doc_len": 18}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_data_build_null_bytes", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_data_build_null_bytes", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_data_build_null_bytes(self) -> None:\n        with self.assertRaises(AstroidSyntaxError):\n            self.builder.string_build(\"\\x00\")\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_data_build_null_bytes", "self", "none", "with", "self", "assertraises", "astroidsyntaxerror", "self", "builder", "string_build", "x00"], "doc_len": 16}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_data_build_invalid_x_escape", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_data_build_invalid_x_escape", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_data_build_invalid_x_escape(self) -> None:\n        with self.assertRaises(AstroidSyntaxError):\n            self.builder.string_build('\"\\\\x1\"')\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_data_build_invalid_x_escape", "self", "none", "with", "self", "assertraises", "astroidsyntaxerror", "self", "builder", "string_build", "x1"], "doc_len": 16}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_missing_newline", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_missing_newline", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_missing_newline(self) -> None:\n        \"\"\"check that a file with no trailing new line is parseable\"\"\"\n        resources.build_file(\"data/noendingnewline.py\")\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_missing_newline", "self", "none", "check", "that", "a", "file", "with", "no", "trailing", "new", "line", "is", "parseable", "resources", "build_file", "data", "noendingnewline", "py"], "doc_len": 24}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_missing_file", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_missing_file", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_missing_file(self) -> None:\n        with self.assertRaises(AstroidBuildingError):\n            resources.build_file(\"data/inexistent.py\")\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_missing_file", "self", "none", "with", "self", "assertraises", "astroidbuildingerror", "resources", "build_file", "data", "inexistent", "py"], "doc_len": 17}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inspect_build0", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inspect_build0", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inspect_build0(self) -> None:\n        \"\"\"test astroid tree build from a living object\"\"\"\n        builtin_ast = self.manager.ast_from_module_name(\"builtins\")\n        # just check type and object are there\n        builtin_ast.getattr(\"type\")\n        objectastroid = builtin_ast.getattr(\"object\")[0]\n        self.assertIsInstance(objectastroid.getattr(\"__new__\")[0], nodes.FunctionDef)\n        # check open file alias\n        builtin_ast.getattr(\"open\")\n        # check 'help' is there (defined dynamically by site.py)\n        builtin_ast.getattr(\"help\")\n        # check property has __init__\n        pclass = builtin_ast[\"property\"]\n        self.assertIn(\"__init__\", pclass)\n        self.assertIsInstance(builtin_ast[\"None\"], nodes.Const)\n        self.assertIsInstance(builtin_ast[\"True\"], nodes.Const)\n        self.assertIsInstance(builtin_ast[\"False\"], nodes.Const)\n        self.assertIsInstance(builtin_ast[\"Exception\"], nodes.ClassDef)\n        self.assertIsInstance(builtin_ast[\"NotImplementedError\"], nodes.ClassDef)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inspect_build0", "self", "none", "test", "astroid", "tree", "build", "from", "a", "living", "object", "builtin_ast", "self", "manager", "ast_from_module_name", "builtins", "just", "check", "type", "and", "object", "are", "there", "builtin_ast", "getattr", "type", "objectastroid", "builtin_ast", "getattr", "object", "0", "self", "assertisinstance", "objectastroid", "getattr", "__new__", "0", "nodes", "functiondef", "check", "open", "file", "alias", "builtin_ast", "getattr", "open", "check", "help", "is", "there", "defined", "dynamically", "by", "site", "py", "builtin_ast", "getattr", "help", "check", "property", "has", "__init__", "pclass", "builtin_ast", "property", "self", "assertin", "__init__", "pclass", "self", "assertisinstance", "builtin_ast", "none", "nodes", "const", "self", "assertisinstance", "builtin_ast", "true", "nodes", "const", "self", "assertisinstance", "builtin_ast", "false", "nodes", "const", "self", "assertisinstance", "builtin_ast", "exception", "nodes", "classdef", "self", "assertisinstance", "builtin_ast", "notimplementederror", "nodes", "classdef"], "doc_len": 104}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inspect_build1", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inspect_build1", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inspect_build1(self) -> None:\n        time_ast = self.manager.ast_from_module_name(\"time\")\n        self.assertTrue(time_ast)\n        self.assertEqual(time_ast[\"time\"].args.defaults, [])\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inspect_build1", "self", "none", "time_ast", "self", "manager", "ast_from_module_name", "time", "self", "asserttrue", "time_ast", "self", "assertequal", "time_ast", "time", "args", "defaults"], "doc_len": 22}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inspect_build3", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inspect_build3", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inspect_build3(self) -> None:\n        self.builder.inspect_build(unittest)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inspect_build3", "self", "none", "self", "builder", "inspect_build", "unittest"], "doc_len": 12}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inspect_build_type_object", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inspect_build_type_object", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inspect_build_type_object(self) -> None:\n        builtin_ast = self.manager.ast_from_module_name(\"builtins\")\n\n        inferred = list(builtin_ast.igetattr(\"object\"))\n        self.assertEqual(len(inferred), 1)\n        inferred = inferred[0]\n        self.assertEqual(inferred.name, \"object\")\n        inferred.as_string()  # no crash test\n\n        inferred = list(builtin_ast.igetattr(\"type\"))\n        self.assertEqual(len(inferred), 1)\n        inferred = inferred[0]\n        self.assertEqual(inferred.name, \"type\")\n        inferred.as_string()  # no crash test\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inspect_build_type_object", "self", "none", "builtin_ast", "self", "manager", "ast_from_module_name", "builtins", "inferred", "list", "builtin_ast", "igetattr", "object", "self", "assertequal", "len", "inferred", "1", "inferred", "inferred", "0", "self", "assertequal", "inferred", "name", "object", "inferred", "as_string", "no", "crash", "test", "inferred", "list", "builtin_ast", "igetattr", "type", "self", "assertequal", "len", "inferred", "1", "inferred", "inferred", "0", "self", "assertequal", "inferred", "name", "type", "inferred", "as_string", "no", "crash", "test"], "doc_len": 59}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inspect_transform_module", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inspect_transform_module", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inspect_transform_module(self) -> None:\n        # ensure no cached version of the time module\n        self.manager._mod_file_cache.pop((\"time\", None), None)\n        self.manager.astroid_cache.pop(\"time\", None)\n\n        def transform_time(node: Module) -> None:\n            if node.name == \"time\":\n                node.transformed = True\n\n        self.manager.register_transform(nodes.Module, transform_time)\n        try:\n            time_ast = self.manager.ast_from_module_name(\"time\")\n            self.assertTrue(getattr(time_ast, \"transformed\", False))\n        finally:\n            self.manager.unregister_transform(nodes.Module, transform_time)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inspect_transform_module", "self", "none", "ensure", "no", "cached", "version", "of", "the", "time", "module", "self", "manager", "_mod_file_cache", "pop", "time", "none", "none", "self", "manager", "astroid_cache", "pop", "time", "none", "def", "transform_time", "node", "module", "none", "if", "node", "name", "time", "node", "transformed", "true", "self", "manager", "register_transform", "nodes", "module", "transform_time", "try", "time_ast", "self", "manager", "ast_from_module_name", "time", "self", "asserttrue", "getattr", "time_ast", "transformed", "false", "finally", "self", "manager", "unregister_transform", "nodes", "module", "transform_time"], "doc_len": 66}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_package_name", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_package_name", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_package_name(self) -> None:\n        \"\"\"test base properties and method of an astroid module\"\"\"\n        datap = resources.build_file(\"data/__init__.py\", \"data\")\n        self.assertEqual(datap.name, \"data\")\n        self.assertEqual(datap.package, 1)\n        datap = resources.build_file(\"data/__init__.py\", \"data.__init__\")\n        self.assertEqual(datap.name, \"data\")\n        self.assertEqual(datap.package, 1)\n        datap = resources.build_file(\"data/tmp__init__.py\", \"data.tmp__init__\")\n        self.assertEqual(datap.name, \"data.tmp__init__\")\n        self.assertEqual(datap.package, 0)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_package_name", "self", "none", "test", "base", "properties", "and", "method", "of", "an", "astroid", "module", "datap", "resources", "build_file", "data", "__init__", "py", "data", "self", "assertequal", "datap", "name", "data", "self", "assertequal", "datap", "package", "1", "datap", "resources", "build_file", "data", "__init__", "py", "data", "__init__", "self", "assertequal", "datap", "name", "data", "self", "assertequal", "datap", "package", "1", "datap", "resources", "build_file", "data", "tmp__init__", "py", "data", "tmp__init__", "self", "assertequal", "datap", "name", "data", "tmp__init__", "self", "assertequal", "datap", "package", "0"], "doc_len": 71}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_yield_parent", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_yield_parent", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_yield_parent(self) -> None:\n        \"\"\"check if we added discard nodes as yield parent (w/ compiler)\"\"\"\n        code = \"\"\"\n            def yiell(): #@\n                yield 0\n                if noe:\n                    yield more\n        \"\"\"\n        func = builder.extract_node(code)\n        self.assertIsInstance(func, nodes.FunctionDef)\n        stmt = func.body[0]\n        self.assertIsInstance(stmt, nodes.Expr)\n        self.assertIsInstance(stmt.value, nodes.Yield)\n        self.assertIsInstance(func.body[1].body[0], nodes.Expr)\n        self.assertIsInstance(func.body[1].body[0].value, nodes.Yield)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_yield_parent", "self", "none", "check", "if", "we", "added", "discard", "nodes", "as", "yield", "parent", "w", "compiler", "code", "def", "yiell", "yield", "0", "if", "noe", "yield", "more", "func", "builder", "extract_node", "code", "self", "assertisinstance", "func", "nodes", "functiondef", "stmt", "func", "body", "0", "self", "assertisinstance", "stmt", "nodes", "expr", "self", "assertisinstance", "stmt", "value", "nodes", "yield", "self", "assertisinstance", "func", "body", "1", "body", "0", "nodes", "expr", "self", "assertisinstance", "func", "body", "1", "body", "0", "value", "nodes", "yield"], "doc_len": 71}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_object", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_object", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_object(self) -> None:\n        obj_ast = self.builder.inspect_build(object)\n        self.assertIn(\"__setattr__\", obj_ast)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_object", "self", "none", "obj_ast", "self", "builder", "inspect_build", "object", "self", "assertin", "__setattr__", "obj_ast"], "doc_len": 17}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_newstyle_detection", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_newstyle_detection", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_newstyle_detection(self) -> None:\n        data = \"\"\"\n            class A:\n                \"old style\"\n\n            class B(A):\n                \"old style\"\n\n            class C(object):\n                \"new style\"\n\n            class D(C):\n                \"new style\"\n\n            __metaclass__ = type\n\n            class E(A):\n                \"old style\"\n\n            class F:\n                \"new style\"\n        \"\"\"\n        mod_ast = builder.parse(data, __name__)\n        self.assertTrue(mod_ast[\"A\"].newstyle)\n        self.assertTrue(mod_ast[\"B\"].newstyle)\n        self.assertTrue(mod_ast[\"E\"].newstyle)\n        self.assertTrue(mod_ast[\"C\"].newstyle)\n        self.assertTrue(mod_ast[\"D\"].newstyle)\n        self.assertTrue(mod_ast[\"F\"].newstyle)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_newstyle_detection", "self", "none", "data", "class", "a", "old", "style", "class", "b", "a", "old", "style", "class", "c", "object", "new", "style", "class", "d", "c", "new", "style", "__metaclass__", "type", "class", "e", "a", "old", "style", "class", "f", "new", "style", "mod_ast", "builder", "parse", "data", "__name__", "self", "asserttrue", "mod_ast", "a", "newstyle", "self", "asserttrue", "mod_ast", "b", "newstyle", "self", "asserttrue", "mod_ast", "e", "newstyle", "self", "asserttrue", "mod_ast", "c", "newstyle", "self", "asserttrue", "mod_ast", "d", "newstyle", "self", "asserttrue", "mod_ast", "f", "newstyle"], "doc_len": 74}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_globals", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_globals", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_globals(self) -> None:\n        data = \"\"\"\n            CSTE = 1\n\n            def update_global():\n                global CSTE\n                CSTE += 1\n\n            def global_no_effect():\n                global CSTE2\n                print (CSTE)\n        \"\"\"\n        astroid = builder.parse(data, __name__)\n        self.assertEqual(len(astroid.getattr(\"CSTE\")), 2)\n        self.assertIsInstance(astroid.getattr(\"CSTE\")[0], nodes.AssignName)\n        self.assertEqual(astroid.getattr(\"CSTE\")[0].fromlineno, 2)\n        self.assertEqual(astroid.getattr(\"CSTE\")[1].fromlineno, 6)\n        with self.assertRaises(AttributeInferenceError):\n            astroid.getattr(\"CSTE2\")\n        with self.assertRaises(InferenceError):\n            next(astroid[\"global_no_effect\"].ilookup(\"CSTE2\"))\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_globals", "self", "none", "data", "cste", "1", "def", "update_global", "global", "cste", "cste", "1", "def", "global_no_effect", "global", "cste2", "print", "cste", "astroid", "builder", "parse", "data", "__name__", "self", "assertequal", "len", "astroid", "getattr", "cste", "2", "self", "assertisinstance", "astroid", "getattr", "cste", "0", "nodes", "assignname", "self", "assertequal", "astroid", "getattr", "cste", "0", "fromlineno", "2", "self", "assertequal", "astroid", "getattr", "cste", "1", "fromlineno", "6", "with", "self", "assertraises", "attributeinferenceerror", "astroid", "getattr", "cste2", "with", "self", "assertraises", "inferenceerror", "next", "astroid", "global_no_effect", "ilookup", "cste2"], "doc_len": 75}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_socket_build", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_socket_build", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_socket_build(self) -> None:\n        astroid = self.builder.module_build(socket)\n        # XXX just check the first one. Actually 3 objects are inferred (look at\n        # the socket module) but the last one as those attributes dynamically\n        # set and astroid is missing this.\n        for fclass in astroid.igetattr(\"socket\"):\n            self.assertIn(\"connect\", fclass)\n            self.assertIn(\"send\", fclass)\n            self.assertIn(\"close\", fclass)\n            break\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_socket_build", "self", "none", "astroid", "self", "builder", "module_build", "socket", "xxx", "just", "check", "the", "first", "one", "actually", "3", "objects", "are", "inferred", "look", "at", "the", "socket", "module", "but", "the", "last", "one", "as", "those", "attributes", "dynamically", "set", "and", "astroid", "is", "missing", "this", "for", "fclass", "in", "astroid", "igetattr", "socket", "self", "assertin", "connect", "fclass", "self", "assertin", "send", "fclass", "self", "assertin", "close", "fclass", "break"], "doc_len": 62}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_gen_expr_var_scope", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_gen_expr_var_scope", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_gen_expr_var_scope(self) -> None:\n        data = \"l = list(n for n in range(10))\\n\"\n        astroid = builder.parse(data, __name__)\n        # n unavailable outside gen expr scope\n        self.assertNotIn(\"n\", astroid)\n        # test n is inferable anyway\n        n = test_utils.get_name_node(astroid, \"n\")\n        self.assertIsNot(n.scope(), astroid)\n        self.assertEqual([i.__class__ for i in n.infer()], [util.Uninferable.__class__])\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_gen_expr_var_scope", "self", "none", "data", "l", "list", "n", "for", "n", "in", "range", "10", "n", "astroid", "builder", "parse", "data", "__name__", "n", "unavailable", "outside", "gen", "expr", "scope", "self", "assertnotin", "n", "astroid", "test", "n", "is", "inferable", "anyway", "n", "test_utils", "get_name_node", "astroid", "n", "self", "assertisnot", "n", "scope", "astroid", "self", "assertequal", "i", "__class__", "for", "i", "in", "n", "infer", "util", "uninferable", "__class__"], "doc_len": 60}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_no_future_imports", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_no_future_imports", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_no_future_imports(self) -> None:\n        mod = builder.parse(\"import sys\")\n        self.assertEqual(set(), mod.future_imports)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_no_future_imports", "self", "none", "mod", "builder", "parse", "import", "sys", "self", "assertequal", "set", "mod", "future_imports"], "doc_len": 18}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_future_imports", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_future_imports", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_future_imports(self) -> None:\n        mod = builder.parse(\"from __future__ import print_function\")\n        self.assertEqual({\"print_function\"}, mod.future_imports)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_future_imports", "self", "none", "mod", "builder", "parse", "from", "__future__", "import", "print_function", "self", "assertequal", "print_function", "mod", "future_imports"], "doc_len": 20}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_two_future_imports", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_two_future_imports", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_two_future_imports(self) -> None:\n        mod = builder.parse(\n            \"\"\"\n            from __future__ import print_function\n            from __future__ import absolute_import\n            \"\"\"\n        )\n        self.assertEqual({\"print_function\", \"absolute_import\"}, mod.future_imports)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_two_future_imports", "self", "none", "mod", "builder", "parse", "from", "__future__", "import", "print_function", "from", "__future__", "import", "absolute_import", "self", "assertequal", "print_function", "absolute_import", "mod", "future_imports"], "doc_len": 25}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inferred_build", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inferred_build", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inferred_build(self) -> None:\n        code = \"\"\"\n            class A: pass\n            A.type = \"class\"\n\n            def A_assign_type(self):\n                print (self)\n            A.assign_type = A_assign_type\n            \"\"\"\n        astroid = builder.parse(code)\n        lclass = list(astroid.igetattr(\"A\"))\n        self.assertEqual(len(lclass), 1)\n        lclass = lclass[0]\n        self.assertIn(\"assign_type\", lclass.locals)\n        self.assertIn(\"type\", lclass.locals)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inferred_build", "self", "none", "code", "class", "a", "pass", "a", "type", "class", "def", "a_assign_type", "self", "print", "self", "a", "assign_type", "a_assign_type", "astroid", "builder", "parse", "code", "lclass", "list", "astroid", "igetattr", "a", "self", "assertequal", "len", "lclass", "1", "lclass", "lclass", "0", "self", "assertin", "assign_type", "lclass", "locals", "self", "assertin", "type", "lclass", "locals"], "doc_len": 50}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_infer_can_assign_regular_object", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_infer_can_assign_regular_object", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_infer_can_assign_regular_object(self) -> None:\n        mod = builder.parse(\n            \"\"\"\n            class A:\n                pass\n            a = A()\n            a.value = \"is set\"\n            a.other = \"is set\"\n        \"\"\"\n        )\n        obj = list(mod.igetattr(\"a\"))\n        self.assertEqual(len(obj), 1)\n        obj = obj[0]\n        self.assertIsInstance(obj, Instance)\n        self.assertIn(\"value\", obj.instance_attrs)\n        self.assertIn(\"other\", obj.instance_attrs)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_infer_can_assign_regular_object", "self", "none", "mod", "builder", "parse", "class", "a", "pass", "a", "a", "a", "value", "is", "set", "a", "other", "is", "set", "obj", "list", "mod", "igetattr", "a", "self", "assertequal", "len", "obj", "1", "obj", "obj", "0", "self", "assertisinstance", "obj", "instance", "self", "assertin", "value", "obj", "instance_attrs", "self", "assertin", "other", "obj", "instance_attrs"], "doc_len": 51}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_infer_can_assign_has_slots", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_infer_can_assign_has_slots", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_infer_can_assign_has_slots(self) -> None:\n        mod = builder.parse(\n            \"\"\"\n            class A:\n                __slots__ = ('value',)\n            a = A()\n            a.value = \"is set\"\n            a.other = \"not set\"\n        \"\"\"\n        )\n        obj = list(mod.igetattr(\"a\"))\n        self.assertEqual(len(obj), 1)\n        obj = obj[0]\n        self.assertIsInstance(obj, Instance)\n        self.assertIn(\"value\", obj.instance_attrs)\n        self.assertNotIn(\"other\", obj.instance_attrs)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_infer_can_assign_has_slots", "self", "none", "mod", "builder", "parse", "class", "a", "__slots__", "value", "a", "a", "a", "value", "is", "set", "a", "other", "not", "set", "obj", "list", "mod", "igetattr", "a", "self", "assertequal", "len", "obj", "1", "obj", "obj", "0", "self", "assertisinstance", "obj", "instance", "self", "assertin", "value", "obj", "instance_attrs", "self", "assertnotin", "other", "obj", "instance_attrs"], "doc_len": 52}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_infer_can_assign_no_classdict", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_infer_can_assign_no_classdict", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_infer_can_assign_no_classdict(self) -> None:\n        mod = builder.parse(\n            \"\"\"\n            a = object()\n            a.value = \"not set\"\n        \"\"\"\n        )\n        obj = list(mod.igetattr(\"a\"))\n        self.assertEqual(len(obj), 1)\n        obj = obj[0]\n        self.assertIsInstance(obj, Instance)\n        self.assertNotIn(\"value\", obj.instance_attrs)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_infer_can_assign_no_classdict", "self", "none", "mod", "builder", "parse", "a", "object", "a", "value", "not", "set", "obj", "list", "mod", "igetattr", "a", "self", "assertequal", "len", "obj", "1", "obj", "obj", "0", "self", "assertisinstance", "obj", "instance", "self", "assertnotin", "value", "obj", "instance_attrs"], "doc_len": 39}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_augassign_attr", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_augassign_attr", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_augassign_attr(self) -> None:\n        builder.parse(\n            \"\"\"\n            class Counter:\n                v = 0\n                def inc(self):\n                    self.v += 1\n            \"\"\",\n            __name__,\n        )\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_augassign_attr", "self", "none", "builder", "parse", "class", "counter", "v", "0", "def", "inc", "self", "self", "v", "1", "__name__"], "doc_len": 21}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_inferred_dont_pollute", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_inferred_dont_pollute", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_inferred_dont_pollute(self) -> None:\n        code = \"\"\"\n            def func(a=None):\n                a.custom_attr = 0\n            def func2(a={}):\n                a.custom_attr = 0\n            \"\"\"\n        builder.parse(code)\n        nonetype = nodes.const_factory(None)\n        self.assertNotIn(\"custom_attr\", nonetype.locals)\n        self.assertNotIn(\"custom_attr\", nonetype.instance_attrs)\n        nonetype = nodes.const_factory({})\n        self.assertNotIn(\"custom_attr\", nonetype.locals)\n        self.assertNotIn(\"custom_attr\", nonetype.instance_attrs)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_inferred_dont_pollute", "self", "none", "code", "def", "func", "a", "none", "a", "custom_attr", "0", "def", "func2", "a", "a", "custom_attr", "0", "builder", "parse", "code", "nonetype", "nodes", "const_factory", "none", "self", "assertnotin", "custom_attr", "nonetype", "locals", "self", "assertnotin", "custom_attr", "nonetype", "instance_attrs", "nonetype", "nodes", "const_factory", "self", "assertnotin", "custom_attr", "nonetype", "locals", "self", "assertnotin", "custom_attr", "nonetype", "instance_attrs"], "doc_len": 52}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_asstuple", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_asstuple", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_asstuple(self) -> None:\n        code = \"a, b = range(2)\"\n        astroid = builder.parse(code)\n        self.assertIn(\"b\", astroid.locals)\n        code = \"\"\"\n            def visit_if(self, node):\n                node.test, body = node.tests[0]\n            \"\"\"\n        astroid = builder.parse(code)\n        self.assertIn(\"body\", astroid[\"visit_if\"].locals)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_asstuple", "self", "none", "code", "a", "b", "range", "2", "astroid", "builder", "parse", "code", "self", "assertin", "b", "astroid", "locals", "code", "def", "visit_if", "self", "node", "node", "test", "body", "node", "tests", "0", "astroid", "builder", "parse", "code", "self", "assertin", "body", "astroid", "visit_if", "locals"], "doc_len": 43}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_build_constants", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_build_constants", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_build_constants(self) -> None:\n        \"\"\"test expected values of constants after rebuilding\"\"\"\n        code = \"\"\"\n            def func():\n                return None\n                return\n                return 'None'\n            \"\"\"\n        astroid = builder.parse(code)\n        none, nothing, chain = (ret.value for ret in astroid.body[0].body)\n        self.assertIsInstance(none, nodes.Const)\n        self.assertIsNone(none.value)\n        self.assertIsNone(nothing)\n        self.assertIsInstance(chain, nodes.Const)\n        self.assertEqual(chain.value, \"None\")\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_build_constants", "self", "none", "test", "expected", "values", "of", "constants", "after", "rebuilding", "code", "def", "func", "return", "none", "return", "return", "none", "astroid", "builder", "parse", "code", "none", "nothing", "chain", "ret", "value", "for", "ret", "in", "astroid", "body", "0", "body", "self", "assertisinstance", "none", "nodes", "const", "self", "assertisnone", "none", "value", "self", "assertisnone", "nothing", "self", "assertisinstance", "chain", "nodes", "const", "self", "assertequal", "chain", "value", "none"], "doc_len": 61}
{"doc_id": "tests/unittest_builder.py::BuilderTest.test_not_implemented", "file_path": "tests/unittest_builder.py", "class_name": "BuilderTest", "func_name": "test_not_implemented", "text": "文件路径: tests/unittest_builder.py, 类名: BuilderTest\n    def test_not_implemented(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        NotImplemented #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, NotImplemented)\n", "tokens": ["tests", "unittest_builder", "py", "buildertest", "def", "test_not_implemented", "self", "none", "node", "builder", "extract_node", "notimplemented", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "notimplemented"], "doc_len": 26}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.setUp", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "setUp", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def setUp(self) -> None:\n        self.module = resources.build_file(\"data/module.py\", \"data.module\")\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "setup", "self", "none", "self", "module", "resources", "build_file", "data", "module", "py", "data", "module"], "doc_len": 17}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_module_base_props", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_module_base_props", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_module_base_props(self) -> None:\n        \"\"\"test base properties and method of an astroid module\"\"\"\n        module = self.module\n        self.assertEqual(module.name, \"data.module\")\n        self.assertEqual(module.doc, \"test module for astroid\\n\")\n        self.assertEqual(module.fromlineno, 0)\n        self.assertIsNone(module.parent)\n        self.assertEqual(module.frame(), module)\n        self.assertEqual(module.frame(future=True), module)\n        self.assertEqual(module.root(), module)\n        self.assertEqual(module.file, os.path.abspath(resources.find(\"data/module.py\")))\n        self.assertEqual(module.pure_python, 1)\n        self.assertEqual(module.package, 0)\n        self.assertFalse(module.is_statement)\n        with pytest.warns(DeprecationWarning) as records:\n            self.assertEqual(module.statement(), module)\n            assert len(records) == 1\n        with self.assertRaises(StatementMissing):\n            module.statement(future=True)\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_module_base_props", "self", "none", "test", "base", "properties", "and", "method", "of", "an", "astroid", "module", "module", "self", "module", "self", "assertequal", "module", "name", "data", "module", "self", "assertequal", "module", "doc", "test", "module", "for", "astroid", "n", "self", "assertequal", "module", "fromlineno", "0", "self", "assertisnone", "module", "parent", "self", "assertequal", "module", "frame", "module", "self", "assertequal", "module", "frame", "future", "true", "module", "self", "assertequal", "module", "root", "module", "self", "assertequal", "module", "file", "os", "path", "abspath", "resources", "find", "data", "module", "py", "self", "assertequal", "module", "pure_python", "1", "self", "assertequal", "module", "package", "0", "self", "assertfalse", "module", "is_statement", "with", "pytest", "warns", "deprecationwarning", "as", "records", "self", "assertequal", "module", "statement", "module", "assert", "len", "records", "1", "with", "self", "assertraises", "statementmissing", "module", "statement", "future", "true"], "doc_len": 110}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_module_locals", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_module_locals", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_module_locals(self) -> None:\n        \"\"\"test the 'locals' dictionary of an astroid module\"\"\"\n        module = self.module\n        _locals = module.locals\n        self.assertIs(_locals, module.globals)\n        keys = sorted(_locals.keys())\n        should = [\n            \"MY_DICT\",\n            \"NameNode\",\n            \"YO\",\n            \"YOUPI\",\n            \"__revision__\",\n            \"global_access\",\n            \"modutils\",\n            \"four_args\",\n            \"os\",\n            \"redirect\",\n        ]\n        should.sort()\n        self.assertEqual(keys, sorted(should))\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_module_locals", "self", "none", "test", "the", "locals", "dictionary", "of", "an", "astroid", "module", "module", "self", "module", "_locals", "module", "locals", "self", "assertis", "_locals", "module", "globals", "keys", "sorted", "_locals", "keys", "should", "my_dict", "namenode", "yo", "youpi", "__revision__", "global_access", "modutils", "four_args", "os", "redirect", "should", "sort", "self", "assertequal", "keys", "sorted", "should"], "doc_len": 49}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_function_base_props", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_function_base_props", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_function_base_props(self) -> None:\n        \"\"\"test base properties and method of an astroid function\"\"\"\n        module = self.module\n        function = module[\"global_access\"]\n        self.assertEqual(function.name, \"global_access\")\n        self.assertEqual(function.doc, \"function test\")\n        self.assertEqual(function.fromlineno, 11)\n        self.assertTrue(function.parent)\n        self.assertEqual(function.frame(), function)\n        self.assertEqual(function.parent.frame(), module)\n        self.assertEqual(function.frame(future=True), function)\n        self.assertEqual(function.parent.frame(future=True), module)\n        self.assertEqual(function.root(), module)\n        self.assertEqual([n.name for n in function.args.args], [\"key\", \"val\"])\n        self.assertEqual(function.type, \"function\")\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_function_base_props", "self", "none", "test", "base", "properties", "and", "method", "of", "an", "astroid", "function", "module", "self", "module", "function", "module", "global_access", "self", "assertequal", "function", "name", "global_access", "self", "assertequal", "function", "doc", "function", "test", "self", "assertequal", "function", "fromlineno", "11", "self", "asserttrue", "function", "parent", "self", "assertequal", "function", "frame", "function", "self", "assertequal", "function", "parent", "frame", "module", "self", "assertequal", "function", "frame", "future", "true", "function", "self", "assertequal", "function", "parent", "frame", "future", "true", "module", "self", "assertequal", "function", "root", "module", "self", "assertequal", "n", "name", "for", "n", "in", "function", "args", "args", "key", "val", "self", "assertequal", "function", "type", "function"], "doc_len": 91}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_function_locals", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_function_locals", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_function_locals(self) -> None:\n        \"\"\"test the 'locals' dictionary of an astroid function\"\"\"\n        _locals = self.module[\"global_access\"].locals\n        self.assertEqual(len(_locals), 4)\n        keys = sorted(_locals.keys())\n        self.assertEqual(keys, [\"i\", \"key\", \"local\", \"val\"])\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_function_locals", "self", "none", "test", "the", "locals", "dictionary", "of", "an", "astroid", "function", "_locals", "self", "module", "global_access", "locals", "self", "assertequal", "len", "_locals", "4", "keys", "sorted", "_locals", "keys", "self", "assertequal", "keys", "i", "key", "local", "val"], "doc_len": 37}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_class_base_props", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_class_base_props", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_class_base_props(self) -> None:\n        \"\"\"test base properties and method of an astroid class\"\"\"\n        module = self.module\n        klass = module[\"YO\"]\n        self.assertEqual(klass.name, \"YO\")\n        self.assertEqual(klass.doc, \"hehe\\n    haha\")\n        self.assertEqual(klass.fromlineno, 25)\n        self.assertTrue(klass.parent)\n        self.assertEqual(klass.frame(), klass)\n        self.assertEqual(klass.parent.frame(), module)\n        self.assertEqual(klass.frame(future=True), klass)\n        self.assertEqual(klass.parent.frame(future=True), module)\n        self.assertEqual(klass.root(), module)\n        self.assertEqual(klass.basenames, [])\n        self.assertTrue(klass.newstyle)\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_class_base_props", "self", "none", "test", "base", "properties", "and", "method", "of", "an", "astroid", "class", "module", "self", "module", "klass", "module", "yo", "self", "assertequal", "klass", "name", "yo", "self", "assertequal", "klass", "doc", "hehe", "n", "haha", "self", "assertequal", "klass", "fromlineno", "25", "self", "asserttrue", "klass", "parent", "self", "assertequal", "klass", "frame", "klass", "self", "assertequal", "klass", "parent", "frame", "module", "self", "assertequal", "klass", "frame", "future", "true", "klass", "self", "assertequal", "klass", "parent", "frame", "future", "true", "module", "self", "assertequal", "klass", "root", "module", "self", "assertequal", "klass", "basenames", "self", "asserttrue", "klass", "newstyle"], "doc_len": 83}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_class_locals", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_class_locals", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_class_locals(self) -> None:\n        \"\"\"test the 'locals' dictionary of an astroid class\"\"\"\n        module = self.module\n        klass1 = module[\"YO\"]\n        locals1 = klass1.locals\n        keys = sorted(locals1.keys())\n        assert_keys = [\"__init__\", \"__module__\", \"__qualname__\", \"a\"]\n        self.assertEqual(keys, assert_keys)\n        klass2 = module[\"YOUPI\"]\n        locals2 = klass2.locals\n        keys = locals2.keys()\n        assert_keys = [\n            \"__init__\",\n            \"__module__\",\n            \"__qualname__\",\n            \"class_attr\",\n            \"class_method\",\n            \"method\",\n            \"static_method\",\n        ]\n        self.assertEqual(sorted(keys), assert_keys)\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_class_locals", "self", "none", "test", "the", "locals", "dictionary", "of", "an", "astroid", "class", "module", "self", "module", "klass1", "module", "yo", "locals1", "klass1", "locals", "keys", "sorted", "locals1", "keys", "assert_keys", "__init__", "__module__", "__qualname__", "a", "self", "assertequal", "keys", "assert_keys", "klass2", "module", "youpi", "locals2", "klass2", "locals", "keys", "locals2", "keys", "assert_keys", "__init__", "__module__", "__qualname__", "class_attr", "class_method", "method", "static_method", "self", "assertequal", "sorted", "keys", "assert_keys"], "doc_len": 60}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_class_instance_attrs", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_class_instance_attrs", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_class_instance_attrs(self) -> None:\n        module = self.module\n        klass1 = module[\"YO\"]\n        klass2 = module[\"YOUPI\"]\n        self.assertEqual(list(klass1.instance_attrs.keys()), [\"yo\"])\n        self.assertEqual(list(klass2.instance_attrs.keys()), [\"member\"])\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_class_instance_attrs", "self", "none", "module", "self", "module", "klass1", "module", "yo", "klass2", "module", "youpi", "self", "assertequal", "list", "klass1", "instance_attrs", "keys", "yo", "self", "assertequal", "list", "klass2", "instance_attrs", "keys", "member"], "doc_len": 31}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_class_basenames", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_class_basenames", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_class_basenames(self) -> None:\n        module = self.module\n        klass1 = module[\"YO\"]\n        klass2 = module[\"YOUPI\"]\n        self.assertEqual(klass1.basenames, [])\n        self.assertEqual(klass2.basenames, [\"YO\"])\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_class_basenames", "self", "none", "module", "self", "module", "klass1", "module", "yo", "klass2", "module", "youpi", "self", "assertequal", "klass1", "basenames", "self", "assertequal", "klass2", "basenames", "yo"], "doc_len": 26}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_method_base_props", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_method_base_props", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_method_base_props(self) -> None:\n        \"\"\"test base properties and method of an astroid method\"\"\"\n        klass2 = self.module[\"YOUPI\"]\n        # \"normal\" method\n        method = klass2[\"method\"]\n        self.assertEqual(method.name, \"method\")\n        self.assertEqual([n.name for n in method.args.args], [\"self\"])\n        self.assertEqual(method.doc, \"method\\n        test\")\n        self.assertEqual(method.fromlineno, 48)\n        self.assertEqual(method.type, \"method\")\n        # class method\n        method = klass2[\"class_method\"]\n        self.assertEqual([n.name for n in method.args.args], [\"cls\"])\n        self.assertEqual(method.type, \"classmethod\")\n        # static method\n        method = klass2[\"static_method\"]\n        self.assertEqual(method.args.args, [])\n        self.assertEqual(method.type, \"staticmethod\")\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_method_base_props", "self", "none", "test", "base", "properties", "and", "method", "of", "an", "astroid", "method", "klass2", "self", "module", "youpi", "normal", "method", "method", "klass2", "method", "self", "assertequal", "method", "name", "method", "self", "assertequal", "n", "name", "for", "n", "in", "method", "args", "args", "self", "self", "assertequal", "method", "doc", "method", "n", "test", "self", "assertequal", "method", "fromlineno", "48", "self", "assertequal", "method", "type", "method", "class", "method", "method", "klass2", "class_method", "self", "assertequal", "n", "name", "for", "n", "in", "method", "args", "args", "cls", "self", "assertequal", "method", "type", "classmethod", "static", "method", "method", "klass2", "static_method", "self", "assertequal", "method", "args", "args", "self", "assertequal", "method", "type", "staticmethod"], "doc_len": 95}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_method_locals", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_method_locals", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_method_locals(self) -> None:\n        \"\"\"test the 'locals' dictionary of an astroid method\"\"\"\n        method = self.module[\"YOUPI\"][\"method\"]\n        _locals = method.locals\n        keys = sorted(_locals)\n        # ListComp variables are not accessible outside\n        self.assertEqual(len(_locals), 3)\n        self.assertEqual(keys, [\"autre\", \"local\", \"self\"])\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_method_locals", "self", "none", "test", "the", "locals", "dictionary", "of", "an", "astroid", "method", "method", "self", "module", "youpi", "method", "_locals", "method", "locals", "keys", "sorted", "_locals", "listcomp", "variables", "are", "not", "accessible", "outside", "self", "assertequal", "len", "_locals", "3", "self", "assertequal", "keys", "autre", "local", "self"], "doc_len": 44}
{"doc_id": "tests/unittest_builder.py::FileBuildTest.test_unknown_encoding", "file_path": "tests/unittest_builder.py", "class_name": "FileBuildTest", "func_name": "test_unknown_encoding", "text": "文件路径: tests/unittest_builder.py, 类名: FileBuildTest\n    def test_unknown_encoding(self) -> None:\n        with self.assertRaises(AstroidSyntaxError):\n            resources.build_file(\"data/invalid_encoding.py\")\n", "tokens": ["tests", "unittest_builder", "py", "filebuildtest", "def", "test_unknown_encoding", "self", "none", "with", "self", "assertraises", "astroidsyntaxerror", "resources", "build_file", "data", "invalid_encoding", "py"], "doc_len": 17}
{"doc_id": "tests/unittest_builder.py::test_module_build_dunder_file", "file_path": "tests/unittest_builder.py", "class_name": null, "func_name": "test_module_build_dunder_file", "text": "文件路径: tests/unittest_builder.py\ndef test_module_build_dunder_file() -> None:\n    \"\"\"Test that module_build() can work with modules that have the *__file__* attribute\"\"\"\n    module = builder.AstroidBuilder().module_build(collections)\n    assert module.path[0] == collections.__file__\n", "tokens": ["tests", "unittest_builder", "py", "def", "test_module_build_dunder_file", "none", "test", "that", "module_build", "can", "work", "with", "modules", "that", "have", "the", "__file__", "attribute", "module", "builder", "astroidbuilder", "module_build", "collections", "assert", "module", "path", "0", "collections", "__file__"], "doc_len": 29}
{"doc_id": "tests/unittest_builder.py::test_parse_module_with_invalid_type_comments_does_not_crash", "file_path": "tests/unittest_builder.py", "class_name": null, "func_name": "test_parse_module_with_invalid_type_comments_does_not_crash", "text": "文件路径: tests/unittest_builder.py\ndef test_parse_module_with_invalid_type_comments_does_not_crash():\n    node = builder.parse(\n        \"\"\"\n    # op {\n    #   name: \"AssignAddVariableOp\"\n    #   input_arg {\n    #     name: \"resource\"\n    #     type: DT_RESOURCE\n    #   }\n    #   input_arg {\n    #     name: \"value\"\n    #     type_attr: \"dtype\"\n    #   }\n    #   attr {\n    #     name: \"dtype\"\n    #     type: \"type\"\n    #   }\n    #   is_stateful: true\n    # }\n    a, b = 2\n    \"\"\"\n    )\n    assert isinstance(node, nodes.Module)\n", "tokens": ["tests", "unittest_builder", "py", "def", "test_parse_module_with_invalid_type_comments_does_not_crash", "node", "builder", "parse", "op", "name", "assignaddvariableop", "input_arg", "name", "resource", "type", "dt_resource", "input_arg", "name", "value", "type_attr", "dtype", "attr", "name", "dtype", "type", "type", "is_stateful", "true", "a", "b", "2", "assert", "isinstance", "node", "nodes", "module"], "doc_len": 36}
{"doc_id": "tests/unittest_decorators.py::SomeClass.__init__", "file_path": "tests/unittest_decorators.py", "class_name": "SomeClass", "func_name": "__init__", "text": "文件路径: tests/unittest_decorators.py, 类名: SomeClass\n    def __init__(self, name=None, lineno=None):\n        ...\n", "tokens": ["tests", "unittest_decorators", "py", "someclass", "def", "__init__", "self", "name", "none", "lineno", "none"], "doc_len": 11}
{"doc_id": "tests/unittest_decorators.py::SomeClass.func", "file_path": "tests/unittest_decorators.py", "class_name": "SomeClass", "func_name": "func", "text": "文件路径: tests/unittest_decorators.py, 类名: SomeClass\n    def func(self, name=None, var=None, type_annotation=None):\n        ...\n", "tokens": ["tests", "unittest_decorators", "py", "someclass", "def", "func", "self", "name", "none", "var", "none", "type_annotation", "none"], "doc_len": 13}
{"doc_id": "tests/unittest_decorators.py::TestDeprecationDecorators.test_deprecated_default_argument_values_one_arg", "file_path": "tests/unittest_decorators.py", "class_name": "TestDeprecationDecorators", "func_name": "test_deprecated_default_argument_values_one_arg", "text": "文件路径: tests/unittest_decorators.py, 类名: TestDeprecationDecorators\n    def test_deprecated_default_argument_values_one_arg() -> None:\n        with pytest.warns(DeprecationWarning) as records:\n            # No argument passed for 'name'\n            SomeClass()\n            assert len(records) == 1\n            assert \"name\" in records[0].message.args[0]\n            assert \"'SomeClass.__init__'\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            # 'None' passed as argument for 'name'\n            SomeClass(None)\n            assert len(records) == 1\n            assert \"name\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            # 'None' passed as keyword argument for 'name'\n            SomeClass(name=None)\n            assert len(records) == 1\n            assert \"name\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            # No value passed for 'name'\n            SomeClass(lineno=42)\n            assert len(records) == 1\n            assert \"name\" in records[0].message.args[0]\n", "tokens": ["tests", "unittest_decorators", "py", "testdeprecationdecorators", "def", "test_deprecated_default_argument_values_one_arg", "none", "with", "pytest", "warns", "deprecationwarning", "as", "records", "no", "argument", "passed", "for", "name", "someclass", "assert", "len", "records", "1", "assert", "name", "in", "records", "0", "message", "args", "0", "assert", "someclass", "__init__", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "none", "passed", "as", "argument", "for", "name", "someclass", "none", "assert", "len", "records", "1", "assert", "name", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "none", "passed", "as", "keyword", "argument", "for", "name", "someclass", "name", "none", "assert", "len", "records", "1", "assert", "name", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "no", "value", "passed", "for", "name", "someclass", "lineno", "42", "assert", "len", "records", "1", "assert", "name", "in", "records", "0", "message", "args", "0"], "doc_len": 120}
{"doc_id": "tests/unittest_decorators.py::TestDeprecationDecorators.test_deprecated_default_argument_values_two_args", "file_path": "tests/unittest_decorators.py", "class_name": "TestDeprecationDecorators", "func_name": "test_deprecated_default_argument_values_two_args", "text": "文件路径: tests/unittest_decorators.py, 类名: TestDeprecationDecorators\n    def test_deprecated_default_argument_values_two_args() -> None:\n        instance = SomeClass(name=\"\")\n\n        # No value of 'None' passed for both arguments\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func()\n            assert len(records) == 2\n            assert \"'SomeClass.func'\" in records[0].message.args[0]\n            assert \"astroid 3.2\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(None)\n            assert len(records) == 2\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(name=None)\n            assert len(records) == 2\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(var=None)\n            assert len(records) == 2\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(name=None, var=None)\n            assert len(records) == 2\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(type_annotation=\"\")\n            assert len(records) == 2\n\n        # No value of 'None' for one argument\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(42)\n            assert len(records) == 1\n            assert \"var\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(name=\"\")\n            assert len(records) == 1\n            assert \"var\" in records[0].message.args[0]\n\n        with pytest.warns(DeprecationWarning) as records:\n            instance.func(var=42)\n            assert len(records) == 1\n            assert \"name\" in records[0].message.args[0]\n", "tokens": ["tests", "unittest_decorators", "py", "testdeprecationdecorators", "def", "test_deprecated_default_argument_values_two_args", "none", "instance", "someclass", "name", "no", "value", "of", "none", "passed", "for", "both", "arguments", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "assert", "len", "records", "2", "assert", "someclass", "func", "in", "records", "0", "message", "args", "0", "assert", "astroid", "3", "2", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "none", "assert", "len", "records", "2", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "name", "none", "assert", "len", "records", "2", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "var", "none", "assert", "len", "records", "2", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "name", "none", "var", "none", "assert", "len", "records", "2", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "type_annotation", "assert", "len", "records", "2", "no", "value", "of", "none", "for", "one", "argument", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "42", "assert", "len", "records", "1", "assert", "var", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "name", "assert", "len", "records", "1", "assert", "var", "in", "records", "0", "message", "args", "0", "with", "pytest", "warns", "deprecationwarning", "as", "records", "instance", "func", "var", "42", "assert", "len", "records", "1", "assert", "name", "in", "records", "0", "message", "args", "0"], "doc_len": 190}
{"doc_id": "tests/unittest_decorators.py::TestDeprecationDecorators.test_deprecated_default_argument_values_ok", "file_path": "tests/unittest_decorators.py", "class_name": "TestDeprecationDecorators", "func_name": "test_deprecated_default_argument_values_ok", "text": "文件路径: tests/unittest_decorators.py, 类名: TestDeprecationDecorators\n    def test_deprecated_default_argument_values_ok(recwarn: WarningsRecorder) -> None:\n        \"\"\"No DeprecationWarning should be emitted\n        if all arguments are passed with not None values.\n        \"\"\"\n        instance = SomeClass(name=\"some_name\")\n        instance.func(name=\"\", var=42)\n        assert len(recwarn) == 0\n", "tokens": ["tests", "unittest_decorators", "py", "testdeprecationdecorators", "def", "test_deprecated_default_argument_values_ok", "recwarn", "warningsrecorder", "none", "no", "deprecationwarning", "should", "be", "emitted", "if", "all", "arguments", "are", "passed", "with", "not", "none", "values", "instance", "someclass", "name", "some_name", "instance", "func", "name", "var", "42", "assert", "len", "recwarn", "0"], "doc_len": 36}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.setUp", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "setUp", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def setUp(self) -> None:\n        builtins_name = builtins.__name__\n        astroid_manager = manager.AstroidManager()\n        self.builtins = astroid_manager.astroid_cache[builtins_name]\n        self.manager = manager.AstroidManager()\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "setup", "self", "none", "builtins_name", "builtins", "__name__", "astroid_manager", "manager", "astroidmanager", "self", "builtins", "astroid_manager", "astroid_cache", "builtins_name", "self", "manager", "manager", "astroidmanager"], "doc_len": 23}
{"doc_id": "tests/unittest_helpers.py::TestHelpers._extract", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "_extract", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def _extract(self, obj_name: str) -> ClassDef:\n        return self.builtins.getattr(obj_name)[0]\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "_extract", "self", "obj_name", "str", "classdef", "return", "self", "builtins", "getattr", "obj_name", "0"], "doc_len": 16}
{"doc_id": "tests/unittest_helpers.py::TestHelpers._build_custom_builtin", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "_build_custom_builtin", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def _build_custom_builtin(self, obj_name: str) -> ClassDef:\n        proxy = raw_building.build_class(obj_name)\n        proxy.parent = self.builtins\n        return proxy\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "_build_custom_builtin", "self", "obj_name", "str", "classdef", "proxy", "raw_building", "build_class", "obj_name", "proxy", "parent", "self", "builtins", "return", "proxy"], "doc_len": 20}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.assert_classes_equal", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "assert_classes_equal", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def assert_classes_equal(self, cls: ClassDef, other: ClassDef) -> None:\n        self.assertEqual(cls.name, other.name)\n        self.assertEqual(cls.parent, other.parent)\n        self.assertEqual(cls.qname(), other.qname())\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "assert_classes_equal", "self", "cls", "classdef", "other", "classdef", "none", "self", "assertequal", "cls", "name", "other", "name", "self", "assertequal", "cls", "parent", "other", "parent", "self", "assertequal", "cls", "qname", "other", "qname"], "doc_len": 30}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_object_type", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_object_type", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_object_type(self) -> None:\n        pairs = [\n            (\"1\", self._extract(\"int\")),\n            (\"[]\", self._extract(\"list\")),\n            (\"{1, 2, 3}\", self._extract(\"set\")),\n            (\"{1:2, 4:3}\", self._extract(\"dict\")),\n            (\"type\", self._extract(\"type\")),\n            (\"object\", self._extract(\"type\")),\n            (\"object()\", self._extract(\"object\")),\n            (\"lambda: None\", self._build_custom_builtin(\"function\")),\n            (\"len\", self._build_custom_builtin(\"builtin_function_or_method\")),\n            (\"None\", self._build_custom_builtin(\"NoneType\")),\n            (\"import sys\\nsys#@\", self._build_custom_builtin(\"module\")),\n        ]\n        for code, expected in pairs:\n            node = builder.extract_node(code)\n            objtype = helpers.object_type(node)\n            self.assert_classes_equal(objtype, expected)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_object_type", "self", "none", "pairs", "1", "self", "_extract", "int", "self", "_extract", "list", "1", "2", "3", "self", "_extract", "set", "1", "2", "4", "3", "self", "_extract", "dict", "type", "self", "_extract", "type", "object", "self", "_extract", "type", "object", "self", "_extract", "object", "lambda", "none", "self", "_build_custom_builtin", "function", "len", "self", "_build_custom_builtin", "builtin_function_or_method", "none", "self", "_build_custom_builtin", "nonetype", "import", "sys", "nsys", "self", "_build_custom_builtin", "module", "for", "code", "expected", "in", "pairs", "node", "builder", "extract_node", "code", "objtype", "helpers", "object_type", "node", "self", "assert_classes_equal", "objtype", "expected"], "doc_len": 77}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_object_type_classes_and_functions", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_object_type_classes_and_functions", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_object_type_classes_and_functions(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        def generator():\n            yield\n\n        class A(object):\n            def test(self):\n                self #@\n            @classmethod\n            def cls_method(cls): pass\n            @staticmethod\n            def static_method(): pass\n        A #@\n        A() #@\n        A.test #@\n        A().test #@\n        A.cls_method #@\n        A().cls_method #@\n        A.static_method #@\n        A().static_method #@\n        generator() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        from_self = helpers.object_type(ast_nodes[0])\n        cls = next(ast_nodes[1].infer())\n        self.assert_classes_equal(from_self, cls)\n\n        cls_type = helpers.object_type(ast_nodes[1])\n        self.assert_classes_equal(cls_type, self._extract(\"type\"))\n\n        instance_type = helpers.object_type(ast_nodes[2])\n        cls = next(ast_nodes[2].infer())._proxied\n        self.assert_classes_equal(instance_type, cls)\n\n        expected_method_types = [\n            (ast_nodes[3], \"function\"),\n            (ast_nodes[4], \"method\"),\n            (ast_nodes[5], \"method\"),\n            (ast_nodes[6], \"method\"),\n            (ast_nodes[7], \"function\"),\n            (ast_nodes[8], \"function\"),\n            (ast_nodes[9], \"generator\"),\n        ]\n        for node, expected in expected_method_types:\n            node_type = helpers.object_type(node)\n            expected_type = self._build_custom_builtin(expected)\n            self.assert_classes_equal(node_type, expected_type)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_object_type_classes_and_functions", "self", "none", "ast_nodes", "builder", "extract_node", "def", "generator", "yield", "class", "a", "object", "def", "test", "self", "self", "classmethod", "def", "cls_method", "cls", "pass", "staticmethod", "def", "static_method", "pass", "a", "a", "a", "test", "a", "test", "a", "cls_method", "a", "cls_method", "a", "static_method", "a", "static_method", "generator", "assert", "isinstance", "ast_nodes", "list", "from_self", "helpers", "object_type", "ast_nodes", "0", "cls", "next", "ast_nodes", "1", "infer", "self", "assert_classes_equal", "from_self", "cls", "cls_type", "helpers", "object_type", "ast_nodes", "1", "self", "assert_classes_equal", "cls_type", "self", "_extract", "type", "instance_type", "helpers", "object_type", "ast_nodes", "2", "cls", "next", "ast_nodes", "2", "infer", "_proxied", "self", "assert_classes_equal", "instance_type", "cls", "expected_method_types", "ast_nodes", "3", "function", "ast_nodes", "4", "method", "ast_nodes", "5", "method", "ast_nodes", "6", "method", "ast_nodes", "7", "function", "ast_nodes", "8", "function", "ast_nodes", "9", "generator", "for", "node", "expected", "in", "expected_method_types", "node_type", "helpers", "object_type", "node", "expected_type", "self", "_build_custom_builtin", "expected", "self", "assert_classes_equal", "node_type", "expected_type"], "doc_len": 128}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_object_type_metaclasses", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_object_type_metaclasses", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_object_type_metaclasses(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        import abc\n        class Meta(metaclass=abc.ABCMeta):\n            pass\n        meta_instance = Meta()\n        \"\"\"\n        )\n        meta_type = helpers.object_type(module[\"Meta\"])\n        self.assert_classes_equal(meta_type, module[\"Meta\"].metaclass())\n\n        meta_instance = next(module[\"meta_instance\"].infer())\n        instance_type = helpers.object_type(meta_instance)\n        self.assert_classes_equal(instance_type, module[\"Meta\"])\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_object_type_metaclasses", "self", "none", "module", "builder", "parse", "import", "abc", "class", "meta", "metaclass", "abc", "abcmeta", "pass", "meta_instance", "meta", "meta_type", "helpers", "object_type", "module", "meta", "self", "assert_classes_equal", "meta_type", "module", "meta", "metaclass", "meta_instance", "next", "module", "meta_instance", "infer", "instance_type", "helpers", "object_type", "meta_instance", "self", "assert_classes_equal", "instance_type", "module", "meta"], "doc_len": 46}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_object_type_most_derived", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_object_type_most_derived", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_object_type_most_derived(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class A(type):\n            def __new__(*args, **kwargs):\n                 return type.__new__(*args, **kwargs)\n        class B(object): pass\n        class C(object, metaclass=A): pass\n\n        # The most derived metaclass of D is A rather than type.\n        class D(B , C): #@\n            pass\n        \"\"\"\n        )\n        assert isinstance(node, nodes.NodeNG)\n        metaclass = node.metaclass()\n        self.assertEqual(metaclass.name, \"A\")\n        obj_type = helpers.object_type(node)\n        self.assertEqual(metaclass, obj_type)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_object_type_most_derived", "self", "none", "node", "builder", "extract_node", "class", "a", "type", "def", "__new__", "args", "kwargs", "return", "type", "__new__", "args", "kwargs", "class", "b", "object", "pass", "class", "c", "object", "metaclass", "a", "pass", "the", "most", "derived", "metaclass", "of", "d", "is", "a", "rather", "than", "type", "class", "d", "b", "c", "pass", "assert", "isinstance", "node", "nodes", "nodeng", "metaclass", "node", "metaclass", "self", "assertequal", "metaclass", "name", "a", "obj_type", "helpers", "object_type", "node", "self", "assertequal", "metaclass", "obj_type"], "doc_len": 70}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_inference_errors", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_inference_errors", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_inference_errors(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from unknown import Unknown\n        u = Unknown #@\n        \"\"\"\n        )\n        self.assertEqual(helpers.object_type(node), util.Uninferable)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_inference_errors", "self", "none", "node", "builder", "extract_node", "from", "unknown", "import", "unknown", "u", "unknown", "self", "assertequal", "helpers", "object_type", "node", "util", "uninferable"], "doc_len": 24}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_object_type_too_many_types", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_object_type_too_many_types", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_object_type_too_many_types(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        from unknown import Unknown\n        def test(x):\n            if x:\n                return lambda: None\n            else:\n                return 1\n        test(Unknown) #@\n        \"\"\"\n        )\n        self.assertEqual(helpers.object_type(node), util.Uninferable)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_object_type_too_many_types", "self", "none", "node", "builder", "extract_node", "from", "unknown", "import", "unknown", "def", "test", "x", "if", "x", "return", "lambda", "none", "else", "return", "1", "test", "unknown", "self", "assertequal", "helpers", "object_type", "node", "util", "uninferable"], "doc_len": 35}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class int_subclass(int):\n            pass\n        class A(object): pass #@\n        class B(A): pass #@\n        class C(A): pass #@\n        int_subclass() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        cls_a = ast_nodes[0]\n        cls_b = ast_nodes[1]\n        cls_c = ast_nodes[2]\n        int_subclass = ast_nodes[3]\n        int_subclass = helpers.object_type(next(int_subclass.infer()))\n        base_int = self._extract(\"int\")\n        self.assertTrue(helpers.is_subtype(int_subclass, base_int))\n        self.assertTrue(helpers.is_supertype(base_int, int_subclass))\n\n        self.assertTrue(helpers.is_supertype(cls_a, cls_b))\n        self.assertTrue(helpers.is_supertype(cls_a, cls_c))\n        self.assertTrue(helpers.is_subtype(cls_b, cls_a))\n        self.assertTrue(helpers.is_subtype(cls_c, cls_a))\n        self.assertFalse(helpers.is_subtype(cls_a, cls_b))\n        self.assertFalse(helpers.is_subtype(cls_a, cls_b))\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype", "self", "none", "ast_nodes", "builder", "extract_node", "class", "int_subclass", "int", "pass", "class", "a", "object", "pass", "class", "b", "a", "pass", "class", "c", "a", "pass", "int_subclass", "assert", "isinstance", "ast_nodes", "list", "cls_a", "ast_nodes", "0", "cls_b", "ast_nodes", "1", "cls_c", "ast_nodes", "2", "int_subclass", "ast_nodes", "3", "int_subclass", "helpers", "object_type", "next", "int_subclass", "infer", "base_int", "self", "_extract", "int", "self", "asserttrue", "helpers", "is_subtype", "int_subclass", "base_int", "self", "asserttrue", "helpers", "is_supertype", "base_int", "int_subclass", "self", "asserttrue", "helpers", "is_supertype", "cls_a", "cls_b", "self", "asserttrue", "helpers", "is_supertype", "cls_a", "cls_c", "self", "asserttrue", "helpers", "is_subtype", "cls_b", "cls_a", "self", "asserttrue", "helpers", "is_subtype", "cls_c", "cls_a", "self", "assertfalse", "helpers", "is_subtype", "cls_a", "cls_b", "self", "assertfalse", "helpers", "is_subtype", "cls_a", "cls_b"], "doc_len": 102}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype_supertype_mro_error", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype_supertype_mro_error", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype_supertype_mro_error(self) -> None:\n        cls_e, cls_f = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(A): pass\n        class C(A): pass\n        class D(B, C): pass\n        class E(C, B): pass #@\n        class F(D, E): pass #@\n        \"\"\"\n        )\n        self.assertFalse(helpers.is_subtype(cls_e, cls_f))\n\n        self.assertFalse(helpers.is_subtype(cls_e, cls_f))\n        with self.assertRaises(_NonDeducibleTypeHierarchy):\n            helpers.is_subtype(cls_f, cls_e)\n        self.assertFalse(helpers.is_supertype(cls_f, cls_e))\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype_supertype_mro_error", "self", "none", "cls_e", "cls_f", "builder", "extract_node", "class", "a", "object", "pass", "class", "b", "a", "pass", "class", "c", "a", "pass", "class", "d", "b", "c", "pass", "class", "e", "c", "b", "pass", "class", "f", "d", "e", "pass", "self", "assertfalse", "helpers", "is_subtype", "cls_e", "cls_f", "self", "assertfalse", "helpers", "is_subtype", "cls_e", "cls_f", "with", "self", "assertraises", "_nondeducibletypehierarchy", "helpers", "is_subtype", "cls_f", "cls_e", "self", "assertfalse", "helpers", "is_supertype", "cls_f", "cls_e"], "doc_len": 65}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype_supertype_unknown_bases", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype_supertype_unknown_bases", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype_supertype_unknown_bases(self) -> None:\n        cls_a, cls_b = builder.extract_node(\n            \"\"\"\n        from unknown import Unknown\n        class A(Unknown): pass #@\n        class B(A): pass #@\n        \"\"\"\n        )\n        with self.assertRaises(_NonDeducibleTypeHierarchy):\n            helpers.is_subtype(cls_a, cls_b)\n        with self.assertRaises(_NonDeducibleTypeHierarchy):\n            helpers.is_supertype(cls_a, cls_b)\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype_supertype_unknown_bases", "self", "none", "cls_a", "cls_b", "builder", "extract_node", "from", "unknown", "import", "unknown", "class", "a", "unknown", "pass", "class", "b", "a", "pass", "with", "self", "assertraises", "_nondeducibletypehierarchy", "helpers", "is_subtype", "cls_a", "cls_b", "with", "self", "assertraises", "_nondeducibletypehierarchy", "helpers", "is_supertype", "cls_a", "cls_b"], "doc_len": 40}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype_supertype_unrelated_classes", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype_supertype_unrelated_classes", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype_supertype_unrelated_classes(self) -> None:\n        cls_a, cls_b = builder.extract_node(\n            \"\"\"\n        class A(object): pass #@\n        class B(object): pass #@\n        \"\"\"\n        )\n        self.assertFalse(helpers.is_subtype(cls_a, cls_b))\n        self.assertFalse(helpers.is_subtype(cls_b, cls_a))\n        self.assertFalse(helpers.is_supertype(cls_a, cls_b))\n        self.assertFalse(helpers.is_supertype(cls_b, cls_a))\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype_supertype_unrelated_classes", "self", "none", "cls_a", "cls_b", "builder", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "self", "assertfalse", "helpers", "is_subtype", "cls_a", "cls_b", "self", "assertfalse", "helpers", "is_subtype", "cls_b", "cls_a", "self", "assertfalse", "helpers", "is_supertype", "cls_a", "cls_b", "self", "assertfalse", "helpers", "is_supertype", "cls_b", "cls_a"], "doc_len": 44}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype_supertype_classes_no_type_ancestor", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype_supertype_classes_no_type_ancestor", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype_supertype_classes_no_type_ancestor(self) -> None:\n        cls_a = builder.extract_node(\n            \"\"\"\n        class A(object): #@\n            pass\n        \"\"\"\n        )\n        builtin_type = self._extract(\"type\")\n        self.assertFalse(helpers.is_supertype(builtin_type, cls_a))\n        self.assertFalse(helpers.is_subtype(cls_a, builtin_type))\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype_supertype_classes_no_type_ancestor", "self", "none", "cls_a", "builder", "extract_node", "class", "a", "object", "pass", "builtin_type", "self", "_extract", "type", "self", "assertfalse", "helpers", "is_supertype", "builtin_type", "cls_a", "self", "assertfalse", "helpers", "is_subtype", "cls_a", "builtin_type"], "doc_len": 31}
{"doc_id": "tests/unittest_helpers.py::TestHelpers.test_is_subtype_supertype_classes_metaclasses", "file_path": "tests/unittest_helpers.py", "class_name": "TestHelpers", "func_name": "test_is_subtype_supertype_classes_metaclasses", "text": "文件路径: tests/unittest_helpers.py, 类名: TestHelpers\n    def test_is_subtype_supertype_classes_metaclasses(self) -> None:\n        cls_a = builder.extract_node(\n            \"\"\"\n        class A(type): #@\n            pass\n        \"\"\"\n        )\n        builtin_type = self._extract(\"type\")\n        self.assertTrue(helpers.is_supertype(builtin_type, cls_a))\n        self.assertTrue(helpers.is_subtype(cls_a, builtin_type))\n", "tokens": ["tests", "unittest_helpers", "py", "testhelpers", "def", "test_is_subtype_supertype_classes_metaclasses", "self", "none", "cls_a", "builder", "extract_node", "class", "a", "type", "pass", "builtin_type", "self", "_extract", "type", "self", "asserttrue", "helpers", "is_supertype", "builtin_type", "cls_a", "self", "asserttrue", "helpers", "is_subtype", "cls_a", "builtin_type"], "doc_len": 31}
{"doc_id": "tests/unittest_inference.py::get_node_of_class", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "get_node_of_class", "text": "文件路径: tests/unittest_inference.py\ndef get_node_of_class(start_from: nodes.FunctionDef, klass: type) -> nodes.Attribute:\n    return next(start_from.nodes_of_class(klass))\n", "tokens": ["tests", "unittest_inference", "py", "def", "get_node_of_class", "start_from", "nodes", "functiondef", "klass", "type", "nodes", "attribute", "return", "next", "start_from", "nodes_of_class", "klass"], "doc_len": 17}
{"doc_id": "tests/unittest_inference.py::InferenceUtilsTest.test_path_wrapper", "file_path": "tests/unittest_inference.py", "class_name": "InferenceUtilsTest", "func_name": "test_path_wrapper", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceUtilsTest\n    def test_path_wrapper(self) -> None:\n        def infer_default(self: Any, *args: InferenceContext) -> None:\n            raise InferenceError\n\n        infer_default = decoratorsmod.path_wrapper(infer_default)\n        infer_end = decoratorsmod.path_wrapper(inference_infer_end)\n        with self.assertRaises(InferenceError):\n            next(infer_default(1))\n        self.assertEqual(next(infer_end(1)), 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferenceutilstest", "def", "test_path_wrapper", "self", "none", "def", "infer_default", "self", "any", "args", "inferencecontext", "none", "raise", "inferenceerror", "infer_default", "decoratorsmod", "path_wrapper", "infer_default", "infer_end", "decoratorsmod", "path_wrapper", "inference_infer_end", "with", "self", "assertraises", "inferenceerror", "next", "infer_default", "1", "self", "assertequal", "next", "infer_end", "1", "1"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::_assertInferElts", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "_assertInferElts", "text": "文件路径: tests/unittest_inference.py\ndef _assertInferElts(\n    node_type: ABCMeta,\n    self: \"InferenceTest\",\n    node: Any,\n    elts: Union[List[int], List[str]],\n) -> None:\n    inferred = next(node.infer())\n    self.assertIsInstance(inferred, node_type)\n    self.assertEqual(sorted(elt.value for elt in inferred.elts), elts)\n", "tokens": ["tests", "unittest_inference", "py", "def", "_assertinferelts", "node_type", "abcmeta", "self", "inferencetest", "node", "any", "elts", "union", "list", "int", "list", "str", "none", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "node_type", "self", "assertequal", "sorted", "elt", "value", "for", "elt", "in", "inferred", "elts", "elts"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::partialmethod", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "partialmethod", "text": "文件路径: tests/unittest_inference.py\ndef partialmethod(func, arg):\n    \"\"\"similar to functools.partial but return a lambda instead of a class so returned value may be\n    turned into a method.\n    \"\"\"\n    return lambda *args, **kwargs: func(arg, *args, **kwargs)\n", "tokens": ["tests", "unittest_inference", "py", "def", "partialmethod", "func", "arg", "similar", "to", "functools", "partial", "but", "return", "a", "lambda", "instead", "of", "a", "class", "so", "returned", "value", "may", "be", "turned", "into", "a", "method", "return", "lambda", "args", "kwargs", "func", "arg", "args", "kwargs"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::InferenceTest.assertInferConst", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "assertInferConst", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def assertInferConst(self, node: nodes.Call, expected: str) -> None:\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "assertinferconst", "self", "node", "nodes", "call", "expected", "str", "none", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::InferenceTest.assertInferDict", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "assertInferDict", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def assertInferDict(\n        self, node: Union[nodes.Call, nodes.Dict, nodes.NodeNG], expected: Any\n    ) -> None:\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Dict)\n\n        elts = {(key.value, value.value) for (key, value) in inferred.items}\n        self.assertEqual(sorted(elts), sorted(expected.items()))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "assertinferdict", "self", "node", "union", "nodes", "call", "nodes", "dict", "nodes", "nodeng", "expected", "any", "none", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "dict", "elts", "key", "value", "value", "value", "for", "key", "value", "in", "inferred", "items", "self", "assertequal", "sorted", "elts", "sorted", "expected", "items"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_abstract_property_return_values", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_abstract_property_return_values", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_abstract_property_return_values(self) -> None:\n        module = parse(\n            \"\"\"\n        import abc\n\n        class A(object):\n            @abc.abstractproperty\n            def test(self):\n                return 42\n\n        a = A()\n        x = a.test\n        \"\"\"\n        )\n        inferred = next(module[\"x\"].infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_abstract_property_return_values", "self", "none", "module", "parse", "import", "abc", "class", "a", "object", "abc", "abstractproperty", "def", "test", "self", "return", "42", "a", "a", "x", "a", "test", "inferred", "next", "module", "x", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_module_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_module_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_module_inference(self) -> None:\n        inferred = self.ast.infer()\n        obj = next(inferred)\n        self.assertEqual(obj.name, __name__)\n        self.assertEqual(obj.root().name, __name__)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_module_inference", "self", "none", "inferred", "self", "ast", "infer", "obj", "next", "inferred", "self", "assertequal", "obj", "name", "__name__", "self", "assertequal", "obj", "root", "name", "__name__", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 32}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_class_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_class_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_class_inference(self) -> None:\n        inferred = self.ast[\"C\"].infer()\n        obj = next(inferred)\n        self.assertEqual(obj.name, \"C\")\n        self.assertEqual(obj.root().name, __name__)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_class_inference", "self", "none", "inferred", "self", "ast", "c", "infer", "obj", "next", "inferred", "self", "assertequal", "obj", "name", "c", "self", "assertequal", "obj", "root", "name", "__name__", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 33}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_function_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_function_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_function_inference(self) -> None:\n        inferred = self.ast[\"C\"][\"meth1\"].infer()\n        obj = next(inferred)\n        self.assertEqual(obj.name, \"meth1\")\n        self.assertEqual(obj.root().name, __name__)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_function_inference", "self", "none", "inferred", "self", "ast", "c", "meth1", "infer", "obj", "next", "inferred", "self", "assertequal", "obj", "name", "meth1", "self", "assertequal", "obj", "root", "name", "__name__", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_builtin_name_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_builtin_name_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_builtin_name_inference(self) -> None:\n        inferred = self.ast[\"C\"][\"meth1\"][\"var\"].infer()\n        var = next(inferred)\n        self.assertEqual(var.name, \"object\")\n        self.assertEqual(var.root().name, \"builtins\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_builtin_name_inference", "self", "none", "inferred", "self", "ast", "c", "meth1", "var", "infer", "var", "next", "inferred", "self", "assertequal", "var", "name", "object", "self", "assertequal", "var", "root", "name", "builtins", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_tupleassign_name_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_tupleassign_name_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_tupleassign_name_inference(self) -> None:\n        inferred = self.ast[\"a\"].infer()\n        exc = next(inferred)\n        self.assertIsInstance(exc, Instance)\n        self.assertEqual(exc.name, \"Exception\")\n        self.assertEqual(exc.root().name, EXC_MODULE)\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"b\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, 1)\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"c\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, \"bonjour\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_tupleassign_name_inference", "self", "none", "inferred", "self", "ast", "a", "infer", "exc", "next", "inferred", "self", "assertisinstance", "exc", "instance", "self", "assertequal", "exc", "name", "exception", "self", "assertequal", "exc", "root", "name", "exc_module", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "b", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "1", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "c", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "bonjour", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 85}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_listassign_name_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_listassign_name_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_listassign_name_inference(self) -> None:\n        inferred = self.ast[\"d\"].infer()\n        exc = next(inferred)\n        self.assertIsInstance(exc, Instance)\n        self.assertEqual(exc.name, \"Exception\")\n        self.assertEqual(exc.root().name, EXC_MODULE)\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"e\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, 1.0)\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"f\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Tuple)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_listassign_name_inference", "self", "none", "inferred", "self", "ast", "d", "infer", "exc", "next", "inferred", "self", "assertisinstance", "exc", "instance", "self", "assertequal", "exc", "name", "exception", "self", "assertequal", "exc", "root", "name", "exc_module", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "e", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "1", "0", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "f", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "tuple", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 81}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_advanced_tupleassign_name_inference1", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_advanced_tupleassign_name_inference1", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_advanced_tupleassign_name_inference1(self) -> None:\n        inferred = self.ast[\"g\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, \"bonjour\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"h\"].infer()\n        var = next(inferred)\n        self.assertEqual(var.name, \"object\")\n        self.assertEqual(var.root().name, \"builtins\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_advanced_tupleassign_name_inference1", "self", "none", "inferred", "self", "ast", "g", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "bonjour", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "h", "infer", "var", "next", "inferred", "self", "assertequal", "var", "name", "object", "self", "assertequal", "var", "root", "name", "builtins", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 57}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_advanced_tupleassign_name_inference2", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_advanced_tupleassign_name_inference2", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_advanced_tupleassign_name_inference2(self) -> None:\n        inferred = self.ast[\"i\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, \"glup\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"j\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, \"bonjour\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast[\"k\"].infer()\n        var = next(inferred)\n        self.assertEqual(var.name, \"object\")\n        self.assertEqual(var.root().name, \"builtins\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_advanced_tupleassign_name_inference2", "self", "none", "inferred", "self", "ast", "i", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "glup", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "j", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "bonjour", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "k", "infer", "var", "next", "inferred", "self", "assertequal", "var", "name", "object", "self", "assertequal", "var", "root", "name", "builtins", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 81}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_swap_assign_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_swap_assign_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_swap_assign_inference(self) -> None:\n        inferred = self.ast.locals[\"a\"][1].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, 1)\n        self.assertRaises(StopIteration, partial(next, inferred))\n        inferred = self.ast.locals[\"b\"][1].infer()\n        exc = next(inferred)\n        self.assertIsInstance(exc, Instance)\n        self.assertEqual(exc.name, \"Exception\")\n        self.assertEqual(exc.root().name, EXC_MODULE)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_swap_assign_inference", "self", "none", "inferred", "self", "ast", "locals", "a", "1", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "1", "self", "assertraises", "stopiteration", "partial", "next", "inferred", "inferred", "self", "ast", "locals", "b", "1", "infer", "exc", "next", "inferred", "self", "assertisinstance", "exc", "instance", "self", "assertequal", "exc", "name", "exception", "self", "assertequal", "exc", "root", "name", "exc_module", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 65}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_getattr_inference1", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_getattr_inference1", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_getattr_inference1(self) -> None:\n        inferred = self.ast[\"ex\"].infer()\n        exc = next(inferred)\n        self.assertIsInstance(exc, Instance)\n        self.assertEqual(exc.name, \"Exception\")\n        self.assertEqual(exc.root().name, EXC_MODULE)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_getattr_inference1", "self", "none", "inferred", "self", "ast", "ex", "infer", "exc", "next", "inferred", "self", "assertisinstance", "exc", "instance", "self", "assertequal", "exc", "name", "exception", "self", "assertequal", "exc", "root", "name", "exc_module", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_getattr_inference2", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_getattr_inference2", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_getattr_inference2(self) -> None:\n        inferred = get_node_of_class(self.ast[\"C\"][\"meth2\"], nodes.Attribute).infer()\n        meth1 = next(inferred)\n        self.assertEqual(meth1.name, \"meth1\")\n        self.assertEqual(meth1.root().name, __name__)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_getattr_inference2", "self", "none", "inferred", "get_node_of_class", "self", "ast", "c", "meth2", "nodes", "attribute", "infer", "meth1", "next", "inferred", "self", "assertequal", "meth1", "name", "meth1", "self", "assertequal", "meth1", "root", "name", "__name__", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_getattr_inference3", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_getattr_inference3", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_getattr_inference3(self) -> None:\n        inferred = self.ast[\"C\"][\"meth3\"][\"b\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, 4)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_getattr_inference3", "self", "none", "inferred", "self", "ast", "c", "meth3", "b", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "4", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_getattr_inference4", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_getattr_inference4", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_getattr_inference4(self) -> None:\n        inferred = self.ast[\"C\"][\"meth3\"][\"c\"].infer()\n        const = next(inferred)\n        self.assertIsInstance(const, nodes.Const)\n        self.assertEqual(const.value, \"hop\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_getattr_inference4", "self", "none", "inferred", "self", "ast", "c", "meth3", "c", "infer", "const", "next", "inferred", "self", "assertisinstance", "const", "nodes", "const", "self", "assertequal", "const", "value", "hop", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_callfunc_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_callfunc_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_callfunc_inference(self) -> None:\n        inferred = self.ast[\"v\"].infer()\n        meth1 = next(inferred)\n        self.assertIsInstance(meth1, Instance)\n        self.assertEqual(meth1.name, \"object\")\n        self.assertEqual(meth1.root().name, \"builtins\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_callfunc_inference", "self", "none", "inferred", "self", "ast", "v", "infer", "meth1", "next", "inferred", "self", "assertisinstance", "meth1", "instance", "self", "assertequal", "meth1", "name", "object", "self", "assertequal", "meth1", "root", "name", "builtins", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unbound_method_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unbound_method_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unbound_method_inference(self) -> None:\n        inferred = self.ast[\"m_unbound\"].infer()\n        meth1 = next(inferred)\n        self.assertIsInstance(meth1, UnboundMethod)\n        self.assertEqual(meth1.name, \"meth1\")\n        self.assertEqual(meth1.parent.frame().name, \"C\")\n        self.assertEqual(meth1.parent.frame(future=True).name, \"C\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unbound_method_inference", "self", "none", "inferred", "self", "ast", "m_unbound", "infer", "meth1", "next", "inferred", "self", "assertisinstance", "meth1", "unboundmethod", "self", "assertequal", "meth1", "name", "meth1", "self", "assertequal", "meth1", "parent", "frame", "name", "c", "self", "assertequal", "meth1", "parent", "frame", "future", "true", "name", "c", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bound_method_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bound_method_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bound_method_inference(self) -> None:\n        inferred = self.ast[\"m_bound\"].infer()\n        meth1 = next(inferred)\n        self.assertIsInstance(meth1, BoundMethod)\n        self.assertEqual(meth1.name, \"meth1\")\n        self.assertEqual(meth1.parent.frame().name, \"C\")\n        self.assertEqual(meth1.parent.frame(future=True).name, \"C\")\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bound_method_inference", "self", "none", "inferred", "self", "ast", "m_bound", "infer", "meth1", "next", "inferred", "self", "assertisinstance", "meth1", "boundmethod", "self", "assertequal", "meth1", "name", "meth1", "self", "assertequal", "meth1", "parent", "frame", "name", "c", "self", "assertequal", "meth1", "parent", "frame", "future", "true", "name", "c", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_args_default_inference1", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_args_default_inference1", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_args_default_inference1(self) -> None:\n        optarg = test_utils.get_name_node(self.ast[\"C\"][\"meth1\"], \"optarg\")\n        inferred = optarg.infer()\n        obj1 = next(inferred)\n        self.assertIsInstance(obj1, nodes.Const)\n        self.assertEqual(obj1.value, 0)\n        obj1 = next(inferred)\n        self.assertIs(obj1, util.Uninferable, obj1)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_args_default_inference1", "self", "none", "optarg", "test_utils", "get_name_node", "self", "ast", "c", "meth1", "optarg", "inferred", "optarg", "infer", "obj1", "next", "inferred", "self", "assertisinstance", "obj1", "nodes", "const", "self", "assertequal", "obj1", "value", "0", "obj1", "next", "inferred", "self", "assertis", "obj1", "util", "uninferable", "obj1", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_args_default_inference2", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_args_default_inference2", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_args_default_inference2(self) -> None:\n        inferred = self.ast[\"C\"][\"meth3\"].ilookup(\"d\")\n        obj1 = next(inferred)\n        self.assertIsInstance(obj1, nodes.Const)\n        self.assertEqual(obj1.value, 4)\n        obj1 = next(inferred)\n        self.assertIs(obj1, util.Uninferable, obj1)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_args_default_inference2", "self", "none", "inferred", "self", "ast", "c", "meth3", "ilookup", "d", "obj1", "next", "inferred", "self", "assertisinstance", "obj1", "nodes", "const", "self", "assertequal", "obj1", "value", "4", "obj1", "next", "inferred", "self", "assertis", "obj1", "util", "uninferable", "obj1", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inference_restrictions", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inference_restrictions", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inference_restrictions(self) -> None:\n        inferred = test_utils.get_name_node(self.ast[\"C\"][\"meth1\"], \"arg1\").infer()\n        obj1 = next(inferred)\n        self.assertIs(obj1, util.Uninferable, obj1)\n        self.assertRaises(StopIteration, partial(next, inferred))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inference_restrictions", "self", "none", "inferred", "test_utils", "get_name_node", "self", "ast", "c", "meth1", "arg1", "infer", "obj1", "next", "inferred", "self", "assertis", "obj1", "util", "uninferable", "obj1", "self", "assertraises", "stopiteration", "partial", "next", "inferred"], "doc_len": 32}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_ancestors_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_ancestors_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_ancestors_inference(self) -> None:\n        code = \"\"\"\n            class A(object):  #@\n                pass\n\n            class A(A):  #@\n                pass\n        \"\"\"\n        a1, a2 = extract_node(code, __name__)\n        a2_ancestors = list(a2.ancestors())\n        self.assertEqual(len(a2_ancestors), 2)\n        self.assertIs(a2_ancestors[0], a1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_ancestors_inference", "self", "none", "code", "class", "a", "object", "pass", "class", "a", "a", "pass", "a1", "a2", "extract_node", "code", "__name__", "a2_ancestors", "list", "a2", "ancestors", "self", "assertequal", "len", "a2_ancestors", "2", "self", "assertis", "a2_ancestors", "0", "a1"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_ancestors_inference2", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_ancestors_inference2", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_ancestors_inference2(self) -> None:\n        code = \"\"\"\n            class A(object):  #@\n                pass\n\n            class B(A):  #@\n                pass\n\n            class A(B):  #@\n                pass\n        \"\"\"\n        a1, b, a2 = extract_node(code, __name__)\n        a2_ancestors = list(a2.ancestors())\n        self.assertEqual(len(a2_ancestors), 3)\n        self.assertIs(a2_ancestors[0], b)\n        self.assertIs(a2_ancestors[1], a1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_ancestors_inference2", "self", "none", "code", "class", "a", "object", "pass", "class", "b", "a", "pass", "class", "a", "b", "pass", "a1", "b", "a2", "extract_node", "code", "__name__", "a2_ancestors", "list", "a2", "ancestors", "self", "assertequal", "len", "a2_ancestors", "3", "self", "assertis", "a2_ancestors", "0", "b", "self", "assertis", "a2_ancestors", "1", "a1"], "doc_len": 46}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_f_arg_f", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_f_arg_f", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_f_arg_f(self) -> None:\n        code = \"\"\"\n            def f(f=1):\n                return f\n\n            a = f()\n        \"\"\"\n        ast = parse(code, __name__)\n        a = ast[\"a\"]\n        a_inferred = a.inferred()\n        self.assertEqual(a_inferred[0].value, 1)\n        self.assertEqual(len(a_inferred), 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_f_arg_f", "self", "none", "code", "def", "f", "f", "1", "return", "f", "a", "f", "ast", "parse", "code", "__name__", "a", "ast", "a", "a_inferred", "a", "inferred", "self", "assertequal", "a_inferred", "0", "value", "1", "self", "assertequal", "len", "a_inferred", "1"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_exc_ancestors", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_exc_ancestors", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_exc_ancestors(self) -> None:\n        code = \"\"\"\n        def f():\n            raise __(NotImplementedError)\n        \"\"\"\n        error = extract_node(code, __name__)\n        nie = error.inferred()[0]\n        self.assertIsInstance(nie, nodes.ClassDef)\n        nie_ancestors = [c.name for c in nie.ancestors()]\n        expected = [\"RuntimeError\", \"Exception\", \"BaseException\", \"object\"]\n        self.assertEqual(nie_ancestors, expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_exc_ancestors", "self", "none", "code", "def", "f", "raise", "__", "notimplementederror", "error", "extract_node", "code", "__name__", "nie", "error", "inferred", "0", "self", "assertisinstance", "nie", "nodes", "classdef", "nie_ancestors", "c", "name", "for", "c", "in", "nie", "ancestors", "expected", "runtimeerror", "exception", "baseexception", "object", "self", "assertequal", "nie_ancestors", "expected"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_except_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_except_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_except_inference(self) -> None:\n        code = \"\"\"\n            try:\n                print (hop)\n            except NameError as ex:\n                ex1 = ex\n            except Exception as ex:\n                ex2 = ex\n                raise\n        \"\"\"\n        ast = parse(code, __name__)\n        ex1 = ast[\"ex1\"]\n        ex1_infer = ex1.infer()\n        ex1 = next(ex1_infer)\n        self.assertIsInstance(ex1, Instance)\n        self.assertEqual(ex1.name, \"NameError\")\n        self.assertRaises(StopIteration, partial(next, ex1_infer))\n        ex2 = ast[\"ex2\"]\n        ex2_infer = ex2.infer()\n        ex2 = next(ex2_infer)\n        self.assertIsInstance(ex2, Instance)\n        self.assertEqual(ex2.name, \"Exception\")\n        self.assertRaises(StopIteration, partial(next, ex2_infer))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_except_inference", "self", "none", "code", "try", "print", "hop", "except", "nameerror", "as", "ex", "ex1", "ex", "except", "exception", "as", "ex", "ex2", "ex", "raise", "ast", "parse", "code", "__name__", "ex1", "ast", "ex1", "ex1_infer", "ex1", "infer", "ex1", "next", "ex1_infer", "self", "assertisinstance", "ex1", "instance", "self", "assertequal", "ex1", "name", "nameerror", "self", "assertraises", "stopiteration", "partial", "next", "ex1_infer", "ex2", "ast", "ex2", "ex2_infer", "ex2", "infer", "ex2", "next", "ex2_infer", "self", "assertisinstance", "ex2", "instance", "self", "assertequal", "ex2", "name", "exception", "self", "assertraises", "stopiteration", "partial", "next", "ex2_infer"], "doc_len": 77}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_del1", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_del1", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_del1(self) -> None:\n        code = \"\"\"\n            del undefined_attr\n        \"\"\"\n        delete = extract_node(code, __name__)\n        self.assertRaises(InferenceError, next, delete.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_del1", "self", "none", "code", "del", "undefined_attr", "delete", "extract_node", "code", "__name__", "self", "assertraises", "inferenceerror", "next", "delete", "infer"], "doc_len": 21}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_del2", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_del2", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_del2(self) -> None:\n        code = \"\"\"\n            a = 1\n            b = a\n            del a\n            c = a\n            a = 2\n            d = a\n        \"\"\"\n        ast = parse(code, __name__)\n        n = ast[\"b\"]\n        n_infer = n.infer()\n        inferred = next(n_infer)\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 1)\n        self.assertRaises(StopIteration, partial(next, n_infer))\n        n = ast[\"c\"]\n        n_infer = n.infer()\n        self.assertRaises(InferenceError, partial(next, n_infer))\n        n = ast[\"d\"]\n        n_infer = n.infer()\n        inferred = next(n_infer)\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 2)\n        self.assertRaises(StopIteration, partial(next, n_infer))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_del2", "self", "none", "code", "a", "1", "b", "a", "del", "a", "c", "a", "a", "2", "d", "a", "ast", "parse", "code", "__name__", "n", "ast", "b", "n_infer", "n", "infer", "inferred", "next", "n_infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "1", "self", "assertraises", "stopiteration", "partial", "next", "n_infer", "n", "ast", "c", "n_infer", "n", "infer", "self", "assertraises", "inferenceerror", "partial", "next", "n_infer", "n", "ast", "d", "n_infer", "n", "infer", "inferred", "next", "n_infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "2", "self", "assertraises", "stopiteration", "partial", "next", "n_infer"], "doc_len": 87}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_builtin_types", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_builtin_types", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_builtin_types(self) -> None:\n        code = \"\"\"\n            l = [1]\n            t = (2,)\n            d = {}\n            s = ''\n            s2 = '_'\n        \"\"\"\n        ast = parse(code, __name__)\n        n = ast[\"l\"]\n        inferred = next(n.infer())\n        self.assertIsInstance(inferred, nodes.List)\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.getitem(nodes.Const(0)).value, 1)\n        self.assertIsInstance(inferred._proxied, nodes.ClassDef)\n        self.assertEqual(inferred._proxied.name, \"list\")\n        self.assertIn(\"append\", inferred._proxied.locals)\n        n = ast[\"t\"]\n        inferred = next(n.infer())\n        self.assertIsInstance(inferred, nodes.Tuple)\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.getitem(nodes.Const(0)).value, 2)\n        self.assertIsInstance(inferred._proxied, nodes.ClassDef)\n        self.assertEqual(inferred._proxied.name, \"tuple\")\n        n = ast[\"d\"]\n        inferred = next(n.infer())\n        self.assertIsInstance(inferred, nodes.Dict)\n        self.assertIsInstance(inferred, Instance)\n        self.assertIsInstance(inferred._proxied, nodes.ClassDef)\n        self.assertEqual(inferred._proxied.name, \"dict\")\n        self.assertIn(\"get\", inferred._proxied.locals)\n        n = ast[\"s\"]\n        inferred = next(n.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"str\")\n        self.assertIn(\"lower\", inferred._proxied.locals)\n        n = ast[\"s2\"]\n        inferred = next(n.infer())\n        self.assertEqual(inferred.getitem(nodes.Const(0)).value, \"_\")\n\n        code = \"s = {1}\"\n        ast = parse(code, __name__)\n        n = ast[\"s\"]\n        inferred = next(n.infer())\n        self.assertIsInstance(inferred, nodes.Set)\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"set\")\n        self.assertIn(\"remove\", inferred._proxied.locals)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_builtin_types", "self", "none", "code", "l", "1", "t", "2", "d", "s", "s2", "_", "ast", "parse", "code", "__name__", "n", "ast", "l", "inferred", "next", "n", "infer", "self", "assertisinstance", "inferred", "nodes", "list", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "getitem", "nodes", "const", "0", "value", "1", "self", "assertisinstance", "inferred", "_proxied", "nodes", "classdef", "self", "assertequal", "inferred", "_proxied", "name", "list", "self", "assertin", "append", "inferred", "_proxied", "locals", "n", "ast", "t", "inferred", "next", "n", "infer", "self", "assertisinstance", "inferred", "nodes", "tuple", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "getitem", "nodes", "const", "0", "value", "2", "self", "assertisinstance", "inferred", "_proxied", "nodes", "classdef", "self", "assertequal", "inferred", "_proxied", "name", "tuple", "n", "ast", "d", "inferred", "next", "n", "infer", "self", "assertisinstance", "inferred", "nodes", "dict", "self", "assertisinstance", "inferred", "instance", "self", "assertisinstance", "inferred", "_proxied", "nodes", "classdef", "self", "assertequal", "inferred", "_proxied", "name", "dict", "self", "assertin", "get", "inferred", "_proxied", "locals", "n", "ast", "s", "inferred", "next", "n", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "str", "self", "assertin", "lower", "inferred", "_proxied", "locals", "n", "ast", "s2", "inferred", "next", "n", "infer", "self", "assertequal", "inferred", "getitem", "nodes", "const", "0", "value", "_", "code", "s", "1", "ast", "parse", "code", "__name__", "n", "ast", "s", "inferred", "next", "n", "infer", "self", "assertisinstance", "inferred", "nodes", "set", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "set", "self", "assertin", "remove", "inferred", "_proxied", "locals"], "doc_len": 212}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_descriptor_are_callable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_descriptor_are_callable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_descriptor_are_callable(self):\n        code = \"\"\"\n            class A:\n                statm = staticmethod(open)\n                clsm = classmethod('whatever')\n        \"\"\"\n        ast = parse(code, __name__)\n        statm = next(ast[\"A\"].igetattr(\"statm\"))\n        self.assertTrue(statm.callable())\n        clsm = next(ast[\"A\"].igetattr(\"clsm\"))\n        self.assertFalse(clsm.callable())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_descriptor_are_callable", "self", "code", "class", "a", "statm", "staticmethod", "open", "clsm", "classmethod", "whatever", "ast", "parse", "code", "__name__", "statm", "next", "ast", "a", "igetattr", "statm", "self", "asserttrue", "statm", "callable", "clsm", "next", "ast", "a", "igetattr", "clsm", "self", "assertfalse", "clsm", "callable"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bt_ancestor_crash", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bt_ancestor_crash", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bt_ancestor_crash(self) -> None:\n        code = \"\"\"\n            class Warning(Warning):\n                pass\n        \"\"\"\n        ast = parse(code, __name__)\n        w = ast[\"Warning\"]\n        ancestors = w.ancestors()\n        ancestor = next(ancestors)\n        self.assertEqual(ancestor.name, \"Warning\")\n        self.assertEqual(ancestor.root().name, EXC_MODULE)\n        ancestor = next(ancestors)\n        self.assertEqual(ancestor.name, \"Exception\")\n        self.assertEqual(ancestor.root().name, EXC_MODULE)\n        ancestor = next(ancestors)\n        self.assertEqual(ancestor.name, \"BaseException\")\n        self.assertEqual(ancestor.root().name, EXC_MODULE)\n        ancestor = next(ancestors)\n        self.assertEqual(ancestor.name, \"object\")\n        self.assertEqual(ancestor.root().name, \"builtins\")\n        self.assertRaises(StopIteration, partial(next, ancestors))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bt_ancestor_crash", "self", "none", "code", "class", "warning", "warning", "pass", "ast", "parse", "code", "__name__", "w", "ast", "warning", "ancestors", "w", "ancestors", "ancestor", "next", "ancestors", "self", "assertequal", "ancestor", "name", "warning", "self", "assertequal", "ancestor", "root", "name", "exc_module", "ancestor", "next", "ancestors", "self", "assertequal", "ancestor", "name", "exception", "self", "assertequal", "ancestor", "root", "name", "exc_module", "ancestor", "next", "ancestors", "self", "assertequal", "ancestor", "name", "baseexception", "self", "assertequal", "ancestor", "root", "name", "exc_module", "ancestor", "next", "ancestors", "self", "assertequal", "ancestor", "name", "object", "self", "assertequal", "ancestor", "root", "name", "builtins", "self", "assertraises", "stopiteration", "partial", "next", "ancestors"], "doc_len": 85}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_method_argument", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_method_argument", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_method_argument(self) -> None:\n        code = '''\n            class ErudiEntitySchema:\n                \"\"\"an entity has a type, a set of subject and or object relations\"\"\"\n                def __init__(self, e_type, **kwargs):\n                    kwargs['e_type'] = e_type.capitalize().encode()\n\n                def meth(self, e_type, *args, **kwargs):\n                    kwargs['e_type'] = e_type.capitalize().encode()\n                    print(args)\n            '''\n        ast = parse(code, __name__)\n        arg = test_utils.get_name_node(ast[\"ErudiEntitySchema\"][\"__init__\"], \"e_type\")\n        self.assertEqual(\n            [n.__class__ for n in arg.infer()], [util.Uninferable.__class__]\n        )\n        arg = test_utils.get_name_node(ast[\"ErudiEntitySchema\"][\"__init__\"], \"kwargs\")\n        self.assertEqual([n.__class__ for n in arg.infer()], [nodes.Dict])\n        arg = test_utils.get_name_node(ast[\"ErudiEntitySchema\"][\"meth\"], \"e_type\")\n        self.assertEqual(\n            [n.__class__ for n in arg.infer()], [util.Uninferable.__class__]\n        )\n        arg = test_utils.get_name_node(ast[\"ErudiEntitySchema\"][\"meth\"], \"args\")\n        self.assertEqual([n.__class__ for n in arg.infer()], [nodes.Tuple])\n        arg = test_utils.get_name_node(ast[\"ErudiEntitySchema\"][\"meth\"], \"kwargs\")\n        self.assertEqual([n.__class__ for n in arg.infer()], [nodes.Dict])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_method_argument", "self", "none", "code", "class", "erudientityschema", "an", "entity", "has", "a", "type", "a", "set", "of", "subject", "and", "or", "object", "relations", "def", "__init__", "self", "e_type", "kwargs", "kwargs", "e_type", "e_type", "capitalize", "encode", "def", "meth", "self", "e_type", "args", "kwargs", "kwargs", "e_type", "e_type", "capitalize", "encode", "print", "args", "ast", "parse", "code", "__name__", "arg", "test_utils", "get_name_node", "ast", "erudientityschema", "__init__", "e_type", "self", "assertequal", "n", "__class__", "for", "n", "in", "arg", "infer", "util", "uninferable", "__class__", "arg", "test_utils", "get_name_node", "ast", "erudientityschema", "__init__", "kwargs", "self", "assertequal", "n", "__class__", "for", "n", "in", "arg", "infer", "nodes", "dict", "arg", "test_utils", "get_name_node", "ast", "erudientityschema", "meth", "e_type", "self", "assertequal", "n", "__class__", "for", "n", "in", "arg", "infer", "util", "uninferable", "__class__", "arg", "test_utils", "get_name_node", "ast", "erudientityschema", "meth", "args", "self", "assertequal", "n", "__class__", "for", "n", "in", "arg", "infer", "nodes", "tuple", "arg", "test_utils", "get_name_node", "ast", "erudientityschema", "meth", "kwargs", "self", "assertequal", "n", "__class__", "for", "n", "in", "arg", "infer", "nodes", "dict"], "doc_len": 143}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_tuple_then_list", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_tuple_then_list", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_tuple_then_list(self) -> None:\n        code = \"\"\"\n            def test_view(rql, vid, tags=()):\n                tags = list(tags)\n                __(tags).append(vid)\n        \"\"\"\n        name = extract_node(code, __name__)\n        it = name.infer()\n        tags = next(it)\n        self.assertIsInstance(tags, nodes.List)\n        self.assertEqual(tags.elts, [])\n        with self.assertRaises(StopIteration):\n            next(it)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_tuple_then_list", "self", "none", "code", "def", "test_view", "rql", "vid", "tags", "tags", "list", "tags", "__", "tags", "append", "vid", "name", "extract_node", "code", "__name__", "it", "name", "infer", "tags", "next", "it", "self", "assertisinstance", "tags", "nodes", "list", "self", "assertequal", "tags", "elts", "with", "self", "assertraises", "stopiteration", "next", "it"], "doc_len": 46}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_mulassign_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_mulassign_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_mulassign_inference(self) -> None:\n        code = '''\n            def first_word(line):\n                \"\"\"Return the first word of a line\"\"\"\n\n                return line.split()[0]\n\n            def last_word(line):\n                \"\"\"Return last word of a line\"\"\"\n\n                return line.split()[-1]\n\n            def process_line(word_pos):\n                \"\"\"Silly function: returns (ok, callable) based on argument.\n\n                   For test purpose only.\n                \"\"\"\n\n                if word_pos > 0:\n                    return (True, first_word)\n                elif word_pos < 0:\n                    return  (True, last_word)\n                else:\n                    return (False, None)\n\n            if __name__ == '__main__':\n\n                line_number = 0\n                for a_line in file('test_callable.py'):\n                    tupletest  = process_line(line_number)\n                    (ok, fct)  = process_line(line_number)\n                    if ok:\n                        fct(a_line)\n        '''\n        ast = parse(code, __name__)\n        self.assertEqual(len(list(ast[\"process_line\"].infer_call_result(None))), 3)\n        self.assertEqual(len(list(ast[\"tupletest\"].infer())), 3)\n        values = [\n            \"<FunctionDef.first_word\",\n            \"<FunctionDef.last_word\",\n            \"<Const.NoneType\",\n        ]\n        self.assertTrue(\n            all(\n                repr(inferred).startswith(value)\n                for inferred, value in zip(ast[\"fct\"].infer(), values)\n            )\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_mulassign_inference", "self", "none", "code", "def", "first_word", "line", "return", "the", "first", "word", "of", "a", "line", "return", "line", "split", "0", "def", "last_word", "line", "return", "last", "word", "of", "a", "line", "return", "line", "split", "1", "def", "process_line", "word_pos", "silly", "function", "returns", "ok", "callable", "based", "on", "argument", "for", "test", "purpose", "only", "if", "word_pos", "0", "return", "true", "first_word", "elif", "word_pos", "0", "return", "true", "last_word", "else", "return", "false", "none", "if", "__name__", "__main__", "line_number", "0", "for", "a_line", "in", "file", "test_callable", "py", "tupletest", "process_line", "line_number", "ok", "fct", "process_line", "line_number", "if", "ok", "fct", "a_line", "ast", "parse", "code", "__name__", "self", "assertequal", "len", "list", "ast", "process_line", "infer_call_result", "none", "3", "self", "assertequal", "len", "list", "ast", "tupletest", "infer", "3", "values", "functiondef", "first_word", "functiondef", "last_word", "const", "nonetype", "self", "asserttrue", "all", "repr", "inferred", "startswith", "value", "for", "inferred", "value", "in", "zip", "ast", "fct", "infer", "values"], "doc_len": 133}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_float_complex_ambiguity", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_float_complex_ambiguity", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_float_complex_ambiguity(self) -> None:\n        code = '''\n            def no_conjugate_member(magic_flag):  #@\n                \"\"\"should not raise E1101 on something.conjugate\"\"\"\n                if magic_flag:\n                    something = 1.0\n                else:\n                    something = 1.0j\n                if isinstance(something, float):\n                    return something\n                return __(something).conjugate()\n        '''\n        func, retval = extract_node(code, __name__)\n        self.assertEqual([i.value for i in func.ilookup(\"something\")], [1.0, 1.0j])\n        self.assertEqual([i.value for i in retval.infer()], [1.0, 1.0j])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_float_complex_ambiguity", "self", "none", "code", "def", "no_conjugate_member", "magic_flag", "should", "not", "raise", "e1101", "on", "something", "conjugate", "if", "magic_flag", "something", "1", "0", "else", "something", "1", "0j", "if", "isinstance", "something", "float", "return", "something", "return", "__", "something", "conjugate", "func", "retval", "extract_node", "code", "__name__", "self", "assertequal", "i", "value", "for", "i", "in", "func", "ilookup", "something", "1", "0", "1", "0j", "self", "assertequal", "i", "value", "for", "i", "in", "retval", "infer", "1", "0", "1", "0j"], "doc_len": 70}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_lookup_cond_branches", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_lookup_cond_branches", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_lookup_cond_branches(self) -> None:\n        code = '''\n            def no_conjugate_member(magic_flag):\n                \"\"\"should not raise E1101 on something.conjugate\"\"\"\n                something = 1.0\n                if magic_flag:\n                    something = 1.0j\n                return something.conjugate()\n        '''\n        ast = parse(code, __name__)\n        values = [\n            i.value for i in test_utils.get_name_node(ast, \"something\", -1).infer()\n        ]\n        self.assertEqual(values, [1.0, 1.0j])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_lookup_cond_branches", "self", "none", "code", "def", "no_conjugate_member", "magic_flag", "should", "not", "raise", "e1101", "on", "something", "conjugate", "something", "1", "0", "if", "magic_flag", "something", "1", "0j", "return", "something", "conjugate", "ast", "parse", "code", "__name__", "values", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "something", "1", "infer", "self", "assertequal", "values", "1", "0", "1", "0j"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_simple_subscript", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_simple_subscript", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_simple_subscript(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def __getitem__(self, index):\n                    return index + 42\n            [1, 2, 3][0] #@\n            (1, 2, 3)[1] #@\n            (1, 2, 3)[-1] #@\n            [1, 2, 3][0] + (2, )[0] + (3, )[-1] #@\n            e = {'key': 'value'}\n            e['key'] #@\n            \"first\"[0] #@\n            list([1, 2, 3])[-1] #@\n            tuple((4, 5, 6))[2] #@\n            A()[0] #@\n            A()[-1] #@\n        \"\"\"\n        ast_nodes = extract_node(code, __name__)\n        expected = [1, 2, 3, 6, \"value\", \"f\", 3, 6, 42, 41]\n        for node, expected_value in zip(ast_nodes, expected):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_simple_subscript", "self", "none", "code", "class", "a", "object", "def", "__getitem__", "self", "index", "return", "index", "42", "1", "2", "3", "0", "1", "2", "3", "1", "1", "2", "3", "1", "1", "2", "3", "0", "2", "0", "3", "1", "e", "key", "value", "e", "key", "first", "0", "list", "1", "2", "3", "1", "tuple", "4", "5", "6", "2", "a", "0", "a", "1", "ast_nodes", "extract_node", "code", "__name__", "expected", "1", "2", "3", "6", "value", "f", "3", "6", "42", "41", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 96}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_invalid_subscripts", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_invalid_subscripts", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_invalid_subscripts(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class NoGetitem(object):\n            pass\n        class InvalidGetitem(object):\n            def __getitem__(self): pass\n        class InvalidGetitem2(object):\n            __getitem__ = 42\n        NoGetitem()[4] #@\n        InvalidGetitem()[5] #@\n        InvalidGetitem2()[10] #@\n        [1, 2, 3][None] #@\n        'lala'['bala'] #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_invalid_subscripts", "self", "none", "ast_nodes", "extract_node", "class", "nogetitem", "object", "pass", "class", "invalidgetitem", "object", "def", "__getitem__", "self", "pass", "class", "invalidgetitem2", "object", "__getitem__", "42", "nogetitem", "4", "invalidgetitem", "5", "invalidgetitem2", "10", "1", "2", "3", "none", "lala", "bala", "for", "node", "in", "ast_nodes", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bytes_subscript", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bytes_subscript", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bytes_subscript(self) -> None:\n        node = extract_node(\"\"\"b'a'[0]\"\"\")\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 97)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bytes_subscript", "self", "none", "node", "extract_node", "b", "a", "0", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "97"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_subscript_multi_value", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_subscript_multi_value", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_subscript_multi_value(self) -> None:\n        code = \"\"\"\n            def do_thing_with_subscript(magic_flag):\n                src = [3, 2, 1]\n                if magic_flag:\n                    src = [1, 2, 3]\n                something = src[0]\n                return something\n        \"\"\"\n        ast = parse(code, __name__)\n        values = [\n            i.value for i in test_utils.get_name_node(ast, \"something\", -1).infer()\n        ]\n        self.assertEqual(list(sorted(values)), [1, 3])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_subscript_multi_value", "self", "none", "code", "def", "do_thing_with_subscript", "magic_flag", "src", "3", "2", "1", "if", "magic_flag", "src", "1", "2", "3", "something", "src", "0", "return", "something", "ast", "parse", "code", "__name__", "values", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "something", "1", "infer", "self", "assertequal", "list", "sorted", "values", "1", "3"], "doc_len": 50}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_subscript_multi_slice", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_subscript_multi_slice", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_subscript_multi_slice(self) -> None:\n        code = \"\"\"\n            def zero_or_one(magic_flag):\n                if magic_flag:\n                    return 1\n                return 0\n\n            def do_thing_with_subscript(magic_flag):\n                src = [3, 2, 1]\n                index = zero_or_one(magic_flag)\n                something = src[index]\n                return something\n        \"\"\"\n        ast = parse(code, __name__)\n        values = [\n            i.value for i in test_utils.get_name_node(ast, \"something\", -1).infer()\n        ]\n        self.assertEqual(list(sorted(values)), [2, 3])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_subscript_multi_slice", "self", "none", "code", "def", "zero_or_one", "magic_flag", "if", "magic_flag", "return", "1", "return", "0", "def", "do_thing_with_subscript", "magic_flag", "src", "3", "2", "1", "index", "zero_or_one", "magic_flag", "something", "src", "index", "return", "something", "ast", "parse", "code", "__name__", "values", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "something", "1", "infer", "self", "assertequal", "list", "sorted", "values", "2", "3"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_simple_tuple", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_simple_tuple", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_simple_tuple(self) -> None:\n        module = parse(\n            \"\"\"\n        a = (1,)\n        b = (22,)\n        some = a + b #@\n        \"\"\"\n        )\n        ast = next(module[\"some\"].infer())\n        self.assertIsInstance(ast, nodes.Tuple)\n        self.assertEqual(len(ast.elts), 2)\n        self.assertEqual(ast.elts[0].value, 1)\n        self.assertEqual(ast.elts[1].value, 22)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_simple_tuple", "self", "none", "module", "parse", "a", "1", "b", "22", "some", "a", "b", "ast", "next", "module", "some", "infer", "self", "assertisinstance", "ast", "nodes", "tuple", "self", "assertequal", "len", "ast", "elts", "2", "self", "assertequal", "ast", "elts", "0", "value", "1", "self", "assertequal", "ast", "elts", "1", "value", "22"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_simple_for", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_simple_for", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_simple_for(self) -> None:\n        code = \"\"\"\n            for a in [1, 2, 3]:\n                print (a)\n            for b,c in [(1,2), (3,4)]:\n                print (b)\n                print (c)\n\n            print ([(d,e) for e,d in ([1,2], [3,4])])\n        \"\"\"\n        ast = parse(code, __name__)\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"a\", -1).infer()], [1, 2, 3]\n        )\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"b\", -1).infer()], [1, 3]\n        )\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"c\", -1).infer()], [2, 4]\n        )\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"d\", -1).infer()], [2, 4]\n        )\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"e\", -1).infer()], [1, 3]\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_simple_for", "self", "none", "code", "for", "a", "in", "1", "2", "3", "print", "a", "for", "b", "c", "in", "1", "2", "3", "4", "print", "b", "print", "c", "print", "d", "e", "for", "e", "d", "in", "1", "2", "3", "4", "ast", "parse", "code", "__name__", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "a", "1", "infer", "1", "2", "3", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "b", "1", "infer", "1", "3", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "c", "1", "infer", "2", "4", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "d", "1", "infer", "2", "4", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "e", "1", "infer", "1", "3"], "doc_len": 120}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_simple_for_genexpr", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_simple_for_genexpr", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_simple_for_genexpr(self) -> None:\n        code = \"\"\"\n            print ((d,e) for e,d in ([1,2], [3,4]))\n        \"\"\"\n        ast = parse(code, __name__)\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"d\", -1).infer()], [2, 4]\n        )\n        self.assertEqual(\n            [i.value for i in test_utils.get_name_node(ast, \"e\", -1).infer()], [1, 3]\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_simple_for_genexpr", "self", "none", "code", "print", "d", "e", "for", "e", "d", "in", "1", "2", "3", "4", "ast", "parse", "code", "__name__", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "d", "1", "infer", "2", "4", "self", "assertequal", "i", "value", "for", "i", "in", "test_utils", "get_name_node", "ast", "e", "1", "infer", "1", "3"], "doc_len": 54}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_builtin_help", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_builtin_help", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_builtin_help(self) -> None:\n        code = \"\"\"\n            help()\n        \"\"\"\n        # XXX failing since __builtin__.help assignment has\n        #     been moved into a function...\n        node = extract_node(code, __name__)\n        inferred = list(node.func.infer())\n        self.assertEqual(len(inferred), 1, inferred)\n        self.assertIsInstance(inferred[0], Instance)\n        self.assertEqual(inferred[0].name, \"_Helper\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_builtin_help", "self", "none", "code", "help", "xxx", "failing", "since", "__builtin__", "help", "assignment", "has", "been", "moved", "into", "a", "function", "node", "extract_node", "code", "__name__", "inferred", "list", "node", "func", "infer", "self", "assertequal", "len", "inferred", "1", "inferred", "self", "assertisinstance", "inferred", "0", "instance", "self", "assertequal", "inferred", "0", "name", "_helper"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_builtin_open", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_builtin_open", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_builtin_open(self) -> None:\n        code = \"\"\"\n            open(\"toto.txt\")\n        \"\"\"\n        node = extract_node(code, __name__).func\n        inferred = list(node.infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.FunctionDef)\n        self.assertEqual(inferred[0].name, \"open\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_builtin_open", "self", "none", "code", "open", "toto", "txt", "node", "extract_node", "code", "__name__", "func", "inferred", "list", "node", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "functiondef", "self", "assertequal", "inferred", "0", "name", "open"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_callfunc_context_func", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_callfunc_context_func", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_callfunc_context_func(self) -> None:\n        code = \"\"\"\n            def mirror(arg=None):\n                return arg\n\n            un = mirror(1)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast.igetattr(\"un\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Const)\n        self.assertEqual(inferred[0].value, 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_callfunc_context_func", "self", "none", "code", "def", "mirror", "arg", "none", "return", "arg", "un", "mirror", "1", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "igetattr", "un", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "const", "self", "assertequal", "inferred", "0", "value", "1"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_callfunc_context_lambda", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_callfunc_context_lambda", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_callfunc_context_lambda(self) -> None:\n        code = \"\"\"\n            mirror = lambda x=None: x\n\n            un = mirror(1)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast.igetattr(\"mirror\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Lambda)\n        inferred = list(ast.igetattr(\"un\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Const)\n        self.assertEqual(inferred[0].value, 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_callfunc_context_lambda", "self", "none", "code", "mirror", "lambda", "x", "none", "x", "un", "mirror", "1", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "igetattr", "mirror", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "lambda", "inferred", "list", "ast", "igetattr", "un", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "const", "self", "assertequal", "inferred", "0", "value", "1"], "doc_len": 59}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_factory_method", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_factory_method", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_factory_method(self) -> None:\n        code = \"\"\"\n            class Super(object):\n                  @classmethod\n                  def instance(cls):\n                          return cls()\n\n            class Sub(Super):\n                  def method(self):\n                          print ('method called')\n\n            sub = Sub.instance()\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast.igetattr(\"sub\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], Instance)\n        self.assertEqual(inferred[0]._proxied.name, \"Sub\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_factory_method", "self", "none", "code", "class", "super", "object", "classmethod", "def", "instance", "cls", "return", "cls", "class", "sub", "super", "def", "method", "self", "print", "method", "called", "sub", "sub", "instance", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "igetattr", "sub", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "instance", "self", "assertequal", "inferred", "0", "_proxied", "name", "sub"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_factory_methods_cls_call", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_factory_methods_cls_call", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_factory_methods_cls_call(self) -> None:\n        ast = extract_node(\n            \"\"\"\n        class C:\n            @classmethod\n            def factory(cls):\n                return cls()\n\n        class D(C):\n            pass\n\n        C.factory() #@\n        D.factory() #@\n        \"\"\",\n            \"module\",\n        )\n        should_be_c = list(ast[0].infer())\n        should_be_d = list(ast[1].infer())\n        self.assertEqual(1, len(should_be_c))\n        self.assertEqual(1, len(should_be_d))\n        self.assertEqual(\"module.C\", should_be_c[0].qname())\n        self.assertEqual(\"module.D\", should_be_d[0].qname())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_factory_methods_cls_call", "self", "none", "ast", "extract_node", "class", "c", "classmethod", "def", "factory", "cls", "return", "cls", "class", "d", "c", "pass", "c", "factory", "d", "factory", "module", "should_be_c", "list", "ast", "0", "infer", "should_be_d", "list", "ast", "1", "infer", "self", "assertequal", "1", "len", "should_be_c", "self", "assertequal", "1", "len", "should_be_d", "self", "assertequal", "module", "c", "should_be_c", "0", "qname", "self", "assertequal", "module", "d", "should_be_d", "0", "qname"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_factory_methods_object_new_call", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_factory_methods_object_new_call", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_factory_methods_object_new_call(self) -> None:\n        ast = extract_node(\n            \"\"\"\n        class C:\n            @classmethod\n            def factory(cls):\n                return object.__new__(cls)\n\n        class D(C):\n            pass\n\n        C.factory() #@\n        D.factory() #@\n        \"\"\",\n            \"module\",\n        )\n        should_be_c = list(ast[0].infer())\n        should_be_d = list(ast[1].infer())\n        self.assertEqual(1, len(should_be_c))\n        self.assertEqual(1, len(should_be_d))\n        self.assertEqual(\"module.C\", should_be_c[0].qname())\n        self.assertEqual(\"module.D\", should_be_d[0].qname())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_factory_methods_object_new_call", "self", "none", "ast", "extract_node", "class", "c", "classmethod", "def", "factory", "cls", "return", "object", "__new__", "cls", "class", "d", "c", "pass", "c", "factory", "d", "factory", "module", "should_be_c", "list", "ast", "0", "infer", "should_be_d", "list", "ast", "1", "infer", "self", "assertequal", "1", "len", "should_be_c", "self", "assertequal", "1", "len", "should_be_d", "self", "assertequal", "module", "c", "should_be_c", "0", "qname", "self", "assertequal", "module", "d", "should_be_d", "0", "qname"], "doc_len": 63}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_factory_methods_inside_binary_operation", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_factory_methods_inside_binary_operation", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_factory_methods_inside_binary_operation(self):\n        node = extract_node(\n            \"\"\"\n        from pathlib import Path\n        h = Path(\"/home\")\n        u = h / \"user\"\n        u #@\n        \"\"\"\n        )\n        assert next(node.infer()).qname() == \"pathlib.Path\"\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_factory_methods_inside_binary_operation", "self", "node", "extract_node", "from", "pathlib", "import", "path", "h", "path", "home", "u", "h", "user", "u", "assert", "next", "node", "infer", "qname", "pathlib", "path"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_import_as", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_import_as", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_import_as(self) -> None:\n        code = \"\"\"\n            import os.path as osp\n            print (osp.dirname(__file__))\n\n            from os.path import exists as e\n            assert e(__file__)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast.igetattr(\"osp\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Module)\n        self.assertEqual(inferred[0].name, \"os.path\")\n        inferred = list(ast.igetattr(\"e\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.FunctionDef)\n        self.assertEqual(inferred[0].name, \"exists\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_import_as", "self", "none", "code", "import", "os", "path", "as", "osp", "print", "osp", "dirname", "__file__", "from", "os", "path", "import", "exists", "as", "e", "assert", "e", "__file__", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "igetattr", "osp", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "module", "self", "assertequal", "inferred", "0", "name", "os", "path", "inferred", "list", "ast", "igetattr", "e", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "functiondef", "self", "assertequal", "inferred", "0", "name", "exists"], "doc_len": 77}
{"doc_id": "tests/unittest_inference.py::InferenceTest._test_const_inferred", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "_test_const_inferred", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def _test_const_inferred(\n        self, node: nodes.AssignName, value: Union[float, str]\n    ) -> None:\n        inferred = list(node.infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Const)\n        self.assertEqual(inferred[0].value, value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "_test_const_inferred", "self", "node", "nodes", "assignname", "value", "union", "float", "str", "none", "inferred", "list", "node", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "const", "self", "assertequal", "inferred", "0", "value", "value"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_not", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_not", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_not(self) -> None:\n        for code in (\n            \"a = not (1,); b = not ()\",\n            \"a = not {1:2}; b = not {}\",\n            \"a = not [1, 2]; b = not []\",\n            \"a = not {1, 2}; b = not set()\",\n            \"a = not 1; b = not 0\",\n            'a = not \"a\"; b = not \"\"',\n            'a = not b\"a\"; b = not b\"\"',\n        ):\n            ast = builder.string_build(code, __name__, __file__)\n            self._test_const_inferred(ast[\"a\"], False)\n            self._test_const_inferred(ast[\"b\"], True)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_not", "self", "none", "for", "code", "in", "a", "not", "1", "b", "not", "a", "not", "1", "2", "b", "not", "a", "not", "1", "2", "b", "not", "a", "not", "1", "2", "b", "not", "set", "a", "not", "1", "b", "not", "0", "a", "not", "a", "b", "not", "a", "not", "b", "a", "b", "not", "b", "ast", "builder", "string_build", "code", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "false", "self", "_test_const_inferred", "ast", "b", "true"], "doc_len": 69}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_numbers", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_numbers", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_numbers(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        +1 #@\n        -1 #@\n        ~1 #@\n        +2.0 #@\n        -2.0 #@\n        \"\"\"\n        )\n        expected = [1, -1, -2, 2.0, -2.0]\n        for node, expected_value in zip(ast_nodes, expected):\n            inferred = next(node.infer())\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_numbers", "self", "none", "ast_nodes", "extract_node", "1", "1", "1", "2", "0", "2", "0", "expected", "1", "1", "2", "2", "0", "2", "0", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_matmul", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_matmul", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_matmul(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Array:\n            def __matmul__(self, other):\n                return 42\n        Array() @ Array() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_matmul", "self", "none", "node", "extract_node", "class", "array", "def", "__matmul__", "self", "other", "return", "42", "array", "array", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_add", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_add", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_add(self) -> None:\n        ast = builder.string_build(\"a = 1 + 2\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 3)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_add", "self", "none", "ast", "builder", "string_build", "a", "1", "2", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "3"], "doc_len": 21}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_sub", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_sub", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_sub(self) -> None:\n        ast = builder.string_build(\"a = 1 - 2\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], -1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_sub", "self", "none", "ast", "builder", "string_build", "a", "1", "2", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "1"], "doc_len": 21}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_float_div", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_float_div", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_float_div(self) -> None:\n        ast = builder.string_build(\"a = 1 / 2.\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 1 / 2.0)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_float_div", "self", "none", "ast", "builder", "string_build", "a", "1", "2", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "1", "2", "0"], "doc_len": 23}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_str_mul", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_str_mul", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_str_mul(self) -> None:\n        ast = builder.string_build('a = \"*\" * 40', __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], \"*\" * 40)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_str_mul", "self", "none", "ast", "builder", "string_build", "a", "40", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "40"], "doc_len": 20}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_bitand", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_bitand", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_bitand(self) -> None:\n        ast = builder.string_build(\"a = 23&20\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 23 & 20)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_bitand", "self", "none", "ast", "builder", "string_build", "a", "23", "20", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "23", "20"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_bitor", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_bitor", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_bitor(self) -> None:\n        ast = builder.string_build(\"a = 23|8\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 23 | 8)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_bitor", "self", "none", "ast", "builder", "string_build", "a", "23", "8", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "23", "8"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_bitxor", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_bitxor", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_bitxor(self) -> None:\n        ast = builder.string_build(\"a = 23^9\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 23 ^ 9)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_bitxor", "self", "none", "ast", "builder", "string_build", "a", "23", "9", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "23", "9"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_shiftright", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_shiftright", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_shiftright(self) -> None:\n        ast = builder.string_build(\"a = 23 >>1\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 23 >> 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_shiftright", "self", "none", "ast", "builder", "string_build", "a", "23", "1", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "23", "1"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_int_shiftleft", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_int_shiftleft", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_int_shiftleft(self) -> None:\n        ast = builder.string_build(\"a = 23 <<1\", __name__, __file__)\n        self._test_const_inferred(ast[\"a\"], 23 << 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_int_shiftleft", "self", "none", "ast", "builder", "string_build", "a", "23", "1", "__name__", "__file__", "self", "_test_const_inferred", "ast", "a", "23", "1"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_other_type", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_other_type", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_other_type(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A:\n            def __add__(self, other):\n                return other + 42\n        A() + 1 #@\n        1 + A() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.Const)\n        self.assertEqual(first.value, 43)\n\n        second = next(ast_nodes[1].infer())\n        self.assertEqual(second, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_other_type", "self", "none", "ast_nodes", "extract_node", "class", "a", "def", "__add__", "self", "other", "return", "other", "42", "a", "1", "1", "a", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "const", "self", "assertequal", "first", "value", "43", "second", "next", "ast_nodes", "1", "infer", "self", "assertequal", "second", "util", "uninferable"], "doc_len": 52}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_other_type_using_reflected_operands", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_other_type_using_reflected_operands", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_other_type_using_reflected_operands(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def __radd__(self, other):\n                return other + 42\n        A() + 1 #@\n        1 + A() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertEqual(first, util.Uninferable)\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, nodes.Const)\n        self.assertEqual(second.value, 43)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_other_type_using_reflected_operands", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "__radd__", "self", "other", "return", "other", "42", "a", "1", "1", "a", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertequal", "first", "util", "uninferable", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "nodes", "const", "self", "assertequal", "second", "value", "43"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_reflected_and_not_implemented_is_type_error", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_reflected_and_not_implemented_is_type_error", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_reflected_and_not_implemented_is_type_error(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __radd__(self, other): return NotImplemented\n\n        1 + A() #@\n        \"\"\"\n        )\n        first = next(ast_node.infer())\n        self.assertEqual(first, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_reflected_and_not_implemented_is_type_error", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__radd__", "self", "other", "return", "notimplemented", "1", "a", "first", "next", "ast_node", "infer", "self", "assertequal", "first", "util", "uninferable"], "doc_len": 30}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_list_mul", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_list_mul", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_list_mul(self) -> None:\n        for code in (\"a = [[]] * 2\", \"a = 2 * [[]]\"):\n            ast = builder.string_build(code, __name__, __file__)\n            inferred = list(ast[\"a\"].infer())\n            self.assertEqual(len(inferred), 1)\n            self.assertIsInstance(inferred[0], nodes.List)\n            self.assertEqual(len(inferred[0].elts), 2)\n            self.assertIsInstance(inferred[0].elts[0], nodes.List)\n            self.assertIsInstance(inferred[0].elts[1], nodes.List)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_list_mul", "self", "none", "for", "code", "in", "a", "2", "a", "2", "ast", "builder", "string_build", "code", "__name__", "__file__", "inferred", "list", "ast", "a", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "list", "self", "assertequal", "len", "inferred", "0", "elts", "2", "self", "assertisinstance", "inferred", "0", "elts", "0", "nodes", "list", "self", "assertisinstance", "inferred", "0", "elts", "1", "nodes", "list"], "doc_len": 60}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_list_mul_none", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_list_mul_none", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_list_mul_none(self) -> None:\n        \"test correct handling on list multiplied by None\"\n        ast = builder.string_build('a = [1] * None\\nb = [1] * \"r\"')\n        inferred = ast[\"a\"].inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertEqual(inferred[0], util.Uninferable)\n        inferred = ast[\"b\"].inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertEqual(inferred[0], util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_list_mul_none", "self", "none", "test", "correct", "handling", "on", "list", "multiplied", "by", "none", "ast", "builder", "string_build", "a", "1", "none", "nb", "1", "r", "inferred", "ast", "a", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertequal", "inferred", "0", "util", "uninferable", "inferred", "ast", "b", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertequal", "inferred", "0", "util", "uninferable"], "doc_len": 55}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_list_mul_int", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_list_mul_int", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_list_mul_int(self) -> None:\n        \"test correct handling on list multiplied by int when there are more than one\"\n        code = \"\"\"\n        from ctypes import c_int\n        seq = [c_int()] * 4\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = ast[\"seq\"].inferred()\n        self.assertEqual(len(inferred), 1)\n        listval = inferred[0]\n        self.assertIsInstance(listval, nodes.List)\n        self.assertEqual(len(listval.itered()), 4)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_list_mul_int", "self", "none", "test", "correct", "handling", "on", "list", "multiplied", "by", "int", "when", "there", "are", "more", "than", "one", "code", "from", "ctypes", "import", "c_int", "seq", "c_int", "4", "ast", "parse", "code", "__name__", "inferred", "ast", "seq", "inferred", "self", "assertequal", "len", "inferred", "1", "listval", "inferred", "0", "self", "assertisinstance", "listval", "nodes", "list", "self", "assertequal", "len", "listval", "itered", "4"], "doc_len": 57}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_on_self", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_on_self", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_on_self(self) -> None:\n        \"test correct handling of applying binary operator to self\"\n        code = \"\"\"\n        import sys\n        sys.path = ['foo'] + sys.path\n        sys.path.insert(0, 'bar')\n        path = sys.path\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = ast[\"path\"].inferred()\n        self.assertIsInstance(inferred[0], nodes.List)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_on_self", "self", "none", "test", "correct", "handling", "of", "applying", "binary", "operator", "to", "self", "code", "import", "sys", "sys", "path", "foo", "sys", "path", "sys", "path", "insert", "0", "bar", "path", "sys", "path", "ast", "parse", "code", "__name__", "inferred", "ast", "path", "inferred", "self", "assertisinstance", "inferred", "0", "nodes", "list"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_tuple_add", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_tuple_add", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_tuple_add(self) -> None:\n        ast = builder.string_build(\"a = (1,) + (2,)\", __name__, __file__)\n        inferred = list(ast[\"a\"].infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Tuple)\n        self.assertEqual(len(inferred[0].elts), 2)\n        self.assertEqual(inferred[0].elts[0].value, 1)\n        self.assertEqual(inferred[0].elts[1].value, 2)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_tuple_add", "self", "none", "ast", "builder", "string_build", "a", "1", "2", "__name__", "__file__", "inferred", "list", "ast", "a", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "tuple", "self", "assertequal", "len", "inferred", "0", "elts", "2", "self", "assertequal", "inferred", "0", "elts", "0", "value", "1", "self", "assertequal", "inferred", "0", "elts", "1", "value", "2"], "doc_len": 55}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_custom_class", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_custom_class", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_custom_class(self) -> None:\n        code = \"\"\"\n        class myarray:\n            def __init__(self, array):\n                self.array = array\n            def __mul__(self, x):\n                return myarray([2,4,6])\n            def astype(self):\n                return \"ASTYPE\"\n\n        def randint(maximum):\n            if maximum is not None:\n                return myarray([1,2,3]) * 2\n            else:\n                return int(5)\n\n        x = randint(1)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast.igetattr(\"x\"))\n        self.assertEqual(len(inferred), 2)\n        value = [str(v) for v in inferred]\n        # The __name__ trick here makes it work when invoked directly\n        # (__name__ == '__main__') and through pytest (__name__ ==\n        # 'unittest_inference')\n        self.assertEqual(\n            value,\n            [\n                f\"Instance of {__name__}.myarray\",\n                \"Const.int(value=5,\\n          kind=None)\",\n            ],\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_custom_class", "self", "none", "code", "class", "myarray", "def", "__init__", "self", "array", "self", "array", "array", "def", "__mul__", "self", "x", "return", "myarray", "2", "4", "6", "def", "astype", "self", "return", "astype", "def", "randint", "maximum", "if", "maximum", "is", "not", "none", "return", "myarray", "1", "2", "3", "2", "else", "return", "int", "5", "x", "randint", "1", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "igetattr", "x", "self", "assertequal", "len", "inferred", "2", "value", "str", "v", "for", "v", "in", "inferred", "the", "__name__", "trick", "here", "makes", "it", "work", "when", "invoked", "directly", "__name__", "__main__", "and", "through", "pytest", "__name__", "unittest_inference", "self", "assertequal", "value", "f", "instance", "of", "__name__", "myarray", "const", "int", "value", "5", "n", "kind", "none"], "doc_len": 106}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_lambda_arg", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_lambda_arg", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_lambda_arg(self) -> None:\n        code = \"\"\"\n        def f(g = lambda: None):\n                __(g()).x\n\"\"\"\n        callfuncnode = extract_node(code)\n        inferred = list(callfuncnode.infer())\n        self.assertEqual(len(inferred), 2, inferred)\n        inferred.remove(util.Uninferable)\n        self.assertIsInstance(inferred[0], nodes.Const)\n        self.assertIsNone(inferred[0].value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_lambda_arg", "self", "none", "code", "def", "f", "g", "lambda", "none", "__", "g", "x", "callfuncnode", "extract_node", "code", "inferred", "list", "callfuncnode", "infer", "self", "assertequal", "len", "inferred", "2", "inferred", "inferred", "remove", "util", "uninferable", "self", "assertisinstance", "inferred", "0", "nodes", "const", "self", "assertisnone", "inferred", "0", "value"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_getitem_empty_tuple", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_getitem_empty_tuple", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_getitem_empty_tuple(self) -> None:\n        code = \"\"\"\n            def f(x):\n                a = ()[x]\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(ast[\"f\"].ilookup(\"a\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertEqual(inferred[0], util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_getitem_empty_tuple", "self", "none", "code", "def", "f", "x", "a", "x", "ast", "parse", "code", "__name__", "inferred", "list", "ast", "f", "ilookup", "a", "self", "assertequal", "len", "inferred", "1", "self", "assertequal", "inferred", "0", "util", "uninferable"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_instance_attrs", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_instance_attrs", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_instance_attrs(self) -> None:\n        \"\"\"non regression for instance_attrs infinite loop : pylint / #4\"\"\"\n\n        code = \"\"\"\n            class Foo(object):\n\n                def set_42(self):\n                    self.attr = 42\n\n            class Bar(Foo):\n\n                def __init__(self):\n                    self.attr = 41\n        \"\"\"\n        ast = parse(code, __name__)\n        foo_class = ast[\"Foo\"]\n        bar_class = ast[\"Bar\"]\n        bar_self = ast[\"Bar\"][\"__init__\"][\"self\"]\n        assattr = bar_class.instance_attrs[\"attr\"][0]\n        self.assertEqual(len(foo_class.instance_attrs[\"attr\"]), 1)\n        self.assertEqual(len(bar_class.instance_attrs[\"attr\"]), 1)\n        self.assertEqual(bar_class.instance_attrs, {\"attr\": [assattr]})\n        # call 'instance_attr' via 'Instance.getattr' to trigger the bug:\n        instance = bar_self.inferred()[0]\n        instance.getattr(\"attr\")\n        self.assertEqual(len(bar_class.instance_attrs[\"attr\"]), 1)\n        self.assertEqual(len(foo_class.instance_attrs[\"attr\"]), 1)\n        self.assertEqual(bar_class.instance_attrs, {\"attr\": [assattr]})\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_instance_attrs", "self", "none", "non", "regression", "for", "instance_attrs", "infinite", "loop", "pylint", "4", "code", "class", "foo", "object", "def", "set_42", "self", "self", "attr", "42", "class", "bar", "foo", "def", "__init__", "self", "self", "attr", "41", "ast", "parse", "code", "__name__", "foo_class", "ast", "foo", "bar_class", "ast", "bar", "bar_self", "ast", "bar", "__init__", "self", "assattr", "bar_class", "instance_attrs", "attr", "0", "self", "assertequal", "len", "foo_class", "instance_attrs", "attr", "1", "self", "assertequal", "len", "bar_class", "instance_attrs", "attr", "1", "self", "assertequal", "bar_class", "instance_attrs", "attr", "assattr", "call", "instance_attr", "via", "instance", "getattr", "to", "trigger", "the", "bug", "instance", "bar_self", "inferred", "0", "instance", "getattr", "attr", "self", "assertequal", "len", "bar_class", "instance_attrs", "attr", "1", "self", "assertequal", "len", "foo_class", "instance_attrs", "attr", "1", "self", "assertequal", "bar_class", "instance_attrs", "attr", "assattr"], "doc_len": 111}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_multi_referential_addition", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_multi_referential_addition", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_multi_referential_addition(self) -> None:\n        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n        Make sure issue where referring to the same variable\n        in the same inferred expression caused an uninferable result.\n        \"\"\"\n        code = \"\"\"\n        b = 1\n        a = b + b\n        a #@\n        \"\"\"\n        variable_a = extract_node(code)\n        self.assertEqual(variable_a.inferred()[0].value, 2)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_multi_referential_addition", "self", "none", "regression", "test", "for", "https", "github", "com", "pycqa", "astroid", "issues", "483", "make", "sure", "issue", "where", "referring", "to", "the", "same", "variable", "in", "the", "same", "inferred", "expression", "caused", "an", "uninferable", "result", "code", "b", "1", "a", "b", "b", "a", "variable_a", "extract_node", "code", "self", "assertequal", "variable_a", "inferred", "0", "value", "2"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_layed_dictunpack", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_layed_dictunpack", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_layed_dictunpack(self) -> None:\n        \"\"\"Regression test for https://github.com/PyCQA/astroid/issues/483\n        Make sure multiple dictunpack references are inferable\n        \"\"\"\n        code = \"\"\"\n        base = {'data': 0}\n        new = {**base, 'data': 1}\n        new3 = {**base, **new}\n        new3 #@\n        \"\"\"\n        ass = extract_node(code)\n        self.assertIsInstance(ass.inferred()[0], nodes.Dict)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_layed_dictunpack", "self", "none", "regression", "test", "for", "https", "github", "com", "pycqa", "astroid", "issues", "483", "make", "sure", "multiple", "dictunpack", "references", "are", "inferable", "code", "base", "data", "0", "new", "base", "data", "1", "new3", "base", "new", "new3", "ass", "extract_node", "code", "self", "assertisinstance", "ass", "inferred", "0", "nodes", "dict"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_inference_modifying_col_offset", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_inference_modifying_col_offset", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_inference_modifying_col_offset(self) -> None:\n        \"\"\"Make sure inference doesn't improperly modify col_offset\n\n        Regression test for https://github.com/PyCQA/pylint/issues/1839\n        \"\"\"\n\n        code = \"\"\"\n        class F:\n            def _(self):\n                return type(self).f\n        \"\"\"\n        mod = parse(code)\n        cdef = mod.body[0]\n        call = cdef.body[0].body[0].value.expr\n        orig_offset = cdef.col_offset\n        call.inferred()\n        self.assertEqual(cdef.col_offset, orig_offset)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_inference_modifying_col_offset", "self", "none", "make", "sure", "inference", "doesn", "t", "improperly", "modify", "col_offset", "regression", "test", "for", "https", "github", "com", "pycqa", "pylint", "issues", "1839", "code", "class", "f", "def", "_", "self", "return", "type", "self", "f", "mod", "parse", "code", "cdef", "mod", "body", "0", "call", "cdef", "body", "0", "body", "0", "value", "expr", "orig_offset", "cdef", "col_offset", "call", "inferred", "self", "assertequal", "cdef", "col_offset", "orig_offset"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_no_runtime_error_in_repeat_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_no_runtime_error_in_repeat_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_no_runtime_error_in_repeat_inference(self) -> None:\n        \"\"\"Stop repeat inference attempt causing a RuntimeError in Python3.7\n\n        See https://github.com/PyCQA/pylint/issues/2317\n        \"\"\"\n        code = \"\"\"\n\n        class ContextMixin:\n            def get_context_data(self, **kwargs):\n                return kwargs\n\n        class DVM(ContextMixin):\n            def get_context_data(self, **kwargs):\n                ctx = super().get_context_data(**kwargs)\n                return ctx\n\n\n        class IFDVM(DVM):\n            def get_context_data(self, **kwargs):\n                ctx = super().get_context_data(**kwargs)\n                ctx['bar'] = 'foo'\n                ctx #@\n                return ctx\n        \"\"\"\n        node = extract_node(code)\n        assert isinstance(node, nodes.NodeNG)\n        result = node.inferred()\n        assert len(result) == 2\n        assert isinstance(result[0], nodes.Dict)\n        assert result[1] is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_no_runtime_error_in_repeat_inference", "self", "none", "stop", "repeat", "inference", "attempt", "causing", "a", "runtimeerror", "in", "python3", "7", "see", "https", "github", "com", "pycqa", "pylint", "issues", "2317", "code", "class", "contextmixin", "def", "get_context_data", "self", "kwargs", "return", "kwargs", "class", "dvm", "contextmixin", "def", "get_context_data", "self", "kwargs", "ctx", "super", "get_context_data", "kwargs", "return", "ctx", "class", "ifdvm", "dvm", "def", "get_context_data", "self", "kwargs", "ctx", "super", "get_context_data", "kwargs", "ctx", "bar", "foo", "ctx", "return", "ctx", "node", "extract_node", "code", "assert", "isinstance", "node", "nodes", "nodeng", "result", "node", "inferred", "assert", "len", "result", "2", "assert", "isinstance", "result", "0", "nodes", "dict", "assert", "result", "1", "is", "util", "uninferable"], "doc_len": 92}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_python25_no_relative_import", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_python25_no_relative_import", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_python25_no_relative_import(self) -> None:\n        ast = resources.build_file(\"data/package/absimport.py\")\n        self.assertTrue(ast.absolute_import_activated(), True)\n        inferred = next(\n            test_utils.get_name_node(ast, \"import_package_subpackage_module\").infer()\n        )\n        # failed to import since absolute_import is activated\n        self.assertIs(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_python25_no_relative_import", "self", "none", "ast", "resources", "build_file", "data", "package", "absimport", "py", "self", "asserttrue", "ast", "absolute_import_activated", "true", "inferred", "next", "test_utils", "get_name_node", "ast", "import_package_subpackage_module", "infer", "failed", "to", "import", "since", "absolute_import", "is", "activated", "self", "assertis", "inferred", "util", "uninferable"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_absolute_import", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_absolute_import", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_absolute_import(self) -> None:\n        ast = resources.build_file(\"data/absimp/string.py\", \"data.absimp.string\")\n        self.assertTrue(ast.absolute_import_activated(), True)\n        inferred = next(test_utils.get_name_node(ast, \"string\").infer())\n        self.assertIsInstance(inferred, nodes.Module)\n        self.assertEqual(inferred.name, \"string\")\n        self.assertIn(\"ascii_letters\", inferred.locals)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_absolute_import", "self", "none", "ast", "resources", "build_file", "data", "absimp", "string", "py", "data", "absimp", "string", "self", "asserttrue", "ast", "absolute_import_activated", "true", "inferred", "next", "test_utils", "get_name_node", "ast", "string", "infer", "self", "assertisinstance", "inferred", "nodes", "module", "self", "assertequal", "inferred", "name", "string", "self", "assertin", "ascii_letters", "inferred", "locals"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_property", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_property", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_property(self) -> None:\n        code = \"\"\"\n            from smtplib import SMTP\n            class SendMailController(object):\n\n                @property\n                def smtp(self):\n                    return SMTP(mailhost, port)\n\n                @property\n                def me(self):\n                    return self\n\n            my_smtp = SendMailController().smtp\n            my_me = SendMailController().me\n            \"\"\"\n        decorators = {\"builtins.property\"}\n        ast = parse(code, __name__)\n        self.assertEqual(ast[\"SendMailController\"][\"smtp\"].decoratornames(), decorators)\n        propinferred = list(ast.body[2].value.infer())\n        self.assertEqual(len(propinferred), 1)\n        propinferred = propinferred[0]\n        self.assertIsInstance(propinferred, Instance)\n        self.assertEqual(propinferred.name, \"SMTP\")\n        self.assertEqual(propinferred.root().name, \"smtplib\")\n        self.assertEqual(ast[\"SendMailController\"][\"me\"].decoratornames(), decorators)\n        propinferred = list(ast.body[3].value.infer())\n        self.assertEqual(len(propinferred), 1)\n        propinferred = propinferred[0]\n        self.assertIsInstance(propinferred, Instance)\n        self.assertEqual(propinferred.name, \"SendMailController\")\n        self.assertEqual(propinferred.root().name, __name__)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_property", "self", "none", "code", "from", "smtplib", "import", "smtp", "class", "sendmailcontroller", "object", "property", "def", "smtp", "self", "return", "smtp", "mailhost", "port", "property", "def", "me", "self", "return", "self", "my_smtp", "sendmailcontroller", "smtp", "my_me", "sendmailcontroller", "me", "decorators", "builtins", "property", "ast", "parse", "code", "__name__", "self", "assertequal", "ast", "sendmailcontroller", "smtp", "decoratornames", "decorators", "propinferred", "list", "ast", "body", "2", "value", "infer", "self", "assertequal", "len", "propinferred", "1", "propinferred", "propinferred", "0", "self", "assertisinstance", "propinferred", "instance", "self", "assertequal", "propinferred", "name", "smtp", "self", "assertequal", "propinferred", "root", "name", "smtplib", "self", "assertequal", "ast", "sendmailcontroller", "me", "decoratornames", "decorators", "propinferred", "list", "ast", "body", "3", "value", "infer", "self", "assertequal", "len", "propinferred", "1", "propinferred", "propinferred", "0", "self", "assertisinstance", "propinferred", "instance", "self", "assertequal", "propinferred", "name", "sendmailcontroller", "self", "assertequal", "propinferred", "root", "name", "__name__"], "doc_len": 117}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_im_func_unwrap", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_im_func_unwrap", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_im_func_unwrap(self) -> None:\n        code = \"\"\"\n            class EnvBasedTC:\n                def pactions(self):\n                    pass\n            pactions = EnvBasedTC.pactions.im_func\n            print (pactions)\n\n            class EnvBasedTC2:\n                pactions = EnvBasedTC.pactions.im_func\n                print (pactions)\n            \"\"\"\n        ast = parse(code, __name__)\n        pactions = test_utils.get_name_node(ast, \"pactions\")\n        inferred = list(pactions.infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.FunctionDef)\n        pactions = test_utils.get_name_node(ast[\"EnvBasedTC2\"], \"pactions\")\n        inferred = list(pactions.infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_im_func_unwrap", "self", "none", "code", "class", "envbasedtc", "def", "pactions", "self", "pass", "pactions", "envbasedtc", "pactions", "im_func", "print", "pactions", "class", "envbasedtc2", "pactions", "envbasedtc", "pactions", "im_func", "print", "pactions", "ast", "parse", "code", "__name__", "pactions", "test_utils", "get_name_node", "ast", "pactions", "inferred", "list", "pactions", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "functiondef", "pactions", "test_utils", "get_name_node", "ast", "envbasedtc2", "pactions", "inferred", "list", "pactions", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "functiondef"], "doc_len": 74}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augassign", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augassign", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augassign(self) -> None:\n        code = \"\"\"\n            a = 1\n            a += 2\n            print (a)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(test_utils.get_name_node(ast, \"a\").infer())\n\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Const)\n        self.assertEqual(inferred[0].value, 3)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augassign", "self", "none", "code", "a", "1", "a", "2", "print", "a", "ast", "parse", "code", "__name__", "inferred", "list", "test_utils", "get_name_node", "ast", "a", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "const", "self", "assertequal", "inferred", "0", "value", "3"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_func_arg", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_func_arg", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_func_arg(self) -> None:\n        code = \"\"\"\n            def foo(self, bar):\n                def baz():\n                    pass\n                def qux():\n                    return baz\n                spam = bar(None, qux)\n                print (spam)\n            \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(test_utils.get_name_node(ast[\"foo\"], \"spam\").infer())\n        self.assertEqual(len(inferred), 1)\n        self.assertIs(inferred[0], util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_func_arg", "self", "none", "code", "def", "foo", "self", "bar", "def", "baz", "pass", "def", "qux", "return", "baz", "spam", "bar", "none", "qux", "print", "spam", "ast", "parse", "code", "__name__", "inferred", "list", "test_utils", "get_name_node", "ast", "foo", "spam", "infer", "self", "assertequal", "len", "inferred", "1", "self", "assertis", "inferred", "0", "util", "uninferable"], "doc_len": 49}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nonregr_func_global", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nonregr_func_global", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nonregr_func_global(self) -> None:\n        code = \"\"\"\n            active_application = None\n\n            def get_active_application():\n              global active_application\n              return active_application\n\n            class Application(object):\n              def __init__(self):\n                 global active_application\n                 active_application = self\n\n            class DataManager(object):\n              def __init__(self, app=None):\n                 self.app = get_active_application()\n              def test(self):\n                 p = self.app\n                 print (p)\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = list(Instance(ast[\"DataManager\"]).igetattr(\"app\"))\n        self.assertEqual(len(inferred), 2, inferred)  # None / Instance(Application)\n        inferred = list(\n            test_utils.get_name_node(ast[\"DataManager\"][\"test\"], \"p\").infer()\n        )\n        self.assertEqual(len(inferred), 2, inferred)\n        for node in inferred:\n            if isinstance(node, Instance) and node.name == \"Application\":\n                break\n        else:\n            self.fail(f\"expected to find an instance of Application in {inferred}\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nonregr_func_global", "self", "none", "code", "active_application", "none", "def", "get_active_application", "global", "active_application", "return", "active_application", "class", "application", "object", "def", "__init__", "self", "global", "active_application", "active_application", "self", "class", "datamanager", "object", "def", "__init__", "self", "app", "none", "self", "app", "get_active_application", "def", "test", "self", "p", "self", "app", "print", "p", "ast", "parse", "code", "__name__", "inferred", "list", "instance", "ast", "datamanager", "igetattr", "app", "self", "assertequal", "len", "inferred", "2", "inferred", "none", "instance", "application", "inferred", "list", "test_utils", "get_name_node", "ast", "datamanager", "test", "p", "infer", "self", "assertequal", "len", "inferred", "2", "inferred", "for", "node", "in", "inferred", "if", "isinstance", "node", "instance", "and", "node", "name", "application", "break", "else", "self", "fail", "f", "expected", "to", "find", "an", "instance", "of", "application", "in", "inferred"], "doc_len": 107}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_list_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_list_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_list_inference(self) -> None:\n        \"\"\"#20464\"\"\"\n        code = \"\"\"\n            from unknown import Unknown\n            A = []\n            B = []\n\n            def test():\n              xyz = [\n                Unknown\n              ] + A + B\n              return xyz\n\n            Z = test()\n        \"\"\"\n        ast = parse(code, __name__)\n        inferred = next(ast[\"Z\"].infer())\n        self.assertIsInstance(inferred, nodes.List)\n        self.assertEqual(len(inferred.elts), 1)\n        self.assertIsInstance(inferred.elts[0], nodes.Unknown)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_list_inference", "self", "none", "20464", "code", "from", "unknown", "import", "unknown", "a", "b", "def", "test", "xyz", "unknown", "a", "b", "return", "xyz", "z", "test", "ast", "parse", "code", "__name__", "inferred", "next", "ast", "z", "infer", "self", "assertisinstance", "inferred", "nodes", "list", "self", "assertequal", "len", "inferred", "elts", "1", "self", "assertisinstance", "inferred", "elts", "0", "nodes", "unknown"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test__new__", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test__new__", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test__new__(self) -> None:\n        code = \"\"\"\n            class NewTest(object):\n                \"doc\"\n                def __new__(cls, arg):\n                    self = object.__new__(cls)\n                    self.arg = arg\n                    return self\n\n            n = NewTest()\n        \"\"\"\n        ast = parse(code, __name__)\n        self.assertRaises(InferenceError, list, ast[\"NewTest\"].igetattr(\"arg\"))\n        n = next(ast[\"n\"].infer())\n        inferred = list(n.igetattr(\"arg\"))\n        self.assertEqual(len(inferred), 1, inferred)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test__new__", "self", "none", "code", "class", "newtest", "object", "doc", "def", "__new__", "cls", "arg", "self", "object", "__new__", "cls", "self", "arg", "arg", "return", "self", "n", "newtest", "ast", "parse", "code", "__name__", "self", "assertraises", "inferenceerror", "list", "ast", "newtest", "igetattr", "arg", "n", "next", "ast", "n", "infer", "inferred", "list", "n", "igetattr", "arg", "self", "assertequal", "len", "inferred", "1", "inferred"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test__new__bound_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test__new__bound_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test__new__bound_methods(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class cls(object): pass\n        cls().__new__(cls) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred._proxied, node.root()[\"cls\"])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test__new__bound_methods", "self", "none", "node", "extract_node", "class", "cls", "object", "pass", "cls", "__new__", "cls", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "_proxied", "node", "root", "cls"], "doc_len": 32}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_two_parents_from_same_module", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_two_parents_from_same_module", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_two_parents_from_same_module(self) -> None:\n        code = \"\"\"\n            from data import nonregr\n            class Xxx(nonregr.Aaa, nonregr.Ccc):\n                \"doc\"\n        \"\"\"\n        ast = parse(code, __name__)\n        parents = list(ast[\"Xxx\"].ancestors())\n        self.assertEqual(len(parents), 3, parents)  # Aaa, Ccc, object\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_two_parents_from_same_module", "self", "none", "code", "from", "data", "import", "nonregr", "class", "xxx", "nonregr", "aaa", "nonregr", "ccc", "doc", "ast", "parse", "code", "__name__", "parents", "list", "ast", "xxx", "ancestors", "self", "assertequal", "len", "parents", "3", "parents", "aaa", "ccc", "object"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_pluggable_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_pluggable_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_pluggable_inference(self) -> None:\n        code = \"\"\"\n            from collections import namedtuple\n            A = namedtuple('A', ['a', 'b'])\n            B = namedtuple('B', 'a b')\n        \"\"\"\n        ast = parse(code, __name__)\n        aclass = ast[\"A\"].inferred()[0]\n        self.assertIsInstance(aclass, nodes.ClassDef)\n        self.assertIn(\"a\", aclass.instance_attrs)\n        self.assertIn(\"b\", aclass.instance_attrs)\n        bclass = ast[\"B\"].inferred()[0]\n        self.assertIsInstance(bclass, nodes.ClassDef)\n        self.assertIn(\"a\", bclass.instance_attrs)\n        self.assertIn(\"b\", bclass.instance_attrs)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_pluggable_inference", "self", "none", "code", "from", "collections", "import", "namedtuple", "a", "namedtuple", "a", "a", "b", "b", "namedtuple", "b", "a", "b", "ast", "parse", "code", "__name__", "aclass", "ast", "a", "inferred", "0", "self", "assertisinstance", "aclass", "nodes", "classdef", "self", "assertin", "a", "aclass", "instance_attrs", "self", "assertin", "b", "aclass", "instance_attrs", "bclass", "ast", "b", "inferred", "0", "self", "assertisinstance", "bclass", "nodes", "classdef", "self", "assertin", "a", "bclass", "instance_attrs", "self", "assertin", "b", "bclass", "instance_attrs"], "doc_len": 67}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arguments", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arguments(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def first(self, arg1, arg2):\n                    return arg1\n                @classmethod\n                def method(cls, arg1, arg2):\n                    return arg2\n                @classmethod\n                def empty(cls):\n                    return 2\n                @staticmethod\n                def static(arg1, arg2):\n                    return arg1\n                def empty_method(self):\n                    return []\n            x = A().first(1, [])\n            y = A.method(1, [])\n            z = A.static(1, [])\n            empty = A.empty()\n            empty_list = A().empty_method()\n        \"\"\"\n        ast = parse(code, __name__)\n        int_node = ast[\"x\"].inferred()[0]\n        self.assertIsInstance(int_node, nodes.Const)\n        self.assertEqual(int_node.value, 1)\n        list_node = ast[\"y\"].inferred()[0]\n        self.assertIsInstance(list_node, nodes.List)\n        int_node = ast[\"z\"].inferred()[0]\n        self.assertIsInstance(int_node, nodes.Const)\n        self.assertEqual(int_node.value, 1)\n        empty = ast[\"empty\"].inferred()[0]\n        self.assertIsInstance(empty, nodes.Const)\n        self.assertEqual(empty.value, 2)\n        empty_list = ast[\"empty_list\"].inferred()[0]\n        self.assertIsInstance(empty_list, nodes.List)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arguments", "self", "none", "code", "class", "a", "object", "def", "first", "self", "arg1", "arg2", "return", "arg1", "classmethod", "def", "method", "cls", "arg1", "arg2", "return", "arg2", "classmethod", "def", "empty", "cls", "return", "2", "staticmethod", "def", "static", "arg1", "arg2", "return", "arg1", "def", "empty_method", "self", "return", "x", "a", "first", "1", "y", "a", "method", "1", "z", "a", "static", "1", "empty", "a", "empty", "empty_list", "a", "empty_method", "ast", "parse", "code", "__name__", "int_node", "ast", "x", "inferred", "0", "self", "assertisinstance", "int_node", "nodes", "const", "self", "assertequal", "int_node", "value", "1", "list_node", "ast", "y", "inferred", "0", "self", "assertisinstance", "list_node", "nodes", "list", "int_node", "ast", "z", "inferred", "0", "self", "assertisinstance", "int_node", "nodes", "const", "self", "assertequal", "int_node", "value", "1", "empty", "ast", "empty", "inferred", "0", "self", "assertisinstance", "empty", "nodes", "const", "self", "assertequal", "empty", "value", "2", "empty_list", "ast", "empty_list", "inferred", "0", "self", "assertisinstance", "empty_list", "nodes", "list"], "doc_len": 131}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_variable_arguments", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_variable_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_variable_arguments(self) -> None:\n        code = \"\"\"\n            def test(*args, **kwargs):\n                vararg = args\n                kwarg = kwargs\n        \"\"\"\n        ast = parse(code, __name__)\n        func = ast[\"test\"]\n        vararg = func.body[0].value\n        kwarg = func.body[1].value\n\n        kwarg_inferred = kwarg.inferred()[0]\n        self.assertIsInstance(kwarg_inferred, nodes.Dict)\n        self.assertIs(kwarg_inferred.parent, func.args)\n\n        vararg_inferred = vararg.inferred()[0]\n        self.assertIsInstance(vararg_inferred, nodes.Tuple)\n        self.assertIs(vararg_inferred.parent, func.args)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_variable_arguments", "self", "none", "code", "def", "test", "args", "kwargs", "vararg", "args", "kwarg", "kwargs", "ast", "parse", "code", "__name__", "func", "ast", "test", "vararg", "func", "body", "0", "value", "kwarg", "func", "body", "1", "value", "kwarg_inferred", "kwarg", "inferred", "0", "self", "assertisinstance", "kwarg_inferred", "nodes", "dict", "self", "assertis", "kwarg_inferred", "parent", "func", "args", "vararg_inferred", "vararg", "inferred", "0", "self", "assertisinstance", "vararg_inferred", "nodes", "tuple", "self", "assertis", "vararg_inferred", "parent", "func", "args"], "doc_len": 64}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_nested", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_nested", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_nested(self) -> None:\n        code = \"\"\"\n            def nested():\n                from threading import Thread\n\n                class NestedThread(Thread):\n                    def __init__(self):\n                        Thread.__init__(self)\n        \"\"\"\n        # Test that inferring Thread.__init__ looks up in\n        # the nested scope.\n        ast = parse(code, __name__)\n        callfunc = next(ast.nodes_of_class(nodes.Call))\n        func = callfunc.func\n        inferred = func.inferred()[0]\n        self.assertIsInstance(inferred, UnboundMethod)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_nested", "self", "none", "code", "def", "nested", "from", "threading", "import", "thread", "class", "nestedthread", "thread", "def", "__init__", "self", "thread", "__init__", "self", "test", "that", "inferring", "thread", "__init__", "looks", "up", "in", "the", "nested", "scope", "ast", "parse", "code", "__name__", "callfunc", "next", "ast", "nodes_of_class", "nodes", "call", "func", "callfunc", "func", "inferred", "func", "inferred", "0", "self", "assertisinstance", "inferred", "unboundmethod"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_binary_operations", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_binary_operations", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_binary_operations(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def __mul__(self, other):\n                    return 42\n            a = A()\n            b = A()\n            sub = a - b\n            mul = a * b\n        \"\"\"\n        ast = parse(code, __name__)\n        sub = ast[\"sub\"].inferred()[0]\n        mul = ast[\"mul\"].inferred()[0]\n        self.assertIs(sub, util.Uninferable)\n        self.assertIsInstance(mul, nodes.Const)\n        self.assertEqual(mul.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_binary_operations", "self", "none", "code", "class", "a", "object", "def", "__mul__", "self", "other", "return", "42", "a", "a", "b", "a", "sub", "a", "b", "mul", "a", "b", "ast", "parse", "code", "__name__", "sub", "ast", "sub", "inferred", "0", "mul", "ast", "mul", "inferred", "0", "self", "assertis", "sub", "util", "uninferable", "self", "assertisinstance", "mul", "nodes", "const", "self", "assertequal", "mul", "value", "42"], "doc_len": 57}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_binary_operations_parent", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_binary_operations_parent", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_binary_operations_parent(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def __mul__(self, other):\n                    return 42\n            class B(A):\n                pass\n            a = B()\n            b = B()\n            sub = a - b\n            mul = a * b\n        \"\"\"\n        ast = parse(code, __name__)\n        sub = ast[\"sub\"].inferred()[0]\n        mul = ast[\"mul\"].inferred()[0]\n        self.assertIs(sub, util.Uninferable)\n        self.assertIsInstance(mul, nodes.Const)\n        self.assertEqual(mul.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_binary_operations_parent", "self", "none", "code", "class", "a", "object", "def", "__mul__", "self", "other", "return", "42", "class", "b", "a", "pass", "a", "b", "b", "b", "sub", "a", "b", "mul", "a", "b", "ast", "parse", "code", "__name__", "sub", "ast", "sub", "inferred", "0", "mul", "ast", "mul", "inferred", "0", "self", "assertis", "sub", "util", "uninferable", "self", "assertisinstance", "mul", "nodes", "const", "self", "assertequal", "mul", "value", "42"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_binary_operations_multiple_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_binary_operations_multiple_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_binary_operations_multiple_methods(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def __mul__(self, other):\n                    return 42\n            class B(A):\n                def __mul__(self, other):\n                    return [42]\n            a = B()\n            b = B()\n            sub = a - b\n            mul = a * b\n        \"\"\"\n        ast = parse(code, __name__)\n        sub = ast[\"sub\"].inferred()[0]\n        mul = ast[\"mul\"].inferred()[0]\n        self.assertIs(sub, util.Uninferable)\n        self.assertIsInstance(mul, nodes.List)\n        self.assertIsInstance(mul.elts[0], nodes.Const)\n        self.assertEqual(mul.elts[0].value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_binary_operations_multiple_methods", "self", "none", "code", "class", "a", "object", "def", "__mul__", "self", "other", "return", "42", "class", "b", "a", "def", "__mul__", "self", "other", "return", "42", "a", "b", "b", "b", "sub", "a", "b", "mul", "a", "b", "ast", "parse", "code", "__name__", "sub", "ast", "sub", "inferred", "0", "mul", "ast", "mul", "inferred", "0", "self", "assertis", "sub", "util", "uninferable", "self", "assertisinstance", "mul", "nodes", "list", "self", "assertisinstance", "mul", "elts", "0", "nodes", "const", "self", "assertequal", "mul", "elts", "0", "value", "42"], "doc_len": 75}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_call_result_crash", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_call_result_crash", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_call_result_crash(self) -> None:\n        code = \"\"\"\n            class A(object):\n                def __mul__(self, other):\n                    return type.__new__()\n\n            a = A()\n            b = A()\n            c = a * b\n        \"\"\"\n        ast = parse(code, __name__)\n        node = ast[\"c\"]\n        assert isinstance(node, nodes.NodeNG)\n        self.assertEqual(node.inferred(), [util.Uninferable])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_call_result_crash", "self", "none", "code", "class", "a", "object", "def", "__mul__", "self", "other", "return", "type", "__new__", "a", "a", "b", "a", "c", "a", "b", "ast", "parse", "code", "__name__", "node", "ast", "c", "assert", "isinstance", "node", "nodes", "nodeng", "self", "assertequal", "node", "inferred", "util", "uninferable"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_empty_nodes", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_empty_nodes", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_empty_nodes(self) -> None:\n        # Should not crash when trying to infer EmptyNodes.\n        node = nodes.EmptyNode()\n        assert isinstance(node, nodes.NodeNG)\n        self.assertEqual(node.inferred(), [util.Uninferable])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_empty_nodes", "self", "none", "should", "not", "crash", "when", "trying", "to", "infer", "emptynodes", "node", "nodes", "emptynode", "assert", "isinstance", "node", "nodes", "nodeng", "self", "assertequal", "node", "inferred", "util", "uninferable"], "doc_len": 30}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infinite_loop_for_decorators", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infinite_loop_for_decorators", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infinite_loop_for_decorators(self) -> None:\n        # Issue https://bitbucket.org/logilab/astroid/issue/50\n        # A decorator that returns itself leads to an infinite loop.\n        code = \"\"\"\n            def decorator():\n                def wrapper():\n                    return decorator()\n                return wrapper\n\n            @decorator()\n            def do_a_thing():\n                pass\n        \"\"\"\n        ast = parse(code, __name__)\n        node = ast[\"do_a_thing\"]\n        self.assertEqual(node.type, \"function\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infinite_loop_for_decorators", "self", "none", "issue", "https", "bitbucket", "org", "logilab", "astroid", "issue", "50", "a", "decorator", "that", "returns", "itself", "leads", "to", "an", "infinite", "loop", "code", "def", "decorator", "def", "wrapper", "return", "decorator", "return", "wrapper", "decorator", "def", "do_a_thing", "pass", "ast", "parse", "code", "__name__", "node", "ast", "do_a_thing", "self", "assertequal", "node", "type", "function"], "doc_len": 51}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_no_infinite_ancestor_loop", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_no_infinite_ancestor_loop", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_no_infinite_ancestor_loop(self) -> None:\n        klass = extract_node(\n            \"\"\"\n            import datetime\n\n            def method(self):\n                datetime.datetime = something()\n\n            class something(datetime.datetime):  #@\n                pass\n        \"\"\"\n        )\n        ancestors = [base.name for base in klass.ancestors()]\n        expected_subset = [\"datetime\", \"date\"]\n        self.assertEqual(expected_subset, ancestors[:2])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_no_infinite_ancestor_loop", "self", "none", "klass", "extract_node", "import", "datetime", "def", "method", "self", "datetime", "datetime", "something", "class", "something", "datetime", "datetime", "pass", "ancestors", "base", "name", "for", "base", "in", "klass", "ancestors", "expected_subset", "datetime", "date", "self", "assertequal", "expected_subset", "ancestors", "2"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_stop_iteration_leak", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_stop_iteration_leak", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_stop_iteration_leak(self) -> None:\n        code = \"\"\"\n            class Test:\n                def __init__(self):\n                    self.config = {0: self.config[0]}\n                    self.config[0].test() #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        expr = ast.func.expr\n        with pytest.raises(InferenceError):\n            next(expr.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_stop_iteration_leak", "self", "none", "code", "class", "test", "def", "__init__", "self", "self", "config", "0", "self", "config", "0", "self", "config", "0", "test", "ast", "extract_node", "code", "__name__", "expr", "ast", "func", "expr", "with", "pytest", "raises", "inferenceerror", "next", "expr", "infer"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_tuple_builtin_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_tuple_builtin_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_tuple_builtin_inference(self) -> None:\n        code = \"\"\"\n        var = (1, 2)\n        tuple() #@\n        tuple([1]) #@\n        tuple({2}) #@\n        tuple(\"abc\") #@\n        tuple({1: 2}) #@\n        tuple(var) #@\n        tuple(tuple([1])) #@\n        tuple(frozenset((1, 2))) #@\n\n        tuple(None) #@\n        tuple(1) #@\n        tuple(1, 2) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n\n        self.assertInferTuple(ast[0], [])\n        self.assertInferTuple(ast[1], [1])\n        self.assertInferTuple(ast[2], [2])\n        self.assertInferTuple(ast[3], [\"a\", \"b\", \"c\"])\n        self.assertInferTuple(ast[4], [1])\n        self.assertInferTuple(ast[5], [1, 2])\n        self.assertInferTuple(ast[6], [1])\n        self.assertInferTuple(ast[7], [1, 2])\n\n        for node in ast[8:]:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.tuple\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_tuple_builtin_inference", "self", "none", "code", "var", "1", "2", "tuple", "tuple", "1", "tuple", "2", "tuple", "abc", "tuple", "1", "2", "tuple", "var", "tuple", "tuple", "1", "tuple", "frozenset", "1", "2", "tuple", "none", "tuple", "1", "tuple", "1", "2", "ast", "extract_node", "code", "__name__", "self", "assertinfertuple", "ast", "0", "self", "assertinfertuple", "ast", "1", "1", "self", "assertinfertuple", "ast", "2", "2", "self", "assertinfertuple", "ast", "3", "a", "b", "c", "self", "assertinfertuple", "ast", "4", "1", "self", "assertinfertuple", "ast", "5", "1", "2", "self", "assertinfertuple", "ast", "6", "1", "self", "assertinfertuple", "ast", "7", "1", "2", "for", "node", "in", "ast", "8", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "tuple"], "doc_len": 104}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_tuple_literal", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_tuple_literal", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_tuple_literal(self) -> None:\n        code = \"\"\"\n        var = (1, 2, 3)\n        bar = (5, 6, 7)\n        foo = [999, 1000, 1001]\n        (0, *var) #@\n        (0, *var, 4) #@\n        (0, *var, 4, *bar) #@\n        (0, *var, 4, *(*bar, 8)) #@\n        (0, *var, 4, *(*bar, *foo)) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferTuple(ast[0], [0, 1, 2, 3])\n        self.assertInferTuple(ast[1], [0, 1, 2, 3, 4])\n        self.assertInferTuple(ast[2], [0, 1, 2, 3, 4, 5, 6, 7])\n        self.assertInferTuple(ast[3], [0, 1, 2, 3, 4, 5, 6, 7, 8])\n        self.assertInferTuple(ast[4], [0, 1, 2, 3, 4, 5, 6, 7, 999, 1000, 1001])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_tuple_literal", "self", "none", "code", "var", "1", "2", "3", "bar", "5", "6", "7", "foo", "999", "1000", "1001", "0", "var", "0", "var", "4", "0", "var", "4", "bar", "0", "var", "4", "bar", "8", "0", "var", "4", "bar", "foo", "ast", "extract_node", "code", "__name__", "self", "assertinfertuple", "ast", "0", "0", "1", "2", "3", "self", "assertinfertuple", "ast", "1", "0", "1", "2", "3", "4", "self", "assertinfertuple", "ast", "2", "0", "1", "2", "3", "4", "5", "6", "7", "self", "assertinfertuple", "ast", "3", "0", "1", "2", "3", "4", "5", "6", "7", "8", "self", "assertinfertuple", "ast", "4", "0", "1", "2", "3", "4", "5", "6", "7", "999", "1000", "1001"], "doc_len": 101}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_list_literal", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_list_literal", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_list_literal(self) -> None:\n        code = \"\"\"\n        var = (1, 2, 3)\n        bar = (5, 6, 7)\n        foo = [999, 1000, 1001]\n        [0, *var] #@\n        [0, *var, 4] #@\n        [0, *var, 4, *bar] #@\n        [0, *var, 4, *[*bar, 8]] #@\n        [0, *var, 4, *[*bar, *foo]] #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferList(ast[0], [0, 1, 2, 3])\n        self.assertInferList(ast[1], [0, 1, 2, 3, 4])\n        self.assertInferList(ast[2], [0, 1, 2, 3, 4, 5, 6, 7])\n        self.assertInferList(ast[3], [0, 1, 2, 3, 4, 5, 6, 7, 8])\n        self.assertInferList(ast[4], [0, 1, 2, 3, 4, 5, 6, 7, 999, 1000, 1001])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_list_literal", "self", "none", "code", "var", "1", "2", "3", "bar", "5", "6", "7", "foo", "999", "1000", "1001", "0", "var", "0", "var", "4", "0", "var", "4", "bar", "0", "var", "4", "bar", "8", "0", "var", "4", "bar", "foo", "ast", "extract_node", "code", "__name__", "self", "assertinferlist", "ast", "0", "0", "1", "2", "3", "self", "assertinferlist", "ast", "1", "0", "1", "2", "3", "4", "self", "assertinferlist", "ast", "2", "0", "1", "2", "3", "4", "5", "6", "7", "self", "assertinferlist", "ast", "3", "0", "1", "2", "3", "4", "5", "6", "7", "8", "self", "assertinferlist", "ast", "4", "0", "1", "2", "3", "4", "5", "6", "7", "999", "1000", "1001"], "doc_len": 101}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_set_literal", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_set_literal", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_set_literal(self) -> None:\n        code = \"\"\"\n        var = (1, 2, 3)\n        bar = (5, 6, 7)\n        foo = [999, 1000, 1001]\n        {0, *var} #@\n        {0, *var, 4} #@\n        {0, *var, 4, *bar} #@\n        {0, *var, 4, *{*bar, 8}} #@\n        {0, *var, 4, *{*bar, *foo}} #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferSet(ast[0], [0, 1, 2, 3])\n        self.assertInferSet(ast[1], [0, 1, 2, 3, 4])\n        self.assertInferSet(ast[2], [0, 1, 2, 3, 4, 5, 6, 7])\n        self.assertInferSet(ast[3], [0, 1, 2, 3, 4, 5, 6, 7, 8])\n        self.assertInferSet(ast[4], [0, 1, 2, 3, 4, 5, 6, 7, 999, 1000, 1001])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_set_literal", "self", "none", "code", "var", "1", "2", "3", "bar", "5", "6", "7", "foo", "999", "1000", "1001", "0", "var", "0", "var", "4", "0", "var", "4", "bar", "0", "var", "4", "bar", "8", "0", "var", "4", "bar", "foo", "ast", "extract_node", "code", "__name__", "self", "assertinferset", "ast", "0", "0", "1", "2", "3", "self", "assertinferset", "ast", "1", "0", "1", "2", "3", "4", "self", "assertinferset", "ast", "2", "0", "1", "2", "3", "4", "5", "6", "7", "self", "assertinferset", "ast", "3", "0", "1", "2", "3", "4", "5", "6", "7", "8", "self", "assertinferset", "ast", "4", "0", "1", "2", "3", "4", "5", "6", "7", "999", "1000", "1001"], "doc_len": 101}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_literals_inference_issues", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_literals_inference_issues", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_literals_inference_issues(self) -> None:\n        code = \"\"\"\n        {0, *var} #@\n        {0, *var, 4} #@\n        {0, *var, 4, *bar} #@\n        {0, *var, 4, *{*bar, 8}} #@\n        {0, *var, 4, *{*bar, *foo}} #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        for node in ast:\n            with self.assertRaises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_literals_inference_issues", "self", "none", "code", "0", "var", "0", "var", "4", "0", "var", "4", "bar", "0", "var", "4", "bar", "8", "0", "var", "4", "bar", "foo", "ast", "extract_node", "code", "__name__", "for", "node", "in", "ast", "with", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_mapping_literal", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_mapping_literal", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_mapping_literal(self) -> None:\n        code = \"\"\"\n        var = {1: 'b', 2: 'c'}\n        bar = {4: 'e', 5: 'f'}\n        {0: 'a', **var} #@\n        {0: 'a', **var, 3: 'd'} #@\n        {0: 'a', **var, 3: 'd', **{**bar, 6: 'g'}} #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferDict(ast[0], {0: \"a\", 1: \"b\", 2: \"c\"})\n        self.assertInferDict(ast[1], {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\"})\n        self.assertInferDict(\n            ast[2], {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\", 4: \"e\", 5: \"f\", 6: \"g\"}\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_mapping_literal", "self", "none", "code", "var", "1", "b", "2", "c", "bar", "4", "e", "5", "f", "0", "a", "var", "0", "a", "var", "3", "d", "0", "a", "var", "3", "d", "bar", "6", "g", "ast", "extract_node", "code", "__name__", "self", "assertinferdict", "ast", "0", "0", "a", "1", "b", "2", "c", "self", "assertinferdict", "ast", "1", "0", "a", "1", "b", "2", "c", "3", "d", "self", "assertinferdict", "ast", "2", "0", "a", "1", "b", "2", "c", "3", "d", "4", "e", "5", "f", "6", "g"], "doc_len": 79}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_mapping_literal_no_inference_possible", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_mapping_literal_no_inference_possible", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_mapping_literal_no_inference_possible(self) -> None:\n        node = extract_node(\n            \"\"\"\n        from unknown import unknown\n\n        def test(a):\n           return a + 1\n\n        def func():\n            a = {unknown: 'a'}\n            return {0: 1, **a}\n\n        test(**func())\n        \"\"\"\n        )\n        self.assertEqual(next(node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_mapping_literal_no_inference_possible", "self", "none", "node", "extract_node", "from", "unknown", "import", "unknown", "def", "test", "a", "return", "a", "1", "def", "func", "a", "unknown", "a", "return", "0", "1", "a", "test", "func", "self", "assertequal", "next", "node", "infer", "util", "uninferable"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_mapping_inference_issues", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_mapping_inference_issues", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_mapping_inference_issues(self) -> None:\n        code = \"\"\"\n        {0: 'a', **var} #@\n        {0: 'a', **var, 3: 'd'} #@\n        {0: 'a', **var, 3: 'd', **{**bar, 6: 'g'}} #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        for node in ast:\n            with self.assertRaises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_mapping_inference_issues", "self", "none", "code", "0", "a", "var", "0", "a", "var", "3", "d", "0", "a", "var", "3", "d", "bar", "6", "g", "ast", "extract_node", "code", "__name__", "for", "node", "in", "ast", "with", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_starred_in_mapping_literal_non_const_keys_values", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_starred_in_mapping_literal_non_const_keys_values", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_starred_in_mapping_literal_non_const_keys_values(self) -> None:\n        code = \"\"\"\n        a, b, c, d, e, f, g, h, i, j = \"ABCDEFGHIJ\"\n        var = {c: d, e: f}\n        bar = {i: j}\n        {a: b, **var} #@\n        {a: b, **var, **{g: h, **bar}} #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferDict(ast[0], {\"A\": \"B\", \"C\": \"D\", \"E\": \"F\"})\n        self.assertInferDict(ast[1], {\"A\": \"B\", \"C\": \"D\", \"E\": \"F\", \"G\": \"H\", \"I\": \"J\"})\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_starred_in_mapping_literal_non_const_keys_values", "self", "none", "code", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "abcdefghij", "var", "c", "d", "e", "f", "bar", "i", "j", "a", "b", "var", "a", "b", "var", "g", "h", "bar", "ast", "extract_node", "code", "__name__", "self", "assertinferdict", "ast", "0", "a", "b", "c", "d", "e", "f", "self", "assertinferdict", "ast", "1", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j"], "doc_len": 65}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_frozenset_builtin_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_frozenset_builtin_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_frozenset_builtin_inference(self) -> None:\n        code = \"\"\"\n        var = (1, 2)\n        frozenset() #@\n        frozenset([1, 2, 1]) #@\n        frozenset({2, 3, 1}) #@\n        frozenset(\"abcab\") #@\n        frozenset({1: 2}) #@\n        frozenset(var) #@\n        frozenset(tuple([1])) #@\n\n        frozenset(set(tuple([4, 5, set([2])]))) #@\n        frozenset(None) #@\n        frozenset(1) #@\n        frozenset(1, 2) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n\n        self.assertInferFrozenSet(ast[0], [])\n        self.assertInferFrozenSet(ast[1], [1, 2])\n        self.assertInferFrozenSet(ast[2], [1, 2, 3])\n        self.assertInferFrozenSet(ast[3], [\"a\", \"b\", \"c\"])\n        self.assertInferFrozenSet(ast[4], [1])\n        self.assertInferFrozenSet(ast[5], [1, 2])\n        self.assertInferFrozenSet(ast[6], [1])\n\n        for node in ast[7:]:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.frozenset\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_frozenset_builtin_inference", "self", "none", "code", "var", "1", "2", "frozenset", "frozenset", "1", "2", "1", "frozenset", "2", "3", "1", "frozenset", "abcab", "frozenset", "1", "2", "frozenset", "var", "frozenset", "tuple", "1", "frozenset", "set", "tuple", "4", "5", "set", "2", "frozenset", "none", "frozenset", "1", "frozenset", "1", "2", "ast", "extract_node", "code", "__name__", "self", "assertinferfrozenset", "ast", "0", "self", "assertinferfrozenset", "ast", "1", "1", "2", "self", "assertinferfrozenset", "ast", "2", "1", "2", "3", "self", "assertinferfrozenset", "ast", "3", "a", "b", "c", "self", "assertinferfrozenset", "ast", "4", "1", "self", "assertinferfrozenset", "ast", "5", "1", "2", "self", "assertinferfrozenset", "ast", "6", "1", "for", "node", "in", "ast", "7", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "frozenset"], "doc_len": 108}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_set_builtin_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_set_builtin_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_set_builtin_inference(self) -> None:\n        code = \"\"\"\n        var = (1, 2)\n        set() #@\n        set([1, 2, 1]) #@\n        set({2, 3, 1}) #@\n        set(\"abcab\") #@\n        set({1: 2}) #@\n        set(var) #@\n        set(tuple([1])) #@\n\n        set(set(tuple([4, 5, set([2])]))) #@\n        set(None) #@\n        set(1) #@\n        set(1, 2) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n\n        self.assertInferSet(ast[0], [])\n        self.assertInferSet(ast[1], [1, 2])\n        self.assertInferSet(ast[2], [1, 2, 3])\n        self.assertInferSet(ast[3], [\"a\", \"b\", \"c\"])\n        self.assertInferSet(ast[4], [1])\n        self.assertInferSet(ast[5], [1, 2])\n        self.assertInferSet(ast[6], [1])\n\n        for node in ast[7:]:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.set\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_set_builtin_inference", "self", "none", "code", "var", "1", "2", "set", "set", "1", "2", "1", "set", "2", "3", "1", "set", "abcab", "set", "1", "2", "set", "var", "set", "tuple", "1", "set", "set", "tuple", "4", "5", "set", "2", "set", "none", "set", "1", "set", "1", "2", "ast", "extract_node", "code", "__name__", "self", "assertinferset", "ast", "0", "self", "assertinferset", "ast", "1", "1", "2", "self", "assertinferset", "ast", "2", "1", "2", "3", "self", "assertinferset", "ast", "3", "a", "b", "c", "self", "assertinferset", "ast", "4", "1", "self", "assertinferset", "ast", "5", "1", "2", "self", "assertinferset", "ast", "6", "1", "for", "node", "in", "ast", "7", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "set"], "doc_len": 108}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_list_builtin_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_list_builtin_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_list_builtin_inference(self) -> None:\n        code = \"\"\"\n        var = (1, 2)\n        list() #@\n        list([1, 2, 1]) #@\n        list({2, 3, 1}) #@\n        list(\"abcab\") #@\n        list({1: 2}) #@\n        list(var) #@\n        list(tuple([1])) #@\n\n        list(list(tuple([4, 5, list([2])]))) #@\n        list(None) #@\n        list(1) #@\n        list(1, 2) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferList(ast[0], [])\n        self.assertInferList(ast[1], [1, 1, 2])\n        self.assertInferList(ast[2], [1, 2, 3])\n        self.assertInferList(ast[3], [\"a\", \"a\", \"b\", \"b\", \"c\"])\n        self.assertInferList(ast[4], [1])\n        self.assertInferList(ast[5], [1, 2])\n        self.assertInferList(ast[6], [1])\n\n        for node in ast[7:]:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.list\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_list_builtin_inference", "self", "none", "code", "var", "1", "2", "list", "list", "1", "2", "1", "list", "2", "3", "1", "list", "abcab", "list", "1", "2", "list", "var", "list", "tuple", "1", "list", "list", "tuple", "4", "5", "list", "2", "list", "none", "list", "1", "list", "1", "2", "ast", "extract_node", "code", "__name__", "self", "assertinferlist", "ast", "0", "self", "assertinferlist", "ast", "1", "1", "1", "2", "self", "assertinferlist", "ast", "2", "1", "2", "3", "self", "assertinferlist", "ast", "3", "a", "a", "b", "b", "c", "self", "assertinferlist", "ast", "4", "1", "self", "assertinferlist", "ast", "5", "1", "2", "self", "assertinferlist", "ast", "6", "1", "for", "node", "in", "ast", "7", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "list"], "doc_len": 111}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_conversion_of_dict_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_conversion_of_dict_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_conversion_of_dict_methods(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        list({1:2, 2:3}.values()) #@\n        list({1:2, 2:3}.keys()) #@\n        tuple({1:2, 2:3}.values()) #@\n        tuple({1:2, 3:4}.keys()) #@\n        set({1:2, 2:4}.keys()) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        self.assertInferList(ast_nodes[0], [2, 3])\n        self.assertInferList(ast_nodes[1], [1, 2])\n        self.assertInferTuple(ast_nodes[2], [2, 3])\n        self.assertInferTuple(ast_nodes[3], [1, 3])\n        self.assertInferSet(ast_nodes[4], [1, 2])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_conversion_of_dict_methods", "self", "none", "ast_nodes", "extract_node", "list", "1", "2", "2", "3", "values", "list", "1", "2", "2", "3", "keys", "tuple", "1", "2", "2", "3", "values", "tuple", "1", "2", "3", "4", "keys", "set", "1", "2", "2", "4", "keys", "assert", "isinstance", "ast_nodes", "list", "self", "assertinferlist", "ast_nodes", "0", "2", "3", "self", "assertinferlist", "ast_nodes", "1", "1", "2", "self", "assertinfertuple", "ast_nodes", "2", "2", "3", "self", "assertinfertuple", "ast_nodes", "3", "1", "3", "self", "assertinferset", "ast_nodes", "4", "1", "2"], "doc_len": 74}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_builtin_inference_py3k", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_builtin_inference_py3k", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_builtin_inference_py3k(self) -> None:\n        code = \"\"\"\n        list(b\"abc\") #@\n        tuple(b\"abc\") #@\n        set(b\"abc\") #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferList(ast[0], [97, 98, 99])\n        self.assertInferTuple(ast[1], [97, 98, 99])\n        self.assertInferSet(ast[2], [97, 98, 99])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_builtin_inference_py3k", "self", "none", "code", "list", "b", "abc", "tuple", "b", "abc", "set", "b", "abc", "ast", "extract_node", "code", "__name__", "self", "assertinferlist", "ast", "0", "97", "98", "99", "self", "assertinfertuple", "ast", "1", "97", "98", "99", "self", "assertinferset", "ast", "2", "97", "98", "99"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_dict_inference", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_dict_inference", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_dict_inference(self) -> None:\n        code = \"\"\"\n        dict() #@\n        dict(a=1, b=2, c=3) #@\n        dict([(1, 2), (2, 3)]) #@\n        dict([[1, 2], [2, 3]]) #@\n        dict([(1, 2), [2, 3]]) #@\n        dict([('a', 2)], b=2, c=3) #@\n        dict({1: 2}) #@\n        dict({'c': 2}, a=4, b=5) #@\n        def func():\n            return dict(a=1, b=2)\n        func() #@\n        var = {'x': 2, 'y': 3}\n        dict(var, a=1, b=2) #@\n\n        dict([1, 2, 3]) #@\n        dict([(1, 2), (1, 2, 3)]) #@\n        dict({1: 2}, {1: 2}) #@\n        dict({1: 2}, (1, 2)) #@\n        dict({1: 2}, (1, 2), a=4) #@\n        dict([(1, 2), ([4, 5], 2)]) #@\n        dict([None,  None]) #@\n\n        def using_unknown_kwargs(**kwargs):\n            return dict(**kwargs)\n        using_unknown_kwargs(a=1, b=2) #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferDict(ast[0], {})\n        self.assertInferDict(ast[1], {\"a\": 1, \"b\": 2, \"c\": 3})\n        for i in range(2, 5):\n            self.assertInferDict(ast[i], {1: 2, 2: 3})\n        self.assertInferDict(ast[5], {\"a\": 2, \"b\": 2, \"c\": 3})\n        self.assertInferDict(ast[6], {1: 2})\n        self.assertInferDict(ast[7], {\"c\": 2, \"a\": 4, \"b\": 5})\n        self.assertInferDict(ast[8], {\"a\": 1, \"b\": 2})\n        self.assertInferDict(ast[9], {\"x\": 2, \"y\": 3, \"a\": 1, \"b\": 2})\n\n        for node in ast[10:]:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.dict\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_dict_inference", "self", "none", "code", "dict", "dict", "a", "1", "b", "2", "c", "3", "dict", "1", "2", "2", "3", "dict", "1", "2", "2", "3", "dict", "1", "2", "2", "3", "dict", "a", "2", "b", "2", "c", "3", "dict", "1", "2", "dict", "c", "2", "a", "4", "b", "5", "def", "func", "return", "dict", "a", "1", "b", "2", "func", "var", "x", "2", "y", "3", "dict", "var", "a", "1", "b", "2", "dict", "1", "2", "3", "dict", "1", "2", "1", "2", "3", "dict", "1", "2", "1", "2", "dict", "1", "2", "1", "2", "dict", "1", "2", "1", "2", "a", "4", "dict", "1", "2", "4", "5", "2", "dict", "none", "none", "def", "using_unknown_kwargs", "kwargs", "return", "dict", "kwargs", "using_unknown_kwargs", "a", "1", "b", "2", "ast", "extract_node", "code", "__name__", "self", "assertinferdict", "ast", "0", "self", "assertinferdict", "ast", "1", "a", "1", "b", "2", "c", "3", "for", "i", "in", "range", "2", "5", "self", "assertinferdict", "ast", "i", "1", "2", "2", "3", "self", "assertinferdict", "ast", "5", "a", "2", "b", "2", "c", "3", "self", "assertinferdict", "ast", "6", "1", "2", "self", "assertinferdict", "ast", "7", "c", "2", "a", "4", "b", "5", "self", "assertinferdict", "ast", "8", "a", "1", "b", "2", "self", "assertinferdict", "ast", "9", "x", "2", "y", "3", "a", "1", "b", "2", "for", "node", "in", "ast", "10", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "dict"], "doc_len": 213}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_dict_inference_kwargs", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_dict_inference_kwargs", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_dict_inference_kwargs(self) -> None:\n        ast_node = extract_node(\"\"\"dict(a=1, b=2, **{'c': 3})\"\"\")\n        self.assertInferDict(ast_node, {\"a\": 1, \"b\": 2, \"c\": 3})\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_dict_inference_kwargs", "self", "none", "ast_node", "extract_node", "dict", "a", "1", "b", "2", "c", "3", "self", "assertinferdict", "ast_node", "a", "1", "b", "2", "c", "3"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_dict_inference_for_multiple_starred", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_dict_inference_for_multiple_starred", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_dict_inference_for_multiple_starred(self) -> None:\n        pairs = [\n            ('dict(a=1, **{\"b\": 2}, **{\"c\":3})', {\"a\": 1, \"b\": 2, \"c\": 3}),\n            ('dict(a=1, **{\"b\": 2}, d=4, **{\"c\":3})', {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}),\n            ('dict({\"a\":1}, b=2, **{\"c\":3})', {\"a\": 1, \"b\": 2, \"c\": 3}),\n        ]\n        for code, expected_value in pairs:\n            node = extract_node(code)\n            self.assertInferDict(node, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_dict_inference_for_multiple_starred", "self", "none", "pairs", "dict", "a", "1", "b", "2", "c", "3", "a", "1", "b", "2", "c", "3", "dict", "a", "1", "b", "2", "d", "4", "c", "3", "a", "1", "b", "2", "c", "3", "d", "4", "dict", "a", "1", "b", "2", "c", "3", "a", "1", "b", "2", "c", "3", "for", "code", "expected_value", "in", "pairs", "node", "extract_node", "code", "self", "assertinferdict", "node", "expected_value"], "doc_len": 64}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_dict_inference_unpack_repeated_key", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_dict_inference_unpack_repeated_key", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_dict_inference_unpack_repeated_key(self) -> None:\n        \"\"\"Make sure astroid does not infer repeated keys in a dictionary\n\n        Regression test for https://github.com/PyCQA/pylint/issues/1843\n        \"\"\"\n        code = \"\"\"\n        base = {'data': 0}\n        new = {**base, 'data': 1} #@\n        new2 = {'data': 1, **base} #@ # Make sure overwrite works\n        a = 'd' + 'ata'\n        b3 = {**base, a: 3} #@  Make sure keys are properly inferred\n        b4 = {a: 3, **base} #@\n        \"\"\"\n        ast = extract_node(code)\n        final_values = (\"{'data': 1}\", \"{'data': 0}\", \"{'data': 3}\", \"{'data': 0}\")\n        for node, final_value in zip(ast, final_values):\n            assert node.targets[0].inferred()[0].as_string() == final_value\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_dict_inference_unpack_repeated_key", "self", "none", "make", "sure", "astroid", "does", "not", "infer", "repeated", "keys", "in", "a", "dictionary", "regression", "test", "for", "https", "github", "com", "pycqa", "pylint", "issues", "1843", "code", "base", "data", "0", "new", "base", "data", "1", "new2", "data", "1", "base", "make", "sure", "overwrite", "works", "a", "d", "ata", "b3", "base", "a", "3", "make", "sure", "keys", "are", "properly", "inferred", "b4", "a", "3", "base", "ast", "extract_node", "code", "final_values", "data", "1", "data", "0", "data", "3", "data", "0", "for", "node", "final_value", "in", "zip", "ast", "final_values", "assert", "node", "targets", "0", "inferred", "0", "as_string", "final_value"], "doc_len": 89}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_dict_invalid_args", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_dict_invalid_args", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_dict_invalid_args(self) -> None:\n        invalid_values = [\"dict(*1)\", \"dict(**lala)\", \"dict(**[])\"]\n        for invalid in invalid_values:\n            ast_node = extract_node(invalid)\n            inferred = next(ast_node.infer())\n            self.assertIsInstance(inferred, Instance)\n            self.assertEqual(inferred.qname(), \"builtins.dict\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_dict_invalid_args", "self", "none", "invalid_values", "dict", "1", "dict", "lala", "dict", "for", "invalid", "in", "invalid_values", "ast_node", "extract_node", "invalid", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "qname", "builtins", "dict"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_str_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_str_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_str_methods(self) -> None:\n        code = \"\"\"\n        ' '.decode() #@\n        ' '.join('abcd') #@\n        ' '.replace('a', 'b') #@\n        ' '.format('a') #@\n        ' '.capitalize() #@\n        ' '.title() #@\n        ' '.lower() #@\n        ' '.upper() #@\n        ' '.swapcase() #@\n        ' '.strip() #@\n        ' '.rstrip() #@\n        ' '.lstrip() #@\n        ' '.rjust() #@\n        ' '.ljust() #@\n        ' '.center() #@\n\n        ' '.index() #@\n        ' '.find() #@\n        ' '.count() #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferConst(ast[0], \"\")\n        for i in range(1, 15):\n            self.assertInferConst(ast[i], \"\")\n        for i in range(15, 18):\n            self.assertInferConst(ast[i], 0)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_str_methods", "self", "none", "code", "decode", "join", "abcd", "replace", "a", "b", "format", "a", "capitalize", "title", "lower", "upper", "swapcase", "strip", "rstrip", "lstrip", "rjust", "ljust", "center", "index", "find", "count", "ast", "extract_node", "code", "__name__", "self", "assertinferconst", "ast", "0", "for", "i", "in", "range", "1", "15", "self", "assertinferconst", "ast", "i", "for", "i", "in", "range", "15", "18", "self", "assertinferconst", "ast", "i", "0"], "doc_len": 60}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unicode_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unicode_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unicode_methods(self) -> None:\n        code = \"\"\"\n        u' '.decode() #@\n        u' '.join('abcd') #@\n        u' '.replace('a', 'b') #@\n        u' '.format('a') #@\n        u' '.capitalize() #@\n        u' '.title() #@\n        u' '.lower() #@\n        u' '.upper() #@\n        u' '.swapcase() #@\n        u' '.strip() #@\n        u' '.rstrip() #@\n        u' '.lstrip() #@\n        u' '.rjust() #@\n        u' '.ljust() #@\n        u' '.center() #@\n\n        u' '.index() #@\n        u' '.find() #@\n        u' '.count() #@\n        \"\"\"\n        ast = extract_node(code, __name__)\n        self.assertInferConst(ast[0], \"\")\n        for i in range(1, 15):\n            self.assertInferConst(ast[i], \"\")\n        for i in range(15, 18):\n            self.assertInferConst(ast[i], 0)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unicode_methods", "self", "none", "code", "u", "decode", "u", "join", "abcd", "u", "replace", "a", "b", "u", "format", "a", "u", "capitalize", "u", "title", "u", "lower", "u", "upper", "u", "swapcase", "u", "strip", "u", "rstrip", "u", "lstrip", "u", "rjust", "u", "ljust", "u", "center", "u", "index", "u", "find", "u", "count", "ast", "extract_node", "code", "__name__", "self", "assertinferconst", "ast", "0", "for", "i", "in", "range", "1", "15", "self", "assertinferconst", "ast", "i", "for", "i", "in", "range", "15", "18", "self", "assertinferconst", "ast", "i", "0"], "doc_len": 78}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_scope_lookup_same_attributes", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_scope_lookup_same_attributes", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_scope_lookup_same_attributes(self) -> None:\n        code = \"\"\"\n        import collections\n        class Second(collections.Counter):\n            def collections(self):\n                return \"second\"\n\n        \"\"\"\n        ast = parse(code, __name__)\n        bases = ast[\"Second\"].bases[0]\n        inferred = next(bases.infer())\n        self.assertTrue(inferred)\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.qname(), \"collections.Counter\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_scope_lookup_same_attributes", "self", "none", "code", "import", "collections", "class", "second", "collections", "counter", "def", "collections", "self", "return", "second", "ast", "parse", "code", "__name__", "bases", "ast", "second", "bases", "0", "inferred", "next", "bases", "infer", "self", "asserttrue", "inferred", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "qname", "collections", "counter"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_with_statement_failures", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_with_statement_failures", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_with_statement_failures(self) -> None:\n        module = parse(\n            \"\"\"\n        class NoEnter(object):\n            pass\n        class NoMethod(object):\n            __enter__ = None\n        class NoElts(object):\n            def __enter__(self):\n                return 42\n\n        with NoEnter() as no_enter:\n            pass\n        with NoMethod() as no_method:\n            pass\n        with NoElts() as (no_elts, no_elts1):\n            pass\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, module[\"no_enter\"].infer())\n        self.assertRaises(InferenceError, next, module[\"no_method\"].infer())\n        self.assertRaises(InferenceError, next, module[\"no_elts\"].infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_with_statement_failures", "self", "none", "module", "parse", "class", "noenter", "object", "pass", "class", "nomethod", "object", "__enter__", "none", "class", "noelts", "object", "def", "__enter__", "self", "return", "42", "with", "noenter", "as", "no_enter", "pass", "with", "nomethod", "as", "no_method", "pass", "with", "noelts", "as", "no_elts", "no_elts1", "pass", "self", "assertraises", "inferenceerror", "next", "module", "no_enter", "infer", "self", "assertraises", "inferenceerror", "next", "module", "no_method", "infer", "self", "assertraises", "inferenceerror", "next", "module", "no_elts", "infer"], "doc_len": 64}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_with_statement", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_with_statement", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_with_statement(self) -> None:\n        module = parse(\n            \"\"\"\n        class SelfContext(object):\n            def __enter__(self):\n                return self\n\n        class OtherContext(object):\n            def __enter__(self):\n                return SelfContext()\n\n        class MultipleReturns(object):\n            def __enter__(self):\n                return SelfContext(), OtherContext()\n\n        class MultipleReturns2(object):\n            def __enter__(self):\n                return [1, [2, 3]]\n\n        with SelfContext() as self_context:\n            pass\n        with OtherContext() as other_context:\n            pass\n        with MultipleReturns(), OtherContext() as multiple_with:\n            pass\n        with MultipleReturns2() as (stdout, (stderr, stdin)):\n            pass\n        \"\"\"\n        )\n        self_context = module[\"self_context\"]\n        inferred = next(self_context.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"SelfContext\")\n\n        other_context = module[\"other_context\"]\n        inferred = next(other_context.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"SelfContext\")\n\n        multiple_with = module[\"multiple_with\"]\n        inferred = next(multiple_with.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"SelfContext\")\n\n        stdout = module[\"stdout\"]\n        inferred = next(stdout.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 1)\n        stderr = module[\"stderr\"]\n        inferred = next(stderr.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 2)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_with_statement", "self", "none", "module", "parse", "class", "selfcontext", "object", "def", "__enter__", "self", "return", "self", "class", "othercontext", "object", "def", "__enter__", "self", "return", "selfcontext", "class", "multiplereturns", "object", "def", "__enter__", "self", "return", "selfcontext", "othercontext", "class", "multiplereturns2", "object", "def", "__enter__", "self", "return", "1", "2", "3", "with", "selfcontext", "as", "self_context", "pass", "with", "othercontext", "as", "other_context", "pass", "with", "multiplereturns", "othercontext", "as", "multiple_with", "pass", "with", "multiplereturns2", "as", "stdout", "stderr", "stdin", "pass", "self_context", "module", "self_context", "inferred", "next", "self_context", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "selfcontext", "other_context", "module", "other_context", "inferred", "next", "other_context", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "selfcontext", "multiple_with", "module", "multiple_with", "inferred", "next", "multiple_with", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "selfcontext", "stdout", "module", "stdout", "inferred", "next", "stdout", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "1", "stderr", "module", "stderr", "inferred", "next", "stderr", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "2"], "doc_len": 150}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_with_contextlib_contextmanager", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_with_contextlib_contextmanager", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_with_contextlib_contextmanager(self) -> None:\n        module = parse(\n            \"\"\"\n        import contextlib\n        from contextlib import contextmanager\n\n        @contextlib.contextmanager\n        def manager_none():\n            try:\n                yield\n            finally:\n                pass\n\n        @contextlib.contextmanager\n        def manager_something():\n            try:\n                yield 42\n                yield 24 # This should be ignored.\n            finally:\n                pass\n\n        @contextmanager\n        def manager_multiple():\n            with manager_none() as foo:\n                with manager_something() as bar:\n                    yield foo, bar\n\n        with manager_none() as none:\n            pass\n        with manager_something() as something:\n            pass\n        with manager_multiple() as (first, second):\n            pass\n        \"\"\"\n        )\n        none = module[\"none\"]\n        inferred = next(none.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertIsNone(inferred.value)\n\n        something = module[\"something\"]\n        inferred = something.inferred()\n        self.assertEqual(len(inferred), 1)\n        inferred = inferred[0]\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n\n        first, second = module[\"first\"], module[\"second\"]\n        first = next(first.infer())\n        second = next(second.infer())\n        self.assertIsInstance(first, nodes.Const)\n        self.assertIsNone(first.value)\n        self.assertIsInstance(second, nodes.Const)\n        self.assertEqual(second.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_with_contextlib_contextmanager", "self", "none", "module", "parse", "import", "contextlib", "from", "contextlib", "import", "contextmanager", "contextlib", "contextmanager", "def", "manager_none", "try", "yield", "finally", "pass", "contextlib", "contextmanager", "def", "manager_something", "try", "yield", "42", "yield", "24", "this", "should", "be", "ignored", "finally", "pass", "contextmanager", "def", "manager_multiple", "with", "manager_none", "as", "foo", "with", "manager_something", "as", "bar", "yield", "foo", "bar", "with", "manager_none", "as", "none", "pass", "with", "manager_something", "as", "something", "pass", "with", "manager_multiple", "as", "first", "second", "pass", "none", "module", "none", "inferred", "next", "none", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertisnone", "inferred", "value", "something", "module", "something", "inferred", "something", "inferred", "self", "assertequal", "len", "inferred", "1", "inferred", "inferred", "0", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42", "first", "second", "module", "first", "module", "second", "first", "next", "first", "infer", "second", "next", "second", "infer", "self", "assertisinstance", "first", "nodes", "const", "self", "assertisnone", "first", "value", "self", "assertisinstance", "second", "nodes", "const", "self", "assertequal", "second", "value", "42"], "doc_len": 142}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_context_manager_skip_index_error", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_context_manager_skip_index_error", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_context_manager_skip_index_error(self) -> None:\n        # Raise an InferenceError when having multiple 'as' bindings\n        # from a context manager, but its result doesn't have those\n        # indices. This is the case of contextlib.nested, where the\n        # result is a list, which is mutated later on, so it's\n        # undetected by astroid.\n        module = parse(\n            \"\"\"\n        class Manager(object):\n            def __enter__(self):\n                return []\n        with Manager() as (a, b, c):\n            pass\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, module[\"a\"].infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_context_manager_skip_index_error", "self", "none", "raise", "an", "inferenceerror", "when", "having", "multiple", "as", "bindings", "from", "a", "context", "manager", "but", "its", "result", "doesn", "t", "have", "those", "indices", "this", "is", "the", "case", "of", "contextlib", "nested", "where", "the", "result", "is", "a", "list", "which", "is", "mutated", "later", "on", "so", "it", "s", "undetected", "by", "astroid", "module", "parse", "class", "manager", "object", "def", "__enter__", "self", "return", "with", "manager", "as", "a", "b", "c", "pass", "self", "assertraises", "inferenceerror", "next", "module", "a", "infer"], "doc_len": 75}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_context_manager_unpacking_inference_error", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_context_manager_unpacking_inference_error", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_context_manager_unpacking_inference_error(self) -> None:\n        # https://github.com/PyCQA/pylint/issues/1463\n        module = parse(\n            \"\"\"\n        import contextlib\n\n        @contextlib.contextmanager\n        def _select_source(a=None):\n            with _select_source() as result:\n                yield result\n\n        result = _select_source()\n        with result as (a, b, c):\n            pass\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, module[\"a\"].infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_context_manager_unpacking_inference_error", "self", "none", "https", "github", "com", "pycqa", "pylint", "issues", "1463", "module", "parse", "import", "contextlib", "contextlib", "contextmanager", "def", "_select_source", "a", "none", "with", "_select_source", "as", "result", "yield", "result", "result", "_select_source", "with", "result", "as", "a", "b", "c", "pass", "self", "assertraises", "inferenceerror", "next", "module", "a", "infer"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inferring_with_contextlib_contextmanager_failures", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inferring_with_contextlib_contextmanager_failures", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inferring_with_contextlib_contextmanager_failures(self) -> None:\n        module = parse(\n            \"\"\"\n        from contextlib import contextmanager\n\n        def no_decorators_mgr():\n            yield\n        @no_decorators_mgr\n        def other_decorators_mgr():\n            yield\n        @contextmanager\n        def no_yield_mgr():\n            pass\n\n        with no_decorators_mgr() as no_decorators:\n            pass\n        with other_decorators_mgr() as other_decorators:\n            pass\n        with no_yield_mgr() as no_yield:\n            pass\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, module[\"no_decorators\"].infer())\n        self.assertRaises(InferenceError, next, module[\"other_decorators\"].infer())\n        self.assertRaises(InferenceError, next, module[\"no_yield\"].infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inferring_with_contextlib_contextmanager_failures", "self", "none", "module", "parse", "from", "contextlib", "import", "contextmanager", "def", "no_decorators_mgr", "yield", "no_decorators_mgr", "def", "other_decorators_mgr", "yield", "contextmanager", "def", "no_yield_mgr", "pass", "with", "no_decorators_mgr", "as", "no_decorators", "pass", "with", "other_decorators_mgr", "as", "other_decorators", "pass", "with", "no_yield_mgr", "as", "no_yield", "pass", "self", "assertraises", "inferenceerror", "next", "module", "no_decorators", "infer", "self", "assertraises", "inferenceerror", "next", "module", "other_decorators", "infer", "self", "assertraises", "inferenceerror", "next", "module", "no_yield", "infer"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_nested_contextmanager", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_nested_contextmanager", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_nested_contextmanager(self) -> None:\n        \"\"\"Make sure contextmanager works with nested functions\n\n        Previously contextmanager would retrieve\n        the first yield instead of the yield in the\n        proper scope\n\n        Fixes https://github.com/PyCQA/pylint/issues/1746\n        \"\"\"\n        code = \"\"\"\n        from contextlib import contextmanager\n\n        @contextmanager\n        def outer():\n            @contextmanager\n            def inner():\n                yield 2\n            yield inner\n\n        with outer() as ctx:\n            ctx #@\n            with ctx() as val:\n                val #@\n        \"\"\"\n        context_node, value_node = extract_node(code)\n        value = next(value_node.infer())\n        context = next(context_node.infer())\n        assert isinstance(context, nodes.FunctionDef)\n        assert isinstance(value, nodes.Const)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_nested_contextmanager", "self", "none", "make", "sure", "contextmanager", "works", "with", "nested", "functions", "previously", "contextmanager", "would", "retrieve", "the", "first", "yield", "instead", "of", "the", "yield", "in", "the", "proper", "scope", "fixes", "https", "github", "com", "pycqa", "pylint", "issues", "1746", "code", "from", "contextlib", "import", "contextmanager", "contextmanager", "def", "outer", "contextmanager", "def", "inner", "yield", "2", "yield", "inner", "with", "outer", "as", "ctx", "ctx", "with", "ctx", "as", "val", "val", "context_node", "value_node", "extract_node", "code", "value", "next", "value_node", "infer", "context", "next", "context_node", "infer", "assert", "isinstance", "context", "nodes", "functiondef", "assert", "isinstance", "value", "nodes", "const"], "doc_len": 85}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_leaks_stop_iteration", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_leaks_stop_iteration", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_leaks_stop_iteration(self) -> None:\n        node = extract_node(\"+[] #@\")\n        self.assertEqual(util.Uninferable, next(node.infer()))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_leaks_stop_iteration", "self", "none", "node", "extract_node", "self", "assertequal", "util", "uninferable", "next", "node", "infer"], "doc_len": 17}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_operands", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_operands", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_operands(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        import os\n        def func(): pass\n        from missing import missing\n        class GoodInstance(object):\n            def __pos__(self):\n                return 42\n            def __neg__(self):\n                return +self - 41\n            def __invert__(self):\n                return 42\n        class BadInstance(object):\n            def __pos__(self):\n                return lala\n            def __neg__(self):\n                return missing\n        class LambdaInstance(object):\n            __pos__ = lambda self: self.lala\n            __neg__ = lambda self: self.lala + 1\n            @property\n            def lala(self): return 24\n        class InstanceWithAttr(object):\n            def __init__(self):\n                self.x = 42\n            def __pos__(self):\n                return self.x\n            def __neg__(self):\n                return +self - 41\n            def __invert__(self):\n                return self.x + 1\n        instance = GoodInstance()\n        lambda_instance = LambdaInstance()\n        instance_with_attr = InstanceWithAttr()\n        +instance #@\n        -instance #@\n        ~instance #@\n        --instance #@\n        +lambda_instance #@\n        -lambda_instance #@\n        +instance_with_attr #@\n        -instance_with_attr #@\n        ~instance_with_attr #@\n\n        bad_instance = BadInstance()\n        +bad_instance #@\n        -bad_instance #@\n        ~bad_instance #@\n\n        # These should be TypeErrors.\n        ~BadInstance #@\n        ~os #@\n        -func #@\n        +BadInstance #@\n        \"\"\"\n        )\n        expected = [42, 1, 42, -1, 24, 25, 42, 1, 43]\n        for node, value in zip(ast_nodes[:9], expected):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, value)\n\n        for bad_node in ast_nodes[9:]:\n            inferred = next(bad_node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_operands", "self", "none", "ast_nodes", "extract_node", "import", "os", "def", "func", "pass", "from", "missing", "import", "missing", "class", "goodinstance", "object", "def", "__pos__", "self", "return", "42", "def", "__neg__", "self", "return", "self", "41", "def", "__invert__", "self", "return", "42", "class", "badinstance", "object", "def", "__pos__", "self", "return", "lala", "def", "__neg__", "self", "return", "missing", "class", "lambdainstance", "object", "__pos__", "lambda", "self", "self", "lala", "__neg__", "lambda", "self", "self", "lala", "1", "property", "def", "lala", "self", "return", "24", "class", "instancewithattr", "object", "def", "__init__", "self", "self", "x", "42", "def", "__pos__", "self", "return", "self", "x", "def", "__neg__", "self", "return", "self", "41", "def", "__invert__", "self", "return", "self", "x", "1", "instance", "goodinstance", "lambda_instance", "lambdainstance", "instance_with_attr", "instancewithattr", "instance", "instance", "instance", "instance", "lambda_instance", "lambda_instance", "instance_with_attr", "instance_with_attr", "instance_with_attr", "bad_instance", "badinstance", "bad_instance", "bad_instance", "bad_instance", "these", "should", "be", "typeerrors", "badinstance", "os", "func", "badinstance", "expected", "42", "1", "42", "1", "24", "25", "42", "1", "43", "for", "node", "value", "in", "zip", "ast_nodes", "9", "expected", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "value", "for", "bad_node", "in", "ast_nodes", "9", "inferred", "next", "bad_node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 173}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_instance_method_not_callable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_instance_method_not_callable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_instance_method_not_callable(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A:\n            __pos__ = (i for i in range(10))\n        +A() #@\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, ast_node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_instance_method_not_callable", "self", "none", "ast_node", "extract_node", "class", "a", "__pos__", "i", "for", "i", "in", "range", "10", "a", "self", "assertraises", "inferenceerror", "next", "ast_node", "infer"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binary_op_type_errors", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binary_op_type_errors", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binary_op_type_errors(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        import collections\n        1 + \"a\" #@\n        1 - [] #@\n        1 * {} #@\n        1 / collections #@\n        1 ** (lambda x: x) #@\n        {} * {} #@\n        {} - {} #@\n        {} >> {} #@\n        [] + () #@\n        () + [] #@\n        [] * 2.0 #@\n        () * 2.0 #@\n        2.0 >> 2.0 #@\n        class A(object): pass\n        class B(object): pass\n        A() + B() #@\n        class A1(object):\n            def __add__(self, other): return NotImplemented\n        A1() + A1() #@\n        class A(object):\n            def __add__(self, other): return NotImplemented\n        class B(object):\n            def __radd__(self, other): return NotImplemented\n        A() + B() #@\n        class Parent(object):\n            pass\n        class Child(Parent):\n            def __add__(self, other): return NotImplemented\n        Child() + Parent() #@\n        class A(object):\n            def __add__(self, other): return NotImplemented\n        class B(A):\n            def __radd__(self, other):\n                 return NotImplemented\n        A() + B() #@\n        # Augmented\n        f = 1\n        f+=A() #@\n        x = 1\n        x+=[] #@\n        \"\"\"\n        )\n        msg = \"unsupported operand type(s) for {op}: {lhs!r} and {rhs!r}\"\n        expected = [\n            msg.format(op=\"+\", lhs=\"int\", rhs=\"str\"),\n            msg.format(op=\"-\", lhs=\"int\", rhs=\"list\"),\n            msg.format(op=\"*\", lhs=\"int\", rhs=\"dict\"),\n            msg.format(op=\"/\", lhs=\"int\", rhs=\"module\"),\n            msg.format(op=\"**\", lhs=\"int\", rhs=\"function\"),\n            msg.format(op=\"*\", lhs=\"dict\", rhs=\"dict\"),\n            msg.format(op=\"-\", lhs=\"dict\", rhs=\"dict\"),\n            msg.format(op=\">>\", lhs=\"dict\", rhs=\"dict\"),\n            msg.format(op=\"+\", lhs=\"list\", rhs=\"tuple\"),\n            msg.format(op=\"+\", lhs=\"tuple\", rhs=\"list\"),\n            msg.format(op=\"*\", lhs=\"list\", rhs=\"float\"),\n            msg.format(op=\"*\", lhs=\"tuple\", rhs=\"float\"),\n            msg.format(op=\">>\", lhs=\"float\", rhs=\"float\"),\n            msg.format(op=\"+\", lhs=\"A\", rhs=\"B\"),\n            msg.format(op=\"+\", lhs=\"A1\", rhs=\"A1\"),\n            msg.format(op=\"+\", lhs=\"A\", rhs=\"B\"),\n            msg.format(op=\"+\", lhs=\"Child\", rhs=\"Parent\"),\n            msg.format(op=\"+\", lhs=\"A\", rhs=\"B\"),\n            msg.format(op=\"+=\", lhs=\"int\", rhs=\"A\"),\n            msg.format(op=\"+=\", lhs=\"int\", rhs=\"list\"),\n        ]\n\n        # PEP-584 supports | for dictionary union\n        if not PY39_PLUS:\n            ast_nodes.append(extract_node(\"{} | {} #@\"))\n            expected.append(msg.format(op=\"|\", lhs=\"dict\", rhs=\"dict\"))\n\n        for node, expected_value in zip(ast_nodes, expected):\n            errors = node.type_errors()\n            self.assertEqual(len(errors), 1)\n            error = errors[0]\n            self.assertEqual(str(error), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binary_op_type_errors", "self", "none", "ast_nodes", "extract_node", "import", "collections", "1", "a", "1", "1", "1", "collections", "1", "lambda", "x", "x", "2", "0", "2", "0", "2", "0", "2", "0", "class", "a", "object", "pass", "class", "b", "object", "pass", "a", "b", "class", "a1", "object", "def", "__add__", "self", "other", "return", "notimplemented", "a1", "a1", "class", "a", "object", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "class", "parent", "object", "pass", "class", "child", "parent", "def", "__add__", "self", "other", "return", "notimplemented", "child", "parent", "class", "a", "object", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "a", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "augmented", "f", "1", "f", "a", "x", "1", "x", "msg", "unsupported", "operand", "type", "s", "for", "op", "lhs", "r", "and", "rhs", "r", "expected", "msg", "format", "op", "lhs", "int", "rhs", "str", "msg", "format", "op", "lhs", "int", "rhs", "list", "msg", "format", "op", "lhs", "int", "rhs", "dict", "msg", "format", "op", "lhs", "int", "rhs", "module", "msg", "format", "op", "lhs", "int", "rhs", "function", "msg", "format", "op", "lhs", "dict", "rhs", "dict", "msg", "format", "op", "lhs", "dict", "rhs", "dict", "msg", "format", "op", "lhs", "dict", "rhs", "dict", "msg", "format", "op", "lhs", "list", "rhs", "tuple", "msg", "format", "op", "lhs", "tuple", "rhs", "list", "msg", "format", "op", "lhs", "list", "rhs", "float", "msg", "format", "op", "lhs", "tuple", "rhs", "float", "msg", "format", "op", "lhs", "float", "rhs", "float", "msg", "format", "op", "lhs", "a", "rhs", "b", "msg", "format", "op", "lhs", "a1", "rhs", "a1", "msg", "format", "op", "lhs", "a", "rhs", "b", "msg", "format", "op", "lhs", "child", "rhs", "parent", "msg", "format", "op", "lhs", "a", "rhs", "b", "msg", "format", "op", "lhs", "int", "rhs", "a", "msg", "format", "op", "lhs", "int", "rhs", "list", "pep", "584", "supports", "for", "dictionary", "union", "if", "not", "py39_plus", "ast_nodes", "append", "extract_node", "expected", "append", "msg", "format", "op", "lhs", "dict", "rhs", "dict", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "errors", "node", "type_errors", "self", "assertequal", "len", "errors", "1", "error", "errors", "0", "self", "assertequal", "str", "error", "expected_value"], "doc_len": 311}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_type_errors", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_type_errors", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_type_errors(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        import collections\n        ~[] #@\n        ~() #@\n        ~dict() #@\n        ~{} #@\n        ~set() #@\n        -set() #@\n        -\"\" #@\n        ~\"\" #@\n        +\"\" #@\n        class A(object): pass\n        ~(lambda: None) #@\n        ~A #@\n        ~A() #@\n        ~collections #@\n        ~2.0 #@\n        \"\"\"\n        )\n        msg = \"bad operand type for unary {op}: {type}\"\n        expected = [\n            msg.format(op=\"~\", type=\"list\"),\n            msg.format(op=\"~\", type=\"tuple\"),\n            msg.format(op=\"~\", type=\"dict\"),\n            msg.format(op=\"~\", type=\"dict\"),\n            msg.format(op=\"~\", type=\"set\"),\n            msg.format(op=\"-\", type=\"set\"),\n            msg.format(op=\"-\", type=\"str\"),\n            msg.format(op=\"~\", type=\"str\"),\n            msg.format(op=\"+\", type=\"str\"),\n            msg.format(op=\"~\", type=\"<lambda>\"),\n            msg.format(op=\"~\", type=\"A\"),\n            msg.format(op=\"~\", type=\"A\"),\n            msg.format(op=\"~\", type=\"collections\"),\n            msg.format(op=\"~\", type=\"float\"),\n        ]\n        for node, expected_value in zip(ast_nodes, expected):\n            errors = node.type_errors()\n            self.assertEqual(len(errors), 1)\n            error = errors[0]\n            self.assertEqual(str(error), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_type_errors", "self", "none", "ast_nodes", "extract_node", "import", "collections", "dict", "set", "set", "class", "a", "object", "pass", "lambda", "none", "a", "a", "collections", "2", "0", "msg", "bad", "operand", "type", "for", "unary", "op", "type", "expected", "msg", "format", "op", "type", "list", "msg", "format", "op", "type", "tuple", "msg", "format", "op", "type", "dict", "msg", "format", "op", "type", "dict", "msg", "format", "op", "type", "set", "msg", "format", "op", "type", "set", "msg", "format", "op", "type", "str", "msg", "format", "op", "type", "str", "msg", "format", "op", "type", "str", "msg", "format", "op", "type", "lambda", "msg", "format", "op", "type", "a", "msg", "format", "op", "type", "a", "msg", "format", "op", "type", "collections", "msg", "format", "op", "type", "float", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "errors", "node", "type_errors", "self", "assertequal", "len", "errors", "1", "error", "errors", "0", "self", "assertequal", "str", "error", "expected_value"], "doc_len": 128}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_empty_type_errors", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_empty_type_errors", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_empty_type_errors(self) -> None:\n        # These aren't supported right now\n        ast_nodes = extract_node(\n            \"\"\"\n        ~(2 and []) #@\n        -(0 or {}) #@\n        \"\"\"\n        )\n        expected = [\n            \"bad operand type for unary ~: list\",\n            \"bad operand type for unary -: dict\",\n        ]\n        for node, expected_value in zip(ast_nodes, expected):\n            errors = node.type_errors()\n            self.assertEqual(len(errors), 1, (expected, node))\n            self.assertEqual(str(errors[0]), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_empty_type_errors", "self", "none", "these", "aren", "t", "supported", "right", "now", "ast_nodes", "extract_node", "2", "and", "0", "or", "expected", "bad", "operand", "type", "for", "unary", "list", "bad", "operand", "type", "for", "unary", "dict", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "errors", "node", "type_errors", "self", "assertequal", "len", "errors", "1", "expected", "node", "self", "assertequal", "str", "errors", "0", "expected_value"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_type_errors_for_non_instance_objects", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_type_errors_for_non_instance_objects", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_type_errors_for_non_instance_objects(self) -> None:\n        node = extract_node(\"~slice(1, 2, 3)\")\n        errors = node.type_errors()\n        self.assertEqual(len(errors), 1)\n        self.assertEqual(str(errors[0]), \"bad operand type for unary ~: slice\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_type_errors_for_non_instance_objects", "self", "none", "node", "extract_node", "slice", "1", "2", "3", "errors", "node", "type_errors", "self", "assertequal", "len", "errors", "1", "self", "assertequal", "str", "errors", "0", "bad", "operand", "type", "for", "unary", "slice"], "doc_len": 33}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bool_value_recursive", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bool_value_recursive", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bool_value_recursive(self) -> None:\n        pairs = [\n            (\"{}\", False),\n            (\"{1:2}\", True),\n            (\"()\", False),\n            (\"(1, 2)\", True),\n            (\"[]\", False),\n            (\"[1,2]\", True),\n            (\"frozenset()\", False),\n            (\"frozenset((1, 2))\", True),\n        ]\n        for code, expected in pairs:\n            node = extract_node(code)\n            inferred = next(node.infer())\n            self.assertEqual(inferred.bool_value(), expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bool_value_recursive", "self", "none", "pairs", "false", "1", "2", "true", "false", "1", "2", "true", "false", "1", "2", "true", "frozenset", "false", "frozenset", "1", "2", "true", "for", "code", "expected", "in", "pairs", "node", "extract_node", "code", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "bool_value", "expected"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_genexpr_bool_value", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_genexpr_bool_value", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_genexpr_bool_value(self) -> None:\n        node = extract_node(\"\"\"(x for x in range(10))\"\"\")\n        self.assertTrue(node.bool_value())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_genexpr_bool_value", "self", "none", "node", "extract_node", "x", "for", "x", "in", "range", "10", "self", "asserttrue", "node", "bool_value"], "doc_len": 20}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_name_bool_value", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_name_bool_value", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_name_bool_value(self) -> None:\n        node = extract_node(\n            \"\"\"\n        x = 42\n        y = x\n        y\n        \"\"\"\n        )\n        self.assertIs(node.bool_value(), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_name_bool_value", "self", "none", "node", "extract_node", "x", "42", "y", "x", "y", "self", "assertis", "node", "bool_value", "util", "uninferable"], "doc_len": 21}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bool_value", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bool_value", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bool_value(self) -> None:\n        # Verify the truth value of nodes.\n        module = parse(\n            \"\"\"\n        import collections\n        collections_module = collections\n        def function(): pass\n        class Class(object):\n            def method(self): pass\n        dict_comp = {x:y for (x, y) in ((1, 2), (2, 3))}\n        set_comp = {x for x in range(10)}\n        list_comp = [x for x in range(10)]\n        lambda_func = lambda: None\n        unbound_method = Class.method\n        instance = Class()\n        bound_method = instance.method\n        def generator_func():\n             yield\n        def true_value():\n             return True\n        generator = generator_func()\n        bin_op = 1 + 2\n        bool_op = x and y\n        callfunc = test()\n        good_callfunc = true_value()\n        compare = 2 < 3\n        const_str_true = 'testconst'\n        const_str_false = ''\n        \"\"\"\n        )\n        collections_module = next(module[\"collections_module\"].infer())\n        self.assertTrue(collections_module.bool_value())\n        function = module[\"function\"]\n        self.assertTrue(function.bool_value())\n        klass = module[\"Class\"]\n        self.assertTrue(klass.bool_value())\n        dict_comp = next(module[\"dict_comp\"].infer())\n        self.assertEqual(dict_comp, util.Uninferable)\n        set_comp = next(module[\"set_comp\"].infer())\n        self.assertEqual(set_comp, util.Uninferable)\n        list_comp = next(module[\"list_comp\"].infer())\n        self.assertEqual(list_comp, util.Uninferable)\n        lambda_func = next(module[\"lambda_func\"].infer())\n        self.assertTrue(lambda_func)\n        unbound_method = next(module[\"unbound_method\"].infer())\n        self.assertTrue(unbound_method)\n        bound_method = next(module[\"bound_method\"].infer())\n        self.assertTrue(bound_method)\n        generator = next(module[\"generator\"].infer())\n        self.assertTrue(generator)\n        bin_op = module[\"bin_op\"].parent.value\n        self.assertIs(bin_op.bool_value(), util.Uninferable)\n        bool_op = module[\"bool_op\"].parent.value\n        self.assertEqual(bool_op.bool_value(), util.Uninferable)\n        callfunc = module[\"callfunc\"].parent.value\n        self.assertEqual(callfunc.bool_value(), util.Uninferable)\n        good_callfunc = next(module[\"good_callfunc\"].infer())\n        self.assertTrue(good_callfunc.bool_value())\n        compare = module[\"compare\"].parent.value\n        self.assertEqual(compare.bool_value(), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bool_value", "self", "none", "verify", "the", "truth", "value", "of", "nodes", "module", "parse", "import", "collections", "collections_module", "collections", "def", "function", "pass", "class", "class", "object", "def", "method", "self", "pass", "dict_comp", "x", "y", "for", "x", "y", "in", "1", "2", "2", "3", "set_comp", "x", "for", "x", "in", "range", "10", "list_comp", "x", "for", "x", "in", "range", "10", "lambda_func", "lambda", "none", "unbound_method", "class", "method", "instance", "class", "bound_method", "instance", "method", "def", "generator_func", "yield", "def", "true_value", "return", "true", "generator", "generator_func", "bin_op", "1", "2", "bool_op", "x", "and", "y", "callfunc", "test", "good_callfunc", "true_value", "compare", "2", "3", "const_str_true", "testconst", "const_str_false", "collections_module", "next", "module", "collections_module", "infer", "self", "asserttrue", "collections_module", "bool_value", "function", "module", "function", "self", "asserttrue", "function", "bool_value", "klass", "module", "class", "self", "asserttrue", "klass", "bool_value", "dict_comp", "next", "module", "dict_comp", "infer", "self", "assertequal", "dict_comp", "util", "uninferable", "set_comp", "next", "module", "set_comp", "infer", "self", "assertequal", "set_comp", "util", "uninferable", "list_comp", "next", "module", "list_comp", "infer", "self", "assertequal", "list_comp", "util", "uninferable", "lambda_func", "next", "module", "lambda_func", "infer", "self", "asserttrue", "lambda_func", "unbound_method", "next", "module", "unbound_method", "infer", "self", "asserttrue", "unbound_method", "bound_method", "next", "module", "bound_method", "infer", "self", "asserttrue", "bound_method", "generator", "next", "module", "generator", "infer", "self", "asserttrue", "generator", "bin_op", "module", "bin_op", "parent", "value", "self", "assertis", "bin_op", "bool_value", "util", "uninferable", "bool_op", "module", "bool_op", "parent", "value", "self", "assertequal", "bool_op", "bool_value", "util", "uninferable", "callfunc", "module", "callfunc", "parent", "value", "self", "assertequal", "callfunc", "bool_value", "util", "uninferable", "good_callfunc", "next", "module", "good_callfunc", "infer", "self", "asserttrue", "good_callfunc", "bool_value", "compare", "module", "compare", "parent", "value", "self", "assertequal", "compare", "bool_value", "util", "uninferable"], "doc_len": 230}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bool_value_instances", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bool_value_instances", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bool_value_instances(self) -> None:\n        instances = extract_node(\n            f\"\"\"\n        class FalseBoolInstance(object):\n            def {BOOL_SPECIAL_METHOD}(self):\n                return False\n        class TrueBoolInstance(object):\n            def {BOOL_SPECIAL_METHOD}(self):\n                return True\n        class FalseLenInstance(object):\n            def __len__(self):\n                return 0\n        class TrueLenInstance(object):\n            def __len__(self):\n                return 14\n        class AlwaysTrueInstance(object):\n            pass\n        class ErrorInstance(object):\n            def __bool__(self):\n                return lala\n            def __len__(self):\n                return lala\n        class NonMethods(object):\n            __bool__ = 1\n            __len__ = 2\n        FalseBoolInstance() #@\n        TrueBoolInstance() #@\n        FalseLenInstance() #@\n        TrueLenInstance() #@\n        AlwaysTrueInstance() #@\n        ErrorInstance() #@\n        \"\"\"\n        )\n        expected = (False, True, False, True, True, util.Uninferable, util.Uninferable)\n        for node, expected_value in zip(instances, expected):\n            inferred = next(node.infer())\n            self.assertEqual(inferred.bool_value(), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bool_value_instances", "self", "none", "instances", "extract_node", "f", "class", "falseboolinstance", "object", "def", "bool_special_method", "self", "return", "false", "class", "trueboolinstance", "object", "def", "bool_special_method", "self", "return", "true", "class", "falseleninstance", "object", "def", "__len__", "self", "return", "0", "class", "trueleninstance", "object", "def", "__len__", "self", "return", "14", "class", "alwaystrueinstance", "object", "pass", "class", "errorinstance", "object", "def", "__bool__", "self", "return", "lala", "def", "__len__", "self", "return", "lala", "class", "nonmethods", "object", "__bool__", "1", "__len__", "2", "falseboolinstance", "trueboolinstance", "falseleninstance", "trueleninstance", "alwaystrueinstance", "errorinstance", "expected", "false", "true", "false", "true", "true", "util", "uninferable", "util", "uninferable", "for", "node", "expected_value", "in", "zip", "instances", "expected", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "bool_value", "expected_value"], "doc_len": 99}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bool_value_variable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bool_value_variable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bool_value_variable(self) -> None:\n        instance = extract_node(\n            f\"\"\"\n        class VariableBoolInstance(object):\n            def __init__(self, value):\n                self.value = value\n            def {BOOL_SPECIAL_METHOD}(self):\n                return self.value\n\n        not VariableBoolInstance(True)\n        \"\"\"\n        )\n        inferred = next(instance.infer())\n        self.assertIs(inferred.bool_value(), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bool_value_variable", "self", "none", "instance", "extract_node", "f", "class", "variableboolinstance", "object", "def", "__init__", "self", "value", "self", "value", "value", "def", "bool_special_method", "self", "return", "self", "value", "not", "variableboolinstance", "true", "inferred", "next", "instance", "infer", "self", "assertis", "inferred", "bool_value", "util", "uninferable"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_coercion_rules_for_floats_complex", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_coercion_rules_for_floats_complex", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_coercion_rules_for_floats_complex(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        1 + 1.0 #@\n        1 * 1.0 #@\n        2 - 1.0 #@\n        2 / 2.0 #@\n        1 + 1j #@\n        2 * 1j #@\n        2 - 1j #@\n        3 / 1j #@\n        \"\"\"\n        )\n        expected_values = [2.0, 1.0, 1.0, 1.0, 1 + 1j, 2j, 2 - 1j, -3j]\n        for node, expected in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertEqual(inferred.value, expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_coercion_rules_for_floats_complex", "self", "none", "ast_nodes", "extract_node", "1", "1", "0", "1", "1", "0", "2", "1", "0", "2", "2", "0", "1", "1j", "2", "1j", "2", "1j", "3", "1j", "expected_values", "2", "0", "1", "0", "1", "0", "1", "0", "1", "1j", "2j", "2", "1j", "3j", "for", "node", "expected", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "value", "expected"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_list_with_elts", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_list_with_elts", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_list_with_elts(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        x = [A] * 1\n        [1] + x\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.List)\n        self.assertEqual(len(inferred.elts), 2)\n        self.assertIsInstance(inferred.elts[0], nodes.Const)\n        self.assertIsInstance(inferred.elts[1], nodes.Unknown)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_list_with_elts", "self", "none", "ast_node", "extract_node", "x", "a", "1", "1", "x", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "list", "self", "assertequal", "len", "inferred", "elts", "2", "self", "assertisinstance", "inferred", "elts", "0", "nodes", "const", "self", "assertisinstance", "inferred", "elts", "1", "nodes", "unknown"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_same_types", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_same_types", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_same_types(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other):\n                return 42\n        1 + 1 #@\n        1 - 1 #@\n        \"a\" + \"b\" #@\n        A() + A() #@\n        \"\"\"\n        )\n        expected_values = [2, 0, \"ab\", 42]\n        for node, expected in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_same_types", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "42", "1", "1", "1", "1", "a", "b", "a", "a", "expected_values", "2", "0", "ab", "42", "for", "node", "expected", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_different_types_reflected_only", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_different_types_reflected_only", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_different_types_reflected_only(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        class B(object):\n            def __radd__(self, other):\n                return other\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_different_types_reflected_only", "self", "none", "node", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "def", "__radd__", "self", "other", "return", "other", "a", "b", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_different_types_unknown_bases", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_different_types_unknown_bases", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_different_types_unknown_bases(self) -> None:\n        node = extract_node(\n            \"\"\"\n        from foo import bar\n\n        class A(bar):\n            pass\n        class B(object):\n            def __radd__(self, other):\n                return other\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIs(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_different_types_unknown_bases", "self", "none", "node", "extract_node", "from", "foo", "import", "bar", "class", "a", "bar", "pass", "class", "b", "object", "def", "__radd__", "self", "other", "return", "other", "a", "b", "inferred", "next", "node", "infer", "self", "assertis", "inferred", "util", "uninferable"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_different_types_normal_not_implemented_and_reflected", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_different_types_normal_not_implemented_and_reflected", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_different_types_normal_not_implemented_and_reflected(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other):\n                return NotImplemented\n        class B(object):\n            def __radd__(self, other):\n                return other\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_different_types_normal_not_implemented_and_reflected", "self", "none", "node", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__radd__", "self", "other", "return", "other", "a", "b", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_different_types_no_method_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_different_types_no_method_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_different_types_no_method_implemented(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        class B(object): pass\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_different_types_no_method_implemented", "self", "none", "node", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "a", "b", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_different_types_reflected_and_normal_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_different_types_reflected_and_normal_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_different_types_reflected_and_normal_not_implemented(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other): return NotImplemented\n        class B(object):\n            def __radd__(self, other): return NotImplemented\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_different_types_reflected_and_normal_not_implemented", "self", "none", "node", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_subtype", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_subtype", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_subtype(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(A):\n            def __add__(self, other): return other\n        B() + A() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_subtype", "self", "none", "node", "extract_node", "class", "a", "object", "pass", "class", "b", "a", "def", "__add__", "self", "other", "return", "other", "b", "a", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_subtype_implemented_in_parent", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_subtype_implemented_in_parent", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_subtype_implemented_in_parent(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other): return other\n        class B(A): pass\n        B() + A() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_subtype_implemented_in_parent", "self", "none", "node", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "other", "class", "b", "a", "pass", "b", "a", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_subtype_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_subtype_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_subtype_not_implemented(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        class B(A):\n            def __add__(self, other): return NotImplemented\n        B() + A() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_subtype_not_implemented", "self", "none", "node", "extract_node", "class", "a", "object", "pass", "class", "b", "a", "def", "__add__", "self", "other", "return", "notimplemented", "b", "a", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_supertype", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_supertype", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_supertype(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        class B(A):\n            def __radd__(self, other):\n                 return other\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_supertype", "self", "none", "node", "extract_node", "class", "a", "object", "pass", "class", "b", "a", "def", "__radd__", "self", "other", "return", "other", "a", "b", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_supertype_rop_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_supertype_rop_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_supertype_rop_not_implemented(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other):\n                return other\n        class B(A):\n            def __radd__(self, other):\n                 return NotImplemented\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_supertype_rop_not_implemented", "self", "none", "node", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "other", "class", "b", "a", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "b"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_supertype_both_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_supertype_both_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_supertype_both_not_implemented(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self): return NotImplemented\n        class B(A):\n            def __radd__(self, other):\n                 return NotImplemented\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_supertype_both_not_implemented", "self", "none", "node", "extract_node", "class", "a", "object", "def", "__add__", "self", "return", "notimplemented", "class", "b", "a", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_inference_errors", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_inference_errors", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_inference_errors(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from unknown import Unknown\n        class A(object):\n           def __add__(self, other): return NotImplemented\n        class B(object):\n           def __add__(self, other): return Unknown\n        A() + Unknown #@\n        Unknown + A() #@\n        B() + A() #@\n        A() + B() #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertEqual(next(node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_inference_errors", "self", "none", "ast_nodes", "extract_node", "from", "unknown", "import", "unknown", "class", "a", "object", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__add__", "self", "other", "return", "unknown", "a", "unknown", "unknown", "a", "b", "a", "a", "b", "for", "node", "in", "ast_nodes", "self", "assertequal", "next", "node", "infer", "util", "uninferable"], "doc_len": 51}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_binop_ambiguity", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_binop_ambiguity", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_binop_ambiguity(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n           def __add__(self, other):\n               if isinstance(other, B):\n                    return NotImplemented\n               if type(other) is type(self):\n                    return 42\n               return NotImplemented\n        class B(A): pass\n        class C(object):\n           def __radd__(self, other):\n               if isinstance(other, B):\n                   return 42\n               return NotImplemented\n        A() + B() #@\n        B() + A() #@\n        A() + C() #@\n        C() + A() #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertEqual(next(node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_binop_ambiguity", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "if", "isinstance", "other", "b", "return", "notimplemented", "if", "type", "other", "is", "type", "self", "return", "42", "return", "notimplemented", "class", "b", "a", "pass", "class", "c", "object", "def", "__radd__", "self", "other", "if", "isinstance", "other", "b", "return", "42", "return", "notimplemented", "a", "b", "b", "a", "a", "c", "c", "a", "for", "node", "in", "ast_nodes", "self", "assertequal", "next", "node", "infer", "util", "uninferable"], "doc_len": 71}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass__getitem__", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass__getitem__", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass__getitem__(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Meta(type):\n            def __getitem__(cls, arg):\n                return 24\n        class A(object, metaclass=Meta):\n            pass\n\n        A['Awesome'] #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 24)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass__getitem__", "self", "none", "ast_node", "extract_node", "class", "meta", "type", "def", "__getitem__", "cls", "arg", "return", "24", "class", "a", "object", "metaclass", "meta", "pass", "a", "awesome", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "24"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_with_metaclass__getitem__", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_with_metaclass__getitem__", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_with_metaclass__getitem__(self):\n        ast_node = extract_node(\n            \"\"\"\n        class Meta(type):\n            def __getitem__(cls, arg):\n                return 24\n        import six\n        class A(six.with_metaclass(Meta)):\n            pass\n\n        A['Awesome'] #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 24)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_with_metaclass__getitem__", "self", "ast_node", "extract_node", "class", "meta", "type", "def", "__getitem__", "cls", "arg", "return", "24", "import", "six", "class", "a", "six", "with_metaclass", "meta", "pass", "a", "awesome", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "24"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bin_op_classes", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bin_op_classes", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bin_op_classes(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Meta(type):\n            def __or__(self, other):\n                return 24\n        class A(object, metaclass=Meta):\n            pass\n\n        A | A\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 24)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bin_op_classes", "self", "none", "ast_node", "extract_node", "class", "meta", "type", "def", "__or__", "self", "other", "return", "24", "class", "a", "object", "metaclass", "meta", "pass", "a", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "24"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bin_op_classes_with_metaclass", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bin_op_classes_with_metaclass", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bin_op_classes_with_metaclass(self):\n        ast_node = extract_node(\n            \"\"\"\n        class Meta(type):\n            def __or__(self, other):\n                return 24\n        import six\n        class A(six.with_metaclass(Meta)):\n            pass\n\n        A | A\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 24)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bin_op_classes_with_metaclass", "self", "ast_node", "extract_node", "class", "meta", "type", "def", "__or__", "self", "other", "return", "24", "import", "six", "class", "a", "six", "with_metaclass", "meta", "pass", "a", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "24"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_bin_op_supertype_more_complicated_example", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_bin_op_supertype_more_complicated_example", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_bin_op_supertype_more_complicated_example(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __init__(self):\n                self.foo = 42\n            def __add__(self, other):\n                return other.bar + self.foo / 2\n\n        class B(A):\n            def __init__(self):\n                self.bar = 24\n        def __radd__(self, other):\n            return NotImplemented\n\n        A() + B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(int(inferred.value), 45)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_bin_op_supertype_more_complicated_example", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__init__", "self", "self", "foo", "42", "def", "__add__", "self", "other", "return", "other", "bar", "self", "foo", "2", "class", "b", "a", "def", "__init__", "self", "self", "bar", "24", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "int", "inferred", "value", "45"], "doc_len": 61}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_same_type_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_same_type_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_same_type_not_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return NotImplemented\n        A() + A() #@\n        \"\"\"\n        )\n        self.assertEqual(next(ast_node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_same_type_not_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "notimplemented", "a", "a", "self", "assertequal", "next", "ast_node", "infer", "util", "uninferable"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_same_type_aug_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_same_type_aug_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_same_type_aug_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return other\n        f = A()\n        f += A() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_same_type_aug_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "other", "f", "a", "f", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_same_type_aug_not_implemented_normal_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_same_type_aug_not_implemented_normal_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_same_type_aug_not_implemented_normal_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return 42\n        f = A()\n        f += A() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_same_type_aug_not_implemented_normal_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "42", "f", "a", "f", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_subtype_both_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_subtype_both_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_subtype_both_not_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return NotImplemented\n        class B(A):\n            pass\n        b = B()\n        b+=A() #@\n        \"\"\"\n        )\n        self.assertEqual(next(ast_node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_subtype_both_not_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "a", "pass", "b", "b", "b", "a", "self", "assertequal", "next", "ast_node", "infer", "util", "uninferable"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_subtype_aug_op_is_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_subtype_aug_op_is_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_subtype_aug_op_is_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return 42\n        class B(A):\n            pass\n        b = B()\n        b+=A() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_subtype_aug_op_is_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "42", "class", "b", "a", "pass", "b", "b", "b", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_op_subtype_normal_op_is_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_op_subtype_normal_op_is_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_op_subtype_normal_op_is_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __add__(self, other): return 42\n        class B(A):\n            pass\n        b = B()\n        b+=A() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_op_subtype_normal_op_is_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__add__", "self", "other", "return", "42", "class", "b", "a", "pass", "b", "b", "b", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_different_types_no_method_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_different_types_no_method_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_different_types_no_method_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(object): pass\n        f = A()\n        f += B() #@\n        \"\"\"\n        )\n        self.assertEqual(next(ast_node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_different_types_no_method_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "f", "a", "f", "b", "self", "assertequal", "next", "ast_node", "infer", "util", "uninferable"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_different_types_augop_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_different_types_augop_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_different_types_augop_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return other\n        class B(object): pass\n        f = A()\n        f += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_different_types_augop_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "other", "class", "b", "object", "pass", "f", "a", "f", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "b"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_different_types_aug_not_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_different_types_aug_not_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_different_types_aug_not_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return other\n        class B(object): pass\n        f = A()\n        f += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_different_types_aug_not_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "other", "class", "b", "object", "pass", "f", "a", "f", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "b"], "doc_len": 46}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_aug_different_types_aug_not_implemented_rop_fallback", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_aug_different_types_aug_not_implemented_rop_fallback", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_aug_different_types_aug_not_implemented_rop_fallback(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return NotImplemented\n        class B(object):\n            def __radd__(self, other): return other\n        f = A()\n        f += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_aug_different_types_aug_not_implemented_rop_fallback", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__radd__", "self", "other", "return", "other", "f", "a", "f", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 51}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augop_supertypes_none_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augop_supertypes_none_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augop_supertypes_none_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(object): pass\n        a = A()\n        a += B() #@\n        \"\"\"\n        )\n        self.assertEqual(next(ast_node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augop_supertypes_none_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "a", "a", "a", "b", "self", "assertequal", "next", "ast_node", "infer", "util", "uninferable"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augop_supertypes_not_implemented_returned_for_all", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augop_supertypes_not_implemented_returned_for_all", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augop_supertypes_not_implemented_returned_for_all(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return NotImplemented\n        class B(object):\n            def __add__(self, other): return NotImplemented\n        a = A()\n        a += B() #@\n        \"\"\"\n        )\n        self.assertEqual(next(ast_node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augop_supertypes_not_implemented_returned_for_all", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "notimplemented", "class", "b", "object", "def", "__add__", "self", "other", "return", "notimplemented", "a", "a", "a", "b", "self", "assertequal", "next", "ast_node", "infer", "util", "uninferable"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augop_supertypes_augop_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augop_supertypes_augop_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augop_supertypes_augop_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return other\n        class B(A): pass\n        a = A()\n        a += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augop_supertypes_augop_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "other", "class", "b", "a", "pass", "a", "a", "a", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "b"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augop_supertypes_reflected_binop_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augop_supertypes_reflected_binop_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augop_supertypes_reflected_binop_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n        class B(A):\n            def __radd__(self, other): return other\n        a = A()\n        a += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augop_supertypes_reflected_binop_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "class", "b", "a", "def", "__radd__", "self", "other", "return", "other", "a", "a", "a", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "a"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_augop_supertypes_normal_binop_implemented", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_augop_supertypes_normal_binop_implemented", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_augop_supertypes_normal_binop_implemented(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __iadd__(self, other): return NotImplemented\n            def __add__(self, other): return other\n        class B(A):\n            def __radd__(self, other): return NotImplemented\n\n        a = A()\n        a += B() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_augop_supertypes_normal_binop_implemented", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__iadd__", "self", "other", "return", "notimplemented", "def", "__add__", "self", "other", "return", "other", "class", "b", "a", "def", "__radd__", "self", "other", "return", "notimplemented", "a", "a", "a", "b", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "b"], "doc_len": 51}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_string_interpolation", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_string_interpolation", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_string_interpolation(self):\n        ast_nodes = extract_node(\n            \"\"\"\n        \"a%d%d\" % (1, 2) #@\n        \"a%(x)s\" % {\"x\": 42} #@\n        \"\"\"\n        )\n        expected = [\"a12\", \"a42\"]\n        for node, expected_value in zip(ast_nodes, expected):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_string_interpolation", "self", "ast_nodes", "extract_node", "a", "d", "d", "1", "2", "a", "x", "s", "x", "42", "expected", "a12", "a42", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_mul_list_supports__index__", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_mul_list_supports__index__", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_mul_list_supports__index__(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class Index(object):\n            def __index__(self): return 2\n        class NotIndex(object): pass\n        class NotIndex2(object):\n            def __index__(self): return None\n        a = [1, 2]\n        a * Index() #@\n        a * NotIndex() #@\n        a * NotIndex2() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.List)\n        self.assertEqual([node.value for node in first.itered()], [1, 2, 1, 2])\n        for rest in ast_nodes[1:]:\n            inferred = next(rest.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_mul_list_supports__index__", "self", "none", "ast_nodes", "extract_node", "class", "index", "object", "def", "__index__", "self", "return", "2", "class", "notindex", "object", "pass", "class", "notindex2", "object", "def", "__index__", "self", "return", "none", "a", "1", "2", "a", "index", "a", "notindex", "a", "notindex2", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "list", "self", "assertequal", "node", "value", "for", "node", "in", "first", "itered", "1", "2", "1", "2", "for", "rest", "in", "ast_nodes", "1", "inferred", "next", "rest", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 80}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_subscript_supports__index__", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_subscript_supports__index__", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_subscript_supports__index__(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class Index(object):\n            def __index__(self): return 2\n        class LambdaIndex(object):\n            __index__ = lambda self: self.foo\n            @property\n            def foo(self): return 1\n        class NonIndex(object):\n            __index__ = lambda self: None\n        a = [1, 2, 3, 4]\n        a[Index()] #@\n        a[LambdaIndex()] #@\n        a[NonIndex()] #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.Const)\n        self.assertEqual(first.value, 3)\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, nodes.Const)\n        self.assertEqual(second.value, 2)\n        self.assertRaises(InferenceError, next, ast_nodes[2].infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_subscript_supports__index__", "self", "none", "ast_nodes", "extract_node", "class", "index", "object", "def", "__index__", "self", "return", "2", "class", "lambdaindex", "object", "__index__", "lambda", "self", "self", "foo", "property", "def", "foo", "self", "return", "1", "class", "nonindex", "object", "__index__", "lambda", "self", "none", "a", "1", "2", "3", "4", "a", "index", "a", "lambdaindex", "a", "nonindex", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "const", "self", "assertequal", "first", "value", "3", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "nodes", "const", "self", "assertequal", "second", "value", "2", "self", "assertraises", "inferenceerror", "next", "ast_nodes", "2", "infer"], "doc_len": 91}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_special_method_masquerading_as_another", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_special_method_masquerading_as_another", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_special_method_masquerading_as_another(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Info(object):\n            def __add__(self, other):\n                return \"lala\"\n            __or__ = __add__\n\n        f = Info()\n        f | Info() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, \"lala\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_special_method_masquerading_as_another", "self", "none", "ast_node", "extract_node", "class", "info", "object", "def", "__add__", "self", "other", "return", "lala", "__or__", "__add__", "f", "info", "f", "info", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "lala"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_assignment", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_assignment", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_assignment(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object): pass\n        def pos(self):\n            return 42\n        A.__pos__ = pos\n        f = A()\n        +f #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_assignment", "self", "none", "ast_node", "extract_node", "class", "a", "object", "pass", "def", "pos", "self", "return", "42", "a", "__pos__", "pos", "f", "a", "f", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_classes", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_classes", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_classes(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Meta(type):\n            def __invert__(self):\n                return 42\n        class A(object, metaclass=Meta):\n            pass\n        ~A\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_classes", "self", "none", "ast_node", "extract_node", "class", "meta", "type", "def", "__invert__", "self", "return", "42", "class", "a", "object", "metaclass", "meta", "pass", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_unary_op_classes_with_metaclass", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_unary_op_classes_with_metaclass", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_unary_op_classes_with_metaclass(self):\n        ast_node = extract_node(\n            \"\"\"\n        import six\n        class Meta(type):\n            def __invert__(self):\n                return 42\n        class A(six.with_metaclass(Meta)):\n            pass\n        ~A\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_unary_op_classes_with_metaclass", "self", "ast_node", "extract_node", "import", "six", "class", "meta", "type", "def", "__invert__", "self", "return", "42", "class", "a", "six", "with_metaclass", "meta", "pass", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest._slicing_test_helper", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "_slicing_test_helper", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def _slicing_test_helper(\n        self,\n        pairs: Tuple[\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n            Tuple[str, Union[List[int], str]],\n        ],\n        cls: Union[ABCMeta, type],\n        get_elts: Callable,\n    ) -> None:\n        for code, expected in pairs:\n            ast_node = extract_node(code)\n            inferred = next(ast_node.infer())\n            self.assertIsInstance(inferred, cls)\n            self.assertEqual(get_elts(inferred), expected, ast_node.as_string())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "_slicing_test_helper", "self", "pairs", "tuple", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "tuple", "str", "union", "list", "int", "str", "cls", "union", "abcmeta", "type", "get_elts", "callable", "none", "for", "code", "expected", "in", "pairs", "ast_node", "extract_node", "code", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "cls", "self", "assertequal", "get_elts", "inferred", "expected", "ast_node", "as_string"], "doc_len": 99}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_slicing_list", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_slicing_list", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_slicing_list(self) -> None:\n        pairs = (\n            (\"[1, 2, 3][:] #@\", [1, 2, 3]),\n            (\"[1, 2, 3][0:] #@\", [1, 2, 3]),\n            (\"[1, 2, 3][None:] #@\", [1, 2, 3]),\n            (\"[1, 2, 3][None:None] #@\", [1, 2, 3]),\n            (\"[1, 2, 3][0:-1] #@\", [1, 2]),\n            (\"[1, 2, 3][0:2] #@\", [1, 2]),\n            (\"[1, 2, 3][0:2:None] #@\", [1, 2]),\n            (\"[1, 2, 3][::] #@\", [1, 2, 3]),\n            (\"[1, 2, 3][::2] #@\", [1, 3]),\n            (\"[1, 2, 3][::-1] #@\", [3, 2, 1]),\n            (\"[1, 2, 3][0:2:2] #@\", [1]),\n            (\"[1, 2, 3, 4, 5, 6][0:4-1:2+0] #@\", [1, 3]),\n        )\n        self._slicing_test_helper(\n            pairs, nodes.List, lambda inferred: [elt.value for elt in inferred.elts]\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_slicing_list", "self", "none", "pairs", "1", "2", "3", "1", "2", "3", "1", "2", "3", "0", "1", "2", "3", "1", "2", "3", "none", "1", "2", "3", "1", "2", "3", "none", "none", "1", "2", "3", "1", "2", "3", "0", "1", "1", "2", "1", "2", "3", "0", "2", "1", "2", "1", "2", "3", "0", "2", "none", "1", "2", "1", "2", "3", "1", "2", "3", "1", "2", "3", "2", "1", "3", "1", "2", "3", "1", "3", "2", "1", "1", "2", "3", "0", "2", "2", "1", "1", "2", "3", "4", "5", "6", "0", "4", "1", "2", "0", "1", "3", "self", "_slicing_test_helper", "pairs", "nodes", "list", "lambda", "inferred", "elt", "value", "for", "elt", "in", "inferred", "elts"], "doc_len": 112}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_slicing_tuple", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_slicing_tuple", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_slicing_tuple(self) -> None:\n        pairs = (\n            (\"(1, 2, 3)[:] #@\", [1, 2, 3]),\n            (\"(1, 2, 3)[0:] #@\", [1, 2, 3]),\n            (\"(1, 2, 3)[None:] #@\", [1, 2, 3]),\n            (\"(1, 2, 3)[None:None] #@\", [1, 2, 3]),\n            (\"(1, 2, 3)[0:-1] #@\", [1, 2]),\n            (\"(1, 2, 3)[0:2] #@\", [1, 2]),\n            (\"(1, 2, 3)[0:2:None] #@\", [1, 2]),\n            (\"(1, 2, 3)[::] #@\", [1, 2, 3]),\n            (\"(1, 2, 3)[::2] #@\", [1, 3]),\n            (\"(1, 2, 3)[::-1] #@\", [3, 2, 1]),\n            (\"(1, 2, 3)[0:2:2] #@\", [1]),\n            (\"(1, 2, 3, 4, 5, 6)[0:4-1:2+0] #@\", [1, 3]),\n        )\n        self._slicing_test_helper(\n            pairs, nodes.Tuple, lambda inferred: [elt.value for elt in inferred.elts]\n        )\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_slicing_tuple", "self", "none", "pairs", "1", "2", "3", "1", "2", "3", "1", "2", "3", "0", "1", "2", "3", "1", "2", "3", "none", "1", "2", "3", "1", "2", "3", "none", "none", "1", "2", "3", "1", "2", "3", "0", "1", "1", "2", "1", "2", "3", "0", "2", "1", "2", "1", "2", "3", "0", "2", "none", "1", "2", "1", "2", "3", "1", "2", "3", "1", "2", "3", "2", "1", "3", "1", "2", "3", "1", "3", "2", "1", "1", "2", "3", "0", "2", "2", "1", "1", "2", "3", "4", "5", "6", "0", "4", "1", "2", "0", "1", "3", "self", "_slicing_test_helper", "pairs", "nodes", "tuple", "lambda", "inferred", "elt", "value", "for", "elt", "in", "inferred", "elts"], "doc_len": 112}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_slicing_str", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_slicing_str", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_slicing_str(self) -> None:\n        pairs = (\n            (\"'123'[:] #@\", \"123\"),\n            (\"'123'[0:] #@\", \"123\"),\n            (\"'123'[None:] #@\", \"123\"),\n            (\"'123'[None:None] #@\", \"123\"),\n            (\"'123'[0:-1] #@\", \"12\"),\n            (\"'123'[0:2] #@\", \"12\"),\n            (\"'123'[0:2:None] #@\", \"12\"),\n            (\"'123'[::] #@\", \"123\"),\n            (\"'123'[::2] #@\", \"13\"),\n            (\"'123'[::-1] #@\", \"321\"),\n            (\"'123'[0:2:2] #@\", \"1\"),\n            (\"'123456'[0:4-1:2+0] #@\", \"13\"),\n        )\n        self._slicing_test_helper(pairs, nodes.Const, lambda inferred: inferred.value)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_slicing_str", "self", "none", "pairs", "123", "123", "123", "0", "123", "123", "none", "123", "123", "none", "none", "123", "123", "0", "1", "12", "123", "0", "2", "12", "123", "0", "2", "none", "12", "123", "123", "123", "2", "13", "123", "1", "321", "123", "0", "2", "2", "1", "123456", "0", "4", "1", "2", "0", "13", "self", "_slicing_test_helper", "pairs", "nodes", "const", "lambda", "inferred", "inferred", "value"], "doc_len": 63}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_invalid_slicing_primaries", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_invalid_slicing_primaries", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_invalid_slicing_primaries(self) -> None:\n        examples = [\n            \"(lambda x: x)[1:2]\",\n            \"1[2]\",\n            \"(1, 2, 3)[a:]\",\n            \"(1, 2, 3)[object:object]\",\n            \"(1, 2, 3)[1:object]\",\n            \"enumerate[2]\",\n        ]\n        for code in examples:\n            node = extract_node(code)\n            self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_invalid_slicing_primaries", "self", "none", "examples", "lambda", "x", "x", "1", "2", "1", "2", "1", "2", "3", "a", "1", "2", "3", "object", "object", "1", "2", "3", "1", "object", "enumerate", "2", "for", "code", "in", "examples", "node", "extract_node", "code", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_slicing", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_slicing", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_slicing(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def __getitem__(self, index):\n                return [1, 2, 3, 4, 5][index]\n        A()[1:] #@\n        A()[:2] #@\n        A()[1:4] #@\n        \"\"\"\n        )\n        expected_values = [[2, 3, 4, 5], [1, 2], [2, 3, 4]]\n        for expected, node in zip(expected_values, ast_nodes):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.List)\n            self.assertEqual([elt.value for elt in inferred.elts], expected)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_slicing", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "__getitem__", "self", "index", "return", "1", "2", "3", "4", "5", "index", "a", "1", "a", "2", "a", "1", "4", "expected_values", "2", "3", "4", "5", "1", "2", "2", "3", "4", "for", "expected", "node", "in", "zip", "expected_values", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "list", "self", "assertequal", "elt", "value", "for", "elt", "in", "inferred", "elts", "expected"], "doc_len": 67}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_slicing_slices", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_slicing_slices", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_slicing_slices(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            def __getitem__(self, index):\n                return index\n        A()[1:] #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Slice)\n        self.assertEqual(inferred.lower.value, 1)\n        self.assertIsNone(inferred.upper)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_slicing_slices", "self", "none", "ast_node", "extract_node", "class", "a", "object", "def", "__getitem__", "self", "index", "return", "index", "a", "1", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "slice", "self", "assertequal", "inferred", "lower", "value", "1", "self", "assertisnone", "inferred", "upper"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_instance_slicing_fails", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_instance_slicing_fails", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_instance_slicing_fails(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def __getitem__(self, index):\n                return 1[index]\n        A()[4:5] #@\n        A()[2:] #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertEqual(next(node.infer()), util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_instance_slicing_fails", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "__getitem__", "self", "index", "return", "1", "index", "a", "4", "5", "a", "2", "for", "node", "in", "ast_nodes", "self", "assertequal", "next", "node", "infer", "util", "uninferable"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__with_metaclass", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__with_metaclass", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__with_metaclass(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Metaclass(type):\n            pass\n        class Entity(object):\n             pass\n        type.__new__(Metaclass, 'NewClass', (Entity,), {'a': 1}) #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"NewClass\")\n        metaclass = inferred.metaclass()\n        self.assertEqual(metaclass, inferred.root()[\"Metaclass\"])\n        ancestors = list(inferred.ancestors())\n        self.assertEqual(len(ancestors), 2)\n        self.assertEqual(ancestors[0], inferred.root()[\"Entity\"])\n        attributes = inferred.getattr(\"a\")\n        self.assertEqual(len(attributes), 1)\n        self.assertIsInstance(attributes[0], nodes.Const)\n        self.assertEqual(attributes[0].value, 1)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__with_metaclass", "self", "none", "ast_node", "extract_node", "class", "metaclass", "type", "pass", "class", "entity", "object", "pass", "type", "__new__", "metaclass", "newclass", "entity", "a", "1", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "newclass", "metaclass", "inferred", "metaclass", "self", "assertequal", "metaclass", "inferred", "root", "metaclass", "ancestors", "list", "inferred", "ancestors", "self", "assertequal", "len", "ancestors", "2", "self", "assertequal", "ancestors", "0", "inferred", "root", "entity", "attributes", "inferred", "getattr", "a", "self", "assertequal", "len", "attributes", "1", "self", "assertisinstance", "attributes", "0", "nodes", "const", "self", "assertequal", "attributes", "0", "value", "1"], "doc_len": 85}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__not_enough_arguments", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__not_enough_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__not_enough_arguments(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        type.__new__(type, 'foo') #@\n        type.__new__(type, 'foo', ()) #@\n        type.__new__(type, 'foo', (), {}, ()) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            with pytest.raises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__not_enough_arguments", "self", "none", "ast_nodes", "extract_node", "type", "__new__", "type", "foo", "type", "__new__", "type", "foo", "type", "__new__", "type", "foo", "for", "node", "in", "ast_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 33}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__invalid_mcs_argument", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__invalid_mcs_argument", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__invalid_mcs_argument(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class Class(object): pass\n        type.__new__(1, 2, 3, 4) #@\n        type.__new__(Class, 2, 3, 4) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            with pytest.raises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__invalid_mcs_argument", "self", "none", "ast_nodes", "extract_node", "class", "class", "object", "pass", "type", "__new__", "1", "2", "3", "4", "type", "__new__", "class", "2", "3", "4", "for", "node", "in", "ast_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__invalid_name", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__invalid_name", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__invalid_name(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class Class(type): pass\n        type.__new__(Class, object, 1, 2) #@\n        type.__new__(Class, 1, 1, 2) #@\n        type.__new__(Class, [], 1, 2) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            with pytest.raises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__invalid_name", "self", "none", "ast_nodes", "extract_node", "class", "class", "type", "pass", "type", "__new__", "class", "object", "1", "2", "type", "__new__", "class", "1", "1", "2", "type", "__new__", "class", "1", "2", "for", "node", "in", "ast_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__invalid_bases", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__invalid_bases", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__invalid_bases(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        type.__new__(type, 'a', 1, 2) #@\n        type.__new__(type, 'a', [], 2) #@\n        type.__new__(type, 'a', {}, 2) #@\n        type.__new__(type, 'a', (1, ), 2) #@\n        type.__new__(type, 'a', (object, 1), 2) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            with pytest.raises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__invalid_bases", "self", "none", "ast_nodes", "extract_node", "type", "__new__", "type", "a", "1", "2", "type", "__new__", "type", "a", "2", "type", "__new__", "type", "a", "2", "type", "__new__", "type", "a", "1", "2", "type", "__new__", "type", "a", "object", "1", "2", "for", "node", "in", "ast_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer"], "doc_len": 50}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__invalid_attrs", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__invalid_attrs", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__invalid_attrs(self) -> None:\n        type_error_nodes = extract_node(\n            \"\"\"\n        type.__new__(type, 'a', (), ()) #@\n        type.__new__(type, 'a', (), object) #@\n        type.__new__(type, 'a', (), 1) #@\n        \"\"\"\n        )\n        for node in type_error_nodes:\n            with pytest.raises(InferenceError):\n                next(node.infer())\n\n        # Ignore invalid keys\n        ast_nodes = extract_node(\n            \"\"\"\n            type.__new__(type, 'a', (), {object: 1}) #@\n            type.__new__(type, 'a', (), {1:2, \"a\":5}) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.ClassDef)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__invalid_attrs", "self", "none", "type_error_nodes", "extract_node", "type", "__new__", "type", "a", "type", "__new__", "type", "a", "object", "type", "__new__", "type", "a", "1", "for", "node", "in", "type_error_nodes", "with", "pytest", "raises", "inferenceerror", "next", "node", "infer", "ignore", "invalid", "keys", "ast_nodes", "extract_node", "type", "__new__", "type", "a", "object", "1", "type", "__new__", "type", "a", "1", "2", "a", "5", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef"], "doc_len": 67}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__metaclass_lookup", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__metaclass_lookup", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__metaclass_lookup(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Metaclass(type):\n            def test(cls): pass\n            @classmethod\n            def test1(cls): pass\n            attr = 42\n        type.__new__(Metaclass, 'A', (), {}) #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        test = inferred.getattr(\"test\")\n        self.assertEqual(len(test), 1)\n        self.assertIsInstance(test[0], BoundMethod)\n        self.assertIsInstance(test[0].bound, nodes.ClassDef)\n        self.assertEqual(test[0].bound, inferred)\n        test1 = inferred.getattr(\"test1\")\n        self.assertEqual(len(test1), 1)\n        self.assertIsInstance(test1[0], BoundMethod)\n        self.assertIsInstance(test1[0].bound, nodes.ClassDef)\n        self.assertEqual(test1[0].bound, inferred.metaclass())\n        attr = inferred.getattr(\"attr\")\n        self.assertEqual(len(attr), 1)\n        self.assertIsInstance(attr[0], nodes.Const)\n        self.assertEqual(attr[0].value, 42)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__metaclass_lookup", "self", "none", "ast_node", "extract_node", "class", "metaclass", "type", "def", "test", "cls", "pass", "classmethod", "def", "test1", "cls", "pass", "attr", "42", "type", "__new__", "metaclass", "a", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "test", "inferred", "getattr", "test", "self", "assertequal", "len", "test", "1", "self", "assertisinstance", "test", "0", "boundmethod", "self", "assertisinstance", "test", "0", "bound", "nodes", "classdef", "self", "assertequal", "test", "0", "bound", "inferred", "test1", "inferred", "getattr", "test1", "self", "assertequal", "len", "test1", "1", "self", "assertisinstance", "test1", "0", "boundmethod", "self", "assertisinstance", "test1", "0", "bound", "nodes", "classdef", "self", "assertequal", "test1", "0", "bound", "inferred", "metaclass", "attr", "inferred", "getattr", "attr", "self", "assertequal", "len", "attr", "1", "self", "assertisinstance", "attr", "0", "nodes", "const", "self", "assertequal", "attr", "0", "value", "42"], "doc_len": 113}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_type__new__metaclass_and_ancestors_lookup", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_type__new__metaclass_and_ancestors_lookup", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_type__new__metaclass_and_ancestors_lookup(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Book(object):\n             title = 'Ubik'\n        class MetaBook(type):\n             title = 'Grimus'\n        type.__new__(MetaBook, 'book', (Book, ), {'title':'Catch 22'}) #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        titles = [\n            title.value\n            for attr in inferred.getattr(\"title\")\n            for title in attr.inferred()\n        ]\n        self.assertEqual(titles, [\"Catch 22\", \"Ubik\", \"Grimus\"])\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_type__new__metaclass_and_ancestors_lookup", "self", "none", "ast_node", "extract_node", "class", "book", "object", "title", "ubik", "class", "metabook", "type", "title", "grimus", "type", "__new__", "metabook", "book", "book", "title", "catch", "22", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "titles", "title", "value", "for", "attr", "in", "inferred", "getattr", "title", "for", "title", "in", "attr", "inferred", "self", "assertequal", "titles", "catch", "22", "ubik", "grimus"], "doc_len": 58}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_function_metaclasses", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_function_metaclasses", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_function_metaclasses(self):\n        # These are not supported right now, although\n        # they will be in the future.\n        ast_node = extract_node(\n            \"\"\"\n        class BookMeta(type):\n            author = 'Rushdie'\n\n        def metaclass_function(*args):\n            return BookMeta\n\n        class Book(object, metaclass=metaclass_function):\n            pass\n        Book #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        metaclass = inferred.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertEqual(metaclass.name, \"BookMeta\")\n        author = next(inferred.igetattr(\"author\"))\n        self.assertIsInstance(author, nodes.Const)\n        self.assertEqual(author.value, \"Rushdie\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_function_metaclasses", "self", "these", "are", "not", "supported", "right", "now", "although", "they", "will", "be", "in", "the", "future", "ast_node", "extract_node", "class", "bookmeta", "type", "author", "rushdie", "def", "metaclass_function", "args", "return", "bookmeta", "class", "book", "object", "metaclass", "metaclass_function", "pass", "book", "inferred", "next", "ast_node", "infer", "metaclass", "inferred", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertequal", "metaclass", "name", "bookmeta", "author", "next", "inferred", "igetattr", "author", "self", "assertisinstance", "author", "nodes", "const", "self", "assertequal", "author", "value", "rushdie"], "doc_len": 71}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_subscript_inference_error", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_subscript_inference_error", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_subscript_inference_error(self) -> None:\n        # Used to raise StopIteration\n        ast_node = extract_node(\n            \"\"\"\n        class AttributeDict(dict):\n            def __getitem__(self, name):\n                return self\n        flow = AttributeDict()\n        flow['app'] = AttributeDict()\n        flow['app']['config'] = AttributeDict()\n        flow['app']['config']['doffing'] = AttributeDict() #@\n        \"\"\"\n        )\n        self.assertIsNone(helpers.safe_infer(ast_node.targets[0]))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_subscript_inference_error", "self", "none", "used", "to", "raise", "stopiteration", "ast_node", "extract_node", "class", "attributedict", "dict", "def", "__getitem__", "self", "name", "return", "self", "flow", "attributedict", "flow", "app", "attributedict", "flow", "app", "config", "attributedict", "flow", "app", "config", "doffing", "attributedict", "self", "assertisnone", "helpers", "safe_infer", "ast_node", "targets", "0"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_classmethod_inferred_by_context", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_classmethod_inferred_by_context", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_classmethod_inferred_by_context(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class Super(object):\n           def instance(cls):\n              return cls()\n           instance = classmethod(instance)\n\n        class Sub(Super):\n            def method(self):\n                return self\n\n        # should see the Sub.instance() is returning a Sub\n        # instance, not a Super instance\n        Sub.instance().method() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, Instance)\n        self.assertEqual(inferred.name, \"Sub\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_classmethod_inferred_by_context", "self", "none", "ast_node", "extract_node", "class", "super", "object", "def", "instance", "cls", "return", "cls", "instance", "classmethod", "instance", "class", "sub", "super", "def", "method", "self", "return", "self", "should", "see", "the", "sub", "instance", "is", "returning", "a", "sub", "instance", "not", "a", "super", "instance", "sub", "instance", "method", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "instance", "self", "assertequal", "inferred", "name", "sub"], "doc_len": 59}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_call_result_invalid_dunder_call_on_instance", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_call_result_invalid_dunder_call_on_instance", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_call_result_invalid_dunder_call_on_instance(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A:\n            __call__ = 42\n        class B:\n            __call__ = A()\n        class C:\n            __call = None\n        A() #@\n        B() #@\n        C() #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertRaises(InferenceError, next, inferred.infer_call_result(node))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_call_result_invalid_dunder_call_on_instance", "self", "none", "ast_nodes", "extract_node", "class", "a", "__call__", "42", "class", "b", "__call__", "a", "class", "c", "__call", "none", "a", "b", "c", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertraises", "inferenceerror", "next", "inferred", "infer_call_result", "node"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_context_call_for_context_managers", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_context_call_for_context_managers", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_context_call_for_context_managers(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A:\n            def __enter__(self):\n                return self\n        class B:\n            __enter__ = lambda self: self\n        class C:\n            @property\n            def a(self): return A()\n            def __enter__(self):\n                return self.a\n        with A() as a:\n            a #@\n        with B() as b:\n            b #@\n        with C() as c:\n            c #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first_a = next(ast_nodes[0].infer())\n        self.assertIsInstance(first_a, Instance)\n        self.assertEqual(first_a.name, \"A\")\n        second_b = next(ast_nodes[1].infer())\n        self.assertIsInstance(second_b, Instance)\n        self.assertEqual(second_b.name, \"B\")\n        third_c = next(ast_nodes[2].infer())\n        self.assertIsInstance(third_c, Instance)\n        self.assertEqual(third_c.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_context_call_for_context_managers", "self", "none", "ast_nodes", "extract_node", "class", "a", "def", "__enter__", "self", "return", "self", "class", "b", "__enter__", "lambda", "self", "self", "class", "c", "property", "def", "a", "self", "return", "a", "def", "__enter__", "self", "return", "self", "a", "with", "a", "as", "a", "a", "with", "b", "as", "b", "b", "with", "c", "as", "c", "c", "assert", "isinstance", "ast_nodes", "list", "first_a", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first_a", "instance", "self", "assertequal", "first_a", "name", "a", "second_b", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second_b", "instance", "self", "assertequal", "second_b", "name", "b", "third_c", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third_c", "instance", "self", "assertequal", "third_c", "name", "a"], "doc_len": 98}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass_subclasses_arguments_are_classes_not_instances", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass_subclasses_arguments_are_classes_not_instances", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass_subclasses_arguments_are_classes_not_instances(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(type):\n            def test(cls):\n                return cls\n        class B(object, metaclass=A):\n            pass\n\n        B.test() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass_subclasses_arguments_are_classes_not_instances", "self", "none", "ast_node", "extract_node", "class", "a", "type", "def", "test", "cls", "return", "cls", "class", "b", "object", "metaclass", "a", "pass", "b", "test", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "b"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_with_metaclass_subclasses_arguments_are_classes_not_instances", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_with_metaclass_subclasses_arguments_are_classes_not_instances", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_with_metaclass_subclasses_arguments_are_classes_not_instances(self):\n        ast_node = extract_node(\n            \"\"\"\n        class A(type):\n            def test(cls):\n                return cls\n        import six\n        class B(six.with_metaclass(A)):\n            pass\n\n        B.test() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_with_metaclass_subclasses_arguments_are_classes_not_instances", "self", "ast_node", "extract_node", "class", "a", "type", "def", "test", "cls", "return", "cls", "import", "six", "class", "b", "six", "with_metaclass", "a", "pass", "b", "test", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "b"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_with_metaclass_with_partial_imported_name", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_with_metaclass_with_partial_imported_name", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_with_metaclass_with_partial_imported_name(self):\n        ast_node = extract_node(\n            \"\"\"\n        class A(type):\n            def test(cls):\n                return cls\n        from six import with_metaclass\n        class B(with_metaclass(A)):\n            pass\n\n        B.test() #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"B\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_with_metaclass_with_partial_imported_name", "self", "ast_node", "extract_node", "class", "a", "type", "def", "test", "cls", "return", "cls", "from", "six", "import", "with_metaclass", "class", "b", "with_metaclass", "a", "pass", "b", "test", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "b"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_cls_in_class_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_cls_in_class_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_cls_in_class_methods(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(type):\n            def __call__(cls):\n                cls #@\n        class B(object):\n            def __call__(cls):\n                cls #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.ClassDef)\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, Instance)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_cls_in_class_methods", "self", "none", "ast_nodes", "extract_node", "class", "a", "type", "def", "__call__", "cls", "cls", "class", "b", "object", "def", "__call__", "cls", "cls", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "classdef", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "instance"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass_arguments_are_classes_not_instances", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass_arguments_are_classes_not_instances", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass_arguments_are_classes_not_instances(self):\n        ast_node = extract_node(\n            \"\"\"\n        class A(type):\n            def test(cls): return cls\n        A.test() #@\n        \"\"\"\n        )\n        # This is not supported yet\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"A\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass_arguments_are_classes_not_instances", "self", "ast_node", "extract_node", "class", "a", "type", "def", "test", "cls", "return", "cls", "a", "test", "this", "is", "not", "supported", "yet", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass_with_keyword_args", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass_with_keyword_args", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass_with_keyword_args(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class TestMetaKlass(type):\n            def __new__(mcs, name, bases, ns, kwo_arg):\n                return super().__new__(mcs, name, bases, ns)\n\n        class TestKlass(metaclass=TestMetaKlass, kwo_arg=42): #@\n            pass\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass_with_keyword_args", "self", "none", "ast_node", "extract_node", "class", "testmetaklass", "type", "def", "__new__", "mcs", "name", "bases", "ns", "kwo_arg", "return", "super", "__new__", "mcs", "name", "bases", "ns", "class", "testklass", "metaclass", "testmetaklass", "kwo_arg", "42", "pass", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass_custom_dunder_call", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass_custom_dunder_call", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass_custom_dunder_call(self) -> None:\n        \"\"\"The Metaclass __call__ should take precedence\n        over the default metaclass type call (initialization)\n\n        See https://github.com/PyCQA/pylint/issues/2159\n        \"\"\"\n        val = (\n            extract_node(\n                \"\"\"\n        class _Meta(type):\n            def __call__(cls):\n                return 1\n        class Clazz(metaclass=_Meta):\n            def __call__(self):\n                return 5.5\n\n        Clazz() #@\n        \"\"\"\n            )\n            .inferred()[0]\n            .value\n        )\n        assert val == 1\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass_custom_dunder_call", "self", "none", "the", "metaclass", "__call__", "should", "take", "precedence", "over", "the", "default", "metaclass", "type", "call", "initialization", "see", "https", "github", "com", "pycqa", "pylint", "issues", "2159", "val", "extract_node", "class", "_meta", "type", "def", "__call__", "cls", "return", "1", "class", "clazz", "metaclass", "_meta", "def", "__call__", "self", "return", "5", "5", "clazz", "inferred", "0", "value", "assert", "val", "1"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_metaclass_custom_dunder_call_boundnode", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_metaclass_custom_dunder_call_boundnode", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_metaclass_custom_dunder_call_boundnode(self) -> None:\n        \"\"\"The boundnode should be the calling class\"\"\"\n        cls = extract_node(\n            \"\"\"\n        class _Meta(type):\n            def __call__(cls):\n                return cls\n        class Clazz(metaclass=_Meta):\n            pass\n        Clazz() #@\n        \"\"\"\n        ).inferred()[0]\n        assert isinstance(cls, nodes.ClassDef) and cls.name == \"Clazz\"\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_metaclass_custom_dunder_call_boundnode", "self", "none", "the", "boundnode", "should", "be", "the", "calling", "class", "cls", "extract_node", "class", "_meta", "type", "def", "__call__", "cls", "return", "cls", "class", "clazz", "metaclass", "_meta", "pass", "clazz", "inferred", "0", "assert", "isinstance", "cls", "nodes", "classdef", "and", "cls", "name", "clazz"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_subclass_attr_outer_class", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_subclass_attr_outer_class", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_subclass_attr_outer_class(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Outer:\n            data = 123\n\n        class Test(Outer):\n            pass\n        Test.data\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 123\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_subclass_attr_outer_class", "self", "none", "node", "extract_node", "class", "outer", "data", "123", "class", "test", "outer", "pass", "test", "data", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "123"], "doc_len": 33}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_subclass_attr_inner_class_works_indirectly", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_subclass_attr_inner_class_works_indirectly", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_subclass_attr_inner_class_works_indirectly(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Outer:\n            class Inner:\n                data = 123\n        Inner = Outer.Inner\n\n        class Test(Inner):\n            pass\n        Test.data\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 123\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_subclass_attr_inner_class_works_indirectly", "self", "none", "node", "extract_node", "class", "outer", "class", "inner", "data", "123", "inner", "outer", "inner", "class", "test", "inner", "pass", "test", "data", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "123"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_subclass_attr_inner_class", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_subclass_attr_inner_class", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_subclass_attr_inner_class(self) -> None:\n        clsdef_node, attr_node = extract_node(\n            \"\"\"\n        class Outer:\n            class Inner:\n                data = 123\n\n        class Test(Outer.Inner):\n            pass\n        Test  #@\n        Test.data  #@\n            \"\"\"\n        )\n        clsdef = next(clsdef_node.infer())\n        assert isinstance(clsdef, nodes.ClassDef)\n        inferred = next(clsdef.igetattr(\"data\"))\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 123\n        # Inferring the value of .data via igetattr() worked before the\n        # old_boundnode fixes in infer_subscript, so it should have been\n        # possible to infer the subscript directly. It is the difference\n        # between these two cases that led to the discovery of the cause of the\n        # bug in https://github.com/PyCQA/astroid/issues/904\n        inferred = next(attr_node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 123\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_subclass_attr_inner_class", "self", "none", "clsdef_node", "attr_node", "extract_node", "class", "outer", "class", "inner", "data", "123", "class", "test", "outer", "inner", "pass", "test", "test", "data", "clsdef", "next", "clsdef_node", "infer", "assert", "isinstance", "clsdef", "nodes", "classdef", "inferred", "next", "clsdef", "igetattr", "data", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "123", "inferring", "the", "value", "of", "data", "via", "igetattr", "worked", "before", "the", "old_boundnode", "fixes", "in", "infer_subscript", "so", "it", "should", "have", "been", "possible", "to", "infer", "the", "subscript", "directly", "it", "is", "the", "difference", "between", "these", "two", "cases", "that", "led", "to", "the", "discovery", "of", "the", "cause", "of", "the", "bug", "in", "https", "github", "com", "pycqa", "astroid", "issues", "904", "inferred", "next", "attr_node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "123"], "doc_len": 113}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_delayed_attributes_without_slots", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_delayed_attributes_without_slots", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_delayed_attributes_without_slots(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class A(object):\n            __slots__ = ('a', )\n        a = A()\n        a.teta = 24\n        a.a = 24\n        a #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        with self.assertRaises(NotFoundError):\n            inferred.getattr(\"teta\")\n        inferred.getattr(\"a\")\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_delayed_attributes_without_slots", "self", "none", "ast_node", "extract_node", "class", "a", "object", "__slots__", "a", "a", "a", "a", "teta", "24", "a", "a", "24", "a", "inferred", "next", "ast_node", "infer", "with", "self", "assertraises", "notfounderror", "inferred", "getattr", "teta", "inferred", "getattr", "a"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_lambda_as_methods", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_lambda_as_methods", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_lambda_as_methods(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class X:\n           m = lambda self, arg: self.z + arg\n           z = 24\n\n        X().m(4) #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 28)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_lambda_as_methods", "self", "none", "ast_node", "extract_node", "class", "x", "m", "lambda", "self", "arg", "self", "z", "arg", "z", "24", "x", "m", "4", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "28"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inner_value_redefined_by_subclass", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inner_value_redefined_by_subclass", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inner_value_redefined_by_subclass(self) -> None:\n        ast_node = extract_node(\n            \"\"\"\n        class X(object):\n            M = lambda self, arg: \"a\"\n            x = 24\n            def __init__(self):\n                x = 24\n                self.m = self.M(x)\n\n        class Y(X):\n            M = lambda self, arg: arg + 1\n            def blurb(self):\n                self.m #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 25)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inner_value_redefined_by_subclass", "self", "none", "ast_node", "extract_node", "class", "x", "object", "m", "lambda", "self", "arg", "a", "x", "24", "def", "__init__", "self", "x", "24", "self", "m", "self", "m", "x", "class", "y", "x", "m", "lambda", "self", "arg", "arg", "1", "def", "blurb", "self", "self", "m", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "25"], "doc_len": 58}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_inner_value_redefined_by_subclass_with_mro", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_inner_value_redefined_by_subclass_with_mro", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_inner_value_redefined_by_subclass_with_mro(self):\n        # This might work, but it currently doesn't due to not being able\n        # to reuse inference contexts.\n        ast_node = extract_node(\n            \"\"\"\n        class X(object):\n            M = lambda self, arg: arg + 1\n            x = 24\n            def __init__(self):\n                y = self\n                self.m = y.M(1) + y.z\n\n        class C(object):\n            z = 24\n\n        class Y(X, C):\n            M = lambda self, arg: arg + 1\n            def blurb(self):\n                self.m #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 25)\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_inner_value_redefined_by_subclass_with_mro", "self", "this", "might", "work", "but", "it", "currently", "doesn", "t", "due", "to", "not", "being", "able", "to", "reuse", "inference", "contexts", "ast_node", "extract_node", "class", "x", "object", "m", "lambda", "self", "arg", "arg", "1", "x", "24", "def", "__init__", "self", "y", "self", "self", "m", "y", "m", "1", "y", "z", "class", "c", "object", "z", "24", "class", "y", "x", "c", "m", "lambda", "self", "arg", "arg", "1", "def", "blurb", "self", "self", "m", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "25"], "doc_len": 83}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_getitem_of_class_raised_type_error", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_getitem_of_class_raised_type_error", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_getitem_of_class_raised_type_error(self) -> None:\n        # Test that we wrap an AttributeInferenceError\n        # and reraise it as a TypeError in Class.getitem\n        node = extract_node(\n            \"\"\"\n        def test():\n            yield\n        test()\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        with self.assertRaises(AstroidTypeError):\n            inferred.getitem(nodes.Const(\"4\"))\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_getitem_of_class_raised_type_error", "self", "none", "test", "that", "we", "wrap", "an", "attributeinferenceerror", "and", "reraise", "it", "as", "a", "typeerror", "in", "class", "getitem", "node", "extract_node", "def", "test", "yield", "test", "inferred", "next", "node", "infer", "with", "self", "assertraises", "astroidtypeerror", "inferred", "getitem", "nodes", "const", "4"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arg_called_type_is_uninferable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arg_called_type_is_uninferable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arg_called_type_is_uninferable(self) -> None:\n        node = extract_node(\n            \"\"\"\n        def func(type):\n            type #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arg_called_type_is_uninferable", "self", "none", "node", "extract_node", "def", "func", "type", "type", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 23}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arg_called_object_when_used_as_index_is_uninferable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arg_called_object_when_used_as_index_is_uninferable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arg_called_object_when_used_as_index_is_uninferable(self) -> None:\n        node = extract_node(\n            \"\"\"\n        def func(object):\n            ['list'][\n                object #@\n            ]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arg_called_object_when_used_as_index_is_uninferable", "self", "none", "node", "extract_node", "def", "func", "object", "list", "object", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arg_called_type_when_used_as_index_is_uninferable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arg_called_type_when_used_as_index_is_uninferable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arg_called_type_when_used_as_index_is_uninferable(self):\n        # https://github.com/PyCQA/astroid/pull/958\n        node = extract_node(\n            \"\"\"\n        def func(type):\n            ['list'][\n                type #@\n            ]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert not isinstance(inferred, nodes.ClassDef)  # was inferred as builtins.type\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arg_called_type_when_used_as_index_is_uninferable", "self", "https", "github", "com", "pycqa", "astroid", "pull", "958", "node", "extract_node", "def", "func", "type", "list", "type", "inferred", "next", "node", "infer", "assert", "not", "isinstance", "inferred", "nodes", "classdef", "was", "inferred", "as", "builtins", "type", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arg_called_type_when_used_as_subscript_is_uninferable(self):\n        # https://github.com/PyCQA/astroid/pull/958\n        node = extract_node(\n            \"\"\"\n        def func(type):\n            type[0] #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert not isinstance(inferred, nodes.ClassDef)  # was inferred as builtins.type\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arg_called_type_when_used_as_subscript_is_uninferable", "self", "https", "github", "com", "pycqa", "astroid", "pull", "958", "node", "extract_node", "def", "func", "type", "type", "0", "inferred", "next", "node", "infer", "assert", "not", "isinstance", "inferred", "nodes", "classdef", "was", "inferred", "as", "builtins", "type", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_arg_called_type_defined_in_outer_scope_is_uninferable(self):\n        # https://github.com/PyCQA/astroid/pull/958\n        node = extract_node(\n            \"\"\"\n        def outer(type):\n            def inner():\n                type[0] #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert not isinstance(inferred, nodes.ClassDef)  # was inferred as builtins.type\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_arg_called_type_defined_in_outer_scope_is_uninferable", "self", "https", "github", "com", "pycqa", "astroid", "pull", "958", "node", "extract_node", "def", "outer", "type", "def", "inner", "type", "0", "inferred", "next", "node", "infer", "assert", "not", "isinstance", "inferred", "nodes", "classdef", "was", "inferred", "as", "builtins", "type", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 43}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_subclass_attr_instance_attr_indirect", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_subclass_attr_instance_attr_indirect", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_subclass_attr_instance_attr_indirect(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Parent:\n            def __init__(self):\n                self.data = 123\n\n        class Test(Parent):\n            pass\n        t = Test()\n        t\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, Instance)\n        const = next(inferred.igetattr(\"data\"))\n        assert isinstance(const, nodes.Const)\n        assert const.value == 123\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_subclass_attr_instance_attr_indirect", "self", "none", "node", "extract_node", "class", "parent", "def", "__init__", "self", "self", "data", "123", "class", "test", "parent", "pass", "t", "test", "t", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "const", "next", "inferred", "igetattr", "data", "assert", "isinstance", "const", "nodes", "const", "assert", "const", "value", "123"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_infer_subclass_attr_instance_attr", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_infer_subclass_attr_instance_attr", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_infer_subclass_attr_instance_attr(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Parent:\n            def __init__(self):\n                self.data = 123\n\n        class Test(Parent):\n            pass\n        t = Test()\n        t.data\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value == 123\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_infer_subclass_attr_instance_attr", "self", "none", "node", "extract_node", "class", "parent", "def", "__init__", "self", "self", "data", "123", "class", "test", "parent", "pass", "t", "test", "t", "data", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "123"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::InferenceTest.test_uninferable_type_subscript", "file_path": "tests/unittest_inference.py", "class_name": "InferenceTest", "func_name": "test_uninferable_type_subscript", "text": "文件路径: tests/unittest_inference.py, 类名: InferenceTest\n    def test_uninferable_type_subscript(self) -> None:\n        node = extract_node(\"[type for type in [] if type['id']]\")\n        with self.assertRaises(InferenceError):\n            _ = next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "inferencetest", "def", "test_uninferable_type_subscript", "self", "none", "node", "extract_node", "type", "for", "type", "in", "if", "type", "id", "with", "self", "assertraises", "inferenceerror", "_", "next", "node", "infer"], "doc_len": 25}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_yes_when_unknown", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_yes_when_unknown", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_yes_when_unknown(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from missing import Missing\n        getattr(1, Unknown) #@\n        getattr(Unknown, 'a') #@\n        getattr(Unknown, Unknown) #@\n        getattr(Unknown, Unknown, Unknown) #@\n\n        getattr(Missing, 'a') #@\n        getattr(Missing, Missing) #@\n        getattr('a', Missing) #@\n        getattr('a', Missing, Missing) #@\n        \"\"\"\n        )\n        for node in ast_nodes[:4]:\n            self.assertRaises(InferenceError, next, node.infer())\n\n        for node in ast_nodes[4:]:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable, node)\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_yes_when_unknown", "self", "none", "ast_nodes", "extract_node", "from", "missing", "import", "missing", "getattr", "1", "unknown", "getattr", "unknown", "a", "getattr", "unknown", "unknown", "getattr", "unknown", "unknown", "unknown", "getattr", "missing", "a", "getattr", "missing", "missing", "getattr", "a", "missing", "getattr", "a", "missing", "missing", "for", "node", "in", "ast_nodes", "4", "self", "assertraises", "inferenceerror", "next", "node", "infer", "for", "node", "in", "ast_nodes", "4", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable", "node"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_attrname_not_string", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_attrname_not_string", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_attrname_not_string(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        getattr(1, 1) #@\n        c = int\n        getattr(1, c) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_attrname_not_string", "self", "none", "ast_nodes", "extract_node", "getattr", "1", "1", "c", "int", "getattr", "1", "c", "for", "node", "in", "ast_nodes", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 28}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_attribute_missing", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_attribute_missing", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_attribute_missing(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        getattr(1, 'ala') #@\n        getattr(int, 'ala') #@\n        getattr(float, 'bala') #@\n        getattr({}, 'portocala') #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_attribute_missing", "self", "none", "ast_nodes", "extract_node", "getattr", "1", "ala", "getattr", "int", "ala", "getattr", "float", "bala", "getattr", "portocala", "for", "node", "in", "ast_nodes", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 31}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_default", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_default", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_default(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        getattr(1, 'ala', None) #@\n        getattr(int, 'bala', int) #@\n        getattr(int, 'bala', getattr(int, 'portocala', None)) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.Const)\n        self.assertIsNone(first.value)\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, nodes.ClassDef)\n        self.assertEqual(second.qname(), \"builtins.int\")\n\n        third = next(ast_nodes[2].infer())\n        self.assertIsInstance(third, nodes.Const)\n        self.assertIsNone(third.value)\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_default", "self", "none", "ast_nodes", "extract_node", "getattr", "1", "ala", "none", "getattr", "int", "bala", "int", "getattr", "int", "bala", "getattr", "int", "portocala", "none", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "const", "self", "assertisnone", "first", "value", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "nodes", "classdef", "self", "assertequal", "second", "qname", "builtins", "int", "third", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third", "nodes", "const", "self", "assertisnone", "third", "value"], "doc_len": 73}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_lookup", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_lookup", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_lookup(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def test(self): pass\n        class B(A):\n            def test_b(self): pass\n        class C(A): pass\n        class E(C, B):\n            def test_e(self): pass\n\n        getattr(A(), 'test') #@\n        getattr(A, 'test') #@\n        getattr(E(), 'test_b') #@\n        getattr(E(), 'test') #@\n\n        class X(object):\n            def test(self):\n                getattr(self, 'test') #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, BoundMethod)\n        self.assertEqual(first.bound.name, \"A\")\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, UnboundMethod)\n        self.assertIsInstance(second.parent, nodes.ClassDef)\n        self.assertEqual(second.parent.name, \"A\")\n\n        third = next(ast_nodes[2].infer())\n        self.assertIsInstance(third, BoundMethod)\n        # Bound to E, but the provider is B.\n        self.assertEqual(third.bound.name, \"E\")\n        self.assertEqual(third._proxied._proxied.parent.name, \"B\")\n\n        fourth = next(ast_nodes[3].infer())\n        self.assertIsInstance(fourth, BoundMethod)\n        self.assertEqual(fourth.bound.name, \"E\")\n        self.assertEqual(third._proxied._proxied.parent.name, \"B\")\n\n        fifth = next(ast_nodes[4].infer())\n        self.assertIsInstance(fifth, BoundMethod)\n        self.assertEqual(fifth.bound.name, \"X\")\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_lookup", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "test", "self", "pass", "class", "b", "a", "def", "test_b", "self", "pass", "class", "c", "a", "pass", "class", "e", "c", "b", "def", "test_e", "self", "pass", "getattr", "a", "test", "getattr", "a", "test", "getattr", "e", "test_b", "getattr", "e", "test", "class", "x", "object", "def", "test", "self", "getattr", "self", "test", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "boundmethod", "self", "assertequal", "first", "bound", "name", "a", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "unboundmethod", "self", "assertisinstance", "second", "parent", "nodes", "classdef", "self", "assertequal", "second", "parent", "name", "a", "third", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third", "boundmethod", "bound", "to", "e", "but", "the", "provider", "is", "b", "self", "assertequal", "third", "bound", "name", "e", "self", "assertequal", "third", "_proxied", "_proxied", "parent", "name", "b", "fourth", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "fourth", "boundmethod", "self", "assertequal", "fourth", "bound", "name", "e", "self", "assertequal", "third", "_proxied", "_proxied", "parent", "name", "b", "fifth", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "fifth", "boundmethod", "self", "assertequal", "fifth", "bound", "name", "x"], "doc_len": 166}
{"doc_id": "tests/unittest_inference.py::GetattrTest.test_lambda", "file_path": "tests/unittest_inference.py", "class_name": "GetattrTest", "func_name": "test_lambda", "text": "文件路径: tests/unittest_inference.py, 类名: GetattrTest\n    def test_lambda(self) -> None:\n        node = extract_node(\n            \"\"\"\n        getattr(lambda x: x, 'f') #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "getattrtest", "def", "test_lambda", "self", "none", "node", "extract_node", "getattr", "lambda", "x", "x", "f", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::HasattrTest.test_inference_errors", "file_path": "tests/unittest_inference.py", "class_name": "HasattrTest", "func_name": "test_inference_errors", "text": "文件路径: tests/unittest_inference.py, 类名: HasattrTest\n    def test_inference_errors(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from missing import Missing\n\n        hasattr(Unknown, 'ala') #@\n\n        hasattr(Missing, 'bala') #@\n        hasattr('portocala', Missing) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "hasattrtest", "def", "test_inference_errors", "self", "none", "ast_nodes", "extract_node", "from", "missing", "import", "missing", "hasattr", "unknown", "ala", "hasattr", "missing", "bala", "hasattr", "portocala", "missing", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::HasattrTest.test_attribute_is_missing", "file_path": "tests/unittest_inference.py", "class_name": "HasattrTest", "func_name": "test_attribute_is_missing", "text": "文件路径: tests/unittest_inference.py, 类名: HasattrTest\n    def test_attribute_is_missing(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A: pass\n        hasattr(int, 'ala') #@\n        hasattr({}, 'bala') #@\n        hasattr(A(), 'portocala') #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertFalse(inferred.value)\n", "tokens": ["tests", "unittest_inference", "py", "hasattrtest", "def", "test_attribute_is_missing", "self", "none", "ast_nodes", "extract_node", "class", "a", "pass", "hasattr", "int", "ala", "hasattr", "bala", "hasattr", "a", "portocala", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertfalse", "inferred", "value"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::HasattrTest.test_attribute_is_not_missing", "file_path": "tests/unittest_inference.py", "class_name": "HasattrTest", "func_name": "test_attribute_is_not_missing", "text": "文件路径: tests/unittest_inference.py, 类名: HasattrTest\n    def test_attribute_is_not_missing(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class A(object):\n            def test(self): pass\n        class B(A):\n            def test_b(self): pass\n        class C(A): pass\n        class E(C, B):\n            def test_e(self): pass\n\n        hasattr(A(), 'test') #@\n        hasattr(A, 'test') #@\n        hasattr(E(), 'test_b') #@\n        hasattr(E(), 'test') #@\n\n        class X(object):\n            def test(self):\n                hasattr(self, 'test') #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertTrue(inferred.value)\n", "tokens": ["tests", "unittest_inference", "py", "hasattrtest", "def", "test_attribute_is_not_missing", "self", "none", "ast_nodes", "extract_node", "class", "a", "object", "def", "test", "self", "pass", "class", "b", "a", "def", "test_b", "self", "pass", "class", "c", "a", "pass", "class", "e", "c", "b", "def", "test_e", "self", "pass", "hasattr", "a", "test", "hasattr", "a", "test", "hasattr", "e", "test_b", "hasattr", "e", "test", "class", "x", "object", "def", "test", "self", "hasattr", "self", "test", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "asserttrue", "inferred", "value"], "doc_len": 74}
{"doc_id": "tests/unittest_inference.py::HasattrTest.test_lambda", "file_path": "tests/unittest_inference.py", "class_name": "HasattrTest", "func_name": "test_lambda", "text": "文件路径: tests/unittest_inference.py, 类名: HasattrTest\n    def test_lambda(self) -> None:\n        node = extract_node(\n            \"\"\"\n        hasattr(lambda x: x, 'f') #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "hasattrtest", "def", "test_lambda", "self", "none", "node", "extract_node", "hasattr", "lambda", "x", "x", "f", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::BoolOpTest.test_bool_ops", "file_path": "tests/unittest_inference.py", "class_name": "BoolOpTest", "func_name": "test_bool_ops", "text": "文件路径: tests/unittest_inference.py, 类名: BoolOpTest\n    def test_bool_ops(self) -> None:\n        expected = [\n            (\"1 and 2\", 2),\n            (\"0 and 2\", 0),\n            (\"1 or 2\", 1),\n            (\"0 or 2\", 2),\n            (\"0 or 0 or 1\", 1),\n            (\"1 and 2 and 3\", 3),\n            (\"1 and 2 or 3\", 2),\n            (\"1 and 0 or 3\", 3),\n            (\"1 or 0 and 2\", 1),\n            (\"(1 and 2) and (2 and 3)\", 3),\n            (\"not 2 and 3\", False),\n            (\"2 and not 3\", False),\n            (\"not 0 and 3\", 3),\n            (\"True and False\", False),\n            (\"not (True or False) and True\", False),\n        ]\n        for code, expected_value in expected:\n            node = extract_node(code)\n            inferred = next(node.infer())\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "booloptest", "def", "test_bool_ops", "self", "none", "expected", "1", "and", "2", "2", "0", "and", "2", "0", "1", "or", "2", "1", "0", "or", "2", "2", "0", "or", "0", "or", "1", "1", "1", "and", "2", "and", "3", "3", "1", "and", "2", "or", "3", "2", "1", "and", "0", "or", "3", "3", "1", "or", "0", "and", "2", "1", "1", "and", "2", "and", "2", "and", "3", "3", "not", "2", "and", "3", "false", "2", "and", "not", "3", "false", "not", "0", "and", "3", "3", "true", "and", "false", "false", "not", "true", "or", "false", "and", "true", "false", "for", "code", "expected_value", "in", "expected", "node", "extract_node", "code", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 106}
{"doc_id": "tests/unittest_inference.py::BoolOpTest.test_yes_when_unknown", "file_path": "tests/unittest_inference.py", "class_name": "BoolOpTest", "func_name": "test_yes_when_unknown", "text": "文件路径: tests/unittest_inference.py, 类名: BoolOpTest\n    def test_yes_when_unknown(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from unknown import unknown, any, not_any\n        0 and unknown #@\n        unknown or 0 #@\n        any or not_any and unknown #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "booloptest", "def", "test_yes_when_unknown", "self", "none", "ast_nodes", "extract_node", "from", "unknown", "import", "unknown", "any", "not_any", "0", "and", "unknown", "unknown", "or", "0", "any", "or", "not_any", "and", "unknown", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::BoolOpTest.test_other_nodes", "file_path": "tests/unittest_inference.py", "class_name": "BoolOpTest", "func_name": "test_other_nodes", "text": "文件路径: tests/unittest_inference.py, 类名: BoolOpTest\n    def test_other_nodes(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(): pass\n        test and 0 #@\n        1 and test #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertEqual(first.value, 0)\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, nodes.FunctionDef)\n        self.assertEqual(second.name, \"test\")\n", "tokens": ["tests", "unittest_inference", "py", "booloptest", "def", "test_other_nodes", "self", "none", "ast_nodes", "extract_node", "def", "test", "pass", "test", "and", "0", "1", "and", "test", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertequal", "first", "value", "0", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "nodes", "functiondef", "self", "assertequal", "second", "name", "test"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::TestCallable.test_callable", "file_path": "tests/unittest_inference.py", "class_name": "TestCallable", "func_name": "test_callable", "text": "文件路径: tests/unittest_inference.py, 类名: TestCallable\n    def test_callable(self) -> None:\n        expected = [\n            (\"callable(len)\", True),\n            ('callable(\"a\")', False),\n            (\"callable(callable)\", True),\n            (\"callable(lambda x, y: x+y)\", True),\n            (\"import os; __(callable(os))\", False),\n            (\"callable(int)\", True),\n            (\n                \"\"\"\n             def test(): pass\n             callable(test) #@\"\"\",\n                True,\n            ),\n            (\n                \"\"\"\n             class C1:\n                def meth(self): pass\n             callable(C1) #@\"\"\",\n                True,\n            ),\n        ]\n        for code, expected_value in expected:\n            node = extract_node(code)\n            inferred = next(node.infer())\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "testcallable", "def", "test_callable", "self", "none", "expected", "callable", "len", "true", "callable", "a", "false", "callable", "callable", "true", "callable", "lambda", "x", "y", "x", "y", "true", "import", "os", "__", "callable", "os", "false", "callable", "int", "true", "def", "test", "pass", "callable", "test", "true", "class", "c1", "def", "meth", "self", "pass", "callable", "c1", "true", "for", "code", "expected_value", "in", "expected", "node", "extract_node", "code", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::TestCallable.test_callable_methods", "file_path": "tests/unittest_inference.py", "class_name": "TestCallable", "func_name": "test_callable_methods", "text": "文件路径: tests/unittest_inference.py, 类名: TestCallable\n    def test_callable_methods(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        class C:\n            def test(self): pass\n            @staticmethod\n            def static(): pass\n            @classmethod\n            def class_method(cls): pass\n            def __call__(self): pass\n        class D(C):\n            pass\n        class NotReallyCallableDueToPythonMisfeature(object):\n            __call__ = 42\n        callable(C.test) #@\n        callable(C.static) #@\n        callable(C.class_method) #@\n        callable(C().test) #@\n        callable(C().static) #@\n        callable(C().class_method) #@\n        C #@\n        C() #@\n        NotReallyCallableDueToPythonMisfeature() #@\n        staticmethod #@\n        classmethod #@\n        property #@\n        D #@\n        D() #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertTrue(inferred)\n", "tokens": ["tests", "unittest_inference", "py", "testcallable", "def", "test_callable_methods", "self", "none", "ast_nodes", "extract_node", "class", "c", "def", "test", "self", "pass", "staticmethod", "def", "static", "pass", "classmethod", "def", "class_method", "cls", "pass", "def", "__call__", "self", "pass", "class", "d", "c", "pass", "class", "notreallycallableduetopythonmisfeature", "object", "__call__", "42", "callable", "c", "test", "callable", "c", "static", "callable", "c", "class_method", "callable", "c", "test", "callable", "c", "static", "callable", "c", "class_method", "c", "c", "notreallycallableduetopythonmisfeature", "staticmethod", "classmethod", "property", "d", "d", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "asserttrue", "inferred"], "doc_len": 75}
{"doc_id": "tests/unittest_inference.py::TestCallable.test_inference_errors", "file_path": "tests/unittest_inference.py", "class_name": "TestCallable", "func_name": "test_inference_errors", "text": "文件路径: tests/unittest_inference.py, 类名: TestCallable\n    def test_inference_errors(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from unknown import unknown\n        callable(unknown) #@\n        def test():\n            return unknown\n        callable(test()) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "testcallable", "def", "test_inference_errors", "self", "none", "ast_nodes", "extract_node", "from", "unknown", "import", "unknown", "callable", "unknown", "def", "test", "return", "unknown", "callable", "test", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::TestCallable.test_not_callable", "file_path": "tests/unittest_inference.py", "class_name": "TestCallable", "func_name": "test_not_callable", "text": "文件路径: tests/unittest_inference.py, 类名: TestCallable\n    def test_not_callable(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        callable(\"\") #@\n        callable(1) #@\n        callable(True) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertFalse(inferred.value)\n", "tokens": ["tests", "unittest_inference", "py", "testcallable", "def", "test_not_callable", "self", "none", "ast_nodes", "extract_node", "callable", "callable", "1", "callable", "true", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertfalse", "inferred", "value"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::TestBool.test_bool", "file_path": "tests/unittest_inference.py", "class_name": "TestBool", "func_name": "test_bool", "text": "文件路径: tests/unittest_inference.py, 类名: TestBool\n    def test_bool(self) -> None:\n        pairs = [\n            (\"bool()\", False),\n            (\"bool(1)\", True),\n            (\"bool(0)\", False),\n            (\"bool([])\", False),\n            (\"bool([1])\", True),\n            (\"bool({})\", False),\n            (\"bool(True)\", True),\n            (\"bool(False)\", False),\n            (\"bool(None)\", False),\n            (\"from unknown import Unknown; __(bool(Unknown))\", util.Uninferable),\n        ]\n        for code, expected in pairs:\n            node = extract_node(code)\n            inferred = next(node.infer())\n            if expected is util.Uninferable:\n                self.assertEqual(expected, inferred)\n            else:\n                self.assertEqual(inferred.value, expected)\n", "tokens": ["tests", "unittest_inference", "py", "testbool", "def", "test_bool", "self", "none", "pairs", "bool", "false", "bool", "1", "true", "bool", "0", "false", "bool", "false", "bool", "1", "true", "bool", "false", "bool", "true", "true", "bool", "false", "false", "bool", "none", "false", "from", "unknown", "import", "unknown", "__", "bool", "unknown", "util", "uninferable", "for", "code", "expected", "in", "pairs", "node", "extract_node", "code", "inferred", "next", "node", "infer", "if", "expected", "is", "util", "uninferable", "self", "assertequal", "expected", "inferred", "else", "self", "assertequal", "inferred", "value", "expected"], "doc_len": 69}
{"doc_id": "tests/unittest_inference.py::TestBool.test_bool_bool_special_method", "file_path": "tests/unittest_inference.py", "class_name": "TestBool", "func_name": "test_bool_bool_special_method", "text": "文件路径: tests/unittest_inference.py, 类名: TestBool\n    def test_bool_bool_special_method(self) -> None:\n        ast_nodes = extract_node(\n            f\"\"\"\n        class FalseClass:\n           def {BOOL_SPECIAL_METHOD}(self):\n               return False\n        class TrueClass:\n           def {BOOL_SPECIAL_METHOD}(self):\n               return True\n        class C(object):\n           def __call__(self):\n               return False\n        class B(object):\n           {BOOL_SPECIAL_METHOD} = C()\n        class LambdaBoolFalse(object):\n            {BOOL_SPECIAL_METHOD} = lambda self: self.foo\n            @property\n            def foo(self): return 0\n        class FalseBoolLen(object):\n            __len__ = lambda self: self.foo\n            @property\n            def foo(self): return 0\n        bool(FalseClass) #@\n        bool(TrueClass) #@\n        bool(FalseClass()) #@\n        bool(TrueClass()) #@\n        bool(B()) #@\n        bool(LambdaBoolFalse()) #@\n        bool(FalseBoolLen()) #@\n        \"\"\"\n        )\n        expected = [True, True, False, True, False, False, False]\n        for node, expected_value in zip(ast_nodes, expected):\n            inferred = next(node.infer())\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "testbool", "def", "test_bool_bool_special_method", "self", "none", "ast_nodes", "extract_node", "f", "class", "falseclass", "def", "bool_special_method", "self", "return", "false", "class", "trueclass", "def", "bool_special_method", "self", "return", "true", "class", "c", "object", "def", "__call__", "self", "return", "false", "class", "b", "object", "bool_special_method", "c", "class", "lambdaboolfalse", "object", "bool_special_method", "lambda", "self", "self", "foo", "property", "def", "foo", "self", "return", "0", "class", "falseboollen", "object", "__len__", "lambda", "self", "self", "foo", "property", "def", "foo", "self", "return", "0", "bool", "falseclass", "bool", "trueclass", "bool", "falseclass", "bool", "trueclass", "bool", "b", "bool", "lambdaboolfalse", "bool", "falseboollen", "expected", "true", "true", "false", "true", "false", "false", "false", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 104}
{"doc_id": "tests/unittest_inference.py::TestBool.test_bool_instance_not_callable", "file_path": "tests/unittest_inference.py", "class_name": "TestBool", "func_name": "test_bool_instance_not_callable", "text": "文件路径: tests/unittest_inference.py, 类名: TestBool\n    def test_bool_instance_not_callable(self) -> None:\n        ast_nodes = extract_node(\n            f\"\"\"\n        class BoolInvalid(object):\n           {BOOL_SPECIAL_METHOD} = 42\n        class LenInvalid(object):\n           __len__ = \"a\"\n        bool(BoolInvalid()) #@\n        bool(LenInvalid()) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "testbool", "def", "test_bool_instance_not_callable", "self", "none", "ast_nodes", "extract_node", "f", "class", "boolinvalid", "object", "bool_special_method", "42", "class", "leninvalid", "object", "__len__", "a", "bool", "boolinvalid", "bool", "leninvalid", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::TestBool.test_class_subscript", "file_path": "tests/unittest_inference.py", "class_name": "TestBool", "func_name": "test_class_subscript", "text": "文件路径: tests/unittest_inference.py, 类名: TestBool\n    def test_class_subscript(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Foo:\n            def __class_getitem__(cls, *args, **kwargs):\n                return cls\n\n        Foo[int]\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"Foo\")\n", "tokens": ["tests", "unittest_inference", "py", "testbool", "def", "test_class_subscript", "self", "none", "node", "extract_node", "class", "foo", "def", "__class_getitem__", "cls", "args", "kwargs", "return", "cls", "foo", "int", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "foo"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::TestType.test_type", "file_path": "tests/unittest_inference.py", "class_name": "TestType", "func_name": "test_type", "text": "文件路径: tests/unittest_inference.py, 类名: TestType\n    def test_type(self) -> None:\n        pairs = [\n            (\"type(1)\", \"int\"),\n            (\"type(type)\", \"type\"),\n            (\"type(None)\", \"NoneType\"),\n            (\"type(object)\", \"type\"),\n            (\"type(dict())\", \"dict\"),\n            (\"type({})\", \"dict\"),\n            (\"type(frozenset())\", \"frozenset\"),\n        ]\n        for code, expected in pairs:\n            node = extract_node(code)\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.ClassDef)\n            self.assertEqual(inferred.name, expected)\n", "tokens": ["tests", "unittest_inference", "py", "testtype", "def", "test_type", "self", "none", "pairs", "type", "1", "int", "type", "type", "type", "type", "none", "nonetype", "type", "object", "type", "type", "dict", "dict", "type", "dict", "type", "frozenset", "frozenset", "for", "code", "expected", "in", "pairs", "node", "extract_node", "code", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "expected"], "doc_len": 51}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest._get_dict_value", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "_get_dict_value", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def _get_dict_value(\n        inferred: Dict,\n    ) -> Union[List[Tuple[str, int]], List[Tuple[str, str]]]:\n        items = inferred.items\n        return sorted((key.value, value.value) for key, value in items)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "_get_dict_value", "inferred", "dict", "union", "list", "tuple", "str", "int", "list", "tuple", "str", "str", "items", "inferred", "items", "return", "sorted", "key", "value", "value", "value", "for", "key", "value", "in", "items"], "doc_len": 31}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest._get_tuple_value", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "_get_tuple_value", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def _get_tuple_value(inferred: Tuple) -> Tuple[int, ...]:\n        elts = inferred.elts\n        return tuple(elt.value for elt in elts)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "_get_tuple_value", "inferred", "tuple", "tuple", "int", "elts", "inferred", "elts", "return", "tuple", "elt", "value", "for", "elt", "in", "elts"], "doc_len": 21}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_args", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_args", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_args(self) -> None:\n        expected_values = [\n            (),\n            (1,),\n            (2, 3),\n            (4, 5),\n            (3,),\n            (),\n            (3, 4, 5),\n            (),\n            (),\n            (4,),\n            (4, 5),\n            (),\n            (3,),\n            (),\n            (),\n            (3,),\n            (42,),\n        ]\n        ast_nodes = extract_node(\n            \"\"\"\n        def func(*args):\n            return args\n        func() #@\n        func(1) #@\n        func(2, 3) #@\n        func(*(4, 5)) #@\n        def func(a, b, *args):\n            return args\n        func(1, 2, 3) #@\n        func(1, 2) #@\n        func(1, 2, 3, 4, 5) #@\n        def func(a, b, c=42, *args):\n            return args\n        func(1, 2) #@\n        func(1, 2, 3) #@\n        func(1, 2, 3, 4) #@\n        func(1, 2, 3, 4, 5) #@\n        func = lambda a, b, *args: args\n        func(1, 2) #@\n        func(1, 2, 3) #@\n        func = lambda a, b=42, *args: args\n        func(1) #@\n        func(1, 2) #@\n        func(1, 2, 3) #@\n        func(1, 2, *(42, )) #@\n        \"\"\"\n        )\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Tuple)\n            self.assertEqual(self._get_tuple_value(inferred), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_args", "self", "none", "expected_values", "1", "2", "3", "4", "5", "3", "3", "4", "5", "4", "4", "5", "3", "3", "42", "ast_nodes", "extract_node", "def", "func", "args", "return", "args", "func", "func", "1", "func", "2", "3", "func", "4", "5", "def", "func", "a", "b", "args", "return", "args", "func", "1", "2", "3", "func", "1", "2", "func", "1", "2", "3", "4", "5", "def", "func", "a", "b", "c", "42", "args", "return", "args", "func", "1", "2", "func", "1", "2", "3", "func", "1", "2", "3", "4", "func", "1", "2", "3", "4", "5", "func", "lambda", "a", "b", "args", "args", "func", "1", "2", "func", "1", "2", "3", "func", "lambda", "a", "b", "42", "args", "args", "func", "1", "func", "1", "2", "func", "1", "2", "3", "func", "1", "2", "42", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "tuple", "self", "assertequal", "self", "_get_tuple_value", "inferred", "expected_value"], "doc_len": 142}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_multiple_starred_args", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_multiple_starred_args", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_multiple_starred_args(self) -> None:\n        expected_values = [(1, 2, 3), (1, 4, 2, 3, 5, 6, 7)]\n        ast_nodes = extract_node(\n            \"\"\"\n        def func(a, b, *args):\n            return args\n        func(1, 2, *(1, ), *(2, 3)) #@\n        func(1, 2, *(1, ), 4, *(2, 3), 5, *(6, 7)) #@\n        \"\"\"\n        )\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Tuple)\n            self.assertEqual(self._get_tuple_value(inferred), expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_multiple_starred_args", "self", "none", "expected_values", "1", "2", "3", "1", "4", "2", "3", "5", "6", "7", "ast_nodes", "extract_node", "def", "func", "a", "b", "args", "return", "args", "func", "1", "2", "1", "2", "3", "func", "1", "2", "1", "4", "2", "3", "5", "6", "7", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "tuple", "self", "assertequal", "self", "_get_tuple_value", "inferred", "expected_value"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_defaults", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_defaults", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_defaults(self) -> None:\n        expected_values = [42, 3, 41, 42]\n        ast_nodes = extract_node(\n            \"\"\"\n        def func(a, b, c=42, *args):\n            return c\n        func(1, 2) #@\n        func(1, 2, 3) #@\n        func(1, 2, c=41) #@\n        func(1, 2, 42, 41) #@\n        \"\"\"\n        )\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_defaults", "self", "none", "expected_values", "42", "3", "41", "42", "ast_nodes", "extract_node", "def", "func", "a", "b", "c", "42", "args", "return", "c", "func", "1", "2", "func", "1", "2", "3", "func", "1", "2", "c", "41", "func", "1", "2", "42", "41", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 62}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_kwonly_args", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_kwonly_args", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_kwonly_args(self) -> None:\n        expected_values = [24, 24, 42, 23, 24, 24, 54]\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(*, f, b): return f\n        test(f=24, b=33) #@\n        def test(a, *, f): return f\n        test(1, f=24) #@\n        def test(a, *, f=42): return f\n        test(1) #@\n        test(1, f=23) #@\n        def test(a, b, c=42, *args, f=24):\n            return f\n        test(1, 2, 3) #@\n        test(1, 2, 3, 4) #@\n        test(1, 2, 3, 4, 5, f=54) #@\n        \"\"\"\n        )\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_kwonly_args", "self", "none", "expected_values", "24", "24", "42", "23", "24", "24", "54", "ast_nodes", "extract_node", "def", "test", "f", "b", "return", "f", "test", "f", "24", "b", "33", "def", "test", "a", "f", "return", "f", "test", "1", "f", "24", "def", "test", "a", "f", "42", "return", "f", "test", "1", "test", "1", "f", "23", "def", "test", "a", "b", "c", "42", "args", "f", "24", "return", "f", "test", "1", "2", "3", "test", "1", "2", "3", "4", "test", "1", "2", "3", "4", "5", "f", "54", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected_value"], "doc_len": 101}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_kwargs", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_kwargs", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_kwargs(self) -> None:\n        expected = [[(\"a\", 1), (\"b\", 2), (\"c\", 3)], [(\"a\", 1)], [(\"a\", \"b\")]]\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(**kwargs):\n             return kwargs\n        test(a=1, b=2, c=3) #@\n        test(a=1) #@\n        test(**{'a': 'b'}) #@\n        \"\"\"\n        )\n        for node, expected_value in zip(ast_nodes, expected):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Dict)\n            value = self._get_dict_value(inferred)\n            self.assertEqual(value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_kwargs", "self", "none", "expected", "a", "1", "b", "2", "c", "3", "a", "1", "a", "b", "ast_nodes", "extract_node", "def", "test", "kwargs", "return", "kwargs", "test", "a", "1", "b", "2", "c", "3", "test", "a", "1", "test", "a", "b", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "dict", "value", "self", "_get_dict_value", "inferred", "self", "assertequal", "value", "expected_value"], "doc_len": 63}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_kwargs_and_other_named_parameters", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_kwargs_and_other_named_parameters", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_kwargs_and_other_named_parameters(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(a=42, b=24, **kwargs):\n            return kwargs\n        test(42, 24, c=3, d=4) #@\n        test(49, b=24, d=4) #@\n        test(a=42, b=33, c=3, d=42) #@\n        test(a=42, **{'c':42}) #@\n        \"\"\"\n        )\n        expected_values = [\n            [(\"c\", 3), (\"d\", 4)],\n            [(\"d\", 4)],\n            [(\"c\", 3), (\"d\", 42)],\n            [(\"c\", 42)],\n        ]\n        for node, expected_value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Dict)\n            value = self._get_dict_value(inferred)\n            self.assertEqual(value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_kwargs_and_other_named_parameters", "self", "none", "ast_nodes", "extract_node", "def", "test", "a", "42", "b", "24", "kwargs", "return", "kwargs", "test", "42", "24", "c", "3", "d", "4", "test", "49", "b", "24", "d", "4", "test", "a", "42", "b", "33", "c", "3", "d", "42", "test", "a", "42", "c", "42", "expected_values", "c", "3", "d", "4", "d", "4", "c", "3", "d", "42", "c", "42", "for", "node", "expected_value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "dict", "value", "self", "_get_dict_value", "inferred", "self", "assertequal", "value", "expected_value"], "doc_len": 83}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_kwargs_access_by_name", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_kwargs_access_by_name", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_kwargs_access_by_name(self) -> None:\n        expected_values = [42, 42, 42, 24]\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(**kwargs):\n            return kwargs['f']\n        test(f=42) #@\n        test(**{'f': 42}) #@\n        test(**dict(f=42)) #@\n        def test(f=42, **kwargs):\n            return kwargs['l']\n        test(l=24) #@\n        \"\"\"\n        )\n        for ast_node, value in zip(ast_nodes, expected_values):\n            inferred = next(ast_node.infer())\n            self.assertIsInstance(inferred, nodes.Const, inferred)\n            self.assertEqual(inferred.value, value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_kwargs_access_by_name", "self", "none", "expected_values", "42", "42", "42", "24", "ast_nodes", "extract_node", "def", "test", "kwargs", "return", "kwargs", "f", "test", "f", "42", "test", "f", "42", "test", "dict", "f", "42", "def", "test", "f", "42", "kwargs", "return", "kwargs", "l", "test", "l", "24", "for", "ast_node", "value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "inferred", "self", "assertequal", "inferred", "value", "value"], "doc_len": 64}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_multiple_kwargs", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_multiple_kwargs", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_multiple_kwargs(self) -> None:\n        expected_value = [(\"a\", 1), (\"b\", 2), (\"c\", 3), (\"d\", 4), (\"f\", 42)]\n        ast_node = extract_node(\n            \"\"\"\n        def test(**kwargs):\n             return kwargs\n        test(a=1, b=2, **{'c': 3}, **{'d': 4}, f=42) #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.Dict)\n        value = self._get_dict_value(inferred)\n        self.assertEqual(value, expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_multiple_kwargs", "self", "none", "expected_value", "a", "1", "b", "2", "c", "3", "d", "4", "f", "42", "ast_node", "extract_node", "def", "test", "kwargs", "return", "kwargs", "test", "a", "1", "b", "2", "c", "3", "d", "4", "f", "42", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "dict", "value", "self", "_get_dict_value", "inferred", "self", "assertequal", "value", "expected_value"], "doc_len": 54}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_kwargs_are_overridden", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_kwargs_are_overridden", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_kwargs_are_overridden(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(f):\n             return f\n        test(f=23, **{'f': 34}) #@\n        def test(f=None):\n             return f\n        test(f=23, **{'f':23}) #@\n        \"\"\"\n        )\n        for ast_node in ast_nodes:\n            inferred = next(ast_node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_kwargs_are_overridden", "self", "none", "ast_nodes", "extract_node", "def", "test", "f", "return", "f", "test", "f", "23", "f", "34", "def", "test", "f", "none", "return", "f", "test", "f", "23", "f", "23", "for", "ast_node", "in", "ast_nodes", "inferred", "next", "ast_node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_fail_to_infer_args", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_fail_to_infer_args", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_fail_to_infer_args(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        def test(a, **kwargs): return a\n        test(*missing) #@\n        test(*object) #@\n        test(*1) #@\n\n\n        def test(**kwargs): return kwargs\n        test(**miss) #@\n        test(**(1, 2)) #@\n        test(**1) #@\n        test(**{misss:1}) #@\n        test(**{object:1}) #@\n        test(**{1:1}) #@\n        test(**{'a':1, 'a':1}) #@\n\n        def test(a): return a\n        test() #@\n        test(1, 2, 3) #@\n\n        from unknown import unknown\n        test(*unknown) #@\n        def test(*args): return args\n        test(*unknown) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertEqual(inferred, util.Uninferable)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_fail_to_infer_args", "self", "none", "ast_nodes", "extract_node", "def", "test", "a", "kwargs", "return", "a", "test", "missing", "test", "object", "test", "1", "def", "test", "kwargs", "return", "kwargs", "test", "miss", "test", "1", "2", "test", "1", "test", "misss", "1", "test", "object", "1", "test", "1", "1", "test", "a", "1", "a", "1", "def", "test", "a", "return", "a", "test", "test", "1", "2", "3", "from", "unknown", "import", "unknown", "test", "unknown", "def", "test", "args", "return", "args", "test", "unknown", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "util", "uninferable"], "doc_len": 84}
{"doc_id": "tests/unittest_inference.py::ArgumentsTest.test_args_overwritten", "file_path": "tests/unittest_inference.py", "class_name": "ArgumentsTest", "func_name": "test_args_overwritten", "text": "文件路径: tests/unittest_inference.py, 类名: ArgumentsTest\n    def test_args_overwritten(self) -> None:\n        # https://github.com/PyCQA/astroid/issues/180\n        node = extract_node(\n            \"\"\"\n        next = 42\n        def wrapper(next=next):\n             next = 24\n             def test():\n                 return next\n             return test\n        wrapper()() #@\n        \"\"\"\n        )\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.Const, inferred[0])\n        self.assertEqual(inferred[0].value, 24)\n", "tokens": ["tests", "unittest_inference", "py", "argumentstest", "def", "test_args_overwritten", "self", "none", "https", "github", "com", "pycqa", "astroid", "issues", "180", "node", "extract_node", "next", "42", "def", "wrapper", "next", "next", "next", "24", "def", "test", "return", "next", "return", "test", "wrapper", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "const", "inferred", "0", "self", "assertequal", "inferred", "0", "value", "24"], "doc_len": 59}
{"doc_id": "tests/unittest_inference.py::SliceTest.test_slice", "file_path": "tests/unittest_inference.py", "class_name": "SliceTest", "func_name": "test_slice", "text": "文件路径: tests/unittest_inference.py, 类名: SliceTest\n    def test_slice(self) -> None:\n        ast_nodes = [\n            (\"[1, 2, 3][slice(None)]\", [1, 2, 3]),\n            (\"[1, 2, 3][slice(None, None)]\", [1, 2, 3]),\n            (\"[1, 2, 3][slice(None, None, None)]\", [1, 2, 3]),\n            (\"[1, 2, 3][slice(1, None)]\", [2, 3]),\n            (\"[1, 2, 3][slice(None, 1, None)]\", [1]),\n            (\"[1, 2, 3][slice(0, 1)]\", [1]),\n            (\"[1, 2, 3][slice(0, 3, 2)]\", [1, 3]),\n        ]\n        for node, expected_value in ast_nodes:\n            ast_node = extract_node(f\"__({node})\")\n            inferred = next(ast_node.infer())\n            self.assertIsInstance(inferred, nodes.List)\n            self.assertEqual([elt.value for elt in inferred.elts], expected_value)\n", "tokens": ["tests", "unittest_inference", "py", "slicetest", "def", "test_slice", "self", "none", "ast_nodes", "1", "2", "3", "slice", "none", "1", "2", "3", "1", "2", "3", "slice", "none", "none", "1", "2", "3", "1", "2", "3", "slice", "none", "none", "none", "1", "2", "3", "1", "2", "3", "slice", "1", "none", "2", "3", "1", "2", "3", "slice", "none", "1", "none", "1", "1", "2", "3", "slice", "0", "1", "1", "1", "2", "3", "slice", "0", "3", "2", "1", "3", "for", "node", "expected_value", "in", "ast_nodes", "ast_node", "extract_node", "f", "__", "node", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "list", "self", "assertequal", "elt", "value", "for", "elt", "in", "inferred", "elts", "expected_value"], "doc_len": 97}
{"doc_id": "tests/unittest_inference.py::SliceTest.test_slice_inference_error", "file_path": "tests/unittest_inference.py", "class_name": "SliceTest", "func_name": "test_slice_inference_error", "text": "文件路径: tests/unittest_inference.py, 类名: SliceTest\n    def test_slice_inference_error(self) -> None:\n        ast_nodes = extract_node(\n            \"\"\"\n        from unknown import unknown\n        [1, 2, 3][slice(None, unknown, unknown)] #@\n        [1, 2, 3][slice(None, missing, missing)] #@\n        [1, 2, 3][slice(object, list, tuple)] #@\n        [1, 2, 3][slice(b'a')] #@\n        [1, 2, 3][slice(1, 'aa')] #@\n        [1, 2, 3][slice(1, 2.0, 3.0)] #@\n        [1, 2, 3][slice()] #@\n        [1, 2, 3][slice(1, 2, 3, 4)] #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "slicetest", "def", "test_slice_inference_error", "self", "none", "ast_nodes", "extract_node", "from", "unknown", "import", "unknown", "1", "2", "3", "slice", "none", "unknown", "unknown", "1", "2", "3", "slice", "none", "missing", "missing", "1", "2", "3", "slice", "object", "list", "tuple", "1", "2", "3", "slice", "b", "a", "1", "2", "3", "slice", "1", "aa", "1", "2", "3", "slice", "1", "2", "0", "3", "0", "1", "2", "3", "slice", "1", "2", "3", "slice", "1", "2", "3", "4", "for", "node", "in", "ast_nodes", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 78}
{"doc_id": "tests/unittest_inference.py::SliceTest.test_slice_attributes", "file_path": "tests/unittest_inference.py", "class_name": "SliceTest", "func_name": "test_slice_attributes", "text": "文件路径: tests/unittest_inference.py, 类名: SliceTest\n    def test_slice_attributes(self) -> None:\n        ast_nodes = [\n            (\"slice(2, 3, 4)\", (2, 3, 4)),\n            (\"slice(None, None, 4)\", (None, None, 4)),\n            (\"slice(None, 1, None)\", (None, 1, None)),\n        ]\n        for code, values in ast_nodes:\n            lower, upper, step = values\n            node = extract_node(code)\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Slice)\n            lower_value = next(inferred.igetattr(\"start\"))\n            self.assertIsInstance(lower_value, nodes.Const)\n            self.assertEqual(lower_value.value, lower)\n            higher_value = next(inferred.igetattr(\"stop\"))\n            self.assertIsInstance(higher_value, nodes.Const)\n            self.assertEqual(higher_value.value, upper)\n            step_value = next(inferred.igetattr(\"step\"))\n            self.assertIsInstance(step_value, nodes.Const)\n            self.assertEqual(step_value.value, step)\n            self.assertEqual(inferred.pytype(), \"builtins.slice\")\n", "tokens": ["tests", "unittest_inference", "py", "slicetest", "def", "test_slice_attributes", "self", "none", "ast_nodes", "slice", "2", "3", "4", "2", "3", "4", "slice", "none", "none", "4", "none", "none", "4", "slice", "none", "1", "none", "none", "1", "none", "for", "code", "values", "in", "ast_nodes", "lower", "upper", "step", "values", "node", "extract_node", "code", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "slice", "lower_value", "next", "inferred", "igetattr", "start", "self", "assertisinstance", "lower_value", "nodes", "const", "self", "assertequal", "lower_value", "value", "lower", "higher_value", "next", "inferred", "igetattr", "stop", "self", "assertisinstance", "higher_value", "nodes", "const", "self", "assertequal", "higher_value", "value", "upper", "step_value", "next", "inferred", "igetattr", "step", "self", "assertisinstance", "step_value", "nodes", "const", "self", "assertequal", "step_value", "value", "step", "self", "assertequal", "inferred", "pytype", "builtins", "slice"], "doc_len": 102}
{"doc_id": "tests/unittest_inference.py::SliceTest.test_slice_type", "file_path": "tests/unittest_inference.py", "class_name": "SliceTest", "func_name": "test_slice_type", "text": "文件路径: tests/unittest_inference.py, 类名: SliceTest\n    def test_slice_type(self) -> None:\n        ast_node = extract_node(\"type(slice(None, None, None))\")\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"slice\")\n", "tokens": ["tests", "unittest_inference", "py", "slicetest", "def", "test_slice_type", "self", "none", "ast_node", "extract_node", "type", "slice", "none", "none", "none", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "slice"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::CallSiteTest._call_site_from_call", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "_call_site_from_call", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def _call_site_from_call(call: nodes.Call) -> CallSite:\n        return arguments.CallSite.from_call(call)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "_call_site_from_call", "call", "nodes", "call", "callsite", "return", "arguments", "callsite", "from_call", "call"], "doc_len": 15}
{"doc_id": "tests/unittest_inference.py::CallSiteTest._test_call_site_pair", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "_test_call_site_pair", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def _test_call_site_pair(\n        self, code: str, expected_args: List[int], expected_keywords: Dict[str, int]\n    ) -> None:\n        ast_node = extract_node(code)\n        call_site = self._call_site_from_call(ast_node)\n        self.assertEqual(len(call_site.positional_arguments), len(expected_args))\n        self.assertEqual(\n            [arg.value for arg in call_site.positional_arguments], expected_args\n        )\n        self.assertEqual(len(call_site.keyword_arguments), len(expected_keywords))\n        for keyword, value in expected_keywords.items():\n            self.assertIn(keyword, call_site.keyword_arguments)\n            self.assertEqual(call_site.keyword_arguments[keyword].value, value)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "_test_call_site_pair", "self", "code", "str", "expected_args", "list", "int", "expected_keywords", "dict", "str", "int", "none", "ast_node", "extract_node", "code", "call_site", "self", "_call_site_from_call", "ast_node", "self", "assertequal", "len", "call_site", "positional_arguments", "len", "expected_args", "self", "assertequal", "arg", "value", "for", "arg", "in", "call_site", "positional_arguments", "expected_args", "self", "assertequal", "len", "call_site", "keyword_arguments", "len", "expected_keywords", "for", "keyword", "value", "in", "expected_keywords", "items", "self", "assertin", "keyword", "call_site", "keyword_arguments", "self", "assertequal", "call_site", "keyword_arguments", "keyword", "value", "value"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::CallSiteTest._test_call_site", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "_test_call_site", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def _test_call_site(\n        self, pairs: List[Tuple[str, List[int], Dict[str, int]]]\n    ) -> None:\n        for pair in pairs:\n            self._test_call_site_pair(*pair)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "_test_call_site", "self", "pairs", "list", "tuple", "str", "list", "int", "dict", "str", "int", "none", "for", "pair", "in", "pairs", "self", "_test_call_site_pair", "pair"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::CallSiteTest.test_call_site_starred_args", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "test_call_site_starred_args", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def test_call_site_starred_args(self) -> None:\n        pairs = [\n            (\n                \"f(*(1, 2), *(2, 3), *(3, 4), **{'a':1}, **{'b': 2})\",\n                [1, 2, 2, 3, 3, 4],\n                {\"a\": 1, \"b\": 2},\n            ),\n            (\n                \"f(1, 2, *(3, 4), 5, *(6, 7), f=24, **{'c':3})\",\n                [1, 2, 3, 4, 5, 6, 7],\n                {\"f\": 24, \"c\": 3},\n            ),\n            # Too many fs passed into.\n            (\"f(f=24, **{'f':24})\", [], {}),\n        ]\n        self._test_call_site(pairs)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "test_call_site_starred_args", "self", "none", "pairs", "f", "1", "2", "2", "3", "3", "4", "a", "1", "b", "2", "1", "2", "2", "3", "3", "4", "a", "1", "b", "2", "f", "1", "2", "3", "4", "5", "6", "7", "f", "24", "c", "3", "1", "2", "3", "4", "5", "6", "7", "f", "24", "c", "3", "too", "many", "fs", "passed", "into", "f", "f", "24", "f", "24", "self", "_test_call_site", "pairs"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::CallSiteTest.test_call_site", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "test_call_site", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def test_call_site(self) -> None:\n        pairs = [\n            (\"f(1, 2)\", [1, 2], {}),\n            (\"f(1, 2, *(1, 2))\", [1, 2, 1, 2], {}),\n            (\"f(a=1, b=2, c=3)\", [], {\"a\": 1, \"b\": 2, \"c\": 3}),\n        ]\n        self._test_call_site(pairs)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "test_call_site", "self", "none", "pairs", "f", "1", "2", "1", "2", "f", "1", "2", "1", "2", "1", "2", "1", "2", "f", "a", "1", "b", "2", "c", "3", "a", "1", "b", "2", "c", "3", "self", "_test_call_site", "pairs"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::CallSiteTest._test_call_site_valid_arguments", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "_test_call_site_valid_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def _test_call_site_valid_arguments(self, values: List[str], invalid: bool) -> None:\n        for value in values:\n            ast_node = extract_node(value)\n            call_site = self._call_site_from_call(ast_node)\n            self.assertEqual(call_site.has_invalid_arguments(), invalid)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "_test_call_site_valid_arguments", "self", "values", "list", "str", "invalid", "bool", "none", "for", "value", "in", "values", "ast_node", "extract_node", "value", "call_site", "self", "_call_site_from_call", "ast_node", "self", "assertequal", "call_site", "has_invalid_arguments", "invalid"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::CallSiteTest.test_call_site_valid_arguments", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "test_call_site_valid_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def test_call_site_valid_arguments(self) -> None:\n        values = [\"f(*lala)\", \"f(*1)\", \"f(*object)\"]\n        self._test_call_site_valid_arguments(values, invalid=True)\n        values = [\"f()\", \"f(*(1, ))\", \"f(1, 2, *(2, 3))\"]\n        self._test_call_site_valid_arguments(values, invalid=False)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "test_call_site_valid_arguments", "self", "none", "values", "f", "lala", "f", "1", "f", "object", "self", "_test_call_site_valid_arguments", "values", "invalid", "true", "values", "f", "f", "1", "f", "1", "2", "2", "3", "self", "_test_call_site_valid_arguments", "values", "invalid", "false"], "doc_len": 34}
{"doc_id": "tests/unittest_inference.py::CallSiteTest.test_duplicated_keyword_arguments", "file_path": "tests/unittest_inference.py", "class_name": "CallSiteTest", "func_name": "test_duplicated_keyword_arguments", "text": "文件路径: tests/unittest_inference.py, 类名: CallSiteTest\n    def test_duplicated_keyword_arguments(self) -> None:\n        ast_node = extract_node('f(f=24, **{\"f\": 25})')\n        site = self._call_site_from_call(ast_node)\n        self.assertIn(\"f\", site.duplicated_keywords)\n", "tokens": ["tests", "unittest_inference", "py", "callsitetest", "def", "test_duplicated_keyword_arguments", "self", "none", "ast_node", "extract_node", "f", "f", "24", "f", "25", "site", "self", "_call_site_from_call", "ast_node", "self", "assertin", "f", "site", "duplicated_keywords"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::ObjectDunderNewTest.test_object_dunder_new_is_inferred_if_decorator", "file_path": "tests/unittest_inference.py", "class_name": "ObjectDunderNewTest", "func_name": "test_object_dunder_new_is_inferred_if_decorator", "text": "文件路径: tests/unittest_inference.py, 类名: ObjectDunderNewTest\n    def test_object_dunder_new_is_inferred_if_decorator(self) -> None:\n        node = extract_node(\n            \"\"\"\n        @object.__new__\n        class instance(object):\n            pass\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, Instance)\n", "tokens": ["tests", "unittest_inference", "py", "objectdundernewtest", "def", "test_object_dunder_new_is_inferred_if_decorator", "self", "none", "node", "extract_node", "object", "__new__", "class", "instance", "object", "pass", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "instance"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::test_augassign_recursion", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_augassign_recursion", "text": "文件路径: tests/unittest_inference.py\ndef test_augassign_recursion() -> None:\n    \"\"\"Make sure inference doesn't throw a RecursionError\n\n    Regression test for augmented assign dropping context.path\n    causing recursion errors\n\n    \"\"\"\n    # infinitely recurses in python\n    code = \"\"\"\n    def rec():\n        a = 0\n        a += rec()\n        return a\n    rec()\n    \"\"\"\n    cls_node = extract_node(code)\n    assert next(cls_node.infer()) is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_augassign_recursion", "none", "make", "sure", "inference", "doesn", "t", "throw", "a", "recursionerror", "regression", "test", "for", "augmented", "assign", "dropping", "context", "path", "causing", "recursion", "errors", "infinitely", "recurses", "in", "python", "code", "def", "rec", "a", "0", "a", "rec", "return", "a", "rec", "cls_node", "extract_node", "code", "assert", "next", "cls_node", "infer", "is", "util", "uninferable"], "doc_len": 49}
{"doc_id": "tests/unittest_inference.py::test_infer_custom_inherit_from_property", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_custom_inherit_from_property", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_custom_inherit_from_property() -> None:\n    node = extract_node(\n        \"\"\"\n    class custom_property(property):\n        pass\n\n    class MyClass(object):\n        @custom_property\n        def my_prop(self):\n            return 1\n\n    MyClass().my_prop\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == 1\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_custom_inherit_from_property", "none", "node", "extract_node", "class", "custom_property", "property", "pass", "class", "myclass", "object", "custom_property", "def", "my_prop", "self", "return", "1", "myclass", "my_prop", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "1"], "doc_len": 36}
{"doc_id": "tests/unittest_inference.py::test_cannot_infer_call_result_for_builtin_methods", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_cannot_infer_call_result_for_builtin_methods", "text": "文件路径: tests/unittest_inference.py\ndef test_cannot_infer_call_result_for_builtin_methods() -> None:\n    node = extract_node(\n        \"\"\"\n    a = \"fast\"\n    a\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    lenmeth = next(inferred.igetattr(\"__len__\"))\n    with pytest.raises(InferenceError):\n        next(lenmeth.infer_call_result(None, None))\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_cannot_infer_call_result_for_builtin_methods", "none", "node", "extract_node", "a", "fast", "a", "inferred", "next", "node", "infer", "lenmeth", "next", "inferred", "igetattr", "__len__", "with", "pytest", "raises", "inferenceerror", "next", "lenmeth", "infer_call_result", "none", "none"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::test_unpack_dicts_in_assignment", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_unpack_dicts_in_assignment", "text": "文件路径: tests/unittest_inference.py\ndef test_unpack_dicts_in_assignment() -> None:\n    ast_nodes = extract_node(\n        \"\"\"\n    a, b = {1:2, 2:3}\n    a #@\n    b #@\n    \"\"\"\n    )\n    assert isinstance(ast_nodes, list)\n    first_inferred = next(ast_nodes[0].infer())\n    second_inferred = next(ast_nodes[1].infer())\n    assert isinstance(first_inferred, nodes.Const)\n    assert first_inferred.value == 1\n    assert isinstance(second_inferred, nodes.Const)\n    assert second_inferred.value == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_unpack_dicts_in_assignment", "none", "ast_nodes", "extract_node", "a", "b", "1", "2", "2", "3", "a", "b", "assert", "isinstance", "ast_nodes", "list", "first_inferred", "next", "ast_nodes", "0", "infer", "second_inferred", "next", "ast_nodes", "1", "infer", "assert", "isinstance", "first_inferred", "nodes", "const", "assert", "first_inferred", "value", "1", "assert", "isinstance", "second_inferred", "nodes", "const", "assert", "second_inferred", "value", "2"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::test_slice_inference_in_for_loops", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_slice_inference_in_for_loops", "text": "文件路径: tests/unittest_inference.py\ndef test_slice_inference_in_for_loops() -> None:\n    node = extract_node(\n        \"\"\"\n    for a, (c, *b) in [(1, (2, 3, 4)), (4, (5, 6))]:\n       b #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[3, 4]\"\n\n    node = extract_node(\n        \"\"\"\n    for a, *b in [(1, 2, 3, 4)]:\n       b #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[2, 3, 4]\"\n\n    node = extract_node(\n        \"\"\"\n    for a, *b in [(1,)]:\n       b #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[]\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_slice_inference_in_for_loops", "none", "node", "extract_node", "for", "a", "c", "b", "in", "1", "2", "3", "4", "4", "5", "6", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string", "3", "4", "node", "extract_node", "for", "a", "b", "in", "1", "2", "3", "4", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string", "2", "3", "4", "node", "extract_node", "for", "a", "b", "in", "1", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string"], "doc_len": 81}
{"doc_id": "tests/unittest_inference.py::test_slice_inference_in_for_loops_not_working", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_slice_inference_in_for_loops_not_working", "text": "文件路径: tests/unittest_inference.py\ndef test_slice_inference_in_for_loops_not_working() -> None:\n    ast_nodes = extract_node(\n        \"\"\"\n    from unknown import Unknown\n    for a, *b in something:\n        b #@\n    for a, *b in Unknown:\n        b #@\n    for a, *b in (1):\n        b #@\n    \"\"\"\n    )\n    for node in ast_nodes:\n        inferred = next(node.infer())\n        assert inferred == util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_slice_inference_in_for_loops_not_working", "none", "ast_nodes", "extract_node", "from", "unknown", "import", "unknown", "for", "a", "b", "in", "something", "b", "for", "a", "b", "in", "unknown", "b", "for", "a", "b", "in", "1", "b", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "inferred", "util", "uninferable"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::test_unpacking_starred_and_dicts_in_assignment", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_unpacking_starred_and_dicts_in_assignment", "text": "文件路径: tests/unittest_inference.py\ndef test_unpacking_starred_and_dicts_in_assignment() -> None:\n    node = extract_node(\n        \"\"\"\n    a, *b = {1:2, 2:3, 3:4}\n    b\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[2, 3]\"\n\n    node = extract_node(\n        \"\"\"\n    a, *b = {1:2}\n    b\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[]\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_unpacking_starred_and_dicts_in_assignment", "none", "node", "extract_node", "a", "b", "1", "2", "2", "3", "3", "4", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string", "2", "3", "node", "extract_node", "a", "b", "1", "2", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string"], "doc_len": 50}
{"doc_id": "tests/unittest_inference.py::test_unpacking_starred_empty_list_in_assignment", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_unpacking_starred_empty_list_in_assignment", "text": "文件路径: tests/unittest_inference.py\ndef test_unpacking_starred_empty_list_in_assignment() -> None:\n    node = extract_node(\n        \"\"\"\n    a, *b, c = [1, 2]\n    b #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert inferred.as_string() == \"[]\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_unpacking_starred_empty_list_in_assignment", "none", "node", "extract_node", "a", "b", "c", "1", "2", "b", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "inferred", "as_string"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_regression_infinite_loop_decorator", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_regression_infinite_loop_decorator", "text": "文件路径: tests/unittest_inference.py\ndef test_regression_infinite_loop_decorator() -> None:\n    \"\"\"Make sure decorators with the same names\n    as a decorated method do not cause an infinite loop\n\n    See https://github.com/PyCQA/astroid/issues/375\n    \"\"\"\n    code = \"\"\"\n    from functools import lru_cache\n\n    class Foo():\n        @lru_cache()\n        def lru_cache(self, value):\n            print('Computing {}'.format(value))\n            return value\n    Foo().lru_cache(1)\n    \"\"\"\n    node = extract_node(code)\n    assert isinstance(node, nodes.NodeNG)\n    [result] = node.inferred()\n    assert result.value == 1\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_regression_infinite_loop_decorator", "none", "make", "sure", "decorators", "with", "the", "same", "names", "as", "a", "decorated", "method", "do", "not", "cause", "an", "infinite", "loop", "see", "https", "github", "com", "pycqa", "astroid", "issues", "375", "code", "from", "functools", "import", "lru_cache", "class", "foo", "lru_cache", "def", "lru_cache", "self", "value", "print", "computing", "format", "value", "return", "value", "foo", "lru_cache", "1", "node", "extract_node", "code", "assert", "isinstance", "node", "nodes", "nodeng", "result", "node", "inferred", "assert", "result", "value", "1"], "doc_len": 67}
{"doc_id": "tests/unittest_inference.py::test_stop_iteration_in_int", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_stop_iteration_in_int", "text": "文件路径: tests/unittest_inference.py\ndef test_stop_iteration_in_int() -> None:\n    \"\"\"Handle StopIteration error in infer_int.\"\"\"\n    code = \"\"\"\n    def f(lst):\n        if lst[0]:\n            return f(lst)\n        else:\n            args = lst[:1]\n            return int(args[0])\n\n    f([])\n    \"\"\"\n    [first_result, second_result] = extract_node(code).inferred()\n    assert first_result is util.Uninferable\n    assert isinstance(second_result, Instance)\n    assert second_result.name == \"int\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_stop_iteration_in_int", "none", "handle", "stopiteration", "error", "in", "infer_int", "code", "def", "f", "lst", "if", "lst", "0", "return", "f", "lst", "else", "args", "lst", "1", "return", "int", "args", "0", "f", "first_result", "second_result", "extract_node", "code", "inferred", "assert", "first_result", "is", "util", "uninferable", "assert", "isinstance", "second_result", "instance", "assert", "second_result", "name", "int"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::test_call_on_instance_with_inherited_dunder_call_method", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_call_on_instance_with_inherited_dunder_call_method", "text": "文件路径: tests/unittest_inference.py\ndef test_call_on_instance_with_inherited_dunder_call_method() -> None:\n    \"\"\"Stop inherited __call__ method from incorrectly returning wrong class\n\n    See https://github.com/PyCQA/pylint/issues/2199\n    \"\"\"\n    node = extract_node(\n        \"\"\"\n    class Base:\n        def __call__(self):\n            return self\n\n    class Sub(Base):\n        pass\n    obj = Sub()\n    val = obj()\n    val #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    [val] = node.inferred()\n    assert isinstance(val, Instance)\n    assert val.name == \"Sub\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_call_on_instance_with_inherited_dunder_call_method", "none", "stop", "inherited", "__call__", "method", "from", "incorrectly", "returning", "wrong", "class", "see", "https", "github", "com", "pycqa", "pylint", "issues", "2199", "node", "extract_node", "class", "base", "def", "__call__", "self", "return", "self", "class", "sub", "base", "pass", "obj", "sub", "val", "obj", "val", "assert", "isinstance", "node", "nodes", "nodeng", "val", "node", "inferred", "assert", "isinstance", "val", "instance", "assert", "val", "name", "sub"], "doc_len": 57}
{"doc_id": "tests/unittest_inference.py::TestInferencePropagation.test_call_context_propagation", "file_path": "tests/unittest_inference.py", "class_name": "TestInferencePropagation", "func_name": "test_call_context_propagation", "text": "文件路径: tests/unittest_inference.py, 类名: TestInferencePropagation\n    def test_call_context_propagation(self):\n        n = extract_node(\n            \"\"\"\n        def chest(a):\n            return a * a\n        def best(a, b):\n            return chest(a)\n        def test(a, b, c):\n            return best(a, b)\n        test(4, 5, 6) #@\n        \"\"\"\n        )\n        assert next(n.infer()).as_string() == \"16\"\n", "tokens": ["tests", "unittest_inference", "py", "testinferencepropagation", "def", "test_call_context_propagation", "self", "n", "extract_node", "def", "chest", "a", "return", "a", "a", "def", "best", "a", "b", "return", "chest", "a", "def", "test", "a", "b", "c", "return", "best", "a", "b", "test", "4", "5", "6", "assert", "next", "n", "infer", "as_string", "16"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::TestInferencePropagation.test_call_starargs_propagation", "file_path": "tests/unittest_inference.py", "class_name": "TestInferencePropagation", "func_name": "test_call_starargs_propagation", "text": "文件路径: tests/unittest_inference.py, 类名: TestInferencePropagation\n    def test_call_starargs_propagation(self) -> None:\n        code = \"\"\"\n        def foo(*args):\n            return args\n        def bar(*args):\n            return foo(*args)\n        bar(4, 5, 6, 7) #@\n        \"\"\"\n        assert next(extract_node(code).infer()).as_string() == \"(4, 5, 6, 7)\"\n", "tokens": ["tests", "unittest_inference", "py", "testinferencepropagation", "def", "test_call_starargs_propagation", "self", "none", "code", "def", "foo", "args", "return", "args", "def", "bar", "args", "return", "foo", "args", "bar", "4", "5", "6", "7", "assert", "next", "extract_node", "code", "infer", "as_string", "4", "5", "6", "7"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::TestInferencePropagation.test_call_kwargs_propagation", "file_path": "tests/unittest_inference.py", "class_name": "TestInferencePropagation", "func_name": "test_call_kwargs_propagation", "text": "文件路径: tests/unittest_inference.py, 类名: TestInferencePropagation\n    def test_call_kwargs_propagation(self) -> None:\n        code = \"\"\"\n        def b(**kwargs):\n            return kwargs\n        def f(**kwargs):\n            return b(**kwargs)\n        f(**{'f': 1}) #@\n        \"\"\"\n        assert next(extract_node(code).infer()).as_string() == \"{'f': 1}\"\n", "tokens": ["tests", "unittest_inference", "py", "testinferencepropagation", "def", "test_call_kwargs_propagation", "self", "none", "code", "def", "b", "kwargs", "return", "kwargs", "def", "f", "kwargs", "return", "b", "kwargs", "f", "f", "1", "assert", "next", "extract_node", "code", "infer", "as_string", "f", "1"], "doc_len": 31}
{"doc_id": "tests/unittest_inference.py::test_compare", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare", "text": "文件路径: tests/unittest_inference.py\ndef test_compare(op, result) -> None:\n    code = f\"\"\"\n    123 {op} 123\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value == result\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare", "op", "result", "none", "code", "f", "123", "op", "123", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "result"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::test_compare_identity", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_identity", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_identity(op, result) -> None:\n    code = f\"\"\"\n    obj = object()\n    obj {op} obj\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value == result\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_identity", "op", "result", "none", "code", "f", "obj", "object", "obj", "op", "obj", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "result"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_membership", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_membership", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_membership(op, result) -> None:\n    code = f\"\"\"\n    1 {op} [1, 2, 3]\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value == result\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_membership", "op", "result", "none", "code", "f", "1", "op", "1", "2", "3", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "result"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_lesseq_types", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_lesseq_types", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_lesseq_types(lhs, rhs, result) -> None:\n    code = f\"\"\"\n    {lhs!r} <= {rhs!r}\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value == result\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_lesseq_types", "lhs", "rhs", "result", "none", "code", "f", "lhs", "r", "rhs", "r", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "result"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_chained", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_chained", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_chained() -> None:\n    code = \"\"\"\n    3 < 5 > 3\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value is True\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_chained", "none", "code", "3", "5", "3", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "is", "true"], "doc_len": 22}
{"doc_id": "tests/unittest_inference.py::test_compare_inferred_members", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_inferred_members", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_inferred_members() -> None:\n    code = \"\"\"\n    a = 11\n    b = 13\n    a < b\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value is True\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_inferred_members", "none", "code", "a", "11", "b", "13", "a", "b", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "is", "true"], "doc_len": 25}
{"doc_id": "tests/unittest_inference.py::test_compare_instance_members", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_instance_members", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_instance_members() -> None:\n    code = \"\"\"\n    class A:\n        value = 123\n    class B:\n        @property\n        def value(self):\n            return 456\n    A().value < B().value\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value is True\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_instance_members", "none", "code", "class", "a", "value", "123", "class", "b", "property", "def", "value", "self", "return", "456", "a", "value", "b", "value", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "is", "true"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::test_compare_dynamic", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_dynamic", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_dynamic() -> None:\n    code = \"\"\"\n    class A:\n        def __le__(self, other):\n            return True\n    A() <= None\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value is True\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_dynamic", "none", "code", "class", "a", "def", "__le__", "self", "other", "return", "true", "a", "none", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "is", "true"], "doc_len": 29}
{"doc_id": "tests/unittest_inference.py::test_compare_uninferable_member", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_uninferable_member", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_uninferable_member() -> None:\n    code = \"\"\"\n    from unknown import UNKNOWN\n    0 <= UNKNOWN\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_uninferable_member", "none", "code", "from", "unknown", "import", "unknown", "0", "unknown", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 25}
{"doc_id": "tests/unittest_inference.py::test_compare_chained_comparisons_shortcircuit_on_false", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_chained_comparisons_shortcircuit_on_false", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_chained_comparisons_shortcircuit_on_false() -> None:\n    code = \"\"\"\n    from unknown import UNKNOWN\n    2 < 1 < UNKNOWN\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred.value is False\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_chained_comparisons_shortcircuit_on_false", "none", "code", "from", "unknown", "import", "unknown", "2", "1", "unknown", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "value", "is", "false"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_chained_comparisons_continue_on_true", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_chained_comparisons_continue_on_true", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_chained_comparisons_continue_on_true() -> None:\n    code = \"\"\"\n    from unknown import UNKNOWN\n    1 < 2 < UNKNOWN\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_chained_comparisons_continue_on_true", "none", "code", "from", "unknown", "import", "unknown", "1", "2", "unknown", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_known_false_branch", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_known_false_branch", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_known_false_branch() -> None:\n    code = \"\"\"\n    a = 'hello'\n    if 1 < 2:\n        a = 'goodbye'\n    a\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hello\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_known_false_branch", "none", "code", "a", "hello", "if", "1", "2", "a", "goodbye", "a", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hello"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::test_compare_ifexp_constant", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_ifexp_constant", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_ifexp_constant() -> None:\n    code = \"\"\"\n    a = 'hello' if 1 < 2 else 'goodbye'\n    a\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == \"hello\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_ifexp_constant", "none", "code", "a", "hello", "if", "1", "2", "else", "goodbye", "a", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "hello"], "doc_len": 37}
{"doc_id": "tests/unittest_inference.py::test_compare_typeerror", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_typeerror", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_typeerror() -> None:\n    code = \"\"\"\n    123 <= \"abc\"\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    assert inferred[0] is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_typeerror", "none", "code", "123", "abc", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "util", "uninferable"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_compare_multiple_possibilites", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_multiple_possibilites", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_multiple_possibilites() -> None:\n    code = \"\"\"\n    from unknown import UNKNOWN\n    a = 1\n    if UNKNOWN:\n        a = 2\n    b = 3\n    if UNKNOWN:\n        b = 4\n    a < b\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    # All possible combinations are true: (1 < 3), (1 < 4), (2 < 3), (2 < 4)\n    assert inferred[0].value is True\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_multiple_possibilites", "none", "code", "from", "unknown", "import", "unknown", "a", "1", "if", "unknown", "a", "2", "b", "3", "if", "unknown", "b", "4", "a", "b", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "all", "possible", "combinations", "are", "true", "1", "3", "1", "4", "2", "3", "2", "4", "assert", "inferred", "0", "value", "is", "true"], "doc_len": 55}
{"doc_id": "tests/unittest_inference.py::test_compare_ambiguous_multiple_possibilites", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_ambiguous_multiple_possibilites", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_ambiguous_multiple_possibilites() -> None:\n    code = \"\"\"\n    from unknown import UNKNOWN\n    a = 1\n    if UNKNOWN:\n        a = 3\n    b = 2\n    if UNKNOWN:\n        b = 4\n    a < b\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    # Not all possible combinations are true: (1 < 2), (1 < 4), (3 !< 2), (3 < 4)\n    assert inferred[0] is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_ambiguous_multiple_possibilites", "none", "code", "from", "unknown", "import", "unknown", "a", "1", "if", "unknown", "a", "3", "b", "2", "if", "unknown", "b", "4", "a", "b", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "not", "all", "possible", "combinations", "are", "true", "1", "2", "1", "4", "3", "2", "3", "4", "assert", "inferred", "0", "is", "util", "uninferable"], "doc_len": 56}
{"doc_id": "tests/unittest_inference.py::test_compare_nonliteral", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_nonliteral", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_nonliteral() -> None:\n    code = \"\"\"\n    def func(a, b):\n        return (a, b) <= (1, 2) #@\n    \"\"\"\n    return_node = extract_node(code)\n    node = return_node.value\n    inferred = list(node.infer())  # should not raise ValueError\n    assert len(inferred) == 1\n    assert inferred[0] is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_nonliteral", "none", "code", "def", "func", "a", "b", "return", "a", "b", "1", "2", "return_node", "extract_node", "code", "node", "return_node", "value", "inferred", "list", "node", "infer", "should", "not", "raise", "valueerror", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "util", "uninferable"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::test_compare_unknown", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_compare_unknown", "text": "文件路径: tests/unittest_inference.py\ndef test_compare_unknown() -> None:\n    code = \"\"\"\n    def func(a):\n        if tuple() + (a[1],) in set():\n            raise Exception()\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_compare_unknown", "none", "code", "def", "func", "a", "if", "tuple", "a", "1", "in", "set", "raise", "exception", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "functiondef"], "doc_len": 35}
{"doc_id": "tests/unittest_inference.py::test_limit_inference_result_amount", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_limit_inference_result_amount", "text": "文件路径: tests/unittest_inference.py\ndef test_limit_inference_result_amount() -> None:\n    \"\"\"Test setting limit inference result amount\"\"\"\n    code = \"\"\"\n    args = []\n\n    if True:\n        args += ['a']\n\n    if True:\n        args += ['b']\n\n    if True:\n        args += ['c']\n\n    if True:\n        args += ['d']\n\n    args #@\n    \"\"\"\n    result = extract_node(code).inferred()\n    assert len(result) == 16\n    with patch(\"astroid.manager.AstroidManager.max_inferable_values\", 4):\n        result_limited = extract_node(code).inferred()\n    # Can't guarantee exact size\n    assert len(result_limited) < 16\n    # Will not always be at the end\n    assert util.Uninferable in result_limited\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_limit_inference_result_amount", "none", "test", "setting", "limit", "inference", "result", "amount", "code", "args", "if", "true", "args", "a", "if", "true", "args", "b", "if", "true", "args", "c", "if", "true", "args", "d", "args", "result", "extract_node", "code", "inferred", "assert", "len", "result", "16", "with", "patch", "astroid", "manager", "astroidmanager", "max_inferable_values", "4", "result_limited", "extract_node", "code", "inferred", "can", "t", "guarantee", "exact", "size", "assert", "len", "result_limited", "16", "will", "not", "always", "be", "at", "the", "end", "assert", "util", "uninferable", "in", "result_limited"], "doc_len": 71}
{"doc_id": "tests/unittest_inference.py::test_attribute_inference_should_not_access_base_classes", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_attribute_inference_should_not_access_base_classes", "text": "文件路径: tests/unittest_inference.py\ndef test_attribute_inference_should_not_access_base_classes() -> None:\n    \"\"\"attributes of classes should mask ancestor attributes\"\"\"\n    code = \"\"\"\n    type.__new__ #@\n    \"\"\"\n    res = extract_node(code).inferred()\n    assert len(res) == 1\n    assert res[0].parent.name == \"type\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_attribute_inference_should_not_access_base_classes", "none", "attributes", "of", "classes", "should", "mask", "ancestor", "attributes", "code", "type", "__new__", "res", "extract_node", "code", "inferred", "assert", "len", "res", "1", "assert", "res", "0", "parent", "name", "type"], "doc_len": 30}
{"doc_id": "tests/unittest_inference.py::test_attribute_mro_object_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_attribute_mro_object_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_attribute_mro_object_inference() -> None:\n    \"\"\"\n    Inference should only infer results from the first available method\n    \"\"\"\n    inferred = extract_node(\n        \"\"\"\n    class A:\n        def foo(self):\n            return 1\n    class B(A):\n        def foo(self):\n            return 2\n    B().foo() #@\n    \"\"\"\n    ).inferred()\n    assert len(inferred) == 1\n    assert inferred[0].value == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_attribute_mro_object_inference", "none", "inference", "should", "only", "infer", "results", "from", "the", "first", "available", "method", "inferred", "extract_node", "class", "a", "def", "foo", "self", "return", "1", "class", "b", "a", "def", "foo", "self", "return", "2", "b", "foo", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "value", "2"], "doc_len": 45}
{"doc_id": "tests/unittest_inference.py::test_inferred_sequence_unpacking_works", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_inferred_sequence_unpacking_works", "text": "文件路径: tests/unittest_inference.py\ndef test_inferred_sequence_unpacking_works() -> None:\n    inferred = next(\n        extract_node(\n            \"\"\"\n    def test(*args):\n        return (1, *args)\n    test(2) #@\n    \"\"\"\n        ).infer()\n    )\n    assert isinstance(inferred, nodes.Tuple)\n    assert len(inferred.elts) == 2\n    assert [value.value for value in inferred.elts] == [1, 2]\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_inferred_sequence_unpacking_works", "none", "inferred", "next", "extract_node", "def", "test", "args", "return", "1", "args", "test", "2", "infer", "assert", "isinstance", "inferred", "nodes", "tuple", "assert", "len", "inferred", "elts", "2", "assert", "value", "value", "for", "value", "in", "inferred", "elts", "1", "2"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::test_recursion_error_inferring_slice", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_recursion_error_inferring_slice", "text": "文件路径: tests/unittest_inference.py\ndef test_recursion_error_inferring_slice() -> None:\n    node = extract_node(\n        \"\"\"\n    class MyClass:\n        def __init__(self):\n            self._slice = slice(0, 10)\n\n        def incr(self):\n            self._slice = slice(0, self._slice.stop + 1)\n\n        def test(self):\n            self._slice #@\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, Slice)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_recursion_error_inferring_slice", "none", "node", "extract_node", "class", "myclass", "def", "__init__", "self", "self", "_slice", "slice", "0", "10", "def", "incr", "self", "self", "_slice", "slice", "0", "self", "_slice", "stop", "1", "def", "test", "self", "self", "_slice", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "slice"], "doc_len": 42}
{"doc_id": "tests/unittest_inference.py::test_exception_lookup_last_except_handler_wins", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_exception_lookup_last_except_handler_wins", "text": "文件路径: tests/unittest_inference.py\ndef test_exception_lookup_last_except_handler_wins() -> None:\n    node = extract_node(\n        \"\"\"\n    try:\n        1/0\n    except ValueError as exc:\n        pass\n    try:\n        1/0\n    except OSError as exc:\n        exc #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    inferred_exc = inferred[0]\n    assert isinstance(inferred_exc, Instance)\n    assert inferred_exc.name == \"OSError\"\n\n    # Check that two except handlers on the same TryExcept works the same as separate\n    # TryExcepts\n    node = extract_node(\n        \"\"\"\n    try:\n        1/0\n    except ZeroDivisionError as exc:\n        pass\n    except ValueError as exc:\n        exc #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    inferred_exc = inferred[0]\n    assert isinstance(inferred_exc, Instance)\n    assert inferred_exc.name == \"ValueError\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_exception_lookup_last_except_handler_wins", "none", "node", "extract_node", "try", "1", "0", "except", "valueerror", "as", "exc", "pass", "try", "1", "0", "except", "oserror", "as", "exc", "exc", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "inferred_exc", "inferred", "0", "assert", "isinstance", "inferred_exc", "instance", "assert", "inferred_exc", "name", "oserror", "check", "that", "two", "except", "handlers", "on", "the", "same", "tryexcept", "works", "the", "same", "as", "separate", "tryexcepts", "node", "extract_node", "try", "1", "0", "except", "zerodivisionerror", "as", "exc", "pass", "except", "valueerror", "as", "exc", "exc", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "inferred_exc", "inferred", "0", "assert", "isinstance", "inferred_exc", "instance", "assert", "inferred_exc", "name", "valueerror"], "doc_len": 100}
{"doc_id": "tests/unittest_inference.py::test_exception_lookup_name_bound_in_except_handler", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_exception_lookup_name_bound_in_except_handler", "text": "文件路径: tests/unittest_inference.py\ndef test_exception_lookup_name_bound_in_except_handler() -> None:\n    node = extract_node(\n        \"\"\"\n    try:\n        1/0\n    except ValueError:\n        name = 1\n    try:\n        1/0\n    except OSError:\n        name = 2\n        name #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    inferred_exc = inferred[0]\n    assert isinstance(inferred_exc, nodes.Const)\n    assert inferred_exc.value == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_exception_lookup_name_bound_in_except_handler", "none", "node", "extract_node", "try", "1", "0", "except", "valueerror", "name", "1", "try", "1", "0", "except", "oserror", "name", "2", "name", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "inferred_exc", "inferred", "0", "assert", "isinstance", "inferred_exc", "nodes", "const", "assert", "inferred_exc", "value", "2"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::test_builtin_inference_list_of_exceptions", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_builtin_inference_list_of_exceptions", "text": "文件路径: tests/unittest_inference.py\ndef test_builtin_inference_list_of_exceptions() -> None:\n    node = extract_node(\n        \"\"\"\n    tuple([ValueError, TypeError])\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.Tuple)\n    assert len(inferred.elts) == 2\n    assert isinstance(inferred.elts[0], nodes.EvaluatedObject)\n    assert isinstance(inferred.elts[0].value, nodes.ClassDef)\n    assert inferred.elts[0].value.name == \"ValueError\"\n    assert isinstance(inferred.elts[1], nodes.EvaluatedObject)\n    assert isinstance(inferred.elts[1].value, nodes.ClassDef)\n    assert inferred.elts[1].value.name == \"TypeError\"\n\n    # Test that inference of evaluated objects returns what is expected\n    first_elem = next(inferred.elts[0].infer())\n    assert isinstance(first_elem, nodes.ClassDef)\n    assert first_elem.name == \"ValueError\"\n\n    second_elem = next(inferred.elts[1].infer())\n    assert isinstance(second_elem, nodes.ClassDef)\n    assert second_elem.name == \"TypeError\"\n\n    # Test that as_string() also works\n    as_string = inferred.as_string()\n    assert as_string.strip() == \"(ValueError, TypeError)\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_builtin_inference_list_of_exceptions", "none", "node", "extract_node", "tuple", "valueerror", "typeerror", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "tuple", "assert", "len", "inferred", "elts", "2", "assert", "isinstance", "inferred", "elts", "0", "nodes", "evaluatedobject", "assert", "isinstance", "inferred", "elts", "0", "value", "nodes", "classdef", "assert", "inferred", "elts", "0", "value", "name", "valueerror", "assert", "isinstance", "inferred", "elts", "1", "nodes", "evaluatedobject", "assert", "isinstance", "inferred", "elts", "1", "value", "nodes", "classdef", "assert", "inferred", "elts", "1", "value", "name", "typeerror", "test", "that", "inference", "of", "evaluated", "objects", "returns", "what", "is", "expected", "first_elem", "next", "inferred", "elts", "0", "infer", "assert", "isinstance", "first_elem", "nodes", "classdef", "assert", "first_elem", "name", "valueerror", "second_elem", "next", "inferred", "elts", "1", "infer", "assert", "isinstance", "second_elem", "nodes", "classdef", "assert", "second_elem", "name", "typeerror", "test", "that", "as_string", "also", "works", "as_string", "inferred", "as_string", "assert", "as_string", "strip", "valueerror", "typeerror"], "doc_len": 122}
{"doc_id": "tests/unittest_inference.py::test_cannot_getattr_ann_assigns", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_cannot_getattr_ann_assigns", "text": "文件路径: tests/unittest_inference.py\ndef test_cannot_getattr_ann_assigns() -> None:\n    node = extract_node(\n        \"\"\"\n    class Cls:\n        ann: int\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    with pytest.raises(AttributeInferenceError):\n        inferred.getattr(\"ann\")\n\n    # But if it had a value, then it would be okay.\n    node = extract_node(\n        \"\"\"\n    class Cls:\n        ann: int = 0\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    values = inferred.getattr(\"ann\")\n    assert len(values) == 1\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_cannot_getattr_ann_assigns", "none", "node", "extract_node", "class", "cls", "ann", "int", "inferred", "next", "node", "infer", "with", "pytest", "raises", "attributeinferenceerror", "inferred", "getattr", "ann", "but", "if", "it", "had", "a", "value", "then", "it", "would", "be", "okay", "node", "extract_node", "class", "cls", "ann", "int", "0", "inferred", "next", "node", "infer", "values", "inferred", "getattr", "ann", "assert", "len", "values", "1"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_prevent_recursion_error_in_igetattr_and_context_manager_inference() -> None:\n    code = \"\"\"\n    class DummyContext(object):\n        def __enter__(self):\n            return self\n        def __exit__(self, ex_type, ex_value, ex_tb):\n            return True\n\n    if False:\n        with DummyContext() as con:\n            pass\n\n    with DummyContext() as con:\n        con.__enter__  #@\n    \"\"\"\n    node = extract_node(code)\n    # According to the original issue raised that introduced this test\n    # (https://github.com/PyCQA/astroid/663, see 55076ca), this test was a\n    # non-regression check for StopIteration leaking out of inference and\n    # causing a RuntimeError. Hence, here just consume the inferred value\n    # without checking it and rely on pytest to fail on raise\n    next(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_prevent_recursion_error_in_igetattr_and_context_manager_inference", "none", "code", "class", "dummycontext", "object", "def", "__enter__", "self", "return", "self", "def", "__exit__", "self", "ex_type", "ex_value", "ex_tb", "return", "true", "if", "false", "with", "dummycontext", "as", "con", "pass", "with", "dummycontext", "as", "con", "con", "__enter__", "node", "extract_node", "code", "according", "to", "the", "original", "issue", "raised", "that", "introduced", "this", "test", "https", "github", "com", "pycqa", "astroid", "663", "see", "55076ca", "this", "test", "was", "a", "non", "regression", "check", "for", "stopiteration", "leaking", "out", "of", "inference", "and", "causing", "a", "runtimeerror", "hence", "here", "just", "consume", "the", "inferred", "value", "without", "checking", "it", "and", "rely", "on", "pytest", "to", "fail", "on", "raise", "next", "node", "infer"], "doc_len": 95}
{"doc_id": "tests/unittest_inference.py::test_infer_context_manager_with_unknown_args", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_context_manager_with_unknown_args", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_context_manager_with_unknown_args() -> None:\n    code = \"\"\"\n    class client_log(object):\n        def __init__(self, client):\n            self.client = client\n        def __enter__(self):\n            return self.client\n        def __exit__(self, exc_type, exc_value, traceback):\n            pass\n\n    with client_log(None) as c:\n        c #@\n    \"\"\"\n    node = extract_node(code)\n    assert next(node.infer()) is util.Uninferable\n\n    # But if we know the argument, then it is easy\n    code = \"\"\"\n    class client_log(object):\n        def __init__(self, client=24):\n            self.client = client\n        def __enter__(self):\n            return self.client\n        def __exit__(self, exc_type, exc_value, traceback):\n            pass\n\n    with client_log(None) as c:\n        c #@\n    \"\"\"\n    node = extract_node(code)\n    assert isinstance(next(node.infer()), nodes.Const)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_context_manager_with_unknown_args", "none", "code", "class", "client_log", "object", "def", "__init__", "self", "client", "self", "client", "client", "def", "__enter__", "self", "return", "self", "client", "def", "__exit__", "self", "exc_type", "exc_value", "traceback", "pass", "with", "client_log", "none", "as", "c", "c", "node", "extract_node", "code", "assert", "next", "node", "infer", "is", "util", "uninferable", "but", "if", "we", "know", "the", "argument", "then", "it", "is", "easy", "code", "class", "client_log", "object", "def", "__init__", "self", "client", "24", "self", "client", "client", "def", "__enter__", "self", "return", "self", "client", "def", "__exit__", "self", "exc_type", "exc_value", "traceback", "pass", "with", "client_log", "none", "as", "c", "c", "node", "extract_node", "code", "assert", "isinstance", "next", "node", "infer", "nodes", "const"], "doc_len": 97}
{"doc_id": "tests/unittest_inference.py::test_subclass_of_exception", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_subclass_of_exception", "text": "文件路径: tests/unittest_inference.py\ndef test_subclass_of_exception(code) -> None:\n    inferred = next(extract_node(code).infer())\n    assert isinstance(inferred, Instance)\n    args = next(inferred.igetattr(\"args\"))\n    assert isinstance(args, nodes.Tuple)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_subclass_of_exception", "code", "none", "inferred", "next", "extract_node", "code", "infer", "assert", "isinstance", "inferred", "instance", "args", "next", "inferred", "igetattr", "args", "assert", "isinstance", "args", "nodes", "tuple"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_ifexp_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_ifexp_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_ifexp_inference() -> None:\n    code = \"\"\"\n    def truth_branch():\n        return 1 if True else 2\n\n    def false_branch():\n        return 1 if False else 2\n\n    def both_branches():\n        return 1 if unknown() else 2\n\n    truth_branch() #@\n    false_branch() #@\n    both_branches() #@\n    \"\"\"\n    ast_nodes = extract_node(code)\n    assert isinstance(ast_nodes, list)\n    first = next(ast_nodes[0].infer())\n    assert isinstance(first, nodes.Const)\n    assert first.value == 1\n\n    second = next(ast_nodes[1].infer())\n    assert isinstance(second, nodes.Const)\n    assert second.value == 2\n\n    third = list(ast_nodes[2].infer())\n    assert isinstance(third, list)\n    assert [third[0].value, third[1].value] == [1, 2]\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_ifexp_inference", "none", "code", "def", "truth_branch", "return", "1", "if", "true", "else", "2", "def", "false_branch", "return", "1", "if", "false", "else", "2", "def", "both_branches", "return", "1", "if", "unknown", "else", "2", "truth_branch", "false_branch", "both_branches", "ast_nodes", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "assert", "isinstance", "first", "nodes", "const", "assert", "first", "value", "1", "second", "next", "ast_nodes", "1", "infer", "assert", "isinstance", "second", "nodes", "const", "assert", "second", "value", "2", "third", "list", "ast_nodes", "2", "infer", "assert", "isinstance", "third", "list", "assert", "third", "0", "value", "third", "1", "value", "1", "2"], "doc_len": 87}
{"doc_id": "tests/unittest_inference.py::test_assert_last_function_returns_none_on_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_assert_last_function_returns_none_on_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_assert_last_function_returns_none_on_inference() -> None:\n    code = \"\"\"\n    def check_equal(a, b):\n        res = do_something_with_these(a, b)\n        assert a == b == res\n\n    check_equal(a, b)\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value is None\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_assert_last_function_returns_none_on_inference", "none", "code", "def", "check_equal", "a", "b", "res", "do_something_with_these", "a", "b", "assert", "a", "b", "res", "check_equal", "a", "b", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "is", "none"], "doc_len": 39}
{"doc_id": "tests/unittest_inference.py::test_posonlyargs_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_posonlyargs_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_posonlyargs_inference() -> None:\n    code = \"\"\"\n    class A:\n        method = lambda self, b, /, c: b + c\n\n        def __init__(self, other=(), /, **kw):\n            self #@\n    A() #@\n    A().method #@\n\n    \"\"\"\n    self_node, instance, lambda_method = extract_node(code)\n    inferred = next(self_node.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.name == \"A\"\n\n    inferred = next(instance.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.name == \"A\"\n\n    inferred = next(lambda_method.infer())\n    assert isinstance(inferred, BoundMethod)\n    assert inferred.type == \"method\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_posonlyargs_inference", "none", "code", "class", "a", "method", "lambda", "self", "b", "c", "b", "c", "def", "__init__", "self", "other", "kw", "self", "a", "a", "method", "self_node", "instance", "lambda_method", "extract_node", "code", "inferred", "next", "self_node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "name", "a", "inferred", "next", "instance", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "name", "a", "inferred", "next", "lambda_method", "infer", "assert", "isinstance", "inferred", "boundmethod", "assert", "inferred", "type", "method"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::test_infer_args_unpacking_of_self", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_args_unpacking_of_self", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_args_unpacking_of_self() -> None:\n    code = \"\"\"\n    class A:\n        def __init__(*args, **kwargs):\n            self, *args = args\n            self.data = {1: 2}\n            self #@\n    A().data #@\n    \"\"\"\n    self, data = extract_node(code)\n    inferred_self = next(self.infer())\n    assert isinstance(inferred_self, Instance)\n    assert inferred_self.name == \"A\"\n\n    inferred_data = next(data.infer())\n    assert isinstance(inferred_data, nodes.Dict)\n    assert inferred_data.as_string() == \"{1: 2}\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_args_unpacking_of_self", "none", "code", "class", "a", "def", "__init__", "args", "kwargs", "self", "args", "args", "self", "data", "1", "2", "self", "a", "data", "self", "data", "extract_node", "code", "inferred_self", "next", "self", "infer", "assert", "isinstance", "inferred_self", "instance", "assert", "inferred_self", "name", "a", "inferred_data", "next", "data", "infer", "assert", "isinstance", "inferred_data", "nodes", "dict", "assert", "inferred_data", "as_string", "1", "2"], "doc_len": 53}
{"doc_id": "tests/unittest_inference.py::test_infer_exception_instance_attributes", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_exception_instance_attributes", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_exception_instance_attributes() -> None:\n    code = \"\"\"\n    class UnsupportedFormatCharacter(Exception):\n        def __init__(self, index):\n            Exception.__init__(self, index)\n            self.index = index\n\n    try:\n       1/0\n    except UnsupportedFormatCharacter as exc:\n       exc #@\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, ExceptionInstance)\n    index = inferred.getattr(\"index\")\n    assert len(index) == 1\n    assert isinstance(index[0], nodes.AssignAttr)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_exception_instance_attributes", "none", "code", "class", "unsupportedformatcharacter", "exception", "def", "__init__", "self", "index", "exception", "__init__", "self", "index", "self", "index", "index", "try", "1", "0", "except", "unsupportedformatcharacter", "as", "exc", "exc", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "exceptioninstance", "index", "inferred", "getattr", "index", "assert", "len", "index", "1", "assert", "isinstance", "index", "0", "nodes", "assignattr"], "doc_len": 54}
{"doc_id": "tests/unittest_inference.py::test_inference_is_limited_to_the_boundnode", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_inference_is_limited_to_the_boundnode", "text": "文件路径: tests/unittest_inference.py\ndef test_inference_is_limited_to_the_boundnode(code, instance_name) -> None:\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.name == instance_name\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_inference_is_limited_to_the_boundnode", "code", "instance_name", "none", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "name", "instance_name"], "doc_len": 23}
{"doc_id": "tests/unittest_inference.py::test_property_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_property_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_property_inference() -> None:\n    code = \"\"\"\n    class A:\n        @property\n        def test(self):\n            return 42\n\n        @test.setter\n        def test(self, value):\n            return \"banco\"\n\n    A.test #@\n    A().test #@\n    A.test.fget(A) #@\n    A.test.fset(A, \"a_value\") #@\n    A.test.setter #@\n    A.test.getter #@\n    A.test.deleter #@\n    \"\"\"\n    (\n        prop,\n        prop_result,\n        prop_fget_result,\n        prop_fset_result,\n        prop_setter,\n        prop_getter,\n        prop_deleter,\n    ) = extract_node(code)\n\n    inferred = next(prop.infer())\n    assert isinstance(inferred, objects.Property)\n    assert inferred.pytype() == \"builtins.property\"\n    assert inferred.type == \"property\"\n\n    inferred = next(prop_result.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == 42\n\n    inferred = next(prop_fget_result.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == 42\n\n    inferred = next(prop_fset_result.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == \"banco\"\n\n    for prop_func in prop_setter, prop_getter, prop_deleter:\n        inferred = next(prop_func.infer())\n        assert isinstance(inferred, nodes.FunctionDef)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_property_inference", "none", "code", "class", "a", "property", "def", "test", "self", "return", "42", "test", "setter", "def", "test", "self", "value", "return", "banco", "a", "test", "a", "test", "a", "test", "fget", "a", "a", "test", "fset", "a", "a_value", "a", "test", "setter", "a", "test", "getter", "a", "test", "deleter", "prop", "prop_result", "prop_fget_result", "prop_fset_result", "prop_setter", "prop_getter", "prop_deleter", "extract_node", "code", "inferred", "next", "prop", "infer", "assert", "isinstance", "inferred", "objects", "property", "assert", "inferred", "pytype", "builtins", "property", "assert", "inferred", "type", "property", "inferred", "next", "prop_result", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42", "inferred", "next", "prop_fget_result", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42", "inferred", "next", "prop_fset_result", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "banco", "for", "prop_func", "in", "prop_setter", "prop_getter", "prop_deleter", "inferred", "next", "prop_func", "infer", "assert", "isinstance", "inferred", "nodes", "functiondef"], "doc_len": 126}
{"doc_id": "tests/unittest_inference.py::test_property_as_string", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_property_as_string", "text": "文件路径: tests/unittest_inference.py\ndef test_property_as_string() -> None:\n    code = \"\"\"\n    class A:\n        @property\n        def test(self):\n            return 42\n\n    A.test #@\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, objects.Property)\n    property_body = textwrap.dedent(\n        \"\"\"\n    @property\n    def test(self):\n        return 42\n    \"\"\"\n    )\n    assert inferred.as_string().strip() == property_body.strip()\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_property_as_string", "none", "code", "class", "a", "property", "def", "test", "self", "return", "42", "a", "test", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "objects", "property", "property_body", "textwrap", "dedent", "property", "def", "test", "self", "return", "42", "assert", "inferred", "as_string", "strip", "property_body", "strip"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::test_property_callable_inference", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_property_callable_inference", "text": "文件路径: tests/unittest_inference.py\ndef test_property_callable_inference() -> None:\n    code = \"\"\"\n    class A:\n        def func(self):\n            return 42\n        p = property(func)\n    A().p\n    \"\"\"\n    property_call = extract_node(code)\n    inferred = next(property_call.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == 42\n\n    # Try with lambda as well\n    code = \"\"\"\n    class A:\n        p = property(lambda self: 42)\n    A().p\n    \"\"\"\n    property_call = extract_node(code)\n    inferred = next(property_call.infer())\n    assert isinstance(inferred, nodes.Const)\n    assert inferred.value == 42\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_property_callable_inference", "none", "code", "class", "a", "def", "func", "self", "return", "42", "p", "property", "func", "a", "p", "property_call", "extract_node", "code", "inferred", "next", "property_call", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42", "try", "with", "lambda", "as", "well", "code", "class", "a", "p", "property", "lambda", "self", "42", "a", "p", "property_call", "extract_node", "code", "inferred", "next", "property_call", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "42"], "doc_len": 66}
{"doc_id": "tests/unittest_inference.py::test_recursion_error_inferring_builtin_containers", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_recursion_error_inferring_builtin_containers", "text": "文件路径: tests/unittest_inference.py\ndef test_recursion_error_inferring_builtin_containers() -> None:\n    node = extract_node(\n        \"\"\"\n    class Foo:\n        a = \"foo\"\n    inst = Foo()\n\n    b = tuple([inst.a]) #@\n    inst.a = b\n    \"\"\"\n    )\n    helpers.safe_infer(node.targets[0])\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_recursion_error_inferring_builtin_containers", "none", "node", "extract_node", "class", "foo", "a", "foo", "inst", "foo", "b", "tuple", "inst", "a", "inst", "a", "b", "helpers", "safe_infer", "node", "targets", "0"], "doc_len": 26}
{"doc_id": "tests/unittest_inference.py::test_inferaugassign_picking_parent_instead_of_stmt", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_inferaugassign_picking_parent_instead_of_stmt", "text": "文件路径: tests/unittest_inference.py\ndef test_inferaugassign_picking_parent_instead_of_stmt() -> None:\n    code = \"\"\"\n    from collections import namedtuple\n    SomeClass = namedtuple('SomeClass', ['name'])\n    items = [SomeClass(name='some name')]\n\n    some_str = ''\n    some_str += ', '.join(__(item) for item in items)\n    \"\"\"\n    # item needs to be inferrd as `SomeClass` but it was inferred\n    # as a string because the entire `AugAssign` node was inferred\n    # as a string.\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.name == \"SomeClass\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_inferaugassign_picking_parent_instead_of_stmt", "none", "code", "from", "collections", "import", "namedtuple", "someclass", "namedtuple", "someclass", "name", "items", "someclass", "name", "some", "name", "some_str", "some_str", "join", "__", "item", "for", "item", "in", "items", "item", "needs", "to", "be", "inferrd", "as", "someclass", "but", "it", "was", "inferred", "as", "a", "string", "because", "the", "entire", "augassign", "node", "was", "inferred", "as", "a", "string", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "name", "someclass"], "doc_len": 68}
{"doc_id": "tests/unittest_inference.py::test_classmethod_from_builtins_inferred_as_bound", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_classmethod_from_builtins_inferred_as_bound", "text": "文件路径: tests/unittest_inference.py\ndef test_classmethod_from_builtins_inferred_as_bound() -> None:\n    code = \"\"\"\n    import builtins\n\n    class Foo():\n        @classmethod\n        def bar1(cls, text):\n            pass\n\n        @builtins.classmethod\n        def bar2(cls, text):\n            pass\n\n    Foo.bar1 #@\n    Foo.bar2 #@\n    \"\"\"\n    first_node, second_node = extract_node(code)\n    assert isinstance(next(first_node.infer()), BoundMethod)\n    assert isinstance(next(second_node.infer()), BoundMethod)\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_classmethod_from_builtins_inferred_as_bound", "none", "code", "import", "builtins", "class", "foo", "classmethod", "def", "bar1", "cls", "text", "pass", "builtins", "classmethod", "def", "bar2", "cls", "text", "pass", "foo", "bar1", "foo", "bar2", "first_node", "second_node", "extract_node", "code", "assert", "isinstance", "next", "first_node", "infer", "boundmethod", "assert", "isinstance", "next", "second_node", "infer", "boundmethod"], "doc_len": 44}
{"doc_id": "tests/unittest_inference.py::test_infer_dict_passes_context", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_dict_passes_context", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_dict_passes_context() -> None:\n    code = \"\"\"\n    k = {}\n    (_ for k in __(dict(**k)))\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.qname() == \"builtins.dict\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_dict_passes_context", "none", "code", "k", "_", "for", "k", "in", "__", "dict", "k", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "qname", "builtins", "dict"], "doc_len": 31}
{"doc_id": "tests/unittest_inference.py::test_custom_decorators_for_classmethod_and_staticmethods", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_custom_decorators_for_classmethod_and_staticmethods", "text": "文件路径: tests/unittest_inference.py\ndef test_custom_decorators_for_classmethod_and_staticmethods(code, obj, obj_type):\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, obj)\n    assert inferred.type == obj_type\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_custom_decorators_for_classmethod_and_staticmethods", "code", "obj", "obj_type", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "obj", "assert", "inferred", "type", "obj_type"], "doc_len": 23}
{"doc_id": "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_dataclasses_subscript_inference_recursion_error", "text": "文件路径: tests/unittest_inference.py\ndef test_dataclasses_subscript_inference_recursion_error():\n    code = \"\"\"\n    from dataclasses import dataclass, replace\n\n    @dataclass\n    class ProxyConfig:\n        auth: str = \"/auth\"\n\n\n    a = ProxyConfig(\"\")\n    test_dict = {\"proxy\" : {\"auth\" : \"\", \"bla\" : \"f\"}}\n\n    foo = test_dict['proxy']\n    replace(a, **test_dict['proxy']) # This fails\n    \"\"\"\n    node = extract_node(code)\n    # Reproduces only with safe_infer()\n    assert helpers.safe_infer(node) is None\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_dataclasses_subscript_inference_recursion_error", "code", "from", "dataclasses", "import", "dataclass", "replace", "dataclass", "class", "proxyconfig", "auth", "str", "auth", "a", "proxyconfig", "test_dict", "proxy", "auth", "bla", "f", "foo", "test_dict", "proxy", "replace", "a", "test_dict", "proxy", "this", "fails", "node", "extract_node", "code", "reproduces", "only", "with", "safe_infer", "assert", "helpers", "safe_infer", "node", "is", "none"], "doc_len": 46}
{"doc_id": "tests/unittest_inference.py::test_dataclasses_subscript_inference_recursion_error_39", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_dataclasses_subscript_inference_recursion_error_39", "text": "文件路径: tests/unittest_inference.py\ndef test_dataclasses_subscript_inference_recursion_error_39():\n    code = \"\"\"\n    from dataclasses import dataclass, replace\n\n    @dataclass\n    class ProxyConfig:\n        auth: str = \"/auth\"\n\n\n    a = ProxyConfig(\"\")\n    test_dict = {\"proxy\" : {\"auth\" : \"\", \"bla\" : \"f\"}}\n\n    foo = test_dict['proxy']\n    replace(a, **test_dict['proxy']) # This fails\n    \"\"\"\n    node = extract_node(code)\n    infer_val = helpers.safe_infer(node)\n    assert isinstance(infer_val, Instance)\n    assert infer_val.pytype() == \".ProxyConfig\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_dataclasses_subscript_inference_recursion_error_39", "code", "from", "dataclasses", "import", "dataclass", "replace", "dataclass", "class", "proxyconfig", "auth", "str", "auth", "a", "proxyconfig", "test_dict", "proxy", "auth", "bla", "f", "foo", "test_dict", "proxy", "replace", "a", "test_dict", "proxy", "this", "fails", "node", "extract_node", "code", "infer_val", "helpers", "safe_infer", "node", "assert", "isinstance", "infer_val", "instance", "assert", "infer_val", "pytype", "proxyconfig"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::test_self_reference_infer_does_not_trigger_recursion_error", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_self_reference_infer_does_not_trigger_recursion_error", "text": "文件路径: tests/unittest_inference.py\ndef test_self_reference_infer_does_not_trigger_recursion_error() -> None:\n    # Prevents https://github.com/PyCQA/pylint/issues/1285\n    code = \"\"\"\n    def func(elems):\n        return elems\n\n    class BaseModel(object):\n\n        def __init__(self, *args, **kwargs):\n            self._reference = func(*self._reference.split('.'))\n    BaseModel()._reference\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_self_reference_infer_does_not_trigger_recursion_error", "none", "prevents", "https", "github", "com", "pycqa", "pylint", "issues", "1285", "code", "def", "func", "elems", "return", "elems", "class", "basemodel", "object", "def", "__init__", "self", "args", "kwargs", "self", "_reference", "func", "self", "_reference", "split", "basemodel", "_reference", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 48}
{"doc_id": "tests/unittest_inference.py::test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "text": "文件路径: tests/unittest_inference.py\ndef test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times() -> None:\n    code = \"\"\"\n    class A:\n        @property\n        def a(self):\n            return 42\n\n    A()\n    \"\"\"\n    node = extract_node(code)\n    # Infer the class\n    cls = next(node.infer())\n    (prop,) = cls.getattr(\"a\")\n\n    # Try to infer the property function *multiple* times. `A.locals` should be modified only once\n    for _ in range(3):\n        prop.inferred()\n    a_locals = cls.locals[\"a\"]\n    # [FunctionDef, Property]\n    assert len(a_locals) == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_inferring_properties_multiple_time_does_not_mutate_locals_multiple_times", "none", "code", "class", "a", "property", "def", "a", "self", "return", "42", "a", "node", "extract_node", "code", "infer", "the", "class", "cls", "next", "node", "infer", "prop", "cls", "getattr", "a", "try", "to", "infer", "the", "property", "function", "multiple", "times", "a", "locals", "should", "be", "modified", "only", "once", "for", "_", "in", "range", "3", "prop", "inferred", "a_locals", "cls", "locals", "a", "functiondef", "property", "assert", "len", "a_locals", "2"], "doc_len": 62}
{"doc_id": "tests/unittest_inference.py::test_getattr_fails_on_empty_values", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_getattr_fails_on_empty_values", "text": "文件路径: tests/unittest_inference.py\ndef test_getattr_fails_on_empty_values() -> None:\n    code = \"\"\"\n    import collections\n    collections\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    with pytest.raises(InferenceError):\n        next(inferred.igetattr(\"\"))\n\n    with pytest.raises(AttributeInferenceError):\n        inferred.getattr(\"\")\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_getattr_fails_on_empty_values", "none", "code", "import", "collections", "collections", "node", "extract_node", "code", "inferred", "next", "node", "infer", "with", "pytest", "raises", "inferenceerror", "next", "inferred", "igetattr", "with", "pytest", "raises", "attributeinferenceerror", "inferred", "getattr"], "doc_len": 30}
{"doc_id": "tests/unittest_inference.py::test_infer_first_argument_of_static_method_in_metaclass", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_first_argument_of_static_method_in_metaclass", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_first_argument_of_static_method_in_metaclass() -> None:\n    code = \"\"\"\n    class My(type):\n        @staticmethod\n        def test(args):\n            args #@\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_first_argument_of_static_method_in_metaclass", "none", "code", "class", "my", "type", "staticmethod", "def", "test", "args", "args", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::test_recursion_error_metaclass_monkeypatching", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_recursion_error_metaclass_monkeypatching", "text": "文件路径: tests/unittest_inference.py\ndef test_recursion_error_metaclass_monkeypatching() -> None:\n    module = resources.build_file(\n        \"data/metaclass_recursion/monkeypatch.py\", \"data.metaclass_recursion\"\n    )\n    cls = next(module.igetattr(\"MonkeyPatchClass\"))\n    assert isinstance(cls, nodes.ClassDef)\n    assert cls.declared_metaclass() is None\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_recursion_error_metaclass_monkeypatching", "none", "module", "resources", "build_file", "data", "metaclass_recursion", "monkeypatch", "py", "data", "metaclass_recursion", "cls", "next", "module", "igetattr", "monkeypatchclass", "assert", "isinstance", "cls", "nodes", "classdef", "assert", "cls", "declared_metaclass", "is", "none"], "doc_len": 30}
{"doc_id": "tests/unittest_inference.py::test_recursion_error_self_reference_type_call", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_recursion_error_self_reference_type_call", "text": "文件路径: tests/unittest_inference.py\ndef test_recursion_error_self_reference_type_call() -> None:\n    # Fix for https://github.com/PyCQA/astroid/issues/199\n    code = \"\"\"\n    class A(object):\n        pass\n    class SomeClass(object):\n        route_class = A\n        def __init__(self):\n            self.route_class = type('B', (self.route_class, ), {})\n            self.route_class() #@\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, Instance)\n    assert inferred.name == \"B\"\n    # TODO: Cannot infer [B, A, object] but at least the recursion error is gone.\n    assert [cls.name for cls in inferred.mro()] == [\"B\", \"A\", \"object\"]\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_recursion_error_self_reference_type_call", "none", "fix", "for", "https", "github", "com", "pycqa", "astroid", "issues", "199", "code", "class", "a", "object", "pass", "class", "someclass", "object", "route_class", "a", "def", "__init__", "self", "self", "route_class", "type", "b", "self", "route_class", "self", "route_class", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "name", "b", "todo", "cannot", "infer", "b", "a", "object", "but", "at", "least", "the", "recursion", "error", "is", "gone", "assert", "cls", "name", "for", "cls", "in", "inferred", "mro", "b", "a", "object"], "doc_len": 76}
{"doc_id": "tests/unittest_inference.py::test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "text": "文件路径: tests/unittest_inference.py\ndef test_allow_retrieving_instance_attrs_and_special_attrs_for_functions() -> None:\n    code = \"\"\"\n    class A:\n        def test(self):\n            \"a\"\n        # Add `__doc__` to `FunctionDef.instance_attrs` via an `AugAssign`\n        test.__doc__ += 'b'\n        test #@\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    attrs = inferred.getattr(\"__doc__\")\n    # One from the `AugAssign`, one from the special attributes\n    assert len(attrs) == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_allow_retrieving_instance_attrs_and_special_attrs_for_functions", "none", "code", "class", "a", "def", "test", "self", "a", "add", "__doc__", "to", "functiondef", "instance_attrs", "via", "an", "augassign", "test", "__doc__", "b", "test", "node", "extract_node", "code", "inferred", "next", "node", "infer", "attrs", "inferred", "getattr", "__doc__", "one", "from", "the", "augassign", "one", "from", "the", "special", "attributes", "assert", "len", "attrs", "2"], "doc_len": 49}
{"doc_id": "tests/unittest_inference.py::test_implicit_parameters_bound_method", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_implicit_parameters_bound_method", "text": "文件路径: tests/unittest_inference.py\ndef test_implicit_parameters_bound_method() -> None:\n    code = \"\"\"\n    class A(type):\n        @classmethod\n        def test(cls, first): return first\n        def __new__(cls, name, bases, dictionary):\n            return super().__new__(cls, name, bases, dictionary)\n\n    A.test #@\n    A.__new__ #@\n    \"\"\"\n    test, dunder_new = extract_node(code)\n    test = next(test.infer())\n    assert isinstance(test, BoundMethod)\n    assert test.implicit_parameters() == 1\n\n    dunder_new = next(dunder_new.infer())\n    assert isinstance(dunder_new, BoundMethod)\n    assert dunder_new.implicit_parameters() == 0\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_implicit_parameters_bound_method", "none", "code", "class", "a", "type", "classmethod", "def", "test", "cls", "first", "return", "first", "def", "__new__", "cls", "name", "bases", "dictionary", "return", "super", "__new__", "cls", "name", "bases", "dictionary", "a", "test", "a", "__new__", "test", "dunder_new", "extract_node", "code", "test", "next", "test", "infer", "assert", "isinstance", "test", "boundmethod", "assert", "test", "implicit_parameters", "1", "dunder_new", "next", "dunder_new", "infer", "assert", "isinstance", "dunder_new", "boundmethod", "assert", "dunder_new", "implicit_parameters", "0"], "doc_len": 62}
{"doc_id": "tests/unittest_inference.py::test_super_inference_of_abstract_property", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_super_inference_of_abstract_property", "text": "文件路径: tests/unittest_inference.py\ndef test_super_inference_of_abstract_property() -> None:\n    code = \"\"\"\n    from abc import abstractmethod\n\n    class A:\n       @property\n       def test(self):\n           return \"super\"\n\n    class C:\n       @property\n       @abstractmethod\n       def test(self):\n           \"abstract method\"\n\n    class B(A, C):\n\n       @property\n       def test(self):\n            super() #@\n\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    test = inferred.getattr(\"test\")\n    assert len(test) == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_super_inference_of_abstract_property", "none", "code", "from", "abc", "import", "abstractmethod", "class", "a", "property", "def", "test", "self", "return", "super", "class", "c", "property", "abstractmethod", "def", "test", "self", "abstract", "method", "class", "b", "a", "c", "property", "def", "test", "self", "super", "node", "extract_node", "code", "inferred", "next", "node", "infer", "test", "inferred", "getattr", "test", "assert", "len", "test", "2"], "doc_len": 52}
{"doc_id": "tests/unittest_inference.py::test_infer_generated_setter", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_generated_setter", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_generated_setter() -> None:\n    code = \"\"\"\n    class A:\n        @property\n        def test(self):\n            pass\n    A.test.setter\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.FunctionDef)\n    assert isinstance(inferred.args, nodes.Arguments)\n    # This line used to crash because property generated functions\n    # did not have args properly set\n    assert not list(inferred.nodes_of_class(nodes.Const))\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_generated_setter", "none", "code", "class", "a", "property", "def", "test", "self", "pass", "a", "test", "setter", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "functiondef", "assert", "isinstance", "inferred", "args", "nodes", "arguments", "this", "line", "used", "to", "crash", "because", "property", "generated", "functions", "did", "not", "have", "args", "properly", "set", "assert", "not", "list", "inferred", "nodes_of_class", "nodes", "const"], "doc_len": 57}
{"doc_id": "tests/unittest_inference.py::test_infer_list_of_uninferables_does_not_crash", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_infer_list_of_uninferables_does_not_crash", "text": "文件路径: tests/unittest_inference.py\ndef test_infer_list_of_uninferables_does_not_crash() -> None:\n    code = \"\"\"\n    x = [A] * 1\n    f = [x, [A] * 2]\n    x = list(f) + [] # List[Uninferable]\n    tuple(x[0])\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.Tuple)\n    # Would not be able to infer the first element.\n    assert not inferred.elts\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_infer_list_of_uninferables_does_not_crash", "none", "code", "x", "a", "1", "f", "x", "a", "2", "x", "list", "f", "list", "uninferable", "tuple", "x", "0", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "tuple", "would", "not", "be", "able", "to", "infer", "the", "first", "element", "assert", "not", "inferred", "elts"], "doc_len": 47}
{"doc_id": "tests/unittest_inference.py::test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "text": "文件路径: tests/unittest_inference.py\ndef test_issue926_infer_stmts_referencing_same_name_is_not_uninferable() -> None:\n    code = \"\"\"\n    pair = [1, 2]\n    ex = pair[0]\n    if 1 + 1 == 2:\n        ex = pair[1]\n    ex\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 2\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n    assert isinstance(inferred[1], nodes.Const)\n    assert inferred[1].value == 2\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_issue926_infer_stmts_referencing_same_name_is_not_uninferable", "none", "code", "pair", "1", "2", "ex", "pair", "0", "if", "1", "1", "2", "ex", "pair", "1", "ex", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "2", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1", "assert", "isinstance", "inferred", "1", "nodes", "const", "assert", "inferred", "1", "value", "2"], "doc_len": 54}
{"doc_id": "tests/unittest_inference.py::test_issue926_binop_referencing_same_name_is_not_uninferable", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_issue926_binop_referencing_same_name_is_not_uninferable", "text": "文件路径: tests/unittest_inference.py\ndef test_issue926_binop_referencing_same_name_is_not_uninferable() -> None:\n    code = \"\"\"\n    pair = [1, 2]\n    ex = pair[0] + pair[1]\n    ex\n    \"\"\"\n    node = extract_node(code)\n    inferred = list(node.infer())\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 3\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_issue926_binop_referencing_same_name_is_not_uninferable", "none", "code", "pair", "1", "2", "ex", "pair", "0", "pair", "1", "ex", "node", "extract_node", "code", "inferred", "list", "node", "infer", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "3"], "doc_len": 38}
{"doc_id": "tests/unittest_inference.py::test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "text": "文件路径: tests/unittest_inference.py\ndef test_pylint_issue_4692_attribute_inference_error_in_infer_import_from() -> None:\n    \"\"\"https://github.com/PyCQA/pylint/issues/4692\"\"\"\n    code = \"\"\"\nimport click\n\n\nfor name, item in click.__dict__.items():\n    _ = isinstance(item, click.Command) and item != 'foo'\n    \"\"\"\n    node = extract_node(code)\n    with pytest.raises(InferenceError):\n        list(node.infer())\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_pylint_issue_4692_attribute_inference_error_in_infer_import_from", "none", "https", "github", "com", "pycqa", "pylint", "issues", "4692", "code", "import", "click", "for", "name", "item", "in", "click", "__dict__", "items", "_", "isinstance", "item", "click", "command", "and", "item", "foo", "node", "extract_node", "code", "with", "pytest", "raises", "inferenceerror", "list", "node", "infer"], "doc_len": 41}
{"doc_id": "tests/unittest_inference.py::test_issue_1090_infer_yield_type_base_class", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_issue_1090_infer_yield_type_base_class", "text": "文件路径: tests/unittest_inference.py\ndef test_issue_1090_infer_yield_type_base_class() -> None:\n    code = \"\"\"\nimport contextlib\n\nclass A:\n    @contextlib.contextmanager\n    def get(self):\n        yield self\n\nclass B(A):\n    def play():\n        pass\n\nwith B().get() as b:\n    b\nb\n    \"\"\"\n    node = extract_node(code)\n    assert next(node.infer()).pytype() == \".B\"\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_issue_1090_infer_yield_type_base_class", "none", "code", "import", "contextlib", "class", "a", "contextlib", "contextmanager", "def", "get", "self", "yield", "self", "class", "b", "a", "def", "play", "pass", "with", "b", "get", "as", "b", "b", "b", "node", "extract_node", "code", "assert", "next", "node", "infer", "pytype", "b"], "doc_len": 40}
{"doc_id": "tests/unittest_inference.py::test_namespace_package", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_namespace_package", "text": "文件路径: tests/unittest_inference.py\ndef test_namespace_package() -> None:\n    \"\"\"check that a file using namespace packages and relative imports is parseable\"\"\"\n    resources.build_file(\"data/beyond_top_level/import_package.py\")\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_namespace_package", "none", "check", "that", "a", "file", "using", "namespace", "packages", "and", "relative", "imports", "is", "parseable", "resources", "build_file", "data", "beyond_top_level", "import_package", "py"], "doc_len": 24}
{"doc_id": "tests/unittest_inference.py::test_namespace_package_same_name", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_namespace_package_same_name", "text": "文件路径: tests/unittest_inference.py\ndef test_namespace_package_same_name() -> None:\n    \"\"\"check that a file using namespace packages and relative imports\n    with similar names is parseable\"\"\"\n    resources.build_file(\"data/beyond_top_level_two/a.py\")\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_namespace_package_same_name", "none", "check", "that", "a", "file", "using", "namespace", "packages", "and", "relative", "imports", "with", "similar", "names", "is", "parseable", "resources", "build_file", "data", "beyond_top_level_two", "a", "py"], "doc_len": 27}
{"doc_id": "tests/unittest_inference.py::test_relative_imports_init_package", "file_path": "tests/unittest_inference.py", "class_name": null, "func_name": "test_relative_imports_init_package", "text": "文件路径: tests/unittest_inference.py\ndef test_relative_imports_init_package() -> None:\n    \"\"\"check that relative imports within a package that uses __init__.py\n    still works\"\"\"\n    resources.build_file(\n        \"data/beyond_top_level_three/module/sub_module/sub_sub_module/main.py\"\n    )\n", "tokens": ["tests", "unittest_inference", "py", "def", "test_relative_imports_init_package", "none", "check", "that", "relative", "imports", "within", "a", "package", "that", "uses", "__init__", "py", "still", "works", "resources", "build_file", "data", "beyond_top_level_three", "module", "sub_module", "sub_sub_module", "main", "py"], "doc_len": 28}
{"doc_id": "tests/unittest_inference_calls.py::test_no_return", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_no_return", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_no_return() -> None:\n    \"\"\"Test function with no return statements\"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f():\n        pass\n\n    f()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_no_return", "none", "test", "function", "with", "no", "return", "statements", "node", "builder", "extract_node", "def", "f", "pass", "f", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 36}
{"doc_id": "tests/unittest_inference_calls.py::test_one_return", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_one_return", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_one_return() -> None:\n    \"\"\"Test function with a single return that always executes\"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f():\n        return 1\n\n    f()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_one_return", "none", "test", "function", "with", "a", "single", "return", "that", "always", "executes", "node", "builder", "extract_node", "def", "f", "return", "1", "f", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1"], "doc_len": 46}
{"doc_id": "tests/unittest_inference_calls.py::test_one_return_possible", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_one_return_possible", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_one_return_possible() -> None:\n    \"\"\"Test function with a single return that only sometimes executes\n\n    Note: currently, inference doesn't handle this type of control flow\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f(x):\n        if x:\n            return 1\n\n    f(1)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_one_return_possible", "none", "test", "function", "with", "a", "single", "return", "that", "only", "sometimes", "executes", "note", "currently", "inference", "doesn", "t", "handle", "this", "type", "of", "control", "flow", "node", "builder", "extract_node", "def", "f", "x", "if", "x", "return", "1", "f", "1", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1"], "doc_len": 62}
{"doc_id": "tests/unittest_inference_calls.py::test_multiple_returns", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_multiple_returns", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_multiple_returns() -> None:\n    \"\"\"Test function with multiple returns\"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f(x):\n        if x > 10:\n            return 1\n        elif x > 20:\n            return 2\n        else:\n            return 3\n\n    f(100)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 3\n    assert all(isinstance(node, nodes.Const) for node in inferred)\n    assert {node.value for node in inferred} == {1, 2, 3}\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_multiple_returns", "none", "test", "function", "with", "multiple", "returns", "node", "builder", "extract_node", "def", "f", "x", "if", "x", "10", "return", "1", "elif", "x", "20", "return", "2", "else", "return", "3", "f", "100", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "3", "assert", "all", "isinstance", "node", "nodes", "const", "for", "node", "in", "inferred", "assert", "node", "value", "for", "node", "in", "inferred", "1", "2", "3"], "doc_len": 64}
{"doc_id": "tests/unittest_inference_calls.py::test_argument", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_argument", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_argument() -> None:\n    \"\"\"Test function whose return value uses its arguments\"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f(x, y):\n        return x + y\n\n    f(1, 2)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 3\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_argument", "none", "test", "function", "whose", "return", "value", "uses", "its", "arguments", "node", "builder", "extract_node", "def", "f", "x", "y", "return", "x", "y", "f", "1", "2", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "3"], "doc_len": 50}
{"doc_id": "tests/unittest_inference_calls.py::test_inner_call", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_inner_call", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_inner_call() -> None:\n    \"\"\"Test function where return value is the result of a separate function call\"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f():\n        return g()\n\n    def g():\n        return 1\n\n    f()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_inner_call", "none", "test", "function", "where", "return", "value", "is", "the", "result", "of", "a", "separate", "function", "call", "node", "builder", "extract_node", "def", "f", "return", "g", "def", "g", "return", "1", "f", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1"], "doc_len": 54}
{"doc_id": "tests/unittest_inference_calls.py::test_inner_call_with_const_argument", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_inner_call_with_const_argument", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_inner_call_with_const_argument() -> None:\n    \"\"\"Test function where return value is the result of a separate function call,\n    with a constant value passed to the inner function.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f():\n        return g(1)\n\n    def g(y):\n        return y + 2\n\n    f()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 3\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_inner_call_with_const_argument", "none", "test", "function", "where", "return", "value", "is", "the", "result", "of", "a", "separate", "function", "call", "with", "a", "constant", "value", "passed", "to", "the", "inner", "function", "node", "builder", "extract_node", "def", "f", "return", "g", "1", "def", "g", "y", "return", "y", "2", "f", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "3"], "doc_len": 66}
{"doc_id": "tests/unittest_inference_calls.py::test_inner_call_with_dynamic_argument", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_inner_call_with_dynamic_argument", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_inner_call_with_dynamic_argument() -> None:\n    \"\"\"Test function where return value is the result of a separate function call,\n    with a dynamic value passed to the inner function.\n\n    Currently, this is Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    def f(x):\n        return g(x)\n\n    def g(y):\n        return y + 2\n\n    f(1)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_inner_call_with_dynamic_argument", "none", "test", "function", "where", "return", "value", "is", "the", "result", "of", "a", "separate", "function", "call", "with", "a", "dynamic", "value", "passed", "to", "the", "inner", "function", "currently", "this", "is", "uninferable", "node", "builder", "extract_node", "def", "f", "x", "return", "g", "x", "def", "g", "y", "return", "y", "2", "f", "1", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 66}
{"doc_id": "tests/unittest_inference_calls.py::test_method_const_instance_attr", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_const_instance_attr", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_const_instance_attr() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with a\n    constant value.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def __init__(self):\n            self.x = 1\n\n        def get_x(self):\n            return self.x\n\n    A().get_x()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_const_instance_attr", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "constant", "value", "node", "builder", "extract_node", "class", "a", "def", "__init__", "self", "self", "x", "1", "def", "get_x", "self", "return", "self", "x", "a", "get_x", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1"], "doc_len": 64}
{"doc_id": "tests/unittest_inference_calls.py::test_method_const_instance_attr_multiple", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_const_instance_attr_multiple", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_const_instance_attr_multiple() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    multiple possible constant values, across different methods.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def __init__(self, x):\n            if x:\n                self.x = 1\n            else:\n                self.x = 2\n\n        def set_x(self):\n            self.x = 3\n\n        def get_x(self):\n            return self.x\n\n    A().get_x()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 3\n    assert all(isinstance(node, nodes.Const) for node in inferred)\n    assert {node.value for node in inferred} == {1, 2, 3}\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_const_instance_attr_multiple", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "multiple", "possible", "constant", "values", "across", "different", "methods", "node", "builder", "extract_node", "class", "a", "def", "__init__", "self", "x", "if", "x", "self", "x", "1", "else", "self", "x", "2", "def", "set_x", "self", "self", "x", "3", "def", "get_x", "self", "return", "self", "x", "a", "get_x", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "3", "assert", "all", "isinstance", "node", "nodes", "const", "for", "node", "in", "inferred", "assert", "node", "value", "for", "node", "in", "inferred", "1", "2", "3"], "doc_len": 90}
{"doc_id": "tests/unittest_inference_calls.py::test_method_const_instance_attr_same_method", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_const_instance_attr_same_method", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_const_instance_attr_same_method() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    multiple possible constant values, including in the method being called.\n\n    Note that even with a simple control flow where the assignment in the method body\n    is guaranteed to override any previous assignments, all possible constant values\n    are returned.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def __init__(self, x):\n            if x:\n                self.x = 1\n            else:\n                self.x = 2\n\n        def set_x(self):\n            self.x = 3\n\n        def get_x(self):\n            self.x = 4\n            return self.x\n\n    A().get_x()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 4\n    assert all(isinstance(node, nodes.Const) for node in inferred)\n    assert {node.value for node in inferred} == {1, 2, 3, 4}\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_const_instance_attr_same_method", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "multiple", "possible", "constant", "values", "including", "in", "the", "method", "being", "called", "note", "that", "even", "with", "a", "simple", "control", "flow", "where", "the", "assignment", "in", "the", "method", "body", "is", "guaranteed", "to", "override", "any", "previous", "assignments", "all", "possible", "constant", "values", "are", "returned", "node", "builder", "extract_node", "class", "a", "def", "__init__", "self", "x", "if", "x", "self", "x", "1", "else", "self", "x", "2", "def", "set_x", "self", "self", "x", "3", "def", "get_x", "self", "self", "x", "4", "return", "self", "x", "a", "get_x", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "4", "assert", "all", "isinstance", "node", "nodes", "const", "for", "node", "in", "inferred", "assert", "node", "value", "for", "node", "in", "inferred", "1", "2", "3", "4"], "doc_len": 125}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_1", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_1", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_1() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in a different method.\n\n    In this case, the return value is Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def __init__(self, x):\n            self.x = x\n\n        def get_x(self):\n            return self.x\n\n    A(1).get_x()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_1", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "a", "different", "method", "in", "this", "case", "the", "return", "value", "is", "uninferable", "node", "builder", "extract_node", "class", "a", "def", "__init__", "self", "x", "self", "x", "x", "def", "get_x", "self", "return", "self", "x", "a", "1", "get_x", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 73}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_2", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_2", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_2() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in the same method.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        # Note: no initializer, so the only assignment happens in get_x\n\n        def get_x(self, x):\n            self.x = x\n            return self.x\n\n    A().get_x(1)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 1\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_2", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "the", "same", "method", "node", "builder", "extract_node", "class", "a", "note", "no", "initializer", "so", "the", "only", "assignment", "happens", "in", "get_x", "def", "get_x", "self", "x", "self", "x", "x", "return", "self", "x", "a", "get_x", "1", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "1"], "doc_len": 78}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_3", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_3", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_3() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in a different method.\n\n    This is currently Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def get_x(self, x):  # x is unused\n            return self.x\n\n        def set_x(self, x):\n            self.x = x\n\n    A().get_x(10)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable  # not 10!\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_3", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "a", "different", "method", "this", "is", "currently", "uninferable", "node", "builder", "extract_node", "class", "a", "def", "get_x", "self", "x", "x", "is", "unused", "return", "self", "x", "def", "set_x", "self", "x", "self", "x", "x", "a", "get_x", "10", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable", "not", "10"], "doc_len": 75}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_4", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_4", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_4() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in a different method, and is passed a constant value.\n\n    This is currently Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        # Note: no initializer, so the only assignment happens in get_x\n\n        def get_x(self):\n            self.set_x(10)\n            return self.x\n\n        def set_x(self, x):\n            self.x = x\n\n    A().get_x()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_4", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "a", "different", "method", "and", "is", "passed", "a", "constant", "value", "this", "is", "currently", "uninferable", "node", "builder", "extract_node", "class", "a", "note", "no", "initializer", "so", "the", "only", "assignment", "happens", "in", "get_x", "def", "get_x", "self", "self", "set_x", "10", "return", "self", "x", "def", "set_x", "self", "x", "self", "x", "x", "a", "get_x", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 87}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_5", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_5", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_5() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in a different method, and is passed a constant value.\n\n    But, where the outer and inner functions have the same signature.\n\n    Inspired by https://github.com/PyCQA/pylint/issues/400\n\n    This is currently Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        # Note: no initializer, so the only assignment happens in get_x\n\n        def get_x(self, x):\n            self.set_x(10)\n            return self.x\n\n        def set_x(self, x):\n            self.x = x\n\n    A().get_x(1)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_5", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "a", "different", "method", "and", "is", "passed", "a", "constant", "value", "but", "where", "the", "outer", "and", "inner", "functions", "have", "the", "same", "signature", "inspired", "by", "https", "github", "com", "pycqa", "pylint", "issues", "400", "this", "is", "currently", "uninferable", "node", "builder", "extract_node", "class", "a", "note", "no", "initializer", "so", "the", "only", "assignment", "happens", "in", "get_x", "def", "get_x", "self", "x", "self", "set_x", "10", "return", "self", "x", "def", "set_x", "self", "x", "self", "x", "x", "a", "get_x", "1", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 109}
{"doc_id": "tests/unittest_inference_calls.py::test_method_dynamic_instance_attr_6", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_method_dynamic_instance_attr_6", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_method_dynamic_instance_attr_6() -> None:\n    \"\"\"Test method where the return value is based on an instance attribute with\n    a dynamically-set value in a different method, and is passed a dynamic value.\n\n    This is currently Uninferable.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        # Note: no initializer, so the only assignment happens in get_x\n\n        def get_x(self, x):\n            self.set_x(x + 1)\n            return self.x\n\n        def set_x(self, x):\n            self.x = x\n\n    A().get_x(1)  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_method_dynamic_instance_attr_6", "none", "test", "method", "where", "the", "return", "value", "is", "based", "on", "an", "instance", "attribute", "with", "a", "dynamically", "set", "value", "in", "a", "different", "method", "and", "is", "passed", "a", "dynamic", "value", "this", "is", "currently", "uninferable", "node", "builder", "extract_node", "class", "a", "note", "no", "initializer", "so", "the", "only", "assignment", "happens", "in", "get_x", "def", "get_x", "self", "x", "self", "set_x", "x", "1", "return", "self", "x", "def", "set_x", "self", "x", "self", "x", "x", "a", "get_x", "1", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 90}
{"doc_id": "tests/unittest_inference_calls.py::test_dunder_getitem", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_dunder_getitem", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_dunder_getitem() -> None:\n    \"\"\"Test for the special method __getitem__ (used by Instance.getitem).\n\n    This is currently Uninferable, until we can infer instance attribute values through\n    constructor calls.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def __init__(self, x):\n            self.x = x\n\n        def __getitem__(self, i):\n            return self.x + i\n\n    A(1)[2]  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert inferred[0] is Uninferable\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_dunder_getitem", "none", "test", "for", "the", "special", "method", "__getitem__", "used", "by", "instance", "getitem", "this", "is", "currently", "uninferable", "until", "we", "can", "infer", "instance", "attribute", "values", "through", "constructor", "calls", "node", "builder", "extract_node", "class", "a", "def", "__init__", "self", "x", "self", "x", "x", "def", "__getitem__", "self", "i", "return", "self", "x", "i", "a", "1", "2", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "inferred", "0", "is", "uninferable"], "doc_len": 70}
{"doc_id": "tests/unittest_inference_calls.py::test_instance_method", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_instance_method", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_instance_method() -> None:\n    \"\"\"Tests for instance method, both bound and unbound.\"\"\"\n    nodes_ = builder.extract_node(\n        \"\"\"\n    class A:\n        def method(self, x):\n            return x\n\n    A().method(42)  #@\n\n    # In this case, the 1 argument is bound to self, which is ignored in the method\n    A.method(1, 42)  #@\n    \"\"\"\n    )\n\n    for node in nodes_:\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const)\n        assert inferred[0].value == 42\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_instance_method", "none", "tests", "for", "instance", "method", "both", "bound", "and", "unbound", "nodes_", "builder", "extract_node", "class", "a", "def", "method", "self", "x", "return", "x", "a", "method", "42", "in", "this", "case", "the", "1", "argument", "is", "bound", "to", "self", "which", "is", "ignored", "in", "the", "method", "a", "method", "1", "42", "for", "node", "in", "nodes_", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "42"], "doc_len": 75}
{"doc_id": "tests/unittest_inference_calls.py::test_class_method", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_class_method", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_class_method() -> None:\n    \"\"\"Tests for class method calls, both instance and with the class.\"\"\"\n    nodes_ = builder.extract_node(\n        \"\"\"\n    class A:\n        @classmethod\n        def method(cls, x):\n            return x\n\n    A.method(42)  #@\n    A().method(42)  #@\n\n    \"\"\"\n    )\n\n    for node in nodes_:\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const), node\n        assert inferred[0].value == 42\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_class_method", "none", "tests", "for", "class", "method", "calls", "both", "instance", "and", "with", "the", "class", "nodes_", "builder", "extract_node", "class", "a", "classmethod", "def", "method", "cls", "x", "return", "x", "a", "method", "42", "a", "method", "42", "for", "node", "in", "nodes_", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "node", "assert", "inferred", "0", "value", "42"], "doc_len": 63}
{"doc_id": "tests/unittest_inference_calls.py::test_static_method", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_static_method", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_static_method() -> None:\n    \"\"\"Tests for static method calls, both instance and with the class.\"\"\"\n    nodes_ = builder.extract_node(\n        \"\"\"\n    class A:\n        @staticmethod\n        def method(x):\n            return x\n\n    A.method(42)  #@\n    A().method(42)  #@\n    \"\"\"\n    )\n\n    for node in nodes_:\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.Const), node\n        assert inferred[0].value == 42\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_static_method", "none", "tests", "for", "static", "method", "calls", "both", "instance", "and", "with", "the", "class", "nodes_", "builder", "extract_node", "class", "a", "staticmethod", "def", "method", "x", "return", "x", "a", "method", "42", "a", "method", "42", "for", "node", "in", "nodes_", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "node", "assert", "inferred", "0", "value", "42"], "doc_len": 62}
{"doc_id": "tests/unittest_inference_calls.py::test_instance_method_inherited", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_instance_method_inherited", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_instance_method_inherited() -> None:\n    \"\"\"Tests for instance methods that are inherited from a superclass.\n\n    Based on https://github.com/PyCQA/astroid/issues/1008.\n    \"\"\"\n    nodes_ = builder.extract_node(\n        \"\"\"\n    class A:\n        def method(self):\n            return self\n\n    class B(A):\n        pass\n\n    A().method()  #@\n    A.method(A())  #@\n\n    B().method()  #@\n    B.method(B())  #@\n    A.method(B())  #@\n    \"\"\"\n    )\n    expected = [\"A\", \"A\", \"B\", \"B\", \"B\"]\n    for node, expected in zip(nodes_, expected):\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], bases.Instance)\n        assert inferred[0].name == expected\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_instance_method_inherited", "none", "tests", "for", "instance", "methods", "that", "are", "inherited", "from", "a", "superclass", "based", "on", "https", "github", "com", "pycqa", "astroid", "issues", "1008", "nodes_", "builder", "extract_node", "class", "a", "def", "method", "self", "return", "self", "class", "b", "a", "pass", "a", "method", "a", "method", "a", "b", "method", "b", "method", "b", "a", "method", "b", "expected", "a", "a", "b", "b", "b", "for", "node", "expected", "in", "zip", "nodes_", "expected", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "bases", "instance", "assert", "inferred", "0", "name", "expected"], "doc_len": 88}
{"doc_id": "tests/unittest_inference_calls.py::test_class_method_inherited", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_class_method_inherited", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_class_method_inherited() -> None:\n    \"\"\"Tests for class methods that are inherited from a superclass.\n\n    Based on https://github.com/PyCQA/astroid/issues/1008.\n    \"\"\"\n    nodes_ = builder.extract_node(\n        \"\"\"\n    class A:\n        @classmethod\n        def method(cls):\n            return cls\n\n    class B(A):\n        pass\n\n    A().method()  #@\n    A.method()  #@\n\n    B().method()  #@\n    B.method()  #@\n    \"\"\"\n    )\n    expected = [\"A\", \"A\", \"B\", \"B\"]\n    for node, expected in zip(nodes_, expected):\n        assert isinstance(node, nodes.NodeNG)\n        inferred = node.inferred()\n        assert len(inferred) == 1\n        assert isinstance(inferred[0], nodes.ClassDef)\n        assert inferred[0].name == expected\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_class_method_inherited", "none", "tests", "for", "class", "methods", "that", "are", "inherited", "from", "a", "superclass", "based", "on", "https", "github", "com", "pycqa", "astroid", "issues", "1008", "nodes_", "builder", "extract_node", "class", "a", "classmethod", "def", "method", "cls", "return", "cls", "class", "b", "a", "pass", "a", "method", "a", "method", "b", "method", "b", "method", "expected", "a", "a", "b", "b", "for", "node", "expected", "in", "zip", "nodes_", "expected", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "classdef", "assert", "inferred", "0", "name", "expected"], "doc_len": 83}
{"doc_id": "tests/unittest_inference_calls.py::test_chained_attribute_inherited", "file_path": "tests/unittest_inference_calls.py", "class_name": null, "func_name": "test_chained_attribute_inherited", "text": "文件路径: tests/unittest_inference_calls.py\ndef test_chained_attribute_inherited() -> None:\n    \"\"\"Tests for class methods that are inherited from a superclass.\n\n    Based on https://github.com/PyCQA/pylint/issues/4220.\n    \"\"\"\n    node = builder.extract_node(\n        \"\"\"\n    class A:\n        def f(self):\n            return 42\n\n\n    class B(A):\n        def __init__(self):\n            self.a = A()\n            result = self.a.f()\n\n        def f(self):\n            pass\n\n\n    B().a.f()  #@\n    \"\"\"\n    )\n    assert isinstance(node, nodes.NodeNG)\n    inferred = node.inferred()\n    assert len(inferred) == 1\n    assert isinstance(inferred[0], nodes.Const)\n    assert inferred[0].value == 42\n", "tokens": ["tests", "unittest_inference_calls", "py", "def", "test_chained_attribute_inherited", "none", "tests", "for", "class", "methods", "that", "are", "inherited", "from", "a", "superclass", "based", "on", "https", "github", "com", "pycqa", "pylint", "issues", "4220", "node", "builder", "extract_node", "class", "a", "def", "f", "self", "return", "42", "class", "b", "a", "def", "__init__", "self", "self", "a", "a", "result", "self", "a", "f", "def", "f", "self", "pass", "b", "a", "f", "assert", "isinstance", "node", "nodes", "nodeng", "inferred", "node", "inferred", "assert", "len", "inferred", "1", "assert", "isinstance", "inferred", "0", "nodes", "const", "assert", "inferred", "0", "value", "42"], "doc_len": 78}
{"doc_id": "tests/unittest_lookup.py::LookupTest.setUp", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "setUp", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def setUp(self) -> None:\n        super().setUp()\n        self.module = resources.build_file(\"data/module.py\", \"data.module\")\n        self.module2 = resources.build_file(\"data/module2.py\", \"data.module2\")\n        self.nonregr = resources.build_file(\"data/nonregr.py\", \"data.nonregr\")\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "setup", "self", "none", "super", "setup", "self", "module", "resources", "build_file", "data", "module", "py", "data", "module", "self", "module2", "resources", "build_file", "data", "module2", "py", "data", "module2", "self", "nonregr", "resources", "build_file", "data", "nonregr", "py", "data", "nonregr"], "doc_len": 37}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_limit", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_limit", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_limit(self) -> None:\n        code = \"\"\"\n            l = [a\n                 for a,b in list]\n\n            a = 1\n            b = a\n            a = None\n\n            def func():\n                c = 1\n        \"\"\"\n        astroid = builder.parse(code, __name__)\n        # a & b\n        a = next(astroid.nodes_of_class(nodes.Name))\n        self.assertEqual(a.lineno, 2)\n        self.assertEqual(len(astroid.lookup(\"b\")[1]), 1)\n        self.assertEqual(len(astroid.lookup(\"a\")[1]), 1)\n        b = astroid.locals[\"b\"][0]\n        stmts = a.lookup(\"a\")[1]\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(b.lineno, 6)\n        b_infer = b.infer()\n        b_value = next(b_infer)\n        self.assertEqual(b_value.value, 1)\n        # c\n        self.assertRaises(StopIteration, functools.partial(next, b_infer))\n        func = astroid.locals[\"func\"][0]\n        self.assertEqual(len(func.lookup(\"c\")[1]), 1)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_limit", "self", "none", "code", "l", "a", "for", "a", "b", "in", "list", "a", "1", "b", "a", "a", "none", "def", "func", "c", "1", "astroid", "builder", "parse", "code", "__name__", "a", "b", "a", "next", "astroid", "nodes_of_class", "nodes", "name", "self", "assertequal", "a", "lineno", "2", "self", "assertequal", "len", "astroid", "lookup", "b", "1", "1", "self", "assertequal", "len", "astroid", "lookup", "a", "1", "1", "b", "astroid", "locals", "b", "0", "stmts", "a", "lookup", "a", "1", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "b", "lineno", "6", "b_infer", "b", "infer", "b_value", "next", "b_infer", "self", "assertequal", "b_value", "value", "1", "c", "self", "assertraises", "stopiteration", "functools", "partial", "next", "b_infer", "func", "astroid", "locals", "func", "0", "self", "assertequal", "len", "func", "lookup", "c", "1", "1"], "doc_len": 112}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_module", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_module", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_module(self) -> None:\n        astroid = builder.parse(\"pass\", __name__)\n        # built-in objects\n        none = next(astroid.ilookup(\"None\"))\n        self.assertIsNone(none.value)\n        obj = next(astroid.ilookup(\"object\"))\n        self.assertIsInstance(obj, nodes.ClassDef)\n        self.assertEqual(obj.name, \"object\")\n        self.assertRaises(\n            InferenceError, functools.partial(next, astroid.ilookup(\"YOAA\"))\n        )\n\n        # XXX\n        self.assertEqual(len(list(self.nonregr.ilookup(\"enumerate\"))), 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_module", "self", "none", "astroid", "builder", "parse", "pass", "__name__", "built", "in", "objects", "none", "next", "astroid", "ilookup", "none", "self", "assertisnone", "none", "value", "obj", "next", "astroid", "ilookup", "object", "self", "assertisinstance", "obj", "nodes", "classdef", "self", "assertequal", "obj", "name", "object", "self", "assertraises", "inferenceerror", "functools", "partial", "next", "astroid", "ilookup", "yoaa", "xxx", "self", "assertequal", "len", "list", "self", "nonregr", "ilookup", "enumerate", "2"], "doc_len": 59}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_class_ancestor_name", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_class_ancestor_name", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_class_ancestor_name(self) -> None:\n        code = \"\"\"\n            class A:\n                pass\n\n            class A(A):\n                pass\n        \"\"\"\n        astroid = builder.parse(code, __name__)\n        cls1 = astroid.locals[\"A\"][0]\n        cls2 = astroid.locals[\"A\"][1]\n        name = next(cls2.nodes_of_class(nodes.Name))\n        self.assertEqual(next(name.infer()), cls1)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_class_ancestor_name", "self", "none", "code", "class", "a", "pass", "class", "a", "a", "pass", "astroid", "builder", "parse", "code", "__name__", "cls1", "astroid", "locals", "a", "0", "cls2", "astroid", "locals", "a", "1", "name", "next", "cls2", "nodes_of_class", "nodes", "name", "self", "assertequal", "next", "name", "infer", "cls1"], "doc_len": 43}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_method", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_method", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_method(self) -> None:\n        method = self.module[\"YOUPI\"][\"method\"]\n        my_dict = next(method.ilookup(\"MY_DICT\"))\n        self.assertTrue(isinstance(my_dict, nodes.Dict), my_dict)\n        none = next(method.ilookup(\"None\"))\n        self.assertIsNone(none.value)\n        self.assertRaises(\n            InferenceError, functools.partial(next, method.ilookup(\"YOAA\"))\n        )\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_method", "self", "none", "method", "self", "module", "youpi", "method", "my_dict", "next", "method", "ilookup", "my_dict", "self", "asserttrue", "isinstance", "my_dict", "nodes", "dict", "my_dict", "none", "next", "method", "ilookup", "none", "self", "assertisnone", "none", "value", "self", "assertraises", "inferenceerror", "functools", "partial", "next", "method", "ilookup", "yoaa"], "doc_len": 43}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_function_argument_with_default", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_function_argument_with_default", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_function_argument_with_default(self) -> None:\n        make_class = self.module2[\"make_class\"]\n        base = next(make_class.ilookup(\"base\"))\n        self.assertTrue(isinstance(base, nodes.ClassDef), base.__class__)\n        self.assertEqual(base.name, \"YO\")\n        self.assertEqual(base.root().name, \"data.module\")\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_function_argument_with_default", "self", "none", "make_class", "self", "module2", "make_class", "base", "next", "make_class", "ilookup", "base", "self", "asserttrue", "isinstance", "base", "nodes", "classdef", "base", "__class__", "self", "assertequal", "base", "name", "yo", "self", "assertequal", "base", "root", "name", "data", "module"], "doc_len": 37}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_class", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_class", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_class(self) -> None:\n        klass = self.module[\"YOUPI\"]\n        my_dict = next(klass.ilookup(\"MY_DICT\"))\n        self.assertIsInstance(my_dict, nodes.Dict)\n        none = next(klass.ilookup(\"None\"))\n        self.assertIsNone(none.value)\n        obj = next(klass.ilookup(\"object\"))\n        self.assertIsInstance(obj, nodes.ClassDef)\n        self.assertEqual(obj.name, \"object\")\n        self.assertRaises(\n            InferenceError, functools.partial(next, klass.ilookup(\"YOAA\"))\n        )\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_class", "self", "none", "klass", "self", "module", "youpi", "my_dict", "next", "klass", "ilookup", "my_dict", "self", "assertisinstance", "my_dict", "nodes", "dict", "none", "next", "klass", "ilookup", "none", "self", "assertisnone", "none", "value", "obj", "next", "klass", "ilookup", "object", "self", "assertisinstance", "obj", "nodes", "classdef", "self", "assertequal", "obj", "name", "object", "self", "assertraises", "inferenceerror", "functools", "partial", "next", "klass", "ilookup", "yoaa"], "doc_len": 55}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_inner_classes", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_inner_classes", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_inner_classes(self) -> None:\n        ddd = list(self.nonregr[\"Ccc\"].ilookup(\"Ddd\"))\n        self.assertEqual(ddd[0].name, \"Ddd\")\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_inner_classes", "self", "none", "ddd", "list", "self", "nonregr", "ccc", "ilookup", "ddd", "self", "assertequal", "ddd", "0", "name", "ddd"], "doc_len": 21}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_loopvar_hiding", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_loopvar_hiding", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_loopvar_hiding(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            x = 10\n            for x in range(5):\n                print (x)\n\n            if x > 0:\n                print ('#' * x)\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n        # inside the loop, only one possible assignment\n        self.assertEqual(len(xnames[0].lookup(\"x\")[1]), 1)\n        # outside the loop, two possible assignments\n        self.assertEqual(len(xnames[1].lookup(\"x\")[1]), 2)\n        self.assertEqual(len(xnames[2].lookup(\"x\")[1]), 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_loopvar_hiding", "self", "none", "astroid", "builder", "parse", "x", "10", "for", "x", "in", "range", "5", "print", "x", "if", "x", "0", "print", "x", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "inside", "the", "loop", "only", "one", "possible", "assignment", "self", "assertequal", "len", "xnames", "0", "lookup", "x", "1", "1", "outside", "the", "loop", "two", "possible", "assignments", "self", "assertequal", "len", "xnames", "1", "lookup", "x", "1", "2", "self", "assertequal", "len", "xnames", "2", "lookup", "x", "1", "2"], "doc_len": 79}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_list_comps", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_list_comps", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_list_comps(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            print ([ i for i in range(10) ])\n            print ([ i for i in range(10) ])\n            print ( list( i for i in range(10) ) )\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 2)\n        self.assertEqual(len(xnames[1].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[1].lookup(\"i\")[1][0].lineno, 3)\n        self.assertEqual(len(xnames[2].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[2].lookup(\"i\")[1][0].lineno, 4)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_list_comps", "self", "none", "astroid", "builder", "parse", "print", "i", "for", "i", "in", "range", "10", "print", "i", "for", "i", "in", "range", "10", "print", "list", "i", "for", "i", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "2", "self", "assertequal", "len", "xnames", "1", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "1", "lookup", "i", "1", "0", "lineno", "3", "self", "assertequal", "len", "xnames", "2", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "2", "lookup", "i", "1", "0", "lineno", "4"], "doc_len": 104}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_list_comp_target", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_list_comp_target", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_list_comp_target(self) -> None:\n        \"\"\"test the list comprehension target\"\"\"\n        astroid = builder.parse(\n            \"\"\"\n            ten = [ var for var in range(10) ]\n            var\n        \"\"\"\n        )\n        var = astroid.body[1].value\n        self.assertRaises(NameInferenceError, var.inferred)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_list_comp_target", "self", "none", "test", "the", "list", "comprehension", "target", "astroid", "builder", "parse", "ten", "var", "for", "var", "in", "range", "10", "var", "var", "astroid", "body", "1", "value", "self", "assertraises", "nameinferenceerror", "var", "inferred"], "doc_len": 34}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_dict_comps", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_dict_comps", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_dict_comps(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            print ({ i: j for i in range(10) for j in range(10) })\n            print ({ i: j for i in range(10) for j in range(10) })\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 2)\n        self.assertEqual(len(xnames[1].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[1].lookup(\"i\")[1][0].lineno, 3)\n\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"j\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 2)\n        self.assertEqual(len(xnames[1].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[1].lookup(\"i\")[1][0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_dict_comps", "self", "none", "astroid", "builder", "parse", "print", "i", "j", "for", "i", "in", "range", "10", "for", "j", "in", "range", "10", "print", "i", "j", "for", "i", "in", "range", "10", "for", "j", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "2", "self", "assertequal", "len", "xnames", "1", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "1", "lookup", "i", "1", "0", "lineno", "3", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "j", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "2", "self", "assertequal", "len", "xnames", "1", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "1", "lookup", "i", "1", "0", "lineno", "3"], "doc_len": 140}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_set_comps", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_set_comps", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_set_comps(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            print ({ i for i in range(10) })\n            print ({ i for i in range(10) })\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 2)\n        self.assertEqual(len(xnames[1].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[1].lookup(\"i\")[1][0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_set_comps", "self", "none", "astroid", "builder", "parse", "print", "i", "for", "i", "in", "range", "10", "print", "i", "for", "i", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "2", "self", "assertequal", "len", "xnames", "1", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "1", "lookup", "i", "1", "0", "lineno", "3"], "doc_len": 77}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_set_comp_closure", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_set_comp_closure", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_set_comp_closure(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            ten = { var for var in range(10) }\n            var\n        \"\"\"\n        )\n        var = astroid.body[1].value\n        self.assertRaises(NameInferenceError, var.inferred)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_set_comp_closure", "self", "none", "astroid", "builder", "parse", "ten", "var", "for", "var", "in", "range", "10", "var", "var", "astroid", "body", "1", "value", "self", "assertraises", "nameinferenceerror", "var", "inferred"], "doc_len": 29}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_list_comp_nested", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_list_comp_nested", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_list_comp_nested(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            x = [[i + j for j in range(20)]\n                 for i in range(10)]\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_list_comp_nested", "self", "none", "astroid", "builder", "parse", "x", "i", "j", "for", "j", "in", "range", "20", "for", "i", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "3"], "doc_len": 57}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_dict_comp_nested", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_dict_comp_nested", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_dict_comp_nested(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            x = {i: {i: j for j in range(20)}\n                 for i in range(10)}\n            x3 = [{i + j for j in range(20)}  # Can't do nested sets\n                  for i in range(10)]\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 3)\n        self.assertEqual(len(xnames[1].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[1].lookup(\"i\")[1][0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_dict_comp_nested", "self", "none", "astroid", "builder", "parse", "x", "i", "i", "j", "for", "j", "in", "range", "20", "for", "i", "in", "range", "10", "x3", "i", "j", "for", "j", "in", "range", "20", "can", "t", "do", "nested", "sets", "for", "i", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "3", "self", "assertequal", "len", "xnames", "1", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "1", "lookup", "i", "1", "0", "lineno", "3"], "doc_len": 95}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_set_comp_nested", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_set_comp_nested", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_set_comp_nested(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            x = [{i + j for j in range(20)}  # Can't do nested sets\n                 for i in range(10)]\n        \"\"\",\n            __name__,\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"i\"]\n        self.assertEqual(len(xnames[0].lookup(\"i\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"i\")[1][0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_set_comp_nested", "self", "none", "astroid", "builder", "parse", "x", "i", "j", "for", "j", "in", "range", "20", "can", "t", "do", "nested", "sets", "for", "i", "in", "range", "10", "__name__", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "i", "self", "assertequal", "len", "xnames", "0", "lookup", "i", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "i", "1", "0", "lineno", "3"], "doc_len": 62}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_lambda_nested", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_lambda_nested", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_lambda_nested(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            f = lambda x: (\n                    lambda y: x + y)\n        \"\"\"\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n        self.assertEqual(len(xnames[0].lookup(\"x\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"x\")[1][0].lineno, 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_lambda_nested", "self", "none", "astroid", "builder", "parse", "f", "lambda", "x", "lambda", "y", "x", "y", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "self", "assertequal", "len", "xnames", "0", "lookup", "x", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "x", "1", "0", "lineno", "2"], "doc_len": 50}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_function_nested", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_function_nested", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_function_nested(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            def f1(x):\n                def f2(y):\n                    return x + y\n\n                return f2\n        \"\"\"\n        )\n        xnames = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n        self.assertEqual(len(xnames[0].lookup(\"x\")[1]), 1)\n        self.assertEqual(xnames[0].lookup(\"x\")[1][0].lineno, 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_function_nested", "self", "none", "astroid", "builder", "parse", "def", "f1", "x", "def", "f2", "y", "return", "x", "y", "return", "f2", "xnames", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "self", "assertequal", "len", "xnames", "0", "lookup", "x", "1", "1", "self", "assertequal", "xnames", "0", "lookup", "x", "1", "0", "lineno", "2"], "doc_len": 54}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_class_variables", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_class_variables", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_class_variables(self) -> None:\n        # Class variables are NOT available within nested scopes.\n        astroid = builder.parse(\n            \"\"\"\n            class A:\n                a = 10\n\n                def f1(self):\n                    return a  # a is not defined\n\n                f2 = lambda: a  # a is not defined\n\n                b = [a for _ in range(10)]  # a is not defined\n\n                class _Inner:\n                    inner_a = a + 1\n            \"\"\"\n        )\n        names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"a\"]\n        self.assertEqual(len(names), 4)\n        for name in names:\n            self.assertRaises(NameInferenceError, name.inferred)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_class_variables", "self", "none", "class", "variables", "are", "not", "available", "within", "nested", "scopes", "astroid", "builder", "parse", "class", "a", "a", "10", "def", "f1", "self", "return", "a", "a", "is", "not", "defined", "f2", "lambda", "a", "a", "is", "not", "defined", "b", "a", "for", "_", "in", "range", "10", "a", "is", "not", "defined", "class", "_inner", "inner_a", "a", "1", "names", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "a", "self", "assertequal", "len", "names", "4", "for", "name", "in", "names", "self", "assertraises", "nameinferenceerror", "name", "inferred"], "doc_len": 82}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_class_in_function", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_class_in_function", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_class_in_function(self) -> None:\n        # Function variables are available within classes, including methods\n        astroid = builder.parse(\n            \"\"\"\n            def f():\n                x = 10\n                class A:\n                    a = x\n\n                    def f1(self):\n                        return x\n\n                    f2 = lambda: x\n\n                    b = [x for _ in range(10)]\n\n                    class _Inner:\n                        inner_a = x + 1\n        \"\"\"\n        )\n        names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n        self.assertEqual(len(names), 5)\n        for name in names:\n            self.assertEqual(len(name.lookup(\"x\")[1]), 1, repr(name))\n            self.assertEqual(name.lookup(\"x\")[1][0].lineno, 3, repr(name))\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_class_in_function", "self", "none", "function", "variables", "are", "available", "within", "classes", "including", "methods", "astroid", "builder", "parse", "def", "f", "x", "10", "class", "a", "a", "x", "def", "f1", "self", "return", "x", "f2", "lambda", "x", "b", "x", "for", "_", "in", "range", "10", "class", "_inner", "inner_a", "x", "1", "names", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "self", "assertequal", "len", "names", "5", "for", "name", "in", "names", "self", "assertequal", "len", "name", "lookup", "x", "1", "1", "repr", "name", "self", "assertequal", "name", "lookup", "x", "1", "0", "lineno", "3", "repr", "name"], "doc_len": 90}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_generator_attributes", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_generator_attributes", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_generator_attributes(self) -> None:\n        tree = builder.parse(\n            \"\"\"\n            def count():\n                \"test\"\n                yield 0\n\n            iterer = count()\n            num = iterer.next()\n        \"\"\"\n        )\n        next_node = tree.body[2].value.func\n        gener = next_node.expr.inferred()[0]\n        self.assertIsInstance(gener.getattr(\"__next__\")[0], nodes.FunctionDef)\n        self.assertIsInstance(gener.getattr(\"send\")[0], nodes.FunctionDef)\n        self.assertIsInstance(gener.getattr(\"throw\")[0], nodes.FunctionDef)\n        self.assertIsInstance(gener.getattr(\"close\")[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_generator_attributes", "self", "none", "tree", "builder", "parse", "def", "count", "test", "yield", "0", "iterer", "count", "num", "iterer", "next", "next_node", "tree", "body", "2", "value", "func", "gener", "next_node", "expr", "inferred", "0", "self", "assertisinstance", "gener", "getattr", "__next__", "0", "nodes", "functiondef", "self", "assertisinstance", "gener", "getattr", "send", "0", "nodes", "functiondef", "self", "assertisinstance", "gener", "getattr", "throw", "0", "nodes", "functiondef", "self", "assertisinstance", "gener", "getattr", "close", "0", "nodes", "functiondef"], "doc_len": 64}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_explicit___name__", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_explicit___name__", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_explicit___name__(self) -> None:\n        code = \"\"\"\n            class Pouet:\n                __name__ = \"pouet\"\n            p1 = Pouet()\n\n            class PouetPouet(Pouet): pass\n            p2 = Pouet()\n\n            class NoName: pass\n            p3 = NoName()\n        \"\"\"\n        astroid = builder.parse(code, __name__)\n        p1 = next(astroid[\"p1\"].infer())\n        self.assertTrue(p1.getattr(\"__name__\"))\n        p2 = next(astroid[\"p2\"].infer())\n        self.assertTrue(p2.getattr(\"__name__\"))\n        self.assertTrue(astroid[\"NoName\"].getattr(\"__name__\"))\n        p3 = next(astroid[\"p3\"].infer())\n        self.assertRaises(AttributeInferenceError, p3.getattr, \"__name__\")\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_explicit___name__", "self", "none", "code", "class", "pouet", "__name__", "pouet", "p1", "pouet", "class", "pouetpouet", "pouet", "pass", "p2", "pouet", "class", "noname", "pass", "p3", "noname", "astroid", "builder", "parse", "code", "__name__", "p1", "next", "astroid", "p1", "infer", "self", "asserttrue", "p1", "getattr", "__name__", "p2", "next", "astroid", "p2", "infer", "self", "asserttrue", "p2", "getattr", "__name__", "self", "asserttrue", "astroid", "noname", "getattr", "__name__", "p3", "next", "astroid", "p3", "infer", "self", "assertraises", "attributeinferenceerror", "p3", "getattr", "__name__"], "doc_len": 68}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_function_module_special", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_function_module_special", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_function_module_special(self) -> None:\n        astroid = builder.parse(\n            '''\n        def initialize(linter):\n            \"\"\"initialize linter with checkers in this package \"\"\"\n            package_load(linter, __path__[0])\n        ''',\n            \"data.__init__\",\n        )\n        path = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"__path__\"][\n            0\n        ]\n        self.assertEqual(len(path.lookup(\"__path__\")[1]), 1)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_function_module_special", "self", "none", "astroid", "builder", "parse", "def", "initialize", "linter", "initialize", "linter", "with", "checkers", "in", "this", "package", "package_load", "linter", "__path__", "0", "data", "__init__", "path", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "__path__", "0", "self", "assertequal", "len", "path", "lookup", "__path__", "1", "1"], "doc_len": 49}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_builtin_lookup", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_builtin_lookup", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_builtin_lookup(self) -> None:\n        self.assertEqual(nodes.builtin_lookup(\"__dict__\")[1], ())\n        intstmts = nodes.builtin_lookup(\"int\")[1]\n        self.assertEqual(len(intstmts), 1)\n        self.assertIsInstance(intstmts[0], nodes.ClassDef)\n        self.assertEqual(intstmts[0].name, \"int\")\n        self.assertIs(intstmts[0], nodes.const_factory(1)._proxied)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_builtin_lookup", "self", "none", "self", "assertequal", "nodes", "builtin_lookup", "__dict__", "1", "intstmts", "nodes", "builtin_lookup", "int", "1", "self", "assertequal", "len", "intstmts", "1", "self", "assertisinstance", "intstmts", "0", "nodes", "classdef", "self", "assertequal", "intstmts", "0", "name", "int", "self", "assertis", "intstmts", "0", "nodes", "const_factory", "1", "_proxied"], "doc_len": 44}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_decorator_arguments_lookup", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_decorator_arguments_lookup", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_decorator_arguments_lookup(self) -> None:\n        code = \"\"\"\n            def decorator(value):\n                def wrapper(function):\n                    return function\n                return wrapper\n\n            class foo:\n                member = 10  #@\n\n                @decorator(member) #This will cause pylint to complain\n                def test(self):\n                    pass\n        \"\"\"\n\n        node = builder.extract_node(code, __name__)\n        assert isinstance(node, nodes.Assign)\n        member = node.targets[0]\n        it = member.infer()\n        obj = next(it)\n        self.assertIsInstance(obj, nodes.Const)\n        self.assertEqual(obj.value, 10)\n        self.assertRaises(StopIteration, functools.partial(next, it))\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_decorator_arguments_lookup", "self", "none", "code", "def", "decorator", "value", "def", "wrapper", "function", "return", "function", "return", "wrapper", "class", "foo", "member", "10", "decorator", "member", "this", "will", "cause", "pylint", "to", "complain", "def", "test", "self", "pass", "node", "builder", "extract_node", "code", "__name__", "assert", "isinstance", "node", "nodes", "assign", "member", "node", "targets", "0", "it", "member", "infer", "obj", "next", "it", "self", "assertisinstance", "obj", "nodes", "const", "self", "assertequal", "obj", "value", "10", "self", "assertraises", "stopiteration", "functools", "partial", "next", "it"], "doc_len": 72}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_inner_decorator_member_lookup", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_inner_decorator_member_lookup", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_inner_decorator_member_lookup(self) -> None:\n        code = \"\"\"\n            class FileA:\n                def decorator(bla):\n                    return bla\n\n                @__(decorator)\n                def funcA():\n                    return 4\n        \"\"\"\n        decname = builder.extract_node(code, __name__)\n        it = decname.infer()\n        obj = next(it)\n        self.assertIsInstance(obj, nodes.FunctionDef)\n        self.assertRaises(StopIteration, functools.partial(next, it))\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_inner_decorator_member_lookup", "self", "none", "code", "class", "filea", "def", "decorator", "bla", "return", "bla", "__", "decorator", "def", "funca", "return", "4", "decname", "builder", "extract_node", "code", "__name__", "it", "decname", "infer", "obj", "next", "it", "self", "assertisinstance", "obj", "nodes", "functiondef", "self", "assertraises", "stopiteration", "functools", "partial", "next", "it"], "doc_len": 45}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_static_method_lookup", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_static_method_lookup", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_static_method_lookup(self) -> None:\n        code = \"\"\"\n            class FileA:\n                @staticmethod\n                def funcA():\n                    return 4\n\n\n            class Test:\n                FileA = [1,2,3]\n\n                def __init__(self):\n                    print (FileA.funcA())\n        \"\"\"\n        astroid = builder.parse(code, __name__)\n        it = astroid[\"Test\"][\"__init__\"].ilookup(\"FileA\")\n        obj = next(it)\n        self.assertIsInstance(obj, nodes.ClassDef)\n        self.assertRaises(StopIteration, functools.partial(next, it))\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_static_method_lookup", "self", "none", "code", "class", "filea", "staticmethod", "def", "funca", "return", "4", "class", "test", "filea", "1", "2", "3", "def", "__init__", "self", "print", "filea", "funca", "astroid", "builder", "parse", "code", "__name__", "it", "astroid", "test", "__init__", "ilookup", "filea", "obj", "next", "it", "self", "assertisinstance", "obj", "nodes", "classdef", "self", "assertraises", "stopiteration", "functools", "partial", "next", "it"], "doc_len": 54}
{"doc_id": "tests/unittest_lookup.py::LookupTest.test_global_delete", "file_path": "tests/unittest_lookup.py", "class_name": "LookupTest", "func_name": "test_global_delete", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupTest\n    def test_global_delete(self) -> None:\n        code = \"\"\"\n            def run2():\n                f = Frobble()\n\n            class Frobble:\n                pass\n            Frobble.mumble = True\n\n            del Frobble\n\n            def run1():\n                f = Frobble()\n        \"\"\"\n        astroid = builder.parse(code, __name__)\n        stmts = astroid[\"run2\"].lookup(\"Frobbel\")[1]\n        self.assertEqual(len(stmts), 0)\n        stmts = astroid[\"run1\"].lookup(\"Frobbel\")[1]\n        self.assertEqual(len(stmts), 0)\n", "tokens": ["tests", "unittest_lookup", "py", "lookuptest", "def", "test_global_delete", "self", "none", "code", "def", "run2", "f", "frobble", "class", "frobble", "pass", "frobble", "mumble", "true", "del", "frobble", "def", "run1", "f", "frobble", "astroid", "builder", "parse", "code", "__name__", "stmts", "astroid", "run2", "lookup", "frobbel", "1", "self", "assertequal", "len", "stmts", "0", "stmts", "astroid", "run1", "lookup", "frobbel", "1", "self", "assertequal", "len", "stmts", "0"], "doc_len": 52}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_consecutive_assign", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_consecutive_assign", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_consecutive_assign(self) -> None:\n        \"\"\"When multiple assignment statements are in the same block, only the last one\n        is returned.\n        \"\"\"\n        code = \"\"\"\n            x = 10\n            x = 100\n            print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_consecutive_assign", "self", "none", "when", "multiple", "assignment", "statements", "are", "in", "the", "same", "block", "only", "the", "last", "one", "is", "returned", "code", "x", "10", "x", "100", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "3"], "doc_len": 64}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_after_use", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_after_use", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_after_use(self) -> None:\n        \"\"\"An assignment statement appearing after the variable is not returned.\"\"\"\n        code = \"\"\"\n            print(x)\n            x = 10\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 0)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_after_use", "self", "none", "an", "assignment", "statement", "appearing", "after", "the", "variable", "is", "not", "returned", "code", "print", "x", "x", "10", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "0"], "doc_len": 51}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_del_removes_prior", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_del_removes_prior", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_del_removes_prior(self) -> None:\n        \"\"\"Delete statement removes any prior assignments\"\"\"\n        code = \"\"\"\n            x = 10\n            del x\n            print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 0)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_del_removes_prior", "self", "none", "delete", "statement", "removes", "any", "prior", "assignments", "code", "x", "10", "del", "x", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "0"], "doc_len": 49}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_del_no_effect_after", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_del_no_effect_after", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_del_no_effect_after(self) -> None:\n        \"\"\"Delete statement doesn't remove future assignments\"\"\"\n        code = \"\"\"\n            x = 10\n            del x\n            x = 100\n            print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 4)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_del_no_effect_after", "self", "none", "delete", "statement", "doesn", "t", "remove", "future", "assignments", "code", "x", "10", "del", "x", "x", "100", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "4"], "doc_len": 58}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_assign", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_assign", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_assign(self) -> None:\n        \"\"\"Assignment in if statement is added to lookup results, but does not replace\n        prior assignments.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b:\n                    x = 100\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 2)\n        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 5])\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_assign", "self", "none", "assignment", "in", "if", "statement", "is", "added", "to", "lookup", "results", "but", "does", "not", "replace", "prior", "assignments", "code", "def", "f", "b", "x", "10", "if", "b", "x", "100", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "2", "self", "assertcountequal", "stmt", "lineno", "for", "stmt", "in", "stmts", "3", "5"], "doc_len": 73}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_assigns_same_branch", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_assigns_same_branch", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_assigns_same_branch(self) -> None:\n        \"\"\"When if branch has multiple assignment statements, only the last one\n        is added.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b:\n                    x = 100\n                    x = 1000\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 2)\n        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 6])\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_assigns_same_branch", "self", "none", "when", "if", "branch", "has", "multiple", "assignment", "statements", "only", "the", "last", "one", "is", "added", "code", "def", "f", "b", "x", "10", "if", "b", "x", "100", "x", "1000", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "2", "self", "assertcountequal", "stmt", "lineno", "for", "stmt", "in", "stmts", "3", "6"], "doc_len": 73}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_assigns_different_branch", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_assigns_different_branch", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_assigns_different_branch(self) -> None:\n        \"\"\"When different branches have assignment statements, the last one\n        in each branch is added.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b == 1:\n                    x = 100\n                    x = 1000\n                elif b == 2:\n                    x = 3\n                elif b == 3:\n                    x = 4\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 4)\n        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 6, 8, 10])\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_assigns_different_branch", "self", "none", "when", "different", "branches", "have", "assignment", "statements", "the", "last", "one", "in", "each", "branch", "is", "added", "code", "def", "f", "b", "x", "10", "if", "b", "1", "x", "100", "x", "1000", "elif", "b", "2", "x", "3", "elif", "b", "3", "x", "4", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "4", "self", "assertcountequal", "stmt", "lineno", "for", "stmt", "in", "stmts", "3", "6", "8", "10"], "doc_len": 87}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_exclusive", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_exclusive", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_exclusive(self) -> None:\n        \"\"\"When the variable appears inside a branch of an if statement,\n        no assignment statements from other branches are returned.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b == 1:\n                    x = 100\n                    x = 1000\n                elif b == 2:\n                    x = 3\n                elif b == 3:\n                    x = 4\n                else:\n                    print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_exclusive", "self", "none", "when", "the", "variable", "appears", "inside", "a", "branch", "of", "an", "if", "statement", "no", "assignment", "statements", "from", "other", "branches", "are", "returned", "code", "def", "f", "b", "x", "10", "if", "b", "1", "x", "100", "x", "1000", "elif", "b", "2", "x", "3", "elif", "b", "3", "x", "4", "else", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "3"], "doc_len": 87}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_not_exclusive", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_not_exclusive", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_not_exclusive(self) -> None:\n        \"\"\"When the variable appears inside a branch of an if statement,\n        only the last assignment statement in the same branch is returned.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b == 1:\n                    x = 100\n                    x = 1000\n                elif b == 2:\n                    x = 3\n                elif b == 3:\n                    x = 4\n                    print(x)\n                else:\n                    x = 5\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 10)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_not_exclusive", "self", "none", "when", "the", "variable", "appears", "inside", "a", "branch", "of", "an", "if", "statement", "only", "the", "last", "assignment", "statement", "in", "the", "same", "branch", "is", "returned", "code", "def", "f", "b", "x", "10", "if", "b", "1", "x", "100", "x", "1000", "elif", "b", "2", "x", "3", "elif", "b", "3", "x", "4", "print", "x", "else", "x", "5", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "10"], "doc_len": 92}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_else", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_else", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_else(self) -> None:\n        \"\"\"When an assignment statement appears in both an if and else branch, both\n        are added. This does NOT replace an assignment statement appearing before the\n        if statement. (See issue #213)\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b:\n                    x = 100\n                else:\n                    x = 1000\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 3)\n        self.assertCountEqual([stmt.lineno for stmt in stmts], [3, 5, 7])\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_else", "self", "none", "when", "an", "assignment", "statement", "appears", "in", "both", "an", "if", "and", "else", "branch", "both", "are", "added", "this", "does", "not", "replace", "an", "assignment", "statement", "appearing", "before", "the", "if", "statement", "see", "issue", "213", "code", "def", "f", "b", "x", "10", "if", "b", "x", "100", "else", "x", "1000", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "3", "self", "assertcountequal", "stmt", "lineno", "for", "stmt", "in", "stmts", "3", "5", "7"], "doc_len": 92}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_variable_in_condition_1", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_variable_in_condition_1", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_variable_in_condition_1(self) -> None:\n        \"\"\"Test lookup works correctly when a variable appears in an if condition.\"\"\"\n        code = \"\"\"\n            x = 10\n            if x > 10:\n                print('a')\n            elif x > 0:\n                print('b')\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name1, x_name2 = (\n            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n        )\n\n        _, stmts1 = x_name1.lookup(\"x\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 2)\n\n        _, stmts2 = x_name2.lookup(\"x\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_variable_in_condition_1", "self", "none", "test", "lookup", "works", "correctly", "when", "a", "variable", "appears", "in", "an", "if", "condition", "code", "x", "10", "if", "x", "10", "print", "a", "elif", "x", "0", "print", "b", "astroid", "builder", "parse", "code", "x_name1", "x_name2", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "_", "stmts1", "x_name1", "lookup", "x", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "2", "_", "stmts2", "x_name2", "lookup", "x", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "2"], "doc_len": 83}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_if_variable_in_condition_2", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_if_variable_in_condition_2", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_if_variable_in_condition_2(self) -> None:\n        \"\"\"Test lookup works correctly when a variable appears in an if condition,\n        and the variable is reassigned in each branch.\n\n        This is based on PyCQA/pylint issue #3711.\n        \"\"\"\n        code = \"\"\"\n            x = 10\n            if x > 10:\n                x = 100\n            elif x > 0:\n                x = 200\n            elif x > -10:\n                x = 300\n            else:\n                x = 400\n        \"\"\"\n        astroid = builder.parse(code)\n        x_names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"]\n\n        # All lookups should refer only to the initial x = 10.\n        for x_name in x_names:\n            _, stmts = x_name.lookup(\"x\")\n            self.assertEqual(len(stmts), 1)\n            self.assertEqual(stmts[0].lineno, 2)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_if_variable_in_condition_2", "self", "none", "test", "lookup", "works", "correctly", "when", "a", "variable", "appears", "in", "an", "if", "condition", "and", "the", "variable", "is", "reassigned", "in", "each", "branch", "this", "is", "based", "on", "pycqa", "pylint", "issue", "3711", "code", "x", "10", "if", "x", "10", "x", "100", "elif", "x", "0", "x", "200", "elif", "x", "10", "x", "300", "else", "x", "400", "astroid", "builder", "parse", "code", "x_names", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "all", "lookups", "should", "refer", "only", "to", "the", "initial", "x", "10", "for", "x_name", "in", "x_names", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "2"], "doc_len": 104}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_del_not_exclusive", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_del_not_exclusive", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_del_not_exclusive(self) -> None:\n        \"\"\"A delete statement in an if statement branch removes all previous\n        assignment statements when the delete statement is not exclusive with\n        the variable (e.g., when the variable is used below the if statement).\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b == 1:\n                    x = 100\n                elif b == 2:\n                    del x\n                elif b == 3:\n                    x = 4  # Only this assignment statement is returned\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 9)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_del_not_exclusive", "self", "none", "a", "delete", "statement", "in", "an", "if", "statement", "branch", "removes", "all", "previous", "assignment", "statements", "when", "the", "delete", "statement", "is", "not", "exclusive", "with", "the", "variable", "e", "g", "when", "the", "variable", "is", "used", "below", "the", "if", "statement", "code", "def", "f", "b", "x", "10", "if", "b", "1", "x", "100", "elif", "b", "2", "del", "x", "elif", "b", "3", "x", "4", "only", "this", "assignment", "statement", "is", "returned", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "9"], "doc_len": 105}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_del_exclusive", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_del_exclusive", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_del_exclusive(self) -> None:\n        \"\"\"A delete statement in an if statement branch that is exclusive with the\n        variable does not remove previous assignment statements.\n        \"\"\"\n        code = \"\"\"\n            def f(b):\n                x = 10\n                if b == 1:\n                    x = 100\n                elif b == 2:\n                    del x\n                else:\n                    print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 3)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_del_exclusive", "self", "none", "a", "delete", "statement", "in", "an", "if", "statement", "branch", "that", "is", "exclusive", "with", "the", "variable", "does", "not", "remove", "previous", "assignment", "statements", "code", "def", "f", "b", "x", "10", "if", "b", "1", "x", "100", "elif", "b", "2", "del", "x", "else", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "3"], "doc_len": 81}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_after_param", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_after_param", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_after_param(self) -> None:\n        \"\"\"When an assignment statement overwrites a function parameter, only the\n        assignment is returned, even when the variable and assignment do not have\n        the same parent.\n        \"\"\"\n        code = \"\"\"\n            def f1(x):\n                x = 100\n                print(x)\n\n            def f2(x):\n                x = 100\n                if True:\n                    print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name1, x_name2 = (\n            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n        )\n        _, stmts1 = x_name1.lookup(\"x\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 3)\n\n        _, stmts2 = x_name2.lookup(\"x\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 7)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_after_param", "self", "none", "when", "an", "assignment", "statement", "overwrites", "a", "function", "parameter", "only", "the", "assignment", "is", "returned", "even", "when", "the", "variable", "and", "assignment", "do", "not", "have", "the", "same", "parent", "code", "def", "f1", "x", "x", "100", "print", "x", "def", "f2", "x", "x", "100", "if", "true", "print", "x", "astroid", "builder", "parse", "code", "x_name1", "x_name2", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "_", "stmts1", "x_name1", "lookup", "x", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "3", "_", "stmts2", "x_name2", "lookup", "x", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "7"], "doc_len": 100}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_after_kwonly_param", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_after_kwonly_param", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_after_kwonly_param(self) -> None:\n        \"\"\"When an assignment statement overwrites a function keyword-only parameter,\n        only the assignment is returned, even when the variable and assignment do\n        not have the same parent.\n        \"\"\"\n        code = \"\"\"\n            def f1(*, x):\n                x = 100\n                print(x)\n\n            def f2(*, x):\n                x = 100\n                if True:\n                    print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name1, x_name2 = (\n            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n        )\n        _, stmts1 = x_name1.lookup(\"x\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 3)\n\n        _, stmts2 = x_name2.lookup(\"x\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 7)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_after_kwonly_param", "self", "none", "when", "an", "assignment", "statement", "overwrites", "a", "function", "keyword", "only", "parameter", "only", "the", "assignment", "is", "returned", "even", "when", "the", "variable", "and", "assignment", "do", "not", "have", "the", "same", "parent", "code", "def", "f1", "x", "x", "100", "print", "x", "def", "f2", "x", "x", "100", "if", "true", "print", "x", "astroid", "builder", "parse", "code", "x_name1", "x_name2", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "_", "stmts1", "x_name1", "lookup", "x", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "3", "_", "stmts2", "x_name2", "lookup", "x", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "7"], "doc_len": 102}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_after_posonly_param", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_after_posonly_param", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_after_posonly_param(self):\n        \"\"\"When an assignment statement overwrites a function positional-only parameter,\n        only the assignment is returned, even when the variable and assignment do\n        not have the same parent.\n        \"\"\"\n        code = \"\"\"\n            def f1(x, /):\n                x = 100\n                print(x)\n\n            def f2(x, /):\n                x = 100\n                if True:\n                    print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name1, x_name2 = (\n            n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"\n        )\n        _, stmts1 = x_name1.lookup(\"x\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 3)\n\n        _, stmts2 = x_name2.lookup(\"x\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 7)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_after_posonly_param", "self", "when", "an", "assignment", "statement", "overwrites", "a", "function", "positional", "only", "parameter", "only", "the", "assignment", "is", "returned", "even", "when", "the", "variable", "and", "assignment", "do", "not", "have", "the", "same", "parent", "code", "def", "f1", "x", "x", "100", "print", "x", "def", "f2", "x", "x", "100", "if", "true", "print", "x", "astroid", "builder", "parse", "code", "x_name1", "x_name2", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "_", "stmts1", "x_name1", "lookup", "x", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "3", "_", "stmts2", "x_name2", "lookup", "x", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "7"], "doc_len": 101}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_assign_after_args_param", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_assign_after_args_param", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_assign_after_args_param(self) -> None:\n        \"\"\"When an assignment statement overwrites a function parameter, only the\n        assignment is returned.\n        \"\"\"\n        code = \"\"\"\n            def f(*args, **kwargs):\n                args = [100]\n                kwargs = {}\n                if True:\n                    print(args, kwargs)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"args\"][0]\n        _, stmts1 = x_name.lookup(\"args\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 3)\n\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"kwargs\"][\n            0\n        ]\n        _, stmts2 = x_name.lookup(\"kwargs\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 4)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_assign_after_args_param", "self", "none", "when", "an", "assignment", "statement", "overwrites", "a", "function", "parameter", "only", "the", "assignment", "is", "returned", "code", "def", "f", "args", "kwargs", "args", "100", "kwargs", "if", "true", "print", "args", "kwargs", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "args", "0", "_", "stmts1", "x_name", "lookup", "args", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "3", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "kwargs", "0", "_", "stmts2", "x_name", "lookup", "kwargs", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "4"], "doc_len": 98}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_var_in_block", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_var_in_block", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_var_in_block(self) -> None:\n        \"\"\"When the variable bound to an exception in an except clause, it is returned\n        when that variable is used inside the except block.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except ZeroDivisionError as e:\n                print(e)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n        _, stmts = x_name.lookup(\"e\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 4)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_var_in_block", "self", "none", "when", "the", "variable", "bound", "to", "an", "exception", "in", "an", "except", "clause", "it", "is", "returned", "when", "that", "variable", "is", "used", "inside", "the", "except", "block", "code", "try", "1", "0", "except", "zerodivisionerror", "as", "e", "print", "e", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "e", "0", "_", "stmts", "x_name", "lookup", "e", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "4"], "doc_len": 75}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_var_in_block_overwrites", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_var_in_block_overwrites", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_var_in_block_overwrites(self) -> None:\n        \"\"\"When the variable bound to an exception in an except clause, it is returned\n        when that variable is used inside the except block, and replaces any previous\n        assignments.\n        \"\"\"\n        code = \"\"\"\n            e = 0\n            try:\n                1 / 0\n            except ZeroDivisionError as e:\n                print(e)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n        _, stmts = x_name.lookup(\"e\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 5)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_var_in_block_overwrites", "self", "none", "when", "the", "variable", "bound", "to", "an", "exception", "in", "an", "except", "clause", "it", "is", "returned", "when", "that", "variable", "is", "used", "inside", "the", "except", "block", "and", "replaces", "any", "previous", "assignments", "code", "e", "0", "try", "1", "0", "except", "zerodivisionerror", "as", "e", "print", "e", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "e", "0", "_", "stmts", "x_name", "lookup", "e", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "5"], "doc_len": 82}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_var_in_multiple_blocks", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_var_in_multiple_blocks", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_var_in_multiple_blocks(self) -> None:\n        \"\"\"When multiple variables with the same name are bound to an exception\n        in an except clause, and the variable is used inside the except block,\n        only the assignment from the corresponding except clause is returned.\n        \"\"\"\n        code = \"\"\"\n            e = 0\n            try:\n                1 / 0\n            except ZeroDivisionError as e:\n                print(e)\n            except NameError as e:\n                print(e)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_names = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"]\n\n        _, stmts1 = x_names[0].lookup(\"e\")\n        self.assertEqual(len(stmts1), 1)\n        self.assertEqual(stmts1[0].lineno, 5)\n\n        _, stmts2 = x_names[1].lookup(\"e\")\n        self.assertEqual(len(stmts2), 1)\n        self.assertEqual(stmts2[0].lineno, 7)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_var_in_multiple_blocks", "self", "none", "when", "multiple", "variables", "with", "the", "same", "name", "are", "bound", "to", "an", "exception", "in", "an", "except", "clause", "and", "the", "variable", "is", "used", "inside", "the", "except", "block", "only", "the", "assignment", "from", "the", "corresponding", "except", "clause", "is", "returned", "code", "e", "0", "try", "1", "0", "except", "zerodivisionerror", "as", "e", "print", "e", "except", "nameerror", "as", "e", "print", "e", "astroid", "builder", "parse", "code", "x_names", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "e", "_", "stmts1", "x_names", "0", "lookup", "e", "self", "assertequal", "len", "stmts1", "1", "self", "assertequal", "stmts1", "0", "lineno", "5", "_", "stmts2", "x_names", "1", "lookup", "e", "self", "assertequal", "len", "stmts2", "1", "self", "assertequal", "stmts2", "0", "lineno", "7"], "doc_len": 112}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_var_after_block_single", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_var_after_block_single", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_var_after_block_single(self) -> None:\n        \"\"\"When the variable bound to an exception in an except clause, it is NOT returned\n        when that variable is used after the except block.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except NameError as e:\n                pass\n            print(e)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n        _, stmts = x_name.lookup(\"e\")\n        self.assertEqual(len(stmts), 0)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_var_after_block_single", "self", "none", "when", "the", "variable", "bound", "to", "an", "exception", "in", "an", "except", "clause", "it", "is", "not", "returned", "when", "that", "variable", "is", "used", "after", "the", "except", "block", "code", "try", "1", "0", "except", "nameerror", "as", "e", "pass", "print", "e", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "e", "0", "_", "stmts", "x_name", "lookup", "e", "self", "assertequal", "len", "stmts", "0"], "doc_len": 71}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_var_after_block_multiple", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_var_after_block_multiple", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_var_after_block_multiple(self) -> None:\n        \"\"\"When the variable bound to an exception in multiple except clauses, it is NOT returned\n        when that variable is used after the except blocks.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except NameError as e:\n                pass\n            except ZeroDivisionError as e:\n                pass\n            print(e)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"e\"][0]\n        _, stmts = x_name.lookup(\"e\")\n        self.assertEqual(len(stmts), 0)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_var_after_block_multiple", "self", "none", "when", "the", "variable", "bound", "to", "an", "exception", "in", "multiple", "except", "clauses", "it", "is", "not", "returned", "when", "that", "variable", "is", "used", "after", "the", "except", "blocks", "code", "try", "1", "0", "except", "nameerror", "as", "e", "pass", "except", "zerodivisionerror", "as", "e", "pass", "print", "e", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "e", "0", "_", "stmts", "x_name", "lookup", "e", "self", "assertequal", "len", "stmts", "0"], "doc_len": 76}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_assign_in_block", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_assign_in_block", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_assign_in_block(self) -> None:\n        \"\"\"When a variable is assigned in an except block, it is returned\n        when that variable is used in the except block.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except ZeroDivisionError as e:\n                x = 10\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 5)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_assign_in_block", "self", "none", "when", "a", "variable", "is", "assigned", "in", "an", "except", "block", "it", "is", "returned", "when", "that", "variable", "is", "used", "in", "the", "except", "block", "code", "try", "1", "0", "except", "zerodivisionerror", "as", "e", "x", "10", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "5"], "doc_len": 75}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_assign_in_block_multiple", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_assign_in_block_multiple", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_assign_in_block_multiple(self) -> None:\n        \"\"\"When a variable is assigned in multiple except blocks, and the variable is\n        used in one of the blocks, only the assignments in that block are returned.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except ZeroDivisionError:\n                x = 10\n            except NameError:\n                x = 100\n                print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 7)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_assign_in_block_multiple", "self", "none", "when", "a", "variable", "is", "assigned", "in", "multiple", "except", "blocks", "and", "the", "variable", "is", "used", "in", "one", "of", "the", "blocks", "only", "the", "assignments", "in", "that", "block", "are", "returned", "code", "try", "1", "0", "except", "zerodivisionerror", "x", "10", "except", "nameerror", "x", "100", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "7"], "doc_len": 83}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_assign_after_block", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_assign_after_block", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_assign_after_block(self) -> None:\n        \"\"\"When a variable is assigned in an except clause, it is returned\n        when that variable is used after the except block.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except ZeroDivisionError:\n                x = 10\n            except NameError:\n                x = 100\n            print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 2)\n        self.assertCountEqual([stmt.lineno for stmt in stmts], [5, 7])\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_assign_after_block", "self", "none", "when", "a", "variable", "is", "assigned", "in", "an", "except", "clause", "it", "is", "returned", "when", "that", "variable", "is", "used", "after", "the", "except", "block", "code", "try", "1", "0", "except", "zerodivisionerror", "x", "10", "except", "nameerror", "x", "100", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "2", "self", "assertcountequal", "stmt", "lineno", "for", "stmt", "in", "stmts", "5", "7"], "doc_len": 81}
{"doc_id": "tests/unittest_lookup.py::LookupControlFlowTest.test_except_assign_after_block_overwritten", "file_path": "tests/unittest_lookup.py", "class_name": "LookupControlFlowTest", "func_name": "test_except_assign_after_block_overwritten", "text": "文件路径: tests/unittest_lookup.py, 类名: LookupControlFlowTest\n    def test_except_assign_after_block_overwritten(self) -> None:\n        \"\"\"When a variable is assigned in an except clause, it is not returned\n        when it is reassigned and used after the except block.\n        \"\"\"\n        code = \"\"\"\n            try:\n                1 / 0\n            except ZeroDivisionError:\n                x = 10\n            except NameError:\n                x = 100\n            x = 1000\n            print(x)\n        \"\"\"\n        astroid = builder.parse(code)\n        x_name = [n for n in astroid.nodes_of_class(nodes.Name) if n.name == \"x\"][0]\n        _, stmts = x_name.lookup(\"x\")\n        self.assertEqual(len(stmts), 1)\n        self.assertEqual(stmts[0].lineno, 8)\n", "tokens": ["tests", "unittest_lookup", "py", "lookupcontrolflowtest", "def", "test_except_assign_after_block_overwritten", "self", "none", "when", "a", "variable", "is", "assigned", "in", "an", "except", "clause", "it", "is", "not", "returned", "when", "it", "is", "reassigned", "and", "used", "after", "the", "except", "block", "code", "try", "1", "0", "except", "zerodivisionerror", "x", "10", "except", "nameerror", "x", "100", "x", "1000", "print", "x", "astroid", "builder", "parse", "code", "x_name", "n", "for", "n", "in", "astroid", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "0", "_", "stmts", "x_name", "lookup", "x", "self", "assertequal", "len", "stmts", "1", "self", "assertequal", "stmts", "0", "lineno", "8"], "doc_len": 81}
{"doc_id": "tests/unittest_manager.py::_get_file_from_object", "file_path": "tests/unittest_manager.py", "class_name": null, "func_name": "_get_file_from_object", "text": "文件路径: tests/unittest_manager.py\ndef _get_file_from_object(obj) -> str:\n    if platform.python_implementation() == \"Jython\":\n        return obj.__file__.split(\"$py.class\")[0] + \".py\"\n    return obj.__file__\n", "tokens": ["tests", "unittest_manager", "py", "def", "_get_file_from_object", "obj", "str", "if", "platform", "python_implementation", "jython", "return", "obj", "__file__", "split", "py", "class", "0", "py", "return", "obj", "__file__"], "doc_len": 22}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.setUp", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "setUp", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def setUp(self) -> None:\n        super().setUp()\n        self.manager = test_utils.brainless_manager()\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "setup", "self", "none", "super", "setup", "self", "manager", "test_utils", "brainless_manager"], "doc_len": 14}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_file", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_file", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_file(self) -> None:\n        filepath = unittest.__file__\n        ast = self.manager.ast_from_file(filepath)\n        self.assertEqual(ast.name, \"unittest\")\n        self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_file", "self", "none", "filepath", "unittest", "__file__", "ast", "self", "manager", "ast_from_file", "filepath", "self", "assertequal", "ast", "name", "unittest", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 27}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_file_cache", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_file_cache", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_file_cache(self) -> None:\n        filepath = unittest.__file__\n        self.manager.ast_from_file(filepath)\n        ast = self.manager.ast_from_file(\"unhandledName\", \"unittest\")\n        self.assertEqual(ast.name, \"unittest\")\n        self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_file_cache", "self", "none", "filepath", "unittest", "__file__", "self", "manager", "ast_from_file", "filepath", "ast", "self", "manager", "ast_from_file", "unhandledname", "unittest", "self", "assertequal", "ast", "name", "unittest", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 32}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_file_astro_builder", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_file_astro_builder", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_file_astro_builder(self) -> None:\n        filepath = unittest.__file__\n        ast = self.manager.ast_from_file(filepath, None, True, True)\n        self.assertEqual(ast.name, \"unittest\")\n        self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_file_astro_builder", "self", "none", "filepath", "unittest", "__file__", "ast", "self", "manager", "ast_from_file", "filepath", "none", "true", "true", "self", "assertequal", "ast", "name", "unittest", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 30}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_file_name_astro_builder_exception", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_file_name_astro_builder_exception", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_file_name_astro_builder_exception(self) -> None:\n        self.assertRaises(\n            AstroidBuildingError, self.manager.ast_from_file, \"unhandledName\"\n        )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_file_name_astro_builder_exception", "self", "none", "self", "assertraises", "astroidbuildingerror", "self", "manager", "ast_from_file", "unhandledname"], "doc_len": 15}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_string", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_string", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_string(self) -> None:\n        filepath = unittest.__file__\n        dirname = os.path.dirname(filepath)\n        modname = os.path.basename(dirname)\n        with open(filepath, encoding=\"utf-8\") as file:\n            data = file.read()\n            ast = self.manager.ast_from_string(data, modname, filepath)\n            self.assertEqual(ast.name, \"unittest\")\n            self.assertEqual(ast.file, filepath)\n            self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_string", "self", "none", "filepath", "unittest", "__file__", "dirname", "os", "path", "dirname", "filepath", "modname", "os", "path", "basename", "dirname", "with", "open", "filepath", "encoding", "utf", "8", "as", "file", "data", "file", "read", "ast", "self", "manager", "ast_from_string", "data", "modname", "filepath", "self", "assertequal", "ast", "name", "unittest", "self", "assertequal", "ast", "file", "filepath", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 55}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_do_not_expose_main", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_do_not_expose_main", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_do_not_expose_main(self) -> None:\n        obj = self.manager.ast_from_module_name(\"__main__\")\n        self.assertEqual(obj.name, \"__main__\")\n        self.assertEqual(obj.items(), [])\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_do_not_expose_main", "self", "none", "obj", "self", "manager", "ast_from_module_name", "__main__", "self", "assertequal", "obj", "name", "__main__", "self", "assertequal", "obj", "items"], "doc_len": 22}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name(self) -> None:\n        ast = self.manager.ast_from_module_name(\"unittest\")\n        self.assertEqual(ast.name, \"unittest\")\n        self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name", "self", "none", "ast", "self", "manager", "ast_from_module_name", "unittest", "self", "assertequal", "ast", "name", "unittest", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 24}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name_not_python_source", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name_not_python_source", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name_not_python_source(self) -> None:\n        ast = self.manager.ast_from_module_name(\"time\")\n        self.assertEqual(ast.name, \"time\")\n        self.assertIn(\"time\", self.manager.astroid_cache)\n        self.assertEqual(ast.pure_python, False)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name_not_python_source", "self", "none", "ast", "self", "manager", "ast_from_module_name", "time", "self", "assertequal", "ast", "name", "time", "self", "assertin", "time", "self", "manager", "astroid_cache", "self", "assertequal", "ast", "pure_python", "false"], "doc_len": 29}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name_astro_builder_exception", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name_astro_builder_exception", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name_astro_builder_exception(self) -> None:\n        self.assertRaises(\n            AstroidBuildingError,\n            self.manager.ast_from_module_name,\n            \"unhandledModule\",\n        )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name_astro_builder_exception", "self", "none", "self", "assertraises", "astroidbuildingerror", "self", "manager", "ast_from_module_name", "unhandledmodule"], "doc_len": 15}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest._test_ast_from_old_namespace_package_protocol", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "_test_ast_from_old_namespace_package_protocol", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def _test_ast_from_old_namespace_package_protocol(self, root: str) -> None:\n        origpath = sys.path[:]\n        paths = [resources.find(f\"data/path_{root}_{index}\") for index in range(1, 4)]\n        sys.path.extend(paths)\n        try:\n            for name in (\"foo\", \"bar\", \"baz\"):\n                module = self.manager.ast_from_module_name(\"package.\" + name)\n                self.assertIsInstance(module, astroid.Module)\n        finally:\n            sys.path = origpath\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "_test_ast_from_old_namespace_package_protocol", "self", "root", "str", "none", "origpath", "sys", "path", "paths", "resources", "find", "f", "data", "path_", "root", "_", "index", "for", "index", "in", "range", "1", "4", "sys", "path", "extend", "paths", "try", "for", "name", "in", "foo", "bar", "baz", "module", "self", "manager", "ast_from_module_name", "package", "name", "self", "assertisinstance", "module", "astroid", "module", "finally", "sys", "path", "origpath"], "doc_len": 54}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_namespace_pkgutil", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_namespace_pkgutil", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_namespace_pkgutil(self) -> None:\n        self._test_ast_from_old_namespace_package_protocol(\"pkgutil\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_namespace_pkgutil", "self", "none", "self", "_test_ast_from_old_namespace_package_protocol", "pkgutil"], "doc_len": 11}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_namespace_pkg_resources", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_namespace_pkg_resources", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_namespace_pkg_resources(self) -> None:\n        self._test_ast_from_old_namespace_package_protocol(\"pkg_resources\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_namespace_pkg_resources", "self", "none", "self", "_test_ast_from_old_namespace_package_protocol", "pkg_resources"], "doc_len": 11}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_implicit_namespace_package", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_implicit_namespace_package", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_implicit_namespace_package(self) -> None:\n        data_dir = os.path.dirname(resources.find(\"data/namespace_pep_420\"))\n        contribute = os.path.join(data_dir, \"contribute_to_namespace\")\n        for value in (data_dir, contribute):\n            sys.path.insert(0, value)\n\n        try:\n            module = self.manager.ast_from_module_name(\"namespace_pep_420.module\")\n            self.assertIsInstance(module, astroid.Module)\n            self.assertEqual(module.name, \"namespace_pep_420.module\")\n            var = next(module.igetattr(\"var\"))\n            self.assertIsInstance(var, astroid.Const)\n            self.assertEqual(var.value, 42)\n        finally:\n            for _ in range(2):\n                sys.path.pop(0)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_implicit_namespace_package", "self", "none", "data_dir", "os", "path", "dirname", "resources", "find", "data", "namespace_pep_420", "contribute", "os", "path", "join", "data_dir", "contribute_to_namespace", "for", "value", "in", "data_dir", "contribute", "sys", "path", "insert", "0", "value", "try", "module", "self", "manager", "ast_from_module_name", "namespace_pep_420", "module", "self", "assertisinstance", "module", "astroid", "module", "self", "assertequal", "module", "name", "namespace_pep_420", "module", "var", "next", "module", "igetattr", "var", "self", "assertisinstance", "var", "astroid", "const", "self", "assertequal", "var", "value", "42", "finally", "for", "_", "in", "range", "2", "sys", "path", "pop", "0"], "doc_len": 75}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_namespace_package_pth_support", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_namespace_package_pth_support", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_namespace_package_pth_support(self) -> None:\n        pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n        site.addpackage(resources.RESOURCE_PATH, pth, [])\n        pkg_resources._namespace_packages[\"foogle\"] = []\n\n        try:\n            module = self.manager.ast_from_module_name(\"foogle.fax\")\n            submodule = next(module.igetattr(\"a\"))\n            value = next(submodule.igetattr(\"x\"))\n            self.assertIsInstance(value, astroid.Const)\n            with self.assertRaises(AstroidImportError):\n                self.manager.ast_from_module_name(\"foogle.moogle\")\n        finally:\n            del pkg_resources._namespace_packages[\"foogle\"]\n            sys.modules.pop(\"foogle\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_namespace_package_pth_support", "self", "none", "pth", "foogle_fax", "0", "12", "5", "py2", "7", "nspkg", "pth", "site", "addpackage", "resources", "resource_path", "pth", "pkg_resources", "_namespace_packages", "foogle", "try", "module", "self", "manager", "ast_from_module_name", "foogle", "fax", "submodule", "next", "module", "igetattr", "a", "value", "next", "submodule", "igetattr", "x", "self", "assertisinstance", "value", "astroid", "const", "with", "self", "assertraises", "astroidimporterror", "self", "manager", "ast_from_module_name", "foogle", "moogle", "finally", "del", "pkg_resources", "_namespace_packages", "foogle", "sys", "modules", "pop", "foogle"], "doc_len": 65}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_nested_namespace_import", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_nested_namespace_import", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_nested_namespace_import(self) -> None:\n        pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n        site.addpackage(resources.RESOURCE_PATH, pth, [])\n        pkg_resources._namespace_packages[\"foogle\"] = [\"foogle.crank\"]\n        pkg_resources._namespace_packages[\"foogle.crank\"] = []\n        try:\n            self.manager.ast_from_module_name(\"foogle.crank\")\n        finally:\n            del pkg_resources._namespace_packages[\"foogle\"]\n            sys.modules.pop(\"foogle\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_nested_namespace_import", "self", "none", "pth", "foogle_fax", "0", "12", "5", "py2", "7", "nspkg", "pth", "site", "addpackage", "resources", "resource_path", "pth", "pkg_resources", "_namespace_packages", "foogle", "foogle", "crank", "pkg_resources", "_namespace_packages", "foogle", "crank", "try", "self", "manager", "ast_from_module_name", "foogle", "crank", "finally", "del", "pkg_resources", "_namespace_packages", "foogle", "sys", "modules", "pop", "foogle"], "doc_len": 46}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_namespace_and_file_mismatch", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_namespace_and_file_mismatch", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_namespace_and_file_mismatch(self) -> None:\n        filepath = unittest.__file__\n        ast = self.manager.ast_from_file(filepath)\n        self.assertEqual(ast.name, \"unittest\")\n        pth = \"foogle_fax-0.12.5-py2.7-nspkg.pth\"\n        site.addpackage(resources.RESOURCE_PATH, pth, [])\n        pkg_resources._namespace_packages[\"foogle\"] = []\n        try:\n            with self.assertRaises(AstroidImportError):\n                self.manager.ast_from_module_name(\"unittest.foogle.fax\")\n        finally:\n            del pkg_resources._namespace_packages[\"foogle\"]\n            sys.modules.pop(\"foogle\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_namespace_and_file_mismatch", "self", "none", "filepath", "unittest", "__file__", "ast", "self", "manager", "ast_from_file", "filepath", "self", "assertequal", "ast", "name", "unittest", "pth", "foogle_fax", "0", "12", "5", "py2", "7", "nspkg", "pth", "site", "addpackage", "resources", "resource_path", "pth", "pkg_resources", "_namespace_packages", "foogle", "try", "with", "self", "assertraises", "astroidimporterror", "self", "manager", "ast_from_module_name", "unittest", "foogle", "fax", "finally", "del", "pkg_resources", "_namespace_packages", "foogle", "sys", "modules", "pop", "foogle"], "doc_len": 58}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest._test_ast_from_zip", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "_test_ast_from_zip", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def _test_ast_from_zip(self, archive: str) -> None:\n        sys.modules.pop(\"mypypa\", None)\n        archive_path = resources.find(archive)\n        sys.path.insert(0, archive_path)\n        module = self.manager.ast_from_module_name(\"mypypa\")\n        self.assertEqual(module.name, \"mypypa\")\n        end = os.path.join(archive, \"mypypa\")\n        self.assertTrue(\n            module.file.endswith(end), f\"{module.file} doesn't endswith {end}\"\n        )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "_test_ast_from_zip", "self", "archive", "str", "none", "sys", "modules", "pop", "mypypa", "none", "archive_path", "resources", "find", "archive", "sys", "path", "insert", "0", "archive_path", "module", "self", "manager", "ast_from_module_name", "mypypa", "self", "assertequal", "module", "name", "mypypa", "end", "os", "path", "join", "archive", "mypypa", "self", "asserttrue", "module", "file", "endswith", "end", "f", "module", "file", "doesn", "t", "endswith", "end"], "doc_len": 53}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest._restore_package_cache", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "_restore_package_cache", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def _restore_package_cache(self) -> Iterator:\n        orig_path = sys.path[:]\n        orig_pathcache = sys.path_importer_cache.copy()\n        orig_modcache = self.manager.astroid_cache.copy()\n        orig_modfilecache = self.manager._mod_file_cache.copy()\n        orig_importhooks = self.manager._failed_import_hooks[:]\n        yield\n        self.manager._failed_import_hooks = orig_importhooks\n        self.manager._mod_file_cache = orig_modfilecache\n        self.manager.astroid_cache = orig_modcache\n        sys.path_importer_cache = orig_pathcache\n        sys.path = orig_path\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "_restore_package_cache", "self", "iterator", "orig_path", "sys", "path", "orig_pathcache", "sys", "path_importer_cache", "copy", "orig_modcache", "self", "manager", "astroid_cache", "copy", "orig_modfilecache", "self", "manager", "_mod_file_cache", "copy", "orig_importhooks", "self", "manager", "_failed_import_hooks", "yield", "self", "manager", "_failed_import_hooks", "orig_importhooks", "self", "manager", "_mod_file_cache", "orig_modfilecache", "self", "manager", "astroid_cache", "orig_modcache", "sys", "path_importer_cache", "orig_pathcache", "sys", "path", "orig_path"], "doc_len": 48}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name_egg", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name_egg", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name_egg(self) -> None:\n        with self._restore_package_cache():\n            self._test_ast_from_zip(\n                os.path.sep.join([\"data\", os.path.normcase(\"MyPyPa-0.1.0-py2.5.egg\")])\n            )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name_egg", "self", "none", "with", "self", "_restore_package_cache", "self", "_test_ast_from_zip", "os", "path", "sep", "join", "data", "os", "path", "normcase", "mypypa", "0", "1", "0", "py2", "5", "egg"], "doc_len": 28}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name_zip", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name_zip", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name_zip(self) -> None:\n        with self._restore_package_cache():\n            self._test_ast_from_zip(\n                os.path.sep.join([\"data\", os.path.normcase(\"MyPyPa-0.1.0-py2.5.zip\")])\n            )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name_zip", "self", "none", "with", "self", "_restore_package_cache", "self", "_test_ast_from_zip", "os", "path", "sep", "join", "data", "os", "path", "normcase", "mypypa", "0", "1", "0", "py2", "5", "zip"], "doc_len": 28}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_name_pyz", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_name_pyz", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_name_pyz(self) -> None:\n        try:\n            linked_file_name = os.path.join(\n                resources.RESOURCE_PATH, \"MyPyPa-0.1.0-py2.5.pyz\"\n            )\n            os.symlink(\n                os.path.join(resources.RESOURCE_PATH, \"MyPyPa-0.1.0-py2.5.zip\"),\n                linked_file_name,\n            )\n\n            with self._restore_package_cache():\n                self._test_ast_from_zip(linked_file_name)\n        finally:\n            os.remove(linked_file_name)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_name_pyz", "self", "none", "try", "linked_file_name", "os", "path", "join", "resources", "resource_path", "mypypa", "0", "1", "0", "py2", "5", "pyz", "os", "symlink", "os", "path", "join", "resources", "resource_path", "mypypa", "0", "1", "0", "py2", "5", "zip", "linked_file_name", "with", "self", "_restore_package_cache", "self", "_test_ast_from_zip", "linked_file_name", "finally", "os", "remove", "linked_file_name"], "doc_len": 47}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_zip_import_data", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_zip_import_data", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_zip_import_data(self) -> None:\n        \"\"\"check if zip_import_data works\"\"\"\n        with self._restore_package_cache():\n            filepath = resources.find(\"data/MyPyPa-0.1.0-py2.5.zip/mypypa\")\n            ast = self.manager.zip_import_data(filepath)\n            self.assertEqual(ast.name, \"mypypa\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_zip_import_data", "self", "none", "check", "if", "zip_import_data", "works", "with", "self", "_restore_package_cache", "filepath", "resources", "find", "data", "mypypa", "0", "1", "0", "py2", "5", "zip", "mypypa", "ast", "self", "manager", "zip_import_data", "filepath", "self", "assertequal", "ast", "name", "mypypa"], "doc_len": 37}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_zip_import_data_without_zipimport", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_zip_import_data_without_zipimport", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_zip_import_data_without_zipimport(self) -> None:\n        \"\"\"check if zip_import_data return None without zipimport\"\"\"\n        self.assertEqual(self.manager.zip_import_data(\"path\"), None)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_zip_import_data_without_zipimport", "self", "none", "check", "if", "zip_import_data", "return", "none", "without", "zipimport", "self", "assertequal", "self", "manager", "zip_import_data", "path", "none"], "doc_len": 22}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_file_from_module", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_file_from_module", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_file_from_module(self) -> None:\n        \"\"\"check if the unittest filepath is equals to the result of the method\"\"\"\n        self.assertEqual(\n            _get_file_from_object(unittest),\n            self.manager.file_from_module_name(\"unittest\", None).location,\n        )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_file_from_module", "self", "none", "check", "if", "the", "unittest", "filepath", "is", "equals", "to", "the", "result", "of", "the", "method", "self", "assertequal", "_get_file_from_object", "unittest", "self", "manager", "file_from_module_name", "unittest", "none", "location"], "doc_len": 31}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_file_from_module_name_astro_building_exception", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_file_from_module_name_astro_building_exception", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_file_from_module_name_astro_building_exception(self) -> None:\n        \"\"\"check if the method raises an exception with a wrong module name\"\"\"\n        self.assertRaises(\n            AstroidBuildingError,\n            self.manager.file_from_module_name,\n            \"unhandledModule\",\n            None,\n        )\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_file_from_module_name_astro_building_exception", "self", "none", "check", "if", "the", "method", "raises", "an", "exception", "with", "a", "wrong", "module", "name", "self", "assertraises", "astroidbuildingerror", "self", "manager", "file_from_module_name", "unhandledmodule", "none"], "doc_len": 28}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module(self) -> None:\n        ast = self.manager.ast_from_module(unittest)\n        self.assertEqual(ast.pure_python, True)\n        ast = self.manager.ast_from_module(time)\n        self.assertEqual(ast.pure_python, False)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module", "self", "none", "ast", "self", "manager", "ast_from_module", "unittest", "self", "assertequal", "ast", "pure_python", "true", "ast", "self", "manager", "ast_from_module", "time", "self", "assertequal", "ast", "pure_python", "false"], "doc_len": 28}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_module_cache", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_module_cache", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_module_cache(self) -> None:\n        \"\"\"check if the module is in the cache manager\"\"\"\n        ast = self.manager.ast_from_module(unittest)\n        self.assertEqual(ast.name, \"unittest\")\n        self.assertIn(\"unittest\", self.manager.astroid_cache)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_module_cache", "self", "none", "check", "if", "the", "module", "is", "in", "the", "cache", "manager", "ast", "self", "manager", "ast_from_module", "unittest", "self", "assertequal", "ast", "name", "unittest", "self", "assertin", "unittest", "self", "manager", "astroid_cache"], "doc_len": 33}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_class", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_class", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_class(self) -> None:\n        ast = self.manager.ast_from_class(int)\n        self.assertEqual(ast.name, \"int\")\n        self.assertEqual(ast.parent.frame().name, \"builtins\")\n        self.assertEqual(ast.parent.frame(future=True).name, \"builtins\")\n\n        ast = self.manager.ast_from_class(object)\n        self.assertEqual(ast.name, \"object\")\n        self.assertEqual(ast.parent.frame().name, \"builtins\")\n        self.assertEqual(ast.parent.frame(future=True).name, \"builtins\")\n        self.assertIn(\"__setattr__\", ast)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_class", "self", "none", "ast", "self", "manager", "ast_from_class", "int", "self", "assertequal", "ast", "name", "int", "self", "assertequal", "ast", "parent", "frame", "name", "builtins", "self", "assertequal", "ast", "parent", "frame", "future", "true", "name", "builtins", "ast", "self", "manager", "ast_from_class", "object", "self", "assertequal", "ast", "name", "object", "self", "assertequal", "ast", "parent", "frame", "name", "builtins", "self", "assertequal", "ast", "parent", "frame", "future", "true", "name", "builtins", "self", "assertin", "__setattr__", "ast"], "doc_len": 64}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_class_with_module", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_class_with_module", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_class_with_module(self) -> None:\n        \"\"\"check if the method works with the module name\"\"\"\n        ast = self.manager.ast_from_class(int, int.__module__)\n        self.assertEqual(ast.name, \"int\")\n        self.assertEqual(ast.parent.frame().name, \"builtins\")\n        self.assertEqual(ast.parent.frame(future=True).name, \"builtins\")\n\n        ast = self.manager.ast_from_class(object, object.__module__)\n        self.assertEqual(ast.name, \"object\")\n        self.assertEqual(ast.parent.frame().name, \"builtins\")\n        self.assertEqual(ast.parent.frame(future=True).name, \"builtins\")\n        self.assertIn(\"__setattr__\", ast)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_class_with_module", "self", "none", "check", "if", "the", "method", "works", "with", "the", "module", "name", "ast", "self", "manager", "ast_from_class", "int", "int", "__module__", "self", "assertequal", "ast", "name", "int", "self", "assertequal", "ast", "parent", "frame", "name", "builtins", "self", "assertequal", "ast", "parent", "frame", "future", "true", "name", "builtins", "ast", "self", "manager", "ast_from_class", "object", "object", "__module__", "self", "assertequal", "ast", "name", "object", "self", "assertequal", "ast", "parent", "frame", "name", "builtins", "self", "assertequal", "ast", "parent", "frame", "future", "true", "name", "builtins", "self", "assertin", "__setattr__", "ast"], "doc_len": 77}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_ast_from_class_attr_error", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_ast_from_class_attr_error", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_ast_from_class_attr_error(self) -> None:\n        \"\"\"give a wrong class at the ast_from_class method\"\"\"\n        self.assertRaises(AstroidBuildingError, self.manager.ast_from_class, None)\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_ast_from_class_attr_error", "self", "none", "give", "a", "wrong", "class", "at", "the", "ast_from_class", "method", "self", "assertraises", "astroidbuildingerror", "self", "manager", "ast_from_class", "none"], "doc_len": 23}
{"doc_id": "tests/unittest_manager.py::AstroidManagerTest.test_failed_import_hooks", "file_path": "tests/unittest_manager.py", "class_name": "AstroidManagerTest", "func_name": "test_failed_import_hooks", "text": "文件路径: tests/unittest_manager.py, 类名: AstroidManagerTest\n    def test_failed_import_hooks(self) -> None:\n        def hook(modname: str):\n            if modname == \"foo.bar\":\n                return unittest\n\n            raise AstroidBuildingError()\n\n        with self.assertRaises(AstroidBuildingError):\n            self.manager.ast_from_module_name(\"foo.bar\")\n\n        with self._restore_package_cache():\n            self.manager.register_failed_import_hook(hook)\n            self.assertEqual(unittest, self.manager.ast_from_module_name(\"foo.bar\"))\n            with self.assertRaises(AstroidBuildingError):\n                self.manager.ast_from_module_name(\"foo.bar.baz\")\n", "tokens": ["tests", "unittest_manager", "py", "astroidmanagertest", "def", "test_failed_import_hooks", "self", "none", "def", "hook", "modname", "str", "if", "modname", "foo", "bar", "return", "unittest", "raise", "astroidbuildingerror", "with", "self", "assertraises", "astroidbuildingerror", "self", "manager", "ast_from_module_name", "foo", "bar", "with", "self", "_restore_package_cache", "self", "manager", "register_failed_import_hook", "hook", "self", "assertequal", "unittest", "self", "manager", "ast_from_module_name", "foo", "bar", "with", "self", "assertraises", "astroidbuildingerror", "self", "manager", "ast_from_module_name", "foo", "bar", "baz"], "doc_len": 54}
{"doc_id": "tests/unittest_manager.py::BorgAstroidManagerTC.test_borg", "file_path": "tests/unittest_manager.py", "class_name": "BorgAstroidManagerTC", "func_name": "test_borg", "text": "文件路径: tests/unittest_manager.py, 类名: BorgAstroidManagerTC\n    def test_borg(self) -> None:\n        \"\"\"test that the AstroidManager is really a borg, i.e. that two different\n        instances has same cache\"\"\"\n        first_manager = manager.AstroidManager()\n        built = first_manager.ast_from_module_name(\"builtins\")\n\n        second_manager = manager.AstroidManager()\n        second_built = second_manager.ast_from_module_name(\"builtins\")\n        self.assertIs(built, second_built)\n", "tokens": ["tests", "unittest_manager", "py", "borgastroidmanagertc", "def", "test_borg", "self", "none", "test", "that", "the", "astroidmanager", "is", "really", "a", "borg", "i", "e", "that", "two", "different", "instances", "has", "same", "cache", "first_manager", "manager", "astroidmanager", "built", "first_manager", "ast_from_module_name", "builtins", "second_manager", "manager", "astroidmanager", "second_built", "second_manager", "ast_from_module_name", "builtins", "self", "assertis", "built", "second_built"], "doc_len": 43}
{"doc_id": "tests/unittest_modutils.py::_get_file_from_object", "file_path": "tests/unittest_modutils.py", "class_name": null, "func_name": "_get_file_from_object", "text": "文件路径: tests/unittest_modutils.py\ndef _get_file_from_object(obj) -> str:\n    return modutils._path_from_filename(obj.__file__)\n", "tokens": ["tests", "unittest_modutils", "py", "def", "_get_file_from_object", "obj", "str", "return", "modutils", "_path_from_filename", "obj", "__file__"], "doc_len": 12}
{"doc_id": "tests/unittest_modutils.py::ModuleFileTest.tearDown", "file_path": "tests/unittest_modutils.py", "class_name": "ModuleFileTest", "func_name": "tearDown", "text": "文件路径: tests/unittest_modutils.py, 类名: ModuleFileTest\n    def tearDown(self) -> None:\n        for k in list(sys.path_importer_cache):\n            if \"MyPyPa\" in k:\n                del sys.path_importer_cache[k]\n", "tokens": ["tests", "unittest_modutils", "py", "modulefiletest", "def", "teardown", "self", "none", "for", "k", "in", "list", "sys", "path_importer_cache", "if", "mypypa", "in", "k", "del", "sys", "path_importer_cache", "k"], "doc_len": 22}
{"doc_id": "tests/unittest_modutils.py::ModuleFileTest.test_find_zipped_module", "file_path": "tests/unittest_modutils.py", "class_name": "ModuleFileTest", "func_name": "test_find_zipped_module", "text": "文件路径: tests/unittest_modutils.py, 类名: ModuleFileTest\n    def test_find_zipped_module(self) -> None:\n        found_spec = spec.find_spec(\n            [self.package], [resources.find(\"data/MyPyPa-0.1.0-py2.5.zip\")]\n        )\n        self.assertEqual(found_spec.type, spec.ModuleType.PY_ZIPMODULE)\n        self.assertEqual(\n            found_spec.location.split(os.sep)[-3:],\n            [\"data\", \"MyPyPa-0.1.0-py2.5.zip\", self.package],\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "modulefiletest", "def", "test_find_zipped_module", "self", "none", "found_spec", "spec", "find_spec", "self", "package", "resources", "find", "data", "mypypa", "0", "1", "0", "py2", "5", "zip", "self", "assertequal", "found_spec", "type", "spec", "moduletype", "py_zipmodule", "self", "assertequal", "found_spec", "location", "split", "os", "sep", "3", "data", "mypypa", "0", "1", "0", "py2", "5", "zip", "self", "package"], "doc_len": 48}
{"doc_id": "tests/unittest_modutils.py::ModuleFileTest.test_find_egg_module", "file_path": "tests/unittest_modutils.py", "class_name": "ModuleFileTest", "func_name": "test_find_egg_module", "text": "文件路径: tests/unittest_modutils.py, 类名: ModuleFileTest\n    def test_find_egg_module(self) -> None:\n        found_spec = spec.find_spec(\n            [self.package], [resources.find(\"data/MyPyPa-0.1.0-py2.5.egg\")]\n        )\n        self.assertEqual(found_spec.type, spec.ModuleType.PY_ZIPMODULE)\n        self.assertEqual(\n            found_spec.location.split(os.sep)[-3:],\n            [\"data\", \"MyPyPa-0.1.0-py2.5.egg\", self.package],\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "modulefiletest", "def", "test_find_egg_module", "self", "none", "found_spec", "spec", "find_spec", "self", "package", "resources", "find", "data", "mypypa", "0", "1", "0", "py2", "5", "egg", "self", "assertequal", "found_spec", "type", "spec", "moduletype", "py_zipmodule", "self", "assertequal", "found_spec", "location", "split", "os", "sep", "3", "data", "mypypa", "0", "1", "0", "py2", "5", "egg", "self", "package"], "doc_len": 48}
{"doc_id": "tests/unittest_modutils.py::LoadModuleFromNameTest.test_known_values_load_module_from_name_1", "file_path": "tests/unittest_modutils.py", "class_name": "LoadModuleFromNameTest", "func_name": "test_known_values_load_module_from_name_1", "text": "文件路径: tests/unittest_modutils.py, 类名: LoadModuleFromNameTest\n    def test_known_values_load_module_from_name_1(self) -> None:\n        self.assertEqual(modutils.load_module_from_name(\"sys\"), sys)\n", "tokens": ["tests", "unittest_modutils", "py", "loadmodulefromnametest", "def", "test_known_values_load_module_from_name_1", "self", "none", "self", "assertequal", "modutils", "load_module_from_name", "sys", "sys"], "doc_len": 14}
{"doc_id": "tests/unittest_modutils.py::LoadModuleFromNameTest.test_known_values_load_module_from_name_2", "file_path": "tests/unittest_modutils.py", "class_name": "LoadModuleFromNameTest", "func_name": "test_known_values_load_module_from_name_2", "text": "文件路径: tests/unittest_modutils.py, 类名: LoadModuleFromNameTest\n    def test_known_values_load_module_from_name_2(self) -> None:\n        self.assertEqual(modutils.load_module_from_name(\"os.path\"), os.path)\n", "tokens": ["tests", "unittest_modutils", "py", "loadmodulefromnametest", "def", "test_known_values_load_module_from_name_2", "self", "none", "self", "assertequal", "modutils", "load_module_from_name", "os", "path", "os", "path"], "doc_len": 16}
{"doc_id": "tests/unittest_modutils.py::LoadModuleFromNameTest.test_raise_load_module_from_name_1", "file_path": "tests/unittest_modutils.py", "class_name": "LoadModuleFromNameTest", "func_name": "test_raise_load_module_from_name_1", "text": "文件路径: tests/unittest_modutils.py, 类名: LoadModuleFromNameTest\n    def test_raise_load_module_from_name_1(self) -> None:\n        self.assertRaises(\n            ImportError, modutils.load_module_from_name, \"_this_module_does_not_exist_\"\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "loadmodulefromnametest", "def", "test_raise_load_module_from_name_1", "self", "none", "self", "assertraises", "importerror", "modutils", "load_module_from_name", "_this_module_does_not_exist_"], "doc_len": 14}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_known_values_get_module_part_1", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_known_values_get_module_part_1", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_known_values_get_module_part_1(self) -> None:\n        self.assertEqual(\n            modutils.get_module_part(\"astroid.modutils\"), \"astroid.modutils\"\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_known_values_get_module_part_1", "self", "none", "self", "assertequal", "modutils", "get_module_part", "astroid", "modutils", "astroid", "modutils"], "doc_len": 16}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_known_values_get_module_part_2", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_known_values_get_module_part_2", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_known_values_get_module_part_2(self) -> None:\n        self.assertEqual(\n            modutils.get_module_part(\"astroid.modutils.get_module_part\"),\n            \"astroid.modutils\",\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_known_values_get_module_part_2", "self", "none", "self", "assertequal", "modutils", "get_module_part", "astroid", "modutils", "get_module_part", "astroid", "modutils"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_known_values_get_module_part_3", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_known_values_get_module_part_3", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_known_values_get_module_part_3(self) -> None:\n        \"\"\"relative import from given file\"\"\"\n        self.assertEqual(\n            modutils.get_module_part(\"nodes.node_classes.AssName\", modutils.__file__),\n            \"nodes.node_classes\",\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_known_values_get_module_part_3", "self", "none", "relative", "import", "from", "given", "file", "self", "assertequal", "modutils", "get_module_part", "nodes", "node_classes", "assname", "modutils", "__file__", "nodes", "node_classes"], "doc_len": 24}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_known_values_get_compiled_module_part", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_known_values_get_compiled_module_part", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_known_values_get_compiled_module_part(self) -> None:\n        self.assertEqual(modutils.get_module_part(\"math.log10\"), \"math\")\n        self.assertEqual(modutils.get_module_part(\"math.log10\", __file__), \"math\")\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_known_values_get_compiled_module_part", "self", "none", "self", "assertequal", "modutils", "get_module_part", "math", "log10", "math", "self", "assertequal", "modutils", "get_module_part", "math", "log10", "__file__", "math"], "doc_len": 23}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_known_values_get_builtin_module_part", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_known_values_get_builtin_module_part", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_known_values_get_builtin_module_part(self) -> None:\n        self.assertEqual(modutils.get_module_part(\"sys.path\"), \"sys\")\n        self.assertEqual(modutils.get_module_part(\"sys.path\", \"__file__\"), \"sys\")\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_known_values_get_builtin_module_part", "self", "none", "self", "assertequal", "modutils", "get_module_part", "sys", "path", "sys", "self", "assertequal", "modutils", "get_module_part", "sys", "path", "__file__", "sys"], "doc_len": 23}
{"doc_id": "tests/unittest_modutils.py::GetModulePartTest.test_get_module_part_exception", "file_path": "tests/unittest_modutils.py", "class_name": "GetModulePartTest", "func_name": "test_get_module_part_exception", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModulePartTest\n    def test_get_module_part_exception(self) -> None:\n        self.assertRaises(\n            ImportError, modutils.get_module_part, \"unknown.module\", modutils.__file__\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "getmoduleparttest", "def", "test_get_module_part_exception", "self", "none", "self", "assertraises", "importerror", "modutils", "get_module_part", "unknown", "module", "modutils", "__file__"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::ModPathFromFileTest.test_known_values_modpath_from_file_1", "file_path": "tests/unittest_modutils.py", "class_name": "ModPathFromFileTest", "func_name": "test_known_values_modpath_from_file_1", "text": "文件路径: tests/unittest_modutils.py, 类名: ModPathFromFileTest\n    def test_known_values_modpath_from_file_1(self) -> None:\n        self.assertEqual(\n            modutils.modpath_from_file(ElementTree.__file__),\n            [\"xml\", \"etree\", \"ElementTree\"],\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "modpathfromfiletest", "def", "test_known_values_modpath_from_file_1", "self", "none", "self", "assertequal", "modutils", "modpath_from_file", "elementtree", "__file__", "xml", "etree", "elementtree"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::ModPathFromFileTest.test_raise_modpath_from_file_exception", "file_path": "tests/unittest_modutils.py", "class_name": "ModPathFromFileTest", "func_name": "test_raise_modpath_from_file_exception", "text": "文件路径: tests/unittest_modutils.py, 类名: ModPathFromFileTest\n    def test_raise_modpath_from_file_exception(self) -> None:\n        self.assertRaises(Exception, modutils.modpath_from_file, \"/turlututu\")\n", "tokens": ["tests", "unittest_modutils", "py", "modpathfromfiletest", "def", "test_raise_modpath_from_file_exception", "self", "none", "self", "assertraises", "exception", "modutils", "modpath_from_file", "turlututu"], "doc_len": 14}
{"doc_id": "tests/unittest_modutils.py::ModPathFromFileTest.test_import_symlink_with_source_outside_of_path", "file_path": "tests/unittest_modutils.py", "class_name": "ModPathFromFileTest", "func_name": "test_import_symlink_with_source_outside_of_path", "text": "文件路径: tests/unittest_modutils.py, 类名: ModPathFromFileTest\n    def test_import_symlink_with_source_outside_of_path(self) -> None:\n        with tempfile.NamedTemporaryFile() as tmpfile:\n            linked_file_name = \"symlinked_file.py\"\n            try:\n                os.symlink(tmpfile.name, linked_file_name)\n                self.assertEqual(\n                    modutils.modpath_from_file(linked_file_name), [\"symlinked_file\"]\n                )\n            finally:\n                os.remove(linked_file_name)\n", "tokens": ["tests", "unittest_modutils", "py", "modpathfromfiletest", "def", "test_import_symlink_with_source_outside_of_path", "self", "none", "with", "tempfile", "namedtemporaryfile", "as", "tmpfile", "linked_file_name", "symlinked_file", "py", "try", "os", "symlink", "tmpfile", "name", "linked_file_name", "self", "assertequal", "modutils", "modpath_from_file", "linked_file_name", "symlinked_file", "finally", "os", "remove", "linked_file_name"], "doc_len": 32}
{"doc_id": "tests/unittest_modutils.py::ModPathFromFileTest.test_import_symlink_both_outside_of_path", "file_path": "tests/unittest_modutils.py", "class_name": "ModPathFromFileTest", "func_name": "test_import_symlink_both_outside_of_path", "text": "文件路径: tests/unittest_modutils.py, 类名: ModPathFromFileTest\n    def test_import_symlink_both_outside_of_path(self) -> None:\n        with tempfile.NamedTemporaryFile() as tmpfile:\n            linked_file_name = os.path.join(tempfile.gettempdir(), \"symlinked_file.py\")\n            try:\n                os.symlink(tmpfile.name, linked_file_name)\n                self.assertRaises(\n                    ImportError, modutils.modpath_from_file, linked_file_name\n                )\n            finally:\n                os.remove(linked_file_name)\n", "tokens": ["tests", "unittest_modutils", "py", "modpathfromfiletest", "def", "test_import_symlink_both_outside_of_path", "self", "none", "with", "tempfile", "namedtemporaryfile", "as", "tmpfile", "linked_file_name", "os", "path", "join", "tempfile", "gettempdir", "symlinked_file", "py", "try", "os", "symlink", "tmpfile", "name", "linked_file_name", "self", "assertraises", "importerror", "modutils", "modpath_from_file", "linked_file_name", "finally", "os", "remove", "linked_file_name"], "doc_len": 37}
{"doc_id": "tests/unittest_modutils.py::ModPathFromFileTest.test_load_from_module_symlink_on_symlinked_paths_in_syspath", "file_path": "tests/unittest_modutils.py", "class_name": "ModPathFromFileTest", "func_name": "test_load_from_module_symlink_on_symlinked_paths_in_syspath", "text": "文件路径: tests/unittest_modutils.py, 类名: ModPathFromFileTest\n    def test_load_from_module_symlink_on_symlinked_paths_in_syspath(self) -> None:\n        # constants\n        tmp = tempfile.gettempdir()\n        deployment_path = os.path.join(tmp, \"deployment\")\n        path_to_include = os.path.join(tmp, \"path_to_include\")\n        real_secret_path = os.path.join(tmp, \"secret.py\")\n        symlink_secret_path = os.path.join(path_to_include, \"secret.py\")\n\n        # setup double symlink\n        # /tmp/deployment\n        # /tmp/path_to_include (symlink to /tmp/deployment)\n        # /tmp/secret.py\n        # /tmp/deployment/secret.py (points to /tmp/secret.py)\n        try:\n            os.mkdir(deployment_path)\n            self.addCleanup(shutil.rmtree, deployment_path)\n            os.symlink(deployment_path, path_to_include)\n            self.addCleanup(os.remove, path_to_include)\n        except OSError:\n            pass\n        with open(real_secret_path, \"w\", encoding=\"utf-8\"):\n            pass\n        os.symlink(real_secret_path, symlink_secret_path)\n        self.addCleanup(os.remove, real_secret_path)\n\n        # add the symlinked path to sys.path\n        sys.path.append(path_to_include)\n        self.addCleanup(sys.path.pop)\n\n        # this should be equivalent to: import secret\n        self.assertEqual(modutils.modpath_from_file(symlink_secret_path), [\"secret\"])\n", "tokens": ["tests", "unittest_modutils", "py", "modpathfromfiletest", "def", "test_load_from_module_symlink_on_symlinked_paths_in_syspath", "self", "none", "constants", "tmp", "tempfile", "gettempdir", "deployment_path", "os", "path", "join", "tmp", "deployment", "path_to_include", "os", "path", "join", "tmp", "path_to_include", "real_secret_path", "os", "path", "join", "tmp", "secret", "py", "symlink_secret_path", "os", "path", "join", "path_to_include", "secret", "py", "setup", "double", "symlink", "tmp", "deployment", "tmp", "path_to_include", "symlink", "to", "tmp", "deployment", "tmp", "secret", "py", "tmp", "deployment", "secret", "py", "points", "to", "tmp", "secret", "py", "try", "os", "mkdir", "deployment_path", "self", "addcleanup", "shutil", "rmtree", "deployment_path", "os", "symlink", "deployment_path", "path_to_include", "self", "addcleanup", "os", "remove", "path_to_include", "except", "oserror", "pass", "with", "open", "real_secret_path", "w", "encoding", "utf", "8", "pass", "os", "symlink", "real_secret_path", "symlink_secret_path", "self", "addcleanup", "os", "remove", "real_secret_path", "add", "the", "symlinked", "path", "to", "sys", "path", "sys", "path", "append", "path_to_include", "self", "addcleanup", "sys", "path", "pop", "this", "should", "be", "equivalent", "to", "import", "secret", "self", "assertequal", "modutils", "modpath_from_file", "symlink_secret_path", "secret"], "doc_len": 128}
{"doc_id": "tests/unittest_modutils.py::LoadModuleFromPathTest.test_do_not_load_twice", "file_path": "tests/unittest_modutils.py", "class_name": "LoadModuleFromPathTest", "func_name": "test_do_not_load_twice", "text": "文件路径: tests/unittest_modutils.py, 类名: LoadModuleFromPathTest\n    def test_do_not_load_twice(self) -> None:\n        modutils.load_module_from_modpath([\"data\", \"lmfp\", \"foo\"])\n        modutils.load_module_from_modpath([\"data\", \"lmfp\"])\n        # pylint: disable=no-member; just-once is added by a test file dynamically.\n        self.assertEqual(len(sys.just_once), 1)\n        del sys.just_once\n", "tokens": ["tests", "unittest_modutils", "py", "loadmodulefrompathtest", "def", "test_do_not_load_twice", "self", "none", "modutils", "load_module_from_modpath", "data", "lmfp", "foo", "modutils", "load_module_from_modpath", "data", "lmfp", "pylint", "disable", "no", "member", "just", "once", "is", "added", "by", "a", "test", "file", "dynamically", "self", "assertequal", "len", "sys", "just_once", "1", "del", "sys", "just_once"], "doc_len": 39}
{"doc_id": "tests/unittest_modutils.py::FileFromModPathTest.test_site_packages", "file_path": "tests/unittest_modutils.py", "class_name": "FileFromModPathTest", "func_name": "test_site_packages", "text": "文件路径: tests/unittest_modutils.py, 类名: FileFromModPathTest\n    def test_site_packages(self) -> None:\n        filename = _get_file_from_object(modutils)\n        result = modutils.file_from_modpath([\"astroid\", \"modutils\"])\n        self.assertEqual(os.path.realpath(result), os.path.realpath(filename))\n", "tokens": ["tests", "unittest_modutils", "py", "filefrommodpathtest", "def", "test_site_packages", "self", "none", "filename", "_get_file_from_object", "modutils", "result", "modutils", "file_from_modpath", "astroid", "modutils", "self", "assertequal", "os", "path", "realpath", "result", "os", "path", "realpath", "filename"], "doc_len": 26}
{"doc_id": "tests/unittest_modutils.py::FileFromModPathTest.test_std_lib", "file_path": "tests/unittest_modutils.py", "class_name": "FileFromModPathTest", "func_name": "test_std_lib", "text": "文件路径: tests/unittest_modutils.py, 类名: FileFromModPathTest\n    def test_std_lib(self) -> None:\n        path = modutils.file_from_modpath([\"os\", \"path\"]).replace(\".pyc\", \".py\")\n        self.assertEqual(\n            os.path.realpath(path),\n            os.path.realpath(os.path.__file__.replace(\".pyc\", \".py\")),\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "filefrommodpathtest", "def", "test_std_lib", "self", "none", "path", "modutils", "file_from_modpath", "os", "path", "replace", "pyc", "py", "self", "assertequal", "os", "path", "realpath", "path", "os", "path", "realpath", "os", "path", "__file__", "replace", "pyc", "py"], "doc_len": 31}
{"doc_id": "tests/unittest_modutils.py::FileFromModPathTest.test_builtin", "file_path": "tests/unittest_modutils.py", "class_name": "FileFromModPathTest", "func_name": "test_builtin", "text": "文件路径: tests/unittest_modutils.py, 类名: FileFromModPathTest\n    def test_builtin(self) -> None:\n        self.assertIsNone(modutils.file_from_modpath([\"sys\"]))\n", "tokens": ["tests", "unittest_modutils", "py", "filefrommodpathtest", "def", "test_builtin", "self", "none", "self", "assertisnone", "modutils", "file_from_modpath", "sys"], "doc_len": 13}
{"doc_id": "tests/unittest_modutils.py::FileFromModPathTest.test_unexisting", "file_path": "tests/unittest_modutils.py", "class_name": "FileFromModPathTest", "func_name": "test_unexisting", "text": "文件路径: tests/unittest_modutils.py, 类名: FileFromModPathTest\n    def test_unexisting(self) -> None:\n        self.assertRaises(ImportError, modutils.file_from_modpath, [\"turlututu\"])\n", "tokens": ["tests", "unittest_modutils", "py", "filefrommodpathtest", "def", "test_unexisting", "self", "none", "self", "assertraises", "importerror", "modutils", "file_from_modpath", "turlututu"], "doc_len": 14}
{"doc_id": "tests/unittest_modutils.py::FileFromModPathTest.test_unicode_in_package_init", "file_path": "tests/unittest_modutils.py", "class_name": "FileFromModPathTest", "func_name": "test_unicode_in_package_init", "text": "文件路径: tests/unittest_modutils.py, 类名: FileFromModPathTest\n    def test_unicode_in_package_init(self) -> None:\n        # file_from_modpath should not crash when reading an __init__\n        # file with unicode characters.\n        modutils.file_from_modpath([\"data\", \"unicode_package\", \"core\"])\n", "tokens": ["tests", "unittest_modutils", "py", "filefrommodpathtest", "def", "test_unicode_in_package_init", "self", "none", "file_from_modpath", "should", "not", "crash", "when", "reading", "an", "__init__", "file", "with", "unicode", "characters", "modutils", "file_from_modpath", "data", "unicode_package", "core"], "doc_len": 25}
{"doc_id": "tests/unittest_modutils.py::GetSourceFileTest.test", "file_path": "tests/unittest_modutils.py", "class_name": "GetSourceFileTest", "func_name": "test", "text": "文件路径: tests/unittest_modutils.py, 类名: GetSourceFileTest\n    def test(self) -> None:\n        filename = _get_file_from_object(os.path)\n        self.assertEqual(\n            modutils.get_source_file(os.path.__file__), os.path.normpath(filename)\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "getsourcefiletest", "def", "test", "self", "none", "filename", "_get_file_from_object", "os", "path", "self", "assertequal", "modutils", "get_source_file", "os", "path", "__file__", "os", "path", "normpath", "filename"], "doc_len": 23}
{"doc_id": "tests/unittest_modutils.py::GetSourceFileTest.test_raise", "file_path": "tests/unittest_modutils.py", "class_name": "GetSourceFileTest", "func_name": "test_raise", "text": "文件路径: tests/unittest_modutils.py, 类名: GetSourceFileTest\n    def test_raise(self) -> None:\n        self.assertRaises(modutils.NoSourceFile, modutils.get_source_file, \"whatever\")\n", "tokens": ["tests", "unittest_modutils", "py", "getsourcefiletest", "def", "test_raise", "self", "none", "self", "assertraises", "modutils", "nosourcefile", "modutils", "get_source_file", "whatever"], "doc_len": 15}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_datetime", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_datetime", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_datetime(self) -> None:\n        # This is an interesting example, since datetime, on pypy,\n        # is under lib_pypy, rather than the usual Lib directory.\n        self.assertTrue(modutils.is_standard_module(\"datetime\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_datetime", "self", "none", "this", "is", "an", "interesting", "example", "since", "datetime", "on", "pypy", "is", "under", "lib_pypy", "rather", "than", "the", "usual", "lib", "directory", "self", "asserttrue", "modutils", "is_standard_module", "datetime"], "doc_len": 31}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_builtins", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_builtins", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_builtins(self) -> None:\n        self.assertFalse(modutils.is_standard_module(\"__builtin__\"))\n        self.assertTrue(modutils.is_standard_module(\"builtins\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_builtins", "self", "none", "self", "assertfalse", "modutils", "is_standard_module", "__builtin__", "self", "asserttrue", "modutils", "is_standard_module", "builtins"], "doc_len": 18}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_builtin", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_builtin", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_builtin(self) -> None:\n        self.assertTrue(modutils.is_standard_module(\"sys\"))\n        self.assertTrue(modutils.is_standard_module(\"marshal\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_builtin", "self", "none", "self", "asserttrue", "modutils", "is_standard_module", "sys", "self", "asserttrue", "modutils", "is_standard_module", "marshal"], "doc_len": 18}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_nonstandard", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_nonstandard", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_nonstandard(self) -> None:\n        self.assertFalse(modutils.is_standard_module(\"astroid\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_nonstandard", "self", "none", "self", "assertfalse", "modutils", "is_standard_module", "astroid"], "doc_len": 13}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_unknown", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_unknown", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_unknown(self) -> None:\n        self.assertFalse(modutils.is_standard_module(\"unknown\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_unknown", "self", "none", "self", "assertfalse", "modutils", "is_standard_module", "unknown"], "doc_len": 13}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_4", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_4", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_4(self) -> None:\n        self.assertTrue(modutils.is_standard_module(\"hashlib\"))\n        self.assertTrue(modutils.is_standard_module(\"pickle\"))\n        self.assertTrue(modutils.is_standard_module(\"email\"))\n        self.assertTrue(modutils.is_standard_module(\"io\"))\n        self.assertFalse(modutils.is_standard_module(\"StringIO\"))\n        self.assertTrue(modutils.is_standard_module(\"unicodedata\"))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_4", "self", "none", "self", "asserttrue", "modutils", "is_standard_module", "hashlib", "self", "asserttrue", "modutils", "is_standard_module", "pickle", "self", "asserttrue", "modutils", "is_standard_module", "email", "self", "asserttrue", "modutils", "is_standard_module", "io", "self", "assertfalse", "modutils", "is_standard_module", "stringio", "self", "asserttrue", "modutils", "is_standard_module", "unicodedata"], "doc_len": 38}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_custom_path", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_custom_path", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_custom_path(self) -> None:\n        datadir = resources.find(\"\")\n        if any(datadir.startswith(p) for p in modutils.EXT_LIB_DIRS):\n            self.skipTest(\"known breakage of is_standard_module on installed package\")\n\n        self.assertTrue(modutils.is_standard_module(\"data.module\", (datadir,)))\n        self.assertTrue(\n            modutils.is_standard_module(\"data.module\", (os.path.abspath(datadir),))\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_custom_path", "self", "none", "datadir", "resources", "find", "if", "any", "datadir", "startswith", "p", "for", "p", "in", "modutils", "ext_lib_dirs", "self", "skiptest", "known", "breakage", "of", "is_standard_module", "on", "installed", "package", "self", "asserttrue", "modutils", "is_standard_module", "data", "module", "datadir", "self", "asserttrue", "modutils", "is_standard_module", "data", "module", "os", "path", "abspath", "datadir"], "doc_len": 47}
{"doc_id": "tests/unittest_modutils.py::StandardLibModuleTest.test_failing_edge_cases", "file_path": "tests/unittest_modutils.py", "class_name": "StandardLibModuleTest", "func_name": "test_failing_edge_cases", "text": "文件路径: tests/unittest_modutils.py, 类名: StandardLibModuleTest\n    def test_failing_edge_cases(self) -> None:\n        # using a subpackage/submodule path as std_path argument\n        self.assertFalse(modutils.is_standard_module(\"xml.etree\", etree.__path__))\n        # using a module + object name as modname argument\n        self.assertTrue(modutils.is_standard_module(\"sys.path\"))\n        # this is because only the first package/module is considered\n        self.assertTrue(modutils.is_standard_module(\"sys.whatever\"))\n        self.assertFalse(modutils.is_standard_module(\"xml.whatever\", etree.__path__))\n", "tokens": ["tests", "unittest_modutils", "py", "standardlibmoduletest", "def", "test_failing_edge_cases", "self", "none", "using", "a", "subpackage", "submodule", "path", "as", "std_path", "argument", "self", "assertfalse", "modutils", "is_standard_module", "xml", "etree", "etree", "__path__", "using", "a", "module", "object", "name", "as", "modname", "argument", "self", "asserttrue", "modutils", "is_standard_module", "sys", "path", "this", "is", "because", "only", "the", "first", "package", "module", "is", "considered", "self", "asserttrue", "modutils", "is_standard_module", "sys", "whatever", "self", "assertfalse", "modutils", "is_standard_module", "xml", "whatever", "etree", "__path__"], "doc_len": 62}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_known_values_is_relative_1", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_known_values_is_relative_1", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_known_values_is_relative_1(self) -> None:\n        self.assertTrue(modutils.is_relative(\"utils\", email.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_known_values_is_relative_1", "self", "none", "self", "asserttrue", "modutils", "is_relative", "utils", "email", "__path__", "0"], "doc_len": 16}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_known_values_is_relative_3", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_known_values_is_relative_3", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_known_values_is_relative_3(self) -> None:\n        self.assertFalse(modutils.is_relative(\"astroid\", astroid.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_known_values_is_relative_3", "self", "none", "self", "assertfalse", "modutils", "is_relative", "astroid", "astroid", "__path__", "0"], "doc_len": 16}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_known_values_is_relative_4", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_known_values_is_relative_4", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_known_values_is_relative_4(self) -> None:\n        self.assertTrue(\n            modutils.is_relative(\"util\", astroid.interpreter._import.spec.__file__)\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_known_values_is_relative_4", "self", "none", "self", "asserttrue", "modutils", "is_relative", "util", "astroid", "interpreter", "_import", "spec", "__file__"], "doc_len": 18}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_known_values_is_relative_5", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_known_values_is_relative_5", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_known_values_is_relative_5(self) -> None:\n        self.assertFalse(\n            modutils.is_relative(\n                \"objectmodel\", astroid.interpreter._import.spec.__file__\n            )\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_known_values_is_relative_5", "self", "none", "self", "assertfalse", "modutils", "is_relative", "objectmodel", "astroid", "interpreter", "_import", "spec", "__file__"], "doc_len": 18}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_deep_relative", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_deep_relative", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_deep_relative(self) -> None:\n        self.assertTrue(modutils.is_relative(\"ElementTree\", xml.etree.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_deep_relative", "self", "none", "self", "asserttrue", "modutils", "is_relative", "elementtree", "xml", "etree", "__path__", "0"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_deep_relative2", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_deep_relative2", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_deep_relative2(self) -> None:\n        self.assertFalse(modutils.is_relative(\"ElementTree\", xml.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_deep_relative2", "self", "none", "self", "assertfalse", "modutils", "is_relative", "elementtree", "xml", "__path__", "0"], "doc_len": 16}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_deep_relative3", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_deep_relative3", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_deep_relative3(self) -> None:\n        self.assertTrue(modutils.is_relative(\"etree.ElementTree\", xml.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_deep_relative3", "self", "none", "self", "asserttrue", "modutils", "is_relative", "etree", "elementtree", "xml", "__path__", "0"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_deep_relative4", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_deep_relative4", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_deep_relative4(self) -> None:\n        self.assertTrue(modutils.is_relative(\"etree.gibberish\", xml.__path__[0]))\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_deep_relative4", "self", "none", "self", "asserttrue", "modutils", "is_relative", "etree", "gibberish", "xml", "__path__", "0"], "doc_len": 17}
{"doc_id": "tests/unittest_modutils.py::IsRelativeTest.test_is_relative_bad_path", "file_path": "tests/unittest_modutils.py", "class_name": "IsRelativeTest", "func_name": "test_is_relative_bad_path", "text": "文件路径: tests/unittest_modutils.py, 类名: IsRelativeTest\n    def test_is_relative_bad_path(self) -> None:\n        self.assertFalse(\n            modutils.is_relative(\"ElementTree\", os.path.join(xml.__path__[0], \"ftree\"))\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "isrelativetest", "def", "test_is_relative_bad_path", "self", "none", "self", "assertfalse", "modutils", "is_relative", "elementtree", "os", "path", "join", "xml", "__path__", "0", "ftree"], "doc_len": 20}
{"doc_id": "tests/unittest_modutils.py::GetModuleFilesTest.test_get_module_files_1", "file_path": "tests/unittest_modutils.py", "class_name": "GetModuleFilesTest", "func_name": "test_get_module_files_1", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModuleFilesTest\n    def test_get_module_files_1(self) -> None:\n        package = resources.find(\"data/find_test\")\n        modules = set(modutils.get_module_files(package, []))\n        expected = [\n            \"__init__.py\",\n            \"module.py\",\n            \"module2.py\",\n            \"noendingnewline.py\",\n            \"nonregr.py\",\n        ]\n        self.assertEqual(modules, {os.path.join(package, x) for x in expected})\n", "tokens": ["tests", "unittest_modutils", "py", "getmodulefilestest", "def", "test_get_module_files_1", "self", "none", "package", "resources", "find", "data", "find_test", "modules", "set", "modutils", "get_module_files", "package", "expected", "__init__", "py", "module", "py", "module2", "py", "noendingnewline", "py", "nonregr", "py", "self", "assertequal", "modules", "os", "path", "join", "package", "x", "for", "x", "in", "expected"], "doc_len": 41}
{"doc_id": "tests/unittest_modutils.py::GetModuleFilesTest.test_get_all_files", "file_path": "tests/unittest_modutils.py", "class_name": "GetModuleFilesTest", "func_name": "test_get_all_files", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModuleFilesTest\n    def test_get_all_files(self) -> None:\n        \"\"\"test that list_all returns all Python files from given location\"\"\"\n        non_package = resources.find(\"data/notamodule\")\n        modules = modutils.get_module_files(non_package, [], list_all=True)\n        self.assertEqual(modules, [os.path.join(non_package, \"file.py\")])\n", "tokens": ["tests", "unittest_modutils", "py", "getmodulefilestest", "def", "test_get_all_files", "self", "none", "test", "that", "list_all", "returns", "all", "python", "files", "from", "given", "location", "non_package", "resources", "find", "data", "notamodule", "modules", "modutils", "get_module_files", "non_package", "list_all", "true", "self", "assertequal", "modules", "os", "path", "join", "non_package", "file", "py"], "doc_len": 38}
{"doc_id": "tests/unittest_modutils.py::GetModuleFilesTest.test_load_module_set_attribute", "file_path": "tests/unittest_modutils.py", "class_name": "GetModuleFilesTest", "func_name": "test_load_module_set_attribute", "text": "文件路径: tests/unittest_modutils.py, 类名: GetModuleFilesTest\n    def test_load_module_set_attribute(self) -> None:\n        del xml.etree.ElementTree\n        del sys.modules[\"xml.etree.ElementTree\"]\n        m = modutils.load_module_from_modpath([\"xml\", \"etree\", \"ElementTree\"])\n        self.assertTrue(hasattr(xml, \"etree\"))\n        self.assertTrue(hasattr(xml.etree, \"ElementTree\"))\n        self.assertTrue(m is xml.etree.ElementTree)\n", "tokens": ["tests", "unittest_modutils", "py", "getmodulefilestest", "def", "test_load_module_set_attribute", "self", "none", "del", "xml", "etree", "elementtree", "del", "sys", "modules", "xml", "etree", "elementtree", "m", "modutils", "load_module_from_modpath", "xml", "etree", "elementtree", "self", "asserttrue", "hasattr", "xml", "etree", "self", "asserttrue", "hasattr", "xml", "etree", "elementtree", "self", "asserttrue", "m", "is", "xml", "etree", "elementtree"], "doc_len": 42}
{"doc_id": "tests/unittest_modutils.py::ExtensionPackageWhitelistTest.test_is_module_name_part_of_extension_package_whitelist_true", "file_path": "tests/unittest_modutils.py", "class_name": "ExtensionPackageWhitelistTest", "func_name": "test_is_module_name_part_of_extension_package_whitelist_true", "text": "文件路径: tests/unittest_modutils.py, 类名: ExtensionPackageWhitelistTest\n    def test_is_module_name_part_of_extension_package_whitelist_true(self) -> None:\n        \"\"\"Test that the is_module_name_part_of_extension_package_whitelist function returns True when needed\"\"\"\n        self.assertTrue(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"numpy\", {\"numpy\"}\n            )\n        )\n        self.assertTrue(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"numpy.core\", {\"numpy\"}\n            )\n        )\n        self.assertTrue(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"numpy.core.umath\", {\"numpy\"}\n            )\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "extensionpackagewhitelisttest", "def", "test_is_module_name_part_of_extension_package_whitelist_true", "self", "none", "test", "that", "the", "is_module_name_part_of_extension_package_whitelist", "function", "returns", "true", "when", "needed", "self", "asserttrue", "modutils", "is_module_name_part_of_extension_package_whitelist", "numpy", "numpy", "self", "asserttrue", "modutils", "is_module_name_part_of_extension_package_whitelist", "numpy", "core", "numpy", "self", "asserttrue", "modutils", "is_module_name_part_of_extension_package_whitelist", "numpy", "core", "umath", "numpy"], "doc_len": 38}
{"doc_id": "tests/unittest_modutils.py::ExtensionPackageWhitelistTest.test_is_module_name_part_of_extension_package_whitelist_success", "file_path": "tests/unittest_modutils.py", "class_name": "ExtensionPackageWhitelistTest", "func_name": "test_is_module_name_part_of_extension_package_whitelist_success", "text": "文件路径: tests/unittest_modutils.py, 类名: ExtensionPackageWhitelistTest\n    def test_is_module_name_part_of_extension_package_whitelist_success(self) -> None:\n        \"\"\"Test that the is_module_name_part_of_extension_package_whitelist function returns False when needed\"\"\"\n        self.assertFalse(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"numpy\", {\"numpy.core\"}\n            )\n        )\n        self.assertFalse(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"numpy.core\", {\"numpy.core.umath\"}\n            )\n        )\n        self.assertFalse(\n            modutils.is_module_name_part_of_extension_package_whitelist(\n                \"core.umath\", {\"numpy\"}\n            )\n        )\n", "tokens": ["tests", "unittest_modutils", "py", "extensionpackagewhitelisttest", "def", "test_is_module_name_part_of_extension_package_whitelist_success", "self", "none", "test", "that", "the", "is_module_name_part_of_extension_package_whitelist", "function", "returns", "false", "when", "needed", "self", "assertfalse", "modutils", "is_module_name_part_of_extension_package_whitelist", "numpy", "numpy", "core", "self", "assertfalse", "modutils", "is_module_name_part_of_extension_package_whitelist", "numpy", "core", "numpy", "core", "umath", "self", "assertfalse", "modutils", "is_module_name_part_of_extension_package_whitelist", "core", "umath", "numpy"], "doc_len": 40}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_tuple_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_tuple_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_tuple_as_string(self) -> None:\n        def build(string: str) -> Tuple:\n            return abuilder.string_build(string).body[0].value\n\n        self.assertEqual(build(\"1,\").as_string(), \"(1, )\")\n        self.assertEqual(build(\"1, 2, 3\").as_string(), \"(1, 2, 3)\")\n        self.assertEqual(build(\"(1, )\").as_string(), \"(1, )\")\n        self.assertEqual(build(\"1, 2, 3\").as_string(), \"(1, 2, 3)\")\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_tuple_as_string", "self", "none", "def", "build", "string", "str", "tuple", "return", "abuilder", "string_build", "string", "body", "0", "value", "self", "assertequal", "build", "1", "as_string", "1", "self", "assertequal", "build", "1", "2", "3", "as_string", "1", "2", "3", "self", "assertequal", "build", "1", "as_string", "1", "self", "assertequal", "build", "1", "2", "3", "as_string", "1", "2", "3"], "doc_len": 52}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_func_signature_issue_185", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_func_signature_issue_185", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_func_signature_issue_185(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        def test(a, b, c=42, *, x=42, **kwargs):\n            print(a, b, c, args)\n        \"\"\"\n        )\n        node = parse(code)\n        self.assertEqual(node.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_func_signature_issue_185", "self", "none", "code", "textwrap", "dedent", "def", "test", "a", "b", "c", "42", "x", "42", "kwargs", "print", "a", "b", "c", "args", "node", "parse", "code", "self", "assertequal", "node", "as_string", "strip", "code", "strip"], "doc_len": 35}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_as_string_for_list_containing_uninferable", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_as_string_for_list_containing_uninferable", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_as_string_for_list_containing_uninferable(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        def foo():\n            bar = [arg] * 1\n        \"\"\"\n        )\n        binop = node.body[0].value\n        inferred = next(binop.infer())\n        self.assertEqual(inferred.as_string(), \"[Uninferable]\")\n        self.assertEqual(binop.as_string(), \"[arg] * 1\")\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_as_string_for_list_containing_uninferable", "self", "none", "node", "builder", "extract_node", "def", "foo", "bar", "arg", "1", "binop", "node", "body", "0", "value", "inferred", "next", "binop", "infer", "self", "assertequal", "inferred", "as_string", "uninferable", "self", "assertequal", "binop", "as_string", "arg", "1"], "doc_len": 36}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_frozenset_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_frozenset_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_frozenset_as_string(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        frozenset((1, 2, 3)) #@\n        frozenset({1, 2, 3}) #@\n        frozenset([1, 2, 3,]) #@\n\n        frozenset(None) #@\n        frozenset(1) #@\n        \"\"\"\n        )\n        ast_nodes = [next(node.infer()) for node in ast_nodes]\n        assert isinstance(ast_nodes, list)\n        self.assertEqual(ast_nodes[0].as_string(), \"frozenset((1, 2, 3))\")\n        self.assertEqual(ast_nodes[1].as_string(), \"frozenset({1, 2, 3})\")\n        self.assertEqual(ast_nodes[2].as_string(), \"frozenset([1, 2, 3])\")\n\n        self.assertNotEqual(ast_nodes[3].as_string(), \"frozenset(None)\")\n        self.assertNotEqual(ast_nodes[4].as_string(), \"frozenset(1)\")\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_frozenset_as_string", "self", "none", "ast_nodes", "builder", "extract_node", "frozenset", "1", "2", "3", "frozenset", "1", "2", "3", "frozenset", "1", "2", "3", "frozenset", "none", "frozenset", "1", "ast_nodes", "next", "node", "infer", "for", "node", "in", "ast_nodes", "assert", "isinstance", "ast_nodes", "list", "self", "assertequal", "ast_nodes", "0", "as_string", "frozenset", "1", "2", "3", "self", "assertequal", "ast_nodes", "1", "as_string", "frozenset", "1", "2", "3", "self", "assertequal", "ast_nodes", "2", "as_string", "frozenset", "1", "2", "3", "self", "assertnotequal", "ast_nodes", "3", "as_string", "frozenset", "none", "self", "assertnotequal", "ast_nodes", "4", "as_string", "frozenset", "1"], "doc_len": 80}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_varargs_kwargs_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_varargs_kwargs_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_varargs_kwargs_as_string(self) -> None:\n        ast = abuilder.string_build(\"raise_string(*args, **kwargs)\").body[0]\n        self.assertEqual(ast.as_string(), \"raise_string(*args, **kwargs)\")\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_varargs_kwargs_as_string", "self", "none", "ast", "abuilder", "string_build", "raise_string", "args", "kwargs", "body", "0", "self", "assertequal", "ast", "as_string", "raise_string", "args", "kwargs"], "doc_len": 23}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_module_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_module_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_module_as_string(self) -> None:\n        \"\"\"check as_string on a whole module prepared to be returned identically\"\"\"\n        module = resources.build_file(\"data/module.py\", \"data.module\")\n        with open(resources.find(\"data/module.py\"), encoding=\"utf-8\") as fobj:\n            self.assertMultiLineEqual(module.as_string(), fobj.read())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_module_as_string", "self", "none", "check", "as_string", "on", "a", "whole", "module", "prepared", "to", "be", "returned", "identically", "module", "resources", "build_file", "data", "module", "py", "data", "module", "with", "open", "resources", "find", "data", "module", "py", "encoding", "utf", "8", "as", "fobj", "self", "assertmultilineequal", "module", "as_string", "fobj", "read"], "doc_len": 45}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_module2_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_module2_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_module2_as_string(self) -> None:\n        \"\"\"check as_string on a whole module prepared to be returned identically\"\"\"\n        module2 = resources.build_file(\"data/module2.py\", \"data.module2\")\n        with open(resources.find(\"data/module2.py\"), encoding=\"utf-8\") as fobj:\n            self.assertMultiLineEqual(module2.as_string(), fobj.read())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_module2_as_string", "self", "none", "check", "as_string", "on", "a", "whole", "module", "prepared", "to", "be", "returned", "identically", "module2", "resources", "build_file", "data", "module2", "py", "data", "module2", "with", "open", "resources", "find", "data", "module2", "py", "encoding", "utf", "8", "as", "fobj", "self", "assertmultilineequal", "module2", "as_string", "fobj", "read"], "doc_len": 45}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_as_string(self) -> None:\n        \"\"\"check as_string for python syntax >= 2.7\"\"\"\n        code = \"\"\"one_two = {1, 2}\nb = {v: k for (k, v) in enumerate('string')}\ncdd = {k for k in b}\\n\\n\"\"\"\n        ast = abuilder.string_build(code)\n        self.assertMultiLineEqual(ast.as_string(), code)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_as_string", "self", "none", "check", "as_string", "for", "python", "syntax", "2", "7", "code", "one_two", "1", "2", "b", "v", "k", "for", "k", "v", "in", "enumerate", "string", "cdd", "k", "for", "k", "in", "b", "n", "n", "ast", "abuilder", "string_build", "code", "self", "assertmultilineequal", "ast", "as_string", "code"], "doc_len": 45}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_3k_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_3k_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_3k_as_string(self) -> None:\n        \"\"\"check as_string for python 3k syntax\"\"\"\n        code = \"\"\"print()\n\ndef function(var):\n    nonlocal counter\n    try:\n        hello\n    except NameError as nexc:\n        (*hell, o) = b'hello'\n        raise AttributeError from nexc\n\\n\"\"\"\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string(), code)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_3k_as_string", "self", "none", "check", "as_string", "for", "python", "3k", "syntax", "code", "print", "def", "function", "var", "nonlocal", "counter", "try", "hello", "except", "nameerror", "as", "nexc", "hell", "o", "b", "hello", "raise", "attributeerror", "from", "nexc", "n", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "code"], "doc_len": 45}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_3k_annotations_and_metaclass", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_3k_annotations_and_metaclass", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_3k_annotations_and_metaclass(self) -> None:\n        code = '''\n        def function(var: int):\n            nonlocal counter\n\n        class Language(metaclass=Natural):\n            \"\"\"natural language\"\"\"\n        '''\n\n        code_annotations = textwrap.dedent(code)\n        expected = '''\\\ndef function(var: int):\n    nonlocal counter\n\n\nclass Language(metaclass=Natural):\n    \"\"\"natural language\"\"\"'''\n        ast = abuilder.string_build(code_annotations)\n        self.assertEqual(ast.as_string().strip(), expected)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_3k_annotations_and_metaclass", "self", "none", "code", "def", "function", "var", "int", "nonlocal", "counter", "class", "language", "metaclass", "natural", "natural", "language", "code_annotations", "textwrap", "dedent", "code", "expected", "def", "function", "var", "int", "nonlocal", "counter", "class", "language", "metaclass", "natural", "natural", "language", "ast", "abuilder", "string_build", "code_annotations", "self", "assertequal", "ast", "as_string", "strip", "expected"], "doc_len": 48}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_ellipsis", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_ellipsis", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_ellipsis(self) -> None:\n        ast = abuilder.string_build(\"a[...]\").body[0]\n        self.assertEqual(ast.as_string(), \"a[...]\")\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_ellipsis", "self", "none", "ast", "abuilder", "string_build", "a", "body", "0", "self", "assertequal", "ast", "as_string", "a"], "doc_len": 19}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_slices", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_slices", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_slices(self) -> None:\n        for code in (\n            \"a[0]\",\n            \"a[1:3]\",\n            \"a[:-1:step]\",\n            \"a[:, newaxis]\",\n            \"a[newaxis, :]\",\n            \"del L[::2]\",\n            \"del A[1]\",\n            \"del Br[:]\",\n        ):\n            ast = abuilder.string_build(code).body[0]\n            self.assertEqual(ast.as_string(), code)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_slices", "self", "none", "for", "code", "in", "a", "0", "a", "1", "3", "a", "1", "step", "a", "newaxis", "a", "newaxis", "del", "l", "2", "del", "a", "1", "del", "br", "ast", "abuilder", "string_build", "code", "body", "0", "self", "assertequal", "ast", "as_string", "code"], "doc_len": 42}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_slice_and_subscripts", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_slice_and_subscripts", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_slice_and_subscripts(self) -> None:\n        code = \"\"\"a[:1] = bord[2:]\na[:1] = bord[2:]\ndel bree[3:d]\nbord[2:]\ndel av[d::f], a[df:]\na[:1] = bord[2:]\ndel SRC[::1, newaxis, 1:]\ntous[vals] = 1010\ndel thousand[key]\ndel a[::2], a[:-1:step]\ndel Fee.form[left:]\naout.vals = miles.of_stuff\ndel (ccok, (name.thing, foo.attrib.value)), Fee.form[left:]\nif all[1] == bord[0:]:\n    pass\\n\\n\"\"\"\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string(), code)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_slice_and_subscripts", "self", "none", "code", "a", "1", "bord", "2", "a", "1", "bord", "2", "del", "bree", "3", "d", "bord", "2", "del", "av", "d", "f", "a", "df", "a", "1", "bord", "2", "del", "src", "1", "newaxis", "1", "tous", "vals", "1010", "del", "thousand", "key", "del", "a", "2", "a", "1", "step", "del", "fee", "form", "left", "aout", "vals", "miles", "of_stuff", "del", "ccok", "name", "thing", "foo", "attrib", "value", "fee", "form", "left", "if", "all", "1", "bord", "0", "pass", "n", "n", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "code"], "doc_len": 85}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_int_attribute", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_int_attribute", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_int_attribute(self) -> None:\n        code = \"\"\"\nx = (-3).real\ny = (3).imag\n        \"\"\"\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_int_attribute", "self", "none", "code", "x", "3", "real", "y", "3", "imag", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "strip", "code", "strip"], "doc_len": 26}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_operator_precedence", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_operator_precedence", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_operator_precedence(self) -> None:\n        with open(resources.find(\"data/operator_precedence.py\"), encoding=\"utf-8\") as f:\n            for code in f:\n                self.check_as_string_ast_equality(code)\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_operator_precedence", "self", "none", "with", "open", "resources", "find", "data", "operator_precedence", "py", "encoding", "utf", "8", "as", "f", "for", "code", "in", "f", "self", "check_as_string_ast_equality", "code"], "doc_len": 27}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.check_as_string_ast_equality", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "check_as_string_ast_equality", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def check_as_string_ast_equality(code: str) -> None:\n        \"\"\"\n        Check that as_string produces source code with exactly the same\n        semantics as the source it was originally parsed from\n        \"\"\"\n        pre = builder.parse(code)\n        post = builder.parse(pre.as_string())\n\n        pre_repr = pre.repr_tree()\n        post_repr = post.repr_tree()\n\n        assert pre_repr == post_repr\n        assert pre.as_string().strip() == code.strip()\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "check_as_string_ast_equality", "code", "str", "none", "check", "that", "as_string", "produces", "source", "code", "with", "exactly", "the", "same", "semantics", "as", "the", "source", "it", "was", "originally", "parsed", "from", "pre", "builder", "parse", "code", "post", "builder", "parse", "pre", "as_string", "pre_repr", "pre", "repr_tree", "post_repr", "post", "repr_tree", "assert", "pre_repr", "post_repr", "assert", "pre", "as_string", "strip", "code", "strip"], "doc_len": 52}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_class_def", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_class_def", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_class_def(self) -> None:\n        code = \"\"\"\nimport abc\nfrom typing import Tuple\n\n\nclass A:\n    pass\n\n\n\nclass B(metaclass=A, x=1):\n    pass\n\n\n\nclass C(B):\n    pass\n\n\n\nclass D(metaclass=abc.ABCMeta):\n    pass\n\n\ndef func(param: Tuple):\n    pass\n\"\"\"\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_class_def", "self", "none", "code", "import", "abc", "from", "typing", "import", "tuple", "class", "a", "pass", "class", "b", "metaclass", "a", "x", "1", "pass", "class", "c", "b", "pass", "class", "d", "metaclass", "abc", "abcmeta", "pass", "def", "func", "param", "tuple", "pass", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "strip", "code", "strip"], "doc_len": 51}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_f_strings", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_f_strings", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_f_strings(self):\n        code = r'''\na = f\"{'a'}\"\nb = f'{{b}}'\nc = f\"\"\" \"{'c'}\" \"\"\"\nd = f'{d!r} {d!s} {d!a}'\ne = f'{e:.3}'\nf = f'{f:{x}.{y}}'\nn = f'\\n'\neverything = f\"\"\" \" \\' \\r \\t \\\\ {{ }} {'x' + x!r:a} {[\"'\"]!s:{a}}\"\"\"\n'''\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_f_strings", "self", "code", "r", "a", "f", "a", "b", "f", "b", "c", "f", "c", "d", "f", "d", "r", "d", "s", "d", "a", "e", "f", "e", "3", "f", "f", "f", "x", "y", "n", "f", "n", "everything", "f", "r", "t", "x", "x", "r", "a", "s", "a", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "strip", "code", "strip"], "doc_len": 59}
{"doc_id": "tests/unittest_nodes.py::AsStringTest.test_as_string_unknown", "file_path": "tests/unittest_nodes.py", "class_name": "AsStringTest", "func_name": "test_as_string_unknown", "text": "文件路径: tests/unittest_nodes.py, 类名: AsStringTest\n    def test_as_string_unknown() -> None:\n        assert nodes.Unknown().as_string() == \"Unknown.Unknown()\"\n        assert nodes.Unknown(lineno=1, col_offset=0).as_string() == \"Unknown.Unknown()\"\n", "tokens": ["tests", "unittest_nodes", "py", "asstringtest", "def", "test_as_string_unknown", "none", "assert", "nodes", "unknown", "as_string", "unknown", "unknown", "assert", "nodes", "unknown", "lineno", "1", "col_offset", "0", "as_string", "unknown", "unknown"], "doc_len": 23}
{"doc_id": "tests/unittest_nodes.py::_NodeTest.astroid", "file_path": "tests/unittest_nodes.py", "class_name": "_NodeTest", "func_name": "astroid", "text": "文件路径: tests/unittest_nodes.py, 类名: _NodeTest\n    def astroid(self) -> Module:\n        try:\n            return self.__class__.__dict__[\"CODE_Astroid\"]\n        except KeyError:\n            module = builder.parse(self.CODE)\n            self.__class__.CODE_Astroid = module\n            return module\n", "tokens": ["tests", "unittest_nodes", "py", "_nodetest", "def", "astroid", "self", "module", "try", "return", "self", "__class__", "__dict__", "code_astroid", "except", "keyerror", "module", "builder", "parse", "self", "code", "self", "__class__", "code_astroid", "module", "return", "module"], "doc_len": 27}
{"doc_id": "tests/unittest_nodes.py::IfNodeTest.test_if_elif_else_node", "file_path": "tests/unittest_nodes.py", "class_name": "IfNodeTest", "func_name": "test_if_elif_else_node", "text": "文件路径: tests/unittest_nodes.py, 类名: IfNodeTest\n    def test_if_elif_else_node(self) -> None:\n        \"\"\"test transformation for If node\"\"\"\n        self.assertEqual(len(self.astroid.body), 4)\n        for stmt in self.astroid.body:\n            self.assertIsInstance(stmt, nodes.If)\n        self.assertFalse(self.astroid.body[0].orelse)  # simple If\n        self.assertIsInstance(self.astroid.body[1].orelse[0], nodes.Pass)  # If / else\n        self.assertIsInstance(self.astroid.body[2].orelse[0], nodes.If)  # If / elif\n        self.assertIsInstance(self.astroid.body[3].orelse[0].orelse[0], nodes.If)\n", "tokens": ["tests", "unittest_nodes", "py", "ifnodetest", "def", "test_if_elif_else_node", "self", "none", "test", "transformation", "for", "if", "node", "self", "assertequal", "len", "self", "astroid", "body", "4", "for", "stmt", "in", "self", "astroid", "body", "self", "assertisinstance", "stmt", "nodes", "if", "self", "assertfalse", "self", "astroid", "body", "0", "orelse", "simple", "if", "self", "assertisinstance", "self", "astroid", "body", "1", "orelse", "0", "nodes", "pass", "if", "else", "self", "assertisinstance", "self", "astroid", "body", "2", "orelse", "0", "nodes", "if", "if", "elif", "self", "assertisinstance", "self", "astroid", "body", "3", "orelse", "0", "orelse", "0", "nodes", "if"], "doc_len": 76}
{"doc_id": "tests/unittest_nodes.py::IfNodeTest.test_block_range", "file_path": "tests/unittest_nodes.py", "class_name": "IfNodeTest", "func_name": "test_block_range", "text": "文件路径: tests/unittest_nodes.py, 类名: IfNodeTest\n    def test_block_range(self) -> None:\n        # XXX ensure expected values\n        self.assertEqual(self.astroid.block_range(1), (0, 22))\n        self.assertEqual(self.astroid.block_range(10), (0, 22))  # XXX (10, 22) ?\n        self.assertEqual(self.astroid.body[1].block_range(5), (5, 6))\n        self.assertEqual(self.astroid.body[1].block_range(6), (6, 6))\n        self.assertEqual(self.astroid.body[1].orelse[0].block_range(7), (7, 8))\n        self.assertEqual(self.astroid.body[1].orelse[0].block_range(8), (8, 8))\n", "tokens": ["tests", "unittest_nodes", "py", "ifnodetest", "def", "test_block_range", "self", "none", "xxx", "ensure", "expected", "values", "self", "assertequal", "self", "astroid", "block_range", "1", "0", "22", "self", "assertequal", "self", "astroid", "block_range", "10", "0", "22", "xxx", "10", "22", "self", "assertequal", "self", "astroid", "body", "1", "block_range", "5", "5", "6", "self", "assertequal", "self", "astroid", "body", "1", "block_range", "6", "6", "6", "self", "assertequal", "self", "astroid", "body", "1", "orelse", "0", "block_range", "7", "7", "8", "self", "assertequal", "self", "astroid", "body", "1", "orelse", "0", "block_range", "8", "8", "8"], "doc_len": 75}
{"doc_id": "tests/unittest_nodes.py::IfNodeTest.test_if_sys_guard", "file_path": "tests/unittest_nodes.py", "class_name": "IfNodeTest", "func_name": "test_if_sys_guard", "text": "文件路径: tests/unittest_nodes.py, 类名: IfNodeTest\n    def test_if_sys_guard() -> None:\n        code = builder.extract_node(\n            \"\"\"\n        import sys\n        if sys.version_info > (3, 8):  #@\n            pass\n\n        if sys.version_info[:2] > (3, 8):  #@\n            pass\n\n        if sys.some_other_function > (3, 8):  #@\n            pass\n        \"\"\"\n        )\n        assert isinstance(code, list) and len(code) == 3\n\n        assert isinstance(code[0], nodes.If)\n        assert code[0].is_sys_guard() is True\n        assert isinstance(code[1], nodes.If)\n        assert code[1].is_sys_guard() is True\n\n        assert isinstance(code[2], nodes.If)\n        assert code[2].is_sys_guard() is False\n", "tokens": ["tests", "unittest_nodes", "py", "ifnodetest", "def", "test_if_sys_guard", "none", "code", "builder", "extract_node", "import", "sys", "if", "sys", "version_info", "3", "8", "pass", "if", "sys", "version_info", "2", "3", "8", "pass", "if", "sys", "some_other_function", "3", "8", "pass", "assert", "isinstance", "code", "list", "and", "len", "code", "3", "assert", "isinstance", "code", "0", "nodes", "if", "assert", "code", "0", "is_sys_guard", "is", "true", "assert", "isinstance", "code", "1", "nodes", "if", "assert", "code", "1", "is_sys_guard", "is", "true", "assert", "isinstance", "code", "2", "nodes", "if", "assert", "code", "2", "is_sys_guard", "is", "false"], "doc_len": 75}
{"doc_id": "tests/unittest_nodes.py::IfNodeTest.test_if_typing_guard", "file_path": "tests/unittest_nodes.py", "class_name": "IfNodeTest", "func_name": "test_if_typing_guard", "text": "文件路径: tests/unittest_nodes.py, 类名: IfNodeTest\n    def test_if_typing_guard() -> None:\n        code = builder.extract_node(\n            \"\"\"\n        import typing\n        import typing as t\n        from typing import TYPE_CHECKING\n\n        if typing.TYPE_CHECKING:  #@\n            pass\n\n        if t.TYPE_CHECKING:  #@\n            pass\n\n        if TYPE_CHECKING:  #@\n            pass\n\n        if typing.SOME_OTHER_CONST:  #@\n            pass\n        \"\"\"\n        )\n        assert isinstance(code, list) and len(code) == 4\n\n        assert isinstance(code[0], nodes.If)\n        assert code[0].is_typing_guard() is True\n        assert isinstance(code[1], nodes.If)\n        assert code[1].is_typing_guard() is True\n        assert isinstance(code[2], nodes.If)\n        assert code[2].is_typing_guard() is True\n\n        assert isinstance(code[3], nodes.If)\n        assert code[3].is_typing_guard() is False\n", "tokens": ["tests", "unittest_nodes", "py", "ifnodetest", "def", "test_if_typing_guard", "none", "code", "builder", "extract_node", "import", "typing", "import", "typing", "as", "t", "from", "typing", "import", "type_checking", "if", "typing", "type_checking", "pass", "if", "t", "type_checking", "pass", "if", "type_checking", "pass", "if", "typing", "some_other_const", "pass", "assert", "isinstance", "code", "list", "and", "len", "code", "4", "assert", "isinstance", "code", "0", "nodes", "if", "assert", "code", "0", "is_typing_guard", "is", "true", "assert", "isinstance", "code", "1", "nodes", "if", "assert", "code", "1", "is_typing_guard", "is", "true", "assert", "isinstance", "code", "2", "nodes", "if", "assert", "code", "2", "is_typing_guard", "is", "true", "assert", "isinstance", "code", "3", "nodes", "if", "assert", "code", "3", "is_typing_guard", "is", "false"], "doc_len": 91}
{"doc_id": "tests/unittest_nodes.py::TryExceptNodeTest.test_block_range", "file_path": "tests/unittest_nodes.py", "class_name": "TryExceptNodeTest", "func_name": "test_block_range", "text": "文件路径: tests/unittest_nodes.py, 类名: TryExceptNodeTest\n    def test_block_range(self) -> None:\n        # XXX ensure expected values\n        self.assertEqual(self.astroid.body[0].block_range(1), (1, 8))\n        self.assertEqual(self.astroid.body[0].block_range(2), (2, 2))\n        self.assertEqual(self.astroid.body[0].block_range(3), (3, 8))\n        self.assertEqual(self.astroid.body[0].block_range(4), (4, 4))\n        self.assertEqual(self.astroid.body[0].block_range(5), (5, 5))\n        self.assertEqual(self.astroid.body[0].block_range(6), (6, 6))\n        self.assertEqual(self.astroid.body[0].block_range(7), (7, 7))\n        self.assertEqual(self.astroid.body[0].block_range(8), (8, 8))\n", "tokens": ["tests", "unittest_nodes", "py", "tryexceptnodetest", "def", "test_block_range", "self", "none", "xxx", "ensure", "expected", "values", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "1", "1", "8", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "2", "2", "2", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "3", "3", "8", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "4", "4", "4", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "5", "5", "5", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "6", "6", "6", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "7", "7", "7", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "8", "8", "8"], "doc_len": 92}
{"doc_id": "tests/unittest_nodes.py::TryFinallyNodeTest.test_block_range", "file_path": "tests/unittest_nodes.py", "class_name": "TryFinallyNodeTest", "func_name": "test_block_range", "text": "文件路径: tests/unittest_nodes.py, 类名: TryFinallyNodeTest\n    def test_block_range(self) -> None:\n        # XXX ensure expected values\n        self.assertEqual(self.astroid.body[0].block_range(1), (1, 4))\n        self.assertEqual(self.astroid.body[0].block_range(2), (2, 2))\n        self.assertEqual(self.astroid.body[0].block_range(3), (3, 4))\n        self.assertEqual(self.astroid.body[0].block_range(4), (4, 4))\n", "tokens": ["tests", "unittest_nodes", "py", "tryfinallynodetest", "def", "test_block_range", "self", "none", "xxx", "ensure", "expected", "values", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "1", "1", "4", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "2", "2", "2", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "3", "3", "4", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "4", "4", "4"], "doc_len": 52}
{"doc_id": "tests/unittest_nodes.py::TryExceptFinallyNodeTest.test_block_range", "file_path": "tests/unittest_nodes.py", "class_name": "TryExceptFinallyNodeTest", "func_name": "test_block_range", "text": "文件路径: tests/unittest_nodes.py, 类名: TryExceptFinallyNodeTest\n    def test_block_range(self) -> None:\n        # XXX ensure expected values\n        self.assertEqual(self.astroid.body[0].block_range(1), (1, 6))\n        self.assertEqual(self.astroid.body[0].block_range(2), (2, 2))\n        self.assertEqual(self.astroid.body[0].block_range(3), (3, 4))\n        self.assertEqual(self.astroid.body[0].block_range(4), (4, 4))\n        self.assertEqual(self.astroid.body[0].block_range(5), (5, 5))\n        self.assertEqual(self.astroid.body[0].block_range(6), (6, 6))\n", "tokens": ["tests", "unittest_nodes", "py", "tryexceptfinallynodetest", "def", "test_block_range", "self", "none", "xxx", "ensure", "expected", "values", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "1", "1", "6", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "2", "2", "2", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "3", "3", "4", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "4", "4", "4", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "5", "5", "5", "self", "assertequal", "self", "astroid", "body", "0", "block_range", "6", "6", "6"], "doc_len": 72}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.setUp", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "setUp", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def setUp(self) -> None:\n        super().setUp()\n        self.module = resources.build_file(\"data/module.py\", \"data.module\")\n        self.module2 = resources.build_file(\"data/module2.py\", \"data.module2\")\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "setup", "self", "none", "super", "setup", "self", "module", "resources", "build_file", "data", "module", "py", "data", "module", "self", "module2", "resources", "build_file", "data", "module2", "py", "data", "module2"], "doc_len": 28}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_import_self_resolve", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_import_self_resolve", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_import_self_resolve(self) -> None:\n        myos = next(self.module2.igetattr(\"myos\"))\n        self.assertTrue(isinstance(myos, nodes.Module), myos)\n        self.assertEqual(myos.name, \"os\")\n        self.assertEqual(myos.qname(), \"os\")\n        self.assertEqual(myos.pytype(), \"builtins.module\")\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_import_self_resolve", "self", "none", "myos", "next", "self", "module2", "igetattr", "myos", "self", "asserttrue", "isinstance", "myos", "nodes", "module", "myos", "self", "assertequal", "myos", "name", "os", "self", "assertequal", "myos", "qname", "os", "self", "assertequal", "myos", "pytype", "builtins", "module"], "doc_len": 37}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_from_self_resolve", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_from_self_resolve", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_from_self_resolve(self) -> None:\n        namenode = next(self.module.igetattr(\"NameNode\"))\n        self.assertTrue(isinstance(namenode, nodes.ClassDef), namenode)\n        self.assertEqual(namenode.root().name, \"astroid.nodes.node_classes\")\n        self.assertEqual(namenode.qname(), \"astroid.nodes.node_classes.Name\")\n        self.assertEqual(namenode.pytype(), \"builtins.type\")\n        abspath = next(self.module2.igetattr(\"abspath\"))\n        self.assertTrue(isinstance(abspath, nodes.FunctionDef), abspath)\n        self.assertEqual(abspath.root().name, \"os.path\")\n        self.assertEqual(abspath.pytype(), \"builtins.function\")\n        if sys.platform != \"win32\":\n            # Not sure what is causing this check to fail on Windows.\n            # For some reason the abspath() inference returns a different\n            # path than expected:\n            # AssertionError: 'os.path._abspath_fallback' != 'os.path.abspath'\n            self.assertEqual(abspath.qname(), \"os.path.abspath\")\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_from_self_resolve", "self", "none", "namenode", "next", "self", "module", "igetattr", "namenode", "self", "asserttrue", "isinstance", "namenode", "nodes", "classdef", "namenode", "self", "assertequal", "namenode", "root", "name", "astroid", "nodes", "node_classes", "self", "assertequal", "namenode", "qname", "astroid", "nodes", "node_classes", "name", "self", "assertequal", "namenode", "pytype", "builtins", "type", "abspath", "next", "self", "module2", "igetattr", "abspath", "self", "asserttrue", "isinstance", "abspath", "nodes", "functiondef", "abspath", "self", "assertequal", "abspath", "root", "name", "os", "path", "self", "assertequal", "abspath", "pytype", "builtins", "function", "if", "sys", "platform", "win32", "not", "sure", "what", "is", "causing", "this", "check", "to", "fail", "on", "windows", "for", "some", "reason", "the", "abspath", "inference", "returns", "a", "different", "path", "than", "expected", "assertionerror", "os", "path", "_abspath_fallback", "os", "path", "abspath", "self", "assertequal", "abspath", "qname", "os", "path", "abspath"], "doc_len": 110}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_real_name", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_real_name", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_real_name(self) -> None:\n        from_ = self.module[\"NameNode\"]\n        self.assertEqual(from_.real_name(\"NameNode\"), \"Name\")\n        imp_ = self.module[\"os\"]\n        self.assertEqual(imp_.real_name(\"os\"), \"os\")\n        self.assertRaises(AttributeInferenceError, imp_.real_name, \"os.path\")\n        imp_ = self.module[\"NameNode\"]\n        self.assertEqual(imp_.real_name(\"NameNode\"), \"Name\")\n        self.assertRaises(AttributeInferenceError, imp_.real_name, \"Name\")\n        imp_ = self.module2[\"YO\"]\n        self.assertEqual(imp_.real_name(\"YO\"), \"YO\")\n        self.assertRaises(AttributeInferenceError, imp_.real_name, \"data\")\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_real_name", "self", "none", "from_", "self", "module", "namenode", "self", "assertequal", "from_", "real_name", "namenode", "name", "imp_", "self", "module", "os", "self", "assertequal", "imp_", "real_name", "os", "os", "self", "assertraises", "attributeinferenceerror", "imp_", "real_name", "os", "path", "imp_", "self", "module", "namenode", "self", "assertequal", "imp_", "real_name", "namenode", "name", "self", "assertraises", "attributeinferenceerror", "imp_", "real_name", "name", "imp_", "self", "module2", "yo", "self", "assertequal", "imp_", "real_name", "yo", "yo", "self", "assertraises", "attributeinferenceerror", "imp_", "real_name", "data"], "doc_len": 67}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_as_string(self) -> None:\n        ast = self.module[\"modutils\"]\n        self.assertEqual(ast.as_string(), \"from astroid import modutils\")\n        ast = self.module[\"NameNode\"]\n        self.assertEqual(\n            ast.as_string(), \"from astroid.nodes.node_classes import Name as NameNode\"\n        )\n        ast = self.module[\"os\"]\n        self.assertEqual(ast.as_string(), \"import os.path\")\n        code = \"\"\"from . import here\nfrom .. import door\nfrom .store import bread\nfrom ..cave import wine\\n\\n\"\"\"\n        ast = abuilder.string_build(code)\n        self.assertMultiLineEqual(ast.as_string(), code)\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_as_string", "self", "none", "ast", "self", "module", "modutils", "self", "assertequal", "ast", "as_string", "from", "astroid", "import", "modutils", "ast", "self", "module", "namenode", "self", "assertequal", "ast", "as_string", "from", "astroid", "nodes", "node_classes", "import", "name", "as", "namenode", "ast", "self", "module", "os", "self", "assertequal", "ast", "as_string", "import", "os", "path", "code", "from", "import", "here", "from", "import", "door", "from", "store", "import", "bread", "from", "cave", "import", "wine", "n", "n", "ast", "abuilder", "string_build", "code", "self", "assertmultilineequal", "ast", "as_string", "code"], "doc_len": 73}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_bad_import_inference", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_bad_import_inference", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_bad_import_inference(self) -> None:\n        # Explication of bug\n        \"\"\"When we import PickleError from nonexistent, a call to the infer\n        method of this From node will be made by unpack_infer.\n        inference.infer_from will try to import this module, which will fail and\n        raise a InferenceException (by mixins.do_import_module). The infer_name\n        will catch this exception and yield and Uninferable instead.\n        \"\"\"\n\n        code = \"\"\"\n            try:\n                from pickle import PickleError\n            except ImportError:\n                from nonexistent import PickleError\n\n            try:\n                pass\n            except PickleError:\n                pass\n        \"\"\"\n        module = builder.parse(code)\n        handler_type = module.body[1].handlers[0].type\n\n        excs = list(nodes.unpack_infer(handler_type))\n        # The number of returned object can differ on Python 2\n        # and Python 3. In one version, an additional item will\n        # be returned, from the _pickle module, which is not\n        # present in the other version.\n        self.assertIsInstance(excs[0], nodes.ClassDef)\n        self.assertEqual(excs[0].name, \"PickleError\")\n        self.assertIs(excs[-1], util.Uninferable)\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_bad_import_inference", "self", "none", "explication", "of", "bug", "when", "we", "import", "pickleerror", "from", "nonexistent", "a", "call", "to", "the", "infer", "method", "of", "this", "from", "node", "will", "be", "made", "by", "unpack_infer", "inference", "infer_from", "will", "try", "to", "import", "this", "module", "which", "will", "fail", "and", "raise", "a", "inferenceexception", "by", "mixins", "do_import_module", "the", "infer_name", "will", "catch", "this", "exception", "and", "yield", "and", "uninferable", "instead", "code", "try", "from", "pickle", "import", "pickleerror", "except", "importerror", "from", "nonexistent", "import", "pickleerror", "try", "pass", "except", "pickleerror", "pass", "module", "builder", "parse", "code", "handler_type", "module", "body", "1", "handlers", "0", "type", "excs", "list", "nodes", "unpack_infer", "handler_type", "the", "number", "of", "returned", "object", "can", "differ", "on", "python", "2", "and", "python", "3", "in", "one", "version", "an", "additional", "item", "will", "be", "returned", "from", "the", "_pickle", "module", "which", "is", "not", "present", "in", "the", "other", "version", "self", "assertisinstance", "excs", "0", "nodes", "classdef", "self", "assertequal", "excs", "0", "name", "pickleerror", "self", "assertis", "excs", "1", "util", "uninferable"], "doc_len": 146}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_absolute_import", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_absolute_import", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_absolute_import(self) -> None:\n        module = resources.build_file(\"data/absimport.py\")\n        ctx = InferenceContext()\n        # will fail if absolute import failed\n        ctx.lookupname = \"message\"\n        next(module[\"message\"].infer(ctx))\n        ctx.lookupname = \"email\"\n        m = next(module[\"email\"].infer(ctx))\n        self.assertFalse(m.file.startswith(os.path.join(\"data\", \"email.py\")))\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_absolute_import", "self", "none", "module", "resources", "build_file", "data", "absimport", "py", "ctx", "inferencecontext", "will", "fail", "if", "absolute", "import", "failed", "ctx", "lookupname", "message", "next", "module", "message", "infer", "ctx", "ctx", "lookupname", "email", "m", "next", "module", "email", "infer", "ctx", "self", "assertfalse", "m", "file", "startswith", "os", "path", "join", "data", "email", "py"], "doc_len": 50}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_more_absolute_import", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_more_absolute_import", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_more_absolute_import(self) -> None:\n        module = resources.build_file(\"data/module1abs/__init__.py\", \"data.module1abs\")\n        self.assertIn(\"sys\", module.locals)\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_more_absolute_import", "self", "none", "module", "resources", "build_file", "data", "module1abs", "__init__", "py", "data", "module1abs", "self", "assertin", "sys", "module", "locals"], "doc_len": 22}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_conditional", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_conditional", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_conditional(self) -> None:\n        module = resources.build_file(\"data/conditional_import/__init__.py\")\n        ctx = InferenceContext()\n\n        for name in self._pickle_names:\n            ctx.lookupname = name\n            some = list(module[name].infer(ctx))\n            assert Uninferable not in some, name\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_conditional", "self", "none", "module", "resources", "build_file", "data", "conditional_import", "__init__", "py", "ctx", "inferencecontext", "for", "name", "in", "self", "_pickle_names", "ctx", "lookupname", "name", "some", "list", "module", "name", "infer", "ctx", "assert", "uninferable", "not", "in", "some", "name"], "doc_len": 37}
{"doc_id": "tests/unittest_nodes.py::ImportNodeTest.test_conditional_import", "file_path": "tests/unittest_nodes.py", "class_name": "ImportNodeTest", "func_name": "test_conditional_import", "text": "文件路径: tests/unittest_nodes.py, 类名: ImportNodeTest\n    def test_conditional_import(self) -> None:\n        module = resources.build_file(\"data/conditional.py\")\n        ctx = InferenceContext()\n\n        for name in self._pickle_names:\n            ctx.lookupname = name\n            some = list(module[name].infer(ctx))\n            assert Uninferable not in some, name\n", "tokens": ["tests", "unittest_nodes", "py", "importnodetest", "def", "test_conditional_import", "self", "none", "module", "resources", "build_file", "data", "conditional", "py", "ctx", "inferencecontext", "for", "name", "in", "self", "_pickle_names", "ctx", "lookupname", "name", "some", "list", "module", "name", "infer", "ctx", "assert", "uninferable", "not", "in", "some", "name"], "doc_len": 36}
{"doc_id": "tests/unittest_nodes.py::CmpNodeTest.test_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "CmpNodeTest", "func_name": "test_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: CmpNodeTest\n    def test_as_string(self) -> None:\n        ast = abuilder.string_build(\"a == 2\").body[0]\n        self.assertEqual(ast.as_string(), \"a == 2\")\n", "tokens": ["tests", "unittest_nodes", "py", "cmpnodetest", "def", "test_as_string", "self", "none", "ast", "abuilder", "string_build", "a", "2", "body", "0", "self", "assertequal", "ast", "as_string", "a", "2"], "doc_len": 21}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest._test", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "_test", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def _test(self, value: Any) -> None:\n        node = nodes.const_factory(value)\n        self.assertIsInstance(node._proxied, nodes.ClassDef)\n        self.assertEqual(node._proxied.name, value.__class__.__name__)\n        self.assertIs(node.value, value)\n        self.assertTrue(node._proxied.parent)\n        self.assertEqual(node._proxied.root().name, value.__class__.__module__)\n        with self.assertRaises(AttributeError):\n            with pytest.warns(DeprecationWarning) as records:\n                node.statement()\n                assert len(records) == 1\n        with self.assertRaises(StatementMissing):\n            node.statement(future=True)\n\n        with self.assertRaises(AttributeError):\n            with pytest.warns(DeprecationWarning) as records:\n                node.frame()\n                assert len(records) == 1\n        with self.assertRaises(ParentMissingError):\n            node.frame(future=True)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "_test", "self", "value", "any", "none", "node", "nodes", "const_factory", "value", "self", "assertisinstance", "node", "_proxied", "nodes", "classdef", "self", "assertequal", "node", "_proxied", "name", "value", "__class__", "__name__", "self", "assertis", "node", "value", "value", "self", "asserttrue", "node", "_proxied", "parent", "self", "assertequal", "node", "_proxied", "root", "name", "value", "__class__", "__module__", "with", "self", "assertraises", "attributeerror", "with", "pytest", "warns", "deprecationwarning", "as", "records", "node", "statement", "assert", "len", "records", "1", "with", "self", "assertraises", "statementmissing", "node", "statement", "future", "true", "with", "self", "assertraises", "attributeerror", "with", "pytest", "warns", "deprecationwarning", "as", "records", "node", "frame", "assert", "len", "records", "1", "with", "self", "assertraises", "parentmissingerror", "node", "frame", "future", "true"], "doc_len": 95}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_none", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_none", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_none(self) -> None:\n        self._test(None)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_none", "self", "none", "self", "_test", "none"], "doc_len": 11}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_bool", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_bool", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_bool(self) -> None:\n        self._test(True)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_bool", "self", "none", "self", "_test", "true"], "doc_len": 11}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_int", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_int", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_int(self) -> None:\n        self._test(1)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_int", "self", "none", "self", "_test", "1"], "doc_len": 11}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_float", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_float", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_float(self) -> None:\n        self._test(1.0)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_float", "self", "none", "self", "_test", "1", "0"], "doc_len": 12}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_complex", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_complex", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_complex(self) -> None:\n        self._test(1.0j)\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_complex", "self", "none", "self", "_test", "1", "0j"], "doc_len": 12}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_str", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_str", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_str(self) -> None:\n        self._test(\"a\")\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_str", "self", "none", "self", "_test", "a"], "doc_len": 11}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_unicode", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_unicode", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_unicode(self) -> None:\n        self._test(\"a\")\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_unicode", "self", "none", "self", "_test", "a"], "doc_len": 11}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_str_kind", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_str_kind", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_str_kind(self):\n        node = builder.extract_node(\n            \"\"\"\n            const = u\"foo\"\n        \"\"\"\n        )\n        assert isinstance(node.value, nodes.Const)\n        assert node.value.value == \"foo\"\n        assert node.value.kind, \"u\"\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_str_kind", "self", "node", "builder", "extract_node", "const", "u", "foo", "assert", "isinstance", "node", "value", "nodes", "const", "assert", "node", "value", "value", "foo", "assert", "node", "value", "kind", "u"], "doc_len": 29}
{"doc_id": "tests/unittest_nodes.py::ConstNodeTest.test_copy", "file_path": "tests/unittest_nodes.py", "class_name": "ConstNodeTest", "func_name": "test_copy", "text": "文件路径: tests/unittest_nodes.py, 类名: ConstNodeTest\n    def test_copy(self) -> None:\n        \"\"\"\n        Make sure copying a Const object doesn't result in infinite recursion\n        \"\"\"\n        const = copy.copy(nodes.Const(1))\n        assert const.value == 1\n", "tokens": ["tests", "unittest_nodes", "py", "constnodetest", "def", "test_copy", "self", "none", "make", "sure", "copying", "a", "const", "object", "doesn", "t", "result", "in", "infinite", "recursion", "const", "copy", "copy", "nodes", "const", "1", "assert", "const", "value", "1"], "doc_len": 30}
{"doc_id": "tests/unittest_nodes.py::NameNodeTest.test_assign_to_true", "file_path": "tests/unittest_nodes.py", "class_name": "NameNodeTest", "func_name": "test_assign_to_true", "text": "文件路径: tests/unittest_nodes.py, 类名: NameNodeTest\n    def test_assign_to_true(self) -> None:\n        \"\"\"Test that True and False assignments don't crash\"\"\"\n        code = \"\"\"\n            True = False\n            def hello(False):\n                pass\n            del True\n        \"\"\"\n        with self.assertRaises(AstroidBuildingError):\n            builder.parse(code)\n", "tokens": ["tests", "unittest_nodes", "py", "namenodetest", "def", "test_assign_to_true", "self", "none", "test", "that", "true", "and", "false", "assignments", "don", "t", "crash", "code", "true", "false", "def", "hello", "false", "pass", "del", "true", "with", "self", "assertraises", "astroidbuildingerror", "builder", "parse", "code"], "doc_len": 33}
{"doc_id": "tests/unittest_nodes.py::TestNamedExprNode.test_frame", "file_path": "tests/unittest_nodes.py", "class_name": "TestNamedExprNode", "func_name": "test_frame", "text": "文件路径: tests/unittest_nodes.py, 类名: TestNamedExprNode\n    def test_frame() -> None:\n        \"\"\"Test if the frame of NamedExpr is correctly set for certain types\n        of parent nodes.\n        \"\"\"\n        module = builder.parse(\n            \"\"\"\n            def func(var_1):\n                pass\n\n            def func_two(var_2, var_2 = (named_expr_1 := \"walrus\")):\n                pass\n\n            class MyBaseClass:\n                pass\n\n            class MyInheritedClass(MyBaseClass, var_3=(named_expr_2 := \"walrus\")):\n                pass\n\n            VAR = lambda y = (named_expr_3 := \"walrus\"): print(y)\n\n            def func_with_lambda(\n                var_5 = (\n                    named_expr_4 := lambda y = (named_expr_5 := \"walrus\"): y\n                    )\n                ):\n                pass\n\n            COMPREHENSION = [y for i in (1, 2) if (y := i ** 2)]\n        \"\"\"\n        )\n        function = module.body[0]\n        assert function.args.frame() == function\n        assert function.args.frame(future=True) == function\n\n        function_two = module.body[1]\n        assert function_two.args.args[0].frame() == function_two\n        assert function_two.args.args[0].frame(future=True) == function_two\n        assert function_two.args.args[1].frame() == function_two\n        assert function_two.args.args[1].frame(future=True) == function_two\n        assert function_two.args.defaults[0].frame() == module\n        assert function_two.args.defaults[0].frame(future=True) == module\n\n        inherited_class = module.body[3]\n        assert inherited_class.keywords[0].frame() == inherited_class\n        assert inherited_class.keywords[0].frame(future=True) == inherited_class\n        assert inherited_class.keywords[0].value.frame() == module\n        assert inherited_class.keywords[0].value.frame(future=True) == module\n\n        lambda_assignment = module.body[4].value\n        assert lambda_assignment.args.args[0].frame() == lambda_assignment\n        assert lambda_assignment.args.args[0].frame(future=True) == lambda_assignment\n        assert lambda_assignment.args.defaults[0].frame() == module\n        assert lambda_assignment.args.defaults[0].frame(future=True) == module\n\n        lambda_named_expr = module.body[5].args.defaults[0]\n        assert lambda_named_expr.value.args.defaults[0].frame() == module\n        assert lambda_named_expr.value.args.defaults[0].frame(future=True) == module\n\n        comprehension = module.body[6].value\n        assert comprehension.generators[0].ifs[0].frame() == module\n        assert comprehension.generators[0].ifs[0].frame(future=True) == module\n", "tokens": ["tests", "unittest_nodes", "py", "testnamedexprnode", "def", "test_frame", "none", "test", "if", "the", "frame", "of", "namedexpr", "is", "correctly", "set", "for", "certain", "types", "of", "parent", "nodes", "module", "builder", "parse", "def", "func", "var_1", "pass", "def", "func_two", "var_2", "var_2", "named_expr_1", "walrus", "pass", "class", "mybaseclass", "pass", "class", "myinheritedclass", "mybaseclass", "var_3", "named_expr_2", "walrus", "pass", "var", "lambda", "y", "named_expr_3", "walrus", "print", "y", "def", "func_with_lambda", "var_5", "named_expr_4", "lambda", "y", "named_expr_5", "walrus", "y", "pass", "comprehension", "y", "for", "i", "in", "1", "2", "if", "y", "i", "2", "function", "module", "body", "0", "assert", "function", "args", "frame", "function", "assert", "function", "args", "frame", "future", "true", "function", "function_two", "module", "body", "1", "assert", "function_two", "args", "args", "0", "frame", "function_two", "assert", "function_two", "args", "args", "0", "frame", "future", "true", "function_two", "assert", "function_two", "args", "args", "1", "frame", "function_two", "assert", "function_two", "args", "args", "1", "frame", "future", "true", "function_two", "assert", "function_two", "args", "defaults", "0", "frame", "module", "assert", "function_two", "args", "defaults", "0", "frame", "future", "true", "module", "inherited_class", "module", "body", "3", "assert", "inherited_class", "keywords", "0", "frame", "inherited_class", "assert", "inherited_class", "keywords", "0", "frame", "future", "true", "inherited_class", "assert", "inherited_class", "keywords", "0", "value", "frame", "module", "assert", "inherited_class", "keywords", "0", "value", "frame", "future", "true", "module", "lambda_assignment", "module", "body", "4", "value", "assert", "lambda_assignment", "args", "args", "0", "frame", "lambda_assignment", "assert", "lambda_assignment", "args", "args", "0", "frame", "future", "true", "lambda_assignment", "assert", "lambda_assignment", "args", "defaults", "0", "frame", "module", "assert", "lambda_assignment", "args", "defaults", "0", "frame", "future", "true", "module", "lambda_named_expr", "module", "body", "5", "args", "defaults", "0", "assert", "lambda_named_expr", "value", "args", "defaults", "0", "frame", "module", "assert", "lambda_named_expr", "value", "args", "defaults", "0", "frame", "future", "true", "module", "comprehension", "module", "body", "6", "value", "assert", "comprehension", "generators", "0", "ifs", "0", "frame", "module", "assert", "comprehension", "generators", "0", "ifs", "0", "frame", "future", "true", "module"], "doc_len": 261}
{"doc_id": "tests/unittest_nodes.py::TestNamedExprNode.test_scope", "file_path": "tests/unittest_nodes.py", "class_name": "TestNamedExprNode", "func_name": "test_scope", "text": "文件路径: tests/unittest_nodes.py, 类名: TestNamedExprNode\n    def test_scope() -> None:\n        \"\"\"Test if the scope of NamedExpr is correctly set for certain types\n        of parent nodes.\n        \"\"\"\n        module = builder.parse(\n            \"\"\"\n            def func(var_1):\n                pass\n\n            def func_two(var_2, var_2 = (named_expr_1 := \"walrus\")):\n                pass\n\n            class MyBaseClass:\n                pass\n\n            class MyInheritedClass(MyBaseClass, var_3=(named_expr_2 := \"walrus\")):\n                pass\n\n            VAR = lambda y = (named_expr_3 := \"walrus\"): print(y)\n\n            def func_with_lambda(\n                var_5 = (\n                    named_expr_4 := lambda y = (named_expr_5 := \"walrus\"): y\n                    )\n                ):\n                pass\n\n            COMPREHENSION = [y for i in (1, 2) if (y := i ** 2)]\n        \"\"\"\n        )\n        function = module.body[0]\n        assert function.args.scope() == function\n\n        function_two = module.body[1]\n        assert function_two.args.args[0].scope() == function_two\n        assert function_two.args.args[1].scope() == function_two\n        assert function_two.args.defaults[0].scope() == module\n\n        inherited_class = module.body[3]\n        assert inherited_class.keywords[0].scope() == inherited_class\n        assert inherited_class.keywords[0].value.scope() == module\n\n        lambda_assignment = module.body[4].value\n        assert lambda_assignment.args.args[0].scope() == lambda_assignment\n        assert lambda_assignment.args.defaults[0].scope()\n\n        lambda_named_expr = module.body[5].args.defaults[0]\n        assert lambda_named_expr.value.args.defaults[0].scope() == module\n\n        comprehension = module.body[6].value\n        assert comprehension.generators[0].ifs[0].scope() == module\n", "tokens": ["tests", "unittest_nodes", "py", "testnamedexprnode", "def", "test_scope", "none", "test", "if", "the", "scope", "of", "namedexpr", "is", "correctly", "set", "for", "certain", "types", "of", "parent", "nodes", "module", "builder", "parse", "def", "func", "var_1", "pass", "def", "func_two", "var_2", "var_2", "named_expr_1", "walrus", "pass", "class", "mybaseclass", "pass", "class", "myinheritedclass", "mybaseclass", "var_3", "named_expr_2", "walrus", "pass", "var", "lambda", "y", "named_expr_3", "walrus", "print", "y", "def", "func_with_lambda", "var_5", "named_expr_4", "lambda", "y", "named_expr_5", "walrus", "y", "pass", "comprehension", "y", "for", "i", "in", "1", "2", "if", "y", "i", "2", "function", "module", "body", "0", "assert", "function", "args", "scope", "function", "function_two", "module", "body", "1", "assert", "function_two", "args", "args", "0", "scope", "function_two", "assert", "function_two", "args", "args", "1", "scope", "function_two", "assert", "function_two", "args", "defaults", "0", "scope", "module", "inherited_class", "module", "body", "3", "assert", "inherited_class", "keywords", "0", "scope", "inherited_class", "assert", "inherited_class", "keywords", "0", "value", "scope", "module", "lambda_assignment", "module", "body", "4", "value", "assert", "lambda_assignment", "args", "args", "0", "scope", "lambda_assignment", "assert", "lambda_assignment", "args", "defaults", "0", "scope", "lambda_named_expr", "module", "body", "5", "args", "defaults", "0", "assert", "lambda_named_expr", "value", "args", "defaults", "0", "scope", "module", "comprehension", "module", "body", "6", "value", "assert", "comprehension", "generators", "0", "ifs", "0", "scope", "module"], "doc_len": 171}
{"doc_id": "tests/unittest_nodes.py::AnnAssignNodeTest.test_primitive", "file_path": "tests/unittest_nodes.py", "class_name": "AnnAssignNodeTest", "func_name": "test_primitive", "text": "文件路径: tests/unittest_nodes.py, 类名: AnnAssignNodeTest\n    def test_primitive(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n            test: int = 5\n        \"\"\"\n        )\n        assign = builder.extract_node(code)\n        self.assertIsInstance(assign, nodes.AnnAssign)\n        self.assertEqual(assign.target.name, \"test\")\n        self.assertEqual(assign.annotation.name, \"int\")\n        self.assertEqual(assign.value.value, 5)\n        self.assertEqual(assign.simple, 1)\n", "tokens": ["tests", "unittest_nodes", "py", "annassignnodetest", "def", "test_primitive", "self", "none", "code", "textwrap", "dedent", "test", "int", "5", "assign", "builder", "extract_node", "code", "self", "assertisinstance", "assign", "nodes", "annassign", "self", "assertequal", "assign", "target", "name", "test", "self", "assertequal", "assign", "annotation", "name", "int", "self", "assertequal", "assign", "value", "value", "5", "self", "assertequal", "assign", "simple", "1"], "doc_len": 46}
{"doc_id": "tests/unittest_nodes.py::AnnAssignNodeTest.test_primitive_without_initial_value", "file_path": "tests/unittest_nodes.py", "class_name": "AnnAssignNodeTest", "func_name": "test_primitive_without_initial_value", "text": "文件路径: tests/unittest_nodes.py, 类名: AnnAssignNodeTest\n    def test_primitive_without_initial_value(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n            test: str\n        \"\"\"\n        )\n        assign = builder.extract_node(code)\n        self.assertIsInstance(assign, nodes.AnnAssign)\n        self.assertEqual(assign.target.name, \"test\")\n        self.assertEqual(assign.annotation.name, \"str\")\n        self.assertEqual(assign.value, None)\n", "tokens": ["tests", "unittest_nodes", "py", "annassignnodetest", "def", "test_primitive_without_initial_value", "self", "none", "code", "textwrap", "dedent", "test", "str", "assign", "builder", "extract_node", "code", "self", "assertisinstance", "assign", "nodes", "annassign", "self", "assertequal", "assign", "target", "name", "test", "self", "assertequal", "assign", "annotation", "name", "str", "self", "assertequal", "assign", "value", "none"], "doc_len": 39}
{"doc_id": "tests/unittest_nodes.py::AnnAssignNodeTest.test_complex", "file_path": "tests/unittest_nodes.py", "class_name": "AnnAssignNodeTest", "func_name": "test_complex", "text": "文件路径: tests/unittest_nodes.py, 类名: AnnAssignNodeTest\n    def test_complex(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n            test: Dict[List[str]] = {}\n        \"\"\"\n        )\n        assign = builder.extract_node(code)\n        self.assertIsInstance(assign, nodes.AnnAssign)\n        self.assertEqual(assign.target.name, \"test\")\n        self.assertIsInstance(assign.annotation, astroid.Subscript)\n        self.assertIsInstance(assign.value, astroid.Dict)\n", "tokens": ["tests", "unittest_nodes", "py", "annassignnodetest", "def", "test_complex", "self", "none", "code", "textwrap", "dedent", "test", "dict", "list", "str", "assign", "builder", "extract_node", "code", "self", "assertisinstance", "assign", "nodes", "annassign", "self", "assertequal", "assign", "target", "name", "test", "self", "assertisinstance", "assign", "annotation", "astroid", "subscript", "self", "assertisinstance", "assign", "value", "astroid", "dict"], "doc_len": 42}
{"doc_id": "tests/unittest_nodes.py::AnnAssignNodeTest.test_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "AnnAssignNodeTest", "func_name": "test_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: AnnAssignNodeTest\n    def test_as_string(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n            print()\n            test: int = 5\n            test2: str\n            test3: List[Dict[str, str]] = []\n        \"\"\"\n        )\n        ast = abuilder.string_build(code)\n        self.assertEqual(ast.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "annassignnodetest", "def", "test_as_string", "self", "none", "code", "textwrap", "dedent", "print", "test", "int", "5", "test2", "str", "test3", "list", "dict", "str", "str", "ast", "abuilder", "string_build", "code", "self", "assertequal", "ast", "as_string", "strip", "code", "strip"], "doc_len": 33}
{"doc_id": "tests/unittest_nodes.py::ArgumentsNodeTC.test_linenumbering", "file_path": "tests/unittest_nodes.py", "class_name": "ArgumentsNodeTC", "func_name": "test_linenumbering", "text": "文件路径: tests/unittest_nodes.py, 类名: ArgumentsNodeTC\n    def test_linenumbering(self) -> None:\n        ast = builder.parse(\n            \"\"\"\n            def func(a,\n                b): pass\n            x = lambda x: None\n        \"\"\"\n        )\n        self.assertEqual(ast[\"func\"].args.fromlineno, 2)\n        self.assertFalse(ast[\"func\"].args.is_statement)\n        xlambda = next(ast[\"x\"].infer())\n        self.assertEqual(xlambda.args.fromlineno, 4)\n        self.assertEqual(xlambda.args.tolineno, 4)\n        self.assertFalse(xlambda.args.is_statement)\n", "tokens": ["tests", "unittest_nodes", "py", "argumentsnodetc", "def", "test_linenumbering", "self", "none", "ast", "builder", "parse", "def", "func", "a", "b", "pass", "x", "lambda", "x", "none", "self", "assertequal", "ast", "func", "args", "fromlineno", "2", "self", "assertfalse", "ast", "func", "args", "is_statement", "xlambda", "next", "ast", "x", "infer", "self", "assertequal", "xlambda", "args", "fromlineno", "4", "self", "assertequal", "xlambda", "args", "tolineno", "4", "self", "assertfalse", "xlambda", "args", "is_statement"], "doc_len": 55}
{"doc_id": "tests/unittest_nodes.py::ArgumentsNodeTC.test_kwoargs", "file_path": "tests/unittest_nodes.py", "class_name": "ArgumentsNodeTC", "func_name": "test_kwoargs", "text": "文件路径: tests/unittest_nodes.py, 类名: ArgumentsNodeTC\n    def test_kwoargs(self) -> None:\n        ast = builder.parse(\n            \"\"\"\n            def func(*, x):\n                pass\n        \"\"\"\n        )\n        args = ast[\"func\"].args\n        self.assertTrue(args.is_argument(\"x\"))\n", "tokens": ["tests", "unittest_nodes", "py", "argumentsnodetc", "def", "test_kwoargs", "self", "none", "ast", "builder", "parse", "def", "func", "x", "pass", "args", "ast", "func", "args", "self", "asserttrue", "args", "is_argument", "x"], "doc_len": 24}
{"doc_id": "tests/unittest_nodes.py::ArgumentsNodeTC.test_positional_only", "file_path": "tests/unittest_nodes.py", "class_name": "ArgumentsNodeTC", "func_name": "test_positional_only", "text": "文件路径: tests/unittest_nodes.py, 类名: ArgumentsNodeTC\n    def test_positional_only(self):\n        ast = builder.parse(\n            \"\"\"\n            def func(x, /, y):\n                pass\n        \"\"\"\n        )\n        args = ast[\"func\"].args\n        self.assertTrue(args.is_argument(\"x\"))\n        self.assertTrue(args.is_argument(\"y\"))\n        index, node = args.find_argname(\"x\")\n        self.assertEqual(index, 0)\n        self.assertIsNotNone(node)\n", "tokens": ["tests", "unittest_nodes", "py", "argumentsnodetc", "def", "test_positional_only", "self", "ast", "builder", "parse", "def", "func", "x", "y", "pass", "args", "ast", "func", "args", "self", "asserttrue", "args", "is_argument", "x", "self", "asserttrue", "args", "is_argument", "y", "index", "node", "args", "find_argname", "x", "self", "assertequal", "index", "0", "self", "assertisnotnone", "node"], "doc_len": 41}
{"doc_id": "tests/unittest_nodes.py::UnboundMethodNodeTest.test_no_super_getattr", "file_path": "tests/unittest_nodes.py", "class_name": "UnboundMethodNodeTest", "func_name": "test_no_super_getattr", "text": "文件路径: tests/unittest_nodes.py, 类名: UnboundMethodNodeTest\n    def test_no_super_getattr(self) -> None:\n        # This is a test for issue\n        # https://bitbucket.org/logilab/astroid/issue/91, which tests\n        # that UnboundMethod doesn't call super when doing .getattr.\n\n        ast = builder.parse(\n            \"\"\"\n        class A(object):\n            def test(self):\n                pass\n        meth = A.test\n        \"\"\"\n        )\n        node = next(ast[\"meth\"].infer())\n        with self.assertRaises(AttributeInferenceError):\n            node.getattr(\"__missssing__\")\n        name = node.getattr(\"__name__\")[0]\n        self.assertIsInstance(name, nodes.Const)\n        self.assertEqual(name.value, \"test\")\n", "tokens": ["tests", "unittest_nodes", "py", "unboundmethodnodetest", "def", "test_no_super_getattr", "self", "none", "this", "is", "a", "test", "for", "issue", "https", "bitbucket", "org", "logilab", "astroid", "issue", "91", "which", "tests", "that", "unboundmethod", "doesn", "t", "call", "super", "when", "doing", "getattr", "ast", "builder", "parse", "class", "a", "object", "def", "test", "self", "pass", "meth", "a", "test", "node", "next", "ast", "meth", "infer", "with", "self", "assertraises", "attributeinferenceerror", "node", "getattr", "__missssing__", "name", "node", "getattr", "__name__", "0", "self", "assertisinstance", "name", "nodes", "const", "self", "assertequal", "name", "value", "test"], "doc_len": 72}
{"doc_id": "tests/unittest_nodes.py::BoundMethodNodeTest.test_is_property", "file_path": "tests/unittest_nodes.py", "class_name": "BoundMethodNodeTest", "func_name": "test_is_property", "text": "文件路径: tests/unittest_nodes.py, 类名: BoundMethodNodeTest\n    def test_is_property(self) -> None:\n        ast = builder.parse(\n            \"\"\"\n        import abc\n\n        def cached_property():\n            # Not a real decorator, but we don't care\n            pass\n        def reify():\n            # Same as cached_property\n            pass\n        def lazy_property():\n            pass\n        def lazyproperty():\n            pass\n        def lazy(): pass\n        class A(object):\n            @property\n            def builtin_property(self):\n                return 42\n            @abc.abstractproperty\n            def abc_property(self):\n                return 42\n            @cached_property\n            def cached_property(self): return 42\n            @reify\n            def reified(self): return 42\n            @lazy_property\n            def lazy_prop(self): return 42\n            @lazyproperty\n            def lazyprop(self): return 42\n            def not_prop(self): pass\n            @lazy\n            def decorated_with_lazy(self): return 42\n\n        cls = A()\n        builtin_property = cls.builtin_property\n        abc_property = cls.abc_property\n        cached_p = cls.cached_property\n        reified = cls.reified\n        not_prop = cls.not_prop\n        lazy_prop = cls.lazy_prop\n        lazyprop = cls.lazyprop\n        decorated_with_lazy = cls.decorated_with_lazy\n        \"\"\"\n        )\n        for prop in (\n            \"builtin_property\",\n            \"abc_property\",\n            \"cached_p\",\n            \"reified\",\n            \"lazy_prop\",\n            \"lazyprop\",\n            \"decorated_with_lazy\",\n        ):\n            inferred = next(ast[prop].infer())\n            self.assertIsInstance(inferred, nodes.Const, prop)\n            self.assertEqual(inferred.value, 42, prop)\n\n        inferred = next(ast[\"not_prop\"].infer())\n        self.assertIsInstance(inferred, bases.BoundMethod)\n", "tokens": ["tests", "unittest_nodes", "py", "boundmethodnodetest", "def", "test_is_property", "self", "none", "ast", "builder", "parse", "import", "abc", "def", "cached_property", "not", "a", "real", "decorator", "but", "we", "don", "t", "care", "pass", "def", "reify", "same", "as", "cached_property", "pass", "def", "lazy_property", "pass", "def", "lazyproperty", "pass", "def", "lazy", "pass", "class", "a", "object", "property", "def", "builtin_property", "self", "return", "42", "abc", "abstractproperty", "def", "abc_property", "self", "return", "42", "cached_property", "def", "cached_property", "self", "return", "42", "reify", "def", "reified", "self", "return", "42", "lazy_property", "def", "lazy_prop", "self", "return", "42", "lazyproperty", "def", "lazyprop", "self", "return", "42", "def", "not_prop", "self", "pass", "lazy", "def", "decorated_with_lazy", "self", "return", "42", "cls", "a", "builtin_property", "cls", "builtin_property", "abc_property", "cls", "abc_property", "cached_p", "cls", "cached_property", "reified", "cls", "reified", "not_prop", "cls", "not_prop", "lazy_prop", "cls", "lazy_prop", "lazyprop", "cls", "lazyprop", "decorated_with_lazy", "cls", "decorated_with_lazy", "for", "prop", "in", "builtin_property", "abc_property", "cached_p", "reified", "lazy_prop", "lazyprop", "decorated_with_lazy", "inferred", "next", "ast", "prop", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "prop", "self", "assertequal", "inferred", "value", "42", "prop", "inferred", "next", "ast", "not_prop", "infer", "self", "assertisinstance", "inferred", "bases", "boundmethod"], "doc_len": 153}
{"doc_id": "tests/unittest_nodes.py::AliasesTest.setUp", "file_path": "tests/unittest_nodes.py", "class_name": "AliasesTest", "func_name": "setUp", "text": "文件路径: tests/unittest_nodes.py, 类名: AliasesTest\n    def setUp(self) -> None:\n        self.transformer = transforms.TransformVisitor()\n", "tokens": ["tests", "unittest_nodes", "py", "aliasestest", "def", "setup", "self", "none", "self", "transformer", "transforms", "transformvisitor"], "doc_len": 12}
{"doc_id": "tests/unittest_nodes.py::AliasesTest.parse_transform", "file_path": "tests/unittest_nodes.py", "class_name": "AliasesTest", "func_name": "parse_transform", "text": "文件路径: tests/unittest_nodes.py, 类名: AliasesTest\n    def parse_transform(self, code: str) -> Module:\n        module = parse(code, apply_transforms=False)\n        return self.transformer.visit(module)\n", "tokens": ["tests", "unittest_nodes", "py", "aliasestest", "def", "parse_transform", "self", "code", "str", "module", "module", "parse", "code", "apply_transforms", "false", "return", "self", "transformer", "visit", "module"], "doc_len": 20}
{"doc_id": "tests/unittest_nodes.py::AliasesTest.test_aliases", "file_path": "tests/unittest_nodes.py", "class_name": "AliasesTest", "func_name": "test_aliases", "text": "文件路径: tests/unittest_nodes.py, 类名: AliasesTest\n    def test_aliases(self) -> None:\n        def test_from(node: ImportFrom) -> ImportFrom:\n            node.names = node.names + [(\"absolute_import\", None)]\n            return node\n\n        def test_class(node: ClassDef) -> ClassDef:\n            node.name = \"Bar\"\n            return node\n\n        def test_function(node: FunctionDef) -> FunctionDef:\n            node.name = \"another_test\"\n            return node\n\n        def test_callfunc(node: Call) -> Optional[Call]:\n            if node.func.name == \"Foo\":\n                node.func.name = \"Bar\"\n                return node\n            return None\n\n        def test_assname(node: AssignName) -> Optional[AssignName]:\n            if node.name == \"foo\":\n                return nodes.AssignName(\n                    \"bar\", node.lineno, node.col_offset, node.parent\n                )\n            return None\n\n        def test_assattr(node: AssignAttr) -> AssignAttr:\n            if node.attrname == \"a\":\n                node.attrname = \"b\"\n                return node\n            return None\n\n        def test_getattr(node: Attribute) -> Attribute:\n            if node.attrname == \"a\":\n                node.attrname = \"b\"\n                return node\n            return None\n\n        def test_genexpr(node: GeneratorExp) -> GeneratorExp:\n            if node.elt.value == 1:\n                node.elt = nodes.Const(2, node.lineno, node.col_offset, node.parent)\n                return node\n            return None\n\n        self.transformer.register_transform(nodes.ImportFrom, test_from)\n        self.transformer.register_transform(nodes.ClassDef, test_class)\n        self.transformer.register_transform(nodes.FunctionDef, test_function)\n        self.transformer.register_transform(nodes.Call, test_callfunc)\n        self.transformer.register_transform(nodes.AssignName, test_assname)\n        self.transformer.register_transform(nodes.AssignAttr, test_assattr)\n        self.transformer.register_transform(nodes.Attribute, test_getattr)\n        self.transformer.register_transform(nodes.GeneratorExp, test_genexpr)\n\n        string = \"\"\"\n        from __future__ import print_function\n\n        class Foo: pass\n\n        def test(a): return a\n\n        foo = Foo()\n        foo.a = test(42)\n        foo.a\n        (1 for _ in range(0, 42))\n        \"\"\"\n\n        module = self.parse_transform(string)\n\n        self.assertEqual(len(module.body[0].names), 2)\n        self.assertIsInstance(module.body[0], nodes.ImportFrom)\n        self.assertEqual(module.body[1].name, \"Bar\")\n        self.assertIsInstance(module.body[1], nodes.ClassDef)\n        self.assertEqual(module.body[2].name, \"another_test\")\n        self.assertIsInstance(module.body[2], nodes.FunctionDef)\n        self.assertEqual(module.body[3].targets[0].name, \"bar\")\n        self.assertIsInstance(module.body[3].targets[0], nodes.AssignName)\n        self.assertEqual(module.body[3].value.func.name, \"Bar\")\n        self.assertIsInstance(module.body[3].value, nodes.Call)\n        self.assertEqual(module.body[4].targets[0].attrname, \"b\")\n        self.assertIsInstance(module.body[4].targets[0], nodes.AssignAttr)\n        self.assertIsInstance(module.body[5], nodes.Expr)\n        self.assertEqual(module.body[5].value.attrname, \"b\")\n        self.assertIsInstance(module.body[5].value, nodes.Attribute)\n        self.assertEqual(module.body[6].value.elt.value, 2)\n        self.assertIsInstance(module.body[6].value, nodes.GeneratorExp)\n", "tokens": ["tests", "unittest_nodes", "py", "aliasestest", "def", "test_aliases", "self", "none", "def", "test_from", "node", "importfrom", "importfrom", "node", "names", "node", "names", "absolute_import", "none", "return", "node", "def", "test_class", "node", "classdef", "classdef", "node", "name", "bar", "return", "node", "def", "test_function", "node", "functiondef", "functiondef", "node", "name", "another_test", "return", "node", "def", "test_callfunc", "node", "call", "optional", "call", "if", "node", "func", "name", "foo", "node", "func", "name", "bar", "return", "node", "return", "none", "def", "test_assname", "node", "assignname", "optional", "assignname", "if", "node", "name", "foo", "return", "nodes", "assignname", "bar", "node", "lineno", "node", "col_offset", "node", "parent", "return", "none", "def", "test_assattr", "node", "assignattr", "assignattr", "if", "node", "attrname", "a", "node", "attrname", "b", "return", "node", "return", "none", "def", "test_getattr", "node", "attribute", "attribute", "if", "node", "attrname", "a", "node", "attrname", "b", "return", "node", "return", "none", "def", "test_genexpr", "node", "generatorexp", "generatorexp", "if", "node", "elt", "value", "1", "node", "elt", "nodes", "const", "2", "node", "lineno", "node", "col_offset", "node", "parent", "return", "node", "return", "none", "self", "transformer", "register_transform", "nodes", "importfrom", "test_from", "self", "transformer", "register_transform", "nodes", "classdef", "test_class", "self", "transformer", "register_transform", "nodes", "functiondef", "test_function", "self", "transformer", "register_transform", "nodes", "call", "test_callfunc", "self", "transformer", "register_transform", "nodes", "assignname", "test_assname", "self", "transformer", "register_transform", "nodes", "assignattr", "test_assattr", "self", "transformer", "register_transform", "nodes", "attribute", "test_getattr", "self", "transformer", "register_transform", "nodes", "generatorexp", "test_genexpr", "string", "from", "__future__", "import", "print_function", "class", "foo", "pass", "def", "test", "a", "return", "a", "foo", "foo", "foo", "a", "test", "42", "foo", "a", "1", "for", "_", "in", "range", "0", "42", "module", "self", "parse_transform", "string", "self", "assertequal", "len", "module", "body", "0", "names", "2", "self", "assertisinstance", "module", "body", "0", "nodes", "importfrom", "self", "assertequal", "module", "body", "1", "name", "bar", "self", "assertisinstance", "module", "body", "1", "nodes", "classdef", "self", "assertequal", "module", "body", "2", "name", "another_test", "self", "assertisinstance", "module", "body", "2", "nodes", "functiondef", "self", "assertequal", "module", "body", "3", "targets", "0", "name", "bar", "self", "assertisinstance", "module", "body", "3", "targets", "0", "nodes", "assignname", "self", "assertequal", "module", "body", "3", "value", "func", "name", "bar", "self", "assertisinstance", "module", "body", "3", "value", "nodes", "call", "self", "assertequal", "module", "body", "4", "targets", "0", "attrname", "b", "self", "assertisinstance", "module", "body", "4", "targets", "0", "nodes", "assignattr", "self", "assertisinstance", "module", "body", "5", "nodes", "expr", "self", "assertequal", "module", "body", "5", "value", "attrname", "b", "self", "assertisinstance", "module", "body", "5", "value", "nodes", "attribute", "self", "assertequal", "module", "body", "6", "value", "elt", "value", "2", "self", "assertisinstance", "module", "body", "6", "value", "nodes", "generatorexp"], "doc_len": 355}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest.test_async_await_keywords", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "test_async_await_keywords", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def test_async_await_keywords(self) -> None:\n        async_def, async_for, async_with, await_node = builder.extract_node(\n            \"\"\"\n        async def func(): #@\n            async for i in range(10): #@\n                f = __(await i)\n            async with test(): #@\n                pass\n        \"\"\"\n        )\n        self.assertIsInstance(async_def, nodes.AsyncFunctionDef)\n        self.assertIsInstance(async_for, nodes.AsyncFor)\n        self.assertIsInstance(async_with, nodes.AsyncWith)\n        self.assertIsInstance(await_node, nodes.Await)\n        self.assertIsInstance(await_node.value, nodes.Name)\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "test_async_await_keywords", "self", "none", "async_def", "async_for", "async_with", "await_node", "builder", "extract_node", "async", "def", "func", "async", "for", "i", "in", "range", "10", "f", "__", "await", "i", "async", "with", "test", "pass", "self", "assertisinstance", "async_def", "nodes", "asyncfunctiondef", "self", "assertisinstance", "async_for", "nodes", "asyncfor", "self", "assertisinstance", "async_with", "nodes", "asyncwith", "self", "assertisinstance", "await_node", "nodes", "await", "self", "assertisinstance", "await_node", "value", "nodes", "name"], "doc_len": 57}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest._test_await_async_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "_test_await_async_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def _test_await_async_as_string(self, code: str) -> None:\n        ast_node = parse(code)\n        self.assertEqual(ast_node.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "_test_await_async_as_string", "self", "code", "str", "none", "ast_node", "parse", "code", "self", "assertequal", "ast_node", "as_string", "strip", "code", "strip"], "doc_len": 20}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest.test_await_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "test_await_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def test_await_as_string(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        async def function():\n            await 42\n            await x[0]\n            (await x)[0]\n            await (x + y)[0]\n        \"\"\"\n        )\n        self._test_await_async_as_string(code)\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "test_await_as_string", "self", "none", "code", "textwrap", "dedent", "async", "def", "function", "await", "42", "await", "x", "0", "await", "x", "0", "await", "x", "y", "0", "self", "_test_await_async_as_string", "code"], "doc_len": 29}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest.test_asyncwith_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "test_asyncwith_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def test_asyncwith_as_string(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        async def function():\n            async with 42:\n                pass\n        \"\"\"\n        )\n        self._test_await_async_as_string(code)\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "test_asyncwith_as_string", "self", "none", "code", "textwrap", "dedent", "async", "def", "function", "async", "with", "42", "pass", "self", "_test_await_async_as_string", "code"], "doc_len": 21}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest.test_asyncfor_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "test_asyncfor_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def test_asyncfor_as_string(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        async def function():\n            async for i in range(10):\n                await 42\n        \"\"\"\n        )\n        self._test_await_async_as_string(code)\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "test_asyncfor_as_string", "self", "none", "code", "textwrap", "dedent", "async", "def", "function", "async", "for", "i", "in", "range", "10", "await", "42", "self", "_test_await_async_as_string", "code"], "doc_len": 25}
{"doc_id": "tests/unittest_nodes.py::Python35AsyncTest.test_decorated_async_def_as_string", "file_path": "tests/unittest_nodes.py", "class_name": "Python35AsyncTest", "func_name": "test_decorated_async_def_as_string", "text": "文件路径: tests/unittest_nodes.py, 类名: Python35AsyncTest\n    def test_decorated_async_def_as_string(self) -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        @decorator\n        async def function():\n            async for i in range(10):\n                await 42\n        \"\"\"\n        )\n        self._test_await_async_as_string(code)\n", "tokens": ["tests", "unittest_nodes", "py", "python35asynctest", "def", "test_decorated_async_def_as_string", "self", "none", "code", "textwrap", "dedent", "decorator", "async", "def", "function", "async", "for", "i", "in", "range", "10", "await", "42", "self", "_test_await_async_as_string", "code"], "doc_len": 26}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_subscript_load", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_subscript_load", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_subscript_load(self) -> None:\n        node = builder.extract_node(\"f[1]\")\n        self.assertIs(node.ctx, Context.Load)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_subscript_load", "self", "none", "node", "builder", "extract_node", "f", "1", "self", "assertis", "node", "ctx", "context", "load"], "doc_len": 19}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_subscript_del", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_subscript_del", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_subscript_del(self) -> None:\n        node = builder.extract_node(\"del f[1]\")\n        self.assertIs(node.targets[0].ctx, Context.Del)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_subscript_del", "self", "none", "node", "builder", "extract_node", "del", "f", "1", "self", "assertis", "node", "targets", "0", "ctx", "context", "del"], "doc_len": 22}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_subscript_store", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_subscript_store", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_subscript_store(self) -> None:\n        node = builder.extract_node(\"f[1] = 2\")\n        subscript = node.targets[0]\n        self.assertIs(subscript.ctx, Context.Store)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_subscript_store", "self", "none", "node", "builder", "extract_node", "f", "1", "2", "subscript", "node", "targets", "0", "self", "assertis", "subscript", "ctx", "context", "store"], "doc_len": 24}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_list_load", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_list_load", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_list_load(self) -> None:\n        node = builder.extract_node(\"[]\")\n        self.assertIs(node.ctx, Context.Load)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_list_load", "self", "none", "node", "builder", "extract_node", "self", "assertis", "node", "ctx", "context", "load"], "doc_len": 17}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_list_del", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_list_del", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_list_del(self) -> None:\n        node = builder.extract_node(\"del []\")\n        self.assertIs(node.targets[0].ctx, Context.Del)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_list_del", "self", "none", "node", "builder", "extract_node", "del", "self", "assertis", "node", "targets", "0", "ctx", "context", "del"], "doc_len": 20}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_list_store", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_list_store", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_list_store(self) -> None:\n        with self.assertRaises(AstroidSyntaxError):\n            builder.extract_node(\"[0] = 2\")\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_list_store", "self", "none", "with", "self", "assertraises", "astroidsyntaxerror", "builder", "extract_node", "0", "2"], "doc_len": 16}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_tuple_load", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_tuple_load", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_tuple_load(self) -> None:\n        node = builder.extract_node(\"(1, )\")\n        self.assertIs(node.ctx, Context.Load)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_tuple_load", "self", "none", "node", "builder", "extract_node", "1", "self", "assertis", "node", "ctx", "context", "load"], "doc_len": 18}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_tuple_store", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_tuple_store", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_tuple_store(self) -> None:\n        with self.assertRaises(AstroidSyntaxError):\n            builder.extract_node(\"(1, ) = 3\")\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_tuple_store", "self", "none", "with", "self", "assertraises", "astroidsyntaxerror", "builder", "extract_node", "1", "3"], "doc_len": 16}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_starred_load", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_starred_load", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_starred_load(self) -> None:\n        node = builder.extract_node(\"a = *b\")\n        starred = node.value\n        self.assertIs(starred.ctx, Context.Load)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_starred_load", "self", "none", "node", "builder", "extract_node", "a", "b", "starred", "node", "value", "self", "assertis", "starred", "ctx", "context", "load"], "doc_len": 22}
{"doc_id": "tests/unittest_nodes.py::ContextTest.test_starred_store", "file_path": "tests/unittest_nodes.py", "class_name": "ContextTest", "func_name": "test_starred_store", "text": "文件路径: tests/unittest_nodes.py, 类名: ContextTest\n    def test_starred_store(self) -> None:\n        node = builder.extract_node(\"a, *b = 1, 2\")\n        starred = node.targets[0].elts[1]\n        self.assertIs(starred.ctx, Context.Store)\n", "tokens": ["tests", "unittest_nodes", "py", "contexttest", "def", "test_starred_store", "self", "none", "node", "builder", "extract_node", "a", "b", "1", "2", "starred", "node", "targets", "0", "elts", "1", "self", "assertis", "starred", "ctx", "context", "store"], "doc_len": 27}
{"doc_id": "tests/unittest_nodes.py::test_unknown", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_unknown", "text": "文件路径: tests/unittest_nodes.py\ndef test_unknown() -> None:\n    \"\"\"Test Unknown node\"\"\"\n    assert isinstance(next(nodes.Unknown().infer()), type(util.Uninferable))\n    assert isinstance(nodes.Unknown().name, str)\n    assert isinstance(nodes.Unknown().qname(), str)\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_unknown", "none", "test", "unknown", "node", "assert", "isinstance", "next", "nodes", "unknown", "infer", "type", "util", "uninferable", "assert", "isinstance", "nodes", "unknown", "name", "str", "assert", "isinstance", "nodes", "unknown", "qname", "str"], "doc_len": 30}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_with", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_with", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_with() -> None:\n    module = builder.parse(\n        \"\"\"\n    with a as b: # type: int\n        pass\n    with a as b: # type: ignore\n        pass\n    \"\"\"\n    )\n    node = module.body[0]\n    ignored_node = module.body[1]\n    assert isinstance(node.type_annotation, astroid.Name)\n\n    assert ignored_node.type_annotation is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_with", "none", "module", "builder", "parse", "with", "a", "as", "b", "type", "int", "pass", "with", "a", "as", "b", "type", "ignore", "pass", "node", "module", "body", "0", "ignored_node", "module", "body", "1", "assert", "isinstance", "node", "type_annotation", "astroid", "name", "assert", "ignored_node", "type_annotation", "is", "none"], "doc_len": 42}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_for", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_for", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_for() -> None:\n    module = builder.parse(\n        \"\"\"\n    for a, b in [1, 2, 3]: # type: List[int]\n        pass\n    for a, b in [1, 2, 3]: # type: ignore\n        pass\n    \"\"\"\n    )\n    node = module.body[0]\n    ignored_node = module.body[1]\n    assert isinstance(node.type_annotation, astroid.Subscript)\n    assert node.type_annotation.as_string() == \"List[int]\"\n\n    assert ignored_node.type_annotation is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_for", "none", "module", "builder", "parse", "for", "a", "b", "in", "1", "2", "3", "type", "list", "int", "pass", "for", "a", "b", "in", "1", "2", "3", "type", "ignore", "pass", "node", "module", "body", "0", "ignored_node", "module", "body", "1", "assert", "isinstance", "node", "type_annotation", "astroid", "subscript", "assert", "node", "type_annotation", "as_string", "list", "int", "assert", "ignored_node", "type_annotation", "is", "none"], "doc_len": 55}
{"doc_id": "tests/unittest_nodes.py::test_type_coments_assign", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_coments_assign", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_coments_assign() -> None:\n    module = builder.parse(\n        \"\"\"\n    a, b = [1, 2, 3] # type: List[int]\n    a, b = [1, 2, 3] # type: ignore\n    \"\"\"\n    )\n    node = module.body[0]\n    ignored_node = module.body[1]\n    assert isinstance(node.type_annotation, astroid.Subscript)\n    assert node.type_annotation.as_string() == \"List[int]\"\n\n    assert ignored_node.type_annotation is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_coments_assign", "none", "module", "builder", "parse", "a", "b", "1", "2", "3", "type", "list", "int", "a", "b", "1", "2", "3", "type", "ignore", "node", "module", "body", "0", "ignored_node", "module", "body", "1", "assert", "isinstance", "node", "type_annotation", "astroid", "subscript", "assert", "node", "type_annotation", "as_string", "list", "int", "assert", "ignored_node", "type_annotation", "is", "none"], "doc_len": 49}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_invalid_expression", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_invalid_expression", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_invalid_expression() -> None:\n    module = builder.parse(\n        \"\"\"\n    a, b = [1, 2, 3] # type: something completely invalid\n    a, b = [1, 2, 3] # typeee: 2*+4\n    a, b = [1, 2, 3] # type: List[int\n    \"\"\"\n    )\n    for node in module.body:\n        assert node.type_annotation is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_invalid_expression", "none", "module", "builder", "parse", "a", "b", "1", "2", "3", "type", "something", "completely", "invalid", "a", "b", "1", "2", "3", "typeee", "2", "4", "a", "b", "1", "2", "3", "type", "list", "int", "for", "node", "in", "module", "body", "assert", "node", "type_annotation", "is", "none"], "doc_len": 44}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_invalid_function_comments", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_invalid_function_comments", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_invalid_function_comments() -> None:\n    module = builder.parse(\n        \"\"\"\n    def func():\n        # type: something completely invalid\n        pass\n    def func1():\n        # typeee: 2*+4\n        pass\n    def func2():\n        # type: List[int\n        pass\n    \"\"\"\n    )\n    for node in module.body:\n        assert node.type_comment_returns is None\n        assert node.type_comment_args is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_invalid_function_comments", "none", "module", "builder", "parse", "def", "func", "type", "something", "completely", "invalid", "pass", "def", "func1", "typeee", "2", "4", "pass", "def", "func2", "type", "list", "int", "pass", "for", "node", "in", "module", "body", "assert", "node", "type_comment_returns", "is", "none", "assert", "node", "type_comment_args", "is", "none"], "doc_len": 43}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_function", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_function", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_function() -> None:\n    module = builder.parse(\n        \"\"\"\n    def func():\n        # type: (int) -> str\n        pass\n    def func1():\n        # type: (int, int, int) -> (str, str)\n        pass\n    def func2():\n        # type: (int, int, str, List[int]) -> List[int]\n        pass\n    \"\"\"\n    )\n    expected_annotations = [\n        ([\"int\"], astroid.Name, \"str\"),\n        ([\"int\", \"int\", \"int\"], astroid.Tuple, \"(str, str)\"),\n        ([\"int\", \"int\", \"str\", \"List[int]\"], astroid.Subscript, \"List[int]\"),\n    ]\n    for node, (expected_args, expected_returns_type, expected_returns_string) in zip(\n        module.body, expected_annotations\n    ):\n        assert node.type_comment_returns is not None\n        assert node.type_comment_args is not None\n        for expected_arg, actual_arg in zip(expected_args, node.type_comment_args):\n            assert actual_arg.as_string() == expected_arg\n        assert isinstance(node.type_comment_returns, expected_returns_type)\n        assert node.type_comment_returns.as_string() == expected_returns_string\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_function", "none", "module", "builder", "parse", "def", "func", "type", "int", "str", "pass", "def", "func1", "type", "int", "int", "int", "str", "str", "pass", "def", "func2", "type", "int", "int", "str", "list", "int", "list", "int", "pass", "expected_annotations", "int", "astroid", "name", "str", "int", "int", "int", "astroid", "tuple", "str", "str", "int", "int", "str", "list", "int", "astroid", "subscript", "list", "int", "for", "node", "expected_args", "expected_returns_type", "expected_returns_string", "in", "zip", "module", "body", "expected_annotations", "assert", "node", "type_comment_returns", "is", "not", "none", "assert", "node", "type_comment_args", "is", "not", "none", "for", "expected_arg", "actual_arg", "in", "zip", "expected_args", "node", "type_comment_args", "assert", "actual_arg", "as_string", "expected_arg", "assert", "isinstance", "node", "type_comment_returns", "expected_returns_type", "assert", "node", "type_comment_returns", "as_string", "expected_returns_string"], "doc_len": 100}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_arguments", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_arguments", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_arguments() -> None:\n    module = builder.parse(\n        \"\"\"\n    def func(\n        a,  # type: int\n    ):\n        # type: (...) -> str\n        pass\n    def func1(\n        a,  # type: int\n        b,  # type: int\n        c,  # type: int\n    ):\n        # type: (...) -> (str, str)\n        pass\n    def func2(\n        a,  # type: int\n        b,  # type: int\n        c,  # type: str\n        d,  # type: List[int]\n    ):\n        # type: (...) -> List[int]\n        pass\n    \"\"\"\n    )\n    expected_annotations = [\n        [\"int\"],\n        [\"int\", \"int\", \"int\"],\n        [\"int\", \"int\", \"str\", \"List[int]\"],\n    ]\n    for node, expected_args in zip(module.body, expected_annotations):\n        assert len(node.type_comment_args) == 1\n        assert isinstance(node.type_comment_args[0], astroid.Const)\n        assert node.type_comment_args[0].value == Ellipsis\n        assert len(node.args.type_comment_args) == len(expected_args)\n        for expected_arg, actual_arg in zip(expected_args, node.args.type_comment_args):\n            assert actual_arg.as_string() == expected_arg\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_arguments", "none", "module", "builder", "parse", "def", "func", "a", "type", "int", "type", "str", "pass", "def", "func1", "a", "type", "int", "b", "type", "int", "c", "type", "int", "type", "str", "str", "pass", "def", "func2", "a", "type", "int", "b", "type", "int", "c", "type", "str", "d", "type", "list", "int", "type", "list", "int", "pass", "expected_annotations", "int", "int", "int", "int", "int", "int", "str", "list", "int", "for", "node", "expected_args", "in", "zip", "module", "body", "expected_annotations", "assert", "len", "node", "type_comment_args", "1", "assert", "isinstance", "node", "type_comment_args", "0", "astroid", "const", "assert", "node", "type_comment_args", "0", "value", "ellipsis", "assert", "len", "node", "args", "type_comment_args", "len", "expected_args", "for", "expected_arg", "actual_arg", "in", "zip", "expected_args", "node", "args", "type_comment_args", "assert", "actual_arg", "as_string", "expected_arg"], "doc_len": 107}
{"doc_id": "tests/unittest_nodes.py::test_type_comments_posonly_arguments", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_type_comments_posonly_arguments", "text": "文件路径: tests/unittest_nodes.py\ndef test_type_comments_posonly_arguments() -> None:\n    module = builder.parse(\n        \"\"\"\n    def f_arg_comment(\n        a,  # type: int\n        b,  # type: int\n        /,\n        c,  # type: Optional[int]\n        d,  # type: Optional[int]\n        *,\n        e,  # type: float\n        f,  # type: float\n    ):\n        # type: (...) -> None\n        pass\n    \"\"\"\n    )\n    expected_annotations = [\n        [[\"int\", \"int\"], [\"Optional[int]\", \"Optional[int]\"], [\"float\", \"float\"]]\n    ]\n    for node, expected_types in zip(module.body, expected_annotations):\n        assert len(node.type_comment_args) == 1\n        assert isinstance(node.type_comment_args[0], astroid.Const)\n        assert node.type_comment_args[0].value == Ellipsis\n        type_comments = [\n            node.args.type_comment_posonlyargs,\n            node.args.type_comment_args,\n            node.args.type_comment_kwonlyargs,\n        ]\n        for expected_args, actual_args in zip(expected_types, type_comments):\n            assert len(expected_args) == len(actual_args)\n            for expected_arg, actual_arg in zip(expected_args, actual_args):\n                assert actual_arg.as_string() == expected_arg\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_type_comments_posonly_arguments", "none", "module", "builder", "parse", "def", "f_arg_comment", "a", "type", "int", "b", "type", "int", "c", "type", "optional", "int", "d", "type", "optional", "int", "e", "type", "float", "f", "type", "float", "type", "none", "pass", "expected_annotations", "int", "int", "optional", "int", "optional", "int", "float", "float", "for", "node", "expected_types", "in", "zip", "module", "body", "expected_annotations", "assert", "len", "node", "type_comment_args", "1", "assert", "isinstance", "node", "type_comment_args", "0", "astroid", "const", "assert", "node", "type_comment_args", "0", "value", "ellipsis", "type_comments", "node", "args", "type_comment_posonlyargs", "node", "args", "type_comment_args", "node", "args", "type_comment_kwonlyargs", "for", "expected_args", "actual_args", "in", "zip", "expected_types", "type_comments", "assert", "len", "expected_args", "len", "actual_args", "for", "expected_arg", "actual_arg", "in", "zip", "expected_args", "actual_args", "assert", "actual_arg", "as_string", "expected_arg"], "doc_len": 102}
{"doc_id": "tests/unittest_nodes.py::test_correct_function_type_comment_parent", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_correct_function_type_comment_parent", "text": "文件路径: tests/unittest_nodes.py\ndef test_correct_function_type_comment_parent() -> None:\n    data = \"\"\"\n        def f(a):\n            # type: (A) -> A\n            pass\n    \"\"\"\n    parsed_data = builder.parse(data)\n    f = parsed_data.body[0]\n    assert f.type_comment_args[0].parent is f\n    assert f.type_comment_returns.parent is f\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_correct_function_type_comment_parent", "none", "data", "def", "f", "a", "type", "a", "a", "pass", "parsed_data", "builder", "parse", "data", "f", "parsed_data", "body", "0", "assert", "f", "type_comment_args", "0", "parent", "is", "f", "assert", "f", "type_comment_returns", "parent", "is", "f"], "doc_len": 35}
{"doc_id": "tests/unittest_nodes.py::test_is_generator_for_yield_assignments", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_is_generator_for_yield_assignments", "text": "文件路径: tests/unittest_nodes.py\ndef test_is_generator_for_yield_assignments() -> None:\n    node = astroid.extract_node(\n        \"\"\"\n    class A:\n        def test(self):\n            a = yield\n            while True:\n                print(a)\n                yield a\n    a = A()\n    a.test\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, astroid.BoundMethod)\n    assert bool(inferred.is_generator())\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_is_generator_for_yield_assignments", "none", "node", "astroid", "extract_node", "class", "a", "def", "test", "self", "a", "yield", "while", "true", "print", "a", "yield", "a", "a", "a", "a", "test", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "boundmethod", "assert", "bool", "inferred", "is_generator"], "doc_len": 39}
{"doc_id": "tests/unittest_nodes.py::AsyncGeneratorTest.test_async_generator", "file_path": "tests/unittest_nodes.py", "class_name": "AsyncGeneratorTest", "func_name": "test_async_generator", "text": "文件路径: tests/unittest_nodes.py, 类名: AsyncGeneratorTest\n    def test_async_generator(self):\n        node = astroid.extract_node(\n            \"\"\"\n        async def a_iter(n):\n            for i in range(1, n + 1):\n                yield i\n                await asyncio.sleep(1)\n        a_iter(2) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, bases.AsyncGenerator)\n        assert inferred.getattr(\"__aiter__\")\n        assert inferred.getattr(\"__anext__\")\n        assert inferred.pytype() == \"builtins.async_generator\"\n        assert inferred.display_type() == \"AsyncGenerator\"\n", "tokens": ["tests", "unittest_nodes", "py", "asyncgeneratortest", "def", "test_async_generator", "self", "node", "astroid", "extract_node", "async", "def", "a_iter", "n", "for", "i", "in", "range", "1", "n", "1", "yield", "i", "await", "asyncio", "sleep", "1", "a_iter", "2", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "bases", "asyncgenerator", "assert", "inferred", "getattr", "__aiter__", "assert", "inferred", "getattr", "__anext__", "assert", "inferred", "pytype", "builtins", "async_generator", "assert", "inferred", "display_type", "asyncgenerator"], "doc_len": 55}
{"doc_id": "tests/unittest_nodes.py::AsyncGeneratorTest.test_async_generator_is_generator_on_older_python", "file_path": "tests/unittest_nodes.py", "class_name": "AsyncGeneratorTest", "func_name": "test_async_generator_is_generator_on_older_python", "text": "文件路径: tests/unittest_nodes.py, 类名: AsyncGeneratorTest\n    def test_async_generator_is_generator_on_older_python(self):\n        node = astroid.extract_node(\n            \"\"\"\n        async def a_iter(n):\n            for i in range(1, n + 1):\n                yield i\n                await asyncio.sleep(1)\n        a_iter(2) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert isinstance(inferred, bases.Generator)\n        assert inferred.getattr(\"__iter__\")\n        assert inferred.getattr(\"__next__\")\n        assert inferred.pytype() == \"builtins.generator\"\n        assert inferred.display_type() == \"Generator\"\n", "tokens": ["tests", "unittest_nodes", "py", "asyncgeneratortest", "def", "test_async_generator_is_generator_on_older_python", "self", "node", "astroid", "extract_node", "async", "def", "a_iter", "n", "for", "i", "in", "range", "1", "n", "1", "yield", "i", "await", "asyncio", "sleep", "1", "a_iter", "2", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "bases", "generator", "assert", "inferred", "getattr", "__iter__", "assert", "inferred", "getattr", "__next__", "assert", "inferred", "pytype", "builtins", "generator", "assert", "inferred", "display_type", "generator"], "doc_len": 55}
{"doc_id": "tests/unittest_nodes.py::test_f_string_correct_line_numbering", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_f_string_correct_line_numbering", "text": "文件路径: tests/unittest_nodes.py\ndef test_f_string_correct_line_numbering() -> None:\n    \"\"\"Test that we generate correct line numbers for f-strings\"\"\"\n    node = astroid.extract_node(\n        \"\"\"\n    def func_foo(arg_bar, arg_foo):\n        dict_foo = {}\n\n        f'{arg_bar.attr_bar}' #@\n    \"\"\"\n    )\n    assert node.lineno == 5\n    assert node.last_child().lineno == 5\n    assert node.last_child().last_child().lineno == 5\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_f_string_correct_line_numbering", "none", "test", "that", "we", "generate", "correct", "line", "numbers", "for", "f", "strings", "node", "astroid", "extract_node", "def", "func_foo", "arg_bar", "arg_foo", "dict_foo", "f", "arg_bar", "attr_bar", "assert", "node", "lineno", "5", "assert", "node", "last_child", "lineno", "5", "assert", "node", "last_child", "last_child", "lineno", "5"], "doc_len": 42}
{"doc_id": "tests/unittest_nodes.py::test_assignment_expression", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_assignment_expression", "text": "文件路径: tests/unittest_nodes.py\ndef test_assignment_expression() -> None:\n    code = \"\"\"\n    if __(a := 1):\n        pass\n    if __(b := test):\n        pass\n    \"\"\"\n    first, second = astroid.extract_node(code)\n\n    assert isinstance(first.target, nodes.AssignName)\n    assert first.target.name == \"a\"\n    assert isinstance(first.value, nodes.Const)\n    assert first.value.value == 1\n    assert first.as_string() == \"a := 1\"\n\n    assert isinstance(second.target, nodes.AssignName)\n    assert second.target.name == \"b\"\n    assert isinstance(second.value, nodes.Name)\n    assert second.value.name == \"test\"\n    assert second.as_string() == \"b := test\"\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_assignment_expression", "none", "code", "if", "__", "a", "1", "pass", "if", "__", "b", "test", "pass", "first", "second", "astroid", "extract_node", "code", "assert", "isinstance", "first", "target", "nodes", "assignname", "assert", "first", "target", "name", "a", "assert", "isinstance", "first", "value", "nodes", "const", "assert", "first", "value", "value", "1", "assert", "first", "as_string", "a", "1", "assert", "isinstance", "second", "target", "nodes", "assignname", "assert", "second", "target", "name", "b", "assert", "isinstance", "second", "value", "nodes", "name", "assert", "second", "value", "name", "test", "assert", "second", "as_string", "b", "test"], "doc_len": 76}
{"doc_id": "tests/unittest_nodes.py::test_assignment_expression_in_functiondef", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_assignment_expression_in_functiondef", "text": "文件路径: tests/unittest_nodes.py\ndef test_assignment_expression_in_functiondef() -> None:\n    code = \"\"\"\n    def function(param = (assignment := \"walrus\")):\n        def inner_function(inner_param = (inner_assign := \"walrus\")):\n            pass\n        pass\n\n    class MyClass(attr = (assignment_two := \"walrus\")):\n        pass\n\n    VAR = lambda y = (assignment_three := \"walrus\"): print(y)\n\n    def func_with_lambda(\n        param=(named_expr_four := lambda y=(assignment_four := \"walrus\"): y),\n    ):\n        pass\n\n    COMPREHENSION = [y for i in (1, 2) if (assignment_five := i ** 2)]\n\n    def func():\n        var = lambda y = (assignment_six := 2): print(y)\n\n    VAR_TWO = [\n        func(assignment_seven := 2)\n        for _ in (1,)\n    ]\n\n    LAMBDA = lambda x: print(assignment_eight := x ** 2)\n\n    class SomeClass:\n        (assignment_nine := 2**2)\n    \"\"\"\n    module = astroid.parse(code)\n\n    assert \"assignment\" in module.locals\n    assert isinstance(module.locals.get(\"assignment\")[0], nodes.AssignName)\n    function = module.body[0]\n    assert \"inner_assign\" in function.locals\n    assert \"inner_assign\" not in module.locals\n    assert isinstance(function.locals.get(\"inner_assign\")[0], nodes.AssignName)\n\n    assert \"assignment_two\" in module.locals\n    assert isinstance(module.locals.get(\"assignment_two\")[0], nodes.AssignName)\n\n    assert \"assignment_three\" in module.locals\n    assert isinstance(module.locals.get(\"assignment_three\")[0], nodes.AssignName)\n\n    assert \"assignment_four\" in module.locals\n    assert isinstance(module.locals.get(\"assignment_four\")[0], nodes.AssignName)\n\n    assert \"assignment_five\" in module.locals\n    assert isinstance(module.locals.get(\"assignment_five\")[0], nodes.AssignName)\n\n    func = module.body[5]\n    assert \"assignment_six\" in func.locals\n    assert \"assignment_six\" not in module.locals\n    assert isinstance(func.locals.get(\"assignment_six\")[0], nodes.AssignName)\n\n    assert \"assignment_seven\" in module.locals\n    assert isinstance(module.locals.get(\"assignment_seven\")[0], nodes.AssignName)\n\n    lambda_assign = module.body[7]\n    assert \"assignment_eight\" in lambda_assign.value.locals\n    assert \"assignment_eight\" not in module.locals\n    assert isinstance(\n        lambda_assign.value.locals.get(\"assignment_eight\")[0], nodes.AssignName\n    )\n\n    class_assign = module.body[8]\n    assert \"assignment_nine\" in class_assign.locals\n    assert \"assignment_nine\" not in module.locals\n    assert isinstance(class_assign.locals.get(\"assignment_nine\")[0], nodes.AssignName)\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_assignment_expression_in_functiondef", "none", "code", "def", "function", "param", "assignment", "walrus", "def", "inner_function", "inner_param", "inner_assign", "walrus", "pass", "pass", "class", "myclass", "attr", "assignment_two", "walrus", "pass", "var", "lambda", "y", "assignment_three", "walrus", "print", "y", "def", "func_with_lambda", "param", "named_expr_four", "lambda", "y", "assignment_four", "walrus", "y", "pass", "comprehension", "y", "for", "i", "in", "1", "2", "if", "assignment_five", "i", "2", "def", "func", "var", "lambda", "y", "assignment_six", "2", "print", "y", "var_two", "func", "assignment_seven", "2", "for", "_", "in", "1", "lambda", "lambda", "x", "print", "assignment_eight", "x", "2", "class", "someclass", "assignment_nine", "2", "2", "module", "astroid", "parse", "code", "assert", "assignment", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment", "0", "nodes", "assignname", "function", "module", "body", "0", "assert", "inner_assign", "in", "function", "locals", "assert", "inner_assign", "not", "in", "module", "locals", "assert", "isinstance", "function", "locals", "get", "inner_assign", "0", "nodes", "assignname", "assert", "assignment_two", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment_two", "0", "nodes", "assignname", "assert", "assignment_three", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment_three", "0", "nodes", "assignname", "assert", "assignment_four", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment_four", "0", "nodes", "assignname", "assert", "assignment_five", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment_five", "0", "nodes", "assignname", "func", "module", "body", "5", "assert", "assignment_six", "in", "func", "locals", "assert", "assignment_six", "not", "in", "module", "locals", "assert", "isinstance", "func", "locals", "get", "assignment_six", "0", "nodes", "assignname", "assert", "assignment_seven", "in", "module", "locals", "assert", "isinstance", "module", "locals", "get", "assignment_seven", "0", "nodes", "assignname", "lambda_assign", "module", "body", "7", "assert", "assignment_eight", "in", "lambda_assign", "value", "locals", "assert", "assignment_eight", "not", "in", "module", "locals", "assert", "isinstance", "lambda_assign", "value", "locals", "get", "assignment_eight", "0", "nodes", "assignname", "class_assign", "module", "body", "8", "assert", "assignment_nine", "in", "class_assign", "locals", "assert", "assignment_nine", "not", "in", "module", "locals", "assert", "isinstance", "class_assign", "locals", "get", "assignment_nine", "0", "nodes", "assignname"], "doc_len": 268}
{"doc_id": "tests/unittest_nodes.py::test_get_doc", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_get_doc", "text": "文件路径: tests/unittest_nodes.py\ndef test_get_doc() -> None:\n    node = astroid.extract_node(\n        \"\"\"\n    def func():\n        \"Docstring\"\n        return 1\n    \"\"\"\n    )\n    assert node.doc == \"Docstring\"\n\n    node = astroid.extract_node(\n        \"\"\"\n    def func():\n        ...\n        return 1\n    \"\"\"\n    )\n    assert node.doc is None\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_get_doc", "none", "node", "astroid", "extract_node", "def", "func", "docstring", "return", "1", "assert", "node", "doc", "docstring", "node", "astroid", "extract_node", "def", "func", "return", "1", "assert", "node", "doc", "is", "none"], "doc_len": 30}
{"doc_id": "tests/unittest_nodes.py::test_parse_fstring_debug_mode", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_parse_fstring_debug_mode", "text": "文件路径: tests/unittest_nodes.py\ndef test_parse_fstring_debug_mode() -> None:\n    node = astroid.extract_node('f\"{3=}\"')\n    assert isinstance(node, nodes.JoinedStr)\n    assert node.as_string() == \"f'3={3!r}'\"\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_parse_fstring_debug_mode", "none", "node", "astroid", "extract_node", "f", "3", "assert", "isinstance", "node", "nodes", "joinedstr", "assert", "node", "as_string", "f", "3", "3", "r"], "doc_len": 23}
{"doc_id": "tests/unittest_nodes.py::test_parse_type_comments_with_proper_parent", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_parse_type_comments_with_proper_parent", "text": "文件路径: tests/unittest_nodes.py\ndef test_parse_type_comments_with_proper_parent() -> None:\n    code = \"\"\"\n    class D: #@\n        @staticmethod\n        def g(\n                x  # type: np.array\n        ):\n            pass\n    \"\"\"\n    node = astroid.extract_node(code)\n    func = node.getattr(\"g\")[0]\n    type_comments = func.args.type_comment_args\n    assert len(type_comments) == 1\n\n    type_comment = type_comments[0]\n    assert isinstance(type_comment, astroid.Attribute)\n    assert isinstance(type_comment.parent, astroid.Expr)\n    assert isinstance(type_comment.parent.parent, astroid.Arguments)\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_parse_type_comments_with_proper_parent", "none", "code", "class", "d", "staticmethod", "def", "g", "x", "type", "np", "array", "pass", "node", "astroid", "extract_node", "code", "func", "node", "getattr", "g", "0", "type_comments", "func", "args", "type_comment_args", "assert", "len", "type_comments", "1", "type_comment", "type_comments", "0", "assert", "isinstance", "type_comment", "astroid", "attribute", "assert", "isinstance", "type_comment", "parent", "astroid", "expr", "assert", "isinstance", "type_comment", "parent", "parent", "astroid", "arguments"], "doc_len": 55}
{"doc_id": "tests/unittest_nodes.py::test_const_itered", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_const_itered", "text": "文件路径: tests/unittest_nodes.py\ndef test_const_itered() -> None:\n    code = 'a = \"string\"'\n    node = astroid.extract_node(code).value\n    assert isinstance(node, astroid.Const)\n    itered = node.itered()\n    assert len(itered) == 6\n    assert [elem.value for elem in itered] == list(\"string\")\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_const_itered", "none", "code", "a", "string", "node", "astroid", "extract_node", "code", "value", "assert", "isinstance", "node", "astroid", "const", "itered", "node", "itered", "assert", "len", "itered", "6", "assert", "elem", "value", "for", "elem", "in", "itered", "list", "string"], "doc_len": 35}
{"doc_id": "tests/unittest_nodes.py::test_is_generator_for_yield_in_while", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_is_generator_for_yield_in_while", "text": "文件路径: tests/unittest_nodes.py\ndef test_is_generator_for_yield_in_while() -> None:\n    code = \"\"\"\n    def paused_iter(iterable):\n        while True:\n            # Continue to yield the same item until `next(i)` or `i.send(False)`\n            while (yield value):\n                pass\n    \"\"\"\n    node = astroid.extract_node(code)\n    assert bool(node.is_generator())\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_is_generator_for_yield_in_while", "none", "code", "def", "paused_iter", "iterable", "while", "true", "continue", "to", "yield", "the", "same", "item", "until", "next", "i", "or", "i", "send", "false", "while", "yield", "value", "pass", "node", "astroid", "extract_node", "code", "assert", "bool", "node", "is_generator"], "doc_len": 37}
{"doc_id": "tests/unittest_nodes.py::test_is_generator_for_yield_in_if", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_is_generator_for_yield_in_if", "text": "文件路径: tests/unittest_nodes.py\ndef test_is_generator_for_yield_in_if() -> None:\n    code = \"\"\"\n    import asyncio\n\n    def paused_iter(iterable):\n        if (yield from asyncio.sleep(0.01)):\n            pass\n            return\n    \"\"\"\n    node = astroid.extract_node(code)\n    assert bool(node.is_generator())\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_is_generator_for_yield_in_if", "none", "code", "import", "asyncio", "def", "paused_iter", "iterable", "if", "yield", "from", "asyncio", "sleep", "0", "01", "pass", "return", "node", "astroid", "extract_node", "code", "assert", "bool", "node", "is_generator"], "doc_len": 29}
{"doc_id": "tests/unittest_nodes.py::test_is_generator_for_yield_in_aug_assign", "file_path": "tests/unittest_nodes.py", "class_name": null, "func_name": "test_is_generator_for_yield_in_aug_assign", "text": "文件路径: tests/unittest_nodes.py\ndef test_is_generator_for_yield_in_aug_assign() -> None:\n    code = \"\"\"\n    def test():\n        buf = ''\n        while True:\n            buf += yield\n    \"\"\"\n    node = astroid.extract_node(code)\n    assert bool(node.is_generator())\n", "tokens": ["tests", "unittest_nodes", "py", "def", "test_is_generator_for_yield_in_aug_assign", "none", "code", "def", "test", "buf", "while", "true", "buf", "yield", "node", "astroid", "extract_node", "code", "assert", "bool", "node", "is_generator"], "doc_len": 22}
{"doc_id": "tests/unittest_nodes.py::TestPatternMatching.test_match_simple", "file_path": "tests/unittest_nodes.py", "class_name": "TestPatternMatching", "func_name": "test_match_simple", "text": "文件路径: tests/unittest_nodes.py, 类名: TestPatternMatching\n    def test_match_simple():\n        code = textwrap.dedent(\n            \"\"\"\n        match status:\n            case 200:\n                pass\n            case 401 | 402 | 403:\n                pass\n            case None:\n                pass\n            case _:\n                pass\n        \"\"\"\n        ).strip()\n        node = builder.extract_node(code)\n        assert node.as_string() == code\n        assert isinstance(node, nodes.Match)\n        assert isinstance(node.subject, nodes.Name)\n        assert node.subject.name == \"status\"\n        assert isinstance(node.cases, list) and len(node.cases) == 4\n        case0, case1, case2, case3 = node.cases\n        assert list(node.get_children()) == [node.subject, *node.cases]\n\n        assert isinstance(case0.pattern, nodes.MatchValue)\n        assert (\n            isinstance(case0.pattern.value, astroid.Const)\n            and case0.pattern.value.value == 200\n        )\n        assert list(case0.pattern.get_children()) == [case0.pattern.value]\n        assert case0.guard is None\n        assert isinstance(case0.body[0], astroid.Pass)\n        assert list(case0.get_children()) == [case0.pattern, case0.body[0]]\n\n        assert isinstance(case1.pattern, nodes.MatchOr)\n        assert (\n            isinstance(case1.pattern.patterns, list)\n            and len(case1.pattern.patterns) == 3\n        )\n        for i in range(3):\n            match_value = case1.pattern.patterns[i]\n            assert isinstance(match_value, nodes.MatchValue)\n            assert isinstance(match_value.value, nodes.Const)\n            assert match_value.value.value == (401, 402, 403)[i]\n        assert list(case1.pattern.get_children()) == case1.pattern.patterns\n\n        assert isinstance(case2.pattern, nodes.MatchSingleton)\n        assert case2.pattern.value is None\n        assert not list(case2.pattern.get_children())\n\n        assert isinstance(case3.pattern, nodes.MatchAs)\n        assert case3.pattern.name is None\n        assert case3.pattern.pattern is None\n        assert not list(case3.pattern.get_children())\n", "tokens": ["tests", "unittest_nodes", "py", "testpatternmatching", "def", "test_match_simple", "code", "textwrap", "dedent", "match", "status", "case", "200", "pass", "case", "401", "402", "403", "pass", "case", "none", "pass", "case", "_", "pass", "strip", "node", "builder", "extract_node", "code", "assert", "node", "as_string", "code", "assert", "isinstance", "node", "nodes", "match", "assert", "isinstance", "node", "subject", "nodes", "name", "assert", "node", "subject", "name", "status", "assert", "isinstance", "node", "cases", "list", "and", "len", "node", "cases", "4", "case0", "case1", "case2", "case3", "node", "cases", "assert", "list", "node", "get_children", "node", "subject", "node", "cases", "assert", "isinstance", "case0", "pattern", "nodes", "matchvalue", "assert", "isinstance", "case0", "pattern", "value", "astroid", "const", "and", "case0", "pattern", "value", "value", "200", "assert", "list", "case0", "pattern", "get_children", "case0", "pattern", "value", "assert", "case0", "guard", "is", "none", "assert", "isinstance", "case0", "body", "0", "astroid", "pass", "assert", "list", "case0", "get_children", "case0", "pattern", "case0", "body", "0", "assert", "isinstance", "case1", "pattern", "nodes", "matchor", "assert", "isinstance", "case1", "pattern", "patterns", "list", "and", "len", "case1", "pattern", "patterns", "3", "for", "i", "in", "range", "3", "match_value", "case1", "pattern", "patterns", "i", "assert", "isinstance", "match_value", "nodes", "matchvalue", "assert", "isinstance", "match_value", "value", "nodes", "const", "assert", "match_value", "value", "value", "401", "402", "403", "i", "assert", "list", "case1", "pattern", "get_children", "case1", "pattern", "patterns", "assert", "isinstance", "case2", "pattern", "nodes", "matchsingleton", "assert", "case2", "pattern", "value", "is", "none", "assert", "not", "list", "case2", "pattern", "get_children", "assert", "isinstance", "case3", "pattern", "nodes", "matchas", "assert", "case3", "pattern", "name", "is", "none", "assert", "case3", "pattern", "pattern", "is", "none", "assert", "not", "list", "case3", "pattern", "get_children"], "doc_len": 219}
{"doc_id": "tests/unittest_nodes.py::TestPatternMatching.test_match_sequence", "file_path": "tests/unittest_nodes.py", "class_name": "TestPatternMatching", "func_name": "test_match_sequence", "text": "文件路径: tests/unittest_nodes.py, 类名: TestPatternMatching\n    def test_match_sequence():\n        code = textwrap.dedent(\n            \"\"\"\n        match status:\n            case [x, 2, _, *rest] as y if x > 2:\n                pass\n        \"\"\"\n        ).strip()\n        node = builder.extract_node(code)\n        assert node.as_string() == code\n        assert isinstance(node, nodes.Match)\n        assert isinstance(node.cases, list) and len(node.cases) == 1\n        case = node.cases[0]\n\n        assert isinstance(case.pattern, nodes.MatchAs)\n        assert isinstance(case.pattern.name, nodes.AssignName)\n        assert case.pattern.name.name == \"y\"\n        assert list(case.pattern.get_children()) == [\n            case.pattern.pattern,\n            case.pattern.name,\n        ]\n        assert isinstance(case.guard, nodes.Compare)\n        assert isinstance(case.body[0], nodes.Pass)\n        assert list(case.get_children()) == [case.pattern, case.guard, case.body[0]]\n\n        pattern_seq = case.pattern.pattern\n        assert isinstance(pattern_seq, nodes.MatchSequence)\n        assert isinstance(pattern_seq.patterns, list) and len(pattern_seq.patterns) == 4\n        assert (\n            isinstance(pattern_seq.patterns[0], nodes.MatchAs)\n            and isinstance(pattern_seq.patterns[0].name, nodes.AssignName)\n            and pattern_seq.patterns[0].name.name == \"x\"\n            and pattern_seq.patterns[0].pattern is None\n        )\n        assert (\n            isinstance(pattern_seq.patterns[1], nodes.MatchValue)\n            and isinstance(pattern_seq.patterns[1].value, nodes.Const)\n            and pattern_seq.patterns[1].value.value == 2\n        )\n        assert (\n            isinstance(pattern_seq.patterns[2], nodes.MatchAs)\n            and pattern_seq.patterns[2].name is None\n        )\n        assert (\n            isinstance(pattern_seq.patterns[3], nodes.MatchStar)\n            and isinstance(pattern_seq.patterns[3].name, nodes.AssignName)\n            and pattern_seq.patterns[3].name.name == \"rest\"\n        )\n        assert list(pattern_seq.patterns[3].get_children()) == [\n            pattern_seq.patterns[3].name\n        ]\n        assert list(pattern_seq.get_children()) == pattern_seq.patterns\n", "tokens": ["tests", "unittest_nodes", "py", "testpatternmatching", "def", "test_match_sequence", "code", "textwrap", "dedent", "match", "status", "case", "x", "2", "_", "rest", "as", "y", "if", "x", "2", "pass", "strip", "node", "builder", "extract_node", "code", "assert", "node", "as_string", "code", "assert", "isinstance", "node", "nodes", "match", "assert", "isinstance", "node", "cases", "list", "and", "len", "node", "cases", "1", "case", "node", "cases", "0", "assert", "isinstance", "case", "pattern", "nodes", "matchas", "assert", "isinstance", "case", "pattern", "name", "nodes", "assignname", "assert", "case", "pattern", "name", "name", "y", "assert", "list", "case", "pattern", "get_children", "case", "pattern", "pattern", "case", "pattern", "name", "assert", "isinstance", "case", "guard", "nodes", "compare", "assert", "isinstance", "case", "body", "0", "nodes", "pass", "assert", "list", "case", "get_children", "case", "pattern", "case", "guard", "case", "body", "0", "pattern_seq", "case", "pattern", "pattern", "assert", "isinstance", "pattern_seq", "nodes", "matchsequence", "assert", "isinstance", "pattern_seq", "patterns", "list", "and", "len", "pattern_seq", "patterns", "4", "assert", "isinstance", "pattern_seq", "patterns", "0", "nodes", "matchas", "and", "isinstance", "pattern_seq", "patterns", "0", "name", "nodes", "assignname", "and", "pattern_seq", "patterns", "0", "name", "name", "x", "and", "pattern_seq", "patterns", "0", "pattern", "is", "none", "assert", "isinstance", "pattern_seq", "patterns", "1", "nodes", "matchvalue", "and", "isinstance", "pattern_seq", "patterns", "1", "value", "nodes", "const", "and", "pattern_seq", "patterns", "1", "value", "value", "2", "assert", "isinstance", "pattern_seq", "patterns", "2", "nodes", "matchas", "and", "pattern_seq", "patterns", "2", "name", "is", "none", "assert", "isinstance", "pattern_seq", "patterns", "3", "nodes", "matchstar", "and", "isinstance", "pattern_seq", "patterns", "3", "name", "nodes", "assignname", "and", "pattern_seq", "patterns", "3", "name", "name", "rest", "assert", "list", "pattern_seq", "patterns", "3", "get_children", "pattern_seq", "patterns", "3", "name", "assert", "list", "pattern_seq", "get_children", "pattern_seq", "patterns"], "doc_len": 226}
{"doc_id": "tests/unittest_nodes.py::TestPatternMatching.test_match_mapping", "file_path": "tests/unittest_nodes.py", "class_name": "TestPatternMatching", "func_name": "test_match_mapping", "text": "文件路径: tests/unittest_nodes.py, 类名: TestPatternMatching\n    def test_match_mapping():\n        code = textwrap.dedent(\n            \"\"\"\n        match status:\n            case {0: x, 1: _}:\n                pass\n            case {**rest}:\n                pass\n        \"\"\"\n        ).strip()\n        node = builder.extract_node(code)\n        assert node.as_string() == code\n        assert isinstance(node, nodes.Match)\n        assert isinstance(node.cases, list) and len(node.cases) == 2\n        case0, case1 = node.cases\n\n        assert isinstance(case0.pattern, nodes.MatchMapping)\n        assert case0.pattern.rest is None\n        assert isinstance(case0.pattern.keys, list) and len(case0.pattern.keys) == 2\n        assert (\n            isinstance(case0.pattern.patterns, list)\n            and len(case0.pattern.patterns) == 2\n        )\n        for i in range(2):\n            key = case0.pattern.keys[i]\n            assert isinstance(key, nodes.Const)\n            assert key.value == i\n            pattern = case0.pattern.patterns[i]\n            assert isinstance(pattern, nodes.MatchAs)\n            if i == 0:\n                assert isinstance(pattern.name, nodes.AssignName)\n                assert pattern.name.name == \"x\"\n            elif i == 1:\n                assert pattern.name is None\n        assert list(case0.pattern.get_children()) == [\n            *case0.pattern.keys,\n            *case0.pattern.patterns,\n        ]\n\n        assert isinstance(case1.pattern, nodes.MatchMapping)\n        assert isinstance(case1.pattern.rest, nodes.AssignName)\n        assert case1.pattern.rest.name == \"rest\"\n        assert isinstance(case1.pattern.keys, list) and len(case1.pattern.keys) == 0\n        assert (\n            isinstance(case1.pattern.patterns, list)\n            and len(case1.pattern.patterns) == 0\n        )\n        assert list(case1.pattern.get_children()) == [case1.pattern.rest]\n", "tokens": ["tests", "unittest_nodes", "py", "testpatternmatching", "def", "test_match_mapping", "code", "textwrap", "dedent", "match", "status", "case", "0", "x", "1", "_", "pass", "case", "rest", "pass", "strip", "node", "builder", "extract_node", "code", "assert", "node", "as_string", "code", "assert", "isinstance", "node", "nodes", "match", "assert", "isinstance", "node", "cases", "list", "and", "len", "node", "cases", "2", "case0", "case1", "node", "cases", "assert", "isinstance", "case0", "pattern", "nodes", "matchmapping", "assert", "case0", "pattern", "rest", "is", "none", "assert", "isinstance", "case0", "pattern", "keys", "list", "and", "len", "case0", "pattern", "keys", "2", "assert", "isinstance", "case0", "pattern", "patterns", "list", "and", "len", "case0", "pattern", "patterns", "2", "for", "i", "in", "range", "2", "key", "case0", "pattern", "keys", "i", "assert", "isinstance", "key", "nodes", "const", "assert", "key", "value", "i", "pattern", "case0", "pattern", "patterns", "i", "assert", "isinstance", "pattern", "nodes", "matchas", "if", "i", "0", "assert", "isinstance", "pattern", "name", "nodes", "assignname", "assert", "pattern", "name", "name", "x", "elif", "i", "1", "assert", "pattern", "name", "is", "none", "assert", "list", "case0", "pattern", "get_children", "case0", "pattern", "keys", "case0", "pattern", "patterns", "assert", "isinstance", "case1", "pattern", "nodes", "matchmapping", "assert", "isinstance", "case1", "pattern", "rest", "nodes", "assignname", "assert", "case1", "pattern", "rest", "name", "rest", "assert", "isinstance", "case1", "pattern", "keys", "list", "and", "len", "case1", "pattern", "keys", "0", "assert", "isinstance", "case1", "pattern", "patterns", "list", "and", "len", "case1", "pattern", "patterns", "0", "assert", "list", "case1", "pattern", "get_children", "case1", "pattern", "rest"], "doc_len": 197}
{"doc_id": "tests/unittest_nodes.py::TestPatternMatching.test_match_class", "file_path": "tests/unittest_nodes.py", "class_name": "TestPatternMatching", "func_name": "test_match_class", "text": "文件路径: tests/unittest_nodes.py, 类名: TestPatternMatching\n    def test_match_class():\n        code = textwrap.dedent(\n            \"\"\"\n        match x:\n            case Point2D(0, a):\n                pass\n            case Point3D(x=0, y=1, z=b):\n                pass\n        \"\"\"\n        ).strip()\n        node = builder.extract_node(code)\n        assert node.as_string() == code\n        assert isinstance(node, nodes.Match)\n        assert isinstance(node.cases, list) and len(node.cases) == 2\n        case0, case1 = node.cases\n\n        assert isinstance(case0.pattern, nodes.MatchClass)\n        assert isinstance(case0.pattern.cls, nodes.Name)\n        assert case0.pattern.cls.name == \"Point2D\"\n        assert (\n            isinstance(case0.pattern.patterns, list)\n            and len(case0.pattern.patterns) == 2\n        )\n        match_value = case0.pattern.patterns[0]\n        assert (\n            isinstance(match_value, nodes.MatchValue)\n            and isinstance(match_value.value, nodes.Const)\n            and match_value.value.value == 0\n        )\n        match_as = case0.pattern.patterns[1]\n        assert (\n            isinstance(match_as, nodes.MatchAs)\n            and match_as.pattern is None\n            and isinstance(match_as.name, nodes.AssignName)\n            and match_as.name.name == \"a\"\n        )\n        assert list(case0.pattern.get_children()) == [\n            case0.pattern.cls,\n            *case0.pattern.patterns,\n        ]\n\n        assert isinstance(case1.pattern, nodes.MatchClass)\n        assert isinstance(case1.pattern.cls, nodes.Name)\n        assert case1.pattern.cls.name == \"Point3D\"\n        assert (\n            isinstance(case1.pattern.patterns, list)\n            and len(case1.pattern.patterns) == 0\n        )\n        assert (\n            isinstance(case1.pattern.kwd_attrs, list)\n            and len(case1.pattern.kwd_attrs) == 3\n        )\n        assert (\n            isinstance(case1.pattern.kwd_patterns, list)\n            and len(case1.pattern.kwd_patterns) == 3\n        )\n        for i in range(2):\n            assert case1.pattern.kwd_attrs[i] == (\"x\", \"y\")[i]\n            kwd_pattern = case1.pattern.kwd_patterns[i]\n            assert isinstance(kwd_pattern, nodes.MatchValue)\n            assert isinstance(kwd_pattern.value, nodes.Const)\n            assert kwd_pattern.value.value == i\n        assert case1.pattern.kwd_attrs[2] == \"z\"\n        kwd_pattern = case1.pattern.kwd_patterns[2]\n        assert (\n            isinstance(kwd_pattern, nodes.MatchAs)\n            and kwd_pattern.pattern is None\n            and isinstance(kwd_pattern.name, nodes.AssignName)\n            and kwd_pattern.name.name == \"b\"\n        )\n        assert list(case1.pattern.get_children()) == [\n            case1.pattern.cls,\n            *case1.pattern.kwd_patterns,\n        ]\n", "tokens": ["tests", "unittest_nodes", "py", "testpatternmatching", "def", "test_match_class", "code", "textwrap", "dedent", "match", "x", "case", "point2d", "0", "a", "pass", "case", "point3d", "x", "0", "y", "1", "z", "b", "pass", "strip", "node", "builder", "extract_node", "code", "assert", "node", "as_string", "code", "assert", "isinstance", "node", "nodes", "match", "assert", "isinstance", "node", "cases", "list", "and", "len", "node", "cases", "2", "case0", "case1", "node", "cases", "assert", "isinstance", "case0", "pattern", "nodes", "matchclass", "assert", "isinstance", "case0", "pattern", "cls", "nodes", "name", "assert", "case0", "pattern", "cls", "name", "point2d", "assert", "isinstance", "case0", "pattern", "patterns", "list", "and", "len", "case0", "pattern", "patterns", "2", "match_value", "case0", "pattern", "patterns", "0", "assert", "isinstance", "match_value", "nodes", "matchvalue", "and", "isinstance", "match_value", "value", "nodes", "const", "and", "match_value", "value", "value", "0", "match_as", "case0", "pattern", "patterns", "1", "assert", "isinstance", "match_as", "nodes", "matchas", "and", "match_as", "pattern", "is", "none", "and", "isinstance", "match_as", "name", "nodes", "assignname", "and", "match_as", "name", "name", "a", "assert", "list", "case0", "pattern", "get_children", "case0", "pattern", "cls", "case0", "pattern", "patterns", "assert", "isinstance", "case1", "pattern", "nodes", "matchclass", "assert", "isinstance", "case1", "pattern", "cls", "nodes", "name", "assert", "case1", "pattern", "cls", "name", "point3d", "assert", "isinstance", "case1", "pattern", "patterns", "list", "and", "len", "case1", "pattern", "patterns", "0", "assert", "isinstance", "case1", "pattern", "kwd_attrs", "list", "and", "len", "case1", "pattern", "kwd_attrs", "3", "assert", "isinstance", "case1", "pattern", "kwd_patterns", "list", "and", "len", "case1", "pattern", "kwd_patterns", "3", "for", "i", "in", "range", "2", "assert", "case1", "pattern", "kwd_attrs", "i", "x", "y", "i", "kwd_pattern", "case1", "pattern", "kwd_patterns", "i", "assert", "isinstance", "kwd_pattern", "nodes", "matchvalue", "assert", "isinstance", "kwd_pattern", "value", "nodes", "const", "assert", "kwd_pattern", "value", "value", "i", "assert", "case1", "pattern", "kwd_attrs", "2", "z", "kwd_pattern", "case1", "pattern", "kwd_patterns", "2", "assert", "isinstance", "kwd_pattern", "nodes", "matchas", "and", "kwd_pattern", "pattern", "is", "none", "and", "isinstance", "kwd_pattern", "name", "nodes", "assignname", "and", "kwd_pattern", "name", "name", "b", "assert", "list", "case1", "pattern", "get_children", "case1", "pattern", "cls", "case1", "pattern", "kwd_patterns"], "doc_len": 274}
{"doc_id": "tests/unittest_nodes_lineno.py::TestEndLinenoNotSet.test_end_lineno_not_set", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestEndLinenoNotSet", "func_name": "test_end_lineno_not_set", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestEndLinenoNotSet\n    def test_end_lineno_not_set() -> None:\n        code = textwrap.dedent(\n            \"\"\"\n        [1, 2, 3]  #@\n        var  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        n1 = ast_nodes[0]\n        assert isinstance(n1, nodes.List)\n        assert (n1.lineno, n1.col_offset) == (1, 0)\n        assert (n1.end_lineno, n1.end_col_offset) == (None, None)\n\n        n2 = ast_nodes[1]\n        assert isinstance(n2, nodes.Name)\n        assert (n2.lineno, n2.col_offset) == (2, 0)\n        assert (n2.end_lineno, n2.end_col_offset) == (None, None)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testendlinenonotset", "def", "test_end_lineno_not_set", "none", "code", "textwrap", "dedent", "1", "2", "3", "var", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "n1", "ast_nodes", "0", "assert", "isinstance", "n1", "nodes", "list", "assert", "n1", "lineno", "n1", "col_offset", "1", "0", "assert", "n1", "end_lineno", "n1", "end_col_offset", "none", "none", "n2", "ast_nodes", "1", "assert", "isinstance", "n2", "nodes", "name", "assert", "n2", "lineno", "n2", "col_offset", "2", "0", "assert", "n2", "end_lineno", "n2", "end_col_offset", "none", "none"], "doc_len": 71}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_container", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_container", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_container() -> None:\n        \"\"\"Container nodes: List, Tuple, Set.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        [1, 2, 3]  #@\n        [  #@\n            1, 2, 3\n        ]\n        (1, 2, 3)  #@\n        {1, 2, 3}  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        c1 = ast_nodes[0]\n        assert isinstance(c1, nodes.List)\n        assert (c1.lineno, c1.col_offset) == (1, 0)\n        assert (c1.end_lineno, c1.end_col_offset) == (1, 9)\n\n        c2 = ast_nodes[1]\n        assert isinstance(c2, nodes.List)\n        assert (c2.lineno, c2.col_offset) == (2, 0)\n        assert (c2.end_lineno, c2.end_col_offset) == (4, 1)\n\n        c3 = ast_nodes[2]\n        assert isinstance(c3, nodes.Tuple)\n        assert (c3.lineno, c3.col_offset) == (5, 0)\n        assert (c3.end_lineno, c3.end_col_offset) == (5, 9)\n\n        c4 = ast_nodes[3]\n        assert isinstance(c4, nodes.Set)\n        assert (c4.lineno, c4.col_offset) == (6, 0)\n        assert (c4.end_lineno, c4.end_col_offset) == (6, 9)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_container", "none", "container", "nodes", "list", "tuple", "set", "code", "textwrap", "dedent", "1", "2", "3", "1", "2", "3", "1", "2", "3", "1", "2", "3", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "c1", "ast_nodes", "0", "assert", "isinstance", "c1", "nodes", "list", "assert", "c1", "lineno", "c1", "col_offset", "1", "0", "assert", "c1", "end_lineno", "c1", "end_col_offset", "1", "9", "c2", "ast_nodes", "1", "assert", "isinstance", "c2", "nodes", "list", "assert", "c2", "lineno", "c2", "col_offset", "2", "0", "assert", "c2", "end_lineno", "c2", "end_col_offset", "4", "1", "c3", "ast_nodes", "2", "assert", "isinstance", "c3", "nodes", "tuple", "assert", "c3", "lineno", "c3", "col_offset", "5", "0", "assert", "c3", "end_lineno", "c3", "end_col_offset", "5", "9", "c4", "ast_nodes", "3", "assert", "isinstance", "c4", "nodes", "set", "assert", "c4", "lineno", "c4", "col_offset", "6", "0", "assert", "c4", "end_lineno", "c4", "end_col_offset", "6", "9"], "doc_len": 128}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_name", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_name", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_name() -> None:\n        \"\"\"Name, Assign, AssignName, Delete, DelName.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        var = 42  #@\n        var  #@\n        del var  #@\n\n        var2 = (  #@\n            1, 2, 3\n        )\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        n1 = ast_nodes[0]\n        assert isinstance(n1, nodes.Assign)\n        assert isinstance(n1.targets[0], nodes.AssignName)\n        assert isinstance(n1.value, nodes.Const)\n        assert (n1.lineno, n1.col_offset) == (1, 0)\n        assert (n1.end_lineno, n1.end_col_offset) == (1, 8)\n        assert (n1.targets[0].lineno, n1.targets[0].col_offset) == (1, 0)\n        assert (n1.targets[0].end_lineno, n1.targets[0].end_col_offset) == (1, 3)\n        assert (n1.value.lineno, n1.value.col_offset) == (1, 6)\n        assert (n1.value.end_lineno, n1.value.end_col_offset) == (1, 8)\n\n        n2 = ast_nodes[1]\n        assert isinstance(n2, nodes.Name)\n        assert (n2.lineno, n2.col_offset) == (2, 0)\n        assert (n2.end_lineno, n2.end_col_offset) == (2, 3)\n\n        n3 = ast_nodes[2]\n        assert isinstance(n3, nodes.Delete) and isinstance(n3.targets[0], nodes.DelName)\n        assert (n3.lineno, n3.col_offset) == (3, 0)\n        assert (n3.end_lineno, n3.end_col_offset) == (3, 7)\n        assert (n3.targets[0].lineno, n3.targets[0].col_offset) == (3, 4)\n        assert (n3.targets[0].end_lineno, n3.targets[0].end_col_offset) == (3, 7)\n\n        n4 = ast_nodes[3]\n        assert isinstance(n4, nodes.Assign)\n        assert isinstance(n4.targets[0], nodes.AssignName)\n        assert (n4.lineno, n4.col_offset) == (5, 0)\n        assert (n4.end_lineno, n4.end_col_offset) == (7, 1)\n        assert (n4.targets[0].lineno, n4.targets[0].col_offset) == (5, 0)\n        assert (n4.targets[0].end_lineno, n4.targets[0].end_col_offset) == (5, 4)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_name", "none", "name", "assign", "assignname", "delete", "delname", "code", "textwrap", "dedent", "var", "42", "var", "del", "var", "var2", "1", "2", "3", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "n1", "ast_nodes", "0", "assert", "isinstance", "n1", "nodes", "assign", "assert", "isinstance", "n1", "targets", "0", "nodes", "assignname", "assert", "isinstance", "n1", "value", "nodes", "const", "assert", "n1", "lineno", "n1", "col_offset", "1", "0", "assert", "n1", "end_lineno", "n1", "end_col_offset", "1", "8", "assert", "n1", "targets", "0", "lineno", "n1", "targets", "0", "col_offset", "1", "0", "assert", "n1", "targets", "0", "end_lineno", "n1", "targets", "0", "end_col_offset", "1", "3", "assert", "n1", "value", "lineno", "n1", "value", "col_offset", "1", "6", "assert", "n1", "value", "end_lineno", "n1", "value", "end_col_offset", "1", "8", "n2", "ast_nodes", "1", "assert", "isinstance", "n2", "nodes", "name", "assert", "n2", "lineno", "n2", "col_offset", "2", "0", "assert", "n2", "end_lineno", "n2", "end_col_offset", "2", "3", "n3", "ast_nodes", "2", "assert", "isinstance", "n3", "nodes", "delete", "and", "isinstance", "n3", "targets", "0", "nodes", "delname", "assert", "n3", "lineno", "n3", "col_offset", "3", "0", "assert", "n3", "end_lineno", "n3", "end_col_offset", "3", "7", "assert", "n3", "targets", "0", "lineno", "n3", "targets", "0", "col_offset", "3", "4", "assert", "n3", "targets", "0", "end_lineno", "n3", "targets", "0", "end_col_offset", "3", "7", "n4", "ast_nodes", "3", "assert", "isinstance", "n4", "nodes", "assign", "assert", "isinstance", "n4", "targets", "0", "nodes", "assignname", "assert", "n4", "lineno", "n4", "col_offset", "5", "0", "assert", "n4", "end_lineno", "n4", "end_col_offset", "7", "1", "assert", "n4", "targets", "0", "lineno", "n4", "targets", "0", "col_offset", "5", "0", "assert", "n4", "targets", "0", "end_lineno", "n4", "targets", "0", "end_col_offset", "5", "4"], "doc_len": 236}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_attribute", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_attribute", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_attribute() -> None:\n        \"\"\"Attribute, AssignAttr, DelAttr.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        class X:\n            var = 42\n\n        X.var2 = 2  #@\n        X.var2  #@\n        del X.var2  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 3\n\n        a1 = ast_nodes[0]\n        assert isinstance(a1, nodes.Assign)\n        assert isinstance(a1.targets[0], nodes.AssignAttr)\n        assert isinstance(a1.value, nodes.Const)\n        assert (a1.lineno, a1.col_offset) == (4, 0)\n        assert (a1.end_lineno, a1.end_col_offset) == (4, 10)\n        assert (a1.targets[0].lineno, a1.targets[0].col_offset) == (4, 0)\n        assert (a1.targets[0].end_lineno, a1.targets[0].end_col_offset) == (4, 6)\n        assert (a1.value.lineno, a1.value.col_offset) == (4, 9)\n        assert (a1.value.end_lineno, a1.value.end_col_offset) == (4, 10)\n\n        a2 = ast_nodes[1]\n        assert isinstance(a2, nodes.Attribute) and isinstance(a2.expr, nodes.Name)\n        assert (a2.lineno, a2.col_offset) == (5, 0)\n        assert (a2.end_lineno, a2.end_col_offset) == (5, 6)\n        assert (a2.expr.lineno, a2.expr.col_offset) == (5, 0)\n        assert (a2.expr.end_lineno, a2.expr.end_col_offset) == (5, 1)\n\n        a3 = ast_nodes[2]\n        assert isinstance(a3, nodes.Delete) and isinstance(a3.targets[0], nodes.DelAttr)\n        assert (a3.lineno, a3.col_offset) == (6, 0)\n        assert (a3.end_lineno, a3.end_col_offset) == (6, 10)\n        assert (a3.targets[0].lineno, a3.targets[0].col_offset) == (6, 4)\n        assert (a3.targets[0].end_lineno, a3.targets[0].end_col_offset) == (6, 10)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_attribute", "none", "attribute", "assignattr", "delattr", "code", "textwrap", "dedent", "class", "x", "var", "42", "x", "var2", "2", "x", "var2", "del", "x", "var2", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "3", "a1", "ast_nodes", "0", "assert", "isinstance", "a1", "nodes", "assign", "assert", "isinstance", "a1", "targets", "0", "nodes", "assignattr", "assert", "isinstance", "a1", "value", "nodes", "const", "assert", "a1", "lineno", "a1", "col_offset", "4", "0", "assert", "a1", "end_lineno", "a1", "end_col_offset", "4", "10", "assert", "a1", "targets", "0", "lineno", "a1", "targets", "0", "col_offset", "4", "0", "assert", "a1", "targets", "0", "end_lineno", "a1", "targets", "0", "end_col_offset", "4", "6", "assert", "a1", "value", "lineno", "a1", "value", "col_offset", "4", "9", "assert", "a1", "value", "end_lineno", "a1", "value", "end_col_offset", "4", "10", "a2", "ast_nodes", "1", "assert", "isinstance", "a2", "nodes", "attribute", "and", "isinstance", "a2", "expr", "nodes", "name", "assert", "a2", "lineno", "a2", "col_offset", "5", "0", "assert", "a2", "end_lineno", "a2", "end_col_offset", "5", "6", "assert", "a2", "expr", "lineno", "a2", "expr", "col_offset", "5", "0", "assert", "a2", "expr", "end_lineno", "a2", "expr", "end_col_offset", "5", "1", "a3", "ast_nodes", "2", "assert", "isinstance", "a3", "nodes", "delete", "and", "isinstance", "a3", "targets", "0", "nodes", "delattr", "assert", "a3", "lineno", "a3", "col_offset", "6", "0", "assert", "a3", "end_lineno", "a3", "end_col_offset", "6", "10", "assert", "a3", "targets", "0", "lineno", "a3", "targets", "0", "col_offset", "6", "4", "assert", "a3", "targets", "0", "end_lineno", "a3", "targets", "0", "end_col_offset", "6", "10"], "doc_len": 210}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_call", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_call", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_call() -> None:\n        \"\"\"Call, Keyword.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        func(arg1, arg2=value)  #@\n        \"\"\"\n        ).strip()\n        c1 = builder.extract_node(code)\n        assert isinstance(c1, nodes.Call)\n        assert isinstance(c1.func, nodes.Name)\n        assert isinstance(c1.args[0], nodes.Name)\n        assert isinstance(c1.keywords[0], nodes.Keyword)\n        assert isinstance(c1.keywords[0].value, nodes.Name)\n\n        assert (c1.lineno, c1.col_offset) == (1, 0)\n        assert (c1.end_lineno, c1.end_col_offset) == (1, 22)\n        assert (c1.func.lineno, c1.func.col_offset) == (1, 0)\n        assert (c1.func.end_lineno, c1.func.end_col_offset) == (1, 4)\n\n        assert (c1.args[0].lineno, c1.args[0].col_offset) == (1, 5)\n        assert (c1.args[0].end_lineno, c1.args[0].end_col_offset) == (1, 9)\n\n        # fmt: off\n        if PY39_PLUS:\n            # 'lineno' and 'col_offset' information only added in Python 3.9\n            assert (c1.keywords[0].lineno, c1.keywords[0].col_offset) == (1, 11)\n            assert (c1.keywords[0].end_lineno, c1.keywords[0].end_col_offset) == (1, 21)\n        else:\n            assert (c1.keywords[0].lineno, c1.keywords[0].col_offset) == (None, None)\n            assert (c1.keywords[0].end_lineno, c1.keywords[0].end_col_offset) == (None, None)\n        assert (c1.keywords[0].value.lineno, c1.keywords[0].value.col_offset) == (1, 16)\n        assert (c1.keywords[0].value.end_lineno, c1.keywords[0].value.end_col_offset) == (1, 21)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_call", "none", "call", "keyword", "code", "textwrap", "dedent", "func", "arg1", "arg2", "value", "strip", "c1", "builder", "extract_node", "code", "assert", "isinstance", "c1", "nodes", "call", "assert", "isinstance", "c1", "func", "nodes", "name", "assert", "isinstance", "c1", "args", "0", "nodes", "name", "assert", "isinstance", "c1", "keywords", "0", "nodes", "keyword", "assert", "isinstance", "c1", "keywords", "0", "value", "nodes", "name", "assert", "c1", "lineno", "c1", "col_offset", "1", "0", "assert", "c1", "end_lineno", "c1", "end_col_offset", "1", "22", "assert", "c1", "func", "lineno", "c1", "func", "col_offset", "1", "0", "assert", "c1", "func", "end_lineno", "c1", "func", "end_col_offset", "1", "4", "assert", "c1", "args", "0", "lineno", "c1", "args", "0", "col_offset", "1", "5", "assert", "c1", "args", "0", "end_lineno", "c1", "args", "0", "end_col_offset", "1", "9", "fmt", "off", "if", "py39_plus", "lineno", "and", "col_offset", "information", "only", "added", "in", "python", "3", "9", "assert", "c1", "keywords", "0", "lineno", "c1", "keywords", "0", "col_offset", "1", "11", "assert", "c1", "keywords", "0", "end_lineno", "c1", "keywords", "0", "end_col_offset", "1", "21", "else", "assert", "c1", "keywords", "0", "lineno", "c1", "keywords", "0", "col_offset", "none", "none", "assert", "c1", "keywords", "0", "end_lineno", "c1", "keywords", "0", "end_col_offset", "none", "none", "assert", "c1", "keywords", "0", "value", "lineno", "c1", "keywords", "0", "value", "col_offset", "1", "16", "assert", "c1", "keywords", "0", "value", "end_lineno", "c1", "keywords", "0", "value", "end_col_offset", "1", "21"], "doc_len": 193}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_assignment", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_assignment", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_assignment() -> None:\n        \"\"\"Assign, AnnAssign, AugAssign.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        var = 2  #@\n        var2: int = 2  #@\n        var3 += 2  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 3\n\n        a1 = ast_nodes[0]\n        assert isinstance(a1, nodes.Assign)\n        assert isinstance(a1.targets[0], nodes.AssignName)\n        assert isinstance(a1.value, nodes.Const)\n        assert (a1.lineno, a1.col_offset) == (1, 0)\n        assert (a1.end_lineno, a1.end_col_offset) == (1, 7)\n        assert (a1.targets[0].lineno, a1.targets[0].col_offset) == (1, 0)\n        assert (a1.targets[0].end_lineno, a1.targets[0].end_col_offset) == (1, 3)\n        assert (a1.value.lineno, a1.value.col_offset) == (1, 6)\n        assert (a1.value.end_lineno, a1.value.end_col_offset) == (1, 7)\n\n        a2 = ast_nodes[1]\n        assert isinstance(a2, nodes.AnnAssign)\n        assert isinstance(a2.target, nodes.AssignName)\n        assert isinstance(a2.annotation, nodes.Name)\n        assert isinstance(a2.value, nodes.Const)\n        assert (a2.lineno, a2.col_offset) == (2, 0)\n        assert (a2.end_lineno, a2.end_col_offset) == (2, 13)\n        assert (a2.target.lineno, a2.target.col_offset) == (2, 0)\n        assert (a2.target.end_lineno, a2.target.end_col_offset) == (2, 4)\n        assert (a2.annotation.lineno, a2.annotation.col_offset) == (2, 6)\n        assert (a2.annotation.end_lineno, a2.annotation.end_col_offset) == (2, 9)\n        assert (a2.value.lineno, a2.value.col_offset) == (2, 12)\n        assert (a2.value.end_lineno, a2.value.end_col_offset) == (2, 13)\n\n        a3 = ast_nodes[2]\n        assert isinstance(a3, nodes.AugAssign)\n        assert isinstance(a3.target, nodes.AssignName)\n        assert isinstance(a3.value, nodes.Const)\n        assert (a3.lineno, a3.col_offset) == (3, 0)\n        assert (a3.end_lineno, a3.end_col_offset) == (3, 9)\n        assert (a3.target.lineno, a3.target.col_offset) == (3, 0)\n        assert (a3.target.end_lineno, a3.target.end_col_offset) == (3, 4)\n        assert (a3.value.lineno, a3.value.col_offset) == (3, 8)\n        assert (a3.value.end_lineno, a3.value.end_col_offset) == (3, 9)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_assignment", "none", "assign", "annassign", "augassign", "code", "textwrap", "dedent", "var", "2", "var2", "int", "2", "var3", "2", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "3", "a1", "ast_nodes", "0", "assert", "isinstance", "a1", "nodes", "assign", "assert", "isinstance", "a1", "targets", "0", "nodes", "assignname", "assert", "isinstance", "a1", "value", "nodes", "const", "assert", "a1", "lineno", "a1", "col_offset", "1", "0", "assert", "a1", "end_lineno", "a1", "end_col_offset", "1", "7", "assert", "a1", "targets", "0", "lineno", "a1", "targets", "0", "col_offset", "1", "0", "assert", "a1", "targets", "0", "end_lineno", "a1", "targets", "0", "end_col_offset", "1", "3", "assert", "a1", "value", "lineno", "a1", "value", "col_offset", "1", "6", "assert", "a1", "value", "end_lineno", "a1", "value", "end_col_offset", "1", "7", "a2", "ast_nodes", "1", "assert", "isinstance", "a2", "nodes", "annassign", "assert", "isinstance", "a2", "target", "nodes", "assignname", "assert", "isinstance", "a2", "annotation", "nodes", "name", "assert", "isinstance", "a2", "value", "nodes", "const", "assert", "a2", "lineno", "a2", "col_offset", "2", "0", "assert", "a2", "end_lineno", "a2", "end_col_offset", "2", "13", "assert", "a2", "target", "lineno", "a2", "target", "col_offset", "2", "0", "assert", "a2", "target", "end_lineno", "a2", "target", "end_col_offset", "2", "4", "assert", "a2", "annotation", "lineno", "a2", "annotation", "col_offset", "2", "6", "assert", "a2", "annotation", "end_lineno", "a2", "annotation", "end_col_offset", "2", "9", "assert", "a2", "value", "lineno", "a2", "value", "col_offset", "2", "12", "assert", "a2", "value", "end_lineno", "a2", "value", "end_col_offset", "2", "13", "a3", "ast_nodes", "2", "assert", "isinstance", "a3", "nodes", "augassign", "assert", "isinstance", "a3", "target", "nodes", "assignname", "assert", "isinstance", "a3", "value", "nodes", "const", "assert", "a3", "lineno", "a3", "col_offset", "3", "0", "assert", "a3", "end_lineno", "a3", "end_col_offset", "3", "9", "assert", "a3", "target", "lineno", "a3", "target", "col_offset", "3", "0", "assert", "a3", "target", "end_lineno", "a3", "target", "end_col_offset", "3", "4", "assert", "a3", "value", "lineno", "a3", "value", "col_offset", "3", "8", "assert", "a3", "value", "end_lineno", "a3", "value", "end_col_offset", "3", "9"], "doc_len": 272}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_mix_stmts", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_mix_stmts", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_mix_stmts() -> None:\n        \"\"\"Assert, Break, Continue, Global, Nonlocal, Pass, Raise, Return, Expr.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        assert True, \"Some message\"  #@\n        break  #@\n        continue  #@\n        global var  #@\n        nonlocal var  #@\n        pass  #@\n        raise Exception from ex  #@\n        return 42  #@\n        var  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 9\n\n        s1 = ast_nodes[0]\n        assert isinstance(s1, nodes.Assert)\n        assert isinstance(s1.test, nodes.Const)\n        assert isinstance(s1.fail, nodes.Const)\n        assert (s1.lineno, s1.col_offset) == (1, 0)\n        assert (s1.end_lineno, s1.end_col_offset) == (1, 27)\n        assert (s1.test.lineno, s1.test.col_offset) == (1, 7)\n        assert (s1.test.end_lineno, s1.test.end_col_offset) == (1, 11)\n        assert (s1.fail.lineno, s1.fail.col_offset) == (1, 13)\n        assert (s1.fail.end_lineno, s1.fail.end_col_offset) == (1, 27)\n\n        s2 = ast_nodes[1]\n        assert isinstance(s2, nodes.Break)\n        assert (s2.lineno, s2.col_offset) == (2, 0)\n        assert (s2.end_lineno, s2.end_col_offset) == (2, 5)\n\n        s3 = ast_nodes[2]\n        assert isinstance(s3, nodes.Continue)\n        assert (s3.lineno, s3.col_offset) == (3, 0)\n        assert (s3.end_lineno, s3.end_col_offset) == (3, 8)\n\n        s4 = ast_nodes[3]\n        assert isinstance(s4, nodes.Global)\n        assert (s4.lineno, s4.col_offset) == (4, 0)\n        assert (s4.end_lineno, s4.end_col_offset) == (4, 10)\n\n        s5 = ast_nodes[4]\n        assert isinstance(s5, nodes.Nonlocal)\n        assert (s5.lineno, s5.col_offset) == (5, 0)\n        assert (s5.end_lineno, s5.end_col_offset) == (5, 12)\n\n        s6 = ast_nodes[5]\n        assert isinstance(s6, nodes.Pass)\n        assert (s6.lineno, s6.col_offset) == (6, 0)\n        assert (s6.end_lineno, s6.end_col_offset) == (6, 4)\n\n        s7 = ast_nodes[6]\n        assert isinstance(s7, nodes.Raise)\n        assert isinstance(s7.exc, nodes.Name)\n        assert isinstance(s7.cause, nodes.Name)\n        assert (s7.lineno, s7.col_offset) == (7, 0)\n        assert (s7.end_lineno, s7.end_col_offset) == (7, 23)\n        assert (s7.exc.lineno, s7.exc.col_offset) == (7, 6)\n        assert (s7.exc.end_lineno, s7.exc.end_col_offset) == (7, 15)\n        assert (s7.cause.lineno, s7.cause.col_offset) == (7, 21)\n        assert (s7.cause.end_lineno, s7.cause.end_col_offset) == (7, 23)\n\n        s8 = ast_nodes[7]\n        assert isinstance(s8, nodes.Return)\n        assert isinstance(s8.value, nodes.Const)\n        assert (s8.lineno, s8.col_offset) == (8, 0)\n        assert (s8.end_lineno, s8.end_col_offset) == (8, 9)\n        assert (s8.value.lineno, s8.value.col_offset) == (8, 7)\n        assert (s8.value.end_lineno, s8.value.end_col_offset) == (8, 9)\n\n        s9 = ast_nodes[8].parent\n        assert isinstance(s9, nodes.Expr)\n        assert isinstance(s9.value, nodes.Name)\n        assert (s9.lineno, s9.col_offset) == (9, 0)\n        assert (s9.end_lineno, s9.end_col_offset) == (9, 3)\n        assert (s9.value.lineno, s9.value.col_offset) == (9, 0)\n        assert (s9.value.end_lineno, s9.value.end_col_offset) == (9, 3)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_mix_stmts", "none", "assert", "break", "continue", "global", "nonlocal", "pass", "raise", "return", "expr", "code", "textwrap", "dedent", "assert", "true", "some", "message", "break", "continue", "global", "var", "nonlocal", "var", "pass", "raise", "exception", "from", "ex", "return", "42", "var", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "9", "s1", "ast_nodes", "0", "assert", "isinstance", "s1", "nodes", "assert", "assert", "isinstance", "s1", "test", "nodes", "const", "assert", "isinstance", "s1", "fail", "nodes", "const", "assert", "s1", "lineno", "s1", "col_offset", "1", "0", "assert", "s1", "end_lineno", "s1", "end_col_offset", "1", "27", "assert", "s1", "test", "lineno", "s1", "test", "col_offset", "1", "7", "assert", "s1", "test", "end_lineno", "s1", "test", "end_col_offset", "1", "11", "assert", "s1", "fail", "lineno", "s1", "fail", "col_offset", "1", "13", "assert", "s1", "fail", "end_lineno", "s1", "fail", "end_col_offset", "1", "27", "s2", "ast_nodes", "1", "assert", "isinstance", "s2", "nodes", "break", "assert", "s2", "lineno", "s2", "col_offset", "2", "0", "assert", "s2", "end_lineno", "s2", "end_col_offset", "2", "5", "s3", "ast_nodes", "2", "assert", "isinstance", "s3", "nodes", "continue", "assert", "s3", "lineno", "s3", "col_offset", "3", "0", "assert", "s3", "end_lineno", "s3", "end_col_offset", "3", "8", "s4", "ast_nodes", "3", "assert", "isinstance", "s4", "nodes", "global", "assert", "s4", "lineno", "s4", "col_offset", "4", "0", "assert", "s4", "end_lineno", "s4", "end_col_offset", "4", "10", "s5", "ast_nodes", "4", "assert", "isinstance", "s5", "nodes", "nonlocal", "assert", "s5", "lineno", "s5", "col_offset", "5", "0", "assert", "s5", "end_lineno", "s5", "end_col_offset", "5", "12", "s6", "ast_nodes", "5", "assert", "isinstance", "s6", "nodes", "pass", "assert", "s6", "lineno", "s6", "col_offset", "6", "0", "assert", "s6", "end_lineno", "s6", "end_col_offset", "6", "4", "s7", "ast_nodes", "6", "assert", "isinstance", "s7", "nodes", "raise", "assert", "isinstance", "s7", "exc", "nodes", "name", "assert", "isinstance", "s7", "cause", "nodes", "name", "assert", "s7", "lineno", "s7", "col_offset", "7", "0", "assert", "s7", "end_lineno", "s7", "end_col_offset", "7", "23", "assert", "s7", "exc", "lineno", "s7", "exc", "col_offset", "7", "6", "assert", "s7", "exc", "end_lineno", "s7", "exc", "end_col_offset", "7", "15", "assert", "s7", "cause", "lineno", "s7", "cause", "col_offset", "7", "21", "assert", "s7", "cause", "end_lineno", "s7", "cause", "end_col_offset", "7", "23", "s8", "ast_nodes", "7", "assert", "isinstance", "s8", "nodes", "return", "assert", "isinstance", "s8", "value", "nodes", "const", "assert", "s8", "lineno", "s8", "col_offset", "8", "0", "assert", "s8", "end_lineno", "s8", "end_col_offset", "8", "9", "assert", "s8", "value", "lineno", "s8", "value", "col_offset", "8", "7", "assert", "s8", "value", "end_lineno", "s8", "value", "end_col_offset", "8", "9", "s9", "ast_nodes", "8", "parent", "assert", "isinstance", "s9", "nodes", "expr", "assert", "isinstance", "s9", "value", "nodes", "name", "assert", "s9", "lineno", "s9", "col_offset", "9", "0", "assert", "s9", "end_lineno", "s9", "end_col_offset", "9", "3", "assert", "s9", "value", "lineno", "s9", "value", "col_offset", "9", "0", "assert", "s9", "value", "end_lineno", "s9", "value", "end_col_offset", "9", "3"], "doc_len": 393}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_mix_nodes", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_mix_nodes", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_mix_nodes() -> None:\n        \"\"\"Await, Starred, Yield, YieldFrom.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        await func  #@\n        *args  #@\n        yield 42  #@\n        yield from (1, 2)  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        n1 = ast_nodes[0]\n        assert isinstance(n1, nodes.Await)\n        assert isinstance(n1.value, nodes.Name)\n        assert (n1.lineno, n1.col_offset) == (1, 0)\n        assert (n1.end_lineno, n1.end_col_offset) == (1, 10)\n        assert (n1.value.lineno, n1.value.col_offset) == (1, 6)\n        assert (n1.value.end_lineno, n1.value.end_col_offset) == (1, 10)\n\n        n2 = ast_nodes[1]\n        assert isinstance(n2, nodes.Starred)\n        assert isinstance(n2.value, nodes.Name)\n        assert (n2.lineno, n2.col_offset) == (2, 0)\n        assert (n2.end_lineno, n2.end_col_offset) == (2, 5)\n        assert (n2.value.lineno, n2.value.col_offset) == (2, 1)\n        assert (n2.value.end_lineno, n2.value.end_col_offset) == (2, 5)\n\n        n3 = ast_nodes[2]\n        assert isinstance(n3, nodes.Yield)\n        assert isinstance(n3.value, nodes.Const)\n        assert (n3.lineno, n3.col_offset) == (3, 0)\n        assert (n3.end_lineno, n3.end_col_offset) == (3, 8)\n        assert (n3.value.lineno, n3.value.col_offset) == (3, 6)\n        assert (n3.value.end_lineno, n3.value.end_col_offset) == (3, 8)\n\n        n4 = ast_nodes[3]\n        assert isinstance(n4, nodes.YieldFrom)\n        assert isinstance(n4.value, nodes.Tuple)\n        assert (n4.lineno, n4.col_offset) == (4, 0)\n        assert (n4.end_lineno, n4.end_col_offset) == (4, 17)\n        assert (n4.value.lineno, n4.value.col_offset) == (4, 11)\n        assert (n4.value.end_lineno, n4.value.end_col_offset) == (4, 17)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_mix_nodes", "none", "await", "starred", "yield", "yieldfrom", "code", "textwrap", "dedent", "await", "func", "args", "yield", "42", "yield", "from", "1", "2", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "n1", "ast_nodes", "0", "assert", "isinstance", "n1", "nodes", "await", "assert", "isinstance", "n1", "value", "nodes", "name", "assert", "n1", "lineno", "n1", "col_offset", "1", "0", "assert", "n1", "end_lineno", "n1", "end_col_offset", "1", "10", "assert", "n1", "value", "lineno", "n1", "value", "col_offset", "1", "6", "assert", "n1", "value", "end_lineno", "n1", "value", "end_col_offset", "1", "10", "n2", "ast_nodes", "1", "assert", "isinstance", "n2", "nodes", "starred", "assert", "isinstance", "n2", "value", "nodes", "name", "assert", "n2", "lineno", "n2", "col_offset", "2", "0", "assert", "n2", "end_lineno", "n2", "end_col_offset", "2", "5", "assert", "n2", "value", "lineno", "n2", "value", "col_offset", "2", "1", "assert", "n2", "value", "end_lineno", "n2", "value", "end_col_offset", "2", "5", "n3", "ast_nodes", "2", "assert", "isinstance", "n3", "nodes", "yield", "assert", "isinstance", "n3", "value", "nodes", "const", "assert", "n3", "lineno", "n3", "col_offset", "3", "0", "assert", "n3", "end_lineno", "n3", "end_col_offset", "3", "8", "assert", "n3", "value", "lineno", "n3", "value", "col_offset", "3", "6", "assert", "n3", "value", "end_lineno", "n3", "value", "end_col_offset", "3", "8", "n4", "ast_nodes", "3", "assert", "isinstance", "n4", "nodes", "yieldfrom", "assert", "isinstance", "n4", "value", "nodes", "tuple", "assert", "n4", "lineno", "n4", "col_offset", "4", "0", "assert", "n4", "end_lineno", "n4", "end_col_offset", "4", "17", "assert", "n4", "value", "lineno", "n4", "value", "col_offset", "4", "11", "assert", "n4", "value", "end_lineno", "n4", "value", "end_col_offset", "4", "17"], "doc_len": 220}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_ops", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_ops", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_ops() -> None:\n        \"\"\"BinOp, BoolOp, UnaryOp, Compare.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        x + y  #@\n        a and b  #@\n        -var  #@\n        a < b  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        o1 = ast_nodes[0]\n        assert isinstance(o1, nodes.BinOp)\n        assert isinstance(o1.left, nodes.Name)\n        assert isinstance(o1.right, nodes.Name)\n        assert (o1.lineno, o1.col_offset) == (1, 0)\n        assert (o1.end_lineno, o1.end_col_offset) == (1, 5)\n        assert (o1.left.lineno, o1.left.col_offset) == (1, 0)\n        assert (o1.left.end_lineno, o1.left.end_col_offset) == (1, 1)\n        assert (o1.right.lineno, o1.right.col_offset) == (1, 4)\n        assert (o1.right.end_lineno, o1.right.end_col_offset) == (1, 5)\n\n        o2 = ast_nodes[1]\n        assert isinstance(o2, nodes.BoolOp)\n        assert isinstance(o2.values[0], nodes.Name)\n        assert isinstance(o2.values[1], nodes.Name)\n        assert (o2.lineno, o2.col_offset) == (2, 0)\n        assert (o2.end_lineno, o2.end_col_offset) == (2, 7)\n        assert (o2.values[0].lineno, o2.values[0].col_offset) == (2, 0)\n        assert (o2.values[0].end_lineno, o2.values[0].end_col_offset) == (2, 1)\n        assert (o2.values[1].lineno, o2.values[1].col_offset) == (2, 6)\n        assert (o2.values[1].end_lineno, o2.values[1].end_col_offset) == (2, 7)\n\n        o3 = ast_nodes[2]\n        assert isinstance(o3, nodes.UnaryOp)\n        assert isinstance(o3.operand, nodes.Name)\n        assert (o3.lineno, o3.col_offset) == (3, 0)\n        assert (o3.end_lineno, o3.end_col_offset) == (3, 4)\n        assert (o3.operand.lineno, o3.operand.col_offset) == (3, 1)\n        assert (o3.operand.end_lineno, o3.operand.end_col_offset) == (3, 4)\n\n        o4 = ast_nodes[3]\n        assert isinstance(o4, nodes.Compare)\n        assert isinstance(o4.left, nodes.Name)\n        assert isinstance(o4.ops[0][1], nodes.Name)\n        assert (o4.lineno, o4.col_offset) == (4, 0)\n        assert (o4.end_lineno, o4.end_col_offset) == (4, 5)\n        assert (o4.left.lineno, o4.left.col_offset) == (4, 0)\n        assert (o4.left.end_lineno, o4.left.end_col_offset) == (4, 1)\n        assert (o4.ops[0][1].lineno, o4.ops[0][1].col_offset) == (4, 4)\n        assert (o4.ops[0][1].end_lineno, o4.ops[0][1].end_col_offset) == (4, 5)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_ops", "none", "binop", "boolop", "unaryop", "compare", "code", "textwrap", "dedent", "x", "y", "a", "and", "b", "var", "a", "b", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "o1", "ast_nodes", "0", "assert", "isinstance", "o1", "nodes", "binop", "assert", "isinstance", "o1", "left", "nodes", "name", "assert", "isinstance", "o1", "right", "nodes", "name", "assert", "o1", "lineno", "o1", "col_offset", "1", "0", "assert", "o1", "end_lineno", "o1", "end_col_offset", "1", "5", "assert", "o1", "left", "lineno", "o1", "left", "col_offset", "1", "0", "assert", "o1", "left", "end_lineno", "o1", "left", "end_col_offset", "1", "1", "assert", "o1", "right", "lineno", "o1", "right", "col_offset", "1", "4", "assert", "o1", "right", "end_lineno", "o1", "right", "end_col_offset", "1", "5", "o2", "ast_nodes", "1", "assert", "isinstance", "o2", "nodes", "boolop", "assert", "isinstance", "o2", "values", "0", "nodes", "name", "assert", "isinstance", "o2", "values", "1", "nodes", "name", "assert", "o2", "lineno", "o2", "col_offset", "2", "0", "assert", "o2", "end_lineno", "o2", "end_col_offset", "2", "7", "assert", "o2", "values", "0", "lineno", "o2", "values", "0", "col_offset", "2", "0", "assert", "o2", "values", "0", "end_lineno", "o2", "values", "0", "end_col_offset", "2", "1", "assert", "o2", "values", "1", "lineno", "o2", "values", "1", "col_offset", "2", "6", "assert", "o2", "values", "1", "end_lineno", "o2", "values", "1", "end_col_offset", "2", "7", "o3", "ast_nodes", "2", "assert", "isinstance", "o3", "nodes", "unaryop", "assert", "isinstance", "o3", "operand", "nodes", "name", "assert", "o3", "lineno", "o3", "col_offset", "3", "0", "assert", "o3", "end_lineno", "o3", "end_col_offset", "3", "4", "assert", "o3", "operand", "lineno", "o3", "operand", "col_offset", "3", "1", "assert", "o3", "operand", "end_lineno", "o3", "operand", "end_col_offset", "3", "4", "o4", "ast_nodes", "3", "assert", "isinstance", "o4", "nodes", "compare", "assert", "isinstance", "o4", "left", "nodes", "name", "assert", "isinstance", "o4", "ops", "0", "1", "nodes", "name", "assert", "o4", "lineno", "o4", "col_offset", "4", "0", "assert", "o4", "end_lineno", "o4", "end_col_offset", "4", "5", "assert", "o4", "left", "lineno", "o4", "left", "col_offset", "4", "0", "assert", "o4", "left", "end_lineno", "o4", "left", "end_col_offset", "4", "1", "assert", "o4", "ops", "0", "1", "lineno", "o4", "ops", "0", "1", "col_offset", "4", "4", "assert", "o4", "ops", "0", "1", "end_lineno", "o4", "ops", "0", "1", "end_col_offset", "4", "5"], "doc_len": 311}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_if", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_if", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_if() -> None:\n        \"\"\"If, IfExp, NamedExpr.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        if (  #@\n            var := 2  #@\n        ):\n            pass\n        else:\n            pass\n\n        2 if True else 1  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 3\n\n        i1 = ast_nodes[0]\n        assert isinstance(i1, nodes.If)\n        assert isinstance(i1.test, nodes.NamedExpr)\n        assert isinstance(i1.body[0], nodes.Pass)\n        assert isinstance(i1.orelse[0], nodes.Pass)\n        assert (i1.lineno, i1.col_offset) == (1, 0)\n        assert (i1.end_lineno, i1.end_col_offset) == (6, 8)\n        assert (i1.test.lineno, i1.test.col_offset) == (2, 4)\n        assert (i1.test.end_lineno, i1.test.end_col_offset) == (2, 12)\n        assert (i1.body[0].lineno, i1.body[0].col_offset) == (4, 4)\n        assert (i1.body[0].end_lineno, i1.body[0].end_col_offset) == (4, 8)\n        assert (i1.orelse[0].lineno, i1.orelse[0].col_offset) == (6, 4)\n        assert (i1.orelse[0].end_lineno, i1.orelse[0].end_col_offset) == (6, 8)\n\n        i2 = ast_nodes[1]\n        assert isinstance(i2, nodes.NamedExpr)\n        assert isinstance(i2.target, nodes.AssignName)\n        assert isinstance(i2.value, nodes.Const)\n        assert (i2.lineno, i2.col_offset) == (2, 4)\n        assert (i2.end_lineno, i2.end_col_offset) == (2, 12)\n        assert (i2.target.lineno, i2.target.col_offset) == (2, 4)\n        assert (i2.target.end_lineno, i2.target.end_col_offset) == (2, 7)\n        assert (i2.value.lineno, i2.value.col_offset) == (2, 11)\n        assert (i2.value.end_lineno, i2.value.end_col_offset) == (2, 12)\n\n        i3 = ast_nodes[2]\n        assert isinstance(i3, nodes.IfExp)\n        assert isinstance(i3.test, nodes.Const)\n        assert isinstance(i3.body, nodes.Const)\n        assert isinstance(i3.orelse, nodes.Const)\n        assert (i3.lineno, i3.col_offset) == (8, 0)\n        assert (i3.end_lineno, i3.end_col_offset) == (8, 16)\n        assert (i3.test.lineno, i3.test.col_offset) == (8, 5)\n        assert (i3.test.end_lineno, i3.test.end_col_offset) == (8, 9)\n        assert (i3.body.lineno, i3.body.col_offset) == (8, 0)\n        assert (i3.body.end_lineno, i3.body.end_col_offset) == (8, 1)\n        assert (i3.orelse.lineno, i3.orelse.col_offset) == (8, 15)\n        assert (i3.orelse.end_lineno, i3.orelse.end_col_offset) == (8, 16)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_if", "none", "if", "ifexp", "namedexpr", "code", "textwrap", "dedent", "if", "var", "2", "pass", "else", "pass", "2", "if", "true", "else", "1", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "3", "i1", "ast_nodes", "0", "assert", "isinstance", "i1", "nodes", "if", "assert", "isinstance", "i1", "test", "nodes", "namedexpr", "assert", "isinstance", "i1", "body", "0", "nodes", "pass", "assert", "isinstance", "i1", "orelse", "0", "nodes", "pass", "assert", "i1", "lineno", "i1", "col_offset", "1", "0", "assert", "i1", "end_lineno", "i1", "end_col_offset", "6", "8", "assert", "i1", "test", "lineno", "i1", "test", "col_offset", "2", "4", "assert", "i1", "test", "end_lineno", "i1", "test", "end_col_offset", "2", "12", "assert", "i1", "body", "0", "lineno", "i1", "body", "0", "col_offset", "4", "4", "assert", "i1", "body", "0", "end_lineno", "i1", "body", "0", "end_col_offset", "4", "8", "assert", "i1", "orelse", "0", "lineno", "i1", "orelse", "0", "col_offset", "6", "4", "assert", "i1", "orelse", "0", "end_lineno", "i1", "orelse", "0", "end_col_offset", "6", "8", "i2", "ast_nodes", "1", "assert", "isinstance", "i2", "nodes", "namedexpr", "assert", "isinstance", "i2", "target", "nodes", "assignname", "assert", "isinstance", "i2", "value", "nodes", "const", "assert", "i2", "lineno", "i2", "col_offset", "2", "4", "assert", "i2", "end_lineno", "i2", "end_col_offset", "2", "12", "assert", "i2", "target", "lineno", "i2", "target", "col_offset", "2", "4", "assert", "i2", "target", "end_lineno", "i2", "target", "end_col_offset", "2", "7", "assert", "i2", "value", "lineno", "i2", "value", "col_offset", "2", "11", "assert", "i2", "value", "end_lineno", "i2", "value", "end_col_offset", "2", "12", "i3", "ast_nodes", "2", "assert", "isinstance", "i3", "nodes", "ifexp", "assert", "isinstance", "i3", "test", "nodes", "const", "assert", "isinstance", "i3", "body", "nodes", "const", "assert", "isinstance", "i3", "orelse", "nodes", "const", "assert", "i3", "lineno", "i3", "col_offset", "8", "0", "assert", "i3", "end_lineno", "i3", "end_col_offset", "8", "16", "assert", "i3", "test", "lineno", "i3", "test", "col_offset", "8", "5", "assert", "i3", "test", "end_lineno", "i3", "test", "end_col_offset", "8", "9", "assert", "i3", "body", "lineno", "i3", "body", "col_offset", "8", "0", "assert", "i3", "body", "end_lineno", "i3", "body", "end_col_offset", "8", "1", "assert", "i3", "orelse", "lineno", "i3", "orelse", "col_offset", "8", "15", "assert", "i3", "orelse", "end_lineno", "i3", "orelse", "end_col_offset", "8", "16"], "doc_len": 305}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_for", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_for", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_for() -> None:\n        \"\"\"For, AsyncFor.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        for i in lst:  #@\n            pass\n        else:\n            pass\n\n        async for i in lst:  #@\n            pass\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        f1 = ast_nodes[0]\n        assert isinstance(f1, nodes.For)\n        assert isinstance(f1.target, nodes.AssignName)\n        assert isinstance(f1.iter, nodes.Name)\n        assert isinstance(f1.body[0], nodes.Pass)\n        assert isinstance(f1.orelse[0], nodes.Pass)\n        assert (f1.lineno, f1.col_offset) == (1, 0)\n        assert (f1.end_lineno, f1.end_col_offset) == (4, 8)\n        assert (f1.target.lineno, f1.target.col_offset) == (1, 4)\n        assert (f1.target.end_lineno, f1.target.end_col_offset) == (1, 5)\n        assert (f1.iter.lineno, f1.iter.col_offset) == (1, 9)\n        assert (f1.iter.end_lineno, f1.iter.end_col_offset) == (1, 12)\n        assert (f1.body[0].lineno, f1.body[0].col_offset) == (2, 4)\n        assert (f1.body[0].end_lineno, f1.body[0].end_col_offset) == (2, 8)\n        assert (f1.orelse[0].lineno, f1.orelse[0].col_offset) == (4, 4)\n        assert (f1.orelse[0].end_lineno, f1.orelse[0].end_col_offset) == (4, 8)\n\n        f2 = ast_nodes[1]\n        assert isinstance(f2, nodes.AsyncFor)\n        assert isinstance(f2.target, nodes.AssignName)\n        assert isinstance(f2.iter, nodes.Name)\n        assert isinstance(f2.body[0], nodes.Pass)\n        assert (f2.lineno, f2.col_offset) == (6, 0)\n        assert (f2.end_lineno, f2.end_col_offset) == (7, 8)\n        assert (f2.target.lineno, f2.target.col_offset) == (6, 10)\n        assert (f2.target.end_lineno, f2.target.end_col_offset) == (6, 11)\n        assert (f2.iter.lineno, f2.iter.col_offset) == (6, 15)\n        assert (f2.iter.end_lineno, f2.iter.end_col_offset) == (6, 18)\n        assert (f2.body[0].lineno, f2.body[0].col_offset) == (7, 4)\n        assert (f2.body[0].end_lineno, f2.body[0].end_col_offset) == (7, 8)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_for", "none", "for", "asyncfor", "code", "textwrap", "dedent", "for", "i", "in", "lst", "pass", "else", "pass", "async", "for", "i", "in", "lst", "pass", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "f1", "ast_nodes", "0", "assert", "isinstance", "f1", "nodes", "for", "assert", "isinstance", "f1", "target", "nodes", "assignname", "assert", "isinstance", "f1", "iter", "nodes", "name", "assert", "isinstance", "f1", "body", "0", "nodes", "pass", "assert", "isinstance", "f1", "orelse", "0", "nodes", "pass", "assert", "f1", "lineno", "f1", "col_offset", "1", "0", "assert", "f1", "end_lineno", "f1", "end_col_offset", "4", "8", "assert", "f1", "target", "lineno", "f1", "target", "col_offset", "1", "4", "assert", "f1", "target", "end_lineno", "f1", "target", "end_col_offset", "1", "5", "assert", "f1", "iter", "lineno", "f1", "iter", "col_offset", "1", "9", "assert", "f1", "iter", "end_lineno", "f1", "iter", "end_col_offset", "1", "12", "assert", "f1", "body", "0", "lineno", "f1", "body", "0", "col_offset", "2", "4", "assert", "f1", "body", "0", "end_lineno", "f1", "body", "0", "end_col_offset", "2", "8", "assert", "f1", "orelse", "0", "lineno", "f1", "orelse", "0", "col_offset", "4", "4", "assert", "f1", "orelse", "0", "end_lineno", "f1", "orelse", "0", "end_col_offset", "4", "8", "f2", "ast_nodes", "1", "assert", "isinstance", "f2", "nodes", "asyncfor", "assert", "isinstance", "f2", "target", "nodes", "assignname", "assert", "isinstance", "f2", "iter", "nodes", "name", "assert", "isinstance", "f2", "body", "0", "nodes", "pass", "assert", "f2", "lineno", "f2", "col_offset", "6", "0", "assert", "f2", "end_lineno", "f2", "end_col_offset", "7", "8", "assert", "f2", "target", "lineno", "f2", "target", "col_offset", "6", "10", "assert", "f2", "target", "end_lineno", "f2", "target", "end_col_offset", "6", "11", "assert", "f2", "iter", "lineno", "f2", "iter", "col_offset", "6", "15", "assert", "f2", "iter", "end_lineno", "f2", "iter", "end_col_offset", "6", "18", "assert", "f2", "body", "0", "lineno", "f2", "body", "0", "col_offset", "7", "4", "assert", "f2", "body", "0", "end_lineno", "f2", "body", "0", "end_col_offset", "7", "8"], "doc_len": 265}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_const", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_const", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_const() -> None:\n        \"\"\"Const (int, str, bool, None, bytes, ellipsis).\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        2  #@\n        \"Hello\"  #@\n        True  #@\n        None  #@\n        b\"01\"  #@\n        ...  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 6\n\n        c1 = ast_nodes[0]\n        assert isinstance(c1, nodes.Const)\n        assert (c1.lineno, c1.col_offset) == (1, 0)\n        assert (c1.end_lineno, c1.end_col_offset) == (1, 1)\n\n        c2 = ast_nodes[1]\n        assert isinstance(c2, nodes.Const)\n        assert (c2.lineno, c2.col_offset) == (2, 0)\n        assert (c2.end_lineno, c2.end_col_offset) == (2, 7)\n\n        c3 = ast_nodes[2]\n        assert isinstance(c3, nodes.Const)\n        assert (c3.lineno, c3.col_offset) == (3, 0)\n        assert (c3.end_lineno, c3.end_col_offset) == (3, 4)\n\n        c4 = ast_nodes[3]\n        assert isinstance(c4, nodes.Const)\n        assert (c4.lineno, c4.col_offset) == (4, 0)\n        assert (c4.end_lineno, c4.end_col_offset) == (4, 4)\n\n        c5 = ast_nodes[4]\n        assert isinstance(c5, nodes.Const)\n        assert (c5.lineno, c5.col_offset) == (5, 0)\n        assert (c5.end_lineno, c5.end_col_offset) == (5, 5)\n\n        c6 = ast_nodes[5]\n        assert isinstance(c6, nodes.Const)\n        assert (c6.lineno, c6.col_offset) == (6, 0)\n        assert (c6.end_lineno, c6.end_col_offset) == (6, 3)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_const", "none", "const", "int", "str", "bool", "none", "bytes", "ellipsis", "code", "textwrap", "dedent", "2", "hello", "true", "none", "b", "01", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "6", "c1", "ast_nodes", "0", "assert", "isinstance", "c1", "nodes", "const", "assert", "c1", "lineno", "c1", "col_offset", "1", "0", "assert", "c1", "end_lineno", "c1", "end_col_offset", "1", "1", "c2", "ast_nodes", "1", "assert", "isinstance", "c2", "nodes", "const", "assert", "c2", "lineno", "c2", "col_offset", "2", "0", "assert", "c2", "end_lineno", "c2", "end_col_offset", "2", "7", "c3", "ast_nodes", "2", "assert", "isinstance", "c3", "nodes", "const", "assert", "c3", "lineno", "c3", "col_offset", "3", "0", "assert", "c3", "end_lineno", "c3", "end_col_offset", "3", "4", "c4", "ast_nodes", "3", "assert", "isinstance", "c4", "nodes", "const", "assert", "c4", "lineno", "c4", "col_offset", "4", "0", "assert", "c4", "end_lineno", "c4", "end_col_offset", "4", "4", "c5", "ast_nodes", "4", "assert", "isinstance", "c5", "nodes", "const", "assert", "c5", "lineno", "c5", "col_offset", "5", "0", "assert", "c5", "end_lineno", "c5", "end_col_offset", "5", "5", "c6", "ast_nodes", "5", "assert", "isinstance", "c6", "nodes", "const", "assert", "c6", "lineno", "c6", "col_offset", "6", "0", "assert", "c6", "end_lineno", "c6", "end_col_offset", "6", "3"], "doc_len": 168}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_function", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_function", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_function() -> None:\n        \"\"\"FunctionDef, AsyncFunctionDef, Decorators, Lambda, Arguments.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        def func(  #@\n            a: int = 0, /,\n            var: int = 1, *args: Any,\n            keyword: int = 2, **kwargs: Any\n        ) -> None:\n            pass\n\n        @decorator1\n        @decorator2\n        async def func():  #@\n            pass\n\n        lambda x: 2  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 3\n\n        # fmt: off\n        f1 = ast_nodes[0]\n        assert isinstance(f1, nodes.FunctionDef)\n        assert isinstance(f1.args, nodes.Arguments)\n        assert isinstance(f1.returns, nodes.Const)\n        assert isinstance(f1.body[0], nodes.Pass)\n        assert (f1.lineno, f1.col_offset) == (1, 0)\n        assert (f1.end_lineno, f1.end_col_offset) == (6, 8)\n        assert (f1.returns.lineno, f1.returns.col_offset) == (5, 5)\n        assert (f1.returns.end_lineno, f1.returns.end_col_offset) == (5, 9)\n        assert (f1.body[0].lineno, f1.body[0].col_offset) == (6, 4)\n        assert (f1.body[0].end_lineno, f1.body[0].end_col_offset) == (6, 8)\n\n        # pos only arguments\n        # TODO fix column offset: arg -> arg (AssignName)\n        assert isinstance(f1.args.posonlyargs[0], nodes.AssignName)\n        assert (f1.args.posonlyargs[0].lineno, f1.args.posonlyargs[0].col_offset) == (2, 4)\n        assert (f1.args.posonlyargs[0].end_lineno, f1.args.posonlyargs[0].end_col_offset) == (2, 10)\n        assert isinstance(f1.args.posonlyargs_annotations[0], nodes.Name)\n        assert (\n            f1.args.posonlyargs_annotations[0].lineno, f1.args.posonlyargs_annotations[0].col_offset\n        ) == (2, 7)\n        assert (\n            f1.args.posonlyargs_annotations[0].end_lineno, f1.args.posonlyargs_annotations[0].end_col_offset\n        ) == (2, 10)\n        assert (f1.args.defaults[0].lineno, f1.args.defaults[0].col_offset) == (2, 13)\n        assert (f1.args.defaults[0].end_lineno, f1.args.defaults[0].end_col_offset) == (2, 14)\n\n        # pos or kw arguments\n        assert isinstance(f1.args.args[0], nodes.AssignName)\n        assert (f1.args.args[0].lineno, f1.args.args[0].col_offset) == (3, 4)\n        assert (f1.args.args[0].end_lineno, f1.args.args[0].end_col_offset) == (3, 12)\n        assert isinstance(f1.args.annotations[0], nodes.Name)\n        assert (f1.args.annotations[0].lineno, f1.args.annotations[0].col_offset) == (3, 9)\n        assert (f1.args.annotations[0].end_lineno, f1.args.annotations[0].end_col_offset) == (3, 12)\n        assert isinstance(f1.args.defaults[1], nodes.Const)\n        assert (f1.args.defaults[1].lineno, f1.args.defaults[1].col_offset) == (3, 15)\n        assert (f1.args.defaults[1].end_lineno, f1.args.defaults[1].end_col_offset) == (3, 16)\n\n        # *args\n        assert isinstance(f1.args.varargannotation, nodes.Name)\n        assert (f1.args.varargannotation.lineno, f1.args.varargannotation.col_offset) == (3, 25)\n        assert (f1.args.varargannotation.end_lineno, f1.args.varargannotation.end_col_offset) == (3, 28)\n\n        # kw_only arguments\n        assert isinstance(f1.args.kwonlyargs[0], nodes.AssignName)\n        assert (f1.args.kwonlyargs[0].lineno, f1.args.kwonlyargs[0].col_offset) == (4, 4)\n        assert (f1.args.kwonlyargs[0].end_lineno, f1.args.kwonlyargs[0].end_col_offset) == (4, 16)\n        assert isinstance(f1.args.kwonlyargs_annotations[0], nodes.Name)\n        assert (f1.args.kwonlyargs_annotations[0].lineno, f1.args.kwonlyargs_annotations[0].col_offset) == (4, 13)\n        assert (f1.args.kwonlyargs_annotations[0].end_lineno, f1.args.kwonlyargs_annotations[0].end_col_offset) == (4, 16)\n        assert isinstance(f1.args.kw_defaults[0], nodes.Const)\n        assert (f1.args.kw_defaults[0].lineno, f1.args.kw_defaults[0].col_offset) == (4, 19)\n        assert (f1.args.kw_defaults[0].end_lineno, f1.args.kw_defaults[0].end_col_offset) == (4, 20)\n\n        # **kwargs\n        assert isinstance(f1.args.kwargannotation, nodes.Name)\n        assert (f1.args.kwargannotation.lineno, f1.args.kwargannotation.col_offset) == (4, 32)\n        assert (f1.args.kwargannotation.end_lineno, f1.args.kwargannotation.end_col_offset) == (4, 35)\n\n        f2 = ast_nodes[1]\n        assert isinstance(f2, nodes.AsyncFunctionDef)\n        assert isinstance(f2.decorators, nodes.Decorators)\n        assert isinstance(f2.decorators.nodes[0], nodes.Name)\n        assert isinstance(f2.decorators.nodes[1], nodes.Name)\n        assert (f2.lineno, f2.col_offset) == (8, 0)\n        assert (f2.end_lineno, f2.end_col_offset) == (11, 8)\n        assert (f2.decorators.lineno, f2.decorators.col_offset) == (8, 0)\n        assert (f2.decorators.end_lineno, f2.decorators.end_col_offset) == (9, 11)\n        assert (f2.decorators.nodes[0].lineno, f2.decorators.nodes[0].col_offset) == (8, 1)\n        assert (f2.decorators.nodes[0].end_lineno, f2.decorators.nodes[0].end_col_offset) == (8, 11)\n        assert (f2.decorators.nodes[1].lineno, f2.decorators.nodes[1].col_offset) == (9, 1)\n        assert (f2.decorators.nodes[1].end_lineno, f2.decorators.nodes[1].end_col_offset) == (9, 11)\n\n        f3 = ast_nodes[2]\n        assert isinstance(f3, nodes.Lambda)\n        assert isinstance(f3.args, nodes.Arguments)\n        assert isinstance(f3.args.args[0], nodes.AssignName)\n        assert isinstance(f3.body, nodes.Const)\n        assert (f3.lineno, f3.col_offset) == (13, 0)\n        assert (f3.end_lineno, f3.end_col_offset) == (13, 11)\n        assert (f3.args.args[0].lineno, f3.args.args[0].col_offset) == (13, 7)\n        assert (f3.args.args[0].end_lineno, f3.args.args[0].end_col_offset) == (13, 8)\n        assert (f3.body.lineno, f3.body.col_offset) == (13, 10)\n        assert (f3.body.end_lineno, f3.body.end_col_offset) == (13, 11)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_function", "none", "functiondef", "asyncfunctiondef", "decorators", "lambda", "arguments", "code", "textwrap", "dedent", "def", "func", "a", "int", "0", "var", "int", "1", "args", "any", "keyword", "int", "2", "kwargs", "any", "none", "pass", "decorator1", "decorator2", "async", "def", "func", "pass", "lambda", "x", "2", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "3", "fmt", "off", "f1", "ast_nodes", "0", "assert", "isinstance", "f1", "nodes", "functiondef", "assert", "isinstance", "f1", "args", "nodes", "arguments", "assert", "isinstance", "f1", "returns", "nodes", "const", "assert", "isinstance", "f1", "body", "0", "nodes", "pass", "assert", "f1", "lineno", "f1", "col_offset", "1", "0", "assert", "f1", "end_lineno", "f1", "end_col_offset", "6", "8", "assert", "f1", "returns", "lineno", "f1", "returns", "col_offset", "5", "5", "assert", "f1", "returns", "end_lineno", "f1", "returns", "end_col_offset", "5", "9", "assert", "f1", "body", "0", "lineno", "f1", "body", "0", "col_offset", "6", "4", "assert", "f1", "body", "0", "end_lineno", "f1", "body", "0", "end_col_offset", "6", "8", "pos", "only", "arguments", "todo", "fix", "column", "offset", "arg", "arg", "assignname", "assert", "isinstance", "f1", "args", "posonlyargs", "0", "nodes", "assignname", "assert", "f1", "args", "posonlyargs", "0", "lineno", "f1", "args", "posonlyargs", "0", "col_offset", "2", "4", "assert", "f1", "args", "posonlyargs", "0", "end_lineno", "f1", "args", "posonlyargs", "0", "end_col_offset", "2", "10", "assert", "isinstance", "f1", "args", "posonlyargs_annotations", "0", "nodes", "name", "assert", "f1", "args", "posonlyargs_annotations", "0", "lineno", "f1", "args", "posonlyargs_annotations", "0", "col_offset", "2", "7", "assert", "f1", "args", "posonlyargs_annotations", "0", "end_lineno", "f1", "args", "posonlyargs_annotations", "0", "end_col_offset", "2", "10", "assert", "f1", "args", "defaults", "0", "lineno", "f1", "args", "defaults", "0", "col_offset", "2", "13", "assert", "f1", "args", "defaults", "0", "end_lineno", "f1", "args", "defaults", "0", "end_col_offset", "2", "14", "pos", "or", "kw", "arguments", "assert", "isinstance", "f1", "args", "args", "0", "nodes", "assignname", "assert", "f1", "args", "args", "0", "lineno", "f1", "args", "args", "0", "col_offset", "3", "4", "assert", "f1", "args", "args", "0", "end_lineno", "f1", "args", "args", "0", "end_col_offset", "3", "12", "assert", "isinstance", "f1", "args", "annotations", "0", "nodes", "name", "assert", "f1", "args", "annotations", "0", "lineno", "f1", "args", "annotations", "0", "col_offset", "3", "9", "assert", "f1", "args", "annotations", "0", "end_lineno", "f1", "args", "annotations", "0", "end_col_offset", "3", "12", "assert", "isinstance", "f1", "args", "defaults", "1", "nodes", "const", "assert", "f1", "args", "defaults", "1", "lineno", "f1", "args", "defaults", "1", "col_offset", "3", "15", "assert", "f1", "args", "defaults", "1", "end_lineno", "f1", "args", "defaults", "1", "end_col_offset", "3", "16", "args", "assert", "isinstance", "f1", "args", "varargannotation", "nodes", "name", "assert", "f1", "args", "varargannotation", "lineno", "f1", "args", "varargannotation", "col_offset", "3", "25", "assert", "f1", "args", "varargannotation", "end_lineno", "f1", "args", "varargannotation", "end_col_offset", "3", "28", "kw_only", "arguments", "assert", "isinstance", "f1", "args", "kwonlyargs", "0", "nodes", "assignname", "assert", "f1", "args", "kwonlyargs", "0", "lineno", "f1", "args", "kwonlyargs", "0", "col_offset", "4", "4", "assert", "f1", "args", "kwonlyargs", "0", "end_lineno", "f1", "args", "kwonlyargs", "0", "end_col_offset", "4", "16", "assert", "isinstance", "f1", "args", "kwonlyargs_annotations", "0", "nodes", "name", "assert", "f1", "args", "kwonlyargs_annotations", "0", "lineno", "f1", "args", "kwonlyargs_annotations", "0", "col_offset", "4", "13", "assert", "f1", "args", "kwonlyargs_annotations", "0", "end_lineno", "f1", "args", "kwonlyargs_annotations", "0", "end_col_offset", "4", "16", "assert", "isinstance", "f1", "args", "kw_defaults", "0", "nodes", "const", "assert", "f1", "args", "kw_defaults", "0", "lineno", "f1", "args", "kw_defaults", "0", "col_offset", "4", "19", "assert", "f1", "args", "kw_defaults", "0", "end_lineno", "f1", "args", "kw_defaults", "0", "end_col_offset", "4", "20", "kwargs", "assert", "isinstance", "f1", "args", "kwargannotation", "nodes", "name", "assert", "f1", "args", "kwargannotation", "lineno", "f1", "args", "kwargannotation", "col_offset", "4", "32", "assert", "f1", "args", "kwargannotation", "end_lineno", "f1", "args", "kwargannotation", "end_col_offset", "4", "35", "f2", "ast_nodes", "1", "assert", "isinstance", "f2", "nodes", "asyncfunctiondef", "assert", "isinstance", "f2", "decorators", "nodes", "decorators", "assert", "isinstance", "f2", "decorators", "nodes", "0", "nodes", "name", "assert", "isinstance", "f2", "decorators", "nodes", "1", "nodes", "name", "assert", "f2", "lineno", "f2", "col_offset", "8", "0", "assert", "f2", "end_lineno", "f2", "end_col_offset", "11", "8", "assert", "f2", "decorators", "lineno", "f2", "decorators", "col_offset", "8", "0", "assert", "f2", "decorators", "end_lineno", "f2", "decorators", "end_col_offset", "9", "11", "assert", "f2", "decorators", "nodes", "0", "lineno", "f2", "decorators", "nodes", "0", "col_offset", "8", "1", "assert", "f2", "decorators", "nodes", "0", "end_lineno", "f2", "decorators", "nodes", "0", "end_col_offset", "8", "11", "assert", "f2", "decorators", "nodes", "1", "lineno", "f2", "decorators", "nodes", "1", "col_offset", "9", "1", "assert", "f2", "decorators", "nodes", "1", "end_lineno", "f2", "decorators", "nodes", "1", "end_col_offset", "9", "11", "f3", "ast_nodes", "2", "assert", "isinstance", "f3", "nodes", "lambda", "assert", "isinstance", "f3", "args", "nodes", "arguments", "assert", "isinstance", "f3", "args", "args", "0", "nodes", "assignname", "assert", "isinstance", "f3", "body", "nodes", "const", "assert", "f3", "lineno", "f3", "col_offset", "13", "0", "assert", "f3", "end_lineno", "f3", "end_col_offset", "13", "11", "assert", "f3", "args", "args", "0", "lineno", "f3", "args", "args", "0", "col_offset", "13", "7", "assert", "f3", "args", "args", "0", "end_lineno", "f3", "args", "args", "0", "end_col_offset", "13", "8", "assert", "f3", "body", "lineno", "f3", "body", "col_offset", "13", "10", "assert", "f3", "body", "end_lineno", "f3", "body", "end_col_offset", "13", "11"], "doc_len": 711}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_dict", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_dict", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_dict() -> None:\n        \"\"\"Dict, DictUnpack.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        {  #@\n            1: \"Hello\",\n            **{2: \"World\"}  #@\n        }\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        d1 = ast_nodes[0]\n        assert isinstance(d1, nodes.Dict)\n        assert isinstance(d1.items[0][0], nodes.Const)\n        assert isinstance(d1.items[0][1], nodes.Const)\n        assert (d1.lineno, d1.col_offset) == (1, 0)\n        assert (d1.end_lineno, d1.end_col_offset) == (4, 1)\n        assert (d1.items[0][0].lineno, d1.items[0][0].col_offset) == (2, 4)\n        assert (d1.items[0][0].end_lineno, d1.items[0][0].end_col_offset) == (2, 5)\n        assert (d1.items[0][1].lineno, d1.items[0][1].col_offset) == (2, 7)\n        assert (d1.items[0][1].end_lineno, d1.items[0][1].end_col_offset) == (2, 14)\n\n        d2 = ast_nodes[1]\n        assert isinstance(d2, nodes.DictUnpack)\n        assert (d2.lineno, d2.col_offset) == (3, 6)\n        assert (d2.end_lineno, d2.end_col_offset) == (3, 18)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_dict", "none", "dict", "dictunpack", "code", "textwrap", "dedent", "1", "hello", "2", "world", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "d1", "ast_nodes", "0", "assert", "isinstance", "d1", "nodes", "dict", "assert", "isinstance", "d1", "items", "0", "0", "nodes", "const", "assert", "isinstance", "d1", "items", "0", "1", "nodes", "const", "assert", "d1", "lineno", "d1", "col_offset", "1", "0", "assert", "d1", "end_lineno", "d1", "end_col_offset", "4", "1", "assert", "d1", "items", "0", "0", "lineno", "d1", "items", "0", "0", "col_offset", "2", "4", "assert", "d1", "items", "0", "0", "end_lineno", "d1", "items", "0", "0", "end_col_offset", "2", "5", "assert", "d1", "items", "0", "1", "lineno", "d1", "items", "0", "1", "col_offset", "2", "7", "assert", "d1", "items", "0", "1", "end_lineno", "d1", "items", "0", "1", "end_col_offset", "2", "14", "d2", "ast_nodes", "1", "assert", "isinstance", "d2", "nodes", "dictunpack", "assert", "d2", "lineno", "d2", "col_offset", "3", "6", "assert", "d2", "end_lineno", "d2", "end_col_offset", "3", "18"], "doc_len": 141}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_try", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_try", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_try() -> None:\n        \"\"\"TryExcept, TryFinally, ExceptHandler.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        try:  #@\n            pass\n        except KeyError as ex:\n            pass\n        except AttributeError as ex:\n            pass\n        else:\n            pass\n\n        try:  #@\n            pass\n        except KeyError as ex:\n            pass\n        else:\n            pass\n        finally:\n            pass\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        t1 = ast_nodes[0]\n        assert isinstance(t1, nodes.TryExcept)\n        assert isinstance(t1.body[0], nodes.Pass)\n        assert isinstance(t1.orelse[0], nodes.Pass)\n        assert (t1.lineno, t1.col_offset) == (1, 0)\n        assert (t1.end_lineno, t1.end_col_offset) == (8, 8)\n        assert (t1.body[0].lineno, t1.body[0].col_offset) == (2, 4)\n        assert (t1.body[0].end_lineno, t1.body[0].end_col_offset) == (2, 8)\n        assert (t1.orelse[0].lineno, t1.orelse[0].col_offset) == (8, 4)\n        assert (t1.orelse[0].end_lineno, t1.orelse[0].end_col_offset) == (8, 8)\n\n        t2 = t1.handlers[0]\n        assert isinstance(t2, nodes.ExceptHandler)\n        assert isinstance(t2.type, nodes.Name)\n        assert isinstance(t2.name, nodes.AssignName)\n        assert isinstance(t2.body[0], nodes.Pass)\n        assert (t2.lineno, t2.col_offset) == (3, 0)\n        assert (t2.end_lineno, t2.end_col_offset) == (4, 8)\n        assert (t2.type.lineno, t2.type.col_offset) == (3, 7)\n        assert (t2.type.end_lineno, t2.type.end_col_offset) == (3, 15)\n        # TODO fix column offset: ExceptHandler -> name (AssignName)\n        assert (t2.name.lineno, t2.name.col_offset) == (3, 0)\n        assert (t2.name.end_lineno, t2.name.end_col_offset) == (4, 8)\n        assert (t2.body[0].lineno, t2.body[0].col_offset) == (4, 4)\n        assert (t2.body[0].end_lineno, t2.body[0].end_col_offset) == (4, 8)\n\n        t3 = ast_nodes[1]\n        assert isinstance(t3, nodes.TryFinally)\n        assert isinstance(t3.body[0], nodes.TryExcept)\n        assert isinstance(t3.finalbody[0], nodes.Pass)\n        assert (t3.lineno, t3.col_offset) == (10, 0)\n        assert (t3.end_lineno, t3.end_col_offset) == (17, 8)\n        assert (t3.body[0].lineno, t3.body[0].col_offset) == (10, 0)\n        assert (t3.body[0].end_lineno, t3.body[0].end_col_offset) == (17, 8)\n        assert (t3.finalbody[0].lineno, t3.finalbody[0].col_offset) == (17, 4)\n        assert (t3.finalbody[0].end_lineno, t3.finalbody[0].end_col_offset) == (17, 8)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_try", "none", "tryexcept", "tryfinally", "excepthandler", "code", "textwrap", "dedent", "try", "pass", "except", "keyerror", "as", "ex", "pass", "except", "attributeerror", "as", "ex", "pass", "else", "pass", "try", "pass", "except", "keyerror", "as", "ex", "pass", "else", "pass", "finally", "pass", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "t1", "ast_nodes", "0", "assert", "isinstance", "t1", "nodes", "tryexcept", "assert", "isinstance", "t1", "body", "0", "nodes", "pass", "assert", "isinstance", "t1", "orelse", "0", "nodes", "pass", "assert", "t1", "lineno", "t1", "col_offset", "1", "0", "assert", "t1", "end_lineno", "t1", "end_col_offset", "8", "8", "assert", "t1", "body", "0", "lineno", "t1", "body", "0", "col_offset", "2", "4", "assert", "t1", "body", "0", "end_lineno", "t1", "body", "0", "end_col_offset", "2", "8", "assert", "t1", "orelse", "0", "lineno", "t1", "orelse", "0", "col_offset", "8", "4", "assert", "t1", "orelse", "0", "end_lineno", "t1", "orelse", "0", "end_col_offset", "8", "8", "t2", "t1", "handlers", "0", "assert", "isinstance", "t2", "nodes", "excepthandler", "assert", "isinstance", "t2", "type", "nodes", "name", "assert", "isinstance", "t2", "name", "nodes", "assignname", "assert", "isinstance", "t2", "body", "0", "nodes", "pass", "assert", "t2", "lineno", "t2", "col_offset", "3", "0", "assert", "t2", "end_lineno", "t2", "end_col_offset", "4", "8", "assert", "t2", "type", "lineno", "t2", "type", "col_offset", "3", "7", "assert", "t2", "type", "end_lineno", "t2", "type", "end_col_offset", "3", "15", "todo", "fix", "column", "offset", "excepthandler", "name", "assignname", "assert", "t2", "name", "lineno", "t2", "name", "col_offset", "3", "0", "assert", "t2", "name", "end_lineno", "t2", "name", "end_col_offset", "4", "8", "assert", "t2", "body", "0", "lineno", "t2", "body", "0", "col_offset", "4", "4", "assert", "t2", "body", "0", "end_lineno", "t2", "body", "0", "end_col_offset", "4", "8", "t3", "ast_nodes", "1", "assert", "isinstance", "t3", "nodes", "tryfinally", "assert", "isinstance", "t3", "body", "0", "nodes", "tryexcept", "assert", "isinstance", "t3", "finalbody", "0", "nodes", "pass", "assert", "t3", "lineno", "t3", "col_offset", "10", "0", "assert", "t3", "end_lineno", "t3", "end_col_offset", "17", "8", "assert", "t3", "body", "0", "lineno", "t3", "body", "0", "col_offset", "10", "0", "assert", "t3", "body", "0", "end_lineno", "t3", "body", "0", "end_col_offset", "17", "8", "assert", "t3", "finalbody", "0", "lineno", "t3", "finalbody", "0", "col_offset", "17", "4", "assert", "t3", "finalbody", "0", "end_lineno", "t3", "finalbody", "0", "end_col_offset", "17", "8"], "doc_len": 318}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_subscript", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_subscript", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_subscript() -> None:\n        \"\"\"Subscript, Slice, (ExtSlice, Index).\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        var[0]  #@\n        var[1:2:1]  #@\n        var[1:2, 2]  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 3\n\n        s1 = ast_nodes[0]\n        assert isinstance(s1, nodes.Subscript)\n        assert isinstance(s1.value, nodes.Name)\n        assert isinstance(s1.slice, nodes.Const)\n        assert (s1.lineno, s1.col_offset) == (1, 0)\n        assert (s1.end_lineno, s1.end_col_offset) == (1, 6)\n        assert (s1.value.lineno, s1.value.col_offset) == (1, 0)\n        assert (s1.value.end_lineno, s1.value.end_col_offset) == (1, 3)\n        assert (s1.slice.lineno, s1.slice.col_offset) == (1, 4)\n        assert (s1.slice.end_lineno, s1.slice.end_col_offset) == (1, 5)\n\n        s2 = ast_nodes[1]\n        assert isinstance(s2, nodes.Subscript)\n        assert isinstance(s2.slice, nodes.Slice)\n        assert isinstance(s2.slice.lower, nodes.Const)\n        assert isinstance(s2.slice.upper, nodes.Const)\n        assert isinstance(s2.slice.step, nodes.Const)\n        assert (s2.lineno, s2.col_offset) == (2, 0)\n        assert (s2.end_lineno, s2.end_col_offset) == (2, 10)\n        assert (s2.slice.lower.lineno, s2.slice.lower.col_offset) == (2, 4)\n        assert (s2.slice.lower.end_lineno, s2.slice.lower.end_col_offset) == (2, 5)\n        assert (s2.slice.upper.lineno, s2.slice.upper.col_offset) == (2, 6)\n        assert (s2.slice.upper.end_lineno, s2.slice.upper.end_col_offset) == (2, 7)\n        assert (s2.slice.step.lineno, s2.slice.step.col_offset) == (2, 8)\n        assert (s2.slice.step.end_lineno, s2.slice.step.end_col_offset) == (2, 9)\n\n        s3 = ast_nodes[2]\n        assert isinstance(s3, nodes.Subscript)\n        assert isinstance(s3.slice, nodes.Tuple)\n        assert (s3.lineno, s3.col_offset) == (3, 0)\n        assert (s3.end_lineno, s3.end_col_offset) == (3, 11)\n        if PY39_PLUS:\n            # 'lineno' and 'col_offset' information only added in Python 3.9\n            assert (s3.slice.lineno, s3.slice.col_offset) == (3, 4)\n            assert (s3.slice.end_lineno, s3.slice.end_col_offset) == (3, 10)\n        else:\n            assert (s3.slice.lineno, s3.slice.col_offset) == (None, None)\n            assert (s3.slice.end_lineno, s3.slice.end_col_offset) == (None, None)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_subscript", "none", "subscript", "slice", "extslice", "index", "code", "textwrap", "dedent", "var", "0", "var", "1", "2", "1", "var", "1", "2", "2", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "3", "s1", "ast_nodes", "0", "assert", "isinstance", "s1", "nodes", "subscript", "assert", "isinstance", "s1", "value", "nodes", "name", "assert", "isinstance", "s1", "slice", "nodes", "const", "assert", "s1", "lineno", "s1", "col_offset", "1", "0", "assert", "s1", "end_lineno", "s1", "end_col_offset", "1", "6", "assert", "s1", "value", "lineno", "s1", "value", "col_offset", "1", "0", "assert", "s1", "value", "end_lineno", "s1", "value", "end_col_offset", "1", "3", "assert", "s1", "slice", "lineno", "s1", "slice", "col_offset", "1", "4", "assert", "s1", "slice", "end_lineno", "s1", "slice", "end_col_offset", "1", "5", "s2", "ast_nodes", "1", "assert", "isinstance", "s2", "nodes", "subscript", "assert", "isinstance", "s2", "slice", "nodes", "slice", "assert", "isinstance", "s2", "slice", "lower", "nodes", "const", "assert", "isinstance", "s2", "slice", "upper", "nodes", "const", "assert", "isinstance", "s2", "slice", "step", "nodes", "const", "assert", "s2", "lineno", "s2", "col_offset", "2", "0", "assert", "s2", "end_lineno", "s2", "end_col_offset", "2", "10", "assert", "s2", "slice", "lower", "lineno", "s2", "slice", "lower", "col_offset", "2", "4", "assert", "s2", "slice", "lower", "end_lineno", "s2", "slice", "lower", "end_col_offset", "2", "5", "assert", "s2", "slice", "upper", "lineno", "s2", "slice", "upper", "col_offset", "2", "6", "assert", "s2", "slice", "upper", "end_lineno", "s2", "slice", "upper", "end_col_offset", "2", "7", "assert", "s2", "slice", "step", "lineno", "s2", "slice", "step", "col_offset", "2", "8", "assert", "s2", "slice", "step", "end_lineno", "s2", "slice", "step", "end_col_offset", "2", "9", "s3", "ast_nodes", "2", "assert", "isinstance", "s3", "nodes", "subscript", "assert", "isinstance", "s3", "slice", "nodes", "tuple", "assert", "s3", "lineno", "s3", "col_offset", "3", "0", "assert", "s3", "end_lineno", "s3", "end_col_offset", "3", "11", "if", "py39_plus", "lineno", "and", "col_offset", "information", "only", "added", "in", "python", "3", "9", "assert", "s3", "slice", "lineno", "s3", "slice", "col_offset", "3", "4", "assert", "s3", "slice", "end_lineno", "s3", "slice", "end_col_offset", "3", "10", "else", "assert", "s3", "slice", "lineno", "s3", "slice", "col_offset", "none", "none", "assert", "s3", "slice", "end_lineno", "s3", "slice", "end_col_offset", "none", "none"], "doc_len": 299}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_import", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_import", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_import() -> None:\n        \"\"\"Import, ImportFrom.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        import a.b  #@\n        import a as x  #@\n        from . import x  #@\n        from .a import y as y  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        i1 = ast_nodes[0]\n        assert isinstance(i1, nodes.Import)\n        assert (i1.lineno, i1.col_offset) == (1, 0)\n        assert (i1.end_lineno, i1.end_col_offset) == (1, 10)\n\n        i2 = ast_nodes[1]\n        assert isinstance(i2, nodes.Import)\n        assert (i2.lineno, i2.col_offset) == (2, 0)\n        assert (i2.end_lineno, i2.end_col_offset) == (2, 13)\n\n        i3 = ast_nodes[2]\n        assert isinstance(i3, nodes.ImportFrom)\n        assert (i3.lineno, i3.col_offset) == (3, 0)\n        assert (i3.end_lineno, i3.end_col_offset) == (3, 15)\n\n        i4 = ast_nodes[3]\n        assert isinstance(i4, nodes.ImportFrom)\n        assert (i4.lineno, i4.col_offset) == (4, 0)\n        assert (i4.end_lineno, i4.end_col_offset) == (4, 21)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_import", "none", "import", "importfrom", "code", "textwrap", "dedent", "import", "a", "b", "import", "a", "as", "x", "from", "import", "x", "from", "a", "import", "y", "as", "y", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "i1", "ast_nodes", "0", "assert", "isinstance", "i1", "nodes", "import", "assert", "i1", "lineno", "i1", "col_offset", "1", "0", "assert", "i1", "end_lineno", "i1", "end_col_offset", "1", "10", "i2", "ast_nodes", "1", "assert", "isinstance", "i2", "nodes", "import", "assert", "i2", "lineno", "i2", "col_offset", "2", "0", "assert", "i2", "end_lineno", "i2", "end_col_offset", "2", "13", "i3", "ast_nodes", "2", "assert", "isinstance", "i3", "nodes", "importfrom", "assert", "i3", "lineno", "i3", "col_offset", "3", "0", "assert", "i3", "end_lineno", "i3", "end_col_offset", "3", "15", "i4", "ast_nodes", "3", "assert", "isinstance", "i4", "nodes", "importfrom", "assert", "i4", "lineno", "i4", "col_offset", "4", "0", "assert", "i4", "end_lineno", "i4", "end_col_offset", "4", "21"], "doc_len": 129}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_with", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_with", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_with() -> None:\n        \"\"\"With, AsyncWith.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        with open(file) as fp, \\\\\n                open(file2) as fp2:  #@\n            pass\n\n        async with open(file) as fp:  #@\n            pass\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        w1 = ast_nodes[0].parent\n        assert isinstance(w1, nodes.With)\n        assert isinstance(w1.items[0][0], nodes.Call)\n        assert isinstance(w1.items[0][1], nodes.AssignName)\n        assert isinstance(w1.items[1][0], nodes.Call)\n        assert isinstance(w1.items[1][1], nodes.AssignName)\n        assert isinstance(w1.body[0], nodes.Pass)\n        assert (w1.lineno, w1.col_offset) == (1, 0)\n        assert (w1.end_lineno, w1.end_col_offset) == (3, 8)\n        assert (w1.items[0][0].lineno, w1.items[0][0].col_offset) == (1, 5)\n        assert (w1.items[0][0].end_lineno, w1.items[0][0].end_col_offset) == (1, 15)\n        assert (w1.items[0][1].lineno, w1.items[0][1].col_offset) == (1, 19)\n        assert (w1.items[0][1].end_lineno, w1.items[0][1].end_col_offset) == (1, 21)\n        assert (w1.items[1][0].lineno, w1.items[1][0].col_offset) == (2, 8)\n        assert (w1.items[1][0].end_lineno, w1.items[1][0].end_col_offset) == (2, 19)\n        assert (w1.items[1][1].lineno, w1.items[1][1].col_offset) == (2, 23)\n        assert (w1.items[1][1].end_lineno, w1.items[1][1].end_col_offset) == (2, 26)\n        assert (w1.body[0].lineno, w1.body[0].col_offset) == (3, 4)\n        assert (w1.body[0].end_lineno, w1.body[0].end_col_offset) == (3, 8)\n\n        w2 = ast_nodes[1]\n        assert isinstance(w2, nodes.AsyncWith)\n        assert isinstance(w2.items[0][0], nodes.Call)\n        assert isinstance(w2.items[0][1], nodes.AssignName)\n        assert isinstance(w2.body[0], nodes.Pass)\n        assert (w2.lineno, w2.col_offset) == (5, 0)\n        assert (w2.end_lineno, w2.end_col_offset) == (6, 8)\n        assert (w2.items[0][0].lineno, w2.items[0][0].col_offset) == (5, 11)\n        assert (w2.items[0][0].end_lineno, w2.items[0][0].end_col_offset) == (5, 21)\n        assert (w2.items[0][1].lineno, w2.items[0][1].col_offset) == (5, 25)\n        assert (w2.items[0][1].end_lineno, w2.items[0][1].end_col_offset) == (5, 27)\n        assert (w2.body[0].lineno, w2.body[0].col_offset) == (6, 4)\n        assert (w2.body[0].end_lineno, w2.body[0].end_col_offset) == (6, 8)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_with", "none", "with", "asyncwith", "code", "textwrap", "dedent", "with", "open", "file", "as", "fp", "open", "file2", "as", "fp2", "pass", "async", "with", "open", "file", "as", "fp", "pass", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "w1", "ast_nodes", "0", "parent", "assert", "isinstance", "w1", "nodes", "with", "assert", "isinstance", "w1", "items", "0", "0", "nodes", "call", "assert", "isinstance", "w1", "items", "0", "1", "nodes", "assignname", "assert", "isinstance", "w1", "items", "1", "0", "nodes", "call", "assert", "isinstance", "w1", "items", "1", "1", "nodes", "assignname", "assert", "isinstance", "w1", "body", "0", "nodes", "pass", "assert", "w1", "lineno", "w1", "col_offset", "1", "0", "assert", "w1", "end_lineno", "w1", "end_col_offset", "3", "8", "assert", "w1", "items", "0", "0", "lineno", "w1", "items", "0", "0", "col_offset", "1", "5", "assert", "w1", "items", "0", "0", "end_lineno", "w1", "items", "0", "0", "end_col_offset", "1", "15", "assert", "w1", "items", "0", "1", "lineno", "w1", "items", "0", "1", "col_offset", "1", "19", "assert", "w1", "items", "0", "1", "end_lineno", "w1", "items", "0", "1", "end_col_offset", "1", "21", "assert", "w1", "items", "1", "0", "lineno", "w1", "items", "1", "0", "col_offset", "2", "8", "assert", "w1", "items", "1", "0", "end_lineno", "w1", "items", "1", "0", "end_col_offset", "2", "19", "assert", "w1", "items", "1", "1", "lineno", "w1", "items", "1", "1", "col_offset", "2", "23", "assert", "w1", "items", "1", "1", "end_lineno", "w1", "items", "1", "1", "end_col_offset", "2", "26", "assert", "w1", "body", "0", "lineno", "w1", "body", "0", "col_offset", "3", "4", "assert", "w1", "body", "0", "end_lineno", "w1", "body", "0", "end_col_offset", "3", "8", "w2", "ast_nodes", "1", "assert", "isinstance", "w2", "nodes", "asyncwith", "assert", "isinstance", "w2", "items", "0", "0", "nodes", "call", "assert", "isinstance", "w2", "items", "0", "1", "nodes", "assignname", "assert", "isinstance", "w2", "body", "0", "nodes", "pass", "assert", "w2", "lineno", "w2", "col_offset", "5", "0", "assert", "w2", "end_lineno", "w2", "end_col_offset", "6", "8", "assert", "w2", "items", "0", "0", "lineno", "w2", "items", "0", "0", "col_offset", "5", "11", "assert", "w2", "items", "0", "0", "end_lineno", "w2", "items", "0", "0", "end_col_offset", "5", "21", "assert", "w2", "items", "0", "1", "lineno", "w2", "items", "0", "1", "col_offset", "5", "25", "assert", "w2", "items", "0", "1", "end_lineno", "w2", "items", "0", "1", "end_col_offset", "5", "27", "assert", "w2", "body", "0", "lineno", "w2", "body", "0", "col_offset", "6", "4", "assert", "w2", "body", "0", "end_lineno", "w2", "body", "0", "end_col_offset", "6", "8"], "doc_len": 349}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_while", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_while", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_while() -> None:\n        \"\"\"While.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        while 2:\n            pass\n        else:\n            pass\n        \"\"\"\n        ).strip()\n        w1 = builder.extract_node(code)\n        assert isinstance(w1, nodes.While)\n        assert isinstance(w1.test, nodes.Const)\n        assert isinstance(w1.body[0], nodes.Pass)\n        assert isinstance(w1.orelse[0], nodes.Pass)\n        assert (w1.lineno, w1.col_offset) == (1, 0)\n        assert (w1.end_lineno, w1.end_col_offset) == (4, 8)\n        assert (w1.test.lineno, w1.test.col_offset) == (1, 6)\n        assert (w1.test.end_lineno, w1.test.end_col_offset) == (1, 7)\n        assert (w1.body[0].lineno, w1.body[0].col_offset) == (2, 4)\n        assert (w1.body[0].end_lineno, w1.body[0].end_col_offset) == (2, 8)\n        assert (w1.orelse[0].lineno, w1.orelse[0].col_offset) == (4, 4)\n        assert (w1.orelse[0].end_lineno, w1.orelse[0].end_col_offset) == (4, 8)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_while", "none", "while", "code", "textwrap", "dedent", "while", "2", "pass", "else", "pass", "strip", "w1", "builder", "extract_node", "code", "assert", "isinstance", "w1", "nodes", "while", "assert", "isinstance", "w1", "test", "nodes", "const", "assert", "isinstance", "w1", "body", "0", "nodes", "pass", "assert", "isinstance", "w1", "orelse", "0", "nodes", "pass", "assert", "w1", "lineno", "w1", "col_offset", "1", "0", "assert", "w1", "end_lineno", "w1", "end_col_offset", "4", "8", "assert", "w1", "test", "lineno", "w1", "test", "col_offset", "1", "6", "assert", "w1", "test", "end_lineno", "w1", "test", "end_col_offset", "1", "7", "assert", "w1", "body", "0", "lineno", "w1", "body", "0", "col_offset", "2", "4", "assert", "w1", "body", "0", "end_lineno", "w1", "body", "0", "end_col_offset", "2", "8", "assert", "w1", "orelse", "0", "lineno", "w1", "orelse", "0", "col_offset", "4", "4", "assert", "w1", "orelse", "0", "end_lineno", "w1", "orelse", "0", "end_col_offset", "4", "8"], "doc_len": 122}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_string", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_string", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_string() -> None:\n        \"\"\"FormattedValue, JoinedStr.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        f\"Hello World: {42.1234:02d}\"  #@\n        f\"Hello: {name=}\"  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 2\n\n        s1 = ast_nodes[0]\n        assert isinstance(s1, nodes.JoinedStr)\n        assert isinstance(s1.values[0], nodes.Const)\n        assert (s1.lineno, s1.col_offset) == (1, 0)\n        assert (s1.end_lineno, s1.end_col_offset) == (1, 29)\n        assert (s1.values[0].lineno, s1.values[0].col_offset) == (1, 0)\n        assert (s1.values[0].end_lineno, s1.values[0].end_col_offset) == (1, 29)\n\n        s2 = s1.values[1]\n        assert isinstance(s2, nodes.FormattedValue)\n        assert (s2.lineno, s2.col_offset) == (1, 0)\n        assert (s2.end_lineno, s2.end_col_offset) == (1, 29)\n        assert isinstance(s2.value, nodes.Const)  # 42.1234\n        if PY39_PLUS:\n            assert (s2.value.lineno, s2.value.col_offset) == (1, 16)\n            assert (s2.value.end_lineno, s2.value.end_col_offset) == (1, 23)\n        else:\n            # Bug in Python 3.8\n            # https://bugs.python.org/issue44885\n            assert (s2.value.lineno, s2.value.col_offset) == (1, 1)\n            assert (s2.value.end_lineno, s2.value.end_col_offset) == (1, 8)\n        assert isinstance(s2.format_spec, nodes.JoinedStr)  # '02d'\n        assert (s2.format_spec.lineno, s2.format_spec.col_offset) == (1, 0)\n        assert (s2.format_spec.end_lineno, s2.format_spec.end_col_offset) == (1, 29)\n\n        s3 = ast_nodes[1]\n        assert isinstance(s3, nodes.JoinedStr)\n        assert isinstance(s3.values[0], nodes.Const)\n        assert (s3.lineno, s3.col_offset) == (2, 0)\n        assert (s3.end_lineno, s3.end_col_offset) == (2, 17)\n        assert (s3.values[0].lineno, s3.values[0].col_offset) == (2, 0)\n        assert (s3.values[0].end_lineno, s3.values[0].end_col_offset) == (2, 17)\n\n        s4 = s3.values[1]\n        assert isinstance(s4, nodes.FormattedValue)\n        assert (s4.lineno, s4.col_offset) == (2, 0)\n        assert (s4.end_lineno, s4.end_col_offset) == (2, 17)\n        assert isinstance(s4.value, nodes.Name)  # 'name'\n        if PY39_PLUS:\n            assert (s4.value.lineno, s4.value.col_offset) == (2, 10)\n            assert (s4.value.end_lineno, s4.value.end_col_offset) == (2, 14)\n        else:\n            # Bug in Python 3.8\n            # https://bugs.python.org/issue44885\n            assert (s4.value.lineno, s4.value.col_offset) == (2, 1)\n            assert (s4.value.end_lineno, s4.value.end_col_offset) == (2, 5)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_string", "none", "formattedvalue", "joinedstr", "code", "textwrap", "dedent", "f", "hello", "world", "42", "1234", "02d", "f", "hello", "name", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "2", "s1", "ast_nodes", "0", "assert", "isinstance", "s1", "nodes", "joinedstr", "assert", "isinstance", "s1", "values", "0", "nodes", "const", "assert", "s1", "lineno", "s1", "col_offset", "1", "0", "assert", "s1", "end_lineno", "s1", "end_col_offset", "1", "29", "assert", "s1", "values", "0", "lineno", "s1", "values", "0", "col_offset", "1", "0", "assert", "s1", "values", "0", "end_lineno", "s1", "values", "0", "end_col_offset", "1", "29", "s2", "s1", "values", "1", "assert", "isinstance", "s2", "nodes", "formattedvalue", "assert", "s2", "lineno", "s2", "col_offset", "1", "0", "assert", "s2", "end_lineno", "s2", "end_col_offset", "1", "29", "assert", "isinstance", "s2", "value", "nodes", "const", "42", "1234", "if", "py39_plus", "assert", "s2", "value", "lineno", "s2", "value", "col_offset", "1", "16", "assert", "s2", "value", "end_lineno", "s2", "value", "end_col_offset", "1", "23", "else", "bug", "in", "python", "3", "8", "https", "bugs", "python", "org", "issue44885", "assert", "s2", "value", "lineno", "s2", "value", "col_offset", "1", "1", "assert", "s2", "value", "end_lineno", "s2", "value", "end_col_offset", "1", "8", "assert", "isinstance", "s2", "format_spec", "nodes", "joinedstr", "02d", "assert", "s2", "format_spec", "lineno", "s2", "format_spec", "col_offset", "1", "0", "assert", "s2", "format_spec", "end_lineno", "s2", "format_spec", "end_col_offset", "1", "29", "s3", "ast_nodes", "1", "assert", "isinstance", "s3", "nodes", "joinedstr", "assert", "isinstance", "s3", "values", "0", "nodes", "const", "assert", "s3", "lineno", "s3", "col_offset", "2", "0", "assert", "s3", "end_lineno", "s3", "end_col_offset", "2", "17", "assert", "s3", "values", "0", "lineno", "s3", "values", "0", "col_offset", "2", "0", "assert", "s3", "values", "0", "end_lineno", "s3", "values", "0", "end_col_offset", "2", "17", "s4", "s3", "values", "1", "assert", "isinstance", "s4", "nodes", "formattedvalue", "assert", "s4", "lineno", "s4", "col_offset", "2", "0", "assert", "s4", "end_lineno", "s4", "end_col_offset", "2", "17", "assert", "isinstance", "s4", "value", "nodes", "name", "name", "if", "py39_plus", "assert", "s4", "value", "lineno", "s4", "value", "col_offset", "2", "10", "assert", "s4", "value", "end_lineno", "s4", "value", "end_col_offset", "2", "14", "else", "bug", "in", "python", "3", "8", "https", "bugs", "python", "org", "issue44885", "assert", "s4", "value", "lineno", "s4", "value", "col_offset", "2", "1", "assert", "s4", "value", "end_lineno", "s4", "value", "end_col_offset", "2", "5"], "doc_len": 320}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_match", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_match", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_match() -> None:\n        \"\"\"Match, MatchValue, MatchSingleton, MatchSequence, MatchMapping,\n        MatchClass, MatchStar, MatchOr, MatchAs.\n        \"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        match x:  #@\n            case 200 if True:  #@\n                pass\n            case True:  #@\n                pass\n            case (1, 2, *args): #@\n                pass\n            case {1: \"Hello\", **rest}: #@\n                pass\n            case Point2d(0, y=0):  #@\n                pass\n            case 200 | 300:  #@\n                pass\n            case 200 as c:  #@\n                pass\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 8\n\n        # fmt: off\n        m1 = ast_nodes[0]\n        assert isinstance(m1, nodes.Match)\n        assert (m1.lineno, m1.col_offset) == (1, 0)\n        assert (m1.end_lineno, m1.end_col_offset) == (15, 12)\n        assert (m1.subject.lineno, m1.subject.col_offset) == (1, 6)\n        assert (m1.subject.end_lineno, m1.subject.end_col_offset) == (1, 7)\n\n        m2 = ast_nodes[1]\n        assert isinstance(m2, nodes.MatchCase)\n        assert isinstance(m2.pattern, nodes.MatchValue)\n        assert isinstance(m2.guard, nodes.Const)\n        assert isinstance(m2.body[0], nodes.Pass)\n        assert (m2.pattern.lineno, m2.pattern.col_offset) == (2, 9)\n        assert (m2.pattern.end_lineno, m2.pattern.end_col_offset) == (2, 12)\n        assert (m2.guard.lineno, m2.guard.col_offset) == (2, 16)\n        assert (m2.guard.end_lineno, m2.guard.end_col_offset) == (2, 20)\n        assert (m2.body[0].lineno, m2.body[0].col_offset) == (3, 8)\n        assert (m2.body[0].end_lineno, m2.body[0].end_col_offset) == (3, 12)\n\n        m3 = ast_nodes[2]\n        assert isinstance(m3, nodes.MatchCase)\n        assert isinstance(m3.pattern, nodes.MatchSingleton)\n        assert (m3.pattern.lineno, m3.pattern.col_offset) == (4, 9)\n        assert (m3.pattern.end_lineno, m3.pattern.end_col_offset) == (4, 13)\n\n        m4 = ast_nodes[3]\n        assert isinstance(m4, nodes.MatchCase)\n        assert isinstance(m4.pattern, nodes.MatchSequence)\n        assert isinstance(m4.pattern.patterns[0], nodes.MatchValue)\n        assert (m4.pattern.lineno, m4.pattern.col_offset) == (6, 9)\n        assert (m4.pattern.end_lineno, m4.pattern.end_col_offset) == (6, 22)\n        assert (m4.pattern.patterns[0].lineno, m4.pattern.patterns[0].col_offset) == (6, 10)\n        assert (m4.pattern.patterns[0].end_lineno, m4.pattern.patterns[0].end_col_offset) == (6, 11)\n\n        m5 = m4.pattern.patterns[2]\n        assert isinstance(m5, nodes.MatchStar)\n        assert isinstance(m5.name, nodes.AssignName)\n        assert (m5.lineno, m5.col_offset) == (6, 16)\n        assert (m5.end_lineno, m5.end_col_offset) == (6, 21)\n        # TODO fix column offset: MatchStar -> name (AssignName)\n        assert (m5.name.lineno, m5.name.col_offset) == (6, 16)\n        assert (m5.name.end_lineno, m5.name.end_col_offset) == (6, 21)\n\n        m6 = ast_nodes[4]\n        assert isinstance(m6, nodes.MatchCase)\n        assert isinstance(m6.pattern, nodes.MatchMapping)\n        assert isinstance(m6.pattern.keys[0], nodes.Const)\n        assert isinstance(m6.pattern.patterns[0], nodes.MatchValue)\n        assert isinstance(m6.pattern.rest, nodes.AssignName)\n        assert (m6.pattern.lineno, m6.pattern.col_offset) == (8, 9)\n        assert (m6.pattern.end_lineno, m6.pattern.end_col_offset) == (8, 29)\n        assert (m6.pattern.keys[0].lineno, m6.pattern.keys[0].col_offset) == (8, 10)\n        assert (m6.pattern.keys[0].end_lineno, m6.pattern.keys[0].end_col_offset) == (8, 11)\n        assert (m6.pattern.patterns[0].lineno, m6.pattern.patterns[0].col_offset) == (8, 13)\n        assert (m6.pattern.patterns[0].end_lineno, m6.pattern.patterns[0].end_col_offset) == (8, 20)\n        # TODO fix column offset: MatchMapping -> rest (AssignName)\n        assert (m6.pattern.rest.lineno, m6.pattern.rest.col_offset) == (8, 9)\n        assert (m6.pattern.rest.end_lineno, m6.pattern.rest.end_col_offset) == (8, 29)\n\n        m7 = ast_nodes[5]\n        assert isinstance(m7, nodes.MatchCase)\n        assert isinstance(m7.pattern, nodes.MatchClass)\n        assert isinstance(m7.pattern.cls, nodes.Name)\n        assert isinstance(m7.pattern.patterns[0], nodes.MatchValue)\n        assert isinstance(m7.pattern.kwd_patterns[0], nodes.MatchValue)\n        assert (m7.pattern.lineno, m7.pattern.col_offset) == (10, 9)\n        assert (m7.pattern.end_lineno, m7.pattern.end_col_offset) == (10, 24)\n        assert (m7.pattern.cls.lineno, m7.pattern.cls.col_offset) == (10, 9)\n        assert (m7.pattern.cls.end_lineno, m7.pattern.cls.end_col_offset) == (10, 16)\n        assert (m7.pattern.patterns[0].lineno, m7.pattern.patterns[0].col_offset) == (10, 17)\n        assert (m7.pattern.patterns[0].end_lineno, m7.pattern.patterns[0].end_col_offset) == (10, 18)\n        assert (m7.pattern.kwd_patterns[0].lineno, m7.pattern.kwd_patterns[0].col_offset) == (10, 22)\n        assert (m7.pattern.kwd_patterns[0].end_lineno, m7.pattern.kwd_patterns[0].end_col_offset) == (10, 23)\n\n        m8 = ast_nodes[6]\n        assert isinstance(m8, nodes.MatchCase)\n        assert isinstance(m8.pattern, nodes.MatchOr)\n        assert isinstance(m8.pattern.patterns[0], nodes.MatchValue)\n        assert (m8.pattern.lineno, m8.pattern.col_offset) == (12, 9)\n        assert (m8.pattern.end_lineno, m8.pattern.end_col_offset) == (12, 18)\n        assert (m8.pattern.patterns[0].lineno, m8.pattern.patterns[0].col_offset) == (12, 9)\n        assert (m8.pattern.patterns[0].end_lineno, m8.pattern.patterns[0].end_col_offset) == (12, 12)\n\n        m9 = ast_nodes[7]\n        assert isinstance(m9, nodes.MatchCase)\n        assert isinstance(m9.pattern, nodes.MatchAs)\n        assert isinstance(m9.pattern.pattern, nodes.MatchValue)\n        assert isinstance(m9.pattern.name, nodes.AssignName)\n        assert (m9.pattern.lineno, m9.pattern.col_offset) == (14, 9)\n        assert (m9.pattern.end_lineno, m9.pattern.end_col_offset) == (14, 17)\n        assert (m9.pattern.pattern.lineno, m9.pattern.pattern.col_offset) == (14, 9)\n        assert (m9.pattern.pattern.end_lineno, m9.pattern.pattern.end_col_offset) == (14, 12)\n        # TODO fix column offset: MatchAs -> name (AssignName)\n        assert (m9.pattern.name.lineno, m9.pattern.name.col_offset) == (14, 9)\n        assert (m9.pattern.name.end_lineno, m9.pattern.name.end_col_offset) == (14, 17)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_match", "none", "match", "matchvalue", "matchsingleton", "matchsequence", "matchmapping", "matchclass", "matchstar", "matchor", "matchas", "code", "textwrap", "dedent", "match", "x", "case", "200", "if", "true", "pass", "case", "true", "pass", "case", "1", "2", "args", "pass", "case", "1", "hello", "rest", "pass", "case", "point2d", "0", "y", "0", "pass", "case", "200", "300", "pass", "case", "200", "as", "c", "pass", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "8", "fmt", "off", "m1", "ast_nodes", "0", "assert", "isinstance", "m1", "nodes", "match", "assert", "m1", "lineno", "m1", "col_offset", "1", "0", "assert", "m1", "end_lineno", "m1", "end_col_offset", "15", "12", "assert", "m1", "subject", "lineno", "m1", "subject", "col_offset", "1", "6", "assert", "m1", "subject", "end_lineno", "m1", "subject", "end_col_offset", "1", "7", "m2", "ast_nodes", "1", "assert", "isinstance", "m2", "nodes", "matchcase", "assert", "isinstance", "m2", "pattern", "nodes", "matchvalue", "assert", "isinstance", "m2", "guard", "nodes", "const", "assert", "isinstance", "m2", "body", "0", "nodes", "pass", "assert", "m2", "pattern", "lineno", "m2", "pattern", "col_offset", "2", "9", "assert", "m2", "pattern", "end_lineno", "m2", "pattern", "end_col_offset", "2", "12", "assert", "m2", "guard", "lineno", "m2", "guard", "col_offset", "2", "16", "assert", "m2", "guard", "end_lineno", "m2", "guard", "end_col_offset", "2", "20", "assert", "m2", "body", "0", "lineno", "m2", "body", "0", "col_offset", "3", "8", "assert", "m2", "body", "0", "end_lineno", "m2", "body", "0", "end_col_offset", "3", "12", "m3", "ast_nodes", "2", "assert", "isinstance", "m3", "nodes", "matchcase", "assert", "isinstance", "m3", "pattern", "nodes", "matchsingleton", "assert", "m3", "pattern", "lineno", "m3", "pattern", "col_offset", "4", "9", "assert", "m3", "pattern", "end_lineno", "m3", "pattern", "end_col_offset", "4", "13", "m4", "ast_nodes", "3", "assert", "isinstance", "m4", "nodes", "matchcase", "assert", "isinstance", "m4", "pattern", "nodes", "matchsequence", "assert", "isinstance", "m4", "pattern", "patterns", "0", "nodes", "matchvalue", "assert", "m4", "pattern", "lineno", "m4", "pattern", "col_offset", "6", "9", "assert", "m4", "pattern", "end_lineno", "m4", "pattern", "end_col_offset", "6", "22", "assert", "m4", "pattern", "patterns", "0", "lineno", "m4", "pattern", "patterns", "0", "col_offset", "6", "10", "assert", "m4", "pattern", "patterns", "0", "end_lineno", "m4", "pattern", "patterns", "0", "end_col_offset", "6", "11", "m5", "m4", "pattern", "patterns", "2", "assert", "isinstance", "m5", "nodes", "matchstar", "assert", "isinstance", "m5", "name", "nodes", "assignname", "assert", "m5", "lineno", "m5", "col_offset", "6", "16", "assert", "m5", "end_lineno", "m5", "end_col_offset", "6", "21", "todo", "fix", "column", "offset", "matchstar", "name", "assignname", "assert", "m5", "name", "lineno", "m5", "name", "col_offset", "6", "16", "assert", "m5", "name", "end_lineno", "m5", "name", "end_col_offset", "6", "21", "m6", "ast_nodes", "4", "assert", "isinstance", "m6", "nodes", "matchcase", "assert", "isinstance", "m6", "pattern", "nodes", "matchmapping", "assert", "isinstance", "m6", "pattern", "keys", "0", "nodes", "const", "assert", "isinstance", "m6", "pattern", "patterns", "0", "nodes", "matchvalue", "assert", "isinstance", "m6", "pattern", "rest", "nodes", "assignname", "assert", "m6", "pattern", "lineno", "m6", "pattern", "col_offset", "8", "9", "assert", "m6", "pattern", "end_lineno", "m6", "pattern", "end_col_offset", "8", "29", "assert", "m6", "pattern", "keys", "0", "lineno", "m6", "pattern", "keys", "0", "col_offset", "8", "10", "assert", "m6", "pattern", "keys", "0", "end_lineno", "m6", "pattern", "keys", "0", "end_col_offset", "8", "11", "assert", "m6", "pattern", "patterns", "0", "lineno", "m6", "pattern", "patterns", "0", "col_offset", "8", "13", "assert", "m6", "pattern", "patterns", "0", "end_lineno", "m6", "pattern", "patterns", "0", "end_col_offset", "8", "20", "todo", "fix", "column", "offset", "matchmapping", "rest", "assignname", "assert", "m6", "pattern", "rest", "lineno", "m6", "pattern", "rest", "col_offset", "8", "9", "assert", "m6", "pattern", "rest", "end_lineno", "m6", "pattern", "rest", "end_col_offset", "8", "29", "m7", "ast_nodes", "5", "assert", "isinstance", "m7", "nodes", "matchcase", "assert", "isinstance", "m7", "pattern", "nodes", "matchclass", "assert", "isinstance", "m7", "pattern", "cls", "nodes", "name", "assert", "isinstance", "m7", "pattern", "patterns", "0", "nodes", "matchvalue", "assert", "isinstance", "m7", "pattern", "kwd_patterns", "0", "nodes", "matchvalue", "assert", "m7", "pattern", "lineno", "m7", "pattern", "col_offset", "10", "9", "assert", "m7", "pattern", "end_lineno", "m7", "pattern", "end_col_offset", "10", "24", "assert", "m7", "pattern", "cls", "lineno", "m7", "pattern", "cls", "col_offset", "10", "9", "assert", "m7", "pattern", "cls", "end_lineno", "m7", "pattern", "cls", "end_col_offset", "10", "16", "assert", "m7", "pattern", "patterns", "0", "lineno", "m7", "pattern", "patterns", "0", "col_offset", "10", "17", "assert", "m7", "pattern", "patterns", "0", "end_lineno", "m7", "pattern", "patterns", "0", "end_col_offset", "10", "18", "assert", "m7", "pattern", "kwd_patterns", "0", "lineno", "m7", "pattern", "kwd_patterns", "0", "col_offset", "10", "22", "assert", "m7", "pattern", "kwd_patterns", "0", "end_lineno", "m7", "pattern", "kwd_patterns", "0", "end_col_offset", "10", "23", "m8", "ast_nodes", "6", "assert", "isinstance", "m8", "nodes", "matchcase", "assert", "isinstance", "m8", "pattern", "nodes", "matchor", "assert", "isinstance", "m8", "pattern", "patterns", "0", "nodes", "matchvalue", "assert", "m8", "pattern", "lineno", "m8", "pattern", "col_offset", "12", "9", "assert", "m8", "pattern", "end_lineno", "m8", "pattern", "end_col_offset", "12", "18", "assert", "m8", "pattern", "patterns", "0", "lineno", "m8", "pattern", "patterns", "0", "col_offset", "12", "9", "assert", "m8", "pattern", "patterns", "0", "end_lineno", "m8", "pattern", "patterns", "0", "end_col_offset", "12", "12", "m9", "ast_nodes", "7", "assert", "isinstance", "m9", "nodes", "matchcase", "assert", "isinstance", "m9", "pattern", "nodes", "matchas", "assert", "isinstance", "m9", "pattern", "pattern", "nodes", "matchvalue", "assert", "isinstance", "m9", "pattern", "name", "nodes", "assignname", "assert", "m9", "pattern", "lineno", "m9", "pattern", "col_offset", "14", "9", "assert", "m9", "pattern", "end_lineno", "m9", "pattern", "end_col_offset", "14", "17", "assert", "m9", "pattern", "pattern", "lineno", "m9", "pattern", "pattern", "col_offset", "14", "9", "assert", "m9", "pattern", "pattern", "end_lineno", "m9", "pattern", "pattern", "end_col_offset", "14", "12", "todo", "fix", "column", "offset", "matchas", "name", "assignname", "assert", "m9", "pattern", "name", "lineno", "m9", "pattern", "name", "col_offset", "14", "9", "assert", "m9", "pattern", "name", "end_lineno", "m9", "pattern", "name", "end_col_offset", "14", "17"], "doc_len": 775}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_comprehension", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_comprehension", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_comprehension() -> None:\n        \"\"\"ListComp, SetComp, DictComp, GeneratorExpr.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        [x for x in var]  #@\n        {x for x in var}  #@\n        {x: y for x, y in var}  #@\n        (x for x in var)  #@\n        \"\"\"\n        ).strip()\n        ast_nodes = builder.extract_node(code)\n        assert isinstance(ast_nodes, list) and len(ast_nodes) == 4\n\n        c1 = ast_nodes[0]\n        assert isinstance(c1, nodes.ListComp)\n        assert isinstance(c1.elt, nodes.Name)\n        assert isinstance(c1.generators[0], nodes.Comprehension)  # type: ignore\n        assert (c1.lineno, c1.col_offset) == (1, 0)\n        assert (c1.end_lineno, c1.end_col_offset) == (1, 16)\n        assert (c1.elt.lineno, c1.elt.col_offset) == (1, 1)\n        assert (c1.elt.end_lineno, c1.elt.end_col_offset) == (1, 2)\n\n        c2 = ast_nodes[1]\n        assert isinstance(c2, nodes.SetComp)\n        assert isinstance(c2.elt, nodes.Name)\n        assert isinstance(c2.generators[0], nodes.Comprehension)  # type: ignore\n        assert (c2.lineno, c2.col_offset) == (2, 0)\n        assert (c2.end_lineno, c2.end_col_offset) == (2, 16)\n        assert (c2.elt.lineno, c2.elt.col_offset) == (2, 1)\n        assert (c2.elt.end_lineno, c2.elt.end_col_offset) == (2, 2)\n\n        c3 = ast_nodes[2]\n        assert isinstance(c3, nodes.DictComp)\n        assert isinstance(c3.key, nodes.Name)\n        assert isinstance(c3.value, nodes.Name)\n        assert isinstance(c3.generators[0], nodes.Comprehension)  # type: ignore\n        assert (c3.lineno, c3.col_offset) == (3, 0)\n        assert (c3.end_lineno, c3.end_col_offset) == (3, 22)\n        assert (c3.key.lineno, c3.key.col_offset) == (3, 1)\n        assert (c3.key.end_lineno, c3.key.end_col_offset) == (3, 2)\n        assert (c3.value.lineno, c3.value.col_offset) == (3, 4)\n        assert (c3.value.end_lineno, c3.value.end_col_offset) == (3, 5)\n\n        c4 = ast_nodes[3]\n        assert isinstance(c4, nodes.GeneratorExp)\n        assert isinstance(c4.elt, nodes.Name)\n        assert isinstance(c4.generators[0], nodes.Comprehension)  # type: ignore\n        assert (c4.lineno, c4.col_offset) == (4, 0)\n        assert (c4.end_lineno, c4.end_col_offset) == (4, 16)\n        assert (c4.elt.lineno, c4.elt.col_offset) == (4, 1)\n        assert (c4.elt.end_lineno, c4.elt.end_col_offset) == (4, 2)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_comprehension", "none", "listcomp", "setcomp", "dictcomp", "generatorexpr", "code", "textwrap", "dedent", "x", "for", "x", "in", "var", "x", "for", "x", "in", "var", "x", "y", "for", "x", "y", "in", "var", "x", "for", "x", "in", "var", "strip", "ast_nodes", "builder", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "and", "len", "ast_nodes", "4", "c1", "ast_nodes", "0", "assert", "isinstance", "c1", "nodes", "listcomp", "assert", "isinstance", "c1", "elt", "nodes", "name", "assert", "isinstance", "c1", "generators", "0", "nodes", "comprehension", "type", "ignore", "assert", "c1", "lineno", "c1", "col_offset", "1", "0", "assert", "c1", "end_lineno", "c1", "end_col_offset", "1", "16", "assert", "c1", "elt", "lineno", "c1", "elt", "col_offset", "1", "1", "assert", "c1", "elt", "end_lineno", "c1", "elt", "end_col_offset", "1", "2", "c2", "ast_nodes", "1", "assert", "isinstance", "c2", "nodes", "setcomp", "assert", "isinstance", "c2", "elt", "nodes", "name", "assert", "isinstance", "c2", "generators", "0", "nodes", "comprehension", "type", "ignore", "assert", "c2", "lineno", "c2", "col_offset", "2", "0", "assert", "c2", "end_lineno", "c2", "end_col_offset", "2", "16", "assert", "c2", "elt", "lineno", "c2", "elt", "col_offset", "2", "1", "assert", "c2", "elt", "end_lineno", "c2", "elt", "end_col_offset", "2", "2", "c3", "ast_nodes", "2", "assert", "isinstance", "c3", "nodes", "dictcomp", "assert", "isinstance", "c3", "key", "nodes", "name", "assert", "isinstance", "c3", "value", "nodes", "name", "assert", "isinstance", "c3", "generators", "0", "nodes", "comprehension", "type", "ignore", "assert", "c3", "lineno", "c3", "col_offset", "3", "0", "assert", "c3", "end_lineno", "c3", "end_col_offset", "3", "22", "assert", "c3", "key", "lineno", "c3", "key", "col_offset", "3", "1", "assert", "c3", "key", "end_lineno", "c3", "key", "end_col_offset", "3", "2", "assert", "c3", "value", "lineno", "c3", "value", "col_offset", "3", "4", "assert", "c3", "value", "end_lineno", "c3", "value", "end_col_offset", "3", "5", "c4", "ast_nodes", "3", "assert", "isinstance", "c4", "nodes", "generatorexp", "assert", "isinstance", "c4", "elt", "nodes", "name", "assert", "isinstance", "c4", "generators", "0", "nodes", "comprehension", "type", "ignore", "assert", "c4", "lineno", "c4", "col_offset", "4", "0", "assert", "c4", "end_lineno", "c4", "end_col_offset", "4", "16", "assert", "c4", "elt", "lineno", "c4", "elt", "col_offset", "4", "1", "assert", "c4", "elt", "end_lineno", "c4", "elt", "end_col_offset", "4", "2"], "doc_len": 293}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_class", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_class", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_class() -> None:\n        \"\"\"ClassDef, Keyword.\"\"\"\n        code = textwrap.dedent(\n            \"\"\"\n        @decorator1\n        @decorator2\n        class X(Parent, var=42):\n            pass\n        \"\"\"\n        ).strip()\n        c1 = builder.extract_node(code)\n        assert isinstance(c1, nodes.ClassDef)\n        assert isinstance(c1.decorators, nodes.Decorators)\n        assert isinstance(c1.bases[0], nodes.Name)\n        assert isinstance(c1.keywords[0], nodes.Keyword)\n        assert isinstance(c1.body[0], nodes.Pass)\n\n        # fmt: off\n        assert (c1.lineno, c1.col_offset) == (3, 0)\n        assert (c1.end_lineno, c1.end_col_offset) == (4, 8)\n        assert (c1.decorators.lineno, c1.decorators.col_offset) == (1, 0)\n        assert (c1.decorators.end_lineno, c1.decorators.end_col_offset) == (2, 11)\n        assert (c1.bases[0].lineno, c1.bases[0].col_offset) == (3, 8)\n        assert (c1.bases[0].end_lineno, c1.bases[0].end_col_offset) == (3, 14)\n        if PY39_PLUS:\n            # 'lineno' and 'col_offset' information only added in Python 3.9\n            assert (c1.keywords[0].lineno, c1.keywords[0].col_offset) == (3, 16)\n            assert (c1.keywords[0].end_lineno, c1.keywords[0].end_col_offset) == (3, 22)\n        else:\n            assert (c1.keywords[0].lineno, c1.keywords[0].col_offset) == (None, None)\n            assert (c1.keywords[0].end_lineno, c1.keywords[0].end_col_offset) == (None, None)\n        assert (c1.body[0].lineno, c1.body[0].col_offset) == (4, 4)\n        assert (c1.body[0].end_lineno, c1.body[0].end_col_offset) == (4, 8)\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_class", "none", "classdef", "keyword", "code", "textwrap", "dedent", "decorator1", "decorator2", "class", "x", "parent", "var", "42", "pass", "strip", "c1", "builder", "extract_node", "code", "assert", "isinstance", "c1", "nodes", "classdef", "assert", "isinstance", "c1", "decorators", "nodes", "decorators", "assert", "isinstance", "c1", "bases", "0", "nodes", "name", "assert", "isinstance", "c1", "keywords", "0", "nodes", "keyword", "assert", "isinstance", "c1", "body", "0", "nodes", "pass", "fmt", "off", "assert", "c1", "lineno", "c1", "col_offset", "3", "0", "assert", "c1", "end_lineno", "c1", "end_col_offset", "4", "8", "assert", "c1", "decorators", "lineno", "c1", "decorators", "col_offset", "1", "0", "assert", "c1", "decorators", "end_lineno", "c1", "decorators", "end_col_offset", "2", "11", "assert", "c1", "bases", "0", "lineno", "c1", "bases", "0", "col_offset", "3", "8", "assert", "c1", "bases", "0", "end_lineno", "c1", "bases", "0", "end_col_offset", "3", "14", "if", "py39_plus", "lineno", "and", "col_offset", "information", "only", "added", "in", "python", "3", "9", "assert", "c1", "keywords", "0", "lineno", "c1", "keywords", "0", "col_offset", "3", "16", "assert", "c1", "keywords", "0", "end_lineno", "c1", "keywords", "0", "end_col_offset", "3", "22", "else", "assert", "c1", "keywords", "0", "lineno", "c1", "keywords", "0", "col_offset", "none", "none", "assert", "c1", "keywords", "0", "end_lineno", "c1", "keywords", "0", "end_col_offset", "none", "none", "assert", "c1", "body", "0", "lineno", "c1", "body", "0", "col_offset", "4", "4", "assert", "c1", "body", "0", "end_lineno", "c1", "body", "0", "end_col_offset", "4", "8"], "doc_len": 192}
{"doc_id": "tests/unittest_nodes_lineno.py::TestLinenoColOffset.test_end_lineno_module", "file_path": "tests/unittest_nodes_lineno.py", "class_name": "TestLinenoColOffset", "func_name": "test_end_lineno_module", "text": "文件路径: tests/unittest_nodes_lineno.py, 类名: TestLinenoColOffset\n    def test_end_lineno_module() -> None:\n        \"\"\"Tests for Module\"\"\"\n        code = \"\"\"print()\"\"\"\n        module = astroid.parse(code)\n        assert isinstance(module, nodes.Module)\n        assert module.lineno == 0\n        assert module.col_offset is None\n        assert module.end_lineno is None\n        assert module.end_col_offset is None\n", "tokens": ["tests", "unittest_nodes_lineno", "py", "testlinenocoloffset", "def", "test_end_lineno_module", "none", "tests", "for", "module", "code", "print", "module", "astroid", "parse", "code", "assert", "isinstance", "module", "nodes", "module", "assert", "module", "lineno", "0", "assert", "module", "col_offset", "is", "none", "assert", "module", "end_lineno", "is", "none", "assert", "module", "end_col_offset", "is", "none"], "doc_len": 40}
{"doc_id": "tests/unittest_objects.py::ObjectsTest.test_frozenset", "file_path": "tests/unittest_objects.py", "class_name": "ObjectsTest", "func_name": "test_frozenset", "text": "文件路径: tests/unittest_objects.py, 类名: ObjectsTest\n    def test_frozenset(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        frozenset({1: 2, 2: 3}) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, objects.FrozenSet)\n\n        self.assertEqual(inferred.pytype(), \"builtins.frozenset\")\n\n        itered = inferred.itered()\n        self.assertEqual(len(itered), 2)\n        self.assertIsInstance(itered[0], nodes.Const)\n        self.assertEqual([const.value for const in itered], [1, 2])\n\n        proxied = inferred._proxied\n        self.assertEqual(inferred.qname(), \"builtins.frozenset\")\n        self.assertIsInstance(proxied, nodes.ClassDef)\n", "tokens": ["tests", "unittest_objects", "py", "objectstest", "def", "test_frozenset", "self", "none", "node", "builder", "extract_node", "frozenset", "1", "2", "2", "3", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "objects", "frozenset", "self", "assertequal", "inferred", "pytype", "builtins", "frozenset", "itered", "inferred", "itered", "self", "assertequal", "len", "itered", "2", "self", "assertisinstance", "itered", "0", "nodes", "const", "self", "assertequal", "const", "value", "for", "const", "in", "itered", "1", "2", "proxied", "inferred", "_proxied", "self", "assertequal", "inferred", "qname", "builtins", "frozenset", "self", "assertisinstance", "proxied", "nodes", "classdef"], "doc_len": 69}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_inferring_super_outside_methods", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_inferring_super_outside_methods", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_inferring_super_outside_methods(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class Module(object):\n            pass\n        class StaticMethod(object):\n            @staticmethod\n            def static():\n                # valid, but we don't bother with it.\n                return super(StaticMethod, StaticMethod) #@\n        # super outside methods aren't inferred\n        super(Module, Module) #@\n        # no argument super is not recognised outside methods as well.\n        super() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        in_static = next(ast_nodes[0].value.infer())\n        self.assertIsInstance(in_static, bases.Instance)\n        self.assertEqual(in_static.qname(), \"builtins.super\")\n\n        module_level = next(ast_nodes[1].infer())\n        self.assertIsInstance(module_level, bases.Instance)\n        self.assertEqual(in_static.qname(), \"builtins.super\")\n\n        no_arguments = next(ast_nodes[2].infer())\n        self.assertIsInstance(no_arguments, bases.Instance)\n        self.assertEqual(no_arguments.qname(), \"builtins.super\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_inferring_super_outside_methods", "self", "none", "ast_nodes", "builder", "extract_node", "class", "module", "object", "pass", "class", "staticmethod", "object", "staticmethod", "def", "static", "valid", "but", "we", "don", "t", "bother", "with", "it", "return", "super", "staticmethod", "staticmethod", "super", "outside", "methods", "aren", "t", "inferred", "super", "module", "module", "no", "argument", "super", "is", "not", "recognised", "outside", "methods", "as", "well", "super", "assert", "isinstance", "ast_nodes", "list", "in_static", "next", "ast_nodes", "0", "value", "infer", "self", "assertisinstance", "in_static", "bases", "instance", "self", "assertequal", "in_static", "qname", "builtins", "super", "module_level", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "module_level", "bases", "instance", "self", "assertequal", "in_static", "qname", "builtins", "super", "no_arguments", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "no_arguments", "bases", "instance", "self", "assertequal", "no_arguments", "qname", "builtins", "super"], "doc_len": 106}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_inferring_unbound_super_doesnt_work", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_inferring_unbound_super_doesnt_work", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_inferring_unbound_super_doesnt_work(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class Test(object):\n            def __init__(self):\n                super(Test) #@\n        \"\"\"\n        )\n        unbounded = next(node.infer())\n        self.assertIsInstance(unbounded, bases.Instance)\n        self.assertEqual(unbounded.qname(), \"builtins.super\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_inferring_unbound_super_doesnt_work", "self", "none", "node", "builder", "extract_node", "class", "test", "object", "def", "__init__", "self", "super", "test", "unbounded", "next", "node", "infer", "self", "assertisinstance", "unbounded", "bases", "instance", "self", "assertequal", "unbounded", "qname", "builtins", "super"], "doc_len": 34}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_use_default_inference_on_not_inferring_args", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_use_default_inference_on_not_inferring_args", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_use_default_inference_on_not_inferring_args(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class Test(object):\n            def __init__(self):\n                super(Lala, self) #@\n                super(Test, lala) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, bases.Instance)\n        self.assertEqual(first.qname(), \"builtins.super\")\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, bases.Instance)\n        self.assertEqual(second.qname(), \"builtins.super\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_use_default_inference_on_not_inferring_args", "self", "none", "ast_nodes", "builder", "extract_node", "class", "test", "object", "def", "__init__", "self", "super", "lala", "self", "super", "test", "lala", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "bases", "instance", "self", "assertequal", "first", "qname", "builtins", "super", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "bases", "instance", "self", "assertequal", "second", "qname", "builtins", "super"], "doc_len": 59}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_no_arguments_super", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_no_arguments_super", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_no_arguments_super(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class First(object): pass\n        class Second(First):\n            def test(self):\n                super() #@\n            @classmethod\n            def test_classmethod(cls):\n                super() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, objects.Super)\n        self.assertIsInstance(first.type, bases.Instance)\n        self.assertEqual(first.type.name, \"Second\")\n        self.assertIsInstance(first.mro_pointer, nodes.ClassDef)\n        self.assertEqual(first.mro_pointer.name, \"Second\")\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, objects.Super)\n        self.assertIsInstance(second.type, nodes.ClassDef)\n        self.assertEqual(second.type.name, \"Second\")\n        self.assertIsInstance(second.mro_pointer, nodes.ClassDef)\n        self.assertEqual(second.mro_pointer.name, \"Second\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_no_arguments_super", "self", "none", "ast_nodes", "builder", "extract_node", "class", "first", "object", "pass", "class", "second", "first", "def", "test", "self", "super", "classmethod", "def", "test_classmethod", "cls", "super", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "objects", "super", "self", "assertisinstance", "first", "type", "bases", "instance", "self", "assertequal", "first", "type", "name", "second", "self", "assertisinstance", "first", "mro_pointer", "nodes", "classdef", "self", "assertequal", "first", "mro_pointer", "name", "second", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "objects", "super", "self", "assertisinstance", "second", "type", "nodes", "classdef", "self", "assertequal", "second", "type", "name", "second", "self", "assertisinstance", "second", "mro_pointer", "nodes", "classdef", "self", "assertequal", "second", "mro_pointer", "name", "second"], "doc_len": 99}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_simple_cases", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_simple_cases", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_simple_cases(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class First(object): pass\n        class Second(First): pass\n        class Third(First):\n            def test(self):\n                super(Third, self) #@\n                super(Second, self) #@\n\n                # mro position and the type\n                super(Third, Third) #@\n                super(Third, Second) #@\n                super(Fourth, Fourth) #@\n\n        class Fourth(Third):\n            pass\n        \"\"\"\n        )\n\n        # .type is the object which provides the mro.\n        # .mro_pointer is the position in the mro from where\n        # the lookup should be done.\n\n        # super(Third, self)\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, objects.Super)\n        self.assertIsInstance(first.type, bases.Instance)\n        self.assertEqual(first.type.name, \"Third\")\n        self.assertIsInstance(first.mro_pointer, nodes.ClassDef)\n        self.assertEqual(first.mro_pointer.name, \"Third\")\n\n        # super(Second, self)\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, objects.Super)\n        self.assertIsInstance(second.type, bases.Instance)\n        self.assertEqual(second.type.name, \"Third\")\n        self.assertIsInstance(first.mro_pointer, nodes.ClassDef)\n        self.assertEqual(second.mro_pointer.name, \"Second\")\n\n        # super(Third, Third)\n        third = next(ast_nodes[2].infer())\n        self.assertIsInstance(third, objects.Super)\n        self.assertIsInstance(third.type, nodes.ClassDef)\n        self.assertEqual(third.type.name, \"Third\")\n        self.assertIsInstance(third.mro_pointer, nodes.ClassDef)\n        self.assertEqual(third.mro_pointer.name, \"Third\")\n\n        # super(Third, second)\n        fourth = next(ast_nodes[3].infer())\n        self.assertIsInstance(fourth, objects.Super)\n        self.assertIsInstance(fourth.type, nodes.ClassDef)\n        self.assertEqual(fourth.type.name, \"Second\")\n        self.assertIsInstance(fourth.mro_pointer, nodes.ClassDef)\n        self.assertEqual(fourth.mro_pointer.name, \"Third\")\n\n        # Super(Fourth, Fourth)\n        fifth = next(ast_nodes[4].infer())\n        self.assertIsInstance(fifth, objects.Super)\n        self.assertIsInstance(fifth.type, nodes.ClassDef)\n        self.assertEqual(fifth.type.name, \"Fourth\")\n        self.assertIsInstance(fifth.mro_pointer, nodes.ClassDef)\n        self.assertEqual(fifth.mro_pointer.name, \"Fourth\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_simple_cases", "self", "none", "ast_nodes", "builder", "extract_node", "class", "first", "object", "pass", "class", "second", "first", "pass", "class", "third", "first", "def", "test", "self", "super", "third", "self", "super", "second", "self", "mro", "position", "and", "the", "type", "super", "third", "third", "super", "third", "second", "super", "fourth", "fourth", "class", "fourth", "third", "pass", "type", "is", "the", "object", "which", "provides", "the", "mro", "mro_pointer", "is", "the", "position", "in", "the", "mro", "from", "where", "the", "lookup", "should", "be", "done", "super", "third", "self", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "objects", "super", "self", "assertisinstance", "first", "type", "bases", "instance", "self", "assertequal", "first", "type", "name", "third", "self", "assertisinstance", "first", "mro_pointer", "nodes", "classdef", "self", "assertequal", "first", "mro_pointer", "name", "third", "super", "second", "self", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "objects", "super", "self", "assertisinstance", "second", "type", "bases", "instance", "self", "assertequal", "second", "type", "name", "third", "self", "assertisinstance", "first", "mro_pointer", "nodes", "classdef", "self", "assertequal", "second", "mro_pointer", "name", "second", "super", "third", "third", "third", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third", "objects", "super", "self", "assertisinstance", "third", "type", "nodes", "classdef", "self", "assertequal", "third", "type", "name", "third", "self", "assertisinstance", "third", "mro_pointer", "nodes", "classdef", "self", "assertequal", "third", "mro_pointer", "name", "third", "super", "third", "second", "fourth", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "fourth", "objects", "super", "self", "assertisinstance", "fourth", "type", "nodes", "classdef", "self", "assertequal", "fourth", "type", "name", "second", "self", "assertisinstance", "fourth", "mro_pointer", "nodes", "classdef", "self", "assertequal", "fourth", "mro_pointer", "name", "third", "super", "fourth", "fourth", "fifth", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "fifth", "objects", "super", "self", "assertisinstance", "fifth", "type", "nodes", "classdef", "self", "assertequal", "fifth", "type", "name", "fourth", "self", "assertisinstance", "fifth", "mro_pointer", "nodes", "classdef", "self", "assertequal", "fifth", "mro_pointer", "name", "fourth"], "doc_len": 260}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_infer", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_infer", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_infer(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class Super(object):\n            def __init__(self):\n                super(Super, self) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, objects.Super)\n        reinferred = next(inferred.infer())\n        self.assertIsInstance(reinferred, objects.Super)\n        self.assertIs(inferred, reinferred)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_infer", "self", "none", "node", "builder", "extract_node", "class", "super", "object", "def", "__init__", "self", "super", "super", "self", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "objects", "super", "reinferred", "next", "inferred", "infer", "self", "assertisinstance", "reinferred", "objects", "super", "self", "assertis", "inferred", "reinferred"], "doc_len": 42}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_inferring_invalid_supers", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_inferring_invalid_supers", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_inferring_invalid_supers(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class Super(object):\n            def __init__(self):\n                # MRO pointer is not a type\n                super(1, self) #@\n                # MRO type is not a subtype\n                super(Super, 1) #@\n                # self is not a subtype of Bupper\n                super(Bupper, self) #@\n        class Bupper(Super):\n            pass\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, objects.Super)\n        with self.assertRaises(SuperError) as cm:\n            first.super_mro()\n        self.assertIsInstance(cm.exception.super_.mro_pointer, nodes.Const)\n        self.assertEqual(cm.exception.super_.mro_pointer.value, 1)\n        for node, invalid_type in zip(ast_nodes[1:], (nodes.Const, bases.Instance)):\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, objects.Super, node)\n            with self.assertRaises(SuperError) as cm:\n                inferred.super_mro()\n            self.assertIsInstance(cm.exception.super_.type, invalid_type)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_inferring_invalid_supers", "self", "none", "ast_nodes", "builder", "extract_node", "class", "super", "object", "def", "__init__", "self", "mro", "pointer", "is", "not", "a", "type", "super", "1", "self", "mro", "type", "is", "not", "a", "subtype", "super", "super", "1", "self", "is", "not", "a", "subtype", "of", "bupper", "super", "bupper", "self", "class", "bupper", "super", "pass", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "objects", "super", "with", "self", "assertraises", "supererror", "as", "cm", "first", "super_mro", "self", "assertisinstance", "cm", "exception", "super_", "mro_pointer", "nodes", "const", "self", "assertequal", "cm", "exception", "super_", "mro_pointer", "value", "1", "for", "node", "invalid_type", "in", "zip", "ast_nodes", "1", "nodes", "const", "bases", "instance", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "objects", "super", "node", "with", "self", "assertraises", "supererror", "as", "cm", "inferred", "super_mro", "self", "assertisinstance", "cm", "exception", "super_", "type", "invalid_type"], "doc_len": 123}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_proxied", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_proxied", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_proxied(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class Super(object):\n            def __init__(self):\n                super(Super, self) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        proxied = inferred._proxied\n        self.assertEqual(proxied.qname(), \"builtins.super\")\n        self.assertIsInstance(proxied, nodes.ClassDef)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_proxied", "self", "none", "node", "builder", "extract_node", "class", "super", "object", "def", "__init__", "self", "super", "super", "self", "inferred", "next", "node", "infer", "proxied", "inferred", "_proxied", "self", "assertequal", "proxied", "qname", "builtins", "super", "self", "assertisinstance", "proxied", "nodes", "classdef"], "doc_len": 38}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_bound_model", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_bound_model", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_bound_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class First(object):\n            def method(self):\n                pass\n            @classmethod\n            def class_method(cls):\n                pass\n        class Super_Type_Type(First):\n            def method(self):\n                super(Super_Type_Type, Super_Type_Type).method #@\n                super(Super_Type_Type, Super_Type_Type).class_method #@\n            @classmethod\n            def class_method(cls):\n                super(Super_Type_Type, Super_Type_Type).method #@\n                super(Super_Type_Type, Super_Type_Type).class_method #@\n\n        class Super_Type_Object(First):\n            def method(self):\n                super(Super_Type_Object, self).method #@\n                super(Super_Type_Object, self).class_method #@\n        \"\"\"\n        )\n        # Super(type, type) is the same for both functions and classmethods.\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, nodes.FunctionDef)\n        self.assertEqual(first.name, \"method\")\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, bases.BoundMethod)\n        self.assertEqual(second.bound.name, \"First\")\n        self.assertEqual(second.type, \"classmethod\")\n\n        third = next(ast_nodes[2].infer())\n        self.assertIsInstance(third, nodes.FunctionDef)\n        self.assertEqual(third.name, \"method\")\n\n        fourth = next(ast_nodes[3].infer())\n        self.assertIsInstance(fourth, bases.BoundMethod)\n        self.assertEqual(fourth.bound.name, \"First\")\n        self.assertEqual(fourth.type, \"classmethod\")\n\n        # Super(type, obj) can lead to different attribute bindings\n        # depending on the type of the place where super was called.\n        fifth = next(ast_nodes[4].infer())\n        self.assertIsInstance(fifth, bases.BoundMethod)\n        self.assertEqual(fifth.bound.name, \"First\")\n        self.assertEqual(fifth.type, \"method\")\n\n        sixth = next(ast_nodes[5].infer())\n        self.assertIsInstance(sixth, bases.BoundMethod)\n        self.assertEqual(sixth.bound.name, \"First\")\n        self.assertEqual(sixth.type, \"classmethod\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_bound_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "first", "object", "def", "method", "self", "pass", "classmethod", "def", "class_method", "cls", "pass", "class", "super_type_type", "first", "def", "method", "self", "super", "super_type_type", "super_type_type", "method", "super", "super_type_type", "super_type_type", "class_method", "classmethod", "def", "class_method", "cls", "super", "super_type_type", "super_type_type", "method", "super", "super_type_type", "super_type_type", "class_method", "class", "super_type_object", "first", "def", "method", "self", "super", "super_type_object", "self", "method", "super", "super_type_object", "self", "class_method", "super", "type", "type", "is", "the", "same", "for", "both", "functions", "and", "classmethods", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "nodes", "functiondef", "self", "assertequal", "first", "name", "method", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "bases", "boundmethod", "self", "assertequal", "second", "bound", "name", "first", "self", "assertequal", "second", "type", "classmethod", "third", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third", "nodes", "functiondef", "self", "assertequal", "third", "name", "method", "fourth", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "fourth", "bases", "boundmethod", "self", "assertequal", "fourth", "bound", "name", "first", "self", "assertequal", "fourth", "type", "classmethod", "super", "type", "obj", "can", "lead", "to", "different", "attribute", "bindings", "depending", "on", "the", "type", "of", "the", "place", "where", "super", "was", "called", "fifth", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "fifth", "bases", "boundmethod", "self", "assertequal", "fifth", "bound", "name", "first", "self", "assertequal", "fifth", "type", "method", "sixth", "next", "ast_nodes", "5", "infer", "self", "assertisinstance", "sixth", "bases", "boundmethod", "self", "assertequal", "sixth", "bound", "name", "first", "self", "assertequal", "sixth", "type", "classmethod"], "doc_len": 212}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_getattr_single_inheritance", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_getattr_single_inheritance", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_getattr_single_inheritance(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class First(object):\n            def test(self): pass\n        class Second(First):\n            def test2(self): pass\n        class Third(Second):\n            test3 = 42\n            def __init__(self):\n                super(Third, self).test2 #@\n                super(Third, self).test #@\n                # test3 is local, no MRO lookup is done.\n                super(Third, self).test3 #@\n                super(Third, self) #@\n\n                # Unbounds.\n                super(Third, Third).test2 #@\n                super(Third, Third).test #@\n\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, bases.BoundMethod)\n        self.assertEqual(first.bound.name, \"Second\")\n\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, bases.BoundMethod)\n        self.assertEqual(second.bound.name, \"First\")\n\n        with self.assertRaises(InferenceError):\n            next(ast_nodes[2].infer())\n        fourth = next(ast_nodes[3].infer())\n        with self.assertRaises(AttributeInferenceError):\n            fourth.getattr(\"test3\")\n        with self.assertRaises(AttributeInferenceError):\n            next(fourth.igetattr(\"test3\"))\n\n        first_unbound = next(ast_nodes[4].infer())\n        self.assertIsInstance(first_unbound, nodes.FunctionDef)\n        self.assertEqual(first_unbound.name, \"test2\")\n        self.assertEqual(first_unbound.parent.name, \"Second\")\n\n        second_unbound = next(ast_nodes[5].infer())\n        self.assertIsInstance(second_unbound, nodes.FunctionDef)\n        self.assertEqual(second_unbound.name, \"test\")\n        self.assertEqual(second_unbound.parent.name, \"First\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_getattr_single_inheritance", "self", "none", "ast_nodes", "builder", "extract_node", "class", "first", "object", "def", "test", "self", "pass", "class", "second", "first", "def", "test2", "self", "pass", "class", "third", "second", "test3", "42", "def", "__init__", "self", "super", "third", "self", "test2", "super", "third", "self", "test", "test3", "is", "local", "no", "mro", "lookup", "is", "done", "super", "third", "self", "test3", "super", "third", "self", "unbounds", "super", "third", "third", "test2", "super", "third", "third", "test", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "bases", "boundmethod", "self", "assertequal", "first", "bound", "name", "second", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "bases", "boundmethod", "self", "assertequal", "second", "bound", "name", "first", "with", "self", "assertraises", "inferenceerror", "next", "ast_nodes", "2", "infer", "fourth", "next", "ast_nodes", "3", "infer", "with", "self", "assertraises", "attributeinferenceerror", "fourth", "getattr", "test3", "with", "self", "assertraises", "attributeinferenceerror", "next", "fourth", "igetattr", "test3", "first_unbound", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "first_unbound", "nodes", "functiondef", "self", "assertequal", "first_unbound", "name", "test2", "self", "assertequal", "first_unbound", "parent", "name", "second", "second_unbound", "next", "ast_nodes", "5", "infer", "self", "assertisinstance", "second_unbound", "nodes", "functiondef", "self", "assertequal", "second_unbound", "name", "test", "self", "assertequal", "second_unbound", "parent", "name", "first"], "doc_len": 171}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_invalid_mro", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_invalid_mro", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_invalid_mro(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class A(object):\n           test = 42\n        class Super(A, A):\n           def __init__(self):\n               super(Super, self) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        with self.assertRaises(AttributeInferenceError):\n            next(inferred.getattr(\"test\"))\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_invalid_mro", "self", "none", "node", "builder", "extract_node", "class", "a", "object", "test", "42", "class", "super", "a", "a", "def", "__init__", "self", "super", "super", "self", "inferred", "next", "node", "infer", "with", "self", "assertraises", "attributeinferenceerror", "next", "inferred", "getattr", "test"], "doc_len": 38}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_complex_mro", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_complex_mro", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_complex_mro(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A(object):\n            def spam(self): return \"A\"\n            def foo(self): return \"A\"\n            @staticmethod\n            def static(self): pass\n        class B(A):\n            def boo(self): return \"B\"\n            def spam(self): return \"B\"\n        class C(A):\n            def boo(self): return \"C\"\n        class E(C, B):\n            def __init__(self):\n                super(E, self).boo #@\n                super(C, self).boo #@\n                super(E, self).spam #@\n                super(E, self).foo #@\n                super(E, self).static #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, bases.BoundMethod)\n        self.assertEqual(first.bound.name, \"C\")\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, bases.BoundMethod)\n        self.assertEqual(second.bound.name, \"B\")\n        third = next(ast_nodes[2].infer())\n        self.assertIsInstance(third, bases.BoundMethod)\n        self.assertEqual(third.bound.name, \"B\")\n        fourth = next(ast_nodes[3].infer())\n        self.assertEqual(fourth.bound.name, \"A\")\n        static = next(ast_nodes[4].infer())\n        self.assertIsInstance(static, nodes.FunctionDef)\n        self.assertEqual(static.parent.scope().name, \"A\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_complex_mro", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "object", "def", "spam", "self", "return", "a", "def", "foo", "self", "return", "a", "staticmethod", "def", "static", "self", "pass", "class", "b", "a", "def", "boo", "self", "return", "b", "def", "spam", "self", "return", "b", "class", "c", "a", "def", "boo", "self", "return", "c", "class", "e", "c", "b", "def", "__init__", "self", "super", "e", "self", "boo", "super", "c", "self", "boo", "super", "e", "self", "spam", "super", "e", "self", "foo", "super", "e", "self", "static", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "bases", "boundmethod", "self", "assertequal", "first", "bound", "name", "c", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "bases", "boundmethod", "self", "assertequal", "second", "bound", "name", "b", "third", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "third", "bases", "boundmethod", "self", "assertequal", "third", "bound", "name", "b", "fourth", "next", "ast_nodes", "3", "infer", "self", "assertequal", "fourth", "bound", "name", "a", "static", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "static", "nodes", "functiondef", "self", "assertequal", "static", "parent", "scope", "name", "a"], "doc_len": 157}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_data_model", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_data_model", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_data_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class X(object): pass\n        class A(X):\n            def __init__(self):\n                super(A, self) #@\n                super(A, A) #@\n                super(X, A) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        thisclass = first.getattr(\"__thisclass__\")[0]\n        self.assertIsInstance(thisclass, nodes.ClassDef)\n        self.assertEqual(thisclass.name, \"A\")\n        selfclass = first.getattr(\"__self_class__\")[0]\n        self.assertIsInstance(selfclass, nodes.ClassDef)\n        self.assertEqual(selfclass.name, \"A\")\n        self_ = first.getattr(\"__self__\")[0]\n        self.assertIsInstance(self_, bases.Instance)\n        self.assertEqual(self_.name, \"A\")\n        cls = first.getattr(\"__class__\")[0]\n        self.assertEqual(cls, first._proxied)\n\n        second = next(ast_nodes[1].infer())\n        thisclass = second.getattr(\"__thisclass__\")[0]\n        self.assertEqual(thisclass.name, \"A\")\n        self_ = second.getattr(\"__self__\")[0]\n        self.assertIsInstance(self_, nodes.ClassDef)\n        self.assertEqual(self_.name, \"A\")\n\n        third = next(ast_nodes[2].infer())\n        thisclass = third.getattr(\"__thisclass__\")[0]\n        self.assertEqual(thisclass.name, \"X\")\n        selfclass = third.getattr(\"__self_class__\")[0]\n        self.assertEqual(selfclass.name, \"A\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_data_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "x", "object", "pass", "class", "a", "x", "def", "__init__", "self", "super", "a", "self", "super", "a", "a", "super", "x", "a", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "thisclass", "first", "getattr", "__thisclass__", "0", "self", "assertisinstance", "thisclass", "nodes", "classdef", "self", "assertequal", "thisclass", "name", "a", "selfclass", "first", "getattr", "__self_class__", "0", "self", "assertisinstance", "selfclass", "nodes", "classdef", "self", "assertequal", "selfclass", "name", "a", "self_", "first", "getattr", "__self__", "0", "self", "assertisinstance", "self_", "bases", "instance", "self", "assertequal", "self_", "name", "a", "cls", "first", "getattr", "__class__", "0", "self", "assertequal", "cls", "first", "_proxied", "second", "next", "ast_nodes", "1", "infer", "thisclass", "second", "getattr", "__thisclass__", "0", "self", "assertequal", "thisclass", "name", "a", "self_", "second", "getattr", "__self__", "0", "self", "assertisinstance", "self_", "nodes", "classdef", "self", "assertequal", "self_", "name", "a", "third", "next", "ast_nodes", "2", "infer", "thisclass", "third", "getattr", "__thisclass__", "0", "self", "assertequal", "thisclass", "name", "x", "selfclass", "third", "getattr", "__self_class__", "0", "self", "assertequal", "selfclass", "name", "a"], "doc_len": 149}
{"doc_id": "tests/unittest_objects.py::SuperTests.assertEqualMro", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "assertEqualMro", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def assertEqualMro(self, klass: Super, expected_mro: List[str]) -> None:\n        self.assertEqual([member.name for member in klass.super_mro()], expected_mro)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "assertequalmro", "self", "klass", "super", "expected_mro", "list", "str", "none", "self", "assertequal", "member", "name", "for", "member", "in", "klass", "super_mro", "expected_mro"], "doc_len": 23}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_mro", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_mro", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_mro(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(A): pass\n        class C(A): pass\n        class E(C, B):\n            def __init__(self):\n                super(E, self) #@\n                super(C, self) #@\n                super(B, self) #@\n\n                super(B, 1) #@\n                super(1, B) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertEqualMro(first, [\"C\", \"B\", \"A\", \"object\"])\n        second = next(ast_nodes[1].infer())\n        self.assertEqualMro(second, [\"B\", \"A\", \"object\"])\n        third = next(ast_nodes[2].infer())\n        self.assertEqualMro(third, [\"A\", \"object\"])\n\n        fourth = next(ast_nodes[3].infer())\n        with self.assertRaises(SuperError):\n            fourth.super_mro()\n        fifth = next(ast_nodes[4].infer())\n        with self.assertRaises(SuperError):\n            fifth.super_mro()\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_mro", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "object", "pass", "class", "b", "a", "pass", "class", "c", "a", "pass", "class", "e", "c", "b", "def", "__init__", "self", "super", "e", "self", "super", "c", "self", "super", "b", "self", "super", "b", "1", "super", "1", "b", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertequalmro", "first", "c", "b", "a", "object", "second", "next", "ast_nodes", "1", "infer", "self", "assertequalmro", "second", "b", "a", "object", "third", "next", "ast_nodes", "2", "infer", "self", "assertequalmro", "third", "a", "object", "fourth", "next", "ast_nodes", "3", "infer", "with", "self", "assertraises", "supererror", "fourth", "super_mro", "fifth", "next", "ast_nodes", "4", "infer", "with", "self", "assertraises", "supererror", "fifth", "super_mro"], "doc_len": 104}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_yes_objects", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_yes_objects", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_yes_objects(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        from collections import Missing\n        class A(object):\n            def __init__(self):\n                super(Missing, self) #@\n                super(A, Missing) #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        first = next(ast_nodes[0].infer())\n        self.assertIsInstance(first, bases.Instance)\n        second = next(ast_nodes[1].infer())\n        self.assertIsInstance(second, bases.Instance)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_yes_objects", "self", "none", "ast_nodes", "builder", "extract_node", "from", "collections", "import", "missing", "class", "a", "object", "def", "__init__", "self", "super", "missing", "self", "super", "a", "missing", "assert", "isinstance", "ast_nodes", "list", "first", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "first", "bases", "instance", "second", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "second", "bases", "instance"], "doc_len": 51}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_invalid_types", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_invalid_types", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_invalid_types(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        import collections\n        class A(object):\n            def __init__(self):\n                super(A, collections) #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        with self.assertRaises(SuperError):\n            inferred.super_mro()\n        with self.assertRaises(SuperError):\n            inferred.super_mro()\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_invalid_types", "self", "none", "node", "builder", "extract_node", "import", "collections", "class", "a", "object", "def", "__init__", "self", "super", "a", "collections", "inferred", "next", "node", "infer", "with", "self", "assertraises", "supererror", "inferred", "super_mro", "with", "self", "assertraises", "supererror", "inferred", "super_mro"], "doc_len": 38}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_properties", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_properties", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_properties(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class Foo(object):\n            @property\n            def dict(self):\n                return 42\n\n        class Bar(Foo):\n            @property\n            def dict(self):\n                return super(Bar, self).dict\n\n        Bar().dict\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_properties", "self", "none", "node", "builder", "extract_node", "class", "foo", "object", "property", "def", "dict", "self", "return", "42", "class", "bar", "foo", "property", "def", "dict", "self", "return", "super", "bar", "self", "dict", "bar", "dict", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 48}
{"doc_id": "tests/unittest_objects.py::SuperTests.test_super_qname", "file_path": "tests/unittest_objects.py", "class_name": "SuperTests", "func_name": "test_super_qname", "text": "文件路径: tests/unittest_objects.py, 类名: SuperTests\n    def test_super_qname(self) -> None:\n        \"\"\"Make sure a Super object generates a qname\n        equivalent to super.__qname__\n        \"\"\"\n        # See issue 533\n        code = \"\"\"\n        class C:\n           def foo(self): return super()\n        C().foo() #@\n        \"\"\"\n        super_obj = next(builder.extract_node(code).infer())\n        self.assertEqual(super_obj.qname(), \"super\")\n", "tokens": ["tests", "unittest_objects", "py", "supertests", "def", "test_super_qname", "self", "none", "make", "sure", "a", "super", "object", "generates", "a", "qname", "equivalent", "to", "super", "__qname__", "see", "issue", "533", "code", "class", "c", "def", "foo", "self", "return", "super", "c", "foo", "super_obj", "next", "builder", "extract_node", "code", "infer", "self", "assertequal", "super_obj", "qname", "super"], "doc_len": 44}
{"doc_id": "tests/unittest_object_model.py::InstanceModelTest.test_instance_special_model", "file_path": "tests/unittest_object_model.py", "class_name": "InstanceModelTest", "func_name": "test_instance_special_model", "text": "文件路径: tests/unittest_object_model.py, 类名: InstanceModelTest\n    def test_instance_special_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A:\n            \"test\"\n            def __init__(self):\n                self.a = 42\n        a = A()\n        a.__class__ #@\n        a.__module__ #@\n        a.__doc__ #@\n        a.__dict__ #@\n        \"\"\",\n            module_name=\"fake_module\",\n        )\n        assert isinstance(ast_nodes, list)\n        cls = next(ast_nodes[0].infer())\n        self.assertIsInstance(cls, astroid.ClassDef)\n        self.assertEqual(cls.name, \"A\")\n\n        module = next(ast_nodes[1].infer())\n        self.assertIsInstance(module, astroid.Const)\n        self.assertEqual(module.value, \"fake_module\")\n\n        doc = next(ast_nodes[2].infer())\n        self.assertIsInstance(doc, astroid.Const)\n        self.assertEqual(doc.value, \"test\")\n\n        dunder_dict = next(ast_nodes[3].infer())\n        self.assertIsInstance(dunder_dict, astroid.Dict)\n        attr = next(dunder_dict.getitem(astroid.Const(\"a\")).infer())\n        self.assertIsInstance(attr, astroid.Const)\n        self.assertEqual(attr.value, 42)\n", "tokens": ["tests", "unittest_object_model", "py", "instancemodeltest", "def", "test_instance_special_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "test", "def", "__init__", "self", "self", "a", "42", "a", "a", "a", "__class__", "a", "__module__", "a", "__doc__", "a", "__dict__", "module_name", "fake_module", "assert", "isinstance", "ast_nodes", "list", "cls", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "cls", "astroid", "classdef", "self", "assertequal", "cls", "name", "a", "module", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "module", "astroid", "const", "self", "assertequal", "module", "value", "fake_module", "doc", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "doc", "astroid", "const", "self", "assertequal", "doc", "value", "test", "dunder_dict", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "dunder_dict", "astroid", "dict", "attr", "next", "dunder_dict", "getitem", "astroid", "const", "a", "infer", "self", "assertisinstance", "attr", "astroid", "const", "self", "assertequal", "attr", "value", "42"], "doc_len": 109}
{"doc_id": "tests/unittest_object_model.py::InstanceModelTest.test_instance_local_attributes_overrides_object_model", "file_path": "tests/unittest_object_model.py", "class_name": "InstanceModelTest", "func_name": "test_instance_local_attributes_overrides_object_model", "text": "文件路径: tests/unittest_object_model.py, 类名: InstanceModelTest\n    def test_instance_local_attributes_overrides_object_model(self):\n        # The instance lookup needs to be changed in order for this to work.\n        ast_node = builder.extract_node(\n            \"\"\"\n        class A:\n            @property\n            def __dict__(self):\n                  return []\n        A().__dict__\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, astroid.List)\n        self.assertEqual(inferred.elts, [])\n", "tokens": ["tests", "unittest_object_model", "py", "instancemodeltest", "def", "test_instance_local_attributes_overrides_object_model", "self", "the", "instance", "lookup", "needs", "to", "be", "changed", "in", "order", "for", "this", "to", "work", "ast_node", "builder", "extract_node", "class", "a", "property", "def", "__dict__", "self", "return", "a", "__dict__", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "astroid", "list", "self", "assertequal", "inferred", "elts"], "doc_len": 45}
{"doc_id": "tests/unittest_object_model.py::BoundMethodModelTest.test_bound_method_model", "file_path": "tests/unittest_object_model.py", "class_name": "BoundMethodModelTest", "func_name": "test_bound_method_model", "text": "文件路径: tests/unittest_object_model.py, 类名: BoundMethodModelTest\n    def test_bound_method_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A:\n            def test(self): pass\n        a = A()\n        a.test.__func__ #@\n        a.test.__self__ #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        func = next(ast_nodes[0].infer())\n        self.assertIsInstance(func, astroid.FunctionDef)\n        self.assertEqual(func.name, \"test\")\n\n        self_ = next(ast_nodes[1].infer())\n        self.assertIsInstance(self_, astroid.Instance)\n        self.assertEqual(self_.name, \"A\")\n", "tokens": ["tests", "unittest_object_model", "py", "boundmethodmodeltest", "def", "test_bound_method_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "def", "test", "self", "pass", "a", "a", "a", "test", "__func__", "a", "test", "__self__", "assert", "isinstance", "ast_nodes", "list", "func", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "func", "astroid", "functiondef", "self", "assertequal", "func", "name", "test", "self_", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "self_", "astroid", "instance", "self", "assertequal", "self_", "name", "a"], "doc_len": 59}
{"doc_id": "tests/unittest_object_model.py::UnboundMethodModelTest.test_unbound_method_model", "file_path": "tests/unittest_object_model.py", "class_name": "UnboundMethodModelTest", "func_name": "test_unbound_method_model", "text": "文件路径: tests/unittest_object_model.py, 类名: UnboundMethodModelTest\n    def test_unbound_method_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A:\n            def test(self): pass\n        t = A.test\n        t.__class__ #@\n        t.__func__ #@\n        t.__self__ #@\n        t.im_class #@\n        t.im_func #@\n        t.im_self #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        cls = next(ast_nodes[0].infer())\n        self.assertIsInstance(cls, astroid.ClassDef)\n        unbound_name = \"function\"\n\n        self.assertEqual(cls.name, unbound_name)\n\n        func = next(ast_nodes[1].infer())\n        self.assertIsInstance(func, astroid.FunctionDef)\n        self.assertEqual(func.name, \"test\")\n\n        self_ = next(ast_nodes[2].infer())\n        self.assertIsInstance(self_, astroid.Const)\n        self.assertIsNone(self_.value)\n\n        self.assertEqual(cls.name, next(ast_nodes[3].infer()).name)\n        self.assertEqual(func, next(ast_nodes[4].infer()))\n        self.assertIsNone(next(ast_nodes[5].infer()).value)\n", "tokens": ["tests", "unittest_object_model", "py", "unboundmethodmodeltest", "def", "test_unbound_method_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "def", "test", "self", "pass", "t", "a", "test", "t", "__class__", "t", "__func__", "t", "__self__", "t", "im_class", "t", "im_func", "t", "im_self", "assert", "isinstance", "ast_nodes", "list", "cls", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "cls", "astroid", "classdef", "unbound_name", "function", "self", "assertequal", "cls", "name", "unbound_name", "func", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "func", "astroid", "functiondef", "self", "assertequal", "func", "name", "test", "self_", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "self_", "astroid", "const", "self", "assertisnone", "self_", "value", "self", "assertequal", "cls", "name", "next", "ast_nodes", "3", "infer", "name", "self", "assertequal", "func", "next", "ast_nodes", "4", "infer", "self", "assertisnone", "next", "ast_nodes", "5", "infer", "value"], "doc_len": 105}
{"doc_id": "tests/unittest_object_model.py::ClassModelTest.test_priority_to_local_defined_values", "file_path": "tests/unittest_object_model.py", "class_name": "ClassModelTest", "func_name": "test_priority_to_local_defined_values", "text": "文件路径: tests/unittest_object_model.py, 类名: ClassModelTest\n    def test_priority_to_local_defined_values(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class A:\n            __doc__ = \"first\"\n        A.__doc__ #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, astroid.Const)\n        self.assertEqual(inferred.value, \"first\")\n", "tokens": ["tests", "unittest_object_model", "py", "classmodeltest", "def", "test_priority_to_local_defined_values", "self", "none", "ast_node", "builder", "extract_node", "class", "a", "__doc__", "first", "a", "__doc__", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "astroid", "const", "self", "assertequal", "inferred", "value", "first"], "doc_len": 31}
{"doc_id": "tests/unittest_object_model.py::ClassModelTest.test_class_model_correct_mro_subclasses_proxied", "file_path": "tests/unittest_object_model.py", "class_name": "ClassModelTest", "func_name": "test_class_model_correct_mro_subclasses_proxied", "text": "文件路径: tests/unittest_object_model.py, 类名: ClassModelTest\n    def test_class_model_correct_mro_subclasses_proxied(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        A.mro #@\n        A.__subclasses__ #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, astroid.BoundMethod)\n            self.assertIsInstance(inferred._proxied, astroid.FunctionDef)\n            self.assertIsInstance(inferred.bound, astroid.ClassDef)\n            self.assertEqual(inferred.bound.name, \"type\")\n", "tokens": ["tests", "unittest_object_model", "py", "classmodeltest", "def", "test_class_model_correct_mro_subclasses_proxied", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "object", "pass", "a", "mro", "a", "__subclasses__", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "boundmethod", "self", "assertisinstance", "inferred", "_proxied", "astroid", "functiondef", "self", "assertisinstance", "inferred", "bound", "astroid", "classdef", "self", "assertequal", "inferred", "bound", "name", "type"], "doc_len": 50}
{"doc_id": "tests/unittest_object_model.py::ClassModelTest.test_class_model", "file_path": "tests/unittest_object_model.py", "class_name": "ClassModelTest", "func_name": "test_class_model", "text": "文件路径: tests/unittest_object_model.py, 类名: ClassModelTest\n    def test_class_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A(object):\n            \"test\"\n\n        class B(A): pass\n        class C(A): pass\n\n        A.__module__ #@\n        A.__name__ #@\n        A.__qualname__ #@\n        A.__doc__ #@\n        A.__mro__ #@\n        A.mro() #@\n        A.__bases__ #@\n        A.__class__ #@\n        A.__dict__ #@\n        A.__subclasses__() #@\n        \"\"\",\n            module_name=\"fake_module\",\n        )\n        assert isinstance(ast_nodes, list)\n        module = next(ast_nodes[0].infer())\n        self.assertIsInstance(module, astroid.Const)\n        self.assertEqual(module.value, \"fake_module\")\n\n        name = next(ast_nodes[1].infer())\n        self.assertIsInstance(name, astroid.Const)\n        self.assertEqual(name.value, \"A\")\n\n        qualname = next(ast_nodes[2].infer())\n        self.assertIsInstance(qualname, astroid.Const)\n        self.assertEqual(qualname.value, \"fake_module.A\")\n\n        doc = next(ast_nodes[3].infer())\n        self.assertIsInstance(doc, astroid.Const)\n        self.assertEqual(doc.value, \"test\")\n\n        mro = next(ast_nodes[4].infer())\n        self.assertIsInstance(mro, astroid.Tuple)\n        self.assertEqual([cls.name for cls in mro.elts], [\"A\", \"object\"])\n\n        called_mro = next(ast_nodes[5].infer())\n        self.assertEqual(called_mro.elts, mro.elts)\n\n        bases = next(ast_nodes[6].infer())\n        self.assertIsInstance(bases, astroid.Tuple)\n        self.assertEqual([cls.name for cls in bases.elts], [\"object\"])\n\n        cls = next(ast_nodes[7].infer())\n        self.assertIsInstance(cls, astroid.ClassDef)\n        self.assertEqual(cls.name, \"type\")\n\n        cls_dict = next(ast_nodes[8].infer())\n        self.assertIsInstance(cls_dict, astroid.Dict)\n\n        subclasses = next(ast_nodes[9].infer())\n        self.assertIsInstance(subclasses, astroid.List)\n        self.assertEqual([cls.name for cls in subclasses.elts], [\"B\", \"C\"])\n", "tokens": ["tests", "unittest_object_model", "py", "classmodeltest", "def", "test_class_model", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "object", "test", "class", "b", "a", "pass", "class", "c", "a", "pass", "a", "__module__", "a", "__name__", "a", "__qualname__", "a", "__doc__", "a", "__mro__", "a", "mro", "a", "__bases__", "a", "__class__", "a", "__dict__", "a", "__subclasses__", "module_name", "fake_module", "assert", "isinstance", "ast_nodes", "list", "module", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "module", "astroid", "const", "self", "assertequal", "module", "value", "fake_module", "name", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "name", "astroid", "const", "self", "assertequal", "name", "value", "a", "qualname", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "qualname", "astroid", "const", "self", "assertequal", "qualname", "value", "fake_module", "a", "doc", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "doc", "astroid", "const", "self", "assertequal", "doc", "value", "test", "mro", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "mro", "astroid", "tuple", "self", "assertequal", "cls", "name", "for", "cls", "in", "mro", "elts", "a", "object", "called_mro", "next", "ast_nodes", "5", "infer", "self", "assertequal", "called_mro", "elts", "mro", "elts", "bases", "next", "ast_nodes", "6", "infer", "self", "assertisinstance", "bases", "astroid", "tuple", "self", "assertequal", "cls", "name", "for", "cls", "in", "bases", "elts", "object", "cls", "next", "ast_nodes", "7", "infer", "self", "assertisinstance", "cls", "astroid", "classdef", "self", "assertequal", "cls", "name", "type", "cls_dict", "next", "ast_nodes", "8", "infer", "self", "assertisinstance", "cls_dict", "astroid", "dict", "subclasses", "next", "ast_nodes", "9", "infer", "self", "assertisinstance", "subclasses", "astroid", "list", "self", "assertequal", "cls", "name", "for", "cls", "in", "subclasses", "elts", "b", "c"], "doc_len": 208}
{"doc_id": "tests/unittest_object_model.py::ModuleModelTest.test_priority_to_local_defined_values", "file_path": "tests/unittest_object_model.py", "class_name": "ModuleModelTest", "func_name": "test_priority_to_local_defined_values", "text": "文件路径: tests/unittest_object_model.py, 类名: ModuleModelTest\n    def test_priority_to_local_defined_values(self) -> None:\n        ast_node = astroid.parse(\n            \"\"\"\n        __file__ = \"mine\"\n        \"\"\"\n        )\n        file_value = next(ast_node.igetattr(\"__file__\"))\n        self.assertIsInstance(file_value, astroid.Const)\n        self.assertEqual(file_value.value, \"mine\")\n", "tokens": ["tests", "unittest_object_model", "py", "modulemodeltest", "def", "test_priority_to_local_defined_values", "self", "none", "ast_node", "astroid", "parse", "__file__", "mine", "file_value", "next", "ast_node", "igetattr", "__file__", "self", "assertisinstance", "file_value", "astroid", "const", "self", "assertequal", "file_value", "value", "mine"], "doc_len": 28}
{"doc_id": "tests/unittest_object_model.py::ModuleModelTest.test__path__not_a_package", "file_path": "tests/unittest_object_model.py", "class_name": "ModuleModelTest", "func_name": "test__path__not_a_package", "text": "文件路径: tests/unittest_object_model.py, 类名: ModuleModelTest\n    def test__path__not_a_package(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        import sys\n        sys.__path__ #@\n        \"\"\"\n        )\n        with self.assertRaises(InferenceError):\n            next(ast_node.infer())\n", "tokens": ["tests", "unittest_object_model", "py", "modulemodeltest", "def", "test__path__not_a_package", "self", "none", "ast_node", "builder", "extract_node", "import", "sys", "sys", "__path__", "with", "self", "assertraises", "inferenceerror", "next", "ast_node", "infer"], "doc_len": 22}
{"doc_id": "tests/unittest_object_model.py::ModuleModelTest.test_module_model", "file_path": "tests/unittest_object_model.py", "class_name": "ModuleModelTest", "func_name": "test_module_model", "text": "文件路径: tests/unittest_object_model.py, 类名: ModuleModelTest\n    def test_module_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        import xml\n        xml.__path__ #@\n        xml.__name__ #@\n        xml.__doc__ #@\n        xml.__file__ #@\n        xml.__spec__ #@\n        xml.__loader__ #@\n        xml.__cached__ #@\n        xml.__package__ #@\n        xml.__dict__ #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        path = next(ast_nodes[0].infer())\n        self.assertIsInstance(path, astroid.List)\n        self.assertIsInstance(path.elts[0], astroid.Const)\n        self.assertEqual(path.elts[0].value, xml.__path__[0])\n\n        name = next(ast_nodes[1].infer())\n        self.assertIsInstance(name, astroid.Const)\n        self.assertEqual(name.value, \"xml\")\n\n        doc = next(ast_nodes[2].infer())\n        self.assertIsInstance(doc, astroid.Const)\n        self.assertEqual(doc.value, xml.__doc__)\n\n        file_ = next(ast_nodes[3].infer())\n        self.assertIsInstance(file_, astroid.Const)\n        self.assertEqual(file_.value, xml.__file__.replace(\".pyc\", \".py\"))\n\n        for ast_node in ast_nodes[4:7]:\n            inferred = next(ast_node.infer())\n            self.assertIs(inferred, astroid.Uninferable)\n\n        package = next(ast_nodes[7].infer())\n        self.assertIsInstance(package, astroid.Const)\n        self.assertEqual(package.value, \"xml\")\n\n        dict_ = next(ast_nodes[8].infer())\n        self.assertIsInstance(dict_, astroid.Dict)\n", "tokens": ["tests", "unittest_object_model", "py", "modulemodeltest", "def", "test_module_model", "self", "none", "ast_nodes", "builder", "extract_node", "import", "xml", "xml", "__path__", "xml", "__name__", "xml", "__doc__", "xml", "__file__", "xml", "__spec__", "xml", "__loader__", "xml", "__cached__", "xml", "__package__", "xml", "__dict__", "assert", "isinstance", "ast_nodes", "list", "path", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "path", "astroid", "list", "self", "assertisinstance", "path", "elts", "0", "astroid", "const", "self", "assertequal", "path", "elts", "0", "value", "xml", "__path__", "0", "name", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "name", "astroid", "const", "self", "assertequal", "name", "value", "xml", "doc", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "doc", "astroid", "const", "self", "assertequal", "doc", "value", "xml", "__doc__", "file_", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "file_", "astroid", "const", "self", "assertequal", "file_", "value", "xml", "__file__", "replace", "pyc", "py", "for", "ast_node", "in", "ast_nodes", "4", "7", "inferred", "next", "ast_node", "infer", "self", "assertis", "inferred", "astroid", "uninferable", "package", "next", "ast_nodes", "7", "infer", "self", "assertisinstance", "package", "astroid", "const", "self", "assertequal", "package", "value", "xml", "dict_", "next", "ast_nodes", "8", "infer", "self", "assertisinstance", "dict_", "astroid", "dict"], "doc_len": 151}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_partial_descriptor_support", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_partial_descriptor_support", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_partial_descriptor_support(self) -> None:\n        bound, result = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        def test(self): return 42\n        f = test.__get__(A(), A)\n        f #@\n        f() #@\n        \"\"\"\n        )\n        bound = next(bound.infer())\n        self.assertIsInstance(bound, astroid.BoundMethod)\n        self.assertEqual(bound._proxied._proxied.name, \"test\")\n        result = next(result.infer())\n        self.assertIsInstance(result, astroid.Const)\n        self.assertEqual(result.value, 42)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_partial_descriptor_support", "self", "none", "bound", "result", "builder", "extract_node", "class", "a", "object", "pass", "def", "test", "self", "return", "42", "f", "test", "__get__", "a", "a", "f", "f", "bound", "next", "bound", "infer", "self", "assertisinstance", "bound", "astroid", "boundmethod", "self", "assertequal", "bound", "_proxied", "_proxied", "name", "test", "result", "next", "result", "infer", "self", "assertisinstance", "result", "astroid", "const", "self", "assertequal", "result", "value", "42"], "doc_len": 58}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test___get__has_extra_params_defined", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test___get__has_extra_params_defined", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test___get__has_extra_params_defined(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        def test(self): return 42\n        test.__get__\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, astroid.BoundMethod)\n        args = inferred.args.args\n        self.assertEqual(len(args), 2)\n        self.assertEqual([arg.name for arg in args], [\"self\", \"type\"])\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test___get__has_extra_params_defined", "self", "none", "node", "builder", "extract_node", "def", "test", "self", "return", "42", "test", "__get__", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "boundmethod", "args", "inferred", "args", "args", "self", "assertequal", "len", "args", "2", "self", "assertequal", "arg", "name", "for", "arg", "in", "args", "self", "type"], "doc_len": 46}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test__get__and_positional_only_args", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test__get__and_positional_only_args", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test__get__and_positional_only_args(self):\n        node = builder.extract_node(\n            \"\"\"\n        def test(self, a, b, /, c): return a + b + c\n        test.__get__(test)(1, 2, 3)\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test__get__and_positional_only_args", "self", "node", "builder", "extract_node", "def", "test", "self", "a", "b", "c", "return", "a", "b", "c", "test", "__get__", "test", "1", "2", "3", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 35}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_descriptor_not_inferrring_self", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_descriptor_not_inferrring_self", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_descriptor_not_inferrring_self(self):\n        # We can't infer __get__(X, Y)() when the bounded function\n        # uses self, because of the tree's parent not being propagating good enough.\n        result = builder.extract_node(\n            \"\"\"\n        class A(object):\n            x = 42\n        def test(self): return self.x\n        f = test.__get__(A(), A)\n        f() #@\n        \"\"\"\n        )\n        result = next(result.infer())\n        self.assertIsInstance(result, astroid.Const)\n        self.assertEqual(result.value, 42)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_descriptor_not_inferrring_self", "self", "we", "can", "t", "infer", "__get__", "x", "y", "when", "the", "bounded", "function", "uses", "self", "because", "of", "the", "tree", "s", "parent", "not", "being", "propagating", "good", "enough", "result", "builder", "extract_node", "class", "a", "object", "x", "42", "def", "test", "self", "return", "self", "x", "f", "test", "__get__", "a", "a", "f", "result", "next", "result", "infer", "self", "assertisinstance", "result", "astroid", "const", "self", "assertequal", "result", "value", "42"], "doc_len": 65}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_descriptors_binding_invalid", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_descriptors_binding_invalid", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_descriptors_binding_invalid(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class A: pass\n        def test(self): return 42\n        test.__get__()() #@\n        test.__get__(2, 3, 4) #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            with self.assertRaises(InferenceError):\n                next(node.infer())\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_descriptors_binding_invalid", "self", "none", "ast_nodes", "builder", "extract_node", "class", "a", "pass", "def", "test", "self", "return", "42", "test", "__get__", "test", "__get__", "2", "3", "4", "for", "node", "in", "ast_nodes", "with", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 37}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_descriptor_error_regression", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_descriptor_error_regression", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_descriptor_error_regression(self) -> None:\n        \"\"\"Make sure the following code does\n        node cause an exception\"\"\"\n        node = builder.extract_node(\n            \"\"\"\n        class MyClass:\n            text = \"MyText\"\n\n            def mymethod1(self):\n                return self.text\n\n            def mymethod2(self):\n                return self.mymethod1.__get__(self, MyClass)\n\n\n        cl = MyClass().mymethod2()()\n        cl #@\n        \"\"\"\n        )\n        assert isinstance(node, nodes.NodeNG)\n        [const] = node.inferred()\n        assert const.value == \"MyText\"\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_descriptor_error_regression", "self", "none", "make", "sure", "the", "following", "code", "does", "node", "cause", "an", "exception", "node", "builder", "extract_node", "class", "myclass", "text", "mytext", "def", "mymethod1", "self", "return", "self", "text", "def", "mymethod2", "self", "return", "self", "mymethod1", "__get__", "self", "myclass", "cl", "myclass", "mymethod2", "cl", "assert", "isinstance", "node", "nodes", "nodeng", "const", "node", "inferred", "assert", "const", "value", "mytext"], "doc_len": 56}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_function_model", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_function_model", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_function_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            '''\n        def func(a=1, b=2):\n            \"\"\"test\"\"\"\n        func.__name__ #@\n        func.__doc__ #@\n        func.__qualname__ #@\n        func.__module__  #@\n        func.__defaults__ #@\n        func.__dict__ #@\n        func.__globals__ #@\n        func.__code__ #@\n        func.__closure__ #@\n        ''',\n            module_name=\"fake_module\",\n        )\n        assert isinstance(ast_nodes, list)\n        name = next(ast_nodes[0].infer())\n        self.assertIsInstance(name, astroid.Const)\n        self.assertEqual(name.value, \"func\")\n\n        doc = next(ast_nodes[1].infer())\n        self.assertIsInstance(doc, astroid.Const)\n        self.assertEqual(doc.value, \"test\")\n\n        qualname = next(ast_nodes[2].infer())\n        self.assertIsInstance(qualname, astroid.Const)\n        self.assertEqual(qualname.value, \"fake_module.func\")\n\n        module = next(ast_nodes[3].infer())\n        self.assertIsInstance(module, astroid.Const)\n        self.assertEqual(module.value, \"fake_module\")\n\n        defaults = next(ast_nodes[4].infer())\n        self.assertIsInstance(defaults, astroid.Tuple)\n        self.assertEqual([default.value for default in defaults.elts], [1, 2])\n\n        dict_ = next(ast_nodes[5].infer())\n        self.assertIsInstance(dict_, astroid.Dict)\n\n        globals_ = next(ast_nodes[6].infer())\n        self.assertIsInstance(globals_, astroid.Dict)\n\n        for ast_node in ast_nodes[7:9]:\n            self.assertIs(next(ast_node.infer()), astroid.Uninferable)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_function_model", "self", "none", "ast_nodes", "builder", "extract_node", "def", "func", "a", "1", "b", "2", "test", "func", "__name__", "func", "__doc__", "func", "__qualname__", "func", "__module__", "func", "__defaults__", "func", "__dict__", "func", "__globals__", "func", "__code__", "func", "__closure__", "module_name", "fake_module", "assert", "isinstance", "ast_nodes", "list", "name", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "name", "astroid", "const", "self", "assertequal", "name", "value", "func", "doc", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "doc", "astroid", "const", "self", "assertequal", "doc", "value", "test", "qualname", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "qualname", "astroid", "const", "self", "assertequal", "qualname", "value", "fake_module", "func", "module", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "module", "astroid", "const", "self", "assertequal", "module", "value", "fake_module", "defaults", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "defaults", "astroid", "tuple", "self", "assertequal", "default", "value", "for", "default", "in", "defaults", "elts", "1", "2", "dict_", "next", "ast_nodes", "5", "infer", "self", "assertisinstance", "dict_", "astroid", "dict", "globals_", "next", "ast_nodes", "6", "infer", "self", "assertisinstance", "globals_", "astroid", "dict", "for", "ast_node", "in", "ast_nodes", "7", "9", "self", "assertis", "next", "ast_node", "infer", "astroid", "uninferable"], "doc_len": 157}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_empty_return_annotation", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_empty_return_annotation", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_empty_return_annotation(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        def test(): pass\n        test.__annotations__\n        \"\"\"\n        )\n        annotations = next(ast_node.infer())\n        self.assertIsInstance(annotations, astroid.Dict)\n        self.assertEqual(len(annotations.items), 0)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_empty_return_annotation", "self", "none", "ast_node", "builder", "extract_node", "def", "test", "pass", "test", "__annotations__", "annotations", "next", "ast_node", "infer", "self", "assertisinstance", "annotations", "astroid", "dict", "self", "assertequal", "len", "annotations", "items", "0"], "doc_len": 31}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_builtin_dunder_init_does_not_crash_when_accessing_annotations(\n        self,\n    ) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class Class:\n            @classmethod\n            def class_method(cls):\n                cls.__init__.__annotations__ #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, astroid.Dict)\n        self.assertEqual(len(inferred.items), 0)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_builtin_dunder_init_does_not_crash_when_accessing_annotations", "self", "none", "ast_node", "builder", "extract_node", "class", "class", "classmethod", "def", "class_method", "cls", "cls", "__init__", "__annotations__", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "astroid", "dict", "self", "assertequal", "len", "inferred", "items", "0"], "doc_len": 35}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_annotations_kwdefaults", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_annotations_kwdefaults", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_annotations_kwdefaults(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        def test(a: 1, *args: 2, f:4='lala', **kwarg:3)->2: pass\n        test.__annotations__ #@\n        test.__kwdefaults__ #@\n        \"\"\"\n        )\n        annotations = next(ast_node[0].infer())\n        self.assertIsInstance(annotations, astroid.Dict)\n        self.assertIsInstance(\n            annotations.getitem(astroid.Const(\"return\")), astroid.Const\n        )\n        self.assertEqual(annotations.getitem(astroid.Const(\"return\")).value, 2)\n        self.assertIsInstance(annotations.getitem(astroid.Const(\"a\")), astroid.Const)\n        self.assertEqual(annotations.getitem(astroid.Const(\"a\")).value, 1)\n        self.assertEqual(annotations.getitem(astroid.Const(\"args\")).value, 2)\n        self.assertEqual(annotations.getitem(astroid.Const(\"kwarg\")).value, 3)\n\n        self.assertEqual(annotations.getitem(astroid.Const(\"f\")).value, 4)\n\n        kwdefaults = next(ast_node[1].infer())\n        self.assertIsInstance(kwdefaults, astroid.Dict)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_annotations_kwdefaults", "self", "none", "ast_node", "builder", "extract_node", "def", "test", "a", "1", "args", "2", "f", "4", "lala", "kwarg", "3", "2", "pass", "test", "__annotations__", "test", "__kwdefaults__", "annotations", "next", "ast_node", "0", "infer", "self", "assertisinstance", "annotations", "astroid", "dict", "self", "assertisinstance", "annotations", "getitem", "astroid", "const", "return", "astroid", "const", "self", "assertequal", "annotations", "getitem", "astroid", "const", "return", "value", "2", "self", "assertisinstance", "annotations", "getitem", "astroid", "const", "a", "astroid", "const", "self", "assertequal", "annotations", "getitem", "astroid", "const", "a", "value", "1", "self", "assertequal", "annotations", "getitem", "astroid", "const", "args", "value", "2", "self", "assertequal", "annotations", "getitem", "astroid", "const", "kwarg", "value", "3", "self", "assertequal", "annotations", "getitem", "astroid", "const", "f", "value", "4", "kwdefaults", "next", "ast_node", "1", "infer", "self", "assertisinstance", "kwdefaults", "astroid", "dict"], "doc_len": 111}
{"doc_id": "tests/unittest_object_model.py::FunctionModelTest.test_annotation_positional_only", "file_path": "tests/unittest_object_model.py", "class_name": "FunctionModelTest", "func_name": "test_annotation_positional_only", "text": "文件路径: tests/unittest_object_model.py, 类名: FunctionModelTest\n    def test_annotation_positional_only(self):\n        ast_node = builder.extract_node(\n            \"\"\"\n        def test(a: 1, b: 2, /, c: 3): pass\n        test.__annotations__ #@\n        \"\"\"\n        )\n        annotations = next(ast_node.infer())\n        self.assertIsInstance(annotations, astroid.Dict)\n\n        self.assertIsInstance(annotations.getitem(astroid.Const(\"a\")), astroid.Const)\n        self.assertEqual(annotations.getitem(astroid.Const(\"a\")).value, 1)\n        self.assertEqual(annotations.getitem(astroid.Const(\"b\")).value, 2)\n        self.assertEqual(annotations.getitem(astroid.Const(\"c\")).value, 3)\n", "tokens": ["tests", "unittest_object_model", "py", "functionmodeltest", "def", "test_annotation_positional_only", "self", "ast_node", "builder", "extract_node", "def", "test", "a", "1", "b", "2", "c", "3", "pass", "test", "__annotations__", "annotations", "next", "ast_node", "infer", "self", "assertisinstance", "annotations", "astroid", "dict", "self", "assertisinstance", "annotations", "getitem", "astroid", "const", "a", "astroid", "const", "self", "assertequal", "annotations", "getitem", "astroid", "const", "a", "value", "1", "self", "assertequal", "annotations", "getitem", "astroid", "const", "b", "value", "2", "self", "assertequal", "annotations", "getitem", "astroid", "const", "c", "value", "3"], "doc_len": 66}
{"doc_id": "tests/unittest_object_model.py::GeneratorModelTest.test_model", "file_path": "tests/unittest_object_model.py", "class_name": "GeneratorModelTest", "func_name": "test_model", "text": "文件路径: tests/unittest_object_model.py, 类名: GeneratorModelTest\n    def test_model(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        def test():\n           \"a\"\n           yield\n\n        gen = test()\n        gen.__name__ #@\n        gen.__doc__ #@\n        gen.gi_code #@\n        gen.gi_frame #@\n        gen.send #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        name = next(ast_nodes[0].infer())\n        self.assertEqual(name.value, \"test\")\n\n        doc = next(ast_nodes[1].infer())\n        self.assertEqual(doc.value, \"a\")\n\n        gi_code = next(ast_nodes[2].infer())\n        self.assertIsInstance(gi_code, astroid.ClassDef)\n        self.assertEqual(gi_code.name, \"gi_code\")\n\n        gi_frame = next(ast_nodes[3].infer())\n        self.assertIsInstance(gi_frame, astroid.ClassDef)\n        self.assertEqual(gi_frame.name, \"gi_frame\")\n\n        send = next(ast_nodes[4].infer())\n        self.assertIsInstance(send, astroid.BoundMethod)\n", "tokens": ["tests", "unittest_object_model", "py", "generatormodeltest", "def", "test_model", "self", "none", "ast_nodes", "builder", "extract_node", "def", "test", "a", "yield", "gen", "test", "gen", "__name__", "gen", "__doc__", "gen", "gi_code", "gen", "gi_frame", "gen", "send", "assert", "isinstance", "ast_nodes", "list", "name", "next", "ast_nodes", "0", "infer", "self", "assertequal", "name", "value", "test", "doc", "next", "ast_nodes", "1", "infer", "self", "assertequal", "doc", "value", "a", "gi_code", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "gi_code", "astroid", "classdef", "self", "assertequal", "gi_code", "name", "gi_code", "gi_frame", "next", "ast_nodes", "3", "infer", "self", "assertisinstance", "gi_frame", "astroid", "classdef", "self", "assertequal", "gi_frame", "name", "gi_frame", "send", "next", "ast_nodes", "4", "infer", "self", "assertisinstance", "send", "astroid", "boundmethod"], "doc_len": 91}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_valueerror_py3", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_valueerror_py3", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_valueerror_py3(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        try:\n            x[42]\n        except ValueError as err:\n           err.args #@\n           err.__traceback__ #@\n\n           err.message #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        args = next(ast_nodes[0].infer())\n        self.assertIsInstance(args, astroid.Tuple)\n        tb = next(ast_nodes[1].infer())\n        self.assertIsInstance(tb, astroid.Instance)\n        self.assertEqual(tb.name, \"traceback\")\n\n        with self.assertRaises(InferenceError):\n            next(ast_nodes[2].infer())\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_valueerror_py3", "self", "none", "ast_nodes", "builder", "extract_node", "try", "x", "42", "except", "valueerror", "as", "err", "err", "args", "err", "__traceback__", "err", "message", "assert", "isinstance", "ast_nodes", "list", "args", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "args", "astroid", "tuple", "tb", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "tb", "astroid", "instance", "self", "assertequal", "tb", "name", "traceback", "with", "self", "assertraises", "inferenceerror", "next", "ast_nodes", "2", "infer"], "doc_len": 61}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_syntax_error", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_syntax_error", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_syntax_error(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        try:\n            x[42]\n        except SyntaxError as err:\n           err.text #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        assert isinstance(inferred, astroid.Const)\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_syntax_error", "self", "none", "ast_node", "builder", "extract_node", "try", "x", "42", "except", "syntaxerror", "as", "err", "err", "text", "inferred", "next", "ast_node", "infer", "assert", "isinstance", "inferred", "astroid", "const"], "doc_len": 29}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_oserror", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_oserror", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_oserror(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        try:\n            raise OSError(\"a\")\n        except OSError as err:\n           err.filename #@\n           err.filename2 #@\n           err.errno #@\n        \"\"\"\n        )\n        expected_values = [\"\", \"\", 0]\n        for node, value in zip(ast_nodes, expected_values):\n            inferred = next(node.infer())\n            assert isinstance(inferred, astroid.Const)\n            assert inferred.value == value\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_oserror", "self", "none", "ast_nodes", "builder", "extract_node", "try", "raise", "oserror", "a", "except", "oserror", "as", "err", "err", "filename", "err", "filename2", "err", "errno", "expected_values", "0", "for", "node", "value", "in", "zip", "ast_nodes", "expected_values", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const", "assert", "inferred", "value", "value"], "doc_len": 47}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_unicodedecodeerror", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_unicodedecodeerror", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_unicodedecodeerror(self) -> None:\n        code = \"\"\"\n        try:\n            raise UnicodeDecodeError(\"utf-8\", \"blob\", 0, 1, \"reason\")\n        except UnicodeDecodeError as error:\n            error.object[:1] #@\n        \"\"\"\n        node = builder.extract_node(code)\n        inferred = next(node.infer())\n        assert isinstance(inferred, astroid.Const)\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_unicodedecodeerror", "self", "none", "code", "try", "raise", "unicodedecodeerror", "utf", "8", "blob", "0", "1", "reason", "except", "unicodedecodeerror", "as", "error", "error", "object", "1", "node", "builder", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const"], "doc_len": 38}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_import_error", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_import_error", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_import_error(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        try:\n            raise ImportError(\"a\")\n        except ImportError as err:\n           err.name #@\n           err.path #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            assert isinstance(inferred, astroid.Const)\n            assert inferred.value == \"\"\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_import_error", "self", "none", "ast_nodes", "builder", "extract_node", "try", "raise", "importerror", "a", "except", "importerror", "as", "err", "err", "name", "err", "path", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "astroid", "const", "assert", "inferred", "value"], "doc_len": 39}
{"doc_id": "tests/unittest_object_model.py::ExceptionModelTest.test_exception_instance_correctly_instantiated", "file_path": "tests/unittest_object_model.py", "class_name": "ExceptionModelTest", "func_name": "test_exception_instance_correctly_instantiated", "text": "文件路径: tests/unittest_object_model.py, 类名: ExceptionModelTest\n    def test_exception_instance_correctly_instantiated(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        try:\n            raise ImportError(\"a\")\n        except ImportError as err:\n           err #@\n        \"\"\"\n        )\n        inferred = next(ast_node.infer())\n        assert isinstance(inferred, astroid.Instance)\n        cls = next(inferred.igetattr(\"__class__\"))\n        assert isinstance(cls, astroid.ClassDef)\n", "tokens": ["tests", "unittest_object_model", "py", "exceptionmodeltest", "def", "test_exception_instance_correctly_instantiated", "self", "none", "ast_node", "builder", "extract_node", "try", "raise", "importerror", "a", "except", "importerror", "as", "err", "err", "inferred", "next", "ast_node", "infer", "assert", "isinstance", "inferred", "astroid", "instance", "cls", "next", "inferred", "igetattr", "__class__", "assert", "isinstance", "cls", "astroid", "classdef"], "doc_len": 39}
{"doc_id": "tests/unittest_object_model.py::DictObjectModelTest.test__class__", "file_path": "tests/unittest_object_model.py", "class_name": "DictObjectModelTest", "func_name": "test__class__", "text": "文件路径: tests/unittest_object_model.py, 类名: DictObjectModelTest\n    def test__class__(self) -> None:\n        ast_node = builder.extract_node(\"{}.__class__\")\n        inferred = next(ast_node.infer())\n        self.assertIsInstance(inferred, astroid.ClassDef)\n        self.assertEqual(inferred.name, \"dict\")\n", "tokens": ["tests", "unittest_object_model", "py", "dictobjectmodeltest", "def", "test__class__", "self", "none", "ast_node", "builder", "extract_node", "__class__", "inferred", "next", "ast_node", "infer", "self", "assertisinstance", "inferred", "astroid", "classdef", "self", "assertequal", "inferred", "name", "dict"], "doc_len": 26}
{"doc_id": "tests/unittest_object_model.py::DictObjectModelTest.test_attributes_inferred_as_methods", "file_path": "tests/unittest_object_model.py", "class_name": "DictObjectModelTest", "func_name": "test_attributes_inferred_as_methods", "text": "文件路径: tests/unittest_object_model.py, 类名: DictObjectModelTest\n    def test_attributes_inferred_as_methods(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        {}.values #@\n        {}.items #@\n        {}.keys #@\n        \"\"\"\n        )\n        for node in ast_nodes:\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, astroid.BoundMethod)\n", "tokens": ["tests", "unittest_object_model", "py", "dictobjectmodeltest", "def", "test_attributes_inferred_as_methods", "self", "none", "ast_nodes", "builder", "extract_node", "values", "items", "keys", "for", "node", "in", "ast_nodes", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "astroid", "boundmethod"], "doc_len": 27}
{"doc_id": "tests/unittest_object_model.py::DictObjectModelTest.test_wrapper_objects_for_dict_methods_python3", "file_path": "tests/unittest_object_model.py", "class_name": "DictObjectModelTest", "func_name": "test_wrapper_objects_for_dict_methods_python3", "text": "文件路径: tests/unittest_object_model.py, 类名: DictObjectModelTest\n    def test_wrapper_objects_for_dict_methods_python3(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        {1:1, 2:3}.values() #@\n        {1:1, 2:3}.keys() #@\n        {1:1, 2:3}.items() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        values = next(ast_nodes[0].infer())\n        self.assertIsInstance(values, objects.DictValues)\n        self.assertEqual([elt.value for elt in values.elts], [1, 3])\n        keys = next(ast_nodes[1].infer())\n        self.assertIsInstance(keys, objects.DictKeys)\n        self.assertEqual([elt.value for elt in keys.elts], [1, 2])\n        items = next(ast_nodes[2].infer())\n        self.assertIsInstance(items, objects.DictItems)\n", "tokens": ["tests", "unittest_object_model", "py", "dictobjectmodeltest", "def", "test_wrapper_objects_for_dict_methods_python3", "self", "none", "ast_nodes", "builder", "extract_node", "1", "1", "2", "3", "values", "1", "1", "2", "3", "keys", "1", "1", "2", "3", "items", "assert", "isinstance", "ast_nodes", "list", "values", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "values", "objects", "dictvalues", "self", "assertequal", "elt", "value", "for", "elt", "in", "values", "elts", "1", "3", "keys", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "keys", "objects", "dictkeys", "self", "assertequal", "elt", "value", "for", "elt", "in", "keys", "elts", "1", "2", "items", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "items", "objects", "dictitems"], "doc_len": 82}
{"doc_id": "tests/unittest_object_model.py::LruCacheModelTest.test_lru_cache", "file_path": "tests/unittest_object_model.py", "class_name": "LruCacheModelTest", "func_name": "test_lru_cache", "text": "文件路径: tests/unittest_object_model.py, 类名: LruCacheModelTest\n    def test_lru_cache(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        import functools\n        class Foo(object):\n            @functools.lru_cache()\n            def foo():\n                pass\n        f = Foo()\n        f.foo.cache_clear #@\n        f.foo.__wrapped__ #@\n        f.foo.cache_info() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        cache_clear = next(ast_nodes[0].infer())\n        self.assertIsInstance(cache_clear, astroid.BoundMethod)\n        wrapped = next(ast_nodes[1].infer())\n        self.assertIsInstance(wrapped, astroid.FunctionDef)\n        self.assertEqual(wrapped.name, \"foo\")\n        cache_info = next(ast_nodes[2].infer())\n        self.assertIsInstance(cache_info, astroid.Instance)\n", "tokens": ["tests", "unittest_object_model", "py", "lrucachemodeltest", "def", "test_lru_cache", "self", "none", "ast_nodes", "builder", "extract_node", "import", "functools", "class", "foo", "object", "functools", "lru_cache", "def", "foo", "pass", "f", "foo", "f", "foo", "cache_clear", "f", "foo", "__wrapped__", "f", "foo", "cache_info", "assert", "isinstance", "ast_nodes", "list", "cache_clear", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "cache_clear", "astroid", "boundmethod", "wrapped", "next", "ast_nodes", "1", "infer", "self", "assertisinstance", "wrapped", "astroid", "functiondef", "self", "assertequal", "wrapped", "name", "foo", "cache_info", "next", "ast_nodes", "2", "infer", "self", "assertisinstance", "cache_info", "astroid", "instance"], "doc_len": 71}
{"doc_id": "tests/unittest_protocols.py::_add_transform", "file_path": "tests/unittest_protocols.py", "class_name": null, "func_name": "_add_transform", "text": "文件路径: tests/unittest_protocols.py\ndef _add_transform(\n    manager: AstroidManager,\n    node: type,\n    transform: Callable,\n    predicate: Optional[Any] = None,\n) -> Iterator:\n    manager.register_transform(node, transform, predicate)\n    try:\n        yield\n    finally:\n        manager.unregister_transform(node, transform, predicate)\n", "tokens": ["tests", "unittest_protocols", "py", "def", "_add_transform", "manager", "astroidmanager", "node", "type", "transform", "callable", "predicate", "optional", "any", "none", "iterator", "manager", "register_transform", "node", "transform", "predicate", "try", "yield", "finally", "manager", "unregister_transform", "node", "transform", "predicate"], "doc_len": 29}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.assertConstNodesEqual", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "assertConstNodesEqual", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def assertConstNodesEqual(\n        self, nodes_list_expected: List[int], nodes_list_got: List[nodes.Const]\n    ) -> None:\n        self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n        for node in nodes_list_got:\n            self.assertIsInstance(node, nodes.Const)\n        for node, expected_value in zip(nodes_list_got, nodes_list_expected):\n            self.assertEqual(expected_value, node.value)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "assertconstnodesequal", "self", "nodes_list_expected", "list", "int", "nodes_list_got", "list", "nodes", "const", "none", "self", "assertequal", "len", "nodes_list_expected", "len", "nodes_list_got", "for", "node", "in", "nodes_list_got", "self", "assertisinstance", "node", "nodes", "const", "for", "node", "expected_value", "in", "zip", "nodes_list_got", "nodes_list_expected", "self", "assertequal", "expected_value", "node", "value"], "doc_len": 42}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.assertNameNodesEqual", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "assertNameNodesEqual", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def assertNameNodesEqual(\n        self, nodes_list_expected: List[str], nodes_list_got: List[nodes.Name]\n    ) -> None:\n        self.assertEqual(len(nodes_list_expected), len(nodes_list_got))\n        for node in nodes_list_got:\n            self.assertIsInstance(node, nodes.Name)\n        for node, expected_name in zip(nodes_list_got, nodes_list_expected):\n            self.assertEqual(expected_name, node.name)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "assertnamenodesequal", "self", "nodes_list_expected", "list", "str", "nodes_list_got", "list", "nodes", "name", "none", "self", "assertequal", "len", "nodes_list_expected", "len", "nodes_list_got", "for", "node", "in", "nodes_list_got", "self", "assertisinstance", "node", "nodes", "name", "for", "node", "expected_name", "in", "zip", "nodes_list_got", "nodes_list_expected", "self", "assertequal", "expected_name", "node", "name"], "doc_len": 42}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_simple_for", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_simple_for", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_simple_for(self) -> None:\n        assign_stmts = extract_node(\n            \"\"\"\n        for a in (1, 2, 3):  #@\n          pass\n\n        for b in range(3): #@\n          pass\n        \"\"\"\n        )\n\n        for1_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n        assigned = list(for1_assnode.assigned_stmts())\n        self.assertConstNodesEqual([1, 2, 3], assigned)\n\n        for2_assnode = next(assign_stmts[1].nodes_of_class(nodes.AssignName))\n        self.assertRaises(InferenceError, list, for2_assnode.assigned_stmts())\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_simple_for", "self", "none", "assign_stmts", "extract_node", "for", "a", "in", "1", "2", "3", "pass", "for", "b", "in", "range", "3", "pass", "for1_assnode", "next", "assign_stmts", "0", "nodes_of_class", "nodes", "assignname", "assigned", "list", "for1_assnode", "assigned_stmts", "self", "assertconstnodesequal", "1", "2", "3", "assigned", "for2_assnode", "next", "assign_stmts", "1", "nodes_of_class", "nodes", "assignname", "self", "assertraises", "inferenceerror", "list", "for2_assnode", "assigned_stmts"], "doc_len": 53}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_starred_for", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_starred_for", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_starred_for(self) -> None:\n        assign_stmts = extract_node(\n            \"\"\"\n        for *a, b in ((1, 2, 3), (4, 5, 6, 7)): #@\n            pass\n        \"\"\"\n        )\n\n        for1_starred = next(assign_stmts.nodes_of_class(nodes.Starred))\n        assigned = next(for1_starred.assigned_stmts())\n        assert isinstance(assigned, astroid.List)\n        assert assigned.as_string() == \"[1, 2]\"\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_starred_for", "self", "none", "assign_stmts", "extract_node", "for", "a", "b", "in", "1", "2", "3", "4", "5", "6", "7", "pass", "for1_starred", "next", "assign_stmts", "nodes_of_class", "nodes", "starred", "assigned", "next", "for1_starred", "assigned_stmts", "assert", "isinstance", "assigned", "astroid", "list", "assert", "assigned", "as_string", "1", "2"], "doc_len": 42}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests._get_starred_stmts", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "_get_starred_stmts", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def _get_starred_stmts(self, code: str) -> Union[List, Uninferable]:\n        assign_stmt = extract_node(f\"{code} #@\")\n        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n        return next(starred.assigned_stmts())\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "_get_starred_stmts", "self", "code", "str", "union", "list", "uninferable", "assign_stmt", "extract_node", "f", "code", "starred", "next", "assign_stmt", "nodes_of_class", "nodes", "starred", "return", "next", "starred", "assigned_stmts"], "doc_len": 26}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests._helper_starred_expected_const", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "_helper_starred_expected_const", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def _helper_starred_expected_const(self, code: str, expected: List[int]) -> None:\n        stmts = self._get_starred_stmts(code)\n        self.assertIsInstance(stmts, nodes.List)\n        stmts = stmts.elts\n        self.assertConstNodesEqual(expected, stmts)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "_helper_starred_expected_const", "self", "code", "str", "expected", "list", "int", "none", "stmts", "self", "_get_starred_stmts", "code", "self", "assertisinstance", "stmts", "nodes", "list", "stmts", "stmts", "elts", "self", "assertconstnodesequal", "expected", "stmts"], "doc_len": 29}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests._helper_starred_expected", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "_helper_starred_expected", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def _helper_starred_expected(self, code: str, expected: Uninferable) -> None:\n        stmts = self._get_starred_stmts(code)\n        self.assertEqual(expected, stmts)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "_helper_starred_expected", "self", "code", "str", "expected", "uninferable", "none", "stmts", "self", "_get_starred_stmts", "code", "self", "assertequal", "expected", "stmts"], "doc_len": 20}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests._helper_starred_inference_error", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "_helper_starred_inference_error", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def _helper_starred_inference_error(self, code: str) -> None:\n        assign_stmt = extract_node(f\"{code} #@\")\n        starred = next(assign_stmt.nodes_of_class(nodes.Starred))\n        self.assertRaises(InferenceError, list, starred.assigned_stmts())\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "_helper_starred_inference_error", "self", "code", "str", "none", "assign_stmt", "extract_node", "f", "code", "starred", "next", "assign_stmt", "nodes_of_class", "nodes", "starred", "self", "assertraises", "inferenceerror", "list", "starred", "assigned_stmts"], "doc_len": 26}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_starred_assnames", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_starred_assnames", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_starred_assnames(self) -> None:\n        self._helper_starred_expected_const(\"a, *b = (1, 2, 3, 4) #@\", [2, 3, 4])\n        self._helper_starred_expected_const(\"*a, b = (1, 2, 3) #@\", [1, 2])\n        self._helper_starred_expected_const(\"a, *b, c = (1, 2, 3, 4, 5) #@\", [2, 3, 4])\n        self._helper_starred_expected_const(\"a, *b = (1, 2) #@\", [2])\n        self._helper_starred_expected_const(\"*b, a = (1, 2) #@\", [1])\n        self._helper_starred_expected_const(\"[*b] = (1, 2) #@\", [1, 2])\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_starred_assnames", "self", "none", "self", "_helper_starred_expected_const", "a", "b", "1", "2", "3", "4", "2", "3", "4", "self", "_helper_starred_expected_const", "a", "b", "1", "2", "3", "1", "2", "self", "_helper_starred_expected_const", "a", "b", "c", "1", "2", "3", "4", "5", "2", "3", "4", "self", "_helper_starred_expected_const", "a", "b", "1", "2", "2", "self", "_helper_starred_expected_const", "b", "a", "1", "2", "1", "self", "_helper_starred_expected_const", "b", "1", "2", "1", "2"], "doc_len": 62}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_starred_yes", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_starred_yes", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_starred_yes(self) -> None:\n        # Not something iterable and known\n        self._helper_starred_expected(\"a, *b = range(3) #@\", Uninferable)\n        # Not something inferable\n        self._helper_starred_expected(\"a, *b = balou() #@\", Uninferable)\n        # In function, unknown.\n        self._helper_starred_expected(\n            \"\"\"\n        def test(arg):\n            head, *tail = arg #@\"\"\",\n            Uninferable,\n        )\n        # These cases aren't worth supporting.\n        self._helper_starred_expected(\n            \"a, (*b, c), d = (1, (2, 3, 4), 5) #@\", Uninferable\n        )\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_starred_yes", "self", "none", "not", "something", "iterable", "and", "known", "self", "_helper_starred_expected", "a", "b", "range", "3", "uninferable", "not", "something", "inferable", "self", "_helper_starred_expected", "a", "b", "balou", "uninferable", "in", "function", "unknown", "self", "_helper_starred_expected", "def", "test", "arg", "head", "tail", "arg", "uninferable", "these", "cases", "aren", "t", "worth", "supporting", "self", "_helper_starred_expected", "a", "b", "c", "d", "1", "2", "3", "4", "5", "uninferable"], "doc_len": 59}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assign_stmts_starred_fails", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assign_stmts_starred_fails", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assign_stmts_starred_fails(self) -> None:\n        # Too many starred\n        self._helper_starred_inference_error(\"a, *b, *c = (1, 2, 3) #@\")\n        # This could be solved properly, but it complicates needlessly the\n        # code for assigned_stmts, without offering real benefit.\n        self._helper_starred_inference_error(\n            \"(*a, b), (c, *d) = (1, 2, 3), (4, 5, 6) #@\"\n        )\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assign_stmts_starred_fails", "self", "none", "too", "many", "starred", "self", "_helper_starred_inference_error", "a", "b", "c", "1", "2", "3", "this", "could", "be", "solved", "properly", "but", "it", "complicates", "needlessly", "the", "code", "for", "assigned_stmts", "without", "offering", "real", "benefit", "self", "_helper_starred_inference_error", "a", "b", "c", "d", "1", "2", "3", "4", "5", "6"], "doc_len": 48}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_assignments", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_assignments", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_assignments(self) -> None:\n        assign_stmts = extract_node(\n            \"\"\"\n        c = a #@\n\n        d, e = b, c #@\n        \"\"\"\n        )\n\n        simple_assnode = next(assign_stmts[0].nodes_of_class(nodes.AssignName))\n        assigned = list(simple_assnode.assigned_stmts())\n        self.assertNameNodesEqual([\"a\"], assigned)\n\n        assnames = assign_stmts[1].nodes_of_class(nodes.AssignName)\n        simple_mul_assnode_1 = next(assnames)\n        assigned = list(simple_mul_assnode_1.assigned_stmts())\n        self.assertNameNodesEqual([\"b\"], assigned)\n        simple_mul_assnode_2 = next(assnames)\n        assigned = list(simple_mul_assnode_2.assigned_stmts())\n        self.assertNameNodesEqual([\"c\"], assigned)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_assignments", "self", "none", "assign_stmts", "extract_node", "c", "a", "d", "e", "b", "c", "simple_assnode", "next", "assign_stmts", "0", "nodes_of_class", "nodes", "assignname", "assigned", "list", "simple_assnode", "assigned_stmts", "self", "assertnamenodesequal", "a", "assigned", "assnames", "assign_stmts", "1", "nodes_of_class", "nodes", "assignname", "simple_mul_assnode_1", "next", "assnames", "assigned", "list", "simple_mul_assnode_1", "assigned_stmts", "self", "assertnamenodesequal", "b", "assigned", "simple_mul_assnode_2", "next", "assnames", "assigned", "list", "simple_mul_assnode_2", "assigned_stmts", "self", "assertnamenodesequal", "c", "assigned"], "doc_len": 59}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_assigned_stmts_annassignments", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_assigned_stmts_annassignments", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_assigned_stmts_annassignments(self) -> None:\n        annassign_stmts = extract_node(\n            \"\"\"\n        a: str = \"abc\"  #@\n        b: str  #@\n        \"\"\"\n        )\n        simple_annassign_node = next(\n            annassign_stmts[0].nodes_of_class(nodes.AssignName)\n        )\n        assigned = list(simple_annassign_node.assigned_stmts())\n        self.assertEqual(1, len(assigned))\n        self.assertIsInstance(assigned[0], nodes.Const)\n        self.assertEqual(assigned[0].value, \"abc\")\n\n        empty_annassign_node = next(annassign_stmts[1].nodes_of_class(nodes.AssignName))\n        assigned = list(empty_annassign_node.assigned_stmts())\n        self.assertEqual(1, len(assigned))\n        self.assertIs(assigned[0], Uninferable)\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_assigned_stmts_annassignments", "self", "none", "annassign_stmts", "extract_node", "a", "str", "abc", "b", "str", "simple_annassign_node", "next", "annassign_stmts", "0", "nodes_of_class", "nodes", "assignname", "assigned", "list", "simple_annassign_node", "assigned_stmts", "self", "assertequal", "1", "len", "assigned", "self", "assertisinstance", "assigned", "0", "nodes", "const", "self", "assertequal", "assigned", "0", "value", "abc", "empty_annassign_node", "next", "annassign_stmts", "1", "nodes_of_class", "nodes", "assignname", "assigned", "list", "empty_annassign_node", "assigned_stmts", "self", "assertequal", "1", "len", "assigned", "self", "assertis", "assigned", "0", "uninferable"], "doc_len": 64}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_sequence_assigned_stmts_not_accepting_empty_node", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_sequence_assigned_stmts_not_accepting_empty_node", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_sequence_assigned_stmts_not_accepting_empty_node(self) -> None:\n        def transform(node: nodes.Assign) -> None:\n            node.root().locals[\"__all__\"] = [node.value]\n\n        manager = astroid.MANAGER\n        with _add_transform(manager, astroid.Assign, transform):\n            module = astroid.parse(\n                \"\"\"\n            __all__ = ['a']\n            \"\"\"\n            )\n            module.wildcard_import_names()\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_sequence_assigned_stmts_not_accepting_empty_node", "self", "none", "def", "transform", "node", "nodes", "assign", "none", "node", "root", "locals", "__all__", "node", "value", "manager", "astroid", "manager", "with", "_add_transform", "manager", "astroid", "assign", "transform", "module", "astroid", "parse", "__all__", "a", "module", "wildcard_import_names"], "doc_len": 36}
{"doc_id": "tests/unittest_protocols.py::ProtocolTests.test_not_passing_uninferable_in_seq_inference", "file_path": "tests/unittest_protocols.py", "class_name": "ProtocolTests", "func_name": "test_not_passing_uninferable_in_seq_inference", "text": "文件路径: tests/unittest_protocols.py, 类名: ProtocolTests\n    def test_not_passing_uninferable_in_seq_inference(self) -> None:\n        class Visitor:\n            def visit(self, node: Union[nodes.Assign, nodes.BinOp, nodes.List]) -> Any:\n                for child in node.get_children():\n                    child.accept(self)\n\n            visit_module = visit\n            visit_assign = visit\n            visit_binop = visit\n            visit_list = visit\n            visit_const = visit\n            visit_name = visit\n\n            def visit_assignname(self, node: nodes.AssignName) -> None:\n                for _ in node.infer():\n                    pass\n\n        parsed = extract_node(\n            \"\"\"\n        a = []\n        x = [a*2, a]*2*2\n        \"\"\"\n        )\n        parsed.accept(Visitor())\n", "tokens": ["tests", "unittest_protocols", "py", "protocoltests", "def", "test_not_passing_uninferable_in_seq_inference", "self", "none", "class", "visitor", "def", "visit", "self", "node", "union", "nodes", "assign", "nodes", "binop", "nodes", "list", "any", "for", "child", "in", "node", "get_children", "child", "accept", "self", "visit_module", "visit", "visit_assign", "visit", "visit_binop", "visit", "visit_list", "visit", "visit_const", "visit", "visit_name", "visit", "def", "visit_assignname", "self", "node", "nodes", "assignname", "none", "for", "_", "in", "node", "infer", "pass", "parsed", "extract_node", "a", "x", "a", "2", "a", "2", "2", "parsed", "accept", "visitor"], "doc_len": 67}
{"doc_id": "tests/unittest_protocols.py::test_named_expr_inference", "file_path": "tests/unittest_protocols.py", "class_name": null, "func_name": "test_named_expr_inference", "text": "文件路径: tests/unittest_protocols.py\ndef test_named_expr_inference() -> None:\n    code = \"\"\"\n    if (a := 2) == 2:\n        a #@\n\n\n    # Test a function call\n    def test():\n        return 24\n\n    if (a := test()):\n        a #@\n\n    # Normal assignments in sequences\n    { (a:= 4) } #@\n    [ (a:= 5) ] #@\n\n    # Something more complicated\n    def test(value=(p := 24)): return p\n    [ y:= test()] #@\n\n    # Priority assignment\n    (x := 1, 2)\n    x #@\n    \"\"\"\n    ast_nodes = extract_node(code)\n    assert isinstance(ast_nodes, list)\n    node = next(ast_nodes[0].infer())\n    assert isinstance(node, nodes.Const)\n    assert node.value == 2\n\n    node = next(ast_nodes[1].infer())\n    assert isinstance(node, nodes.Const)\n    assert node.value == 24\n\n    node = next(ast_nodes[2].infer())\n    assert isinstance(node, nodes.Set)\n    assert isinstance(node.elts[0], nodes.Const)\n    assert node.elts[0].value == 4\n\n    node = next(ast_nodes[3].infer())\n    assert isinstance(node, nodes.List)\n    assert isinstance(node.elts[0], nodes.Const)\n    assert node.elts[0].value == 5\n\n    node = next(ast_nodes[4].infer())\n    assert isinstance(node, nodes.List)\n    assert isinstance(node.elts[0], nodes.Const)\n    assert node.elts[0].value == 24\n\n    node = next(ast_nodes[5].infer())\n    assert isinstance(node, nodes.Const)\n    assert node.value == 1\n", "tokens": ["tests", "unittest_protocols", "py", "def", "test_named_expr_inference", "none", "code", "if", "a", "2", "2", "a", "test", "a", "function", "call", "def", "test", "return", "24", "if", "a", "test", "a", "normal", "assignments", "in", "sequences", "a", "4", "a", "5", "something", "more", "complicated", "def", "test", "value", "p", "24", "return", "p", "y", "test", "priority", "assignment", "x", "1", "2", "x", "ast_nodes", "extract_node", "code", "assert", "isinstance", "ast_nodes", "list", "node", "next", "ast_nodes", "0", "infer", "assert", "isinstance", "node", "nodes", "const", "assert", "node", "value", "2", "node", "next", "ast_nodes", "1", "infer", "assert", "isinstance", "node", "nodes", "const", "assert", "node", "value", "24", "node", "next", "ast_nodes", "2", "infer", "assert", "isinstance", "node", "nodes", "set", "assert", "isinstance", "node", "elts", "0", "nodes", "const", "assert", "node", "elts", "0", "value", "4", "node", "next", "ast_nodes", "3", "infer", "assert", "isinstance", "node", "nodes", "list", "assert", "isinstance", "node", "elts", "0", "nodes", "const", "assert", "node", "elts", "0", "value", "5", "node", "next", "ast_nodes", "4", "infer", "assert", "isinstance", "node", "nodes", "list", "assert", "isinstance", "node", "elts", "0", "nodes", "const", "assert", "node", "elts", "0", "value", "24", "node", "next", "ast_nodes", "5", "infer", "assert", "isinstance", "node", "nodes", "const", "assert", "node", "value", "1"], "doc_len": 168}
{"doc_id": "tests/unittest_protocols.py::TestPatternMatching.test_assigned_stmts_match_mapping", "file_path": "tests/unittest_protocols.py", "class_name": "TestPatternMatching", "func_name": "test_assigned_stmts_match_mapping", "text": "文件路径: tests/unittest_protocols.py, 类名: TestPatternMatching\n    def test_assigned_stmts_match_mapping():\n        \"\"\"Assigned_stmts for MatchMapping not yet implemented.\n\n        Test the result is 'Uninferable' and no exception is raised.\n        \"\"\"\n        assign_stmts = extract_node(\n            \"\"\"\n        var = {1: \"Hello\", 2: \"World\"}\n        match var:\n            case {**rest}:  #@\n                pass\n        \"\"\"\n        )\n        match_mapping: nodes.MatchMapping = assign_stmts.pattern  # type: ignore[union-attr]\n        assert match_mapping.rest\n        assigned = next(match_mapping.rest.assigned_stmts())\n        assert assigned == Uninferable\n", "tokens": ["tests", "unittest_protocols", "py", "testpatternmatching", "def", "test_assigned_stmts_match_mapping", "assigned_stmts", "for", "matchmapping", "not", "yet", "implemented", "test", "the", "result", "is", "uninferable", "and", "no", "exception", "is", "raised", "assign_stmts", "extract_node", "var", "1", "hello", "2", "world", "match", "var", "case", "rest", "pass", "match_mapping", "nodes", "matchmapping", "assign_stmts", "pattern", "type", "ignore", "union", "attr", "assert", "match_mapping", "rest", "assigned", "next", "match_mapping", "rest", "assigned_stmts", "assert", "assigned", "uninferable"], "doc_len": 54}
{"doc_id": "tests/unittest_protocols.py::TestPatternMatching.test_assigned_stmts_match_star", "file_path": "tests/unittest_protocols.py", "class_name": "TestPatternMatching", "func_name": "test_assigned_stmts_match_star", "text": "文件路径: tests/unittest_protocols.py, 类名: TestPatternMatching\n    def test_assigned_stmts_match_star():\n        \"\"\"Assigned_stmts for MatchStar not yet implemented.\n\n        Test the result is 'Uninferable' and no exception is raised.\n        \"\"\"\n        assign_stmts = extract_node(\n            \"\"\"\n        var = (0, 1, 2)\n        match var:\n            case (0, 1, *rest):  #@\n                pass\n        \"\"\"\n        )\n        match_sequence: nodes.MatchSequence = assign_stmts.pattern  # type: ignore[union-attr]\n        match_star = match_sequence.patterns[2]\n        assert isinstance(match_star, nodes.MatchStar) and match_star.name\n        assigned = next(match_star.name.assigned_stmts())\n        assert assigned == Uninferable\n", "tokens": ["tests", "unittest_protocols", "py", "testpatternmatching", "def", "test_assigned_stmts_match_star", "assigned_stmts", "for", "matchstar", "not", "yet", "implemented", "test", "the", "result", "is", "uninferable", "and", "no", "exception", "is", "raised", "assign_stmts", "extract_node", "var", "0", "1", "2", "match", "var", "case", "0", "1", "rest", "pass", "match_sequence", "nodes", "matchsequence", "assign_stmts", "pattern", "type", "ignore", "union", "attr", "match_star", "match_sequence", "patterns", "2", "assert", "isinstance", "match_star", "nodes", "matchstar", "and", "match_star", "name", "assigned", "next", "match_star", "name", "assigned_stmts", "assert", "assigned", "uninferable"], "doc_len": 64}
{"doc_id": "tests/unittest_protocols.py::TestPatternMatching.test_assigned_stmts_match_as", "file_path": "tests/unittest_protocols.py", "class_name": "TestPatternMatching", "func_name": "test_assigned_stmts_match_as", "text": "文件路径: tests/unittest_protocols.py, 类名: TestPatternMatching\n    def test_assigned_stmts_match_as():\n        \"\"\"Assigned_stmts for MatchAs only implemented for the most basic case (y).\"\"\"\n        assign_stmts = extract_node(\n            \"\"\"\n        var = 42\n        match var:  #@\n            case 2 | x:  #@\n                pass\n            case (1, 2) as y:  #@\n                pass\n            case z:  #@\n                pass\n        \"\"\"\n        )\n        subject: nodes.Const = assign_stmts[0].subject  # type: ignore[index,union-attr]\n        match_or: nodes.MatchOr = assign_stmts[1].pattern  # type: ignore[index,union-attr]\n        match_as_with_pattern: nodes.MatchAs = assign_stmts[2].pattern  # type: ignore[index,union-attr]\n        match_as: nodes.MatchAs = assign_stmts[3].pattern  # type: ignore[index,union-attr]\n\n        match_or_1 = match_or.patterns[1]\n        assert isinstance(match_or_1, nodes.MatchAs) and match_or_1.name\n        assigned_match_or_1 = next(match_or_1.name.assigned_stmts())\n        assert assigned_match_or_1 == Uninferable\n\n        assert match_as_with_pattern.name and match_as_with_pattern.pattern\n        assigned_match_as_pattern = next(match_as_with_pattern.name.assigned_stmts())\n        assert assigned_match_as_pattern == Uninferable\n\n        assert match_as.name\n        assigned_match_as = next(match_as.name.assigned_stmts())\n        assert assigned_match_as == subject\n", "tokens": ["tests", "unittest_protocols", "py", "testpatternmatching", "def", "test_assigned_stmts_match_as", "assigned_stmts", "for", "matchas", "only", "implemented", "for", "the", "most", "basic", "case", "y", "assign_stmts", "extract_node", "var", "42", "match", "var", "case", "2", "x", "pass", "case", "1", "2", "as", "y", "pass", "case", "z", "pass", "subject", "nodes", "const", "assign_stmts", "0", "subject", "type", "ignore", "index", "union", "attr", "match_or", "nodes", "matchor", "assign_stmts", "1", "pattern", "type", "ignore", "index", "union", "attr", "match_as_with_pattern", "nodes", "matchas", "assign_stmts", "2", "pattern", "type", "ignore", "index", "union", "attr", "match_as", "nodes", "matchas", "assign_stmts", "3", "pattern", "type", "ignore", "index", "union", "attr", "match_or_1", "match_or", "patterns", "1", "assert", "isinstance", "match_or_1", "nodes", "matchas", "and", "match_or_1", "name", "assigned_match_or_1", "next", "match_or_1", "name", "assigned_stmts", "assert", "assigned_match_or_1", "uninferable", "assert", "match_as_with_pattern", "name", "and", "match_as_with_pattern", "pattern", "assigned_match_as_pattern", "next", "match_as_with_pattern", "name", "assigned_stmts", "assert", "assigned_match_as_pattern", "uninferable", "assert", "match_as", "name", "assigned_match_as", "next", "match_as", "name", "assigned_stmts", "assert", "assigned_match_as", "subject"], "doc_len": 125}
{"doc_id": "tests/unittest_python3.py::Python3TC.setUpClass", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "setUpClass", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def setUpClass(cls):\n        cls.builder = AstroidBuilder()\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "setupclass", "cls", "cls", "builder", "astroidbuilder"], "doc_len": 10}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_starred_notation", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_starred_notation", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_starred_notation(self) -> None:\n        astroid = self.builder.string_build(\"*a, b = [1, 2, 3]\", \"test\", \"test\")\n\n        # Get the star node\n        node = next(next(next(astroid.get_children()).get_children()).get_children())\n\n        self.assertTrue(isinstance(node.assign_type(), nodes.Assign))\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_starred_notation", "self", "none", "astroid", "self", "builder", "string_build", "a", "b", "1", "2", "3", "test", "test", "get", "the", "star", "node", "node", "next", "next", "next", "astroid", "get_children", "get_children", "get_children", "self", "asserttrue", "isinstance", "node", "assign_type", "nodes", "assign"], "doc_len": 38}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_yield_from", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_yield_from", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_yield_from(self) -> None:\n        body = dedent(\n            \"\"\"\n        def func():\n            yield from iter([1, 2])\n        \"\"\"\n        )\n        astroid = self.builder.string_build(body)\n        func = astroid.body[0]\n        self.assertIsInstance(func, nodes.FunctionDef)\n        yieldfrom_stmt = func.body[0]\n\n        self.assertIsInstance(yieldfrom_stmt, nodes.Expr)\n        self.assertIsInstance(yieldfrom_stmt.value, nodes.YieldFrom)\n        self.assertEqual(yieldfrom_stmt.as_string(), \"yield from iter([1, 2])\")\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_yield_from", "self", "none", "body", "dedent", "def", "func", "yield", "from", "iter", "1", "2", "astroid", "self", "builder", "string_build", "body", "func", "astroid", "body", "0", "self", "assertisinstance", "func", "nodes", "functiondef", "yieldfrom_stmt", "func", "body", "0", "self", "assertisinstance", "yieldfrom_stmt", "nodes", "expr", "self", "assertisinstance", "yieldfrom_stmt", "value", "nodes", "yieldfrom", "self", "assertequal", "yieldfrom_stmt", "as_string", "yield", "from", "iter", "1", "2"], "doc_len": 55}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_yield_from_is_generator", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_yield_from_is_generator", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_yield_from_is_generator(self) -> None:\n        body = dedent(\n            \"\"\"\n        def func():\n            yield from iter([1, 2])\n        \"\"\"\n        )\n        astroid = self.builder.string_build(body)\n        func = astroid.body[0]\n        self.assertIsInstance(func, nodes.FunctionDef)\n        self.assertTrue(func.is_generator())\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_yield_from_is_generator", "self", "none", "body", "dedent", "def", "func", "yield", "from", "iter", "1", "2", "astroid", "self", "builder", "string_build", "body", "func", "astroid", "body", "0", "self", "assertisinstance", "func", "nodes", "functiondef", "self", "asserttrue", "func", "is_generator"], "doc_len": 35}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_yield_from_as_string", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_yield_from_as_string", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_yield_from_as_string(self) -> None:\n        body = dedent(\n            \"\"\"\n        def func():\n            yield from iter([1, 2])\n            value = yield from other()\n        \"\"\"\n        )\n        astroid = self.builder.string_build(body)\n        func = astroid.body[0]\n        self.assertEqual(func.as_string().strip(), body.strip())\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_yield_from_as_string", "self", "none", "body", "dedent", "def", "func", "yield", "from", "iter", "1", "2", "value", "yield", "from", "other", "astroid", "self", "builder", "string_build", "body", "func", "astroid", "body", "0", "self", "assertequal", "func", "as_string", "strip", "body", "strip"], "doc_len": 37}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_simple_metaclass", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_simple_metaclass", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_simple_metaclass(self) -> None:\n        astroid = self.builder.string_build(\"class Test(metaclass=type): pass\")\n        klass = astroid.body[0]\n\n        metaclass = klass.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertEqual(metaclass.name, \"type\")\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_simple_metaclass", "self", "none", "astroid", "self", "builder", "string_build", "class", "test", "metaclass", "type", "pass", "klass", "astroid", "body", "0", "metaclass", "klass", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertequal", "metaclass", "name", "type"], "doc_len": 34}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_metaclass_error", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_metaclass_error", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_metaclass_error(self) -> None:\n        astroid = self.builder.string_build(\"class Test(metaclass=typ): pass\")\n        klass = astroid.body[0]\n        self.assertFalse(klass.metaclass())\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_metaclass_error", "self", "none", "astroid", "self", "builder", "string_build", "class", "test", "metaclass", "typ", "pass", "klass", "astroid", "body", "0", "self", "assertfalse", "klass", "metaclass"], "doc_len": 25}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_metaclass_imported", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_metaclass_imported", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_metaclass_imported(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        from abc import ABCMeta\n        class Test(metaclass=ABCMeta): pass\"\"\"\n            )\n        )\n        klass = astroid.body[1]\n\n        metaclass = klass.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertEqual(metaclass.name, \"ABCMeta\")\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_metaclass_imported", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "from", "abc", "import", "abcmeta", "class", "test", "metaclass", "abcmeta", "pass", "klass", "astroid", "body", "1", "metaclass", "klass", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertequal", "metaclass", "name", "abcmeta"], "doc_len": 39}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_metaclass_multiple_keywords", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_metaclass_multiple_keywords", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_metaclass_multiple_keywords(self) -> None:\n        astroid = self.builder.string_build(\n            \"class Test(magic=None, metaclass=type): pass\"\n        )\n        klass = astroid.body[0]\n\n        metaclass = klass.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertEqual(metaclass.name, \"type\")\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_metaclass_multiple_keywords", "self", "none", "astroid", "self", "builder", "string_build", "class", "test", "magic", "none", "metaclass", "type", "pass", "klass", "astroid", "body", "0", "metaclass", "klass", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertequal", "metaclass", "name", "type"], "doc_len": 36}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_as_string", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_as_string", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_as_string(self) -> None:\n        body = dedent(\n            \"\"\"\n        from abc import ABCMeta\n        class Test(metaclass=ABCMeta): pass\"\"\"\n        )\n        astroid = self.builder.string_build(body)\n        klass = astroid.body[1]\n\n        self.assertEqual(\n            klass.as_string(), \"\\n\\nclass Test(metaclass=ABCMeta):\\n    pass\\n\"\n        )\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_as_string", "self", "none", "body", "dedent", "from", "abc", "import", "abcmeta", "class", "test", "metaclass", "abcmeta", "pass", "astroid", "self", "builder", "string_build", "body", "klass", "astroid", "body", "1", "self", "assertequal", "klass", "as_string", "n", "nclass", "test", "metaclass", "abcmeta", "n", "pass", "n"], "doc_len": 40}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_old_syntax_works", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_old_syntax_works", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_old_syntax_works(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        class Test:\n            __metaclass__ = type\n        class SubTest(Test): pass\n        \"\"\"\n            )\n        )\n        klass = astroid[\"SubTest\"]\n        metaclass = klass.metaclass()\n        self.assertIsNone(metaclass)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_old_syntax_works", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "class", "test", "__metaclass__", "type", "class", "subtest", "test", "pass", "klass", "astroid", "subtest", "metaclass", "klass", "metaclass", "self", "assertisnone", "metaclass"], "doc_len": 30}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_metaclass_yes_leak", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_metaclass_yes_leak", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_metaclass_yes_leak(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        # notice `ab` instead of `abc`\n        from ab import ABCMeta\n\n        class Meta(metaclass=ABCMeta): pass\n        \"\"\"\n            )\n        )\n        klass = astroid[\"Meta\"]\n        self.assertIsNone(klass.metaclass())\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_metaclass_yes_leak", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "notice", "ab", "instead", "of", "abc", "from", "ab", "import", "abcmeta", "class", "meta", "metaclass", "abcmeta", "pass", "klass", "astroid", "meta", "self", "assertisnone", "klass", "metaclass"], "doc_len": 34}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_parent_metaclass", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_parent_metaclass", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_parent_metaclass(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        from abc import ABCMeta\n        class Test(metaclass=ABCMeta): pass\n        class SubTest(Test): pass\n        \"\"\"\n            )\n        )\n        klass = astroid[\"SubTest\"]\n        self.assertTrue(klass.newstyle)\n        metaclass = klass.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertEqual(metaclass.name, \"ABCMeta\")\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_parent_metaclass", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "from", "abc", "import", "abcmeta", "class", "test", "metaclass", "abcmeta", "pass", "class", "subtest", "test", "pass", "klass", "astroid", "subtest", "self", "asserttrue", "klass", "newstyle", "metaclass", "klass", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertequal", "metaclass", "name", "abcmeta"], "doc_len": 46}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_metaclass_ancestors", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_metaclass_ancestors", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_metaclass_ancestors(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        from abc import ABCMeta\n\n        class FirstMeta(metaclass=ABCMeta): pass\n        class SecondMeta(metaclass=type):\n            pass\n\n        class Simple:\n            pass\n\n        class FirstImpl(FirstMeta): pass\n        class SecondImpl(FirstImpl): pass\n        class ThirdImpl(Simple, SecondMeta):\n            pass\n        \"\"\"\n            )\n        )\n        classes = {\"ABCMeta\": (\"FirstImpl\", \"SecondImpl\"), \"type\": (\"ThirdImpl\",)}\n        for metaclass, names in classes.items():\n            for name in names:\n                impl = astroid[name]\n                meta = impl.metaclass()\n                self.assertIsInstance(meta, nodes.ClassDef)\n                self.assertEqual(meta.name, metaclass)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_metaclass_ancestors", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "from", "abc", "import", "abcmeta", "class", "firstmeta", "metaclass", "abcmeta", "pass", "class", "secondmeta", "metaclass", "type", "pass", "class", "simple", "pass", "class", "firstimpl", "firstmeta", "pass", "class", "secondimpl", "firstimpl", "pass", "class", "thirdimpl", "simple", "secondmeta", "pass", "classes", "abcmeta", "firstimpl", "secondimpl", "type", "thirdimpl", "for", "metaclass", "names", "in", "classes", "items", "for", "name", "in", "names", "impl", "astroid", "name", "meta", "impl", "metaclass", "self", "assertisinstance", "meta", "nodes", "classdef", "self", "assertequal", "meta", "name", "metaclass"], "doc_len": 75}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_annotation_support", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_annotation_support", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_annotation_support(self) -> None:\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        def test(a: int, b: str, c: None, d, e,\n                 *args: float, **kwargs: int)->int:\n            pass\n        \"\"\"\n            )\n        )\n        func = astroid[\"test\"]\n        self.assertIsInstance(func.args.varargannotation, nodes.Name)\n        self.assertEqual(func.args.varargannotation.name, \"float\")\n        self.assertIsInstance(func.args.kwargannotation, nodes.Name)\n        self.assertEqual(func.args.kwargannotation.name, \"int\")\n        self.assertIsInstance(func.returns, nodes.Name)\n        self.assertEqual(func.returns.name, \"int\")\n        arguments = func.args\n        self.assertIsInstance(arguments.annotations[0], nodes.Name)\n        self.assertEqual(arguments.annotations[0].name, \"int\")\n        self.assertIsInstance(arguments.annotations[1], nodes.Name)\n        self.assertEqual(arguments.annotations[1].name, \"str\")\n        self.assertIsInstance(arguments.annotations[2], nodes.Const)\n        self.assertIsNone(arguments.annotations[2].value)\n        self.assertIsNone(arguments.annotations[3])\n        self.assertIsNone(arguments.annotations[4])\n\n        astroid = self.builder.string_build(\n            dedent(\n                \"\"\"\n        def test(a: int=1, b: str=2):\n            pass\n        \"\"\"\n            )\n        )\n        func = astroid[\"test\"]\n        self.assertIsInstance(func.args.annotations[0], nodes.Name)\n        self.assertEqual(func.args.annotations[0].name, \"int\")\n        self.assertIsInstance(func.args.annotations[1], nodes.Name)\n        self.assertEqual(func.args.annotations[1].name, \"str\")\n        self.assertIsNone(func.returns)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_annotation_support", "self", "none", "astroid", "self", "builder", "string_build", "dedent", "def", "test", "a", "int", "b", "str", "c", "none", "d", "e", "args", "float", "kwargs", "int", "int", "pass", "func", "astroid", "test", "self", "assertisinstance", "func", "args", "varargannotation", "nodes", "name", "self", "assertequal", "func", "args", "varargannotation", "name", "float", "self", "assertisinstance", "func", "args", "kwargannotation", "nodes", "name", "self", "assertequal", "func", "args", "kwargannotation", "name", "int", "self", "assertisinstance", "func", "returns", "nodes", "name", "self", "assertequal", "func", "returns", "name", "int", "arguments", "func", "args", "self", "assertisinstance", "arguments", "annotations", "0", "nodes", "name", "self", "assertequal", "arguments", "annotations", "0", "name", "int", "self", "assertisinstance", "arguments", "annotations", "1", "nodes", "name", "self", "assertequal", "arguments", "annotations", "1", "name", "str", "self", "assertisinstance", "arguments", "annotations", "2", "nodes", "const", "self", "assertisnone", "arguments", "annotations", "2", "value", "self", "assertisnone", "arguments", "annotations", "3", "self", "assertisnone", "arguments", "annotations", "4", "astroid", "self", "builder", "string_build", "dedent", "def", "test", "a", "int", "1", "b", "str", "2", "pass", "func", "astroid", "test", "self", "assertisinstance", "func", "args", "annotations", "0", "nodes", "name", "self", "assertequal", "func", "args", "annotations", "0", "name", "int", "self", "assertisinstance", "func", "args", "annotations", "1", "nodes", "name", "self", "assertequal", "func", "args", "annotations", "1", "name", "str", "self", "assertisnone", "func", "returns"], "doc_len": 179}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_kwonlyargs_annotations_supper", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_kwonlyargs_annotations_supper", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_kwonlyargs_annotations_supper(self) -> None:\n        node = self.builder.string_build(\n            dedent(\n                \"\"\"\n        def test(*, a: int, b: str, c: None, d, e):\n            pass\n        \"\"\"\n            )\n        )\n        func = node[\"test\"]\n        arguments = func.args\n        self.assertIsInstance(arguments.kwonlyargs_annotations[0], nodes.Name)\n        self.assertEqual(arguments.kwonlyargs_annotations[0].name, \"int\")\n        self.assertIsInstance(arguments.kwonlyargs_annotations[1], nodes.Name)\n        self.assertEqual(arguments.kwonlyargs_annotations[1].name, \"str\")\n        self.assertIsInstance(arguments.kwonlyargs_annotations[2], nodes.Const)\n        self.assertIsNone(arguments.kwonlyargs_annotations[2].value)\n        self.assertIsNone(arguments.kwonlyargs_annotations[3])\n        self.assertIsNone(arguments.kwonlyargs_annotations[4])\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_kwonlyargs_annotations_supper", "self", "none", "node", "self", "builder", "string_build", "dedent", "def", "test", "a", "int", "b", "str", "c", "none", "d", "e", "pass", "func", "node", "test", "arguments", "func", "args", "self", "assertisinstance", "arguments", "kwonlyargs_annotations", "0", "nodes", "name", "self", "assertequal", "arguments", "kwonlyargs_annotations", "0", "name", "int", "self", "assertisinstance", "arguments", "kwonlyargs_annotations", "1", "nodes", "name", "self", "assertequal", "arguments", "kwonlyargs_annotations", "1", "name", "str", "self", "assertisinstance", "arguments", "kwonlyargs_annotations", "2", "nodes", "const", "self", "assertisnone", "arguments", "kwonlyargs_annotations", "2", "value", "self", "assertisnone", "arguments", "kwonlyargs_annotations", "3", "self", "assertisnone", "arguments", "kwonlyargs_annotations", "4"], "doc_len": 81}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_annotation_as_string", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_annotation_as_string", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_annotation_as_string(self) -> None:\n        code1 = dedent(\n            \"\"\"\n        def test(a, b: int = 4, c=2, f: 'lala' = 4) -> 2:\n            pass\"\"\"\n        )\n        code2 = dedent(\n            \"\"\"\n        def test(a: typing.Generic[T], c: typing.Any = 24) -> typing.Iterable:\n            pass\"\"\"\n        )\n        for code in (code1, code2):\n            func = extract_node(code)\n            self.assertEqual(func.as_string(), code)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_annotation_as_string", "self", "none", "code1", "dedent", "def", "test", "a", "b", "int", "4", "c", "2", "f", "lala", "4", "2", "pass", "code2", "dedent", "def", "test", "a", "typing", "generic", "t", "c", "typing", "any", "24", "typing", "iterable", "pass", "for", "code", "in", "code1", "code2", "func", "extract_node", "code", "self", "assertequal", "func", "as_string", "code"], "doc_len": 51}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_unpacking_in_dicts", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_unpacking_in_dicts", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_unpacking_in_dicts(self) -> None:\n        code = \"{'x': 1, **{'y': 2}}\"\n        node = extract_node(code)\n        self.assertEqual(node.as_string(), code)\n        assert isinstance(node, nodes.Dict)\n        keys = [key for (key, _) in node.items]\n        self.assertIsInstance(keys[0], nodes.Const)\n        self.assertIsInstance(keys[1], nodes.DictUnpack)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_unpacking_in_dicts", "self", "none", "code", "x", "1", "y", "2", "node", "extract_node", "code", "self", "assertequal", "node", "as_string", "code", "assert", "isinstance", "node", "nodes", "dict", "keys", "key", "for", "key", "_", "in", "node", "items", "self", "assertisinstance", "keys", "0", "nodes", "const", "self", "assertisinstance", "keys", "1", "nodes", "dictunpack"], "doc_len": 46}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_nested_unpacking_in_dicts", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_nested_unpacking_in_dicts", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_nested_unpacking_in_dicts(self) -> None:\n        code = \"{'x': 1, **{'y': 2, **{'z': 3}}}\"\n        node = extract_node(code)\n        self.assertEqual(node.as_string(), code)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_nested_unpacking_in_dicts", "self", "none", "code", "x", "1", "y", "2", "z", "3", "node", "extract_node", "code", "self", "assertequal", "node", "as_string", "code"], "doc_len": 23}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_unpacking_in_dict_getitem", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_unpacking_in_dict_getitem", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_unpacking_in_dict_getitem(self) -> None:\n        node = extract_node(\"{1:2, **{2:3, 3:4}, **{5: 6}}\")\n        for key, expected in ((1, 2), (2, 3), (3, 4), (5, 6)):\n            value = node.getitem(nodes.Const(key))\n            self.assertIsInstance(value, nodes.Const)\n            self.assertEqual(value.value, expected)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_unpacking_in_dict_getitem", "self", "none", "node", "extract_node", "1", "2", "2", "3", "3", "4", "5", "6", "for", "key", "expected", "in", "1", "2", "2", "3", "3", "4", "5", "6", "value", "node", "getitem", "nodes", "const", "key", "self", "assertisinstance", "value", "nodes", "const", "self", "assertequal", "value", "value", "expected"], "doc_len": 46}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_format_string", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_format_string", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_format_string(self) -> None:\n        code = \"f'{greetings} {person}'\"\n        node = extract_node(code)\n        self.assertEqual(node.as_string(), code)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_format_string", "self", "none", "code", "f", "greetings", "person", "node", "extract_node", "code", "self", "assertequal", "node", "as_string", "code"], "doc_len": 20}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_underscores_in_numeral_literal", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_underscores_in_numeral_literal", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_underscores_in_numeral_literal(self) -> None:\n        pairs = [(\"10_1000\", 101000), (\"10_000_000\", 10000000), (\"0x_FF_FF\", 65535)]\n        for value, expected in pairs:\n            node = extract_node(value)\n            inferred = next(node.infer())\n            self.assertIsInstance(inferred, nodes.Const)\n            self.assertEqual(inferred.value, expected)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_underscores_in_numeral_literal", "self", "none", "pairs", "10_1000", "101000", "10_000_000", "10000000", "0x_ff_ff", "65535", "for", "value", "expected", "in", "pairs", "node", "extract_node", "value", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "expected"], "doc_len": 37}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_async_comprehensions", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_async_comprehensions", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_async_comprehensions(self) -> None:\n        async_comprehensions = [\n            extract_node(\n                \"async def f(): return __([i async for i in aiter() if i % 2])\"\n            ),\n            extract_node(\n                \"async def f(): return __({i async for i in aiter() if i % 2})\"\n            ),\n            extract_node(\n                \"async def f(): return __((i async for i in aiter() if i % 2))\"\n            ),\n            extract_node(\n                \"async def f(): return __({i: i async for i in aiter() if i % 2})\"\n            ),\n        ]\n        non_async_comprehensions = [\n            extract_node(\"async def f(): return __({i: i for i in iter() if i % 2})\")\n        ]\n\n        for comp in async_comprehensions:\n            self.assertTrue(comp.generators[0].is_async)\n        for comp in non_async_comprehensions:\n            self.assertFalse(comp.generators[0].is_async)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_async_comprehensions", "self", "none", "async_comprehensions", "extract_node", "async", "def", "f", "return", "__", "i", "async", "for", "i", "in", "aiter", "if", "i", "2", "extract_node", "async", "def", "f", "return", "__", "i", "async", "for", "i", "in", "aiter", "if", "i", "2", "extract_node", "async", "def", "f", "return", "__", "i", "async", "for", "i", "in", "aiter", "if", "i", "2", "extract_node", "async", "def", "f", "return", "__", "i", "i", "async", "for", "i", "in", "aiter", "if", "i", "2", "non_async_comprehensions", "extract_node", "async", "def", "f", "return", "__", "i", "i", "for", "i", "in", "iter", "if", "i", "2", "for", "comp", "in", "async_comprehensions", "self", "asserttrue", "comp", "generators", "0", "is_async", "for", "comp", "in", "non_async_comprehensions", "self", "assertfalse", "comp", "generators", "0", "is_async"], "doc_len": 106}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_async_comprehensions_outside_coroutine", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_async_comprehensions_outside_coroutine", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_async_comprehensions_outside_coroutine(self):\n        # When async and await will become keywords, async comprehensions\n        # will be allowed outside of coroutines body\n        comprehensions = [\n            \"[i async for i in aiter() if condition(i)]\",\n            \"[await fun() async for fun in funcs]\",\n            \"{await fun() async for fun in funcs}\",\n            \"{fun: await fun() async for fun in funcs}\",\n            \"[await fun() async for fun in funcs if await smth]\",\n            \"{await fun() async for fun in funcs if await smth}\",\n            \"{fun: await fun() async for fun in funcs if await smth}\",\n            \"[await fun() async for fun in funcs]\",\n            \"{await fun() async for fun in funcs}\",\n            \"{fun: await fun() async for fun in funcs}\",\n            \"[await fun() async for fun in funcs if await smth]\",\n            \"{await fun() async for fun in funcs if await smth}\",\n            \"{fun: await fun() async for fun in funcs if await smth}\",\n        ]\n\n        for comp in comprehensions:\n            node = extract_node(comp)\n            self.assertTrue(node.generators[0].is_async)\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_async_comprehensions_outside_coroutine", "self", "when", "async", "and", "await", "will", "become", "keywords", "async", "comprehensions", "will", "be", "allowed", "outside", "of", "coroutines", "body", "comprehensions", "i", "async", "for", "i", "in", "aiter", "if", "condition", "i", "await", "fun", "async", "for", "fun", "in", "funcs", "await", "fun", "async", "for", "fun", "in", "funcs", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "await", "fun", "async", "for", "fun", "in", "funcs", "await", "fun", "async", "for", "fun", "in", "funcs", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "for", "comp", "in", "comprehensions", "node", "extract_node", "comp", "self", "asserttrue", "node", "generators", "0", "is_async"], "doc_len": 152}
{"doc_id": "tests/unittest_python3.py::Python3TC.test_async_comprehensions_as_string", "file_path": "tests/unittest_python3.py", "class_name": "Python3TC", "func_name": "test_async_comprehensions_as_string", "text": "文件路径: tests/unittest_python3.py, 类名: Python3TC\n    def test_async_comprehensions_as_string(self) -> None:\n        func_bodies = [\n            \"return [i async for i in aiter() if condition(i)]\",\n            \"return [await fun() for fun in funcs]\",\n            \"return {await fun() for fun in funcs}\",\n            \"return {fun: await fun() for fun in funcs}\",\n            \"return [await fun() for fun in funcs if await smth]\",\n            \"return {await fun() for fun in funcs if await smth}\",\n            \"return {fun: await fun() for fun in funcs if await smth}\",\n            \"return [await fun() async for fun in funcs]\",\n            \"return {await fun() async for fun in funcs}\",\n            \"return {fun: await fun() async for fun in funcs}\",\n            \"return [await fun() async for fun in funcs if await smth]\",\n            \"return {await fun() async for fun in funcs if await smth}\",\n            \"return {fun: await fun() async for fun in funcs if await smth}\",\n        ]\n        for func_body in func_bodies:\n            code = dedent(\n                f\"\"\"\n            async def f():\n                {func_body}\"\"\"\n            )\n            func = extract_node(code)\n            self.assertEqual(func.as_string().strip(), code.strip())\n", "tokens": ["tests", "unittest_python3", "py", "python3tc", "def", "test_async_comprehensions_as_string", "self", "none", "func_bodies", "return", "i", "async", "for", "i", "in", "aiter", "if", "condition", "i", "return", "await", "fun", "for", "fun", "in", "funcs", "return", "await", "fun", "for", "fun", "in", "funcs", "return", "fun", "await", "fun", "for", "fun", "in", "funcs", "return", "await", "fun", "for", "fun", "in", "funcs", "if", "await", "smth", "return", "await", "fun", "for", "fun", "in", "funcs", "if", "await", "smth", "return", "fun", "await", "fun", "for", "fun", "in", "funcs", "if", "await", "smth", "return", "await", "fun", "async", "for", "fun", "in", "funcs", "return", "await", "fun", "async", "for", "fun", "in", "funcs", "return", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "return", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "return", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "return", "fun", "await", "fun", "async", "for", "fun", "in", "funcs", "if", "await", "smth", "for", "func_body", "in", "func_bodies", "code", "dedent", "f", "async", "def", "f", "func_body", "func", "extract_node", "code", "self", "assertequal", "func", "as_string", "strip", "code", "strip"], "doc_len": 152}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_attach_dummy_node", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_attach_dummy_node", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_attach_dummy_node(self) -> None:\n        node = build_module(\"MyModule\")\n        attach_dummy_node(node, \"DummyNode\")\n        self.assertEqual(1, len(list(node.get_children())))\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_attach_dummy_node", "self", "none", "node", "build_module", "mymodule", "attach_dummy_node", "node", "dummynode", "self", "assertequal", "1", "len", "list", "node", "get_children"], "doc_len": 21}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_module", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_module", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_module(self) -> None:\n        node = build_module(\"MyModule\")\n        self.assertEqual(node.name, \"MyModule\")\n        self.assertEqual(node.pure_python, False)\n        self.assertEqual(node.package, False)\n        self.assertEqual(node.parent, None)\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_module", "self", "none", "node", "build_module", "mymodule", "self", "assertequal", "node", "name", "mymodule", "self", "assertequal", "node", "pure_python", "false", "self", "assertequal", "node", "package", "false", "self", "assertequal", "node", "parent", "none"], "doc_len": 31}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_class", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_class", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_class(self) -> None:\n        node = build_class(\"MyClass\")\n        self.assertEqual(node.name, \"MyClass\")\n        self.assertEqual(node.doc, None)\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_class", "self", "none", "node", "build_class", "myclass", "self", "assertequal", "node", "name", "myclass", "self", "assertequal", "node", "doc", "none"], "doc_len": 21}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_function", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_function", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_function(self) -> None:\n        node = build_function(\"MyFunction\")\n        self.assertEqual(node.name, \"MyFunction\")\n        self.assertEqual(node.doc, None)\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_function", "self", "none", "node", "build_function", "myfunction", "self", "assertequal", "node", "name", "myfunction", "self", "assertequal", "node", "doc", "none"], "doc_len": 21}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_function_args", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_function_args", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_function_args(self) -> None:\n        args = [\"myArgs1\", \"myArgs2\"]\n        node = build_function(\"MyFunction\", args)\n        self.assertEqual(\"myArgs1\", node.args.args[0].name)\n        self.assertEqual(\"myArgs2\", node.args.args[1].name)\n        self.assertEqual(2, len(node.args.args))\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_function_args", "self", "none", "args", "myargs1", "myargs2", "node", "build_function", "myfunction", "args", "self", "assertequal", "myargs1", "node", "args", "args", "0", "name", "self", "assertequal", "myargs2", "node", "args", "args", "1", "name", "self", "assertequal", "2", "len", "node", "args", "args"], "doc_len": 38}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_function_defaults", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_function_defaults", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_function_defaults(self) -> None:\n        defaults = [\"defaults1\", \"defaults2\"]\n        node = build_function(name=\"MyFunction\", args=None, defaults=defaults)\n        self.assertEqual(2, len(node.args.defaults))\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_function_defaults", "self", "none", "defaults", "defaults1", "defaults2", "node", "build_function", "name", "myfunction", "args", "none", "defaults", "defaults", "self", "assertequal", "2", "len", "node", "args", "defaults"], "doc_len": 26}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_function_posonlyargs", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_function_posonlyargs", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_function_posonlyargs(self) -> None:\n        node = build_function(name=\"MyFunction\", posonlyargs=[\"a\", \"b\"])\n        self.assertEqual(2, len(node.args.posonlyargs))\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_function_posonlyargs", "self", "none", "node", "build_function", "name", "myfunction", "posonlyargs", "a", "b", "self", "assertequal", "2", "len", "node", "args", "posonlyargs"], "doc_len": 22}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_function_kwonlyargs", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_function_kwonlyargs", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_function_kwonlyargs(self) -> None:\n        node = build_function(name=\"MyFunction\", kwonlyargs=[\"a\", \"b\"])\n        assert len(node.args.kwonlyargs) == 2\n        assert node.args.kwonlyargs[0].name == \"a\"\n        assert node.args.kwonlyargs[1].name == \"b\"\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_function_kwonlyargs", "self", "none", "node", "build_function", "name", "myfunction", "kwonlyargs", "a", "b", "assert", "len", "node", "args", "kwonlyargs", "2", "assert", "node", "args", "kwonlyargs", "0", "name", "a", "assert", "node", "args", "kwonlyargs", "1", "name", "b"], "doc_len": 35}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_build_from_import", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_build_from_import", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_build_from_import(self) -> None:\n        names = [\"exceptions, inference, inspector\"]\n        node = build_from_import(\"astroid\", names)\n        self.assertEqual(len(names), len(node.names))\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_build_from_import", "self", "none", "names", "exceptions", "inference", "inspector", "node", "build_from_import", "astroid", "names", "self", "assertequal", "len", "names", "len", "node", "names"], "doc_len": 23}
{"doc_id": "tests/unittest_raw_building.py::RawBuildingTC.test_io_is__io", "file_path": "tests/unittest_raw_building.py", "class_name": "RawBuildingTC", "func_name": "test_io_is__io", "text": "文件路径: tests/unittest_raw_building.py, 类名: RawBuildingTC\n    def test_io_is__io(self):\n        # _io module calls itself io. This leads\n        # to cyclic dependencies when astroid tries to resolve\n        # what io.BufferedReader is. The code that handles this\n        # is in astroid.raw_building.imported_member, which verifies\n        # the true name of the module.\n        builder = AstroidBuilder()\n        module = builder.inspect_build(_io)\n        buffered_reader = module.getattr(\"BufferedReader\")[0]\n        self.assertEqual(buffered_reader.root().name, \"io\")\n", "tokens": ["tests", "unittest_raw_building", "py", "rawbuildingtc", "def", "test_io_is__io", "self", "_io", "module", "calls", "itself", "io", "this", "leads", "to", "cyclic", "dependencies", "when", "astroid", "tries", "to", "resolve", "what", "io", "bufferedreader", "is", "the", "code", "that", "handles", "this", "is", "in", "astroid", "raw_building", "imported_member", "which", "verifies", "the", "true", "name", "of", "the", "module", "builder", "astroidbuilder", "module", "builder", "inspect_build", "_io", "buffered_reader", "module", "getattr", "bufferedreader", "0", "self", "assertequal", "buffered_reader", "root", "name", "io"], "doc_len": 61}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.setUp", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "setUp", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def setUp(self) -> None:\n        sys.path.insert(0, resources.find(\"data\"))\n        MANAGER.always_load_extensions = True\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "setup", "self", "none", "sys", "path", "insert", "0", "resources", "find", "data", "manager", "always_load_extensions", "true"], "doc_len": 18}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.tearDown", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "tearDown", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def tearDown(self) -> None:\n        MANAGER.always_load_extensions = False\n        sys.path.pop(0)\n        sys.path_importer_cache.pop(resources.find(\"data\"), None)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "teardown", "self", "none", "manager", "always_load_extensions", "false", "sys", "path", "pop", "0", "sys", "path_importer_cache", "pop", "resources", "find", "data", "none"], "doc_len": 22}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_module_path", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_module_path", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_module_path(self) -> None:\n        man = test_utils.brainless_manager()\n        mod = man.ast_from_module_name(\"package.import_package_subpackage_module\")\n        package = next(mod.igetattr(\"package\"))\n        self.assertEqual(package.name, \"package\")\n        subpackage = next(package.igetattr(\"subpackage\"))\n        self.assertIsInstance(subpackage, nodes.Module)\n        self.assertTrue(subpackage.package)\n        self.assertEqual(subpackage.name, \"package.subpackage\")\n        module = next(subpackage.igetattr(\"module\"))\n        self.assertEqual(module.name, \"package.subpackage.module\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_module_path", "self", "none", "man", "test_utils", "brainless_manager", "mod", "man", "ast_from_module_name", "package", "import_package_subpackage_module", "package", "next", "mod", "igetattr", "package", "self", "assertequal", "package", "name", "package", "subpackage", "next", "package", "igetattr", "subpackage", "self", "assertisinstance", "subpackage", "nodes", "module", "self", "asserttrue", "subpackage", "package", "self", "assertequal", "subpackage", "name", "package", "subpackage", "module", "next", "subpackage", "igetattr", "module", "self", "assertequal", "module", "name", "package", "subpackage", "module"], "doc_len": 58}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_package_sidepackage", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_package_sidepackage", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_package_sidepackage(self) -> None:\n        manager = test_utils.brainless_manager()\n        assert \"package.sidepackage\" not in MANAGER.astroid_cache\n        package = manager.ast_from_module_name(\"absimp\")\n        self.assertIsInstance(package, nodes.Module)\n        self.assertTrue(package.package)\n        subpackage = next(package.getattr(\"sidepackage\")[0].infer())\n        self.assertIsInstance(subpackage, nodes.Module)\n        self.assertTrue(subpackage.package)\n        self.assertEqual(subpackage.name, \"absimp.sidepackage\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_package_sidepackage", "self", "none", "manager", "test_utils", "brainless_manager", "assert", "package", "sidepackage", "not", "in", "manager", "astroid_cache", "package", "manager", "ast_from_module_name", "absimp", "self", "assertisinstance", "package", "nodes", "module", "self", "asserttrue", "package", "package", "subpackage", "next", "package", "getattr", "sidepackage", "0", "infer", "self", "assertisinstance", "subpackage", "nodes", "module", "self", "asserttrue", "subpackage", "package", "self", "assertequal", "subpackage", "name", "absimp", "sidepackage"], "doc_len": 53}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_living_property", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_living_property", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_living_property(self) -> None:\n        builder = AstroidBuilder()\n        builder._done = {}\n        builder._module = sys.modules[__name__]\n        builder.object_build(build_module(\"module_name\", \"\"), Whatever)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_living_property", "self", "none", "builder", "astroidbuilder", "builder", "_done", "builder", "_module", "sys", "modules", "__name__", "builder", "object_build", "build_module", "module_name", "whatever"], "doc_len": 22}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_numpy_crash", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_numpy_crash", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_numpy_crash(self):\n        \"\"\"test don't crash on numpy\"\"\"\n        # a crash occurred somewhere in the past, and an\n        # InferenceError instead of a crash was better, but now we even infer!\n        builder = AstroidBuilder()\n        data = \"\"\"\nfrom numpy import multiply\n\nmultiply([1, 2], [3, 4])\n\"\"\"\n        astroid = builder.string_build(data, __name__, __file__)\n        callfunc = astroid.body[1].value.func\n        inferred = callfunc.inferred()\n        self.assertEqual(len(inferred), 1)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_numpy_crash", "self", "test", "don", "t", "crash", "on", "numpy", "a", "crash", "occurred", "somewhere", "in", "the", "past", "and", "an", "inferenceerror", "instead", "of", "a", "crash", "was", "better", "but", "now", "we", "even", "infer", "builder", "astroidbuilder", "data", "from", "numpy", "import", "multiply", "multiply", "1", "2", "3", "4", "astroid", "builder", "string_build", "data", "__name__", "__file__", "callfunc", "astroid", "body", "1", "value", "func", "inferred", "callfunc", "inferred", "self", "assertequal", "len", "inferred", "1"], "doc_len": 66}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_nameconstant", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_nameconstant", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_nameconstant(self) -> None:\n        # used to fail for Python 3.4\n        builder = AstroidBuilder()\n        astroid = builder.string_build(\"def test(x=True): pass\")\n        default = astroid.body[0].args.args[0]\n        self.assertEqual(default.name, \"x\")\n        self.assertEqual(next(default.infer()).value, True)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_nameconstant", "self", "none", "used", "to", "fail", "for", "python", "3", "4", "builder", "astroidbuilder", "astroid", "builder", "string_build", "def", "test", "x", "true", "pass", "default", "astroid", "body", "0", "args", "args", "0", "self", "assertequal", "default", "name", "x", "self", "assertequal", "next", "default", "infer", "value", "true"], "doc_len": 44}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_recursion_regression_issue25", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_recursion_regression_issue25", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_recursion_regression_issue25(self) -> None:\n        builder = AstroidBuilder()\n        data = \"\"\"\nimport recursion as base\n\n_real_Base = base.Base\n\nclass Derived(_real_Base):\n    pass\n\ndef run():\n    base.Base = Derived\n\"\"\"\n        astroid = builder.string_build(data, __name__, __file__)\n        # Used to crash in _is_metaclass, due to wrong\n        # ancestors chain\n        classes = astroid.nodes_of_class(nodes.ClassDef)\n        for klass in classes:\n            # triggers the _is_metaclass call\n            klass.type  # pylint: disable=pointless-statement\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_recursion_regression_issue25", "self", "none", "builder", "astroidbuilder", "data", "import", "recursion", "as", "base", "_real_base", "base", "base", "class", "derived", "_real_base", "pass", "def", "run", "base", "base", "derived", "astroid", "builder", "string_build", "data", "__name__", "__file__", "used", "to", "crash", "in", "_is_metaclass", "due", "to", "wrong", "ancestors", "chain", "classes", "astroid", "nodes_of_class", "nodes", "classdef", "for", "klass", "in", "classes", "triggers", "the", "_is_metaclass", "call", "klass", "type", "pylint", "disable", "pointless", "statement"], "doc_len": 62}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_decorator_callchain_issue42", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_decorator_callchain_issue42", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_decorator_callchain_issue42(self) -> None:\n        builder = AstroidBuilder()\n        data = \"\"\"\n\ndef test():\n    def factory(func):\n        def newfunc():\n            func()\n        return newfunc\n    return factory\n\n@test()\ndef crash():\n    pass\n\"\"\"\n        astroid = builder.string_build(data, __name__, __file__)\n        self.assertEqual(astroid[\"crash\"].type, \"function\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_decorator_callchain_issue42", "self", "none", "builder", "astroidbuilder", "data", "def", "test", "def", "factory", "func", "def", "newfunc", "func", "return", "newfunc", "return", "factory", "test", "def", "crash", "pass", "astroid", "builder", "string_build", "data", "__name__", "__file__", "self", "assertequal", "astroid", "crash", "type", "function"], "doc_len": 39}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_filter_stmts_scoping", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_filter_stmts_scoping", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_filter_stmts_scoping(self) -> None:\n        builder = AstroidBuilder()\n        data = \"\"\"\ndef test():\n    compiler = int()\n    class B(compiler.__class__):\n        pass\n    compiler = B()\n    return compiler\n\"\"\"\n        astroid = builder.string_build(data, __name__, __file__)\n        test = astroid[\"test\"]\n        result = next(test.infer_call_result(astroid))\n        self.assertIsInstance(result, Instance)\n        base = next(result._proxied.bases[0].infer())\n        self.assertEqual(base.name, \"int\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_filter_stmts_scoping", "self", "none", "builder", "astroidbuilder", "data", "def", "test", "compiler", "int", "class", "b", "compiler", "__class__", "pass", "compiler", "b", "return", "compiler", "astroid", "builder", "string_build", "data", "__name__", "__file__", "test", "astroid", "test", "result", "next", "test", "infer_call_result", "astroid", "self", "assertisinstance", "result", "instance", "base", "next", "result", "_proxied", "bases", "0", "infer", "self", "assertequal", "base", "name", "int"], "doc_len": 54}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_filter_stmts_nested_if", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_filter_stmts_nested_if", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_filter_stmts_nested_if(self) -> None:\n        builder = AstroidBuilder()\n        data = \"\"\"\ndef test(val):\n    variable = None\n\n    if val == 1:\n        variable = \"value\"\n        if variable := \"value\":\n            pass\n\n    elif val == 2:\n        variable = \"value_two\"\n        variable = \"value_two\"\n\n    return variable\n\"\"\"\n        module = builder.string_build(data, __name__, __file__)\n        test_func = module[\"test\"]\n        result = list(test_func.infer_call_result(module))\n        assert len(result) == 3\n        assert isinstance(result[0], nodes.Const)\n        assert result[0].value is None\n        assert result[0].lineno == 3\n        assert isinstance(result[1], nodes.Const)\n        assert result[1].value == \"value\"\n        assert result[1].lineno == 7\n        assert isinstance(result[1], nodes.Const)\n        assert result[2].value == \"value_two\"\n        assert result[2].lineno == 12\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_filter_stmts_nested_if", "self", "none", "builder", "astroidbuilder", "data", "def", "test", "val", "variable", "none", "if", "val", "1", "variable", "value", "if", "variable", "value", "pass", "elif", "val", "2", "variable", "value_two", "variable", "value_two", "return", "variable", "module", "builder", "string_build", "data", "__name__", "__file__", "test_func", "module", "test", "result", "list", "test_func", "infer_call_result", "module", "assert", "len", "result", "3", "assert", "isinstance", "result", "0", "nodes", "const", "assert", "result", "0", "value", "is", "none", "assert", "result", "0", "lineno", "3", "assert", "isinstance", "result", "1", "nodes", "const", "assert", "result", "1", "value", "value", "assert", "result", "1", "lineno", "7", "assert", "isinstance", "result", "1", "nodes", "const", "assert", "result", "2", "value", "value_two", "assert", "result", "2", "lineno", "12"], "doc_len": 101}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_ancestors_patching_class_recursion", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_ancestors_patching_class_recursion", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_ancestors_patching_class_recursion(self) -> None:\n        node = AstroidBuilder().string_build(\n            textwrap.dedent(\n                \"\"\"\n        import string\n        Template = string.Template\n\n        class A(Template):\n            pass\n\n        class B(A):\n            pass\n\n        def test(x=False):\n            if x:\n                string.Template = A\n            else:\n                string.Template = B\n        \"\"\"\n            )\n        )\n        klass = node[\"A\"]\n        ancestors = list(klass.ancestors())\n        self.assertEqual(ancestors[0].qname(), \"string.Template\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_ancestors_patching_class_recursion", "self", "none", "node", "astroidbuilder", "string_build", "textwrap", "dedent", "import", "string", "template", "string", "template", "class", "a", "template", "pass", "class", "b", "a", "pass", "def", "test", "x", "false", "if", "x", "string", "template", "a", "else", "string", "template", "b", "klass", "node", "a", "ancestors", "list", "klass", "ancestors", "self", "assertequal", "ancestors", "0", "qname", "string", "template"], "doc_len": 53}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_ancestors_yes_in_bases", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_ancestors_yes_in_bases", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_ancestors_yes_in_bases(self) -> None:\n        # Test for issue https://bitbucket.org/logilab/astroid/issue/84\n        # This used to crash astroid with a TypeError, because an Uninferable\n        # node was present in the bases\n        node = extract_node(\n            \"\"\"\n        def with_metaclass(meta, *bases):\n            class metaclass(meta):\n                def __new__(cls, name, this_bases, d):\n                    return meta(name, bases, d)\n        return type.__new__(metaclass, 'temporary_class', (), {})\n\n        import lala\n\n        class A(with_metaclass(object, lala.lala)): #@\n            pass\n        \"\"\"\n        )\n        ancestors = list(node.ancestors())\n        self.assertEqual(len(ancestors), 1)\n        self.assertEqual(ancestors[0].qname(), \"builtins.object\")\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_ancestors_yes_in_bases", "self", "none", "test", "for", "issue", "https", "bitbucket", "org", "logilab", "astroid", "issue", "84", "this", "used", "to", "crash", "astroid", "with", "a", "typeerror", "because", "an", "uninferable", "node", "was", "present", "in", "the", "bases", "node", "extract_node", "def", "with_metaclass", "meta", "bases", "class", "metaclass", "meta", "def", "__new__", "cls", "name", "this_bases", "d", "return", "meta", "name", "bases", "d", "return", "type", "__new__", "metaclass", "temporary_class", "import", "lala", "class", "a", "with_metaclass", "object", "lala", "lala", "pass", "ancestors", "list", "node", "ancestors", "self", "assertequal", "len", "ancestors", "1", "self", "assertequal", "ancestors", "0", "qname", "builtins", "object"], "doc_len": 85}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_ancestors_missing_from_function", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_ancestors_missing_from_function", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_ancestors_missing_from_function(self) -> None:\n        # Test for https://www.logilab.org/ticket/122793\n        node = extract_node(\n            \"\"\"\n        def gen(): yield\n        GEN = gen()\n        next(GEN)\n        \"\"\"\n        )\n        self.assertRaises(InferenceError, next, node.infer())\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_ancestors_missing_from_function", "self", "none", "test", "for", "https", "www", "logilab", "org", "ticket", "122793", "node", "extract_node", "def", "gen", "yield", "gen", "gen", "next", "gen", "self", "assertraises", "inferenceerror", "next", "node", "infer"], "doc_len": 31}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_unicode_in_docstring", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_unicode_in_docstring", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_unicode_in_docstring(self) -> None:\n        # Crashed for astroid==1.4.1\n        # Test for https://bitbucket.org/logilab/astroid/issues/273/\n\n        # In a regular file, \"coding: utf-8\" would have been used.\n        node = extract_node(\n            f\"\"\"\n        from __future__ import unicode_literals\n\n        class MyClass(object):\n            def method(self):\n                \"With unicode : {'’'} \"\n\n        instance = MyClass()\n        \"\"\"\n        )\n\n        next(node.value.infer()).as_string()\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_unicode_in_docstring", "self", "none", "crashed", "for", "astroid", "1", "4", "1", "test", "for", "https", "bitbucket", "org", "logilab", "astroid", "issues", "273", "in", "a", "regular", "file", "coding", "utf", "8", "would", "have", "been", "used", "node", "extract_node", "f", "from", "__future__", "import", "unicode_literals", "class", "myclass", "object", "def", "method", "self", "with", "unicode", "instance", "myclass", "next", "node", "value", "infer", "as_string"], "doc_len": 56}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_binop_generates_nodes_with_parents", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_binop_generates_nodes_with_parents", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_binop_generates_nodes_with_parents(self) -> None:\n        node = extract_node(\n            \"\"\"\n        def no_op(*args):\n            pass\n        def foo(*args):\n            def inner(*more_args):\n                args + more_args #@\n            return inner\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Tuple)\n        self.assertIsNotNone(inferred.parent)\n        self.assertIsInstance(inferred.parent, nodes.BinOp)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_binop_generates_nodes_with_parents", "self", "none", "node", "extract_node", "def", "no_op", "args", "pass", "def", "foo", "args", "def", "inner", "more_args", "args", "more_args", "return", "inner", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "tuple", "self", "assertisnotnone", "inferred", "parent", "self", "assertisinstance", "inferred", "parent", "nodes", "binop"], "doc_len": 43}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_decorator_names_inference_error_leaking", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_decorator_names_inference_error_leaking", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_decorator_names_inference_error_leaking(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class Parent(object):\n            @property\n            def foo(self):\n                pass\n\n        class Child(Parent):\n            @Parent.foo.getter\n            def foo(self): #@\n                return super(Child, self).foo + ['oink']\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertEqual(inferred.decoratornames(), {\".Parent.foo.getter\"})\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_decorator_names_inference_error_leaking", "self", "none", "node", "extract_node", "class", "parent", "object", "property", "def", "foo", "self", "pass", "class", "child", "parent", "parent", "foo", "getter", "def", "foo", "self", "return", "super", "child", "self", "foo", "oink", "inferred", "next", "node", "infer", "self", "assertequal", "inferred", "decoratornames", "parent", "foo", "getter"], "doc_len": 44}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_ssl_protocol", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_ssl_protocol", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_ssl_protocol(self) -> None:\n        node = extract_node(\n            \"\"\"\n        import ssl\n        ssl.PROTOCOL_TLSv1\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_ssl_protocol", "self", "none", "node", "extract_node", "import", "ssl", "ssl", "protocol_tlsv1", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "const"], "doc_len": 23}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_recursive_property_method", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_recursive_property_method", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_recursive_property_method(self) -> None:\n        node = extract_node(\n            \"\"\"\n        class APropert():\n            @property\n            def property(self):\n                return self\n        APropert().property\n        \"\"\"\n        )\n        next(node.infer())\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_recursive_property_method", "self", "none", "node", "extract_node", "class", "apropert", "property", "def", "property", "self", "return", "self", "apropert", "property", "next", "node", "infer"], "doc_len": 23}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_uninferable_string_argument_of_namedtuple", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_uninferable_string_argument_of_namedtuple", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_uninferable_string_argument_of_namedtuple(self) -> None:\n        node = extract_node(\n            \"\"\"\n        import collections\n        collections.namedtuple('{}'.format(\"a\"), '')()\n        \"\"\"\n        )\n        next(node.infer())\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_uninferable_string_argument_of_namedtuple", "self", "none", "node", "extract_node", "import", "collections", "collections", "namedtuple", "format", "a", "next", "node", "infer"], "doc_len": 19}
{"doc_id": "tests/unittest_regrtest.py::NonRegressionTests.test_regression_inference_of_self_in_lambda", "file_path": "tests/unittest_regrtest.py", "class_name": "NonRegressionTests", "func_name": "test_regression_inference_of_self_in_lambda", "text": "文件路径: tests/unittest_regrtest.py, 类名: NonRegressionTests\n    def test_regression_inference_of_self_in_lambda(self) -> None:\n        code = \"\"\"\n        class A:\n            @b(lambda self: __(self))\n            def d(self):\n                pass\n        \"\"\"\n        node = extract_node(code)\n        inferred = next(node.infer())\n        assert isinstance(inferred, Instance)\n        assert inferred.qname() == \".A\"\n", "tokens": ["tests", "unittest_regrtest", "py", "nonregressiontests", "def", "test_regression_inference_of_self_in_lambda", "self", "none", "code", "class", "a", "b", "lambda", "self", "__", "self", "def", "d", "self", "pass", "node", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance", "assert", "inferred", "qname", "a"], "doc_len": 35}
{"doc_id": "tests/unittest_regrtest.py::test_ancestor_looking_up_redefined_function", "file_path": "tests/unittest_regrtest.py", "class_name": null, "func_name": "test_ancestor_looking_up_redefined_function", "text": "文件路径: tests/unittest_regrtest.py\ndef test_ancestor_looking_up_redefined_function() -> None:\n    code = \"\"\"\n    class Foo:\n        def _format(self):\n            pass\n\n        def format(self):\n            self.format = self._format\n            self.format()\n    Foo\n    \"\"\"\n    node = extract_node(code)\n    inferred = next(node.infer())\n    ancestor = next(inferred.ancestors())\n    _, found = ancestor.lookup(\"format\")\n    assert len(found) == 1\n    assert isinstance(found[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_regrtest", "py", "def", "test_ancestor_looking_up_redefined_function", "none", "code", "class", "foo", "def", "_format", "self", "pass", "def", "format", "self", "self", "format", "self", "_format", "self", "format", "foo", "node", "extract_node", "code", "inferred", "next", "node", "infer", "ancestor", "next", "inferred", "ancestors", "_", "found", "ancestor", "lookup", "format", "assert", "len", "found", "1", "assert", "isinstance", "found", "0", "nodes", "functiondef"], "doc_len": 49}
{"doc_id": "tests/unittest_regrtest.py::test_crash_in_dunder_inference_prevented", "file_path": "tests/unittest_regrtest.py", "class_name": null, "func_name": "test_crash_in_dunder_inference_prevented", "text": "文件路径: tests/unittest_regrtest.py\ndef test_crash_in_dunder_inference_prevented() -> None:\n    code = \"\"\"\n    class MyClass():\n        def fu(self, objects):\n            delitem = dict.__delitem__.__get__(self, dict)\n            delitem #@\n    \"\"\"\n    inferred = next(extract_node(code).infer())\n    assert inferred.qname() == \"builtins.dict.__delitem__\"\n", "tokens": ["tests", "unittest_regrtest", "py", "def", "test_crash_in_dunder_inference_prevented", "none", "code", "class", "myclass", "def", "fu", "self", "objects", "delitem", "dict", "__delitem__", "__get__", "self", "dict", "delitem", "inferred", "next", "extract_node", "code", "infer", "assert", "inferred", "qname", "builtins", "dict", "__delitem__"], "doc_len": 31}
{"doc_id": "tests/unittest_regrtest.py::test_regression_crash_classmethod", "file_path": "tests/unittest_regrtest.py", "class_name": null, "func_name": "test_regression_crash_classmethod", "text": "文件路径: tests/unittest_regrtest.py\ndef test_regression_crash_classmethod() -> None:\n    \"\"\"Regression test for a crash reported in https://github.com/PyCQA/pylint/issues/4982\"\"\"\n    code = \"\"\"\n    class Base:\n        @classmethod\n        def get_first_subclass(cls):\n            for subclass in cls.__subclasses__():\n                return subclass\n            return object\n\n\n    subclass = Base.get_first_subclass()\n\n\n    class Another(subclass):\n        pass\n    \"\"\"\n    parse(code)\n", "tokens": ["tests", "unittest_regrtest", "py", "def", "test_regression_crash_classmethod", "none", "regression", "test", "for", "a", "crash", "reported", "in", "https", "github", "com", "pycqa", "pylint", "issues", "4982", "code", "class", "base", "classmethod", "def", "get_first_subclass", "cls", "for", "subclass", "in", "cls", "__subclasses__", "return", "subclass", "return", "object", "subclass", "base", "get_first_subclass", "class", "another", "subclass", "pass", "parse", "code"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::_test_dict_interface", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "_test_dict_interface", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef _test_dict_interface(\n    self: Any,\n    node: Union[nodes.ClassDef, nodes.FunctionDef, nodes.Module],\n    test_attr: str,\n) -> None:\n    self.assertIs(node[test_attr], node[test_attr])\n    self.assertIn(test_attr, node)\n    node.keys()\n    node.values()\n    node.items()\n    iter(node)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "_test_dict_interface", "self", "any", "node", "union", "nodes", "classdef", "nodes", "functiondef", "nodes", "module", "test_attr", "str", "none", "self", "assertis", "node", "test_attr", "node", "test_attr", "self", "assertin", "test_attr", "node", "node", "keys", "node", "values", "node", "items", "iter", "node"], "doc_len": 36}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleLoader.setUp", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleLoader", "func_name": "setUp", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleLoader\n    def setUp(self) -> None:\n        super().setUp()\n        self.module = resources.build_file(\"data/module.py\", \"data.module\")\n        self.module2 = resources.build_file(\"data/module2.py\", \"data.module2\")\n        self.nonregr = resources.build_file(\"data/nonregr.py\", \"data.nonregr\")\n        self.pack = resources.build_file(\"data/__init__.py\", \"data\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "moduleloader", "def", "setup", "self", "none", "super", "setup", "self", "module", "resources", "build_file", "data", "module", "py", "data", "module", "self", "module2", "resources", "build_file", "data", "module2", "py", "data", "module2", "self", "nonregr", "resources", "build_file", "data", "nonregr", "py", "data", "nonregr", "self", "pack", "resources", "build_file", "data", "__init__", "py", "data"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_special_attributes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_special_attributes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_special_attributes(self) -> None:\n        self.assertEqual(len(self.module.getattr(\"__name__\")), 1)\n        self.assertIsInstance(self.module.getattr(\"__name__\")[0], nodes.Const)\n        self.assertEqual(self.module.getattr(\"__name__\")[0].value, \"data.module\")\n        self.assertEqual(len(self.module.getattr(\"__doc__\")), 1)\n        self.assertIsInstance(self.module.getattr(\"__doc__\")[0], nodes.Const)\n        self.assertEqual(\n            self.module.getattr(\"__doc__\")[0].value, \"test module for astroid\\n\"\n        )\n        self.assertEqual(len(self.module.getattr(\"__file__\")), 1)\n        self.assertIsInstance(self.module.getattr(\"__file__\")[0], nodes.Const)\n        self.assertEqual(\n            self.module.getattr(\"__file__\")[0].value,\n            os.path.abspath(resources.find(\"data/module.py\")),\n        )\n        self.assertEqual(len(self.module.getattr(\"__dict__\")), 1)\n        self.assertIsInstance(self.module.getattr(\"__dict__\")[0], nodes.Dict)\n        self.assertRaises(AttributeInferenceError, self.module.getattr, \"__path__\")\n        self.assertEqual(len(self.pack.getattr(\"__path__\")), 1)\n        self.assertIsInstance(self.pack.getattr(\"__path__\")[0], nodes.List)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_special_attributes", "self", "none", "self", "assertequal", "len", "self", "module", "getattr", "__name__", "1", "self", "assertisinstance", "self", "module", "getattr", "__name__", "0", "nodes", "const", "self", "assertequal", "self", "module", "getattr", "__name__", "0", "value", "data", "module", "self", "assertequal", "len", "self", "module", "getattr", "__doc__", "1", "self", "assertisinstance", "self", "module", "getattr", "__doc__", "0", "nodes", "const", "self", "assertequal", "self", "module", "getattr", "__doc__", "0", "value", "test", "module", "for", "astroid", "n", "self", "assertequal", "len", "self", "module", "getattr", "__file__", "1", "self", "assertisinstance", "self", "module", "getattr", "__file__", "0", "nodes", "const", "self", "assertequal", "self", "module", "getattr", "__file__", "0", "value", "os", "path", "abspath", "resources", "find", "data", "module", "py", "self", "assertequal", "len", "self", "module", "getattr", "__dict__", "1", "self", "assertisinstance", "self", "module", "getattr", "__dict__", "0", "nodes", "dict", "self", "assertraises", "attributeinferenceerror", "self", "module", "getattr", "__path__", "self", "assertequal", "len", "self", "pack", "getattr", "__path__", "1", "self", "assertisinstance", "self", "pack", "getattr", "__path__", "0", "nodes", "list"], "doc_len": 139}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_dict_interface", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_dict_interface", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_dict_interface(self) -> None:\n        _test_dict_interface(self, self.module, \"YO\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_dict_interface", "self", "none", "_test_dict_interface", "self", "self", "module", "yo"], "doc_len": 13}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_getattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_getattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_getattr(self) -> None:\n        yo = self.module.getattr(\"YO\")[0]\n        self.assertIsInstance(yo, nodes.ClassDef)\n        self.assertEqual(yo.name, \"YO\")\n        red = next(self.module.igetattr(\"redirect\"))\n        self.assertIsInstance(red, nodes.FunctionDef)\n        self.assertEqual(red.name, \"four_args\")\n        namenode = next(self.module.igetattr(\"NameNode\"))\n        self.assertIsInstance(namenode, nodes.ClassDef)\n        self.assertEqual(namenode.name, \"Name\")\n        # resolve packageredirection\n        mod = resources.build_file(\n            \"data/appl/myConnection.py\", \"data.appl.myConnection\"\n        )\n        ssl = next(mod.igetattr(\"SSL1\"))\n        cnx = next(ssl.igetattr(\"Connection\"))\n        self.assertEqual(cnx.__class__, nodes.ClassDef)\n        self.assertEqual(cnx.name, \"Connection\")\n        self.assertEqual(cnx.root().name, \"data.SSL1.Connection1\")\n        self.assertEqual(len(self.nonregr.getattr(\"enumerate\")), 2)\n        self.assertRaises(InferenceError, self.nonregr.igetattr, \"YOAA\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_getattr", "self", "none", "yo", "self", "module", "getattr", "yo", "0", "self", "assertisinstance", "yo", "nodes", "classdef", "self", "assertequal", "yo", "name", "yo", "red", "next", "self", "module", "igetattr", "redirect", "self", "assertisinstance", "red", "nodes", "functiondef", "self", "assertequal", "red", "name", "four_args", "namenode", "next", "self", "module", "igetattr", "namenode", "self", "assertisinstance", "namenode", "nodes", "classdef", "self", "assertequal", "namenode", "name", "name", "resolve", "packageredirection", "mod", "resources", "build_file", "data", "appl", "myconnection", "py", "data", "appl", "myconnection", "ssl", "next", "mod", "igetattr", "ssl1", "cnx", "next", "ssl", "igetattr", "connection", "self", "assertequal", "cnx", "__class__", "nodes", "classdef", "self", "assertequal", "cnx", "name", "connection", "self", "assertequal", "cnx", "root", "name", "data", "ssl1", "connection1", "self", "assertequal", "len", "self", "nonregr", "getattr", "enumerate", "2", "self", "assertraises", "inferenceerror", "self", "nonregr", "igetattr", "yoaa"], "doc_len": 112}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_wildcard_import_names", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_wildcard_import_names", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_wildcard_import_names(self) -> None:\n        m = resources.build_file(\"data/all.py\", \"all\")\n        self.assertEqual(m.wildcard_import_names(), [\"Aaa\", \"_bla\", \"name\"])\n        m = resources.build_file(\"data/notall.py\", \"notall\")\n        res = sorted(m.wildcard_import_names())\n        self.assertEqual(res, [\"Aaa\", \"func\", \"name\", \"other\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_wildcard_import_names", "self", "none", "m", "resources", "build_file", "data", "all", "py", "all", "self", "assertequal", "m", "wildcard_import_names", "aaa", "_bla", "name", "m", "resources", "build_file", "data", "notall", "py", "notall", "res", "sorted", "m", "wildcard_import_names", "self", "assertequal", "res", "aaa", "func", "name", "other"], "doc_len": 40}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_public_names", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_public_names", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_public_names(self) -> None:\n        m = builder.parse(\n            \"\"\"\n        name = 'a'\n        _bla = 2\n        other = 'o'\n        class Aaa: pass\n        def func(): print('yo')\n        __all__ = 'Aaa', '_bla', 'name'\n        \"\"\"\n        )\n        values = sorted([\"Aaa\", \"name\", \"other\", \"func\"])\n        self.assertEqual(sorted(m.public_names()), values)\n        m = builder.parse(\n            \"\"\"\n        name = 'a'\n        _bla = 2\n        other = 'o'\n        class Aaa: pass\n\n        def func(): return 'yo'\n        \"\"\"\n        )\n        res = sorted(m.public_names())\n        self.assertEqual(res, values)\n\n        m = builder.parse(\n            \"\"\"\n            from missing import tzop\n            trop = \"test\"\n            __all__ = (trop, \"test1\", tzop, 42)\n        \"\"\"\n        )\n        res = sorted(m.public_names())\n        self.assertEqual(res, [\"trop\", \"tzop\"])\n\n        m = builder.parse(\n            \"\"\"\n            test = tzop = 42\n            __all__ = ('test', ) + ('tzop', )\n        \"\"\"\n        )\n        res = sorted(m.public_names())\n        self.assertEqual(res, [\"test\", \"tzop\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_public_names", "self", "none", "m", "builder", "parse", "name", "a", "_bla", "2", "other", "o", "class", "aaa", "pass", "def", "func", "print", "yo", "__all__", "aaa", "_bla", "name", "values", "sorted", "aaa", "name", "other", "func", "self", "assertequal", "sorted", "m", "public_names", "values", "m", "builder", "parse", "name", "a", "_bla", "2", "other", "o", "class", "aaa", "pass", "def", "func", "return", "yo", "res", "sorted", "m", "public_names", "self", "assertequal", "res", "values", "m", "builder", "parse", "from", "missing", "import", "tzop", "trop", "test", "__all__", "trop", "test1", "tzop", "42", "res", "sorted", "m", "public_names", "self", "assertequal", "res", "trop", "tzop", "m", "builder", "parse", "test", "tzop", "42", "__all__", "test", "tzop", "res", "sorted", "m", "public_names", "self", "assertequal", "res", "test", "tzop"], "doc_len": 105}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_module_getattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_module_getattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_module_getattr(self) -> None:\n        data = \"\"\"\n            appli = application\n            appli += 2\n            del appli\n        \"\"\"\n        astroid = builder.parse(data, __name__)\n        # test del statement not returned by getattr\n        self.assertEqual(len(astroid.getattr(\"appli\")), 2, astroid.getattr(\"appli\"))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_module_getattr", "self", "none", "data", "appli", "application", "appli", "2", "del", "appli", "astroid", "builder", "parse", "data", "__name__", "test", "del", "statement", "not", "returned", "by", "getattr", "self", "assertequal", "len", "astroid", "getattr", "appli", "2", "astroid", "getattr", "appli"], "doc_len": 37}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_relative_to_absolute_name", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_relative_to_absolute_name", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_relative_to_absolute_name(self) -> None:\n        # package\n        mod = nodes.Module(\"very.multi.package\", \"doc\")\n        mod.package = True\n        modname = mod.relative_to_absolute_name(\"utils\", 1)\n        self.assertEqual(modname, \"very.multi.package.utils\")\n        modname = mod.relative_to_absolute_name(\"utils\", 2)\n        self.assertEqual(modname, \"very.multi.utils\")\n        modname = mod.relative_to_absolute_name(\"utils\", 0)\n        self.assertEqual(modname, \"very.multi.package.utils\")\n        modname = mod.relative_to_absolute_name(\"\", 1)\n        self.assertEqual(modname, \"very.multi.package\")\n        # non package\n        mod = nodes.Module(\"very.multi.module\", \"doc\")\n        mod.package = False\n        modname = mod.relative_to_absolute_name(\"utils\", 0)\n        self.assertEqual(modname, \"very.multi.utils\")\n        modname = mod.relative_to_absolute_name(\"utils\", 1)\n        self.assertEqual(modname, \"very.multi.utils\")\n        modname = mod.relative_to_absolute_name(\"utils\", 2)\n        self.assertEqual(modname, \"very.utils\")\n        modname = mod.relative_to_absolute_name(\"\", 1)\n        self.assertEqual(modname, \"very.multi\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_relative_to_absolute_name", "self", "none", "package", "mod", "nodes", "module", "very", "multi", "package", "doc", "mod", "package", "true", "modname", "mod", "relative_to_absolute_name", "utils", "1", "self", "assertequal", "modname", "very", "multi", "package", "utils", "modname", "mod", "relative_to_absolute_name", "utils", "2", "self", "assertequal", "modname", "very", "multi", "utils", "modname", "mod", "relative_to_absolute_name", "utils", "0", "self", "assertequal", "modname", "very", "multi", "package", "utils", "modname", "mod", "relative_to_absolute_name", "1", "self", "assertequal", "modname", "very", "multi", "package", "non", "package", "mod", "nodes", "module", "very", "multi", "module", "doc", "mod", "package", "false", "modname", "mod", "relative_to_absolute_name", "utils", "0", "self", "assertequal", "modname", "very", "multi", "utils", "modname", "mod", "relative_to_absolute_name", "utils", "1", "self", "assertequal", "modname", "very", "multi", "utils", "modname", "mod", "relative_to_absolute_name", "utils", "2", "self", "assertequal", "modname", "very", "utils", "modname", "mod", "relative_to_absolute_name", "1", "self", "assertequal", "modname", "very", "multi"], "doc_len": 117}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_relative_to_absolute_name_beyond_top_level", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_relative_to_absolute_name_beyond_top_level", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_relative_to_absolute_name_beyond_top_level(self) -> None:\n        mod = nodes.Module(\"a.b.c\", \"\")\n        mod.package = True\n        for level in (5, 4):\n            with self.assertRaises(TooManyLevelsError) as cm:\n                mod.relative_to_absolute_name(\"test\", level)\n\n            expected = (\n                \"Relative import with too many levels \"\n                f\"({level-1}) for module {mod.name!r}\"\n            )\n            self.assertEqual(expected, str(cm.exception))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_relative_to_absolute_name_beyond_top_level", "self", "none", "mod", "nodes", "module", "a", "b", "c", "mod", "package", "true", "for", "level", "in", "5", "4", "with", "self", "assertraises", "toomanylevelserror", "as", "cm", "mod", "relative_to_absolute_name", "test", "level", "expected", "relative", "import", "with", "too", "many", "levels", "f", "level", "1", "for", "module", "mod", "name", "r", "self", "assertequal", "expected", "str", "cm", "exception"], "doc_len": 53}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_import_1", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_import_1", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_import_1(self) -> None:\n        data = \"\"\"from . import subpackage\"\"\"\n        sys.path.insert(0, resources.find(\"data\"))\n        astroid = builder.parse(data, \"package\", \"data/package/__init__.py\")\n        try:\n            m = astroid.import_module(\"\", level=1)\n            self.assertEqual(m.name, \"package\")\n            inferred = list(astroid.igetattr(\"subpackage\"))\n            self.assertEqual(len(inferred), 1)\n            self.assertEqual(inferred[0].name, \"package.subpackage\")\n        finally:\n            del sys.path[0]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_import_1", "self", "none", "data", "from", "import", "subpackage", "sys", "path", "insert", "0", "resources", "find", "data", "astroid", "builder", "parse", "data", "package", "data", "package", "__init__", "py", "try", "m", "astroid", "import_module", "level", "1", "self", "assertequal", "m", "name", "package", "inferred", "list", "astroid", "igetattr", "subpackage", "self", "assertequal", "len", "inferred", "1", "self", "assertequal", "inferred", "0", "name", "package", "subpackage", "finally", "del", "sys", "path", "0"], "doc_len": 61}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_import_2", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_import_2", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_import_2(self) -> None:\n        data = \"\"\"from . import subpackage as pouet\"\"\"\n        astroid = builder.parse(data, \"package\", \"data/package/__init__.py\")\n        sys.path.insert(0, resources.find(\"data\"))\n        try:\n            m = astroid.import_module(\"\", level=1)\n            self.assertEqual(m.name, \"package\")\n            inferred = list(astroid.igetattr(\"pouet\"))\n            self.assertEqual(len(inferred), 1)\n            self.assertEqual(inferred[0].name, \"package.subpackage\")\n        finally:\n            del sys.path[0]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_import_2", "self", "none", "data", "from", "import", "subpackage", "as", "pouet", "astroid", "builder", "parse", "data", "package", "data", "package", "__init__", "py", "sys", "path", "insert", "0", "resources", "find", "data", "try", "m", "astroid", "import_module", "level", "1", "self", "assertequal", "m", "name", "package", "inferred", "list", "astroid", "igetattr", "pouet", "self", "assertequal", "len", "inferred", "1", "self", "assertequal", "inferred", "0", "name", "package", "subpackage", "finally", "del", "sys", "path", "0"], "doc_len": 63}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_file_stream_in_memory", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_file_stream_in_memory", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_file_stream_in_memory(self) -> None:\n        data = \"\"\"irrelevant_variable is irrelevant\"\"\"\n        astroid = builder.parse(data, \"in_memory\")\n        with astroid.stream() as stream:\n            self.assertEqual(stream.read().decode(), data)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_file_stream_in_memory", "self", "none", "data", "irrelevant_variable", "is", "irrelevant", "astroid", "builder", "parse", "data", "in_memory", "with", "astroid", "stream", "as", "stream", "self", "assertequal", "stream", "read", "decode", "data"], "doc_len": 28}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_file_stream_physical", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_file_stream_physical", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_file_stream_physical(self) -> None:\n        path = resources.find(\"data/all.py\")\n        astroid = builder.AstroidBuilder().file_build(path, \"all\")\n        with open(path, \"rb\") as file_io:\n            with astroid.stream() as stream:\n                self.assertEqual(stream.read(), file_io.read())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_file_stream_physical", "self", "none", "path", "resources", "find", "data", "all", "py", "astroid", "builder", "astroidbuilder", "file_build", "path", "all", "with", "open", "path", "rb", "as", "file_io", "with", "astroid", "stream", "as", "stream", "self", "assertequal", "stream", "read", "file_io", "read"], "doc_len": 37}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_file_stream_api", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_file_stream_api", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_file_stream_api(self) -> None:\n        path = resources.find(\"data/all.py\")\n        file_build = builder.AstroidBuilder().file_build(path, \"all\")\n        with self.assertRaises(AttributeError):\n            # pylint: disable=pointless-statement\n            file_build.file_stream\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_file_stream_api", "self", "none", "path", "resources", "find", "data", "all", "py", "file_build", "builder", "astroidbuilder", "file_build", "path", "all", "with", "self", "assertraises", "attributeerror", "pylint", "disable", "pointless", "statement", "file_build", "file_stream"], "doc_len": 30}
{"doc_id": "tests/unittest_scoped_nodes.py::ModuleNodeTest.test_stream_api", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ModuleNodeTest", "func_name": "test_stream_api", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ModuleNodeTest\n    def test_stream_api(self) -> None:\n        path = resources.find(\"data/all.py\")\n        astroid = builder.AstroidBuilder().file_build(path, \"all\")\n        stream = astroid.stream()\n        self.assertTrue(hasattr(stream, \"close\"))\n        with stream:\n            with open(path, \"rb\") as file_io:\n                self.assertEqual(stream.read(), file_io.read())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "modulenodetest", "def", "test_stream_api", "self", "none", "path", "resources", "find", "data", "all", "py", "astroid", "builder", "astroidbuilder", "file_build", "path", "all", "stream", "astroid", "stream", "self", "asserttrue", "hasattr", "stream", "close", "with", "stream", "with", "open", "path", "rb", "as", "file_io", "self", "assertequal", "stream", "read", "file_io", "read"], "doc_len": 42}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_special_attributes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_special_attributes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_special_attributes(self) -> None:\n        func = self.module2[\"make_class\"]\n        self.assertEqual(len(func.getattr(\"__name__\")), 1)\n        self.assertIsInstance(func.getattr(\"__name__\")[0], nodes.Const)\n        self.assertEqual(func.getattr(\"__name__\")[0].value, \"make_class\")\n        self.assertEqual(len(func.getattr(\"__doc__\")), 1)\n        self.assertIsInstance(func.getattr(\"__doc__\")[0], nodes.Const)\n        self.assertEqual(\n            func.getattr(\"__doc__\")[0].value,\n            \"check base is correctly resolved to Concrete0\",\n        )\n        self.assertEqual(len(self.module.getattr(\"__dict__\")), 1)\n        self.assertIsInstance(self.module.getattr(\"__dict__\")[0], nodes.Dict)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_special_attributes", "self", "none", "func", "self", "module2", "make_class", "self", "assertequal", "len", "func", "getattr", "__name__", "1", "self", "assertisinstance", "func", "getattr", "__name__", "0", "nodes", "const", "self", "assertequal", "func", "getattr", "__name__", "0", "value", "make_class", "self", "assertequal", "len", "func", "getattr", "__doc__", "1", "self", "assertisinstance", "func", "getattr", "__doc__", "0", "nodes", "const", "self", "assertequal", "func", "getattr", "__doc__", "0", "value", "check", "base", "is", "correctly", "resolved", "to", "concrete0", "self", "assertequal", "len", "self", "module", "getattr", "__dict__", "1", "self", "assertisinstance", "self", "module", "getattr", "__dict__", "0", "nodes", "dict"], "doc_len": 81}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_dict_interface", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_dict_interface", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_dict_interface(self) -> None:\n        _test_dict_interface(self, self.module[\"global_access\"], \"local\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_dict_interface", "self", "none", "_test_dict_interface", "self", "self", "module", "global_access", "local"], "doc_len": 14}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_default_value", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_default_value", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_default_value(self) -> None:\n        func = self.module2[\"make_class\"]\n        self.assertIsInstance(func.args.default_value(\"base\"), nodes.Attribute)\n        self.assertRaises(NoDefault, func.args.default_value, \"args\")\n        self.assertRaises(NoDefault, func.args.default_value, \"kwargs\")\n        self.assertRaises(NoDefault, func.args.default_value, \"any\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_default_value", "self", "none", "func", "self", "module2", "make_class", "self", "assertisinstance", "func", "args", "default_value", "base", "nodes", "attribute", "self", "assertraises", "nodefault", "func", "args", "default_value", "args", "self", "assertraises", "nodefault", "func", "args", "default_value", "kwargs", "self", "assertraises", "nodefault", "func", "args", "default_value", "any"], "doc_len": 41}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_navigation", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_navigation", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_navigation(self) -> None:\n        function = self.module[\"global_access\"]\n        self.assertEqual(function.statement(), function)\n        self.assertEqual(function.statement(future=True), function)\n        l_sibling = function.previous_sibling()\n        # check taking parent if child is not a stmt\n        self.assertIsInstance(l_sibling, nodes.Assign)\n        child = function.args.args[0]\n        self.assertIs(l_sibling, child.previous_sibling())\n        r_sibling = function.next_sibling()\n        self.assertIsInstance(r_sibling, nodes.ClassDef)\n        self.assertEqual(r_sibling.name, \"YO\")\n        self.assertIs(r_sibling, child.next_sibling())\n        last = r_sibling.next_sibling().next_sibling().next_sibling()\n        self.assertIsInstance(last, nodes.Assign)\n        self.assertIsNone(last.next_sibling())\n        first = l_sibling.root().body[0]\n        self.assertIsNone(first.previous_sibling())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_navigation", "self", "none", "function", "self", "module", "global_access", "self", "assertequal", "function", "statement", "function", "self", "assertequal", "function", "statement", "future", "true", "function", "l_sibling", "function", "previous_sibling", "check", "taking", "parent", "if", "child", "is", "not", "a", "stmt", "self", "assertisinstance", "l_sibling", "nodes", "assign", "child", "function", "args", "args", "0", "self", "assertis", "l_sibling", "child", "previous_sibling", "r_sibling", "function", "next_sibling", "self", "assertisinstance", "r_sibling", "nodes", "classdef", "self", "assertequal", "r_sibling", "name", "yo", "self", "assertis", "r_sibling", "child", "next_sibling", "last", "r_sibling", "next_sibling", "next_sibling", "next_sibling", "self", "assertisinstance", "last", "nodes", "assign", "self", "assertisnone", "last", "next_sibling", "first", "l_sibling", "root", "body", "0", "self", "assertisnone", "first", "previous_sibling"], "doc_len": 92}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_four_args", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_four_args", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_four_args(self) -> None:\n        func = self.module[\"four_args\"]\n        local = sorted(func.keys())\n        self.assertEqual(local, [\"a\", \"b\", \"c\", \"d\"])\n        self.assertEqual(func.type, \"function\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_four_args", "self", "none", "func", "self", "module", "four_args", "local", "sorted", "func", "keys", "self", "assertequal", "local", "a", "b", "c", "d", "self", "assertequal", "func", "type", "function"], "doc_len": 28}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_format_args", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_format_args", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_format_args(self) -> None:\n        func = self.module2[\"make_class\"]\n        self.assertEqual(\n            func.args.format_args(), \"any, base=data.module.YO, *args, **kwargs\"\n        )\n        func = self.module[\"four_args\"]\n        self.assertEqual(func.args.format_args(), \"a, b, c, d\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_format_args", "self", "none", "func", "self", "module2", "make_class", "self", "assertequal", "func", "args", "format_args", "any", "base", "data", "module", "yo", "args", "kwargs", "func", "self", "module", "four_args", "self", "assertequal", "func", "args", "format_args", "a", "b", "c", "d"], "doc_len": 37}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_format_args_keyword_only_args", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_format_args_keyword_only_args", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_format_args_keyword_only_args(self) -> None:\n        node = (\n            builder.parse(\n                \"\"\"\n        def test(a: int, *, b: dict):\n            pass\n        \"\"\"\n            )\n            .body[-1]\n            .args\n        )\n        formatted = node.format_args()\n        self.assertEqual(formatted, \"a: int, *, b: dict\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_format_args_keyword_only_args", "self", "none", "node", "builder", "parse", "def", "test", "a", "int", "b", "dict", "pass", "body", "1", "args", "formatted", "node", "format_args", "self", "assertequal", "formatted", "a", "int", "b", "dict"], "doc_len": 31}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_is_generator", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_is_generator", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_is_generator(self) -> None:\n        self.assertTrue(self.module2[\"generator\"].is_generator())\n        self.assertFalse(self.module2[\"not_a_generator\"].is_generator())\n        self.assertFalse(self.module2[\"make_class\"].is_generator())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_is_generator", "self", "none", "self", "asserttrue", "self", "module2", "generator", "is_generator", "self", "assertfalse", "self", "module2", "not_a_generator", "is_generator", "self", "assertfalse", "self", "module2", "make_class", "is_generator"], "doc_len": 26}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_is_abstract", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_is_abstract", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_is_abstract(self) -> None:\n        method = self.module2[\"AbstractClass\"][\"to_override\"]\n        self.assertTrue(method.is_abstract(pass_is_abstract=False))\n        self.assertEqual(method.qname(), \"data.module2.AbstractClass.to_override\")\n        self.assertEqual(method.pytype(), \"builtins.instancemethod\")\n        method = self.module2[\"AbstractClass\"][\"return_something\"]\n        self.assertFalse(method.is_abstract(pass_is_abstract=False))\n        # non regression : test raise \"string\" doesn't cause an exception in is_abstract\n        func = self.module2[\"raise_string\"]\n        self.assertFalse(func.is_abstract(pass_is_abstract=False))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_is_abstract", "self", "none", "method", "self", "module2", "abstractclass", "to_override", "self", "asserttrue", "method", "is_abstract", "pass_is_abstract", "false", "self", "assertequal", "method", "qname", "data", "module2", "abstractclass", "to_override", "self", "assertequal", "method", "pytype", "builtins", "instancemethod", "method", "self", "module2", "abstractclass", "return_something", "self", "assertfalse", "method", "is_abstract", "pass_is_abstract", "false", "non", "regression", "test", "raise", "string", "doesn", "t", "cause", "an", "exception", "in", "is_abstract", "func", "self", "module2", "raise_string", "self", "assertfalse", "func", "is_abstract", "pass_is_abstract", "false"], "doc_len": 66}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_is_abstract_decorated", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_is_abstract_decorated", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_is_abstract_decorated(self) -> None:\n        methods = builder.extract_node(\n            \"\"\"\n            import abc\n\n            class Klass(object):\n                @abc.abstractproperty\n                def prop(self):  #@\n                   pass\n\n                @abc.abstractmethod\n                def method1(self):  #@\n                   pass\n\n                some_other_decorator = lambda x: x\n                @some_other_decorator\n                def method2(self):  #@\n                   pass\n         \"\"\"\n        )\n        assert len(methods) == 3\n        prop, method1, method2 = methods\n        assert isinstance(prop, nodes.FunctionDef)\n        assert prop.is_abstract(pass_is_abstract=False)\n\n        assert isinstance(method1, nodes.FunctionDef)\n        assert method1.is_abstract(pass_is_abstract=False)\n\n        assert isinstance(method2, nodes.FunctionDef)\n        assert not method2.is_abstract(pass_is_abstract=False)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_is_abstract_decorated", "self", "none", "methods", "builder", "extract_node", "import", "abc", "class", "klass", "object", "abc", "abstractproperty", "def", "prop", "self", "pass", "abc", "abstractmethod", "def", "method1", "self", "pass", "some_other_decorator", "lambda", "x", "x", "some_other_decorator", "def", "method2", "self", "pass", "assert", "len", "methods", "3", "prop", "method1", "method2", "methods", "assert", "isinstance", "prop", "nodes", "functiondef", "assert", "prop", "is_abstract", "pass_is_abstract", "false", "assert", "isinstance", "method1", "nodes", "functiondef", "assert", "method1", "is_abstract", "pass_is_abstract", "false", "assert", "isinstance", "method2", "nodes", "functiondef", "assert", "not", "method2", "is_abstract", "pass_is_abstract", "false"], "doc_len": 76}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_lambda_pytype", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_lambda_pytype", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_lambda_pytype(self) -> None:\n        data = \"\"\"\n            def f():\n                g = lambda: None\n        \"\"\"\n        astroid = builder.parse(data)\n        g = list(astroid[\"f\"].ilookup(\"g\"))[0]\n        self.assertEqual(g.pytype(), \"builtins.function\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_lambda_pytype", "self", "none", "data", "def", "f", "g", "lambda", "none", "astroid", "builder", "parse", "data", "g", "list", "astroid", "f", "ilookup", "g", "0", "self", "assertequal", "g", "pytype", "builtins", "function"], "doc_len": 31}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_lambda_qname", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_lambda_qname", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_lambda_qname(self) -> None:\n        astroid = builder.parse(\"lmbd = lambda: None\", __name__)\n        self.assertEqual(f\"{__name__}.<lambda>\", astroid[\"lmbd\"].parent.value.qname())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_lambda_qname", "self", "none", "astroid", "builder", "parse", "lmbd", "lambda", "none", "__name__", "self", "assertequal", "f", "__name__", "lambda", "astroid", "lmbd", "parent", "value", "qname"], "doc_len": 25}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_is_method", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_is_method", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_is_method(self) -> None:\n        data = \"\"\"\n            class A:\n                def meth1(self):\n                    return 1\n                @classmethod\n                def meth2(cls):\n                    return 2\n                @staticmethod\n                def meth3():\n                    return 3\n\n            def function():\n                return 0\n\n            @staticmethod\n            def sfunction():\n                return -1\n        \"\"\"\n        astroid = builder.parse(data)\n        self.assertTrue(astroid[\"A\"][\"meth1\"].is_method())\n        self.assertTrue(astroid[\"A\"][\"meth2\"].is_method())\n        self.assertTrue(astroid[\"A\"][\"meth3\"].is_method())\n        self.assertFalse(astroid[\"function\"].is_method())\n        self.assertFalse(astroid[\"sfunction\"].is_method())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_is_method", "self", "none", "data", "class", "a", "def", "meth1", "self", "return", "1", "classmethod", "def", "meth2", "cls", "return", "2", "staticmethod", "def", "meth3", "return", "3", "def", "function", "return", "0", "staticmethod", "def", "sfunction", "return", "1", "astroid", "builder", "parse", "data", "self", "asserttrue", "astroid", "a", "meth1", "is_method", "self", "asserttrue", "astroid", "a", "meth2", "is_method", "self", "asserttrue", "astroid", "a", "meth3", "is_method", "self", "assertfalse", "astroid", "function", "is_method", "self", "assertfalse", "astroid", "sfunction", "is_method"], "doc_len": 68}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_argnames", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_argnames", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_argnames(self) -> None:\n        code = \"def f(a, b, c, *args, **kwargs): pass\"\n        astroid = builder.parse(code, __name__)\n        self.assertEqual(astroid[\"f\"].argnames(), [\"a\", \"b\", \"c\", \"args\", \"kwargs\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_argnames", "self", "none", "code", "def", "f", "a", "b", "c", "args", "kwargs", "pass", "astroid", "builder", "parse", "code", "__name__", "self", "assertequal", "astroid", "f", "argnames", "a", "b", "c", "args", "kwargs"], "doc_len": 32}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_return_nothing", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_return_nothing", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_return_nothing(self) -> None:\n        \"\"\"test inferred value on a function with empty return\"\"\"\n        data = \"\"\"\n            def func():\n                return\n\n            a = func()\n        \"\"\"\n        astroid = builder.parse(data)\n        call = astroid.body[1].value\n        func_vals = call.inferred()\n        self.assertEqual(len(func_vals), 1)\n        self.assertIsInstance(func_vals[0], nodes.Const)\n        self.assertIsNone(func_vals[0].value)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_return_nothing", "self", "none", "test", "inferred", "value", "on", "a", "function", "with", "empty", "return", "data", "def", "func", "return", "a", "func", "astroid", "builder", "parse", "data", "call", "astroid", "body", "1", "value", "func_vals", "call", "inferred", "self", "assertequal", "len", "func_vals", "1", "self", "assertisinstance", "func_vals", "0", "nodes", "const", "self", "assertisnone", "func_vals", "0", "value"], "doc_len": 51}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_no_returns_is_implicitly_none", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_no_returns_is_implicitly_none", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_no_returns_is_implicitly_none(self) -> None:\n        code = \"\"\"\n            def f():\n                print('non-empty, non-pass, no return statements')\n            value = f()\n            value\n        \"\"\"\n        node = builder.extract_node(code)\n        inferred = next(node.infer())\n        assert isinstance(inferred, nodes.Const)\n        assert inferred.value is None\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_no_returns_is_implicitly_none", "self", "none", "code", "def", "f", "print", "non", "empty", "non", "pass", "no", "return", "statements", "value", "f", "value", "node", "builder", "extract_node", "code", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "is", "none"], "doc_len": 40}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_only_raises_is_not_implicitly_none", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_only_raises_is_not_implicitly_none", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_only_raises_is_not_implicitly_none(self) -> None:\n        code = \"\"\"\n            def f():\n                raise SystemExit()\n            f()\n        \"\"\"\n        node = builder.extract_node(code)\n        assert isinstance(node, nodes.Call)\n        inferred = next(node.infer())\n        assert inferred is util.Uninferable\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_only_raises_is_not_implicitly_none", "self", "none", "code", "def", "f", "raise", "systemexit", "f", "node", "builder", "extract_node", "code", "assert", "isinstance", "node", "nodes", "call", "inferred", "next", "node", "infer", "assert", "inferred", "is", "util", "uninferable"], "doc_len": 32}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_abstract_methods_are_not_implicitly_none", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_abstract_methods_are_not_implicitly_none", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_abstract_methods_are_not_implicitly_none(self) -> None:\n        code = \"\"\"\n            from abc import ABCMeta, abstractmethod\n\n            class Abstract(metaclass=ABCMeta):\n                @abstractmethod\n                def foo(self):\n                    pass\n                def bar(self):\n                    print('non-empty, non-pass, no return statements')\n            Abstract().foo()  #@\n            Abstract().bar()  #@\n\n            class Concrete(Abstract):\n                def foo(self):\n                    return 123\n            Concrete().foo()  #@\n            Concrete().bar()  #@\n        \"\"\"\n        afoo, abar, cfoo, cbar = builder.extract_node(code)\n\n        assert next(afoo.infer()) is util.Uninferable\n        for node, value in ((abar, None), (cfoo, 123), (cbar, None)):\n            inferred = next(node.infer())\n            assert isinstance(inferred, nodes.Const)\n            assert inferred.value == value\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_abstract_methods_are_not_implicitly_none", "self", "none", "code", "from", "abc", "import", "abcmeta", "abstractmethod", "class", "abstract", "metaclass", "abcmeta", "abstractmethod", "def", "foo", "self", "pass", "def", "bar", "self", "print", "non", "empty", "non", "pass", "no", "return", "statements", "abstract", "foo", "abstract", "bar", "class", "concrete", "abstract", "def", "foo", "self", "return", "123", "concrete", "foo", "concrete", "bar", "afoo", "abar", "cfoo", "cbar", "builder", "extract_node", "code", "assert", "next", "afoo", "infer", "is", "util", "uninferable", "for", "node", "value", "in", "abar", "none", "cfoo", "123", "cbar", "none", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "const", "assert", "inferred", "value", "value"], "doc_len": 87}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_func_instance_attr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_func_instance_attr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_func_instance_attr(self) -> None:\n        \"\"\"test instance attributes for functions\"\"\"\n        data = \"\"\"\n            def test():\n                print(test.bar)\n\n            test.bar = 1\n            test()\n        \"\"\"\n        astroid = builder.parse(data, \"mod\")\n        func = astroid.body[2].value.func.inferred()[0]\n        self.assertIsInstance(func, nodes.FunctionDef)\n        self.assertEqual(func.name, \"test\")\n        one = func.getattr(\"bar\")[0].inferred()[0]\n        self.assertIsInstance(one, nodes.Const)\n        self.assertEqual(one.value, 1)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_func_instance_attr", "self", "none", "test", "instance", "attributes", "for", "functions", "data", "def", "test", "print", "test", "bar", "test", "bar", "1", "test", "astroid", "builder", "parse", "data", "mod", "func", "astroid", "body", "2", "value", "func", "inferred", "0", "self", "assertisinstance", "func", "nodes", "functiondef", "self", "assertequal", "func", "name", "test", "one", "func", "getattr", "bar", "0", "inferred", "0", "self", "assertisinstance", "one", "nodes", "const", "self", "assertequal", "one", "value", "1"], "doc_len": 63}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_type_builtin_descriptor_subclasses", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_type_builtin_descriptor_subclasses", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_type_builtin_descriptor_subclasses(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            class classonlymethod(classmethod):\n                pass\n            class staticonlymethod(staticmethod):\n                pass\n\n            class Node:\n                @classonlymethod\n                def clsmethod_subclass(cls):\n                    pass\n                @classmethod\n                def clsmethod(cls):\n                    pass\n                @staticonlymethod\n                def staticmethod_subclass(cls):\n                    pass\n                @staticmethod\n                def stcmethod(cls):\n                    pass\n        \"\"\"\n        )\n        node = astroid.locals[\"Node\"][0]\n        self.assertEqual(node.locals[\"clsmethod_subclass\"][0].type, \"classmethod\")\n        self.assertEqual(node.locals[\"clsmethod\"][0].type, \"classmethod\")\n        self.assertEqual(node.locals[\"staticmethod_subclass\"][0].type, \"staticmethod\")\n        self.assertEqual(node.locals[\"stcmethod\"][0].type, \"staticmethod\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_type_builtin_descriptor_subclasses", "self", "none", "astroid", "builder", "parse", "class", "classonlymethod", "classmethod", "pass", "class", "staticonlymethod", "staticmethod", "pass", "class", "node", "classonlymethod", "def", "clsmethod_subclass", "cls", "pass", "classmethod", "def", "clsmethod", "cls", "pass", "staticonlymethod", "def", "staticmethod_subclass", "cls", "pass", "staticmethod", "def", "stcmethod", "cls", "pass", "node", "astroid", "locals", "node", "0", "self", "assertequal", "node", "locals", "clsmethod_subclass", "0", "type", "classmethod", "self", "assertequal", "node", "locals", "clsmethod", "0", "type", "classmethod", "self", "assertequal", "node", "locals", "staticmethod_subclass", "0", "type", "staticmethod", "self", "assertequal", "node", "locals", "stcmethod", "0", "type", "staticmethod"], "doc_len": 78}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_decorator_builtin_descriptors", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_decorator_builtin_descriptors", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_decorator_builtin_descriptors(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            def static_decorator(platform=None, order=50):\n                def wrapper(f):\n                    f.cgm_module = True\n                    f.cgm_module_order = order\n                    f.cgm_module_platform = platform\n                    return staticmethod(f)\n                return wrapper\n\n            def long_classmethod_decorator(platform=None, order=50):\n                def wrapper(f):\n                    def wrapper2(f):\n                        def wrapper3(f):\n                            f.cgm_module = True\n                            f.cgm_module_order = order\n                            f.cgm_module_platform = platform\n                            return classmethod(f)\n                        return wrapper3(f)\n                    return wrapper2(f)\n                return wrapper\n\n            def classmethod_decorator(platform=None):\n                def wrapper(f):\n                    f.platform = platform\n                    return classmethod(f)\n                return wrapper\n\n            def classmethod_wrapper(fn):\n                def wrapper(cls, *args, **kwargs):\n                    result = fn(cls, *args, **kwargs)\n                    return result\n\n                return classmethod(wrapper)\n\n            def staticmethod_wrapper(fn):\n                def wrapper(*args, **kwargs):\n                    return fn(*args, **kwargs)\n                return staticmethod(wrapper)\n\n            class SomeClass(object):\n                @static_decorator()\n                def static(node, cfg):\n                    pass\n                @classmethod_decorator()\n                def classmethod(cls):\n                    pass\n                @static_decorator\n                def not_so_static(node):\n                    pass\n                @classmethod_decorator\n                def not_so_classmethod(node):\n                    pass\n                @classmethod_wrapper\n                def classmethod_wrapped(cls):\n                    pass\n                @staticmethod_wrapper\n                def staticmethod_wrapped():\n                    pass\n                @long_classmethod_decorator()\n                def long_classmethod(cls):\n                    pass\n        \"\"\"\n        )\n        node = astroid.locals[\"SomeClass\"][0]\n        self.assertEqual(node.locals[\"static\"][0].type, \"staticmethod\")\n        self.assertEqual(node.locals[\"classmethod\"][0].type, \"classmethod\")\n        self.assertEqual(node.locals[\"not_so_static\"][0].type, \"method\")\n        self.assertEqual(node.locals[\"not_so_classmethod\"][0].type, \"method\")\n        self.assertEqual(node.locals[\"classmethod_wrapped\"][0].type, \"classmethod\")\n        self.assertEqual(node.locals[\"staticmethod_wrapped\"][0].type, \"staticmethod\")\n        self.assertEqual(node.locals[\"long_classmethod\"][0].type, \"classmethod\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_decorator_builtin_descriptors", "self", "none", "astroid", "builder", "parse", "def", "static_decorator", "platform", "none", "order", "50", "def", "wrapper", "f", "f", "cgm_module", "true", "f", "cgm_module_order", "order", "f", "cgm_module_platform", "platform", "return", "staticmethod", "f", "return", "wrapper", "def", "long_classmethod_decorator", "platform", "none", "order", "50", "def", "wrapper", "f", "def", "wrapper2", "f", "def", "wrapper3", "f", "f", "cgm_module", "true", "f", "cgm_module_order", "order", "f", "cgm_module_platform", "platform", "return", "classmethod", "f", "return", "wrapper3", "f", "return", "wrapper2", "f", "return", "wrapper", "def", "classmethod_decorator", "platform", "none", "def", "wrapper", "f", "f", "platform", "platform", "return", "classmethod", "f", "return", "wrapper", "def", "classmethod_wrapper", "fn", "def", "wrapper", "cls", "args", "kwargs", "result", "fn", "cls", "args", "kwargs", "return", "result", "return", "classmethod", "wrapper", "def", "staticmethod_wrapper", "fn", "def", "wrapper", "args", "kwargs", "return", "fn", "args", "kwargs", "return", "staticmethod", "wrapper", "class", "someclass", "object", "static_decorator", "def", "static", "node", "cfg", "pass", "classmethod_decorator", "def", "classmethod", "cls", "pass", "static_decorator", "def", "not_so_static", "node", "pass", "classmethod_decorator", "def", "not_so_classmethod", "node", "pass", "classmethod_wrapper", "def", "classmethod_wrapped", "cls", "pass", "staticmethod_wrapper", "def", "staticmethod_wrapped", "pass", "long_classmethod_decorator", "def", "long_classmethod", "cls", "pass", "node", "astroid", "locals", "someclass", "0", "self", "assertequal", "node", "locals", "static", "0", "type", "staticmethod", "self", "assertequal", "node", "locals", "classmethod", "0", "type", "classmethod", "self", "assertequal", "node", "locals", "not_so_static", "0", "type", "method", "self", "assertequal", "node", "locals", "not_so_classmethod", "0", "type", "method", "self", "assertequal", "node", "locals", "classmethod_wrapped", "0", "type", "classmethod", "self", "assertequal", "node", "locals", "staticmethod_wrapped", "0", "type", "staticmethod", "self", "assertequal", "node", "locals", "long_classmethod", "0", "type", "classmethod"], "doc_len": 215}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_igetattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_igetattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_igetattr(self) -> None:\n        func = builder.extract_node(\n            \"\"\"\n        def test():\n            pass\n        \"\"\"\n        )\n        assert isinstance(func, nodes.FunctionDef)\n        func.instance_attrs[\"value\"] = [nodes.Const(42)]\n        value = func.getattr(\"value\")\n        self.assertEqual(len(value), 1)\n        self.assertIsInstance(value[0], nodes.Const)\n        self.assertEqual(value[0].value, 42)\n        inferred = next(func.igetattr(\"value\"))\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_igetattr", "self", "none", "func", "builder", "extract_node", "def", "test", "pass", "assert", "isinstance", "func", "nodes", "functiondef", "func", "instance_attrs", "value", "nodes", "const", "42", "value", "func", "getattr", "value", "self", "assertequal", "len", "value", "1", "self", "assertisinstance", "value", "0", "nodes", "const", "self", "assertequal", "value", "0", "value", "42", "inferred", "next", "func", "igetattr", "value", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 61}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_return_annotation_is_not_the_last", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_return_annotation_is_not_the_last", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_return_annotation_is_not_the_last(self) -> None:\n        func = builder.extract_node(\n            \"\"\"\n        def test() -> bytes:\n            pass\n            pass\n            return\n        \"\"\"\n        )\n        last_child = func.last_child()\n        self.assertIsInstance(last_child, nodes.Return)\n        self.assertEqual(func.tolineno, 5)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_return_annotation_is_not_the_last", "self", "none", "func", "builder", "extract_node", "def", "test", "bytes", "pass", "pass", "return", "last_child", "func", "last_child", "self", "assertisinstance", "last_child", "nodes", "return", "self", "assertequal", "func", "tolineno", "5"], "doc_len": 30}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_method_init_subclass", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_method_init_subclass", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_method_init_subclass(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        class MyClass:\n            def __init_subclass__(cls):\n                pass\n        \"\"\"\n        )\n        method = klass[\"__init_subclass__\"]\n        self.assertEqual([n.name for n in method.args.args], [\"cls\"])\n        self.assertEqual(method.type, \"classmethod\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_method_init_subclass", "self", "none", "klass", "builder", "extract_node", "class", "myclass", "def", "__init_subclass__", "cls", "pass", "method", "klass", "__init_subclass__", "self", "assertequal", "n", "name", "for", "n", "in", "method", "args", "args", "cls", "self", "assertequal", "method", "type", "classmethod"], "doc_len": 36}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_dunder_class_local_to_method", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_dunder_class_local_to_method", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_dunder_class_local_to_method(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class MyClass:\n            def test(self):\n                __class__ #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"MyClass\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_dunder_class_local_to_method", "self", "none", "node", "builder", "extract_node", "class", "myclass", "def", "test", "self", "__class__", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "myclass"], "doc_len": 31}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_dunder_class_local_to_function", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_dunder_class_local_to_function", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_dunder_class_local_to_function(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        def test(self):\n            __class__ #@\n        \"\"\"\n        )\n        with self.assertRaises(NameInferenceError):\n            next(node.infer())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_dunder_class_local_to_function", "self", "none", "node", "builder", "extract_node", "def", "test", "self", "__class__", "with", "self", "assertraises", "nameinferenceerror", "next", "node", "infer"], "doc_len": 22}
{"doc_id": "tests/unittest_scoped_nodes.py::FunctionNodeTest.test_dunder_class_local_to_classmethod", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "FunctionNodeTest", "func_name": "test_dunder_class_local_to_classmethod", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: FunctionNodeTest\n    def test_dunder_class_local_to_classmethod(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class MyClass:\n            @classmethod\n            def test(cls):\n                __class__ #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        self.assertIsInstance(inferred, nodes.ClassDef)\n        self.assertEqual(inferred.name, \"MyClass\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "functionnodetest", "def", "test_dunder_class_local_to_classmethod", "self", "none", "node", "builder", "extract_node", "class", "myclass", "classmethod", "def", "test", "cls", "__class__", "inferred", "next", "node", "infer", "self", "assertisinstance", "inferred", "nodes", "classdef", "self", "assertequal", "inferred", "name", "myclass"], "doc_len": 32}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_dict_interface", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_dict_interface", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_dict_interface(self) -> None:\n        _test_dict_interface(self, self.module[\"YOUPI\"], \"method\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_dict_interface", "self", "none", "_test_dict_interface", "self", "self", "module", "youpi", "method"], "doc_len": 14}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_cls_special_attributes_1", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_cls_special_attributes_1", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_cls_special_attributes_1(self) -> None:\n        cls = self.module[\"YO\"]\n        self.assertEqual(len(cls.getattr(\"__bases__\")), 1)\n        self.assertEqual(len(cls.getattr(\"__name__\")), 1)\n        self.assertIsInstance(cls.getattr(\"__name__\")[0], nodes.Const)\n        self.assertEqual(cls.getattr(\"__name__\")[0].value, \"YO\")\n        self.assertEqual(len(cls.getattr(\"__doc__\")), 1)\n        self.assertIsInstance(cls.getattr(\"__doc__\")[0], nodes.Const)\n        self.assertEqual(cls.getattr(\"__doc__\")[0].value, \"hehe\\n    haha\")\n        # YO is an old styled class for Python 2.7\n        # May want to stop locals from referencing namespaced variables in the future\n        module_attr_num = 4\n        self.assertEqual(len(cls.getattr(\"__module__\")), module_attr_num)\n        self.assertIsInstance(cls.getattr(\"__module__\")[0], nodes.Const)\n        self.assertEqual(cls.getattr(\"__module__\")[0].value, \"data.module\")\n        self.assertEqual(len(cls.getattr(\"__dict__\")), 1)\n        if not cls.newstyle:\n            self.assertRaises(AttributeInferenceError, cls.getattr, \"__mro__\")\n        for cls in (nodes.List._proxied, nodes.Const(1)._proxied):\n            self.assertEqual(len(cls.getattr(\"__bases__\")), 1)\n            self.assertEqual(len(cls.getattr(\"__name__\")), 1)\n            self.assertEqual(\n                len(cls.getattr(\"__doc__\")), 1, (cls, cls.getattr(\"__doc__\"))\n            )\n            self.assertEqual(cls.getattr(\"__doc__\")[0].value, cls.doc)\n            self.assertEqual(len(cls.getattr(\"__module__\")), 4)\n            self.assertEqual(len(cls.getattr(\"__dict__\")), 1)\n            self.assertEqual(len(cls.getattr(\"__mro__\")), 1)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_cls_special_attributes_1", "self", "none", "cls", "self", "module", "yo", "self", "assertequal", "len", "cls", "getattr", "__bases__", "1", "self", "assertequal", "len", "cls", "getattr", "__name__", "1", "self", "assertisinstance", "cls", "getattr", "__name__", "0", "nodes", "const", "self", "assertequal", "cls", "getattr", "__name__", "0", "value", "yo", "self", "assertequal", "len", "cls", "getattr", "__doc__", "1", "self", "assertisinstance", "cls", "getattr", "__doc__", "0", "nodes", "const", "self", "assertequal", "cls", "getattr", "__doc__", "0", "value", "hehe", "n", "haha", "yo", "is", "an", "old", "styled", "class", "for", "python", "2", "7", "may", "want", "to", "stop", "locals", "from", "referencing", "namespaced", "variables", "in", "the", "future", "module_attr_num", "4", "self", "assertequal", "len", "cls", "getattr", "__module__", "module_attr_num", "self", "assertisinstance", "cls", "getattr", "__module__", "0", "nodes", "const", "self", "assertequal", "cls", "getattr", "__module__", "0", "value", "data", "module", "self", "assertequal", "len", "cls", "getattr", "__dict__", "1", "if", "not", "cls", "newstyle", "self", "assertraises", "attributeinferenceerror", "cls", "getattr", "__mro__", "for", "cls", "in", "nodes", "list", "_proxied", "nodes", "const", "1", "_proxied", "self", "assertequal", "len", "cls", "getattr", "__bases__", "1", "self", "assertequal", "len", "cls", "getattr", "__name__", "1", "self", "assertequal", "len", "cls", "getattr", "__doc__", "1", "cls", "cls", "getattr", "__doc__", "self", "assertequal", "cls", "getattr", "__doc__", "0", "value", "cls", "doc", "self", "assertequal", "len", "cls", "getattr", "__module__", "4", "self", "assertequal", "len", "cls", "getattr", "__dict__", "1", "self", "assertequal", "len", "cls", "getattr", "__mro__", "1"], "doc_len": 197}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test__mro__attribute", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test__mro__attribute", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test__mro__attribute(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(object): pass\n        class C(A, B): pass\n        \"\"\"\n        )\n        assert isinstance(node, nodes.ClassDef)\n        mro = node.getattr(\"__mro__\")[0]\n        self.assertIsInstance(mro, nodes.Tuple)\n        self.assertEqual(mro.elts, node.mro())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test__mro__attribute", "self", "none", "node", "builder", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "class", "c", "a", "b", "pass", "assert", "isinstance", "node", "nodes", "classdef", "mro", "node", "getattr", "__mro__", "0", "self", "assertisinstance", "mro", "nodes", "tuple", "self", "assertequal", "mro", "elts", "node", "mro"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test__bases__attribute", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test__bases__attribute", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test__bases__attribute(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        class B(object): pass\n        class C(A, B): pass\n        class D(C): pass\n        \"\"\"\n        )\n        assert isinstance(node, nodes.ClassDef)\n        bases = node.getattr(\"__bases__\")[0]\n        self.assertIsInstance(bases, nodes.Tuple)\n        self.assertEqual(len(bases.elts), 1)\n        self.assertIsInstance(bases.elts[0], nodes.ClassDef)\n        self.assertEqual(bases.elts[0].name, \"C\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test__bases__attribute", "self", "none", "node", "builder", "extract_node", "class", "a", "object", "pass", "class", "b", "object", "pass", "class", "c", "a", "b", "pass", "class", "d", "c", "pass", "assert", "isinstance", "node", "nodes", "classdef", "bases", "node", "getattr", "__bases__", "0", "self", "assertisinstance", "bases", "nodes", "tuple", "self", "assertequal", "len", "bases", "elts", "1", "self", "assertisinstance", "bases", "elts", "0", "nodes", "classdef", "self", "assertequal", "bases", "elts", "0", "name", "c"], "doc_len": 63}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_cls_special_attributes_2", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_cls_special_attributes_2", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_cls_special_attributes_2(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            class A(object): pass\n            class B(object): pass\n\n            A.__bases__ += (B,)\n        \"\"\",\n            __name__,\n        )\n        self.assertEqual(len(astroid[\"A\"].getattr(\"__bases__\")), 2)\n        self.assertIsInstance(astroid[\"A\"].getattr(\"__bases__\")[1], nodes.Tuple)\n        self.assertIsInstance(astroid[\"A\"].getattr(\"__bases__\")[0], nodes.AssignAttr)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_cls_special_attributes_2", "self", "none", "astroid", "builder", "parse", "class", "a", "object", "pass", "class", "b", "object", "pass", "a", "__bases__", "b", "__name__", "self", "assertequal", "len", "astroid", "a", "getattr", "__bases__", "2", "self", "assertisinstance", "astroid", "a", "getattr", "__bases__", "1", "nodes", "tuple", "self", "assertisinstance", "astroid", "a", "getattr", "__bases__", "0", "nodes", "assignattr"], "doc_len": 49}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_special_attributes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_special_attributes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_special_attributes(self) -> None:\n        for inst in (Instance(self.module[\"YO\"]), nodes.List(), nodes.Const(1)):\n            self.assertRaises(AttributeInferenceError, inst.getattr, \"__mro__\")\n            self.assertRaises(AttributeInferenceError, inst.getattr, \"__bases__\")\n            self.assertRaises(AttributeInferenceError, inst.getattr, \"__name__\")\n            self.assertEqual(len(inst.getattr(\"__dict__\")), 1)\n            self.assertEqual(len(inst.getattr(\"__doc__\")), 1)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_special_attributes", "self", "none", "for", "inst", "in", "instance", "self", "module", "yo", "nodes", "list", "nodes", "const", "1", "self", "assertraises", "attributeinferenceerror", "inst", "getattr", "__mro__", "self", "assertraises", "attributeinferenceerror", "inst", "getattr", "__bases__", "self", "assertraises", "attributeinferenceerror", "inst", "getattr", "__name__", "self", "assertequal", "len", "inst", "getattr", "__dict__", "1", "self", "assertequal", "len", "inst", "getattr", "__doc__", "1"], "doc_len": 52}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_navigation", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_navigation", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_navigation(self) -> None:\n        klass = self.module[\"YO\"]\n        self.assertEqual(klass.statement(), klass)\n        self.assertEqual(klass.statement(future=True), klass)\n        l_sibling = klass.previous_sibling()\n        self.assertTrue(isinstance(l_sibling, nodes.FunctionDef), l_sibling)\n        self.assertEqual(l_sibling.name, \"global_access\")\n        r_sibling = klass.next_sibling()\n        self.assertIsInstance(r_sibling, nodes.ClassDef)\n        self.assertEqual(r_sibling.name, \"YOUPI\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_navigation", "self", "none", "klass", "self", "module", "yo", "self", "assertequal", "klass", "statement", "klass", "self", "assertequal", "klass", "statement", "future", "true", "klass", "l_sibling", "klass", "previous_sibling", "self", "asserttrue", "isinstance", "l_sibling", "nodes", "functiondef", "l_sibling", "self", "assertequal", "l_sibling", "name", "global_access", "r_sibling", "klass", "next_sibling", "self", "assertisinstance", "r_sibling", "nodes", "classdef", "self", "assertequal", "r_sibling", "name", "youpi"], "doc_len": 52}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_local_attr_ancestors", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_local_attr_ancestors", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_local_attr_ancestors(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class A():\n            def __init__(self): pass\n        class B(A): pass\n        class C(B): pass\n        class D(object): pass\n        class F(): pass\n        class E(F, D): pass\n        \"\"\"\n        )\n        # Test old-style (Python 2) / new-style (Python 3+) ancestors lookups\n        klass2 = module[\"C\"]\n        it = klass2.local_attr_ancestors(\"__init__\")\n        anc_klass = next(it)\n        self.assertIsInstance(anc_klass, nodes.ClassDef)\n        self.assertEqual(anc_klass.name, \"A\")\n        anc_klass = next(it)\n        self.assertIsInstance(anc_klass, nodes.ClassDef)\n        self.assertEqual(anc_klass.name, \"object\")\n        self.assertRaises(StopIteration, partial(next, it))\n\n        it = klass2.local_attr_ancestors(\"method\")\n        self.assertRaises(StopIteration, partial(next, it))\n\n        # Test mixed-style ancestor lookups\n        klass2 = module[\"E\"]\n        it = klass2.local_attr_ancestors(\"__init__\")\n        anc_klass = next(it)\n        self.assertIsInstance(anc_klass, nodes.ClassDef)\n        self.assertEqual(anc_klass.name, \"object\")\n        self.assertRaises(StopIteration, partial(next, it))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_local_attr_ancestors", "self", "none", "module", "builder", "parse", "class", "a", "def", "__init__", "self", "pass", "class", "b", "a", "pass", "class", "c", "b", "pass", "class", "d", "object", "pass", "class", "f", "pass", "class", "e", "f", "d", "pass", "test", "old", "style", "python", "2", "new", "style", "python", "3", "ancestors", "lookups", "klass2", "module", "c", "it", "klass2", "local_attr_ancestors", "__init__", "anc_klass", "next", "it", "self", "assertisinstance", "anc_klass", "nodes", "classdef", "self", "assertequal", "anc_klass", "name", "a", "anc_klass", "next", "it", "self", "assertisinstance", "anc_klass", "nodes", "classdef", "self", "assertequal", "anc_klass", "name", "object", "self", "assertraises", "stopiteration", "partial", "next", "it", "it", "klass2", "local_attr_ancestors", "method", "self", "assertraises", "stopiteration", "partial", "next", "it", "test", "mixed", "style", "ancestor", "lookups", "klass2", "module", "e", "it", "klass2", "local_attr_ancestors", "__init__", "anc_klass", "next", "it", "self", "assertisinstance", "anc_klass", "nodes", "classdef", "self", "assertequal", "anc_klass", "name", "object", "self", "assertraises", "stopiteration", "partial", "next", "it"], "doc_len": 128}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_local_attr_mro", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_local_attr_mro", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_local_attr_mro(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class A(object):\n            def __init__(self): pass\n        class B(A):\n            def __init__(self, arg, arg2): pass\n        class C(A): pass\n        class D(C, B): pass\n        \"\"\"\n        )\n        dclass = module[\"D\"]\n        init = dclass.local_attr(\"__init__\")[0]\n        self.assertIsInstance(init, nodes.FunctionDef)\n        self.assertEqual(init.parent.name, \"B\")\n\n        cclass = module[\"C\"]\n        init = cclass.local_attr(\"__init__\")[0]\n        self.assertIsInstance(init, nodes.FunctionDef)\n        self.assertEqual(init.parent.name, \"A\")\n\n        ancestors = list(dclass.local_attr_ancestors(\"__init__\"))\n        self.assertEqual([node.name for node in ancestors], [\"B\", \"A\", \"object\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_local_attr_mro", "self", "none", "module", "builder", "parse", "class", "a", "object", "def", "__init__", "self", "pass", "class", "b", "a", "def", "__init__", "self", "arg", "arg2", "pass", "class", "c", "a", "pass", "class", "d", "c", "b", "pass", "dclass", "module", "d", "init", "dclass", "local_attr", "__init__", "0", "self", "assertisinstance", "init", "nodes", "functiondef", "self", "assertequal", "init", "parent", "name", "b", "cclass", "module", "c", "init", "cclass", "local_attr", "__init__", "0", "self", "assertisinstance", "init", "nodes", "functiondef", "self", "assertequal", "init", "parent", "name", "a", "ancestors", "list", "dclass", "local_attr_ancestors", "__init__", "self", "assertequal", "node", "name", "for", "node", "in", "ancestors", "b", "a", "object"], "doc_len": 90}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_attr_ancestors", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_attr_ancestors", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_attr_ancestors(self) -> None:\n        klass2 = self.module[\"YOUPI\"]\n        it = klass2.instance_attr_ancestors(\"yo\")\n        anc_klass = next(it)\n        self.assertIsInstance(anc_klass, nodes.ClassDef)\n        self.assertEqual(anc_klass.name, \"YO\")\n        self.assertRaises(StopIteration, partial(next, it))\n        klass2 = self.module[\"YOUPI\"]\n        it = klass2.instance_attr_ancestors(\"member\")\n        self.assertRaises(StopIteration, partial(next, it))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_attr_ancestors", "self", "none", "klass2", "self", "module", "youpi", "it", "klass2", "instance_attr_ancestors", "yo", "anc_klass", "next", "it", "self", "assertisinstance", "anc_klass", "nodes", "classdef", "self", "assertequal", "anc_klass", "name", "yo", "self", "assertraises", "stopiteration", "partial", "next", "it", "klass2", "self", "module", "youpi", "it", "klass2", "instance_attr_ancestors", "member", "self", "assertraises", "stopiteration", "partial", "next", "it"], "doc_len": 49}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_methods", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_methods", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_methods(self) -> None:\n        expected_methods = {\"__init__\", \"class_method\", \"method\", \"static_method\"}\n        klass2 = self.module[\"YOUPI\"]\n        methods = {m.name for m in klass2.methods()}\n        self.assertTrue(methods.issuperset(expected_methods))\n        methods = {m.name for m in klass2.mymethods()}\n        self.assertSetEqual(expected_methods, methods)\n        klass2 = self.module2[\"Specialization\"]\n        methods = {m.name for m in klass2.mymethods()}\n        self.assertSetEqual(set(), methods)\n        method_locals = klass2.local_attr(\"method\")\n        self.assertEqual(len(method_locals), 1)\n        self.assertEqual(method_locals[0].name, \"method\")\n        self.assertRaises(AttributeInferenceError, klass2.local_attr, \"nonexistent\")\n        methods = {m.name for m in klass2.methods()}\n        self.assertTrue(methods.issuperset(expected_methods))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_methods", "self", "none", "expected_methods", "__init__", "class_method", "method", "static_method", "klass2", "self", "module", "youpi", "methods", "m", "name", "for", "m", "in", "klass2", "methods", "self", "asserttrue", "methods", "issuperset", "expected_methods", "methods", "m", "name", "for", "m", "in", "klass2", "mymethods", "self", "assertsetequal", "expected_methods", "methods", "klass2", "self", "module2", "specialization", "methods", "m", "name", "for", "m", "in", "klass2", "mymethods", "self", "assertsetequal", "set", "methods", "method_locals", "klass2", "local_attr", "method", "self", "assertequal", "len", "method_locals", "1", "self", "assertequal", "method_locals", "0", "name", "method", "self", "assertraises", "attributeinferenceerror", "klass2", "local_attr", "nonexistent", "methods", "m", "name", "for", "m", "in", "klass2", "methods", "self", "asserttrue", "methods", "issuperset", "expected_methods"], "doc_len": 92}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_ancestors", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_ancestors", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_ancestors(self) -> None:\n        klass = self.module[\"YOUPI\"]\n        self.assertEqual([\"YO\", \"object\"], [a.name for a in klass.ancestors()])\n        klass = self.module2[\"Specialization\"]\n        self.assertEqual([\"YOUPI\", \"YO\", \"object\"], [a.name for a in klass.ancestors()])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_ancestors", "self", "none", "klass", "self", "module", "youpi", "self", "assertequal", "yo", "object", "a", "name", "for", "a", "in", "klass", "ancestors", "klass", "self", "module2", "specialization", "self", "assertequal", "youpi", "yo", "object", "a", "name", "for", "a", "in", "klass", "ancestors"], "doc_len": 39}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_type", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_type", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_type(self) -> None:\n        klass = self.module[\"YOUPI\"]\n        self.assertEqual(klass.type, \"class\")\n        klass = self.module2[\"Metaclass\"]\n        self.assertEqual(klass.type, \"metaclass\")\n        klass = self.module2[\"MyException\"]\n        self.assertEqual(klass.type, \"exception\")\n        klass = self.module2[\"MyError\"]\n        self.assertEqual(klass.type, \"exception\")\n        # the following class used to be detected as a metaclass\n        # after the fix which used instance._proxied in .ancestors(),\n        # when in fact it is a normal class\n        klass = self.module2[\"NotMetaclass\"]\n        self.assertEqual(klass.type, \"class\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_type", "self", "none", "klass", "self", "module", "youpi", "self", "assertequal", "klass", "type", "class", "klass", "self", "module2", "metaclass", "self", "assertequal", "klass", "type", "metaclass", "klass", "self", "module2", "myexception", "self", "assertequal", "klass", "type", "exception", "klass", "self", "module2", "myerror", "self", "assertequal", "klass", "type", "exception", "the", "following", "class", "used", "to", "be", "detected", "as", "a", "metaclass", "after", "the", "fix", "which", "used", "instance", "_proxied", "in", "ancestors", "when", "in", "fact", "it", "is", "a", "normal", "class", "klass", "self", "module2", "notmetaclass", "self", "assertequal", "klass", "type", "class"], "doc_len": 80}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_inner_classes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_inner_classes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_inner_classes(self) -> None:\n        eee = self.nonregr[\"Ccc\"][\"Eee\"]\n        self.assertEqual([n.name for n in eee.ancestors()], [\"Ddd\", \"Aaa\", \"object\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_inner_classes", "self", "none", "eee", "self", "nonregr", "ccc", "eee", "self", "assertequal", "n", "name", "for", "n", "in", "eee", "ancestors", "ddd", "aaa", "object"], "doc_len": 25}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_classmethod_attributes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_classmethod_attributes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_classmethod_attributes(self) -> None:\n        data = \"\"\"\n            class WebAppObject(object):\n                def registered(cls, application):\n                    cls.appli = application\n                    cls.schema = application.schema\n                    cls.config = application.config\n                    return cls\n                registered = classmethod(registered)\n        \"\"\"\n        astroid = builder.parse(data, __name__)\n        cls = astroid[\"WebAppObject\"]\n        assert_keys = [\n            \"__module__\",\n            \"__qualname__\",\n            \"appli\",\n            \"config\",\n            \"registered\",\n            \"schema\",\n        ]\n        self.assertEqual(sorted(cls.locals.keys()), assert_keys)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_classmethod_attributes", "self", "none", "data", "class", "webappobject", "object", "def", "registered", "cls", "application", "cls", "appli", "application", "cls", "schema", "application", "schema", "cls", "config", "application", "config", "return", "cls", "registered", "classmethod", "registered", "astroid", "builder", "parse", "data", "__name__", "cls", "astroid", "webappobject", "assert_keys", "__module__", "__qualname__", "appli", "config", "registered", "schema", "self", "assertequal", "sorted", "cls", "locals", "keys", "assert_keys"], "doc_len": 54}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_getattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_getattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_getattr(self) -> None:\n        data = \"\"\"\n            class WebAppObject(object):\n                appli = application\n                appli += 2\n                del self.appli\n        \"\"\"\n        astroid = builder.parse(data, __name__)\n        cls = astroid[\"WebAppObject\"]\n        # test del statement not returned by getattr\n        self.assertEqual(len(cls.getattr(\"appli\")), 2)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_getattr", "self", "none", "data", "class", "webappobject", "object", "appli", "application", "appli", "2", "del", "self", "appli", "astroid", "builder", "parse", "data", "__name__", "cls", "astroid", "webappobject", "test", "del", "statement", "not", "returned", "by", "getattr", "self", "assertequal", "len", "cls", "getattr", "appli", "2"], "doc_len": 41}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_getattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_getattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_getattr(self) -> None:\n        data = \"\"\"\n            class WebAppObject(object):\n                def __init__(self, application):\n                    self.appli = application\n                    self.appli += 2\n                    del self.appli\n         \"\"\"\n        astroid = builder.parse(data)\n        inst = Instance(astroid[\"WebAppObject\"])\n        # test del statement not returned by getattr\n        self.assertEqual(len(inst.getattr(\"appli\")), 2)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_getattr", "self", "none", "data", "class", "webappobject", "object", "def", "__init__", "self", "application", "self", "appli", "application", "self", "appli", "2", "del", "self", "appli", "astroid", "builder", "parse", "data", "inst", "instance", "astroid", "webappobject", "test", "del", "statement", "not", "returned", "by", "getattr", "self", "assertequal", "len", "inst", "getattr", "appli", "2"], "doc_len": 47}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_getattr_with_class_attr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_getattr_with_class_attr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_getattr_with_class_attr(self) -> None:\n        data = \"\"\"\n            class Parent:\n                aa = 1\n                cc = 1\n\n            class Klass(Parent):\n                aa = 0\n                bb = 0\n\n                def incr(self, val):\n                    self.cc = self.aa\n                    if val > self.aa:\n                        val = self.aa\n                    if val < self.bb:\n                        val = self.bb\n                    self.aa += val\n        \"\"\"\n        astroid = builder.parse(data)\n        inst = Instance(astroid[\"Klass\"])\n        self.assertEqual(len(inst.getattr(\"aa\")), 3, inst.getattr(\"aa\"))\n        self.assertEqual(len(inst.getattr(\"bb\")), 1, inst.getattr(\"bb\"))\n        self.assertEqual(len(inst.getattr(\"cc\")), 2, inst.getattr(\"cc\"))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_getattr_with_class_attr", "self", "none", "data", "class", "parent", "aa", "1", "cc", "1", "class", "klass", "parent", "aa", "0", "bb", "0", "def", "incr", "self", "val", "self", "cc", "self", "aa", "if", "val", "self", "aa", "val", "self", "aa", "if", "val", "self", "bb", "val", "self", "bb", "self", "aa", "val", "astroid", "builder", "parse", "data", "inst", "instance", "astroid", "klass", "self", "assertequal", "len", "inst", "getattr", "aa", "3", "inst", "getattr", "aa", "self", "assertequal", "len", "inst", "getattr", "bb", "1", "inst", "getattr", "bb", "self", "assertequal", "len", "inst", "getattr", "cc", "2", "inst", "getattr", "cc"], "doc_len": 85}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_getattr_method_transform", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_getattr_method_transform", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_getattr_method_transform(self) -> None:\n        data = \"\"\"\n            class Clazz(object):\n\n                def m1(self, value):\n                    self.value = value\n                m2 = m1\n\n            def func(arg1, arg2):\n                \"function that will be used as a method\"\n                return arg1.value + arg2\n\n            Clazz.m3 = func\n            inst = Clazz()\n            inst.m4 = func\n        \"\"\"\n        astroid = builder.parse(data)\n        cls = astroid[\"Clazz\"]\n        # test del statement not returned by getattr\n        for method in (\"m1\", \"m2\", \"m3\"):\n            inferred = list(cls.igetattr(method))\n            self.assertEqual(len(inferred), 1)\n            self.assertIsInstance(inferred[0], UnboundMethod)\n            inferred = list(Instance(cls).igetattr(method))\n            self.assertEqual(len(inferred), 1)\n            self.assertIsInstance(inferred[0], BoundMethod)\n        inferred = list(Instance(cls).igetattr(\"m4\"))\n        self.assertEqual(len(inferred), 1)\n        self.assertIsInstance(inferred[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_getattr_method_transform", "self", "none", "data", "class", "clazz", "object", "def", "m1", "self", "value", "self", "value", "value", "m2", "m1", "def", "func", "arg1", "arg2", "function", "that", "will", "be", "used", "as", "a", "method", "return", "arg1", "value", "arg2", "clazz", "m3", "func", "inst", "clazz", "inst", "m4", "func", "astroid", "builder", "parse", "data", "cls", "astroid", "clazz", "test", "del", "statement", "not", "returned", "by", "getattr", "for", "method", "in", "m1", "m2", "m3", "inferred", "list", "cls", "igetattr", "method", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "unboundmethod", "inferred", "list", "instance", "cls", "igetattr", "method", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "boundmethod", "inferred", "list", "instance", "cls", "igetattr", "m4", "self", "assertequal", "len", "inferred", "1", "self", "assertisinstance", "inferred", "0", "nodes", "functiondef"], "doc_len": 113}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_getattr_from_grandpa", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_getattr_from_grandpa", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_getattr_from_grandpa(self) -> None:\n        data = \"\"\"\n            class Future:\n                attr = 1\n\n            class Present(Future):\n                pass\n\n            class Past(Present):\n                pass\n        \"\"\"\n        astroid = builder.parse(data)\n        past = astroid[\"Past\"]\n        attr = past.getattr(\"attr\")\n        self.assertEqual(len(attr), 1)\n        attr1 = attr[0]\n        self.assertIsInstance(attr1, nodes.AssignName)\n        self.assertEqual(attr1.name, \"attr\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_getattr_from_grandpa", "self", "none", "data", "class", "future", "attr", "1", "class", "present", "future", "pass", "class", "past", "present", "pass", "astroid", "builder", "parse", "data", "past", "astroid", "past", "attr", "past", "getattr", "attr", "self", "assertequal", "len", "attr", "1", "attr1", "attr", "0", "self", "assertisinstance", "attr1", "nodes", "assignname", "self", "assertequal", "attr1", "name", "attr"], "doc_len": 50}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_function_with_decorator_lineno", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_function_with_decorator_lineno", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_function_with_decorator_lineno(self) -> None:\n        data = \"\"\"\n            @f(a=2,\n               b=3)\n            def g1(x):\n                print(x)\n\n            @f(a=2,\n               b=3)\n            def g2():\n                pass\n        \"\"\"\n        astroid = builder.parse(data)\n        self.assertEqual(astroid[\"g1\"].fromlineno, 4)\n        self.assertEqual(astroid[\"g1\"].tolineno, 5)\n        self.assertEqual(astroid[\"g2\"].fromlineno, 9)\n        self.assertEqual(astroid[\"g2\"].tolineno, 10)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_function_with_decorator_lineno", "self", "none", "data", "f", "a", "2", "b", "3", "def", "g1", "x", "print", "x", "f", "a", "2", "b", "3", "def", "g2", "pass", "astroid", "builder", "parse", "data", "self", "assertequal", "astroid", "g1", "fromlineno", "4", "self", "assertequal", "astroid", "g1", "tolineno", "5", "self", "assertequal", "astroid", "g2", "fromlineno", "9", "self", "assertequal", "astroid", "g2", "tolineno", "10"], "doc_len": 55}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_error", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_error", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_error(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            class Test(object):\n                __metaclass__ = typ\n        \"\"\"\n        )\n        klass = astroid[\"Test\"]\n        self.assertFalse(klass.metaclass())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_error", "self", "none", "astroid", "builder", "parse", "class", "test", "object", "__metaclass__", "typ", "klass", "astroid", "test", "self", "assertfalse", "klass", "metaclass"], "doc_len": 23}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_yes_leak", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_yes_leak", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_yes_leak(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            # notice `ab` instead of `abc`\n            from ab import ABCMeta\n\n            class Meta(object):\n                __metaclass__ = ABCMeta\n        \"\"\"\n        )\n        klass = astroid[\"Meta\"]\n        self.assertIsNone(klass.metaclass())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_yes_leak", "self", "none", "astroid", "builder", "parse", "notice", "ab", "instead", "of", "abc", "from", "ab", "import", "abcmeta", "class", "meta", "object", "__metaclass__", "abcmeta", "klass", "astroid", "meta", "self", "assertisnone", "klass", "metaclass"], "doc_len": 32}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_type", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_type", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_type(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n            def with_metaclass(meta, base=object):\n                return meta(\"NewBase\", (base, ), {})\n\n            class ClassWithMeta(with_metaclass(type)): #@\n                pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        self.assertEqual(\n            [\"NewBase\", \"object\"], [base.name for base in klass.ancestors()]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_type", "self", "none", "klass", "builder", "extract_node", "def", "with_metaclass", "meta", "base", "object", "return", "meta", "newbase", "base", "class", "classwithmeta", "with_metaclass", "type", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "self", "assertequal", "newbase", "object", "base", "name", "for", "base", "in", "klass", "ancestors"], "doc_len": 41}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_no_infinite_metaclass_loop", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_no_infinite_metaclass_loop", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_no_infinite_metaclass_loop(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n            class SSS(object):\n\n                class JJJ(object):\n                    pass\n\n                @classmethod\n                def Init(cls):\n                    cls.JJJ = type('JJJ', (cls.JJJ,), {})\n\n            class AAA(SSS):\n                pass\n\n            class BBB(AAA.JJJ):\n                pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        self.assertFalse(_is_metaclass(klass))\n        ancestors = [base.name for base in klass.ancestors()]\n        self.assertIn(\"object\", ancestors)\n        self.assertIn(\"JJJ\", ancestors)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_no_infinite_metaclass_loop", "self", "none", "klass", "builder", "extract_node", "class", "sss", "object", "class", "jjj", "object", "pass", "classmethod", "def", "init", "cls", "cls", "jjj", "type", "jjj", "cls", "jjj", "class", "aaa", "sss", "pass", "class", "bbb", "aaa", "jjj", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "self", "assertfalse", "_is_metaclass", "klass", "ancestors", "base", "name", "for", "base", "in", "klass", "ancestors", "self", "assertin", "object", "ancestors", "self", "assertin", "jjj", "ancestors"], "doc_len": 62}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_no_infinite_metaclass_loop_with_redefine", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_no_infinite_metaclass_loop_with_redefine", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_no_infinite_metaclass_loop_with_redefine(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n            import datetime\n\n            class A(datetime.date): #@\n                @classmethod\n                def now(cls):\n                    return cls()\n\n            class B(datetime.date): #@\n                pass\n\n            datetime.date = A\n            datetime.date = B\n        \"\"\"\n        )\n        for klass in ast_nodes:\n            self.assertEqual(None, klass.metaclass())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_no_infinite_metaclass_loop_with_redefine", "self", "none", "ast_nodes", "builder", "extract_node", "import", "datetime", "class", "a", "datetime", "date", "classmethod", "def", "now", "cls", "return", "cls", "class", "b", "datetime", "date", "pass", "datetime", "date", "a", "datetime", "date", "b", "for", "klass", "in", "ast_nodes", "self", "assertequal", "none", "klass", "metaclass"], "doc_len": 43}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_generator_hack", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_generator_hack", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_generator_hack(self):\n        klass = builder.extract_node(\n            \"\"\"\n            import six\n\n            class WithMeta(six.with_metaclass(type, object)): #@\n                pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        self.assertEqual([\"object\"], [base.name for base in klass.ancestors()])\n        self.assertEqual(\"type\", klass.metaclass().name)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_generator_hack", "self", "klass", "builder", "extract_node", "import", "six", "class", "withmeta", "six", "with_metaclass", "type", "object", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "self", "assertequal", "object", "base", "name", "for", "base", "in", "klass", "ancestors", "self", "assertequal", "type", "klass", "metaclass", "name"], "doc_len": 40}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_add_metaclass", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_add_metaclass", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_add_metaclass(self) -> None:\n        klass = builder.extract_node(\n            \"\"\"\n        import abc\n\n        class WithMeta(object, metaclass=abc.ABCMeta):\n            pass\n        \"\"\"\n        )\n        assert isinstance(klass, nodes.ClassDef)\n        inferred = next(klass.infer())\n        metaclass = inferred.metaclass()\n        self.assertIsInstance(metaclass, nodes.ClassDef)\n        self.assertIn(metaclass.qname(), (\"abc.ABCMeta\", \"_py_abc.ABCMeta\"))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_add_metaclass", "self", "none", "klass", "builder", "extract_node", "import", "abc", "class", "withmeta", "object", "metaclass", "abc", "abcmeta", "pass", "assert", "isinstance", "klass", "nodes", "classdef", "inferred", "next", "klass", "infer", "metaclass", "inferred", "metaclass", "self", "assertisinstance", "metaclass", "nodes", "classdef", "self", "assertin", "metaclass", "qname", "abc", "abcmeta", "_py_abc", "abcmeta"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_using_invalid_six_add_metaclass_call", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_using_invalid_six_add_metaclass_call", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_using_invalid_six_add_metaclass_call(self):\n        klass = builder.extract_node(\n            \"\"\"\n        import six\n        @six.add_metaclass()\n        class Invalid(object):\n            pass\n        \"\"\"\n        )\n        inferred = next(klass.infer())\n        self.assertIsNone(inferred.metaclass())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_using_invalid_six_add_metaclass_call", "self", "klass", "builder", "extract_node", "import", "six", "six", "add_metaclass", "class", "invalid", "object", "pass", "inferred", "next", "klass", "infer", "self", "assertisnone", "inferred", "metaclass"], "doc_len": 26}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_nonregr_infer_callresult", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_nonregr_infer_callresult", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_nonregr_infer_callresult(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            class Delegate(object):\n                def __get__(self, obj, cls):\n                    return getattr(obj._subject, self.attribute)\n\n            class CompositeBuilder(object):\n                __call__ = Delegate()\n\n            builder = CompositeBuilder(result, composite)\n            tgts = builder()\n        \"\"\"\n        )\n        instance = astroid[\"tgts\"]\n        # used to raise \"'_Yes' object is not iterable\", see\n        # https://bitbucket.org/logilab/astroid/issue/17\n        self.assertEqual(list(instance.infer()), [util.Uninferable])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_nonregr_infer_callresult", "self", "none", "astroid", "builder", "parse", "class", "delegate", "object", "def", "__get__", "self", "obj", "cls", "return", "getattr", "obj", "_subject", "self", "attribute", "class", "compositebuilder", "object", "__call__", "delegate", "builder", "compositebuilder", "result", "composite", "tgts", "builder", "instance", "astroid", "tgts", "used", "to", "raise", "_yes", "object", "is", "not", "iterable", "see", "https", "bitbucket", "org", "logilab", "astroid", "issue", "17", "self", "assertequal", "list", "instance", "infer", "util", "uninferable"], "doc_len": 62}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_slots", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_slots", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_slots(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n            from collections import deque\n            from textwrap import dedent\n\n            class First(object): #@\n                __slots__ = (\"a\", \"b\", 1)\n            class Second(object): #@\n                __slots__ = \"a\"\n            class Third(object): #@\n                __slots__ = deque([\"a\", \"b\", \"c\"])\n            class Fourth(object): #@\n                __slots__ = {\"a\": \"a\", \"b\": \"b\"}\n            class Fifth(object): #@\n                __slots__ = list\n            class Sixth(object): #@\n                __slots__ = \"\"\n            class Seventh(object): #@\n                __slots__ = dedent.__name__\n            class Eight(object): #@\n                __slots__ = (\"parens\")\n            class Ninth(object): #@\n                pass\n            class Ten(object): #@\n                __slots__ = dict({\"a\": \"b\", \"c\": \"d\"})\n        \"\"\"\n        )\n        expected = [\n            (\"First\", (\"a\", \"b\")),\n            (\"Second\", (\"a\",)),\n            (\"Third\", None),\n            (\"Fourth\", (\"a\", \"b\")),\n            (\"Fifth\", None),\n            (\"Sixth\", None),\n            (\"Seventh\", (\"dedent\",)),\n            (\"Eight\", (\"parens\",)),\n            (\"Ninth\", None),\n            (\"Ten\", (\"a\", \"c\")),\n        ]\n        for cls, expected_value in expected:\n            slots = astroid[cls].slots()\n            if expected_value is None:\n                self.assertIsNone(slots)\n            else:\n                self.assertEqual(list(expected_value), [node.value for node in slots])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_slots", "self", "none", "astroid", "builder", "parse", "from", "collections", "import", "deque", "from", "textwrap", "import", "dedent", "class", "first", "object", "__slots__", "a", "b", "1", "class", "second", "object", "__slots__", "a", "class", "third", "object", "__slots__", "deque", "a", "b", "c", "class", "fourth", "object", "__slots__", "a", "a", "b", "b", "class", "fifth", "object", "__slots__", "list", "class", "sixth", "object", "__slots__", "class", "seventh", "object", "__slots__", "dedent", "__name__", "class", "eight", "object", "__slots__", "parens", "class", "ninth", "object", "pass", "class", "ten", "object", "__slots__", "dict", "a", "b", "c", "d", "expected", "first", "a", "b", "second", "a", "third", "none", "fourth", "a", "b", "fifth", "none", "sixth", "none", "seventh", "dedent", "eight", "parens", "ninth", "none", "ten", "a", "c", "for", "cls", "expected_value", "in", "expected", "slots", "astroid", "cls", "slots", "if", "expected_value", "is", "none", "self", "assertisnone", "slots", "else", "self", "assertequal", "list", "expected_value", "node", "value", "for", "node", "in", "slots"], "doc_len": 131}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_slots_for_dict_keys", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_slots_for_dict_keys", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_slots_for_dict_keys(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class Issue(object):\n          SlotDefaults = {'id': 0, 'id1':1}\n          __slots__ = SlotDefaults.keys()\n        \"\"\"\n        )\n        cls = module[\"Issue\"]\n        slots = cls.slots()\n        self.assertEqual(len(slots), 2)\n        self.assertEqual(slots[0].value, \"id\")\n        self.assertEqual(slots[1].value, \"id1\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_slots_for_dict_keys", "self", "none", "module", "builder", "parse", "class", "issue", "object", "slotdefaults", "id", "0", "id1", "1", "__slots__", "slotdefaults", "keys", "cls", "module", "issue", "slots", "cls", "slots", "self", "assertequal", "len", "slots", "2", "self", "assertequal", "slots", "0", "value", "id", "self", "assertequal", "slots", "1", "value", "id1"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_slots_empty_list_of_slots", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_slots_empty_list_of_slots", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_slots_empty_list_of_slots(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class Klass(object):\n            __slots__ = ()\n        \"\"\"\n        )\n        cls = module[\"Klass\"]\n        self.assertEqual(cls.slots(), [])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_slots_empty_list_of_slots", "self", "none", "module", "builder", "parse", "class", "klass", "object", "__slots__", "cls", "module", "klass", "self", "assertequal", "cls", "slots"], "doc_len": 22}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_slots_taken_from_parents", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_slots_taken_from_parents", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_slots_taken_from_parents(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class FirstParent(object):\n            __slots__ = ('a', 'b', 'c')\n        class SecondParent(FirstParent):\n            __slots__ = ('d', 'e')\n        class Third(SecondParent):\n            __slots__ = ('d', )\n        \"\"\"\n        )\n        cls = module[\"Third\"]\n        slots = cls.slots()\n        self.assertEqual(\n            sorted({slot.value for slot in slots}), [\"a\", \"b\", \"c\", \"d\", \"e\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_slots_taken_from_parents", "self", "none", "module", "builder", "parse", "class", "firstparent", "object", "__slots__", "a", "b", "c", "class", "secondparent", "firstparent", "__slots__", "d", "e", "class", "third", "secondparent", "__slots__", "d", "cls", "module", "third", "slots", "cls", "slots", "self", "assertequal", "sorted", "slot", "value", "for", "slot", "in", "slots", "a", "b", "c", "d", "e"], "doc_len": 49}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_all_ancestors_need_slots", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_all_ancestors_need_slots", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_all_ancestors_need_slots(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class A(object):\n            __slots__ = ('a', )\n        class B(A): pass\n        class C(B):\n            __slots__ = ('a', )\n        \"\"\"\n        )\n        cls = module[\"C\"]\n        self.assertIsNone(cls.slots())\n        cls = module[\"B\"]\n        self.assertIsNone(cls.slots())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_all_ancestors_need_slots", "self", "none", "module", "builder", "parse", "class", "a", "object", "__slots__", "a", "class", "b", "a", "pass", "class", "c", "b", "__slots__", "a", "cls", "module", "c", "self", "assertisnone", "cls", "slots", "cls", "module", "b", "self", "assertisnone", "cls", "slots"], "doc_len": 39}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_slots_added_dynamically_still_inferred", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_slots_added_dynamically_still_inferred", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_slots_added_dynamically_still_inferred(self) -> None:\n        code = \"\"\"\n        class NodeBase(object):\n            __slots__ = \"a\", \"b\"\n\n            if Options.isFullCompat():\n                __slots__ += (\"c\",)\n\n        \"\"\"\n        node = builder.extract_node(code)\n        inferred = next(node.infer())\n        slots = inferred.slots()\n        assert len(slots) == 3, slots\n        assert [slot.value for slot in slots] == [\"a\", \"b\", \"c\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_slots_added_dynamically_still_inferred", "self", "none", "code", "class", "nodebase", "object", "__slots__", "a", "b", "if", "options", "isfullcompat", "__slots__", "c", "node", "builder", "extract_node", "code", "inferred", "next", "node", "infer", "slots", "inferred", "slots", "assert", "len", "slots", "3", "slots", "assert", "slot", "value", "for", "slot", "in", "slots", "a", "b", "c"], "doc_len": 46}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.assertEqualMro", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "assertEqualMro", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def assertEqualMro(self, klass: nodes.ClassDef, expected_mro: List[str]) -> None:\n        self.assertEqual([member.name for member in klass.mro()], expected_mro)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "assertequalmro", "self", "klass", "nodes", "classdef", "expected_mro", "list", "str", "none", "self", "assertequal", "member", "name", "for", "member", "in", "klass", "mro", "expected_mro"], "doc_len": 24}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.assertEqualMroQName", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "assertEqualMroQName", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def assertEqualMroQName(\n        self, klass: nodes.ClassDef, expected_mro: List[str]\n    ) -> None:\n        self.assertEqual([member.qname() for member in klass.mro()], expected_mro)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "assertequalmroqname", "self", "klass", "nodes", "classdef", "expected_mro", "list", "str", "none", "self", "assertequal", "member", "qname", "for", "member", "in", "klass", "mro", "expected_mro"], "doc_len": 24}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_with_metaclass_mro", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_with_metaclass_mro", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_with_metaclass_mro(self):\n        astroid = builder.parse(\n            \"\"\"\n        import six\n\n        class C(object):\n            pass\n        class B(C):\n            pass\n        class A(six.with_metaclass(type, B)):\n            pass\n        \"\"\"\n        )\n        self.assertEqualMro(astroid[\"A\"], [\"A\", \"B\", \"C\", \"object\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_with_metaclass_mro", "self", "astroid", "builder", "parse", "import", "six", "class", "c", "object", "pass", "class", "b", "c", "pass", "class", "a", "six", "with_metaclass", "type", "b", "pass", "self", "assertequalmro", "astroid", "a", "a", "b", "c", "object"], "doc_len": 35}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro(self) -> None:\n        astroid = builder.parse(\n            \"\"\"\n        class C(object): pass\n        class D(dict, C): pass\n\n        class A1(object): pass\n        class B1(A1): pass\n        class C1(A1): pass\n        class D1(B1, C1): pass\n        class E1(C1, B1): pass\n        class F1(D1, E1): pass\n        class G1(E1, D1): pass\n\n        class Boat(object): pass\n        class DayBoat(Boat): pass\n        class WheelBoat(Boat): pass\n        class EngineLess(DayBoat): pass\n        class SmallMultihull(DayBoat): pass\n        class PedalWheelBoat(EngineLess, WheelBoat): pass\n        class SmallCatamaran(SmallMultihull): pass\n        class Pedalo(PedalWheelBoat, SmallCatamaran): pass\n\n        class OuterA(object):\n            class Inner(object):\n                pass\n        class OuterB(OuterA):\n            class Inner(OuterA.Inner):\n                pass\n        class OuterC(OuterA):\n            class Inner(OuterA.Inner):\n                pass\n        class OuterD(OuterC):\n            class Inner(OuterC.Inner, OuterB.Inner):\n                pass\n        class Duplicates(str, str): pass\n\n        \"\"\"\n        )\n        self.assertEqualMro(astroid[\"D\"], [\"D\", \"dict\", \"C\", \"object\"])\n        self.assertEqualMro(astroid[\"D1\"], [\"D1\", \"B1\", \"C1\", \"A1\", \"object\"])\n        self.assertEqualMro(astroid[\"E1\"], [\"E1\", \"C1\", \"B1\", \"A1\", \"object\"])\n        with self.assertRaises(InconsistentMroError) as cm:\n            astroid[\"F1\"].mro()\n        A1 = astroid.getattr(\"A1\")[0]\n        B1 = astroid.getattr(\"B1\")[0]\n        C1 = astroid.getattr(\"C1\")[0]\n        object_ = MANAGER.astroid_cache[\"builtins\"].getattr(\"object\")[0]\n        self.assertEqual(\n            cm.exception.mros, [[B1, C1, A1, object_], [C1, B1, A1, object_]]\n        )\n        with self.assertRaises(InconsistentMroError) as cm:\n            astroid[\"G1\"].mro()\n        self.assertEqual(\n            cm.exception.mros, [[C1, B1, A1, object_], [B1, C1, A1, object_]]\n        )\n        self.assertEqualMro(\n            astroid[\"PedalWheelBoat\"],\n            [\"PedalWheelBoat\", \"EngineLess\", \"DayBoat\", \"WheelBoat\", \"Boat\", \"object\"],\n        )\n\n        self.assertEqualMro(\n            astroid[\"SmallCatamaran\"],\n            [\"SmallCatamaran\", \"SmallMultihull\", \"DayBoat\", \"Boat\", \"object\"],\n        )\n\n        self.assertEqualMro(\n            astroid[\"Pedalo\"],\n            [\n                \"Pedalo\",\n                \"PedalWheelBoat\",\n                \"EngineLess\",\n                \"SmallCatamaran\",\n                \"SmallMultihull\",\n                \"DayBoat\",\n                \"WheelBoat\",\n                \"Boat\",\n                \"object\",\n            ],\n        )\n\n        self.assertEqualMro(\n            astroid[\"OuterD\"][\"Inner\"], [\"Inner\", \"Inner\", \"Inner\", \"Inner\", \"object\"]\n        )\n\n        with self.assertRaises(DuplicateBasesError) as cm:\n            astroid[\"Duplicates\"].mro()\n        Duplicates = astroid.getattr(\"Duplicates\")[0]\n        self.assertEqual(cm.exception.cls, Duplicates)\n        self.assertIsInstance(cm.exception, MroError)\n        self.assertIsInstance(cm.exception, ResolveError)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro", "self", "none", "astroid", "builder", "parse", "class", "c", "object", "pass", "class", "d", "dict", "c", "pass", "class", "a1", "object", "pass", "class", "b1", "a1", "pass", "class", "c1", "a1", "pass", "class", "d1", "b1", "c1", "pass", "class", "e1", "c1", "b1", "pass", "class", "f1", "d1", "e1", "pass", "class", "g1", "e1", "d1", "pass", "class", "boat", "object", "pass", "class", "dayboat", "boat", "pass", "class", "wheelboat", "boat", "pass", "class", "engineless", "dayboat", "pass", "class", "smallmultihull", "dayboat", "pass", "class", "pedalwheelboat", "engineless", "wheelboat", "pass", "class", "smallcatamaran", "smallmultihull", "pass", "class", "pedalo", "pedalwheelboat", "smallcatamaran", "pass", "class", "outera", "object", "class", "inner", "object", "pass", "class", "outerb", "outera", "class", "inner", "outera", "inner", "pass", "class", "outerc", "outera", "class", "inner", "outera", "inner", "pass", "class", "outerd", "outerc", "class", "inner", "outerc", "inner", "outerb", "inner", "pass", "class", "duplicates", "str", "str", "pass", "self", "assertequalmro", "astroid", "d", "d", "dict", "c", "object", "self", "assertequalmro", "astroid", "d1", "d1", "b1", "c1", "a1", "object", "self", "assertequalmro", "astroid", "e1", "e1", "c1", "b1", "a1", "object", "with", "self", "assertraises", "inconsistentmroerror", "as", "cm", "astroid", "f1", "mro", "a1", "astroid", "getattr", "a1", "0", "b1", "astroid", "getattr", "b1", "0", "c1", "astroid", "getattr", "c1", "0", "object_", "manager", "astroid_cache", "builtins", "getattr", "object", "0", "self", "assertequal", "cm", "exception", "mros", "b1", "c1", "a1", "object_", "c1", "b1", "a1", "object_", "with", "self", "assertraises", "inconsistentmroerror", "as", "cm", "astroid", "g1", "mro", "self", "assertequal", "cm", "exception", "mros", "c1", "b1", "a1", "object_", "b1", "c1", "a1", "object_", "self", "assertequalmro", "astroid", "pedalwheelboat", "pedalwheelboat", "engineless", "dayboat", "wheelboat", "boat", "object", "self", "assertequalmro", "astroid", "smallcatamaran", "smallcatamaran", "smallmultihull", "dayboat", "boat", "object", "self", "assertequalmro", "astroid", "pedalo", "pedalo", "pedalwheelboat", "engineless", "smallcatamaran", "smallmultihull", "dayboat", "wheelboat", "boat", "object", "self", "assertequalmro", "astroid", "outerd", "inner", "inner", "inner", "inner", "inner", "object", "with", "self", "assertraises", "duplicatebaseserror", "as", "cm", "astroid", "duplicates", "mro", "duplicates", "astroid", "getattr", "duplicates", "0", "self", "assertequal", "cm", "exception", "cls", "duplicates", "self", "assertisinstance", "cm", "exception", "mroerror", "self", "assertisinstance", "cm", "exception", "resolveerror"], "doc_len": 288}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_with_factories", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_with_factories", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_with_factories(self) -> None:\n        cls = builder.extract_node(\n            \"\"\"\n        def MixinFactory(cls):\n            mixin_name = '{}Mixin'.format(cls.__name__)\n            mixin_bases = (object,)\n            mixin_attrs = {}\n            mixin = type(mixin_name, mixin_bases, mixin_attrs)\n            return mixin\n        class MixinA(MixinFactory(int)):\n            pass\n        class MixinB(MixinFactory(str)):\n            pass\n        class Base(object):\n            pass\n        class ClassA(MixinA, Base):\n            pass\n        class ClassB(MixinB, ClassA):\n            pass\n        class FinalClass(ClassB):\n            def __init__(self):\n                self.name = 'x'\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMro(\n            cls,\n            [\n                \"FinalClass\",\n                \"ClassB\",\n                \"MixinB\",\n                \"\",\n                \"ClassA\",\n                \"MixinA\",\n                \"\",\n                \"Base\",\n                \"object\",\n            ],\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_with_factories", "self", "none", "cls", "builder", "extract_node", "def", "mixinfactory", "cls", "mixin_name", "mixin", "format", "cls", "__name__", "mixin_bases", "object", "mixin_attrs", "mixin", "type", "mixin_name", "mixin_bases", "mixin_attrs", "return", "mixin", "class", "mixina", "mixinfactory", "int", "pass", "class", "mixinb", "mixinfactory", "str", "pass", "class", "base", "object", "pass", "class", "classa", "mixina", "base", "pass", "class", "classb", "mixinb", "classa", "pass", "class", "finalclass", "classb", "def", "__init__", "self", "self", "name", "x", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmro", "cls", "finalclass", "classb", "mixinb", "classa", "mixina", "base", "object"], "doc_len": 77}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_with_attribute_classes", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_with_attribute_classes", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_with_attribute_classes(self) -> None:\n        cls = builder.extract_node(\n            \"\"\"\n        class A:\n            pass\n        class B:\n            pass\n        class Scope:\n            pass\n        scope = Scope()\n        scope.A = A\n        scope.B = B\n        class C(scope.A, scope.B):\n            pass\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMro(cls, [\"C\", \"A\", \"B\", \"object\"])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_with_attribute_classes", "self", "none", "cls", "builder", "extract_node", "class", "a", "pass", "class", "b", "pass", "class", "scope", "pass", "scope", "scope", "scope", "a", "a", "scope", "b", "b", "class", "c", "scope", "a", "scope", "b", "pass", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmro", "cls", "c", "a", "b", "object"], "doc_len": 47}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_1", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_1", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_1(self):\n        cls = builder.extract_node(\n            \"\"\"\n        import typing\n        T = typing.TypeVar('T')\n        class A(typing.Generic[T]): ...\n        class B: ...\n        class C(A[T], B): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".C\", \".A\", \"typing.Generic\", \".B\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_1", "self", "cls", "builder", "extract_node", "import", "typing", "t", "typing", "typevar", "t", "class", "a", "typing", "generic", "t", "class", "b", "class", "c", "a", "t", "b", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "c", "a", "typing", "generic", "b", "builtins", "object"], "doc_len": 43}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_2", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_2", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_2(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A: ...\n        class B(Generic[T]): ...\n        class C(Generic[T], A, B[T]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".C\", \".A\", \".B\", \"typing.Generic\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_2", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "class", "b", "generic", "t", "class", "c", "generic", "t", "a", "b", "t", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "c", "a", "b", "typing", "generic", "builtins", "object"], "doc_len": 46}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_3", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_3", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_3(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A: ...\n        class B(A, Generic[T]): ...\n        class C(Generic[T]): ...\n        class D(B[T], C[T], Generic[T]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".D\", \".B\", \".A\", \".C\", \"typing.Generic\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_3", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "class", "b", "a", "generic", "t", "class", "c", "generic", "t", "class", "d", "b", "t", "c", "t", "generic", "t", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "d", "b", "a", "c", "typing", "generic", "builtins", "object"], "doc_len": 53}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_4", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_4", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_4(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A: ...\n        class B(Generic[T]): ...\n        class C(A, Generic[T], B[T]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".C\", \".A\", \".B\", \"typing.Generic\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_4", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "class", "b", "generic", "t", "class", "c", "a", "generic", "t", "b", "t", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "c", "a", "b", "typing", "generic", "builtins", "object"], "doc_len": 46}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_5", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_5", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_5(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T1 = TypeVar('T1')\n        T2 = TypeVar('T2')\n        class A(Generic[T1]): ...\n        class B(Generic[T2]): ...\n        class C(A[T1], B[T2]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".C\", \".A\", \".B\", \"typing.Generic\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_5", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t1", "typevar", "t1", "t2", "typevar", "t2", "class", "a", "generic", "t1", "class", "b", "generic", "t2", "class", "c", "a", "t1", "b", "t2", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "c", "a", "b", "typing", "generic", "builtins", "object"], "doc_len": 50}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_6", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_6", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_6(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic as TGeneric, TypeVar\n        T = TypeVar('T')\n        class Generic: ...\n        class A(Generic): ...\n        class B(TGeneric[T]): ...\n        class C(A, B[T]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".C\", \".A\", \".Generic\", \".B\", \"typing.Generic\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_6", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "as", "tgeneric", "typevar", "t", "typevar", "t", "class", "generic", "class", "a", "generic", "class", "b", "tgeneric", "t", "class", "c", "a", "b", "t", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "c", "a", "generic", "b", "typing", "generic", "builtins", "object"], "doc_len": 50}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_7", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_7", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_7(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A(): ...\n        class B(Generic[T]): ...\n        class C(A, B[T]): ...\n        class D: ...\n        class E(C[str], D): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqualMroQName(\n            cls, [\".E\", \".C\", \".A\", \".B\", \"typing.Generic\", \".D\", \"builtins.object\"]\n        )\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_7", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "class", "b", "generic", "t", "class", "c", "a", "b", "t", "class", "d", "class", "e", "c", "str", "d", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequalmroqname", "cls", "e", "c", "a", "b", "typing", "generic", "d", "builtins", "object"], "doc_len": 53}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_error_1", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_error_1", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_error_1(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T1 = TypeVar('T1')\n        T2 = TypeVar('T2')\n        class A(Generic[T1], Generic[T2]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        with self.assertRaises(DuplicateBasesError):\n            cls.mro()\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_error_1", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t1", "typevar", "t1", "t2", "typevar", "t2", "class", "a", "generic", "t1", "generic", "t2", "assert", "isinstance", "cls", "nodes", "classdef", "with", "self", "assertraises", "duplicatebaseserror", "cls", "mro"], "doc_len": 38}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_mro_generic_error_2", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_mro_generic_error_2", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_mro_generic_error_2(self):\n        cls = builder.extract_node(\n            \"\"\"\n        from typing import Generic, TypeVar\n        T = TypeVar('T')\n        class A(Generic[T]): ...\n        class B(A[T], A[T]): ...\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        with self.assertRaises(DuplicateBasesError):\n            cls.mro()\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_mro_generic_error_2", "self", "cls", "builder", "extract_node", "from", "typing", "import", "generic", "typevar", "t", "typevar", "t", "class", "a", "generic", "t", "class", "b", "a", "t", "a", "t", "assert", "isinstance", "cls", "nodes", "classdef", "with", "self", "assertraises", "duplicatebaseserror", "cls", "mro"], "doc_len": 39}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_generator_from_infer_call_result_parent", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_generator_from_infer_call_result_parent", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_generator_from_infer_call_result_parent(self) -> None:\n        func = builder.extract_node(\n            \"\"\"\n        import contextlib\n\n        @contextlib.contextmanager\n        def test(): #@\n            yield\n        \"\"\"\n        )\n        assert isinstance(func, nodes.FunctionDef)\n        result = next(func.infer_call_result())\n        self.assertIsInstance(result, Generator)\n        self.assertEqual(result.parent, func)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_generator_from_infer_call_result_parent", "self", "none", "func", "builder", "extract_node", "import", "contextlib", "contextlib", "contextmanager", "def", "test", "yield", "assert", "isinstance", "func", "nodes", "functiondef", "result", "next", "func", "infer_call_result", "self", "assertisinstance", "result", "generator", "self", "assertequal", "result", "parent", "func"], "doc_len": 36}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_type_three_arguments", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_type_three_arguments", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_type_three_arguments(self) -> None:\n        classes = builder.extract_node(\n            \"\"\"\n        type('A', (object, ), {\"a\": 1, \"b\": 2, missing: 3}) #@\n        \"\"\"\n        )\n        assert isinstance(classes, nodes.Call)\n        first = next(classes.infer())\n        self.assertIsInstance(first, nodes.ClassDef)\n        self.assertEqual(first.name, \"A\")\n        self.assertEqual(first.basenames, [\"object\"])\n        self.assertIsInstance(first[\"a\"], nodes.Const)\n        self.assertEqual(first[\"a\"].value, 1)\n        self.assertIsInstance(first[\"b\"], nodes.Const)\n        self.assertEqual(first[\"b\"].value, 2)\n        with self.assertRaises(AttributeInferenceError):\n            first.getattr(\"missing\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_type_three_arguments", "self", "none", "classes", "builder", "extract_node", "type", "a", "object", "a", "1", "b", "2", "missing", "3", "assert", "isinstance", "classes", "nodes", "call", "first", "next", "classes", "infer", "self", "assertisinstance", "first", "nodes", "classdef", "self", "assertequal", "first", "name", "a", "self", "assertequal", "first", "basenames", "object", "self", "assertisinstance", "first", "a", "nodes", "const", "self", "assertequal", "first", "a", "value", "1", "self", "assertisinstance", "first", "b", "nodes", "const", "self", "assertequal", "first", "b", "value", "2", "with", "self", "assertraises", "attributeinferenceerror", "first", "getattr", "missing"], "doc_len": 75}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_implicit_metaclass", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_implicit_metaclass", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_implicit_metaclass(self) -> None:\n        cls = builder.extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        type_cls = nodes.builtin_lookup(\"type\")[1][0]\n        self.assertEqual(cls.implicit_metaclass(), type_cls)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_implicit_metaclass", "self", "none", "cls", "builder", "extract_node", "class", "a", "object", "pass", "assert", "isinstance", "cls", "nodes", "classdef", "type_cls", "nodes", "builtin_lookup", "type", "1", "0", "self", "assertequal", "cls", "implicit_metaclass", "type_cls"], "doc_len": 31}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_implicit_metaclass_lookup", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_implicit_metaclass_lookup", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_implicit_metaclass_lookup(self) -> None:\n        cls = builder.extract_node(\n            \"\"\"\n        class A(object):\n            pass\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        instance = cls.instantiate_class()\n        func = cls.getattr(\"mro\")\n        self.assertEqual(len(func), 1)\n        self.assertRaises(AttributeInferenceError, instance.getattr, \"mro\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_implicit_metaclass_lookup", "self", "none", "cls", "builder", "extract_node", "class", "a", "object", "pass", "assert", "isinstance", "cls", "nodes", "classdef", "instance", "cls", "instantiate_class", "func", "cls", "getattr", "mro", "self", "assertequal", "len", "func", "1", "self", "assertraises", "attributeinferenceerror", "instance", "getattr", "mro"], "doc_len": 38}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_lookup_using_same_class", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_lookup_using_same_class", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_lookup_using_same_class(self) -> None:\n        \"\"\"Check that we don't have recursive attribute access for metaclass\"\"\"\n        cls = builder.extract_node(\n            \"\"\"\n        class A(object): pass\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        self.assertEqual(len(cls.getattr(\"mro\")), 1)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_lookup_using_same_class", "self", "none", "check", "that", "we", "don", "t", "have", "recursive", "attribute", "access", "for", "metaclass", "cls", "builder", "extract_node", "class", "a", "object", "pass", "assert", "isinstance", "cls", "nodes", "classdef", "self", "assertequal", "len", "cls", "getattr", "mro", "1"], "doc_len": 38}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_lookup_inference_errors", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_lookup_inference_errors", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_lookup_inference_errors(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class Metaclass(type):\n            foo = lala\n\n        class B(object, metaclass=Metaclass): pass\n        \"\"\"\n        )\n        cls = module[\"B\"]\n        self.assertEqual(util.Uninferable, next(cls.igetattr(\"foo\")))\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_lookup_inference_errors", "self", "none", "module", "builder", "parse", "class", "metaclass", "type", "foo", "lala", "class", "b", "object", "metaclass", "metaclass", "pass", "cls", "module", "b", "self", "assertequal", "util", "uninferable", "next", "cls", "igetattr", "foo"], "doc_len": 33}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_metaclass_lookup", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_metaclass_lookup", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_metaclass_lookup(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class Metaclass(type):\n            foo = 42\n            @classmethod\n            def class_method(cls):\n                pass\n            def normal_method(cls):\n                pass\n            @property\n            def meta_property(cls):\n                return 42\n            @staticmethod\n            def static():\n                pass\n\n        class A(object, metaclass=Metaclass):\n            pass\n        \"\"\"\n        )\n        acls = module[\"A\"]\n        normal_attr = next(acls.igetattr(\"foo\"))\n        self.assertIsInstance(normal_attr, nodes.Const)\n        self.assertEqual(normal_attr.value, 42)\n\n        class_method = next(acls.igetattr(\"class_method\"))\n        self.assertIsInstance(class_method, BoundMethod)\n        self.assertEqual(class_method.bound, module[\"Metaclass\"])\n\n        normal_method = next(acls.igetattr(\"normal_method\"))\n        self.assertIsInstance(normal_method, BoundMethod)\n        self.assertEqual(normal_method.bound, module[\"A\"])\n\n        # Attribute access for properties:\n        #   from the metaclass is a property object\n        #   from the class that uses the metaclass, the value\n        #   of the property\n        property_meta = next(module[\"Metaclass\"].igetattr(\"meta_property\"))\n        self.assertIsInstance(property_meta, objects.Property)\n        wrapping = nodes.get_wrapping_class(property_meta)\n        self.assertEqual(wrapping, module[\"Metaclass\"])\n\n        property_class = next(acls.igetattr(\"meta_property\"))\n        self.assertIsInstance(property_class, nodes.Const)\n        self.assertEqual(property_class.value, 42)\n\n        static = next(acls.igetattr(\"static\"))\n        self.assertIsInstance(static, nodes.FunctionDef)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_metaclass_lookup", "self", "none", "module", "builder", "parse", "class", "metaclass", "type", "foo", "42", "classmethod", "def", "class_method", "cls", "pass", "def", "normal_method", "cls", "pass", "property", "def", "meta_property", "cls", "return", "42", "staticmethod", "def", "static", "pass", "class", "a", "object", "metaclass", "metaclass", "pass", "acls", "module", "a", "normal_attr", "next", "acls", "igetattr", "foo", "self", "assertisinstance", "normal_attr", "nodes", "const", "self", "assertequal", "normal_attr", "value", "42", "class_method", "next", "acls", "igetattr", "class_method", "self", "assertisinstance", "class_method", "boundmethod", "self", "assertequal", "class_method", "bound", "module", "metaclass", "normal_method", "next", "acls", "igetattr", "normal_method", "self", "assertisinstance", "normal_method", "boundmethod", "self", "assertequal", "normal_method", "bound", "module", "a", "attribute", "access", "for", "properties", "from", "the", "metaclass", "is", "a", "property", "object", "from", "the", "class", "that", "uses", "the", "metaclass", "the", "value", "of", "the", "property", "property_meta", "next", "module", "metaclass", "igetattr", "meta_property", "self", "assertisinstance", "property_meta", "objects", "property", "wrapping", "nodes", "get_wrapping_class", "property_meta", "self", "assertequal", "wrapping", "module", "metaclass", "property_class", "next", "acls", "igetattr", "meta_property", "self", "assertisinstance", "property_class", "nodes", "const", "self", "assertequal", "property_class", "value", "42", "static", "next", "acls", "igetattr", "static", "self", "assertisinstance", "static", "nodes", "functiondef"], "doc_len": 157}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_local_attr_invalid_mro", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_local_attr_invalid_mro", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_local_attr_invalid_mro(self) -> None:\n        cls = builder.extract_node(\n            \"\"\"\n        # A has an invalid MRO, local_attr should fallback\n        # to using .ancestors.\n        class A(object, object):\n            test = 42\n        class B(A): #@\n            pass\n        \"\"\"\n        )\n        assert isinstance(cls, nodes.ClassDef)\n        local = cls.local_attr(\"test\")[0]\n        inferred = next(local.infer())\n        self.assertIsInstance(inferred, nodes.Const)\n        self.assertEqual(inferred.value, 42)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_local_attr_invalid_mro", "self", "none", "cls", "builder", "extract_node", "a", "has", "an", "invalid", "mro", "local_attr", "should", "fallback", "to", "using", "ancestors", "class", "a", "object", "object", "test", "42", "class", "b", "a", "pass", "assert", "isinstance", "cls", "nodes", "classdef", "local", "cls", "local_attr", "test", "0", "inferred", "next", "local", "infer", "self", "assertisinstance", "inferred", "nodes", "const", "self", "assertequal", "inferred", "value", "42"], "doc_len": 56}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_has_dynamic_getattr", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_has_dynamic_getattr", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_has_dynamic_getattr(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        class Getattr(object):\n            def __getattr__(self, attrname):\n                pass\n\n        class Getattribute(object):\n            def __getattribute__(self, attrname):\n                pass\n\n        class ParentGetattr(Getattr):\n            pass\n        \"\"\"\n        )\n        self.assertTrue(module[\"Getattr\"].has_dynamic_getattr())\n        self.assertTrue(module[\"Getattribute\"].has_dynamic_getattr())\n        self.assertTrue(module[\"ParentGetattr\"].has_dynamic_getattr())\n\n        # Test that objects analyzed through the live introspection\n        # aren't considered to have dynamic getattr implemented.\n        astroid_builder = builder.AstroidBuilder()\n        module = astroid_builder.module_build(datetime)\n        self.assertFalse(module[\"timedelta\"].has_dynamic_getattr())\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_has_dynamic_getattr", "self", "none", "module", "builder", "parse", "class", "getattr", "object", "def", "__getattr__", "self", "attrname", "pass", "class", "getattribute", "object", "def", "__getattribute__", "self", "attrname", "pass", "class", "parentgetattr", "getattr", "pass", "self", "asserttrue", "module", "getattr", "has_dynamic_getattr", "self", "asserttrue", "module", "getattribute", "has_dynamic_getattr", "self", "asserttrue", "module", "parentgetattr", "has_dynamic_getattr", "test", "that", "objects", "analyzed", "through", "the", "live", "introspection", "aren", "t", "considered", "to", "have", "dynamic", "getattr", "implemented", "astroid_builder", "builder", "astroidbuilder", "module", "astroid_builder", "module_build", "datetime", "self", "assertfalse", "module", "timedelta", "has_dynamic_getattr"], "doc_len": 74}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_duplicate_bases_namedtuple", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_duplicate_bases_namedtuple", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_duplicate_bases_namedtuple(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        import collections\n        _A = collections.namedtuple('A', 'a')\n\n        class A(_A): pass\n\n        class B(A): pass\n        \"\"\"\n        )\n        names = [\"B\", \"A\", \"A\", \"tuple\", \"object\"]\n        mro = module[\"B\"].mro()\n        class_names = [i.name for i in mro]\n        self.assertEqual(names, class_names)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_duplicate_bases_namedtuple", "self", "none", "module", "builder", "parse", "import", "collections", "_a", "collections", "namedtuple", "a", "a", "class", "a", "_a", "pass", "class", "b", "a", "pass", "names", "b", "a", "a", "tuple", "object", "mro", "module", "b", "mro", "class_names", "i", "name", "for", "i", "in", "mro", "self", "assertequal", "names", "class_names"], "doc_len": 47}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_bound_method_lambdas", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_bound_method_lambdas", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_bound_method_lambdas(self) -> None:\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        class Test(object): #@\n            lam = lambda self: self\n            not_method = lambda xargs: xargs\n        Test() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        cls = next(ast_nodes[0].infer())\n        self.assertIsInstance(next(cls.igetattr(\"lam\")), nodes.Lambda)\n        self.assertIsInstance(next(cls.igetattr(\"not_method\")), nodes.Lambda)\n\n        instance = next(ast_nodes[1].infer())\n        lam = next(instance.igetattr(\"lam\"))\n        self.assertIsInstance(lam, BoundMethod)\n        not_method = next(instance.igetattr(\"not_method\"))\n        self.assertIsInstance(not_method, nodes.Lambda)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_bound_method_lambdas", "self", "none", "ast_nodes", "builder", "extract_node", "class", "test", "object", "lam", "lambda", "self", "self", "not_method", "lambda", "xargs", "xargs", "test", "assert", "isinstance", "ast_nodes", "list", "cls", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "next", "cls", "igetattr", "lam", "nodes", "lambda", "self", "assertisinstance", "next", "cls", "igetattr", "not_method", "nodes", "lambda", "instance", "next", "ast_nodes", "1", "infer", "lam", "next", "instance", "igetattr", "lam", "self", "assertisinstance", "lam", "boundmethod", "not_method", "next", "instance", "igetattr", "not_method", "self", "assertisinstance", "not_method", "nodes", "lambda"], "doc_len": 72}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_instance_bound_method_lambdas_2", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_instance_bound_method_lambdas_2", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_instance_bound_method_lambdas_2(self) -> None:\n        \"\"\"\n        Test the fact that a method which is a lambda built from\n        a factory is well inferred as a bound method (bug pylint 2594)\n        \"\"\"\n        ast_nodes = builder.extract_node(\n            \"\"\"\n        def lambda_factory():\n            return lambda self: print(\"Hello world\")\n\n        class MyClass(object): #@\n            f2 = lambda_factory()\n\n        MyClass() #@\n        \"\"\"\n        )\n        assert isinstance(ast_nodes, list)\n        cls = next(ast_nodes[0].infer())\n        self.assertIsInstance(next(cls.igetattr(\"f2\")), nodes.Lambda)\n\n        instance = next(ast_nodes[1].infer())\n        f2 = next(instance.igetattr(\"f2\"))\n        self.assertIsInstance(f2, BoundMethod)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_instance_bound_method_lambdas_2", "self", "none", "test", "the", "fact", "that", "a", "method", "which", "is", "a", "lambda", "built", "from", "a", "factory", "is", "well", "inferred", "as", "a", "bound", "method", "bug", "pylint", "2594", "ast_nodes", "builder", "extract_node", "def", "lambda_factory", "return", "lambda", "self", "print", "hello", "world", "class", "myclass", "object", "f2", "lambda_factory", "myclass", "assert", "isinstance", "ast_nodes", "list", "cls", "next", "ast_nodes", "0", "infer", "self", "assertisinstance", "next", "cls", "igetattr", "f2", "nodes", "lambda", "instance", "next", "ast_nodes", "1", "infer", "f2", "next", "instance", "igetattr", "f2", "self", "assertisinstance", "f2", "boundmethod"], "doc_len": 80}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_extra_decorators_frame_is_not_class", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_extra_decorators_frame_is_not_class", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_extra_decorators_frame_is_not_class(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        def ala():\n            def bala(): #@\n                func = 42\n        \"\"\"\n        )\n        assert isinstance(ast_node, nodes.FunctionDef)\n        self.assertEqual(ast_node.extra_decorators, [])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_extra_decorators_frame_is_not_class", "self", "none", "ast_node", "builder", "extract_node", "def", "ala", "def", "bala", "func", "42", "assert", "isinstance", "ast_node", "nodes", "functiondef", "self", "assertequal", "ast_node", "extra_decorators"], "doc_len": 26}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_extra_decorators_only_callfunc_are_considered", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_extra_decorators_only_callfunc_are_considered", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_extra_decorators_only_callfunc_are_considered(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class Ala(object):\n             def func(self): #@\n                 pass\n             func = 42\n        \"\"\"\n        )\n        self.assertEqual(ast_node.extra_decorators, [])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_extra_decorators_only_callfunc_are_considered", "self", "none", "ast_node", "builder", "extract_node", "class", "ala", "object", "def", "func", "self", "pass", "func", "42", "self", "assertequal", "ast_node", "extra_decorators"], "doc_len": 24}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_extra_decorators_only_assignment_names_are_considered", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_extra_decorators_only_assignment_names_are_considered", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_extra_decorators_only_assignment_names_are_considered(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class Ala(object):\n             def func(self): #@\n                 pass\n             def __init__(self):\n                 self.func = staticmethod(func)\n\n        \"\"\"\n        )\n        self.assertEqual(ast_node.extra_decorators, [])\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_extra_decorators_only_assignment_names_are_considered", "self", "none", "ast_node", "builder", "extract_node", "class", "ala", "object", "def", "func", "self", "pass", "def", "__init__", "self", "self", "func", "staticmethod", "func", "self", "assertequal", "ast_node", "extra_decorators"], "doc_len": 29}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_extra_decorators_only_same_name_considered", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_extra_decorators_only_same_name_considered", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_extra_decorators_only_same_name_considered(self) -> None:\n        ast_node = builder.extract_node(\n            \"\"\"\n        class Ala(object):\n             def func(self): #@\n                pass\n             bala = staticmethod(func)\n        \"\"\"\n        )\n        self.assertEqual(ast_node.extra_decorators, [])\n        self.assertEqual(ast_node.type, \"method\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_extra_decorators_only_same_name_considered", "self", "none", "ast_node", "builder", "extract_node", "class", "ala", "object", "def", "func", "self", "pass", "bala", "staticmethod", "func", "self", "assertequal", "ast_node", "extra_decorators", "self", "assertequal", "ast_node", "type", "method"], "doc_len": 30}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_extra_decorators", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_extra_decorators", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_extra_decorators(self) -> None:\n        static_method, clsmethod = builder.extract_node(\n            \"\"\"\n        class Ala(object):\n             def static(self): #@\n                 pass\n             def class_method(self): #@\n                 pass\n             class_method = classmethod(class_method)\n             static = staticmethod(static)\n        \"\"\"\n        )\n        self.assertEqual(len(clsmethod.extra_decorators), 1)\n        self.assertEqual(clsmethod.type, \"classmethod\")\n        self.assertEqual(len(static_method.extra_decorators), 1)\n        self.assertEqual(static_method.type, \"staticmethod\")\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_extra_decorators", "self", "none", "static_method", "clsmethod", "builder", "extract_node", "class", "ala", "object", "def", "static", "self", "pass", "def", "class_method", "self", "pass", "class_method", "classmethod", "class_method", "static", "staticmethod", "static", "self", "assertequal", "len", "clsmethod", "extra_decorators", "1", "self", "assertequal", "clsmethod", "type", "classmethod", "self", "assertequal", "len", "static_method", "extra_decorators", "1", "self", "assertequal", "static_method", "type", "staticmethod"], "doc_len": 51}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_extra_decorators_only_class_level_assignments", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_extra_decorators_only_class_level_assignments", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_extra_decorators_only_class_level_assignments(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        def _bind(arg):\n            return arg.bind\n\n        class A(object):\n            @property\n            def bind(self):\n                return 42\n            def irelevant(self):\n                # This is important, because it used to trigger\n                # a maximum recursion error.\n                bind = _bind(self)\n                return bind\n        A() #@\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        bind = next(inferred.igetattr(\"bind\"))\n        self.assertIsInstance(bind, nodes.Const)\n        self.assertEqual(bind.value, 42)\n        parent = bind.scope()\n        self.assertEqual(len(parent.extra_decorators), 0)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_extra_decorators_only_class_level_assignments", "self", "none", "node", "builder", "extract_node", "def", "_bind", "arg", "return", "arg", "bind", "class", "a", "object", "property", "def", "bind", "self", "return", "42", "def", "irelevant", "self", "this", "is", "important", "because", "it", "used", "to", "trigger", "a", "maximum", "recursion", "error", "bind", "_bind", "self", "return", "bind", "a", "inferred", "next", "node", "infer", "bind", "next", "inferred", "igetattr", "bind", "self", "assertisinstance", "bind", "nodes", "const", "self", "assertequal", "bind", "value", "42", "parent", "bind", "scope", "self", "assertequal", "len", "parent", "extra_decorators", "0"], "doc_len": 75}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_class_keywords", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_class_keywords", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_class_keywords(self) -> None:\n        data = \"\"\"\n            class TestKlass(object, metaclass=TestMetaKlass,\n                    foo=42, bar='baz'):\n                pass\n        \"\"\"\n        astroid = builder.parse(data, __name__)\n        cls = astroid[\"TestKlass\"]\n        self.assertEqual(len(cls.keywords), 2)\n        self.assertEqual([x.arg for x in cls.keywords], [\"foo\", \"bar\"])\n        children = list(cls.get_children())\n        assert len(children) == 4\n        assert isinstance(children[1], nodes.Keyword)\n        assert isinstance(children[2], nodes.Keyword)\n        assert children[1].arg == \"foo\"\n        assert children[2].arg == \"bar\"\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_class_keywords", "self", "none", "data", "class", "testklass", "object", "metaclass", "testmetaklass", "foo", "42", "bar", "baz", "pass", "astroid", "builder", "parse", "data", "__name__", "cls", "astroid", "testklass", "self", "assertequal", "len", "cls", "keywords", "2", "self", "assertequal", "x", "arg", "for", "x", "in", "cls", "keywords", "foo", "bar", "children", "list", "cls", "get_children", "assert", "len", "children", "4", "assert", "isinstance", "children", "1", "nodes", "keyword", "assert", "isinstance", "children", "2", "nodes", "keyword", "assert", "children", "1", "arg", "foo", "assert", "children", "2", "arg", "bar"], "doc_len": 74}
{"doc_id": "tests/unittest_scoped_nodes.py::ClassNodeTest.test_kite_graph", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "ClassNodeTest", "func_name": "test_kite_graph", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: ClassNodeTest\n    def test_kite_graph(self) -> None:\n        data = \"\"\"\n        A = type('A', (object,), {})\n\n        class B1(A): pass\n\n        class B2(A): pass\n\n        class C(B1, B2): pass\n\n        class D(C):\n            def update(self):\n                self.hello = 'hello'\n        \"\"\"\n        # Should not crash\n        builder.parse(data)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "classnodetest", "def", "test_kite_graph", "self", "none", "data", "a", "type", "a", "object", "class", "b1", "a", "pass", "class", "b2", "a", "pass", "class", "c", "b1", "b2", "pass", "class", "d", "c", "def", "update", "self", "self", "hello", "hello", "should", "not", "crash", "builder", "parse", "data"], "doc_len": 41}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_metaclass_subclass_property", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_metaclass_subclass_property", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_metaclass_subclass_property() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        @property\n        def __members__(cls):\n            return ['a', 'property']\n    class Parent(metaclass=BaseMeta):\n        pass\n    class Derived(Parent):\n        pass\n    Derived.__members__\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_metaclass_subclass_property", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "property", "def", "__members__", "cls", "return", "a", "property", "class", "parent", "metaclass", "basemeta", "pass", "class", "derived", "parent", "pass", "derived", "__members__", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "c", "value", "for", "c", "in", "inferred", "elts", "a", "property"], "doc_len": 49}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_property_grandchild", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_property_grandchild", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_property_grandchild() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class Grandparent:\n        @property\n        def __members__(self):\n            return ['a', 'property']\n    class Parent(Grandparent):\n        pass\n    class Child(Parent):\n        pass\n    Child().__members__\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_property_grandchild", "none", "node", "builder", "extract_node", "class", "grandparent", "property", "def", "__members__", "self", "return", "a", "property", "class", "parent", "grandparent", "pass", "class", "child", "parent", "pass", "child", "__members__", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "c", "value", "for", "c", "in", "inferred", "elts", "a", "property"], "doc_len": 47}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_metaclass_property", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_metaclass_property", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_metaclass_property() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        @property\n        def __members__(cls):\n            return ['a', 'property']\n    class Parent(metaclass=BaseMeta):\n        pass\n    Parent.__members__\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert [c.value for c in inferred.elts] == [\"a\", \"property\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_metaclass_property", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "property", "def", "__members__", "cls", "return", "a", "property", "class", "parent", "metaclass", "basemeta", "pass", "parent", "__members__", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "c", "value", "for", "c", "in", "inferred", "elts", "a", "property"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_with_metaclass_class_context_property", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_with_metaclass_class_context_property", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_with_metaclass_class_context_property() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        pass\n    class Parent(metaclass=BaseMeta):\n        @property\n        def __members__(self):\n            return ['a', 'property']\n    class Derived(Parent):\n        pass\n    Derived.__members__\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert not isinstance(inferred, nodes.List)\n    assert isinstance(inferred, objects.Property)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_with_metaclass_class_context_property", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "pass", "class", "parent", "metaclass", "basemeta", "property", "def", "__members__", "self", "return", "a", "property", "class", "derived", "parent", "pass", "derived", "__members__", "inferred", "next", "node", "infer", "assert", "not", "isinstance", "inferred", "nodes", "list", "assert", "isinstance", "inferred", "objects", "property"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_metaclass_values_funcdef", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_metaclass_values_funcdef", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_metaclass_values_funcdef() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        def __members__(cls):\n            return ['a', 'func']\n    class Parent(metaclass=BaseMeta):\n        pass\n    Parent.__members__()\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, nodes.List)\n    assert [c.value for c in inferred.elts] == [\"a\", \"func\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_metaclass_values_funcdef", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "def", "__members__", "cls", "return", "a", "func", "class", "parent", "metaclass", "basemeta", "pass", "parent", "__members__", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "nodes", "list", "assert", "c", "value", "for", "c", "in", "inferred", "elts", "a", "func"], "doc_len": 44}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_metaclass_derived_funcdef", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_metaclass_derived_funcdef", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_metaclass_derived_funcdef() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        def __members__(cls):\n            return ['a', 'func']\n    class Parent(metaclass=BaseMeta):\n        pass\n    class Derived(Parent):\n        pass\n    Derived.__members__()\n    \"\"\"\n    )\n    inferred_result = next(node.infer())\n    assert isinstance(inferred_result, nodes.List)\n    assert [c.value for c in inferred_result.elts] == [\"a\", \"func\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_metaclass_derived_funcdef", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "def", "__members__", "cls", "return", "a", "func", "class", "parent", "metaclass", "basemeta", "pass", "class", "derived", "parent", "pass", "derived", "__members__", "inferred_result", "next", "node", "infer", "assert", "isinstance", "inferred_result", "nodes", "list", "assert", "c", "value", "for", "c", "in", "inferred_result", "elts", "a", "func"], "doc_len": 48}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_metaclass_funcdef_is_not_datadescriptor", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_metaclass_funcdef_is_not_datadescriptor", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_metaclass_funcdef_is_not_datadescriptor() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    class BaseMeta(type):\n        def __members__(cls):\n            return ['a', 'property']\n    class Parent(metaclass=BaseMeta):\n        @property\n        def __members__(cls):\n            return BaseMeta.__members__()\n    class Derived(Parent):\n        pass\n    Derived.__members__\n    \"\"\"\n    )\n    # Here the function is defined on the metaclass, but the property\n    # is defined on the base class. When loading the attribute in a\n    # class context, this should return the property object instead of\n    # resolving the data descriptor\n    inferred = next(node.infer())\n    assert isinstance(inferred, objects.Property)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_metaclass_funcdef_is_not_datadescriptor", "none", "node", "builder", "extract_node", "class", "basemeta", "type", "def", "__members__", "cls", "return", "a", "property", "class", "parent", "metaclass", "basemeta", "property", "def", "__members__", "cls", "return", "basemeta", "__members__", "class", "derived", "parent", "pass", "derived", "__members__", "here", "the", "function", "is", "defined", "on", "the", "metaclass", "but", "the", "property", "is", "defined", "on", "the", "base", "class", "when", "loading", "the", "attribute", "in", "a", "class", "context", "this", "should", "return", "the", "property", "object", "instead", "of", "resolving", "the", "data", "descriptor", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "objects", "property"], "doc_len": 81}
{"doc_id": "tests/unittest_scoped_nodes.py::test_issue940_enums_as_a_real_world_usecase", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_issue940_enums_as_a_real_world_usecase", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_issue940_enums_as_a_real_world_usecase() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    from enum import Enum\n    class Sounds(Enum):\n        bee = \"buzz\"\n        cat = \"meow\"\n    Sounds.__members__\n    \"\"\"\n    )\n    inferred_result = next(node.infer())\n    assert isinstance(inferred_result, nodes.Dict)\n    actual = [k.value for k, _ in inferred_result.items]\n    assert sorted(actual) == [\"bee\", \"cat\"]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_issue940_enums_as_a_real_world_usecase", "none", "node", "builder", "extract_node", "from", "enum", "import", "enum", "class", "sounds", "enum", "bee", "buzz", "cat", "meow", "sounds", "__members__", "inferred_result", "next", "node", "infer", "assert", "isinstance", "inferred_result", "nodes", "dict", "actual", "k", "value", "for", "k", "_", "in", "inferred_result", "items", "assert", "sorted", "actual", "bee", "cat"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::test_metaclass_cannot_infer_call_yields_an_instance", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_metaclass_cannot_infer_call_yields_an_instance", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_metaclass_cannot_infer_call_yields_an_instance() -> None:\n    node = builder.extract_node(\n        \"\"\"\n    from undefined import Undefined\n    class Meta(type):\n        __call__ = Undefined\n    class A(metaclass=Meta):\n        pass\n    A()\n    \"\"\"\n    )\n    inferred = next(node.infer())\n    assert isinstance(inferred, Instance)\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_metaclass_cannot_infer_call_yields_an_instance", "none", "node", "builder", "extract_node", "from", "undefined", "import", "undefined", "class", "meta", "type", "__call__", "undefined", "class", "a", "metaclass", "meta", "pass", "a", "inferred", "next", "node", "infer", "assert", "isinstance", "inferred", "instance"], "doc_len": 32}
{"doc_id": "tests/unittest_scoped_nodes.py::test_posonlyargs_python_38", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_posonlyargs_python_38", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_posonlyargs_python_38(func):\n    ast_node = builder.extract_node(func)\n    assert ast_node.as_string().strip() == func.strip()\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_posonlyargs_python_38", "func", "ast_node", "builder", "extract_node", "func", "assert", "ast_node", "as_string", "strip", "func", "strip"], "doc_len": 16}
{"doc_id": "tests/unittest_scoped_nodes.py::test_posonlyargs_default_value", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_posonlyargs_default_value", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_posonlyargs_default_value() -> None:\n    ast_node = builder.extract_node(\n        \"\"\"\n    def func(a, b=1, /, c=2): pass\n    \"\"\"\n    )\n    last_param = ast_node.args.default_value(\"c\")\n    assert isinstance(last_param, nodes.Const)\n    assert last_param.value == 2\n\n    first_param = ast_node.args.default_value(\"b\")\n    assert isinstance(first_param, nodes.Const)\n    assert first_param.value == 1\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_posonlyargs_default_value", "none", "ast_node", "builder", "extract_node", "def", "func", "a", "b", "1", "c", "2", "pass", "last_param", "ast_node", "args", "default_value", "c", "assert", "isinstance", "last_param", "nodes", "const", "assert", "last_param", "value", "2", "first_param", "ast_node", "args", "default_value", "b", "assert", "isinstance", "first_param", "nodes", "const", "assert", "first_param", "value", "1"], "doc_len": 45}
{"doc_id": "tests/unittest_scoped_nodes.py::test_ancestor_with_generic", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_ancestor_with_generic", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_ancestor_with_generic() -> None:\n    # https://github.com/PyCQA/astroid/issues/942\n    tree = builder.parse(\n        \"\"\"\n    from typing import TypeVar, Generic\n    T = TypeVar(\"T\")\n    class A(Generic[T]):\n        def a_method(self):\n            print(\"hello\")\n    class B(A[T]): pass\n    class C(B[str]): pass\n    \"\"\"\n    )\n    inferred_b = next(tree[\"B\"].infer())\n    assert [cdef.name for cdef in inferred_b.ancestors()] == [\"A\", \"Generic\", \"object\"]\n\n    inferred_c = next(tree[\"C\"].infer())\n    assert [cdef.name for cdef in inferred_c.ancestors()] == [\n        \"B\",\n        \"A\",\n        \"Generic\",\n        \"object\",\n    ]\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_ancestor_with_generic", "none", "https", "github", "com", "pycqa", "astroid", "issues", "942", "tree", "builder", "parse", "from", "typing", "import", "typevar", "generic", "t", "typevar", "t", "class", "a", "generic", "t", "def", "a_method", "self", "print", "hello", "class", "b", "a", "t", "pass", "class", "c", "b", "str", "pass", "inferred_b", "next", "tree", "b", "infer", "assert", "cdef", "name", "for", "cdef", "in", "inferred_b", "ancestors", "a", "generic", "object", "inferred_c", "next", "tree", "c", "infer", "assert", "cdef", "name", "for", "cdef", "in", "inferred_c", "ancestors", "b", "a", "generic", "object"], "doc_len": 76}
{"doc_id": "tests/unittest_scoped_nodes.py::test_slots_duplicate_bases_issue_1089", "file_path": "tests/unittest_scoped_nodes.py", "class_name": null, "func_name": "test_slots_duplicate_bases_issue_1089", "text": "文件路径: tests/unittest_scoped_nodes.py\ndef test_slots_duplicate_bases_issue_1089() -> None:\n    astroid = builder.parse(\n        \"\"\"\n            class First(object, object): #@\n                pass\n        \"\"\"\n    )\n    with pytest.raises(NotImplementedError):\n        astroid[\"First\"].slots()\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "def", "test_slots_duplicate_bases_issue_1089", "none", "astroid", "builder", "parse", "class", "first", "object", "object", "pass", "with", "pytest", "raises", "notimplementederror", "astroid", "first", "slots"], "doc_len": 21}
{"doc_id": "tests/unittest_scoped_nodes.py::TestFrameNodes.test_frame_node", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "TestFrameNodes", "func_name": "test_frame_node", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: TestFrameNodes\n    def test_frame_node():\n        \"\"\"Test if the frame of FunctionDef, ClassDef and Module is correctly set\"\"\"\n        module = builder.parse(\n            \"\"\"\n            def func():\n                var_1 = x\n                return var_1\n\n            class MyClass:\n\n                attribute = 1\n\n                def method():\n                    pass\n\n            VAR = lambda y = (named_expr := \"walrus\"): print(y)\n        \"\"\"\n        )\n        function = module.body[0]\n        assert function.frame() == function\n        assert function.frame(future=True) == function\n        assert function.body[0].frame() == function\n        assert function.body[0].frame(future=True) == function\n\n        class_node = module.body[1]\n        assert class_node.frame() == class_node\n        assert class_node.frame(future=True) == class_node\n        assert class_node.body[0].frame() == class_node\n        assert class_node.body[0].frame(future=True) == class_node\n        assert class_node.body[1].frame() == class_node.body[1]\n        assert class_node.body[1].frame(future=True) == class_node.body[1]\n\n        lambda_assignment = module.body[2].value\n        assert lambda_assignment.args.args[0].frame() == lambda_assignment\n        assert lambda_assignment.args.args[0].frame(future=True) == lambda_assignment\n\n        assert module.frame() == module\n        assert module.frame(future=True) == module\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "testframenodes", "def", "test_frame_node", "test", "if", "the", "frame", "of", "functiondef", "classdef", "and", "module", "is", "correctly", "set", "module", "builder", "parse", "def", "func", "var_1", "x", "return", "var_1", "class", "myclass", "attribute", "1", "def", "method", "pass", "var", "lambda", "y", "named_expr", "walrus", "print", "y", "function", "module", "body", "0", "assert", "function", "frame", "function", "assert", "function", "frame", "future", "true", "function", "assert", "function", "body", "0", "frame", "function", "assert", "function", "body", "0", "frame", "future", "true", "function", "class_node", "module", "body", "1", "assert", "class_node", "frame", "class_node", "assert", "class_node", "frame", "future", "true", "class_node", "assert", "class_node", "body", "0", "frame", "class_node", "assert", "class_node", "body", "0", "frame", "future", "true", "class_node", "assert", "class_node", "body", "1", "frame", "class_node", "body", "1", "assert", "class_node", "body", "1", "frame", "future", "true", "class_node", "body", "1", "lambda_assignment", "module", "body", "2", "value", "assert", "lambda_assignment", "args", "args", "0", "frame", "lambda_assignment", "assert", "lambda_assignment", "args", "args", "0", "frame", "future", "true", "lambda_assignment", "assert", "module", "frame", "module", "assert", "module", "frame", "future", "true", "module"], "doc_len": 146}
{"doc_id": "tests/unittest_scoped_nodes.py::TestFrameNodes.test_non_frame_node", "file_path": "tests/unittest_scoped_nodes.py", "class_name": "TestFrameNodes", "func_name": "test_non_frame_node", "text": "文件路径: tests/unittest_scoped_nodes.py, 类名: TestFrameNodes\n    def test_non_frame_node():\n        \"\"\"Test if the frame of non frame nodes is set correctly\"\"\"\n        module = builder.parse(\n            \"\"\"\n            VAR_ONE = 1\n\n            VAR_TWO = [x for x in range(1)]\n        \"\"\"\n        )\n        assert module.body[0].frame() == module\n        assert module.body[0].frame(future=True) == module\n\n        assert module.body[1].value.locals[\"x\"][0].frame() == module\n        assert module.body[1].value.locals[\"x\"][0].frame(future=True) == module\n", "tokens": ["tests", "unittest_scoped_nodes", "py", "testframenodes", "def", "test_non_frame_node", "test", "if", "the", "frame", "of", "non", "frame", "nodes", "is", "set", "correctly", "module", "builder", "parse", "var_one", "1", "var_two", "x", "for", "x", "in", "range", "1", "assert", "module", "body", "0", "frame", "module", "assert", "module", "body", "0", "frame", "future", "true", "module", "assert", "module", "body", "1", "value", "locals", "x", "0", "frame", "module", "assert", "module", "body", "1", "value", "locals", "x", "0", "frame", "future", "true", "module"], "doc_len": 65}
{"doc_id": "tests/unittest_transforms.py::add_transform", "file_path": "tests/unittest_transforms.py", "class_name": null, "func_name": "add_transform", "text": "文件路径: tests/unittest_transforms.py\ndef add_transform(\n    manager: AstroidManager,\n    node: type,\n    transform: Callable,\n    predicate: Optional[Callable] = None,\n) -> Iterator:\n    manager.register_transform(node, transform, predicate)\n    try:\n        yield\n    finally:\n        manager.unregister_transform(node, transform, predicate)\n", "tokens": ["tests", "unittest_transforms", "py", "def", "add_transform", "manager", "astroidmanager", "node", "type", "transform", "callable", "predicate", "optional", "callable", "none", "iterator", "manager", "register_transform", "node", "transform", "predicate", "try", "yield", "finally", "manager", "unregister_transform", "node", "transform", "predicate"], "doc_len": 29}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.setUp", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "setUp", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def setUp(self) -> None:\n        self.transformer = transforms.TransformVisitor()\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "setup", "self", "none", "self", "transformer", "transforms", "transformvisitor"], "doc_len": 12}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.parse_transform", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "parse_transform", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def parse_transform(self, code: str) -> Module:\n        module = parse(code, apply_transforms=False)\n        return self.transformer.visit(module)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "parse_transform", "self", "code", "str", "module", "module", "parse", "code", "apply_transforms", "false", "return", "self", "transformer", "visit", "module"], "doc_len": 20}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_function_inlining_transform", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_function_inlining_transform", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_function_inlining_transform(self) -> None:\n        def transform_call(node: Call) -> Const:\n            # Let's do some function inlining\n            inferred = next(node.infer())\n            return inferred\n\n        self.transformer.register_transform(nodes.Call, transform_call)\n\n        module = self.parse_transform(\n            \"\"\"\n        def test(): return 42\n        test() #@\n        \"\"\"\n        )\n\n        self.assertIsInstance(module.body[1], nodes.Expr)\n        self.assertIsInstance(module.body[1].value, nodes.Const)\n        self.assertEqual(module.body[1].value.value, 42)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_function_inlining_transform", "self", "none", "def", "transform_call", "node", "call", "const", "let", "s", "do", "some", "function", "inlining", "inferred", "next", "node", "infer", "return", "inferred", "self", "transformer", "register_transform", "nodes", "call", "transform_call", "module", "self", "parse_transform", "def", "test", "return", "42", "test", "self", "assertisinstance", "module", "body", "1", "nodes", "expr", "self", "assertisinstance", "module", "body", "1", "value", "nodes", "const", "self", "assertequal", "module", "body", "1", "value", "value", "42"], "doc_len": 62}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_recursive_transforms_into_astroid_fields", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_recursive_transforms_into_astroid_fields", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_recursive_transforms_into_astroid_fields(self) -> None:\n        # Test that the transformer walks properly the tree\n        # by going recursively into the _astroid_fields per each node.\n        def transform_compare(node: Compare) -> Const:\n            # Let's check the values of the ops\n            _, right = node.ops[0]\n            # Assume they are Consts and they were transformed before\n            # us.\n            return nodes.const_factory(node.left.value < right.value)\n\n        def transform_name(node: Name) -> Const:\n            # Should be Consts\n            return next(node.infer())\n\n        self.transformer.register_transform(nodes.Compare, transform_compare)\n        self.transformer.register_transform(nodes.Name, transform_name)\n\n        module = self.parse_transform(\n            \"\"\"\n        a = 42\n        b = 24\n        a < b\n        \"\"\"\n        )\n\n        self.assertIsInstance(module.body[2], nodes.Expr)\n        self.assertIsInstance(module.body[2].value, nodes.Const)\n        self.assertFalse(module.body[2].value.value)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_recursive_transforms_into_astroid_fields", "self", "none", "test", "that", "the", "transformer", "walks", "properly", "the", "tree", "by", "going", "recursively", "into", "the", "_astroid_fields", "per", "each", "node", "def", "transform_compare", "node", "compare", "const", "let", "s", "check", "the", "values", "of", "the", "ops", "_", "right", "node", "ops", "0", "assume", "they", "are", "consts", "and", "they", "were", "transformed", "before", "us", "return", "nodes", "const_factory", "node", "left", "value", "right", "value", "def", "transform_name", "node", "name", "const", "should", "be", "consts", "return", "next", "node", "infer", "self", "transformer", "register_transform", "nodes", "compare", "transform_compare", "self", "transformer", "register_transform", "nodes", "name", "transform_name", "module", "self", "parse_transform", "a", "42", "b", "24", "a", "b", "self", "assertisinstance", "module", "body", "2", "nodes", "expr", "self", "assertisinstance", "module", "body", "2", "value", "nodes", "const", "self", "assertfalse", "module", "body", "2", "value", "value"], "doc_len": 116}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_transform_patches_locals", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_transform_patches_locals", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_transform_patches_locals(self) -> None:\n        def transform_function(node: FunctionDef) -> None:\n            assign = nodes.Assign()\n            name = nodes.AssignName(name=\"value\")\n            assign.targets = [name]\n            assign.value = nodes.const_factory(42)\n            node.body.append(assign)\n\n        self.transformer.register_transform(nodes.FunctionDef, transform_function)\n\n        module = self.parse_transform(\n            \"\"\"\n        def test():\n            pass\n        \"\"\"\n        )\n\n        func = module.body[0]\n        self.assertEqual(len(func.body), 2)\n        self.assertIsInstance(func.body[1], nodes.Assign)\n        self.assertEqual(func.body[1].as_string(), \"value = 42\")\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_transform_patches_locals", "self", "none", "def", "transform_function", "node", "functiondef", "none", "assign", "nodes", "assign", "name", "nodes", "assignname", "name", "value", "assign", "targets", "name", "assign", "value", "nodes", "const_factory", "42", "node", "body", "append", "assign", "self", "transformer", "register_transform", "nodes", "functiondef", "transform_function", "module", "self", "parse_transform", "def", "test", "pass", "func", "module", "body", "0", "self", "assertequal", "len", "func", "body", "2", "self", "assertisinstance", "func", "body", "1", "nodes", "assign", "self", "assertequal", "func", "body", "1", "as_string", "value", "42"], "doc_len": 70}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_predicates", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_predicates", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_predicates(self) -> None:\n        def transform_call(node: Call) -> Const:\n            inferred = next(node.infer())\n            return inferred\n\n        def should_inline(node: Call) -> bool:\n            return node.func.name.startswith(\"inlineme\")\n\n        self.transformer.register_transform(nodes.Call, transform_call, should_inline)\n\n        module = self.parse_transform(\n            \"\"\"\n        def inlineme_1():\n            return 24\n        def dont_inline_me():\n            return 42\n        def inlineme_2():\n            return 2\n        inlineme_1()\n        dont_inline_me()\n        inlineme_2()\n        \"\"\"\n        )\n        values = module.body[-3:]\n        self.assertIsInstance(values[0], nodes.Expr)\n        self.assertIsInstance(values[0].value, nodes.Const)\n        self.assertEqual(values[0].value.value, 24)\n        self.assertIsInstance(values[1], nodes.Expr)\n        self.assertIsInstance(values[1].value, nodes.Call)\n        self.assertIsInstance(values[2], nodes.Expr)\n        self.assertIsInstance(values[2].value, nodes.Const)\n        self.assertEqual(values[2].value.value, 2)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_predicates", "self", "none", "def", "transform_call", "node", "call", "const", "inferred", "next", "node", "infer", "return", "inferred", "def", "should_inline", "node", "call", "bool", "return", "node", "func", "name", "startswith", "inlineme", "self", "transformer", "register_transform", "nodes", "call", "transform_call", "should_inline", "module", "self", "parse_transform", "def", "inlineme_1", "return", "24", "def", "dont_inline_me", "return", "42", "def", "inlineme_2", "return", "2", "inlineme_1", "dont_inline_me", "inlineme_2", "values", "module", "body", "3", "self", "assertisinstance", "values", "0", "nodes", "expr", "self", "assertisinstance", "values", "0", "value", "nodes", "const", "self", "assertequal", "values", "0", "value", "value", "24", "self", "assertisinstance", "values", "1", "nodes", "expr", "self", "assertisinstance", "values", "1", "value", "nodes", "call", "self", "assertisinstance", "values", "2", "nodes", "expr", "self", "assertisinstance", "values", "2", "value", "nodes", "const", "self", "assertequal", "values", "2", "value", "value", "2"], "doc_len": 112}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_transforms_are_separated", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_transforms_are_separated", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_transforms_are_separated(self) -> None:\n        # Test that the transforming is done at a separate\n        # step, which means that we are not doing inference\n        # on a partially constructed tree anymore, which was the\n        # source of crashes in the past when certain inference rules\n        # were used in a transform.\n        def transform_function(node: FunctionDef) -> Const:\n            if node.decorators:\n                for decorator in node.decorators.nodes:\n                    inferred = next(decorator.infer())\n                    if inferred.qname() == \"abc.abstractmethod\":\n                        return next(node.infer_call_result())\n            return None\n\n        manager = MANAGER\n        with add_transform(manager, nodes.FunctionDef, transform_function):\n            module = builder.parse(\n                \"\"\"\n            import abc\n            from abc import abstractmethod\n\n            class A(object):\n                @abc.abstractmethod\n                def ala(self):\n                    return 24\n\n                @abstractmethod\n                def bala(self):\n                    return 42\n            \"\"\"\n            )\n\n        cls = module[\"A\"]\n        ala = cls.body[0]\n        bala = cls.body[1]\n        self.assertIsInstance(ala, nodes.Const)\n        self.assertEqual(ala.value, 24)\n        self.assertIsInstance(bala, nodes.Const)\n        self.assertEqual(bala.value, 42)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_transforms_are_separated", "self", "none", "test", "that", "the", "transforming", "is", "done", "at", "a", "separate", "step", "which", "means", "that", "we", "are", "not", "doing", "inference", "on", "a", "partially", "constructed", "tree", "anymore", "which", "was", "the", "source", "of", "crashes", "in", "the", "past", "when", "certain", "inference", "rules", "were", "used", "in", "a", "transform", "def", "transform_function", "node", "functiondef", "const", "if", "node", "decorators", "for", "decorator", "in", "node", "decorators", "nodes", "inferred", "next", "decorator", "infer", "if", "inferred", "qname", "abc", "abstractmethod", "return", "next", "node", "infer_call_result", "return", "none", "manager", "manager", "with", "add_transform", "manager", "nodes", "functiondef", "transform_function", "module", "builder", "parse", "import", "abc", "from", "abc", "import", "abstractmethod", "class", "a", "object", "abc", "abstractmethod", "def", "ala", "self", "return", "24", "abstractmethod", "def", "bala", "self", "return", "42", "cls", "module", "a", "ala", "cls", "body", "0", "bala", "cls", "body", "1", "self", "assertisinstance", "ala", "nodes", "const", "self", "assertequal", "ala", "value", "24", "self", "assertisinstance", "bala", "nodes", "const", "self", "assertequal", "bala", "value", "42"], "doc_len": 143}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_transforms_are_called_for_builtin_modules", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_transforms_are_called_for_builtin_modules", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_transforms_are_called_for_builtin_modules(self) -> None:\n        # Test that transforms are called for builtin modules.\n        def transform_function(node: FunctionDef) -> FunctionDef:\n            name = nodes.AssignName(name=\"value\")\n            node.args.args = [name]\n            return node\n\n        manager = MANAGER\n\n        def predicate(node: FunctionDef) -> bool:\n            return node.root().name == \"time\"\n\n        with add_transform(manager, nodes.FunctionDef, transform_function, predicate):\n            builder_instance = builder.AstroidBuilder()\n            module = builder_instance.module_build(time)\n\n        asctime = module[\"asctime\"]\n        self.assertEqual(len(asctime.args.args), 1)\n        self.assertIsInstance(asctime.args.args[0], nodes.AssignName)\n        self.assertEqual(asctime.args.args[0].name, \"value\")\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_transforms_are_called_for_builtin_modules", "self", "none", "test", "that", "transforms", "are", "called", "for", "builtin", "modules", "def", "transform_function", "node", "functiondef", "functiondef", "name", "nodes", "assignname", "name", "value", "node", "args", "args", "name", "return", "node", "manager", "manager", "def", "predicate", "node", "functiondef", "bool", "return", "node", "root", "name", "time", "with", "add_transform", "manager", "nodes", "functiondef", "transform_function", "predicate", "builder_instance", "builder", "astroidbuilder", "module", "builder_instance", "module_build", "time", "asctime", "module", "asctime", "self", "assertequal", "len", "asctime", "args", "args", "1", "self", "assertisinstance", "asctime", "args", "args", "0", "nodes", "assignname", "self", "assertequal", "asctime", "args", "args", "0", "name", "value"], "doc_len": 84}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_builder_apply_transforms", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_builder_apply_transforms", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_builder_apply_transforms(self) -> None:\n        def transform_function(node):\n            return nodes.const_factory(42)\n\n        manager = MANAGER\n        with add_transform(manager, nodes.FunctionDef, transform_function):\n            astroid_builder = builder.AstroidBuilder(apply_transforms=False)\n            module = astroid_builder.string_build(\"\"\"def test(): pass\"\"\")\n\n        # The transform wasn't applied.\n        self.assertIsInstance(module.body[0], nodes.FunctionDef)\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_builder_apply_transforms", "self", "none", "def", "transform_function", "node", "return", "nodes", "const_factory", "42", "manager", "manager", "with", "add_transform", "manager", "nodes", "functiondef", "transform_function", "astroid_builder", "builder", "astroidbuilder", "apply_transforms", "false", "module", "astroid_builder", "string_build", "def", "test", "pass", "the", "transform", "wasn", "t", "applied", "self", "assertisinstance", "module", "body", "0", "nodes", "functiondef"], "doc_len": 46}
{"doc_id": "tests/unittest_transforms.py::TestTransforms.test_transform_crashes_on_is_subtype_of", "file_path": "tests/unittest_transforms.py", "class_name": "TestTransforms", "func_name": "test_transform_crashes_on_is_subtype_of", "text": "文件路径: tests/unittest_transforms.py, 类名: TestTransforms\n    def test_transform_crashes_on_is_subtype_of(self) -> None:\n        # Test that we don't crash when having is_subtype_of\n        # in a transform, as per issue #188. This happened\n        # before, when the transforms weren't in their own step.\n        def transform_class(cls):\n            if cls.is_subtype_of(\"django.db.models.base.Model\"):\n                return cls\n            return cls\n\n        self.transformer.register_transform(nodes.ClassDef, transform_class)\n\n        self.parse_transform(\n            \"\"\"\n            # Change environ to automatically call putenv() if it exists\n            import os\n            putenv = os.putenv\n            try:\n                # This will fail if there's no putenv\n                putenv\n            except NameError:\n                pass\n            else:\n                import UserDict\n        \"\"\"\n        )\n", "tokens": ["tests", "unittest_transforms", "py", "testtransforms", "def", "test_transform_crashes_on_is_subtype_of", "self", "none", "test", "that", "we", "don", "t", "crash", "when", "having", "is_subtype_of", "in", "a", "transform", "as", "per", "issue", "188", "this", "happened", "before", "when", "the", "transforms", "weren", "t", "in", "their", "own", "step", "def", "transform_class", "cls", "if", "cls", "is_subtype_of", "django", "db", "models", "base", "model", "return", "cls", "return", "cls", "self", "transformer", "register_transform", "nodes", "classdef", "transform_class", "self", "parse_transform", "change", "environ", "to", "automatically", "call", "putenv", "if", "it", "exists", "import", "os", "putenv", "os", "putenv", "try", "this", "will", "fail", "if", "there", "s", "no", "putenv", "putenv", "except", "nameerror", "pass", "else", "import", "userdict"], "doc_len": 89}
{"doc_id": "tests/unittest_utils.py::InferenceUtil.test_not_exclusive", "file_path": "tests/unittest_utils.py", "class_name": "InferenceUtil", "func_name": "test_not_exclusive", "text": "文件路径: tests/unittest_utils.py, 类名: InferenceUtil\n    def test_not_exclusive(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        x = 10\n        for x in range(5):\n            print (x)\n\n        if x > 0:\n            print ('#' * x)\n        \"\"\",\n            __name__,\n            __file__,\n        )\n        xass1 = module.locals[\"x\"][0]\n        assert xass1.lineno == 2\n        xnames = [n for n in module.nodes_of_class(nodes.Name) if n.name == \"x\"]\n        assert len(xnames) == 3\n        assert xnames[1].lineno == 6\n        self.assertEqual(nodes.are_exclusive(xass1, xnames[1]), False)\n        self.assertEqual(nodes.are_exclusive(xass1, xnames[2]), False)\n", "tokens": ["tests", "unittest_utils", "py", "inferenceutil", "def", "test_not_exclusive", "self", "none", "module", "builder", "parse", "x", "10", "for", "x", "in", "range", "5", "print", "x", "if", "x", "0", "print", "x", "__name__", "__file__", "xass1", "module", "locals", "x", "0", "assert", "xass1", "lineno", "2", "xnames", "n", "for", "n", "in", "module", "nodes_of_class", "nodes", "name", "if", "n", "name", "x", "assert", "len", "xnames", "3", "assert", "xnames", "1", "lineno", "6", "self", "assertequal", "nodes", "are_exclusive", "xass1", "xnames", "1", "false", "self", "assertequal", "nodes", "are_exclusive", "xass1", "xnames", "2", "false"], "doc_len": 74}
{"doc_id": "tests/unittest_utils.py::InferenceUtil.test_if", "file_path": "tests/unittest_utils.py", "class_name": "InferenceUtil", "func_name": "test_if", "text": "文件路径: tests/unittest_utils.py, 类名: InferenceUtil\n    def test_if(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        if 1:\n            a = 1\n            a = 2\n        elif 2:\n            a = 12\n            a = 13\n        else:\n            a = 3\n            a = 4\n        \"\"\"\n        )\n        a1 = module.locals[\"a\"][0]\n        a2 = module.locals[\"a\"][1]\n        a3 = module.locals[\"a\"][2]\n        a4 = module.locals[\"a\"][3]\n        a5 = module.locals[\"a\"][4]\n        a6 = module.locals[\"a\"][5]\n        self.assertEqual(nodes.are_exclusive(a1, a2), False)\n        self.assertEqual(nodes.are_exclusive(a1, a3), True)\n        self.assertEqual(nodes.are_exclusive(a1, a5), True)\n        self.assertEqual(nodes.are_exclusive(a3, a5), True)\n        self.assertEqual(nodes.are_exclusive(a3, a4), False)\n        self.assertEqual(nodes.are_exclusive(a5, a6), False)\n", "tokens": ["tests", "unittest_utils", "py", "inferenceutil", "def", "test_if", "self", "none", "module", "builder", "parse", "if", "1", "a", "1", "a", "2", "elif", "2", "a", "12", "a", "13", "else", "a", "3", "a", "4", "a1", "module", "locals", "a", "0", "a2", "module", "locals", "a", "1", "a3", "module", "locals", "a", "2", "a4", "module", "locals", "a", "3", "a5", "module", "locals", "a", "4", "a6", "module", "locals", "a", "5", "self", "assertequal", "nodes", "are_exclusive", "a1", "a2", "false", "self", "assertequal", "nodes", "are_exclusive", "a1", "a3", "true", "self", "assertequal", "nodes", "are_exclusive", "a1", "a5", "true", "self", "assertequal", "nodes", "are_exclusive", "a3", "a5", "true", "self", "assertequal", "nodes", "are_exclusive", "a3", "a4", "false", "self", "assertequal", "nodes", "are_exclusive", "a5", "a6", "false"], "doc_len": 100}
{"doc_id": "tests/unittest_utils.py::InferenceUtil.test_try_except", "file_path": "tests/unittest_utils.py", "class_name": "InferenceUtil", "func_name": "test_try_except", "text": "文件路径: tests/unittest_utils.py, 类名: InferenceUtil\n    def test_try_except(self) -> None:\n        module = builder.parse(\n            \"\"\"\n        try:\n            def exclusive_func2():\n                \"docstring\"\n        except TypeError:\n            def exclusive_func2():\n                \"docstring\"\n        except:\n            def exclusive_func2():\n                \"docstring\"\n        else:\n            def exclusive_func2():\n                \"this one redefine the one defined line 42\"\n        \"\"\"\n        )\n        f1 = module.locals[\"exclusive_func2\"][0]\n        f2 = module.locals[\"exclusive_func2\"][1]\n        f3 = module.locals[\"exclusive_func2\"][2]\n        f4 = module.locals[\"exclusive_func2\"][3]\n        self.assertEqual(nodes.are_exclusive(f1, f2), True)\n        self.assertEqual(nodes.are_exclusive(f1, f3), True)\n        self.assertEqual(nodes.are_exclusive(f1, f4), False)\n        self.assertEqual(nodes.are_exclusive(f2, f4), True)\n        self.assertEqual(nodes.are_exclusive(f3, f4), True)\n        self.assertEqual(nodes.are_exclusive(f3, f2), True)\n\n        self.assertEqual(nodes.are_exclusive(f2, f1), True)\n        self.assertEqual(nodes.are_exclusive(f4, f1), False)\n        self.assertEqual(nodes.are_exclusive(f4, f2), True)\n", "tokens": ["tests", "unittest_utils", "py", "inferenceutil", "def", "test_try_except", "self", "none", "module", "builder", "parse", "try", "def", "exclusive_func2", "docstring", "except", "typeerror", "def", "exclusive_func2", "docstring", "except", "def", "exclusive_func2", "docstring", "else", "def", "exclusive_func2", "this", "one", "redefine", "the", "one", "defined", "line", "42", "f1", "module", "locals", "exclusive_func2", "0", "f2", "module", "locals", "exclusive_func2", "1", "f3", "module", "locals", "exclusive_func2", "2", "f4", "module", "locals", "exclusive_func2", "3", "self", "assertequal", "nodes", "are_exclusive", "f1", "f2", "true", "self", "assertequal", "nodes", "are_exclusive", "f1", "f3", "true", "self", "assertequal", "nodes", "are_exclusive", "f1", "f4", "false", "self", "assertequal", "nodes", "are_exclusive", "f2", "f4", "true", "self", "assertequal", "nodes", "are_exclusive", "f3", "f4", "true", "self", "assertequal", "nodes", "are_exclusive", "f3", "f2", "true", "self", "assertequal", "nodes", "are_exclusive", "f2", "f1", "true", "self", "assertequal", "nodes", "are_exclusive", "f4", "f1", "false", "self", "assertequal", "nodes", "are_exclusive", "f4", "f2", "true"], "doc_len": 118}
{"doc_id": "tests/unittest_utils.py::InferenceUtil.test_unpack_infer_uninferable_nodes", "file_path": "tests/unittest_utils.py", "class_name": "InferenceUtil", "func_name": "test_unpack_infer_uninferable_nodes", "text": "文件路径: tests/unittest_utils.py, 类名: InferenceUtil\n    def test_unpack_infer_uninferable_nodes(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        x = [A] * 1\n        f = [x, [A] * 2]\n        f\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        unpacked = list(nodes.unpack_infer(inferred))\n        self.assertEqual(len(unpacked), 3)\n        self.assertTrue(all(elt is Uninferable for elt in unpacked))\n", "tokens": ["tests", "unittest_utils", "py", "inferenceutil", "def", "test_unpack_infer_uninferable_nodes", "self", "none", "node", "builder", "extract_node", "x", "a", "1", "f", "x", "a", "2", "f", "inferred", "next", "node", "infer", "unpacked", "list", "nodes", "unpack_infer", "inferred", "self", "assertequal", "len", "unpacked", "3", "self", "asserttrue", "all", "elt", "is", "uninferable", "for", "elt", "in", "unpacked"], "doc_len": 43}
{"doc_id": "tests/unittest_utils.py::InferenceUtil.test_unpack_infer_empty_tuple", "file_path": "tests/unittest_utils.py", "class_name": "InferenceUtil", "func_name": "test_unpack_infer_empty_tuple", "text": "文件路径: tests/unittest_utils.py, 类名: InferenceUtil\n    def test_unpack_infer_empty_tuple(self) -> None:\n        node = builder.extract_node(\n            \"\"\"\n        ()\n        \"\"\"\n        )\n        inferred = next(node.infer())\n        with self.assertRaises(InferenceError):\n            list(nodes.unpack_infer(inferred))\n", "tokens": ["tests", "unittest_utils", "py", "inferenceutil", "def", "test_unpack_infer_empty_tuple", "self", "none", "node", "builder", "extract_node", "inferred", "next", "node", "infer", "with", "self", "assertraises", "inferenceerror", "list", "nodes", "unpack_infer", "inferred"], "doc_len": 23}
{"doc_id": "tests/testdata/python3/data/all.py::func", "file_path": "tests/testdata/python3/data/all.py", "class_name": null, "func_name": "func", "text": "文件路径: tests/testdata/python3/data/all.py\ndef func(): print('yo')\n", "tokens": ["tests", "testdata", "python3", "data", "all", "py", "def", "func", "print", "yo"], "doc_len": 10}
{"doc_id": "tests/testdata/python3/data/descriptor_crash.py::Page.getPage", "file_path": "tests/testdata/python3/data/descriptor_crash.py", "class_name": "Page", "func_name": "getPage", "text": "文件路径: tests/testdata/python3/data/descriptor_crash.py, 类名: Page\n    def getPage(self, url):\n        handle = self._urlOpen(url)\n        data = handle.read()\n        handle.close()\n        return data\n", "tokens": ["tests", "testdata", "python3", "data", "descriptor_crash", "py", "page", "def", "getpage", "self", "url", "handle", "self", "_urlopen", "url", "data", "handle", "read", "handle", "close", "return", "data"], "doc_len": 22}
{"doc_id": "tests/testdata/python3/data/format.py::definition", "file_path": "tests/testdata/python3/data/format.py", "class_name": null, "func_name": "definition", "text": "文件路径: tests/testdata/python3/data/format.py\ndef definition(a,\n               b,\n               c):\n    return a + b + c\n", "tokens": ["tests", "testdata", "python3", "data", "format", "py", "def", "definition", "a", "b", "c", "return", "a", "b", "c"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/module.py::global_access", "file_path": "tests/testdata/python3/data/module.py", "class_name": null, "func_name": "global_access", "text": "文件路径: tests/testdata/python3/data/module.py\ndef global_access(key, val):\n    \"\"\"function test\"\"\"\n    local = 1\n    MY_DICT[key] = val\n    for i in val:\n        if i:\n            del MY_DICT[i]\n            continue\n        else:\n            break\n    else:\n        return\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "def", "global_access", "key", "val", "function", "test", "local", "1", "my_dict", "key", "val", "for", "i", "in", "val", "if", "i", "del", "my_dict", "i", "continue", "else", "break", "else", "return"], "doc_len": 31}
{"doc_id": "tests/testdata/python3/data/module.py::YO.__init__", "file_path": "tests/testdata/python3/data/module.py", "class_name": "YO", "func_name": "__init__", "text": "文件路径: tests/testdata/python3/data/module.py, 类名: YO\n    def __init__(self):\n        try:\n            self.yo = 1\n        except ValueError as ex:\n            pass\n        except (NameError, TypeError):\n            raise XXXError()\n        except:\n            raise\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "yo", "def", "__init__", "self", "try", "self", "yo", "1", "except", "valueerror", "as", "ex", "pass", "except", "nameerror", "typeerror", "raise", "xxxerror", "except", "raise"], "doc_len": 26}
{"doc_id": "tests/testdata/python3/data/module.py::YOUPI.__init__", "file_path": "tests/testdata/python3/data/module.py", "class_name": "YOUPI", "func_name": "__init__", "text": "文件路径: tests/testdata/python3/data/module.py, 类名: YOUPI\n    def __init__(self):\n        self.member = None\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "youpi", "def", "__init__", "self", "self", "member", "none"], "doc_len": 13}
{"doc_id": "tests/testdata/python3/data/module.py::YOUPI.method", "file_path": "tests/testdata/python3/data/module.py", "class_name": "YOUPI", "func_name": "method", "text": "文件路径: tests/testdata/python3/data/module.py, 类名: YOUPI\n    def method(self):\n        \"\"\"method\n        test\"\"\"\n        global MY_DICT\n        try:\n            MY_DICT = {}\n            local = None\n            autre = [a for (a, b) in MY_DICT if b]\n            if b in autre:\n                return\n            elif a in autre:\n                return 'hehe'\n            global_access(local, val=autre)\n        finally:\n            return local\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "youpi", "def", "method", "self", "method", "test", "global", "my_dict", "try", "my_dict", "local", "none", "autre", "a", "for", "a", "b", "in", "my_dict", "if", "b", "if", "b", "in", "autre", "return", "elif", "a", "in", "autre", "return", "hehe", "global_access", "local", "val", "autre", "finally", "return", "local"], "doc_len": 45}
{"doc_id": "tests/testdata/python3/data/module.py::YOUPI.static_method", "file_path": "tests/testdata/python3/data/module.py", "class_name": "YOUPI", "func_name": "static_method", "text": "文件路径: tests/testdata/python3/data/module.py, 类名: YOUPI\n    def static_method():\n        \"\"\"static method test\"\"\"\n        assert MY_DICT, '???'\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "youpi", "def", "static_method", "static", "method", "test", "assert", "my_dict"], "doc_len": 14}
{"doc_id": "tests/testdata/python3/data/module.py::YOUPI.class_method", "file_path": "tests/testdata/python3/data/module.py", "class_name": "YOUPI", "func_name": "class_method", "text": "文件路径: tests/testdata/python3/data/module.py, 类名: YOUPI\n    def class_method(cls):\n        \"\"\"class method test\"\"\"\n        exec(a, b)\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "youpi", "def", "class_method", "cls", "class", "method", "test", "exec", "a", "b"], "doc_len": 16}
{"doc_id": "tests/testdata/python3/data/module.py::four_args", "file_path": "tests/testdata/python3/data/module.py", "class_name": null, "func_name": "four_args", "text": "文件路径: tests/testdata/python3/data/module.py\ndef four_args(a, b, c, d):\n    \"\"\"four arguments (was nested_args)\"\"\"\n    while 1:\n        if a:\n            break\n        a += +1\n    else:\n        b += -2\n    if c:\n        d = a and (b or c)\n    else:\n        c = a and b or d\n    list(map(lambda x, y: (y, x), a))\n", "tokens": ["tests", "testdata", "python3", "data", "module", "py", "def", "four_args", "a", "b", "c", "d", "four", "arguments", "was", "nested_args", "while", "1", "if", "a", "break", "a", "1", "else", "b", "2", "if", "c", "d", "a", "and", "b", "or", "c", "else", "c", "a", "and", "b", "or", "d", "list", "map", "lambda", "x", "y", "y", "x", "a"], "doc_len": 49}
{"doc_id": "tests/testdata/python3/data/module2.py::AbstractClass.to_override", "file_path": "tests/testdata/python3/data/module2.py", "class_name": "AbstractClass", "func_name": "to_override", "text": "文件路径: tests/testdata/python3/data/module2.py, 类名: AbstractClass\n    def to_override(self, whatever):\n        raise NotImplementedError()\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "abstractclass", "def", "to_override", "self", "whatever", "raise", "notimplementederror"], "doc_len": 13}
{"doc_id": "tests/testdata/python3/data/module2.py::AbstractClass.return_something", "file_path": "tests/testdata/python3/data/module2.py", "class_name": "AbstractClass", "func_name": "return_something", "text": "文件路径: tests/testdata/python3/data/module2.py, 类名: AbstractClass\n    def return_something(self, param):\n        if param:\n            return 'toto'\n        return\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "abstractclass", "def", "return_something", "self", "param", "if", "param", "return", "toto", "return"], "doc_len": 16}
{"doc_id": "tests/testdata/python3/data/module2.py::raise_string", "file_path": "tests/testdata/python3/data/module2.py", "class_name": null, "func_name": "raise_string", "text": "文件路径: tests/testdata/python3/data/module2.py\ndef raise_string(a=2, *args, **kwargs):\n    raise Exception('yo')\n    yield 'coucou'\n    yield\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "def", "raise_string", "a", "2", "args", "kwargs", "raise", "exception", "yo", "yield", "coucou", "yield"], "doc_len": 18}
{"doc_id": "tests/testdata/python3/data/module2.py::make_class", "file_path": "tests/testdata/python3/data/module2.py", "class_name": null, "func_name": "make_class", "text": "文件路径: tests/testdata/python3/data/module2.py\ndef make_class(any, base=data.module.YO, *args, **kwargs):\n    \"\"\"check base is correctly resolved to Concrete0\"\"\"\n    \n    \n    class Aaaa(base):\n        \"\"\"dynamic class\"\"\"\n        \n    \n    return Aaaa\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "def", "make_class", "any", "base", "data", "module", "yo", "args", "kwargs", "check", "base", "is", "correctly", "resolved", "to", "concrete0", "class", "aaaa", "base", "dynamic", "class", "return", "aaaa"], "doc_len": 29}
{"doc_id": "tests/testdata/python3/data/module2.py::generator", "file_path": "tests/testdata/python3/data/module2.py", "class_name": null, "func_name": "generator", "text": "文件路径: tests/testdata/python3/data/module2.py\ndef generator():\n    \"\"\"A generator.\"\"\"\n    yield\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "def", "generator", "a", "generator", "yield"], "doc_len": 11}
{"doc_id": "tests/testdata/python3/data/module2.py::not_a_generator", "file_path": "tests/testdata/python3/data/module2.py", "class_name": null, "func_name": "not_a_generator", "text": "文件路径: tests/testdata/python3/data/module2.py\ndef not_a_generator():\n    \"\"\"A function that contains generator, but is not one.\"\"\"\n    \n    def generator():\n        yield\n    genl = lambda: (yield)\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "def", "not_a_generator", "a", "function", "that", "contains", "generator", "but", "is", "not", "one", "def", "generator", "yield", "genl", "lambda", "yield"], "doc_len": 23}
{"doc_id": "tests/testdata/python3/data/module2.py::with_metaclass", "file_path": "tests/testdata/python3/data/module2.py", "class_name": null, "func_name": "with_metaclass", "text": "文件路径: tests/testdata/python3/data/module2.py\ndef with_metaclass(meta, *bases):\n    return meta('NewBase', bases, {})\n", "tokens": ["tests", "testdata", "python3", "data", "module2", "py", "def", "with_metaclass", "meta", "bases", "return", "meta", "newbase", "bases"], "doc_len": 14}
{"doc_id": "tests/testdata/python3/data/noendingnewline.py::TestCase.setUp", "file_path": "tests/testdata/python3/data/noendingnewline.py", "class_name": "TestCase", "func_name": "setUp", "text": "文件路径: tests/testdata/python3/data/noendingnewline.py, 类名: TestCase\n    def setUp(self):\n        unittest.TestCase.setUp(self)\n", "tokens": ["tests", "testdata", "python3", "data", "noendingnewline", "py", "testcase", "def", "setup", "self", "unittest", "testcase", "setup", "self"], "doc_len": 14}
{"doc_id": "tests/testdata/python3/data/noendingnewline.py::TestCase.tearDown", "file_path": "tests/testdata/python3/data/noendingnewline.py", "class_name": "TestCase", "func_name": "tearDown", "text": "文件路径: tests/testdata/python3/data/noendingnewline.py, 类名: TestCase\n    def tearDown(self):\n        unittest.TestCase.tearDown(self)\n", "tokens": ["tests", "testdata", "python3", "data", "noendingnewline", "py", "testcase", "def", "teardown", "self", "unittest", "testcase", "teardown", "self"], "doc_len": 14}
{"doc_id": "tests/testdata/python3/data/noendingnewline.py::TestCase.testIt", "file_path": "tests/testdata/python3/data/noendingnewline.py", "class_name": "TestCase", "func_name": "testIt", "text": "文件路径: tests/testdata/python3/data/noendingnewline.py, 类名: TestCase\n    def testIt(self):\n        self.a = 10\n        self.xxx()\n", "tokens": ["tests", "testdata", "python3", "data", "noendingnewline", "py", "testcase", "def", "testit", "self", "self", "a", "10", "self", "xxx"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/noendingnewline.py::TestCase.xxx", "file_path": "tests/testdata/python3/data/noendingnewline.py", "class_name": "TestCase", "func_name": "xxx", "text": "文件路径: tests/testdata/python3/data/noendingnewline.py, 类名: TestCase\n    def xxx(self):\n        if False:\n            pass\n            print('a')\n\n        if False:\n            pass\n            pass\n\n        if False:\n            pass\n            print('rara')\n", "tokens": ["tests", "testdata", "python3", "data", "noendingnewline", "py", "testcase", "def", "xxx", "self", "if", "false", "pass", "print", "a", "if", "false", "pass", "pass", "if", "false", "pass", "print", "rara"], "doc_len": 24}
{"doc_id": "tests/testdata/python3/data/nonregr.py::toto", "file_path": "tests/testdata/python3/data/nonregr.py", "class_name": null, "func_name": "toto", "text": "文件路径: tests/testdata/python3/data/nonregr.py\ndef toto(value):\n    for k, v in value:\n        print(v.get('yo'))\n", "tokens": ["tests", "testdata", "python3", "data", "nonregr", "py", "def", "toto", "value", "for", "k", "v", "in", "value", "print", "v", "get", "yo"], "doc_len": 18}
{"doc_id": "tests/testdata/python3/data/nonregr.py::OptionParser.parse_args", "file_path": "tests/testdata/python3/data/nonregr.py", "class_name": "OptionParser", "func_name": "parse_args", "text": "文件路径: tests/testdata/python3/data/nonregr.py, 类名: OptionParser\n    def parse_args(self, args=None, values=None, real_optparse=False):\n        if real_optparse:\n            pass\n##          return super(OptionParser, self).parse_args()\n        else:\n            import optcomp\n            optcomp.completion(self)\n", "tokens": ["tests", "testdata", "python3", "data", "nonregr", "py", "optionparser", "def", "parse_args", "self", "args", "none", "values", "none", "real_optparse", "false", "if", "real_optparse", "pass", "return", "super", "optionparser", "self", "parse_args", "else", "import", "optcomp", "optcomp", "completion", "self"], "doc_len": 30}
{"doc_id": "tests/testdata/python3/data/nonregr.py::Aaa.__init__", "file_path": "tests/testdata/python3/data/nonregr.py", "class_name": "Aaa", "func_name": "__init__", "text": "文件路径: tests/testdata/python3/data/nonregr.py, 类名: Aaa\n    def __init__(self):\n        self.__setattr__('a','b')\n        pass\n", "tokens": ["tests", "testdata", "python3", "data", "nonregr", "py", "aaa", "def", "__init__", "self", "self", "__setattr__", "a", "b", "pass"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/nonregr.py::Aaa.one_public", "file_path": "tests/testdata/python3/data/nonregr.py", "class_name": "Aaa", "func_name": "one_public", "text": "文件路径: tests/testdata/python3/data/nonregr.py, 类名: Aaa\n    def one_public(self):\n        \"\"\"docstring\"\"\"\n        pass\n", "tokens": ["tests", "testdata", "python3", "data", "nonregr", "py", "aaa", "def", "one_public", "self", "docstring", "pass"], "doc_len": 12}
{"doc_id": "tests/testdata/python3/data/nonregr.py::Aaa.another_public", "file_path": "tests/testdata/python3/data/nonregr.py", "class_name": "Aaa", "func_name": "another_public", "text": "文件路径: tests/testdata/python3/data/nonregr.py, 类名: Aaa\n    def another_public(self):\n        \"\"\"docstring\"\"\"\n        pass\n", "tokens": ["tests", "testdata", "python3", "data", "nonregr", "py", "aaa", "def", "another_public", "self", "docstring", "pass"], "doc_len": 12}
{"doc_id": "tests/testdata/python3/data/notall.py::func", "file_path": "tests/testdata/python3/data/notall.py", "class_name": null, "func_name": "func", "text": "文件路径: tests/testdata/python3/data/notall.py\ndef func(): print('yo')\n", "tokens": ["tests", "testdata", "python3", "data", "notall", "py", "def", "func", "print", "yo"], "doc_len": 10}
{"doc_id": "tests/testdata/python3/data/appl/myConnection.py::MyConnection.__init__", "file_path": "tests/testdata/python3/data/appl/myConnection.py", "class_name": "MyConnection", "func_name": "__init__", "text": "文件路径: tests/testdata/python3/data/appl/myConnection.py, 类名: MyConnection\n    def __init__(self, dummy):\n        print('MyConnection init')\n", "tokens": ["tests", "testdata", "python3", "data", "appl", "myconnection", "py", "myconnection", "def", "__init__", "self", "dummy", "print", "myconnection", "init"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/beyond_top_level/namespace_package/plugin_api.py::top_message", "file_path": "tests/testdata/python3/data/beyond_top_level/namespace_package/plugin_api.py", "class_name": null, "func_name": "top_message", "text": "文件路径: tests/testdata/python3/data/beyond_top_level/namespace_package/plugin_api.py\ndef top_message(msg):\n    return \"top_message: %s\" % msg\n", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level", "namespace_package", "plugin_api", "py", "def", "top_message", "msg", "return", "top_message", "s", "msg"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/beyond_top_level/namespace_package/top_level_function.py::do_something", "file_path": "tests/testdata/python3/data/beyond_top_level/namespace_package/top_level_function.py", "class_name": null, "func_name": "do_something", "text": "文件路径: tests/testdata/python3/data/beyond_top_level/namespace_package/top_level_function.py\ndef do_something():\n    return plugin_message(\"called by do_something\")\n", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level", "namespace_package", "top_level_function", "py", "def", "do_something", "return", "plugin_message", "called", "by", "do_something"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/beyond_top_level/namespace_package/lower_level/helper_function.py::plugin_message", "file_path": "tests/testdata/python3/data/beyond_top_level/namespace_package/lower_level/helper_function.py", "class_name": null, "func_name": "plugin_message", "text": "文件路径: tests/testdata/python3/data/beyond_top_level/namespace_package/lower_level/helper_function.py\ndef plugin_message(msg):\n    return \"plugin_message: %s\" % top_message(msg)", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level", "namespace_package", "lower_level", "helper_function", "py", "def", "plugin_message", "msg", "return", "plugin_message", "s", "top_message", "msg"], "doc_len": 17}
{"doc_id": "tests/testdata/python3/data/beyond_top_level_two/a.py::do_something", "file_path": "tests/testdata/python3/data/beyond_top_level_two/a.py", "class_name": null, "func_name": "do_something", "text": "文件路径: tests/testdata/python3/data/beyond_top_level_two/a.py\ndef do_something(var, some_other_var):  # error\n    func(var, some_other_var)\n", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level_two", "a", "py", "def", "do_something", "var", "some_other_var", "error", "func", "var", "some_other_var"], "doc_len": 15}
{"doc_id": "tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py::func", "file_path": "tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py", "class_name": null, "func_name": "func", "text": "文件路径: tests/testdata/python3/data/beyond_top_level_two/level1/beyond_top_level_two.py\ndef func(var, some_other_var):\n    pass\n", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level_two", "level1", "beyond_top_level_two", "py", "def", "func", "var", "some_other_var", "pass"], "doc_len": 13}
{"doc_id": "tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py::func", "file_path": "tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py", "class_name": null, "func_name": "func", "text": "文件路径: tests/testdata/python3/data/beyond_top_level_two/level1/__init__.py\ndef func(var):\n    pass\n", "tokens": ["tests", "testdata", "python3", "data", "beyond_top_level_two", "level1", "__init__", "py", "def", "func", "var", "pass"], "doc_len": 12}
{"doc_id": "tests/testdata/python3/data/metaclass_recursion/monkeypatch.py::MonkeyPatchClass.patch", "file_path": "tests/testdata/python3/data/metaclass_recursion/monkeypatch.py", "class_name": "MonkeyPatchClass", "func_name": "patch", "text": "文件路径: tests/testdata/python3/data/metaclass_recursion/monkeypatch.py, 类名: MonkeyPatchClass\n    def patch(cls):\n        if parent.OriginalClass != MonkeyPatchClass:\n            cls._original_class = parent.OriginalClass\n            parent.OriginalClass = MonkeyPatchClass\n", "tokens": ["tests", "testdata", "python3", "data", "metaclass_recursion", "monkeypatch", "py", "monkeypatchclass", "def", "patch", "cls", "if", "parent", "originalclass", "monkeypatchclass", "cls", "_original_class", "parent", "originalclass", "parent", "originalclass", "monkeypatchclass"], "doc_len": 22}
{"doc_id": "tests/testdata/python3/data/metaclass_recursion/monkeypatch.py::MonkeyPatchClass.unpatch", "file_path": "tests/testdata/python3/data/metaclass_recursion/monkeypatch.py", "class_name": "MonkeyPatchClass", "func_name": "unpatch", "text": "文件路径: tests/testdata/python3/data/metaclass_recursion/monkeypatch.py, 类名: MonkeyPatchClass\n    def unpatch(cls):\n        if parent.OriginalClass == MonkeyPatchClass:\n            parent.OriginalClass = cls._original_class\n", "tokens": ["tests", "testdata", "python3", "data", "metaclass_recursion", "monkeypatch", "py", "monkeypatchclass", "def", "unpatch", "cls", "if", "parent", "originalclass", "monkeypatchclass", "parent", "originalclass", "cls", "_original_class"], "doc_len": 19}
{"doc_id": "tests/testdata/python3/data/SSL1/Connection1.py::Connection.__init__", "file_path": "tests/testdata/python3/data/SSL1/Connection1.py", "class_name": "Connection", "func_name": "__init__", "text": "文件路径: tests/testdata/python3/data/SSL1/Connection1.py, 类名: Connection\n    def __init__(self, ctx, sock=None):\n        print('init Connection')\n", "tokens": ["tests", "testdata", "python3", "data", "ssl1", "connection1", "py", "connection", "def", "__init__", "self", "ctx", "sock", "none", "print", "init", "connection"], "doc_len": 17}
