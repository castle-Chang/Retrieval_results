{"doc_id": "setup.py::data_files_inventory", "file_path": "setup.py", "class_name": null, "func_name": "data_files_inventory", "text": "文件路径: setup.py\ndef data_files_inventory():\n    data_files = []\n    data_roots = ['pydicom/data']\n    for data_root in data_roots:\n        for root, subfolder, files in os.walk(data_root):\n            files = [x.replace('pydicom/', '') for x in glob(root + '/*')\n                     if not os.path.isdir(x)]\n            data_files = data_files + files\n    return data_files\n", "tokens": ["setup", "py", "def", "data_files_inventory", "data_files", "data_roots", "pydicom", "data", "for", "data_root", "in", "data_roots", "for", "root", "subfolder", "files", "in", "os", "walk", "data_root", "files", "x", "replace", "pydicom", "for", "x", "in", "glob", "root", "if", "not", "os", "path", "isdir", "x", "data_files", "data_files", "files", "return", "data_files"], "doc_len": 40}
{"doc_id": "doc/conf.py::generate_example_rst", "file_path": "doc/conf.py", "class_name": null, "func_name": "generate_example_rst", "text": "文件路径: doc/conf.py\ndef generate_example_rst(app, what, name, obj, options, lines):\n    # generate empty examples files, so that we don't get\n    # inclusion errors if there are no examples for a class / module\n    examples_path = os.path.join(app.srcdir, \"generated\",\n                                 \"%s.examples\" % name)\n    if not os.path.exists(examples_path):\n        # touch file\n        open(examples_path, 'w').close()\n", "tokens": ["doc", "conf", "py", "def", "generate_example_rst", "app", "what", "name", "obj", "options", "lines", "generate", "empty", "examples", "files", "so", "that", "we", "don", "t", "get", "inclusion", "errors", "if", "there", "are", "no", "examples", "for", "a", "class", "module", "examples_path", "os", "path", "join", "app", "srcdir", "generated", "s", "examples", "name", "if", "not", "os", "path", "exists", "examples_path", "touch", "file", "open", "examples_path", "w", "close"], "doc_len": 54}
{"doc_id": "doc/conf.py::setup", "file_path": "doc/conf.py", "class_name": null, "func_name": "setup", "text": "文件路径: doc/conf.py\ndef setup(app):\n    app.connect('autodoc-process-docstring', generate_example_rst)\n    app.add_stylesheet('css/pydicom.css')\n", "tokens": ["doc", "conf", "py", "def", "setup", "app", "app", "connect", "autodoc", "process", "docstring", "generate_example_rst", "app", "add_stylesheet", "css", "pydicom", "css"], "doc_len": 17}
{"doc_id": "doc/sphinxext/github_link.py::_get_git_revision", "file_path": "doc/sphinxext/github_link.py", "class_name": null, "func_name": "_get_git_revision", "text": "文件路径: doc/sphinxext/github_link.py\ndef _get_git_revision():\n    try:\n        revision = subprocess.check_output(REVISION_CMD.split()).strip()\n    except (subprocess.CalledProcessError, OSError):\n        print('Failed to execute git to get revision')\n        return None\n    return revision.decode('utf-8')\n", "tokens": ["doc", "sphinxext", "github_link", "py", "def", "_get_git_revision", "try", "revision", "subprocess", "check_output", "revision_cmd", "split", "strip", "except", "subprocess", "calledprocesserror", "oserror", "print", "failed", "to", "execute", "git", "to", "get", "revision", "return", "none", "return", "revision", "decode", "utf", "8"], "doc_len": 32}
{"doc_id": "doc/sphinxext/github_link.py::_linkcode_resolve", "file_path": "doc/sphinxext/github_link.py", "class_name": null, "func_name": "_linkcode_resolve", "text": "文件路径: doc/sphinxext/github_link.py\ndef _linkcode_resolve(domain, info, package, url_fmt, revision):\n    \"\"\"Determine a link to online source for a class/method/function\n\n    This is called by sphinx.ext.linkcode\n\n    An example with a long-untouched module that everyone has\n    >>> _linkcode_resolve('py', {'module': 'tty',\n    ...                          'fullname': 'setraw'},\n    ...                   package='tty',\n    ...                   url_fmt='http://hg.python.org/cpython/file/'\n    ...                           '{revision}/Lib/{package}/{path}#L{lineno}',\n    ...                   revision='xxxx')\n    'http://hg.python.org/cpython/file/xxxx/Lib/tty/tty.py#L18'\n    \"\"\"\n\n    if revision is None:\n        return\n    if domain not in ('py', 'pyx'):\n        return\n    if not info.get('module') or not info.get('fullname'):\n        return\n\n    class_name = info['fullname'].split('.')[0]\n    if type(class_name) != str:\n        # Python 2 only\n        class_name = class_name.encode('utf-8')\n    module = __import__(info['module'], fromlist=[class_name])\n    obj = attrgetter(info['fullname'])(module)\n\n    try:\n        fn = inspect.getsourcefile(obj)\n    except Exception:\n        fn = None\n    if not fn:\n        try:\n            fn = inspect.getsourcefile(sys.modules[obj.__module__])\n        except Exception:\n            fn = None\n    if not fn:\n        return\n\n    fn = os.path.relpath(fn,\n                         start=os.path.dirname(__import__(package).__file__))\n    try:\n        lineno = inspect.getsourcelines(obj)[1]\n    except Exception:\n        lineno = ''\n    return url_fmt.format(revision=revision, package=package,\n                          path=fn, lineno=lineno)\n", "tokens": ["doc", "sphinxext", "github_link", "py", "def", "_linkcode_resolve", "domain", "info", "package", "url_fmt", "revision", "determine", "a", "link", "to", "online", "source", "for", "a", "class", "method", "function", "this", "is", "called", "by", "sphinx", "ext", "linkcode", "an", "example", "with", "a", "long", "untouched", "module", "that", "everyone", "has", "_linkcode_resolve", "py", "module", "tty", "fullname", "setraw", "package", "tty", "url_fmt", "http", "hg", "python", "org", "cpython", "file", "revision", "lib", "package", "path", "l", "lineno", "revision", "xxxx", "http", "hg", "python", "org", "cpython", "file", "xxxx", "lib", "tty", "tty", "py", "l18", "if", "revision", "is", "none", "return", "if", "domain", "not", "in", "py", "pyx", "return", "if", "not", "info", "get", "module", "or", "not", "info", "get", "fullname", "return", "class_name", "info", "fullname", "split", "0", "if", "type", "class_name", "str", "python", "2", "only", "class_name", "class_name", "encode", "utf", "8", "module", "__import__", "info", "module", "fromlist", "class_name", "obj", "attrgetter", "info", "fullname", "module", "try", "fn", "inspect", "getsourcefile", "obj", "except", "exception", "fn", "none", "if", "not", "fn", "try", "fn", "inspect", "getsourcefile", "sys", "modules", "obj", "__module__", "except", "exception", "fn", "none", "if", "not", "fn", "return", "fn", "os", "path", "relpath", "fn", "start", "os", "path", "dirname", "__import__", "package", "__file__", "try", "lineno", "inspect", "getsourcelines", "obj", "1", "except", "exception", "lineno", "return", "url_fmt", "format", "revision", "revision", "package", "package", "path", "fn", "lineno", "lineno"], "doc_len": 185}
{"doc_id": "doc/sphinxext/github_link.py::make_linkcode_resolve", "file_path": "doc/sphinxext/github_link.py", "class_name": null, "func_name": "make_linkcode_resolve", "text": "文件路径: doc/sphinxext/github_link.py\ndef make_linkcode_resolve(package, url_fmt):\n    \"\"\"Returns a linkcode_resolve function for the given URL format\n\n    revision is a git commit reference (hash or name)\n\n    package is the name of the root module of the package\n\n    url_fmt is along the lines of ('https://github.com/USER/PROJECT/'\n                                   'blob/{revision}/{package}/'\n                                   '{path}#L{lineno}')\n    \"\"\"\n    revision = _get_git_revision()\n    return partial(_linkcode_resolve, revision=revision, package=package,\n                   url_fmt=url_fmt)\n", "tokens": ["doc", "sphinxext", "github_link", "py", "def", "make_linkcode_resolve", "package", "url_fmt", "returns", "a", "linkcode_resolve", "function", "for", "the", "given", "url", "format", "revision", "is", "a", "git", "commit", "reference", "hash", "or", "name", "package", "is", "the", "name", "of", "the", "root", "module", "of", "the", "package", "url_fmt", "is", "along", "the", "lines", "of", "https", "github", "com", "user", "project", "blob", "revision", "package", "path", "l", "lineno", "revision", "_get_git_revision", "return", "partial", "_linkcode_resolve", "revision", "revision", "package", "package", "url_fmt", "url_fmt"], "doc_len": 65}
{"doc_id": "doc/sphinxext/sphinx_issues.py::user_role", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "user_role", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef user_role(name, rawtext, text, lineno,\n              inliner, options=None, content=None):\n    \"\"\"Sphinx role for linking to a user profile. Defaults to linking to\n    Github profiles, but the profile URIS can be configured via the\n    ``ref_user_uri`` config value.\n\n    Example: ::\n\n        :user:`sloria`\n    \"\"\"\n    options = options or {}\n    has_explicit_title, title, target = split_explicit_title(text)\n\n    target = utils.unescape(target).strip()\n    title = utils.unescape(title).strip()\n    config = inliner.document.settings.env.app.config\n    if config.issues_user_uri:\n        ref = config.ref_user_uri.format(user=target)\n    else:\n        ref = 'https://github.com/{0}'.format(target)\n    if has_explicit_title:\n        text = title\n    else:\n        text = '@{0}'.format(target)\n\n    link = nodes.reference(text=text, refuri=ref, **options)\n    return [link], []\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "user_role", "name", "rawtext", "text", "lineno", "inliner", "options", "none", "content", "none", "sphinx", "role", "for", "linking", "to", "a", "user", "profile", "defaults", "to", "linking", "to", "github", "profiles", "but", "the", "profile", "uris", "can", "be", "configured", "via", "the", "ref_user_uri", "config", "value", "example", "user", "sloria", "options", "options", "or", "has_explicit_title", "title", "target", "split_explicit_title", "text", "target", "utils", "unescape", "target", "strip", "title", "utils", "unescape", "title", "strip", "config", "inliner", "document", "settings", "env", "app", "config", "if", "config", "issues_user_uri", "ref", "config", "ref_user_uri", "format", "user", "target", "else", "ref", "https", "github", "com", "0", "format", "target", "if", "has_explicit_title", "text", "title", "else", "text", "0", "format", "target", "link", "nodes", "reference", "text", "text", "refuri", "ref", "options", "return", "link"], "doc_len": 105}
{"doc_id": "doc/sphinxext/sphinx_issues.py::_make_ref_node", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "_make_ref_node", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef _make_ref_node(ref_type, ref_no, config, uri=None, options=None):\n    options = options or {}\n    if ref_no not in ('-', '0'):\n        if uri:\n            ref = uri.format(ref_type=ref_type, ref_no=ref_no)\n        elif config.ref_github_path:\n            ref = 'https://github.com/{0}/{1}/{2}'.format(\n                config.ref_github_path, ref_type, ref_no\n            )\n        ref_text = '#{0}'.format(ref_no)\n        link = nodes.reference(text=ref_text, refuri=ref, **options)\n    else:\n        link = None\n    return link\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "_make_ref_node", "ref_type", "ref_no", "config", "uri", "none", "options", "none", "options", "options", "or", "if", "ref_no", "not", "in", "0", "if", "uri", "ref", "uri", "format", "ref_type", "ref_type", "ref_no", "ref_no", "elif", "config", "ref_github_path", "ref", "https", "github", "com", "0", "1", "2", "format", "config", "ref_github_path", "ref_type", "ref_no", "ref_text", "0", "format", "ref_no", "link", "nodes", "reference", "text", "ref_text", "refuri", "ref", "options", "else", "link", "none", "return", "link"], "doc_len": 62}
{"doc_id": "doc/sphinxext/sphinx_issues.py::_ref_role", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "_ref_role", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef _ref_role(ref_type, text, inliner, options=None):\n    \"\"\"Sphinx role for linking to a pull request. Must have\n    `pr_uri` or `issues_github_path` configured in ``conf.py``.\n    \"\"\"\n    options = options or {}\n    ref_nos = [each.strip() for each in utils.unescape(text).split(',')]\n    config = inliner.document.settings.env.app.config\n    ret = []\n    for i, ref_no in enumerate(ref_nos):\n        node = _make_ref_node(ref_type, ref_no, config, options=options)\n        ret.append(node)\n        if i != len(ref_nos) - 1:\n            sep = nodes.raw(text=', ', format='html')\n            ret.append(sep)\n    return ret, []\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "_ref_role", "ref_type", "text", "inliner", "options", "none", "sphinx", "role", "for", "linking", "to", "a", "pull", "request", "must", "have", "pr_uri", "or", "issues_github_path", "configured", "in", "conf", "py", "options", "options", "or", "ref_nos", "each", "strip", "for", "each", "in", "utils", "unescape", "text", "split", "config", "inliner", "document", "settings", "env", "app", "config", "ret", "for", "i", "ref_no", "in", "enumerate", "ref_nos", "node", "_make_ref_node", "ref_type", "ref_no", "config", "options", "options", "ret", "append", "node", "if", "i", "len", "ref_nos", "1", "sep", "nodes", "raw", "text", "format", "html", "ret", "append", "sep", "return", "ret"], "doc_len": 81}
{"doc_id": "doc/sphinxext/sphinx_issues.py::issue_role", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "issue_role", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef issue_role(name, rawtext, text, lineno,\n               inliner, options=None, content=None):\n    \"\"\"Sphinx role for linking to an issue. Must have\n    `ref_uri` or `ref_github_path` configured in ``conf.py``.\n\n    Examples: ::\n\n        :issue:`123`\n        :issue:`42,45`\n    \"\"\"\n    return _ref_role('issues', text, inliner, options)\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "issue_role", "name", "rawtext", "text", "lineno", "inliner", "options", "none", "content", "none", "sphinx", "role", "for", "linking", "to", "an", "issue", "must", "have", "ref_uri", "or", "ref_github_path", "configured", "in", "conf", "py", "examples", "issue", "123", "issue", "42", "45", "return", "_ref_role", "issues", "text", "inliner", "options"], "doc_len": 43}
{"doc_id": "doc/sphinxext/sphinx_issues.py::pull_request_role", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "pull_request_role", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef pull_request_role(name, rawtext, text, lineno,\n                      inliner, options=None, content=None):\n    \"\"\"Sphinx role for linking to a pull request. Must have\n    `ref_uri` or `ref_github_path` configured in ``conf.py``.\n\n    Examples: ::\n\n        :pull_request:`123`\n        :pull_request:`42,45`\n    \"\"\"\n    return _ref_role('pull', text, inliner, options)\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "pull_request_role", "name", "rawtext", "text", "lineno", "inliner", "options", "none", "content", "none", "sphinx", "role", "for", "linking", "to", "a", "pull", "request", "must", "have", "ref_uri", "or", "ref_github_path", "configured", "in", "conf", "py", "examples", "pull_request", "123", "pull_request", "42", "45", "return", "_ref_role", "pull", "text", "inliner", "options"], "doc_len": 44}
{"doc_id": "doc/sphinxext/sphinx_issues.py::setup", "file_path": "doc/sphinxext/sphinx_issues.py", "class_name": null, "func_name": "setup", "text": "文件路径: doc/sphinxext/sphinx_issues.py\ndef setup(app):\n    # Format template for issues/pull request URI\n    # e.g. 'https://github.com/sloria/marshmallow/{ref_type}/{ref_no}\n    app.add_config_value('ref_uri', default=None, rebuild='html')\n    # Shortcut for Github, e.g. 'sloria/marshmallow'\n    app.add_config_value('ref_github_path', default=None, rebuild='html')\n    # Format template for user profile URI\n    # e.g. 'https://github.com/{user}'\n    app.add_config_value('ref_user_uri', default=None, rebuild='html')\n    app.add_role('issue', issue_role)\n    app.add_role('pull_request', pull_request_role)\n    app.add_role('user', user_role)\n", "tokens": ["doc", "sphinxext", "sphinx_issues", "py", "def", "setup", "app", "format", "template", "for", "issues", "pull", "request", "uri", "e", "g", "https", "github", "com", "sloria", "marshmallow", "ref_type", "ref_no", "app", "add_config_value", "ref_uri", "default", "none", "rebuild", "html", "shortcut", "for", "github", "e", "g", "sloria", "marshmallow", "app", "add_config_value", "ref_github_path", "default", "none", "rebuild", "html", "format", "template", "for", "user", "profile", "uri", "e", "g", "https", "github", "com", "user", "app", "add_config_value", "ref_user_uri", "default", "none", "rebuild", "html", "app", "add_role", "issue", "issue_role", "app", "add_role", "pull_request", "pull_request_role", "app", "add_role", "user", "user_role"], "doc_len": 75}
{"doc_id": "examples/dicomtree.py::RunTree", "file_path": "examples/dicomtree.py", "class_name": null, "func_name": "RunTree", "text": "文件路径: examples/dicomtree.py\ndef RunTree(w, filename):\n    top = tkinter_tix.Frame(w, relief=tkinter_tix.RAISED, bd=1)\n    tree = tkinter_tix.Tree(top, options=\"hlist.columns 2\")\n    tree.pack(expand=1, fill=tkinter_tix.BOTH, padx=10, pady=10,\n              side=tkinter_tix.LEFT)\n    # print(tree.hlist.keys())   # use to see the available configure() options\n    tree.hlist.configure(bg='white', font='Courier 10', indent=30)\n    tree.hlist.configure(selectbackground='light yellow', gap=150)\n\n    box = tkinter_tix.ButtonBox(w, orientation=tkinter_tix.HORIZONTAL)\n    # box.add('ok', text='Ok', underline=0, command=w.destroy, width=6)\n    box.add('exit', text='Exit', underline=0, command=w.destroy, width=6)\n    box.pack(side=tkinter_tix.BOTTOM, fill=tkinter_tix.X)\n    top.pack(side=tkinter_tix.TOP, fill=tkinter_tix.BOTH, expand=1)\n\n    show_file(filename, tree)\n", "tokens": ["examples", "dicomtree", "py", "def", "runtree", "w", "filename", "top", "tkinter_tix", "frame", "w", "relief", "tkinter_tix", "raised", "bd", "1", "tree", "tkinter_tix", "tree", "top", "options", "hlist", "columns", "2", "tree", "pack", "expand", "1", "fill", "tkinter_tix", "both", "padx", "10", "pady", "10", "side", "tkinter_tix", "left", "print", "tree", "hlist", "keys", "use", "to", "see", "the", "available", "configure", "options", "tree", "hlist", "configure", "bg", "white", "font", "courier", "10", "indent", "30", "tree", "hlist", "configure", "selectbackground", "light", "yellow", "gap", "150", "box", "tkinter_tix", "buttonbox", "w", "orientation", "tkinter_tix", "horizontal", "box", "add", "ok", "text", "ok", "underline", "0", "command", "w", "destroy", "width", "6", "box", "add", "exit", "text", "exit", "underline", "0", "command", "w", "destroy", "width", "6", "box", "pack", "side", "tkinter_tix", "bottom", "fill", "tkinter_tix", "x", "top", "pack", "side", "tkinter_tix", "top", "fill", "tkinter_tix", "both", "expand", "1", "show_file", "filename", "tree"], "doc_len": 119}
{"doc_id": "examples/dicomtree.py::show_file", "file_path": "examples/dicomtree.py", "class_name": null, "func_name": "show_file", "text": "文件路径: examples/dicomtree.py\ndef show_file(filename, tree):\n    tree.hlist.add(\"root\", text=filename)\n    ds = pydicom.dcmread(sys.argv[1])\n    ds.decode()  # change strings to unicode\n    recurse_tree(tree, ds, \"root\", False)\n    tree.autosetmode()\n", "tokens": ["examples", "dicomtree", "py", "def", "show_file", "filename", "tree", "tree", "hlist", "add", "root", "text", "filename", "ds", "pydicom", "dcmread", "sys", "argv", "1", "ds", "decode", "change", "strings", "to", "unicode", "recurse_tree", "tree", "ds", "root", "false", "tree", "autosetmode"], "doc_len": 32}
{"doc_id": "examples/dicomtree.py::recurse_tree", "file_path": "examples/dicomtree.py", "class_name": null, "func_name": "recurse_tree", "text": "文件路径: examples/dicomtree.py\ndef recurse_tree(tree, dataset, parent, hide=False):\n    # order the dicom tags\n    for data_element in dataset:\n        node_id = parent + \".\" + hex(id(data_element))\n        if isinstance(data_element.value, compat.text_type):\n            tree.hlist.add(node_id, text=compat.text_type(data_element))\n        else:\n            tree.hlist.add(node_id, text=str(data_element))\n        if hide:\n            tree.hlist.hide_entry(node_id)\n        if data_element.VR == \"SQ\":   # a sequence\n            for i, dataset in enumerate(data_element.value):\n                item_id = node_id + \".\" + str(i + 1)\n                sq_item_description = data_element.name.replace(\n                    \" Sequence\", \"\")  # XXX not i18n\n                item_text = \"{0:s} {1:d}\".format(sq_item_description, i + 1)\n                tree.hlist.add(item_id, text=item_text)\n                tree.hlist.hide_entry(item_id)\n                recurse_tree(tree, dataset, item_id, hide=True)\n", "tokens": ["examples", "dicomtree", "py", "def", "recurse_tree", "tree", "dataset", "parent", "hide", "false", "order", "the", "dicom", "tags", "for", "data_element", "in", "dataset", "node_id", "parent", "hex", "id", "data_element", "if", "isinstance", "data_element", "value", "compat", "text_type", "tree", "hlist", "add", "node_id", "text", "compat", "text_type", "data_element", "else", "tree", "hlist", "add", "node_id", "text", "str", "data_element", "if", "hide", "tree", "hlist", "hide_entry", "node_id", "if", "data_element", "vr", "sq", "a", "sequence", "for", "i", "dataset", "in", "enumerate", "data_element", "value", "item_id", "node_id", "str", "i", "1", "sq_item_description", "data_element", "name", "replace", "sequence", "xxx", "not", "i18n", "item_text", "0", "s", "1", "d", "format", "sq_item_description", "i", "1", "tree", "hlist", "add", "item_id", "text", "item_text", "tree", "hlist", "hide_entry", "item_id", "recurse_tree", "tree", "dataset", "item_id", "hide", "true"], "doc_len": 102}
{"doc_id": "examples/input_output/plot_printing_dataset.py::myprint", "file_path": "examples/input_output/plot_printing_dataset.py", "class_name": null, "func_name": "myprint", "text": "文件路径: examples/input_output/plot_printing_dataset.py\ndef myprint(dataset, indent=0):\n    \"\"\"Go through all items in the dataset and print them with custom format\n\n    Modelled after Dataset._pretty_str()\n    \"\"\"\n    dont_print = ['Pixel Data', 'File Meta Information Version']\n\n    indent_string = \"   \" * indent\n    next_indent_string = \"   \" * (indent + 1)\n\n    for data_element in dataset:\n        if data_element.VR == \"SQ\":   # a sequence\n            print(indent_string, data_element.name)\n            for sequence_item in data_element.value:\n                myprint(sequence_item, indent + 1)\n                print(next_indent_string + \"---------\")\n        else:\n            if data_element.name in dont_print:\n                print(\"\"\"<item not printed -- in the \"don't print\" list>\"\"\")\n            else:\n                repr_value = repr(data_element.value)\n                if len(repr_value) > 50:\n                    repr_value = repr_value[:50] + \"...\"\n                print(\"{0:s} {1:s} = {2:s}\".format(indent_string,\n                                                   data_element.name,\n                                                   repr_value))\n", "tokens": ["examples", "input_output", "plot_printing_dataset", "py", "def", "myprint", "dataset", "indent", "0", "go", "through", "all", "items", "in", "the", "dataset", "and", "print", "them", "with", "custom", "format", "modelled", "after", "dataset", "_pretty_str", "dont_print", "pixel", "data", "file", "meta", "information", "version", "indent_string", "indent", "next_indent_string", "indent", "1", "for", "data_element", "in", "dataset", "if", "data_element", "vr", "sq", "a", "sequence", "print", "indent_string", "data_element", "name", "for", "sequence_item", "in", "data_element", "value", "myprint", "sequence_item", "indent", "1", "print", "next_indent_string", "else", "if", "data_element", "name", "in", "dont_print", "print", "item", "not", "printed", "in", "the", "don", "t", "print", "list", "else", "repr_value", "repr", "data_element", "value", "if", "len", "repr_value", "50", "repr_value", "repr_value", "50", "print", "0", "s", "1", "s", "2", "s", "format", "indent_string", "data_element", "name", "repr_value"], "doc_len": 103}
{"doc_id": "examples/input_output/plot_read_rtplan.py::list_beams", "file_path": "examples/input_output/plot_read_rtplan.py", "class_name": null, "func_name": "list_beams", "text": "文件路径: examples/input_output/plot_read_rtplan.py\ndef list_beams(plan_dataset):\n    \"\"\"Summarizes the RTPLAN beam information in the dataset.\"\"\"\n    lines = [\"{name:^13s} {num:^8s} {gantry:^8s} {ssd:^11s}\".format(\n        name=\"Beam name\", num=\"Number\", gantry=\"Gantry\", ssd=\"SSD (cm)\")]\n    for beam in plan_dataset.BeamSequence:\n        cp0 = beam.ControlPointSequence[0]\n        SSD = float(cp0.SourceToSurfaceDistance / 10)\n        lines.append(\"{b.BeamName:^13s} {b.BeamNumber:8d} \"\n                     \"{gantry:8.1f} {ssd:8.1f}\".format(b=beam,\n                                                       gantry=cp0.GantryAngle,\n                                                       ssd=SSD))\n    return \"\\n\".join(lines)\n", "tokens": ["examples", "input_output", "plot_read_rtplan", "py", "def", "list_beams", "plan_dataset", "summarizes", "the", "rtplan", "beam", "information", "in", "the", "dataset", "lines", "name", "13s", "num", "8s", "gantry", "8s", "ssd", "11s", "format", "name", "beam", "name", "num", "number", "gantry", "gantry", "ssd", "ssd", "cm", "for", "beam", "in", "plan_dataset", "beamsequence", "cp0", "beam", "controlpointsequence", "0", "ssd", "float", "cp0", "sourcetosurfacedistance", "10", "lines", "append", "b", "beamname", "13s", "b", "beamnumber", "8d", "gantry", "8", "1f", "ssd", "8", "1f", "format", "b", "beam", "gantry", "cp0", "gantryangle", "ssd", "ssd", "return", "n", "join", "lines"], "doc_len": 75}
{"doc_id": "examples/metadata_processing/plot_anonymize.py::person_names_callback", "file_path": "examples/metadata_processing/plot_anonymize.py", "class_name": null, "func_name": "person_names_callback", "text": "文件路径: examples/metadata_processing/plot_anonymize.py\ndef person_names_callback(dataset, data_element):\n    if data_element.VR == \"PN\":\n        data_element.value = \"anonymous\"\n", "tokens": ["examples", "metadata_processing", "plot_anonymize", "py", "def", "person_names_callback", "dataset", "data_element", "if", "data_element", "vr", "pn", "data_element", "value", "anonymous"], "doc_len": 15}
{"doc_id": "examples/metadata_processing/plot_anonymize.py::curves_callback", "file_path": "examples/metadata_processing/plot_anonymize.py", "class_name": null, "func_name": "curves_callback", "text": "文件路径: examples/metadata_processing/plot_anonymize.py\ndef curves_callback(dataset, data_element):\n    if data_element.tag.group & 0xFF00 == 0x5000:\n        del dataset[data_element.tag]\n", "tokens": ["examples", "metadata_processing", "plot_anonymize", "py", "def", "curves_callback", "dataset", "data_element", "if", "data_element", "tag", "group", "0xff00", "0x5000", "del", "dataset", "data_element", "tag"], "doc_len": 18}
{"doc_id": "pydicom/charset.py::_encode_to_jis_x_0201", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_encode_to_jis_x_0201", "text": "文件路径: pydicom/charset.py\ndef _encode_to_jis_x_0201(value, errors='strict'):\n    \"\"\"Convert a unicode string into JIS X 0201 byte string using shift_jis\n    encodings.\n    shift_jis is a superset of jis_x_0201. So we can regard the encoded value\n    as jis_x_0201 if it is single byte character.\n\n    Parameters\n    ----------\n    value : text type\n        The unicode string as presented to the user.\n    errors : str\n        The behavior of a character which could not be encoded. If 'strict' is\n        passed, raise an UnicodeEncodeError. If any other value is passed,\n        non ISO IR 14 characters are replaced by the ASCII '?'.\n\n    Returns\n    -------\n    byte string\n        The encoded string. If some characters in value could not be encoded to\n        JIS X 0201, and `errors` is not set to 'strict', they are replaced to\n        '?'.\n\n    Raises\n    ------\n    UnicodeEncodeError\n        If errors is set to 'strict' and `value` could not be encoded with\n        JIS X 0201.\n    \"\"\"\n\n    Encoder = codecs.getincrementalencoder('shift_jis')\n    encoder = Encoder()\n\n    # If errors is not strict, this function is used as fallback.\n    # In this case, we use only ISO IR 14 to encode given value\n    # without escape sequence.\n    if errors != 'strict' or value == '':\n        encoded = b''\n        for c in value:\n            try:\n                b = encoder.encode(c)\n            except UnicodeEncodeError as e:\n                b = b'?'\n\n            if len(b) != 1 or 0x80 <= ord(b):\n                b = b'?'\n            encoded += b\n        return encoded\n\n    encoded = encoder.encode(value[0])\n    if len(encoded) != 1:\n        raise UnicodeEncodeError(\n            'shift_jis', value, 0, len(value), 'illegal multibyte sequence')\n\n    msb = ord(encoded) & 0x80  # msb is 1 for ISO IR 13, 0 for ISO IR 14\n    for i, c in enumerate(value[1:], 1):\n        try:\n            b = encoder.encode(c)\n        except UnicodeEncodeError as e:\n            e.start = i\n            e.end = len(value)\n            raise e\n        if len(b) != 1 or ((ord(b) & 0x80) ^ msb) != 0:\n            character_set = 'ISO IR 14' if msb == 0 else 'ISO IR 13'\n            msg = 'Given character is out of {}'.format(character_set)\n            raise UnicodeEncodeError('shift_jis', value, i, len(value), msg)\n        encoded += b\n\n    return encoded\n", "tokens": ["pydicom", "charset", "py", "def", "_encode_to_jis_x_0201", "value", "errors", "strict", "convert", "a", "unicode", "string", "into", "jis", "x", "0201", "byte", "string", "using", "shift_jis", "encodings", "shift_jis", "is", "a", "superset", "of", "jis_x_0201", "so", "we", "can", "regard", "the", "encoded", "value", "as", "jis_x_0201", "if", "it", "is", "single", "byte", "character", "parameters", "value", "text", "type", "the", "unicode", "string", "as", "presented", "to", "the", "user", "errors", "str", "the", "behavior", "of", "a", "character", "which", "could", "not", "be", "encoded", "if", "strict", "is", "passed", "raise", "an", "unicodeencodeerror", "if", "any", "other", "value", "is", "passed", "non", "iso", "ir", "14", "characters", "are", "replaced", "by", "the", "ascii", "returns", "byte", "string", "the", "encoded", "string", "if", "some", "characters", "in", "value", "could", "not", "be", "encoded", "to", "jis", "x", "0201", "and", "errors", "is", "not", "set", "to", "strict", "they", "are", "replaced", "to", "raises", "unicodeencodeerror", "if", "errors", "is", "set", "to", "strict", "and", "value", "could", "not", "be", "encoded", "with", "jis", "x", "0201", "encoder", "codecs", "getincrementalencoder", "shift_jis", "encoder", "encoder", "if", "errors", "is", "not", "strict", "this", "function", "is", "used", "as", "fallback", "in", "this", "case", "we", "use", "only", "iso", "ir", "14", "to", "encode", "given", "value", "without", "escape", "sequence", "if", "errors", "strict", "or", "value", "encoded", "b", "for", "c", "in", "value", "try", "b", "encoder", "encode", "c", "except", "unicodeencodeerror", "as", "e", "b", "b", "if", "len", "b", "1", "or", "0x80", "ord", "b", "b", "b", "encoded", "b", "return", "encoded", "encoded", "encoder", "encode", "value", "0", "if", "len", "encoded", "1", "raise", "unicodeencodeerror", "shift_jis", "value", "0", "len", "value", "illegal", "multibyte", "sequence", "msb", "ord", "encoded", "0x80", "msb", "is", "1", "for", "iso", "ir", "13", "0", "for", "iso", "ir", "14", "for", "i", "c", "in", "enumerate", "value", "1", "1", "try", "b", "encoder", "encode", "c", "except", "unicodeencodeerror", "as", "e", "e", "start", "i", "e", "end", "len", "value", "raise", "e", "if", "len", "b", "1", "or", "ord", "b", "0x80", "msb", "0", "character_set", "iso", "ir", "14", "if", "msb", "0", "else", "iso", "ir", "13", "msg", "given", "character", "is", "out", "of", "format", "character_set", "raise", "unicodeencodeerror", "shift_jis", "value", "i", "len", "value", "msg", "encoded", "b", "return", "encoded"], "doc_len": 308}
{"doc_id": "pydicom/charset.py::_encode_to_jis_x_0208", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_encode_to_jis_x_0208", "text": "文件路径: pydicom/charset.py\ndef _encode_to_jis_x_0208(value, errors='strict'):\n    \"\"\"Convert a unicode string into JIS X 0208 byte string using iso2022_jp\n    encodings.\n    The escape sequence which is located at the end of the encoded value has\n    to vary depending on the value 1 of SpecificCharacterSet. So we have to\n    trim it and append the correct escape sequence manually.\n\n    Parameters\n    ----------\n    value : text type\n        The unicode string as presented to the user.\n    errors : str\n        The behavior of a character which could not be encoded. This value\n        is passed to errors argument of str.encode().\n\n    Returns\n    -------\n    byte string\n        The encoded string. If some characters in value could not be encoded to\n        JIS X 0208, it depends on the behavior of iso2022_jp encoder.\n\n    Raises\n    ------\n    UnicodeEncodeError\n        If errors is set to 'strict' and `value` could not be encoded with\n        JIS X 0208.\n    \"\"\"\n\n    # If errors is not strict, this function is used as fallback.\n    # So keep the tail escape sequence of encoded for backward compatibility.\n    if errors != 'strict':\n        return value.encode('iso2022_jp', errors=errors)\n\n    Encoder = codecs.getincrementalencoder('iso2022-jp')\n    encoder = Encoder()\n\n    encoded = encoder.encode(value[0])\n    if encoded[:3] != ENCODINGS_TO_CODES['iso2022_jp']:\n        raise UnicodeEncodeError(\n            'iso2022_jp', value, 0, len(value),\n            'Given character is out of ISO IR 87')\n\n    for i, c in enumerate(value[1:], 1):\n        try:\n            b = encoder.encode(c)\n        except UnicodeEncodeError as e:\n            e.start = i\n            e.end = len(value)\n            raise e\n        if b[:3] == ENCODINGS_TO_CODES['iso8859']:\n            raise UnicodeEncodeError(\n                'iso2022_jp', value, i, len(value),\n                'Given character is out of ISO IR 87')\n        encoded += b\n    return encoded\n", "tokens": ["pydicom", "charset", "py", "def", "_encode_to_jis_x_0208", "value", "errors", "strict", "convert", "a", "unicode", "string", "into", "jis", "x", "0208", "byte", "string", "using", "iso2022_jp", "encodings", "the", "escape", "sequence", "which", "is", "located", "at", "the", "end", "of", "the", "encoded", "value", "has", "to", "vary", "depending", "on", "the", "value", "1", "of", "specificcharacterset", "so", "we", "have", "to", "trim", "it", "and", "append", "the", "correct", "escape", "sequence", "manually", "parameters", "value", "text", "type", "the", "unicode", "string", "as", "presented", "to", "the", "user", "errors", "str", "the", "behavior", "of", "a", "character", "which", "could", "not", "be", "encoded", "this", "value", "is", "passed", "to", "errors", "argument", "of", "str", "encode", "returns", "byte", "string", "the", "encoded", "string", "if", "some", "characters", "in", "value", "could", "not", "be", "encoded", "to", "jis", "x", "0208", "it", "depends", "on", "the", "behavior", "of", "iso2022_jp", "encoder", "raises", "unicodeencodeerror", "if", "errors", "is", "set", "to", "strict", "and", "value", "could", "not", "be", "encoded", "with", "jis", "x", "0208", "if", "errors", "is", "not", "strict", "this", "function", "is", "used", "as", "fallback", "so", "keep", "the", "tail", "escape", "sequence", "of", "encoded", "for", "backward", "compatibility", "if", "errors", "strict", "return", "value", "encode", "iso2022_jp", "errors", "errors", "encoder", "codecs", "getincrementalencoder", "iso2022", "jp", "encoder", "encoder", "encoded", "encoder", "encode", "value", "0", "if", "encoded", "3", "encodings_to_codes", "iso2022_jp", "raise", "unicodeencodeerror", "iso2022_jp", "value", "0", "len", "value", "given", "character", "is", "out", "of", "iso", "ir", "87", "for", "i", "c", "in", "enumerate", "value", "1", "1", "try", "b", "encoder", "encode", "c", "except", "unicodeencodeerror", "as", "e", "e", "start", "i", "e", "end", "len", "value", "raise", "e", "if", "b", "3", "encodings_to_codes", "iso8859", "raise", "unicodeencodeerror", "iso2022_jp", "value", "i", "len", "value", "given", "character", "is", "out", "of", "iso", "ir", "87", "encoded", "b", "return", "encoded"], "doc_len": 249}
{"doc_id": "pydicom/charset.py::_get_escape_sequence_for_encoding", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_get_escape_sequence_for_encoding", "text": "文件路径: pydicom/charset.py\ndef _get_escape_sequence_for_encoding(encoding, encoded=None):\n    \"\"\" Return an escape sequence corresponding to the given encoding. If\n    encoding is 'shift_jis', return 'ESC)I' or 'ESC(J' depending on the first\n    byte of encoded.\n\n    Parameters\n    ----------\n    encoding : str\n        An encoding is used to specify  an escape sequence.\n\n    encoded : bytes or str\n        The encoded value is used to chose an escape sequence if encoding is\n        'shift_jis'\n\n    Returns\n    -------\n    string\n        Escape sequence for encoded value.\n    \"\"\"\n\n    ESC_ISO_IR_14 = ESC + b'(J'\n    ESC_ISO_IR_13 = ESC + b')I'\n\n    if encoding == 'shift_jis':\n        if encoded is None:\n            return ESC_ISO_IR_14\n\n        if not in_py2:\n            first_byte = encoded[0]\n        else:\n            first_byte = ord(encoded[0])\n        if 0x80 <= first_byte:\n            return ESC_ISO_IR_13\n\n        return ESC_ISO_IR_14\n    return ENCODINGS_TO_CODES.get(encoding, b'')\n", "tokens": ["pydicom", "charset", "py", "def", "_get_escape_sequence_for_encoding", "encoding", "encoded", "none", "return", "an", "escape", "sequence", "corresponding", "to", "the", "given", "encoding", "if", "encoding", "is", "shift_jis", "return", "esc", "i", "or", "esc", "j", "depending", "on", "the", "first", "byte", "of", "encoded", "parameters", "encoding", "str", "an", "encoding", "is", "used", "to", "specify", "an", "escape", "sequence", "encoded", "bytes", "or", "str", "the", "encoded", "value", "is", "used", "to", "chose", "an", "escape", "sequence", "if", "encoding", "is", "shift_jis", "returns", "string", "escape", "sequence", "for", "encoded", "value", "esc_iso_ir_14", "esc", "b", "j", "esc_iso_ir_13", "esc", "b", "i", "if", "encoding", "shift_jis", "if", "encoded", "is", "none", "return", "esc_iso_ir_14", "if", "not", "in_py2", "first_byte", "encoded", "0", "else", "first_byte", "ord", "encoded", "0", "if", "0x80", "first_byte", "return", "esc_iso_ir_13", "return", "esc_iso_ir_14", "return", "encodings_to_codes", "get", "encoding", "b"], "doc_len": 111}
{"doc_id": "pydicom/charset.py::decode_string", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "decode_string", "text": "文件路径: pydicom/charset.py\ndef decode_string(value, encodings, delimiters):\n    \"\"\"Convert a raw byte string into a unicode string using the given\n    list of encodings.\n\n    Parameters\n    ----------\n    value : byte string\n        The raw string as encoded in the DICOM tag value.\n    encodings : list\n        The encodings needed to decode the string as a list of Python\n        encodings, converted from the encodings in Specific Character Set.\n    delimiters: set of int (Python 3) or characters (Python 2)\n        A set of characters or character codes, each of which resets the\n        encoding in `byte_str`.\n\n    Returns\n    -------\n    text type\n        The decoded unicode string. If the value could not be decoded,\n        and `config.enforce_valid_values` is not set, a warning is issued,\n        and the value is decoded using the first encoding with replacement\n        characters, resulting in data loss.\n\n    Raises\n    ------\n    UnicodeDecodeError\n        If `config.enforce_valid_values` is set and `value` could not be\n        decoded with the given encodings.\n    \"\"\"\n    # shortcut for the common case - no escape sequences present\n    if ESC not in value:\n        first_encoding = encodings[0]\n        try:\n            return value.decode(first_encoding)\n        except LookupError:\n            if config.enforce_valid_values:\n                raise\n            warnings.warn(u\"Unknown encoding '{}' - \"\n                          u\"using default encoding instead\"\n                          .format(first_encoding))\n            first_encoding = default_encoding\n            return value.decode(first_encoding)\n        except UnicodeError:\n            if config.enforce_valid_values:\n                raise\n            warnings.warn(u\"Failed to decode byte string with encoding '{}' - \"\n                          u\"using replacement characters in decoded \"\n                          u\"string\".format(first_encoding))\n            return value.decode(first_encoding, errors='replace')\n\n    # Each part of the value that starts with an escape sequence is decoded\n    # separately. If it starts with an escape sequence, the\n    # corresponding encoding is used, otherwise (e.g. the first part if it\n    # does not start with an escape sequence) the first encoding.\n    # See PS3.5, 6.1.2.4 and 6.1.2.5 for the use of code extensions.\n    #\n    # The following regex splits the value into these parts, by matching\n    # the substring until the first escape character, and subsequent\n    # substrings starting with an escape character.\n    regex = b'(^[^\\x1b]+|[\\x1b][^\\x1b]*)'\n    fragments = re.findall(regex, value)\n\n    # decode each byte string fragment with it's corresponding encoding\n    # and join them all together\n    return u''.join([_decode_fragment(fragment, encodings, delimiters)\n                     for fragment in fragments])\n", "tokens": ["pydicom", "charset", "py", "def", "decode_string", "value", "encodings", "delimiters", "convert", "a", "raw", "byte", "string", "into", "a", "unicode", "string", "using", "the", "given", "list", "of", "encodings", "parameters", "value", "byte", "string", "the", "raw", "string", "as", "encoded", "in", "the", "dicom", "tag", "value", "encodings", "list", "the", "encodings", "needed", "to", "decode", "the", "string", "as", "a", "list", "of", "python", "encodings", "converted", "from", "the", "encodings", "in", "specific", "character", "set", "delimiters", "set", "of", "int", "python", "3", "or", "characters", "python", "2", "a", "set", "of", "characters", "or", "character", "codes", "each", "of", "which", "resets", "the", "encoding", "in", "byte_str", "returns", "text", "type", "the", "decoded", "unicode", "string", "if", "the", "value", "could", "not", "be", "decoded", "and", "config", "enforce_valid_values", "is", "not", "set", "a", "warning", "is", "issued", "and", "the", "value", "is", "decoded", "using", "the", "first", "encoding", "with", "replacement", "characters", "resulting", "in", "data", "loss", "raises", "unicodedecodeerror", "if", "config", "enforce_valid_values", "is", "set", "and", "value", "could", "not", "be", "decoded", "with", "the", "given", "encodings", "shortcut", "for", "the", "common", "case", "no", "escape", "sequences", "present", "if", "esc", "not", "in", "value", "first_encoding", "encodings", "0", "try", "return", "value", "decode", "first_encoding", "except", "lookuperror", "if", "config", "enforce_valid_values", "raise", "warnings", "warn", "u", "unknown", "encoding", "u", "using", "default", "encoding", "instead", "format", "first_encoding", "first_encoding", "default_encoding", "return", "value", "decode", "first_encoding", "except", "unicodeerror", "if", "config", "enforce_valid_values", "raise", "warnings", "warn", "u", "failed", "to", "decode", "byte", "string", "with", "encoding", "u", "using", "replacement", "characters", "in", "decoded", "u", "string", "format", "first_encoding", "return", "value", "decode", "first_encoding", "errors", "replace", "each", "part", "of", "the", "value", "that", "starts", "with", "an", "escape", "sequence", "is", "decoded", "separately", "if", "it", "starts", "with", "an", "escape", "sequence", "the", "corresponding", "encoding", "is", "used", "otherwise", "e", "g", "the", "first", "part", "if", "it", "does", "not", "start", "with", "an", "escape", "sequence", "the", "first", "encoding", "see", "ps3", "5", "6", "1", "2", "4", "and", "6", "1", "2", "5", "for", "the", "use", "of", "code", "extensions", "the", "following", "regex", "splits", "the", "value", "into", "these", "parts", "by", "matching", "the", "substring", "until", "the", "first", "escape", "character", "and", "subsequent", "substrings", "starting", "with", "an", "escape", "character", "regex", "b", "x1b", "x1b", "x1b", "fragments", "re", "findall", "regex", "value", "decode", "each", "byte", "string", "fragment", "with", "it", "s", "corresponding", "encoding", "and", "join", "them", "all", "together", "return", "u", "join", "_decode_fragment", "fragment", "encodings", "delimiters", "for", "fragment", "in", "fragments"], "doc_len": 344}
{"doc_id": "pydicom/charset.py::_decode_fragment", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_decode_fragment", "text": "文件路径: pydicom/charset.py\ndef _decode_fragment(byte_str, encodings, delimiters):\n    \"\"\"Decode a byte string encoded with a single encoding.\n    If `byte_str` starts with an escape sequence, the encoding corresponding\n    to this sequence is used for decoding if present in `encodings`,\n    otherwise the first value in encodings.\n    If a delimiter occurs inside the string, it resets the encoding to the\n    first encoding in case of single-byte encodings.\n\n    Parameters\n    ----------\n    byte_str : bytes\n        The raw string to be decoded.\n    encodings: list of str\n        The list of Python encodings as converted from the values in the\n        Specific Character Set tag.\n    delimiters: set of int (Python 3) or characters (Python 2)\n        A set of characters or character codes, each of which resets the\n        encoding in `byte_str`.\n\n    Returns\n    -------\n    text type\n        The decoded unicode string. If the value could not be decoded,\n        and `config.enforce_valid_values` is not set, a warning is issued,\n        and the value is decoded using the first encoding with replacement\n        characters, resulting in data loss.\n\n    Raises\n    ------\n    UnicodeDecodeError\n        If `config.enforce_valid_values` is set and `value` could not be\n        decoded with the given encodings.\n\n    Reference\n    ---------\n    * DICOM Standard Part 5, Sections 6.1.2.4 and 6.1.2.5\n    * DICOM Standard Part 3, Anex C.12.1.1.2\n    \"\"\"\n    try:\n        if byte_str.startswith(ESC):\n            return _decode_escaped_fragment(byte_str, encodings, delimiters)\n        # no escape sequence - use first encoding\n        return byte_str.decode(encodings[0])\n    except UnicodeError:\n        if config.enforce_valid_values:\n            raise\n        warnings.warn(u\"Failed to decode byte string with encodings: {} - \"\n                      u\"using replacement characters in decoded \"\n                      u\"string\".format(', '.join(encodings)))\n        return byte_str.decode(encodings[0], errors='replace')\n", "tokens": ["pydicom", "charset", "py", "def", "_decode_fragment", "byte_str", "encodings", "delimiters", "decode", "a", "byte", "string", "encoded", "with", "a", "single", "encoding", "if", "byte_str", "starts", "with", "an", "escape", "sequence", "the", "encoding", "corresponding", "to", "this", "sequence", "is", "used", "for", "decoding", "if", "present", "in", "encodings", "otherwise", "the", "first", "value", "in", "encodings", "if", "a", "delimiter", "occurs", "inside", "the", "string", "it", "resets", "the", "encoding", "to", "the", "first", "encoding", "in", "case", "of", "single", "byte", "encodings", "parameters", "byte_str", "bytes", "the", "raw", "string", "to", "be", "decoded", "encodings", "list", "of", "str", "the", "list", "of", "python", "encodings", "as", "converted", "from", "the", "values", "in", "the", "specific", "character", "set", "tag", "delimiters", "set", "of", "int", "python", "3", "or", "characters", "python", "2", "a", "set", "of", "characters", "or", "character", "codes", "each", "of", "which", "resets", "the", "encoding", "in", "byte_str", "returns", "text", "type", "the", "decoded", "unicode", "string", "if", "the", "value", "could", "not", "be", "decoded", "and", "config", "enforce_valid_values", "is", "not", "set", "a", "warning", "is", "issued", "and", "the", "value", "is", "decoded", "using", "the", "first", "encoding", "with", "replacement", "characters", "resulting", "in", "data", "loss", "raises", "unicodedecodeerror", "if", "config", "enforce_valid_values", "is", "set", "and", "value", "could", "not", "be", "decoded", "with", "the", "given", "encodings", "reference", "dicom", "standard", "part", "5", "sections", "6", "1", "2", "4", "and", "6", "1", "2", "5", "dicom", "standard", "part", "3", "anex", "c", "12", "1", "1", "2", "try", "if", "byte_str", "startswith", "esc", "return", "_decode_escaped_fragment", "byte_str", "encodings", "delimiters", "no", "escape", "sequence", "use", "first", "encoding", "return", "byte_str", "decode", "encodings", "0", "except", "unicodeerror", "if", "config", "enforce_valid_values", "raise", "warnings", "warn", "u", "failed", "to", "decode", "byte", "string", "with", "encodings", "u", "using", "replacement", "characters", "in", "decoded", "u", "string", "format", "join", "encodings", "return", "byte_str", "decode", "encodings", "0", "errors", "replace"], "doc_len": 256}
{"doc_id": "pydicom/charset.py::_decode_escaped_fragment", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_decode_escaped_fragment", "text": "文件路径: pydicom/charset.py\ndef _decode_escaped_fragment(byte_str, encodings, delimiters):\n    \"\"\"Decodes a byte string starting with an escape sequence.\n    See `_decode_fragment` for parameter description and more information.\n    \"\"\"\n    # all 4-character escape codes start with one of two character sets\n    seq_length = 4 if byte_str.startswith((b'\\x1b$(', b'\\x1b$)')) else 3\n    encoding = CODES_TO_ENCODINGS.get(byte_str[:seq_length], '')\n    if encoding in encodings or encoding == default_encoding:\n        if encoding in handled_encodings:\n            # Python strips the escape sequences for this encoding.\n            # Any delimiters must be handled correctly by `byte_str`.\n            return byte_str.decode(encoding)\n        else:\n            # Python doesn't know about the escape sequence -\n            # we have to strip it before decoding\n            byte_str = byte_str[seq_length:]\n\n            # If a delimiter occurs in the string, it resets the encoding.\n            # The following returns the first occurrence of a delimiter in\n            # the byte string, or None if it does not contain any.\n            index = next((index for index, ch in enumerate(byte_str)\n                          if ch in delimiters), None)\n            if index is not None:\n                # the part of the string after the first delimiter\n                # is decoded with the first encoding\n                return (byte_str[:index].decode(encoding) +\n                        byte_str[index:].decode(encodings[0]))\n            # No delimiter - use the encoding defined by the escape code\n            return byte_str.decode(encoding)\n\n    # unknown escape code - use first encoding\n    msg = u\"Found unknown escape sequence in encoded string value\"\n    if config.enforce_valid_values:\n        raise ValueError(msg)\n    warnings.warn(msg + u\" - using encoding {}\".format(encodings[0]))\n    return byte_str.decode(encodings[0], errors='replace')\n", "tokens": ["pydicom", "charset", "py", "def", "_decode_escaped_fragment", "byte_str", "encodings", "delimiters", "decodes", "a", "byte", "string", "starting", "with", "an", "escape", "sequence", "see", "_decode_fragment", "for", "parameter", "description", "and", "more", "information", "all", "4", "character", "escape", "codes", "start", "with", "one", "of", "two", "character", "sets", "seq_length", "4", "if", "byte_str", "startswith", "b", "x1b", "b", "x1b", "else", "3", "encoding", "codes_to_encodings", "get", "byte_str", "seq_length", "if", "encoding", "in", "encodings", "or", "encoding", "default_encoding", "if", "encoding", "in", "handled_encodings", "python", "strips", "the", "escape", "sequences", "for", "this", "encoding", "any", "delimiters", "must", "be", "handled", "correctly", "by", "byte_str", "return", "byte_str", "decode", "encoding", "else", "python", "doesn", "t", "know", "about", "the", "escape", "sequence", "we", "have", "to", "strip", "it", "before", "decoding", "byte_str", "byte_str", "seq_length", "if", "a", "delimiter", "occurs", "in", "the", "string", "it", "resets", "the", "encoding", "the", "following", "returns", "the", "first", "occurrence", "of", "a", "delimiter", "in", "the", "byte", "string", "or", "none", "if", "it", "does", "not", "contain", "any", "index", "next", "index", "for", "index", "ch", "in", "enumerate", "byte_str", "if", "ch", "in", "delimiters", "none", "if", "index", "is", "not", "none", "the", "part", "of", "the", "string", "after", "the", "first", "delimiter", "is", "decoded", "with", "the", "first", "encoding", "return", "byte_str", "index", "decode", "encoding", "byte_str", "index", "decode", "encodings", "0", "no", "delimiter", "use", "the", "encoding", "defined", "by", "the", "escape", "code", "return", "byte_str", "decode", "encoding", "unknown", "escape", "code", "use", "first", "encoding", "msg", "u", "found", "unknown", "escape", "sequence", "in", "encoded", "string", "value", "if", "config", "enforce_valid_values", "raise", "valueerror", "msg", "warnings", "warn", "msg", "u", "using", "encoding", "format", "encodings", "0", "return", "byte_str", "decode", "encodings", "0", "errors", "replace"], "doc_len": 231}
{"doc_id": "pydicom/charset.py::encode_string", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "encode_string", "text": "文件路径: pydicom/charset.py\ndef encode_string(value, encodings):\n    \"\"\"Convert a unicode string into a byte string using the given\n    list of encodings.\n\n    Parameters\n    ----------\n    value : text type\n        The unicode string as presented to the user.\n    encodings : list\n        The encodings needed to encode the string as a list of Python\n        encodings, converted from the encodings in Specific Character Set.\n\n    Returns\n    -------\n    byte string\n        The encoded string. If the value could not be encoded with any of\n        the given encodings, and `config.enforce_valid_values` is not set, a\n        warning is issued, and the value is encoded using the first\n        encoding with replacement characters, resulting in data loss.\n\n    Raises\n    ------\n    UnicodeEncodeError\n        If `config.enforce_valid_values` is set and `value` could not be\n        encoded with the given encodings.\n    \"\"\"\n    for i, encoding in enumerate(encodings):\n        try:\n            encoded = _encode_string_impl(value, encoding)\n\n            if i > 0 and encoding not in handled_encodings:\n                escape_sequence = _get_escape_sequence_for_encoding(\n                        encoding, encoded=encoded)\n                encoded = escape_sequence + encoded\n            if encoding in need_tail_escape_sequence_encodings:\n                encoded += _get_escape_sequence_for_encoding(encodings[0])\n            return encoded\n        except UnicodeError:\n            continue\n    else:\n        # if we have more than one encoding, we retry encoding by splitting\n        # `value` into chunks that can be encoded with one of the encodings\n        if len(encodings) > 1:\n            try:\n                return _encode_string_parts(value, encodings)\n            except ValueError:\n                pass\n        # all attempts failed - raise or warn and encode with replacement\n        # characters\n        if config.enforce_valid_values:\n            # force raising a valid UnicodeEncodeError\n            value.encode(encodings[0])\n\n        warnings.warn(\"Failed to encode value with encodings: {} - using \"\n                      \"replacement characters in encoded string\"\n                      .format(', '.join(encodings)))\n        return _encode_string_impl(value, encodings[0], errors='replace')\n", "tokens": ["pydicom", "charset", "py", "def", "encode_string", "value", "encodings", "convert", "a", "unicode", "string", "into", "a", "byte", "string", "using", "the", "given", "list", "of", "encodings", "parameters", "value", "text", "type", "the", "unicode", "string", "as", "presented", "to", "the", "user", "encodings", "list", "the", "encodings", "needed", "to", "encode", "the", "string", "as", "a", "list", "of", "python", "encodings", "converted", "from", "the", "encodings", "in", "specific", "character", "set", "returns", "byte", "string", "the", "encoded", "string", "if", "the", "value", "could", "not", "be", "encoded", "with", "any", "of", "the", "given", "encodings", "and", "config", "enforce_valid_values", "is", "not", "set", "a", "warning", "is", "issued", "and", "the", "value", "is", "encoded", "using", "the", "first", "encoding", "with", "replacement", "characters", "resulting", "in", "data", "loss", "raises", "unicodeencodeerror", "if", "config", "enforce_valid_values", "is", "set", "and", "value", "could", "not", "be", "encoded", "with", "the", "given", "encodings", "for", "i", "encoding", "in", "enumerate", "encodings", "try", "encoded", "_encode_string_impl", "value", "encoding", "if", "i", "0", "and", "encoding", "not", "in", "handled_encodings", "escape_sequence", "_get_escape_sequence_for_encoding", "encoding", "encoded", "encoded", "encoded", "escape_sequence", "encoded", "if", "encoding", "in", "need_tail_escape_sequence_encodings", "encoded", "_get_escape_sequence_for_encoding", "encodings", "0", "return", "encoded", "except", "unicodeerror", "continue", "else", "if", "we", "have", "more", "than", "one", "encoding", "we", "retry", "encoding", "by", "splitting", "value", "into", "chunks", "that", "can", "be", "encoded", "with", "one", "of", "the", "encodings", "if", "len", "encodings", "1", "try", "return", "_encode_string_parts", "value", "encodings", "except", "valueerror", "pass", "all", "attempts", "failed", "raise", "or", "warn", "and", "encode", "with", "replacement", "characters", "if", "config", "enforce_valid_values", "force", "raising", "a", "valid", "unicodeencodeerror", "value", "encode", "encodings", "0", "warnings", "warn", "failed", "to", "encode", "value", "with", "encodings", "using", "replacement", "characters", "in", "encoded", "string", "format", "join", "encodings", "return", "_encode_string_impl", "value", "encodings", "0", "errors", "replace"], "doc_len": 242}
{"doc_id": "pydicom/charset.py::_encode_string_parts", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_encode_string_parts", "text": "文件路径: pydicom/charset.py\ndef _encode_string_parts(value, encodings):\n    \"\"\"Convert a unicode string into a byte string using the given\n    list of encodings.\n    This is invoked if `encode_string` failed to encode `value` with a single\n    encoding. We try instead to use different encodings for different parts\n    of the string, using the encoding that can encode the longest part of\n    the rest of the string as we go along.\n\n    Parameters\n    ----------\n    value : text type\n        The unicode string as presented to the user.\n    encodings : list\n        The encodings needed to encode the string as a list of Python\n        encodings, converted from the encodings in Specific Character Set.\n\n    Returns\n    -------\n    byte string\n        The encoded string, including the escape sequences needed to switch\n        between different encodings.\n\n    Raises\n    ------\n    ValueError\n        If `value` could not be encoded with the given encodings.\n\n    \"\"\"\n    encoded = bytearray()\n    unencoded_part = value\n    best_encoding = None\n    while unencoded_part:\n        # find the encoding that can encode the longest part of the rest\n        # of the string still to be encoded\n        max_index = 0\n        for encoding in encodings:\n            try:\n                _encode_string_impl(unencoded_part, encoding)\n                # if we get here, the whole rest of the value can be encoded\n                best_encoding = encoding\n                max_index = len(unencoded_part)\n                break\n            except UnicodeError as e:\n                if e.start > max_index:\n                    # e.start is the index of first character failed to encode\n                    max_index = e.start\n                    best_encoding = encoding\n        # none of the given encodings can encode the first character - give up\n        if max_index == 0:\n            raise ValueError(\"None of the given encodings can encode the \"\n                             \"first character\")\n\n        # encode the part that can be encoded with the found encoding\n        encoded_part = _encode_string_impl(unencoded_part[:max_index],\n                                           best_encoding)\n        if best_encoding not in handled_encodings:\n            encoded += _get_escape_sequence_for_encoding(\n                    best_encoding, encoded=encoded_part)\n        encoded += encoded_part\n        # set remaining unencoded part of the string and handle that\n        unencoded_part = unencoded_part[max_index:]\n    # unencoded_part is empty - we are done, return the encoded string\n    if best_encoding in need_tail_escape_sequence_encodings:\n        encoded += _get_escape_sequence_for_encoding(encodings[0])\n    return encoded\n", "tokens": ["pydicom", "charset", "py", "def", "_encode_string_parts", "value", "encodings", "convert", "a", "unicode", "string", "into", "a", "byte", "string", "using", "the", "given", "list", "of", "encodings", "this", "is", "invoked", "if", "encode_string", "failed", "to", "encode", "value", "with", "a", "single", "encoding", "we", "try", "instead", "to", "use", "different", "encodings", "for", "different", "parts", "of", "the", "string", "using", "the", "encoding", "that", "can", "encode", "the", "longest", "part", "of", "the", "rest", "of", "the", "string", "as", "we", "go", "along", "parameters", "value", "text", "type", "the", "unicode", "string", "as", "presented", "to", "the", "user", "encodings", "list", "the", "encodings", "needed", "to", "encode", "the", "string", "as", "a", "list", "of", "python", "encodings", "converted", "from", "the", "encodings", "in", "specific", "character", "set", "returns", "byte", "string", "the", "encoded", "string", "including", "the", "escape", "sequences", "needed", "to", "switch", "between", "different", "encodings", "raises", "valueerror", "if", "value", "could", "not", "be", "encoded", "with", "the", "given", "encodings", "encoded", "bytearray", "unencoded_part", "value", "best_encoding", "none", "while", "unencoded_part", "find", "the", "encoding", "that", "can", "encode", "the", "longest", "part", "of", "the", "rest", "of", "the", "string", "still", "to", "be", "encoded", "max_index", "0", "for", "encoding", "in", "encodings", "try", "_encode_string_impl", "unencoded_part", "encoding", "if", "we", "get", "here", "the", "whole", "rest", "of", "the", "value", "can", "be", "encoded", "best_encoding", "encoding", "max_index", "len", "unencoded_part", "break", "except", "unicodeerror", "as", "e", "if", "e", "start", "max_index", "e", "start", "is", "the", "index", "of", "first", "character", "failed", "to", "encode", "max_index", "e", "start", "best_encoding", "encoding", "none", "of", "the", "given", "encodings", "can", "encode", "the", "first", "character", "give", "up", "if", "max_index", "0", "raise", "valueerror", "none", "of", "the", "given", "encodings", "can", "encode", "the", "first", "character", "encode", "the", "part", "that", "can", "be", "encoded", "with", "the", "found", "encoding", "encoded_part", "_encode_string_impl", "unencoded_part", "max_index", "best_encoding", "if", "best_encoding", "not", "in", "handled_encodings", "encoded", "_get_escape_sequence_for_encoding", "best_encoding", "encoded", "encoded_part", "encoded", "encoded_part", "set", "remaining", "unencoded", "part", "of", "the", "string", "and", "handle", "that", "unencoded_part", "unencoded_part", "max_index", "unencoded_part", "is", "empty", "we", "are", "done", "return", "the", "encoded", "string", "if", "best_encoding", "in", "need_tail_escape_sequence_encodings", "encoded", "_get_escape_sequence_for_encoding", "encodings", "0", "return", "encoded"], "doc_len": 297}
{"doc_id": "pydicom/charset.py::_encode_string_impl", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_encode_string_impl", "text": "文件路径: pydicom/charset.py\ndef _encode_string_impl(value, encoding, errors='strict'):\n    \"\"\"Convert a unicode string into a byte string. If given encoding is in\n    custom_encoders, use a corresponding custom_encoder. If given encoding\n    is not in custom_encoders, use a corresponding python handled encoder.\n    \"\"\"\n    if encoding in custom_encoders:\n        return custom_encoders[encoding](value, errors=errors)\n    else:\n        return value.encode(encoding, errors=errors)\n", "tokens": ["pydicom", "charset", "py", "def", "_encode_string_impl", "value", "encoding", "errors", "strict", "convert", "a", "unicode", "string", "into", "a", "byte", "string", "if", "given", "encoding", "is", "in", "custom_encoders", "use", "a", "corresponding", "custom_encoder", "if", "given", "encoding", "is", "not", "in", "custom_encoders", "use", "a", "corresponding", "python", "handled", "encoder", "if", "encoding", "in", "custom_encoders", "return", "custom_encoders", "encoding", "value", "errors", "errors", "else", "return", "value", "encode", "encoding", "errors", "errors"], "doc_len": 57}
{"doc_id": "pydicom/charset.py::convert_encodings", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "convert_encodings", "text": "文件路径: pydicom/charset.py\ndef convert_encodings(encodings):\n    \"\"\"Converts DICOM encodings into corresponding python encodings.\n    Handles some common spelling mistakes and issues a warning in this case.\n    Handles stand-alone encodings: if they are the first encodings,\n    additional encodings are ignored, if they are not the first encoding,\n    they are ignored. In both cases, a warning is issued.\n    Invalid encodings are replaced with the default encoding with a\n    respective warning issued, if `config.enforce_valid_values` is `False`,\n    otherwise an exception is raised.\n\n    Parameters\n    ----------\n    encodings : list of str\n        The list of encodings as read from Specific Character Set.\n\n    Returns\n    -------\n    list of str\n        The list of Python encodings corresponding to the DICOM encodings.\n        If an encoding is already a Python encoding, it is returned unchanged.\n        Encodings with common spelling errors are replaced by the correct\n        encoding, and invalid encodings are replaced with the default\n        encoding if `config.enforce_valid_values` is `False`.\n\n    Raises\n    ------\n    LookupError\n        In case of an invalid encoding that could not be corrected if\n        `config.enforce_valid_values` is set.\n    \"\"\"\n\n    # If a list if passed, we don't want to modify the list in place so copy it\n    encodings = encodings[:]\n\n    if isinstance(encodings, compat.string_types):\n        encodings = [encodings]\n    elif not encodings[0]:\n        encodings[0] = 'ISO_IR 6'\n\n    py_encodings = []\n    for encoding in encodings:\n        try:\n            py_encodings.append(python_encoding[encoding])\n        except KeyError:\n            py_encodings.append(\n                _python_encoding_for_corrected_encoding(encoding))\n\n    if len(encodings) > 1:\n        py_encodings = _handle_illegal_standalone_encodings(encodings,\n                                                            py_encodings)\n    return py_encodings\n", "tokens": ["pydicom", "charset", "py", "def", "convert_encodings", "encodings", "converts", "dicom", "encodings", "into", "corresponding", "python", "encodings", "handles", "some", "common", "spelling", "mistakes", "and", "issues", "a", "warning", "in", "this", "case", "handles", "stand", "alone", "encodings", "if", "they", "are", "the", "first", "encodings", "additional", "encodings", "are", "ignored", "if", "they", "are", "not", "the", "first", "encoding", "they", "are", "ignored", "in", "both", "cases", "a", "warning", "is", "issued", "invalid", "encodings", "are", "replaced", "with", "the", "default", "encoding", "with", "a", "respective", "warning", "issued", "if", "config", "enforce_valid_values", "is", "false", "otherwise", "an", "exception", "is", "raised", "parameters", "encodings", "list", "of", "str", "the", "list", "of", "encodings", "as", "read", "from", "specific", "character", "set", "returns", "list", "of", "str", "the", "list", "of", "python", "encodings", "corresponding", "to", "the", "dicom", "encodings", "if", "an", "encoding", "is", "already", "a", "python", "encoding", "it", "is", "returned", "unchanged", "encodings", "with", "common", "spelling", "errors", "are", "replaced", "by", "the", "correct", "encoding", "and", "invalid", "encodings", "are", "replaced", "with", "the", "default", "encoding", "if", "config", "enforce_valid_values", "is", "false", "raises", "lookuperror", "in", "case", "of", "an", "invalid", "encoding", "that", "could", "not", "be", "corrected", "if", "config", "enforce_valid_values", "is", "set", "if", "a", "list", "if", "passed", "we", "don", "t", "want", "to", "modify", "the", "list", "in", "place", "so", "copy", "it", "encodings", "encodings", "if", "isinstance", "encodings", "compat", "string_types", "encodings", "encodings", "elif", "not", "encodings", "0", "encodings", "0", "iso_ir", "6", "py_encodings", "for", "encoding", "in", "encodings", "try", "py_encodings", "append", "python_encoding", "encoding", "except", "keyerror", "py_encodings", "append", "_python_encoding_for_corrected_encoding", "encoding", "if", "len", "encodings", "1", "py_encodings", "_handle_illegal_standalone_encodings", "encodings", "py_encodings", "return", "py_encodings"], "doc_len": 224}
{"doc_id": "pydicom/charset.py::_python_encoding_for_corrected_encoding", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_python_encoding_for_corrected_encoding", "text": "文件路径: pydicom/charset.py\ndef _python_encoding_for_corrected_encoding(encoding):\n    \"\"\"Try to replace the given invalid encoding with a valid encoding by\n    checking for common spelling errors, and return the correct Python\n    encoding for that encoding. Otherwise check if the\n    encoding is already a valid Python encoding, and return that. If both\n    attempts fail, return the default encoding.\n    Issue a warning for the invalid encoding except for the case where it is\n    already converted.\n    \"\"\"\n    # standard encodings\n    patched = None\n    if re.match('^ISO[^_]IR', encoding) is not None:\n        patched = 'ISO_IR' + encoding[6:]\n    # encodings with code extensions\n    elif re.match('^(?=ISO.2022.IR.)(?!ISO 2022 IR )',\n                  encoding) is not None:\n        patched = 'ISO 2022 IR ' + encoding[12:]\n\n    if patched:\n        # handle encoding patched for common spelling errors\n        try:\n            py_encoding = python_encoding[patched]\n            _warn_about_invalid_encoding(encoding, patched)\n            return py_encoding\n        except KeyError:\n            _warn_about_invalid_encoding(encoding)\n            return default_encoding\n\n    # fallback: assume that it is already a python encoding\n    try:\n        codecs.lookup(encoding)\n        return encoding\n    except LookupError:\n        _warn_about_invalid_encoding(encoding)\n        return default_encoding\n", "tokens": ["pydicom", "charset", "py", "def", "_python_encoding_for_corrected_encoding", "encoding", "try", "to", "replace", "the", "given", "invalid", "encoding", "with", "a", "valid", "encoding", "by", "checking", "for", "common", "spelling", "errors", "and", "return", "the", "correct", "python", "encoding", "for", "that", "encoding", "otherwise", "check", "if", "the", "encoding", "is", "already", "a", "valid", "python", "encoding", "and", "return", "that", "if", "both", "attempts", "fail", "return", "the", "default", "encoding", "issue", "a", "warning", "for", "the", "invalid", "encoding", "except", "for", "the", "case", "where", "it", "is", "already", "converted", "standard", "encodings", "patched", "none", "if", "re", "match", "iso", "_", "ir", "encoding", "is", "not", "none", "patched", "iso_ir", "encoding", "6", "encodings", "with", "code", "extensions", "elif", "re", "match", "iso", "2022", "ir", "iso", "2022", "ir", "encoding", "is", "not", "none", "patched", "iso", "2022", "ir", "encoding", "12", "if", "patched", "handle", "encoding", "patched", "for", "common", "spelling", "errors", "try", "py_encoding", "python_encoding", "patched", "_warn_about_invalid_encoding", "encoding", "patched", "return", "py_encoding", "except", "keyerror", "_warn_about_invalid_encoding", "encoding", "return", "default_encoding", "fallback", "assume", "that", "it", "is", "already", "a", "python", "encoding", "try", "codecs", "lookup", "encoding", "return", "encoding", "except", "lookuperror", "_warn_about_invalid_encoding", "encoding", "return", "default_encoding"], "doc_len": 156}
{"doc_id": "pydicom/charset.py::_warn_about_invalid_encoding", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_warn_about_invalid_encoding", "text": "文件路径: pydicom/charset.py\ndef _warn_about_invalid_encoding(encoding, patched_encoding=None):\n    \"\"\"Issue a warning for the given invalid encoding.\n    If patched_encoding is given, it is mentioned as the\n    replacement encoding, other the default encoding.\n    If no replacement encoding is given, and config.enforce_valid_values\n    is set, LookupError is raised.\n    \"\"\"\n    if patched_encoding is None:\n        if config.enforce_valid_values:\n            raise LookupError(\n                \"Unknown encoding '{}'\".format(encoding))\n        msg = (\"Unknown encoding '{}' - using default encoding \"\n               \"instead\".format(encoding))\n    else:\n        msg = (\"Incorrect value for Specific Character Set \"\n               \"'{}' - assuming '{}'\".format(encoding, patched_encoding))\n    warnings.warn(msg, stacklevel=2)\n", "tokens": ["pydicom", "charset", "py", "def", "_warn_about_invalid_encoding", "encoding", "patched_encoding", "none", "issue", "a", "warning", "for", "the", "given", "invalid", "encoding", "if", "patched_encoding", "is", "given", "it", "is", "mentioned", "as", "the", "replacement", "encoding", "other", "the", "default", "encoding", "if", "no", "replacement", "encoding", "is", "given", "and", "config", "enforce_valid_values", "is", "set", "lookuperror", "is", "raised", "if", "patched_encoding", "is", "none", "if", "config", "enforce_valid_values", "raise", "lookuperror", "unknown", "encoding", "format", "encoding", "msg", "unknown", "encoding", "using", "default", "encoding", "instead", "format", "encoding", "else", "msg", "incorrect", "value", "for", "specific", "character", "set", "assuming", "format", "encoding", "patched_encoding", "warnings", "warn", "msg", "stacklevel", "2"], "doc_len": 84}
{"doc_id": "pydicom/charset.py::_handle_illegal_standalone_encodings", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "_handle_illegal_standalone_encodings", "text": "文件路径: pydicom/charset.py\ndef _handle_illegal_standalone_encodings(encodings, py_encodings):\n    \"\"\"Check for stand-alone encodings in multi-valued encodings.\n    If the first encoding is a stand-alone encoding, the rest of the\n    encodings is removed. If any other encoding is a stand-alone encoding,\n    it is removed from the encodings.\n    \"\"\"\n    if encodings[0] in STAND_ALONE_ENCODINGS:\n        warnings.warn(\"Value '{}' for Specific Character Set does not \"\n                      \"allow code extensions, ignoring: {}\"\n                      .format(encodings[0], ', '.join(encodings[1:])),\n                      stacklevel=2)\n        py_encodings = py_encodings[:1]\n    else:\n        for i, encoding in reversed(list(enumerate(encodings[1:]))):\n            if encoding in STAND_ALONE_ENCODINGS:\n                warnings.warn(\n                    \"Value '{}' cannot be used as code extension, \"\n                    \"ignoring it\".format(encoding),\n                    stacklevel=2)\n                del py_encodings[i + 1]\n    return py_encodings\n", "tokens": ["pydicom", "charset", "py", "def", "_handle_illegal_standalone_encodings", "encodings", "py_encodings", "check", "for", "stand", "alone", "encodings", "in", "multi", "valued", "encodings", "if", "the", "first", "encoding", "is", "a", "stand", "alone", "encoding", "the", "rest", "of", "the", "encodings", "is", "removed", "if", "any", "other", "encoding", "is", "a", "stand", "alone", "encoding", "it", "is", "removed", "from", "the", "encodings", "if", "encodings", "0", "in", "stand_alone_encodings", "warnings", "warn", "value", "for", "specific", "character", "set", "does", "not", "allow", "code", "extensions", "ignoring", "format", "encodings", "0", "join", "encodings", "1", "stacklevel", "2", "py_encodings", "py_encodings", "1", "else", "for", "i", "encoding", "in", "reversed", "list", "enumerate", "encodings", "1", "if", "encoding", "in", "stand_alone_encodings", "warnings", "warn", "value", "cannot", "be", "used", "as", "code", "extension", "ignoring", "it", "format", "encoding", "stacklevel", "2", "del", "py_encodings", "i", "1", "return", "py_encodings"], "doc_len": 111}
{"doc_id": "pydicom/charset.py::decode", "file_path": "pydicom/charset.py", "class_name": null, "func_name": "decode", "text": "文件路径: pydicom/charset.py\ndef decode(data_element, dicom_character_set):\n    \"\"\"Apply the DICOM character encoding to the data element\n\n    data_element -- DataElement instance containing a value to convert\n    dicom_character_set -- the value of Specific Character Set (0008,0005),\n                    which may be a single value,\n                    a multiple value (code extension), or\n                    may also be '' or None.\n                    If blank or None, ISO_IR 6 is used.\n\n    \"\"\"\n    if not dicom_character_set:\n        dicom_character_set = ['ISO_IR 6']\n\n    encodings = convert_encodings(dicom_character_set)\n\n    # decode the string value to unicode\n    # PN is special case as may have 3 components with different chr sets\n    if data_element.VR == \"PN\":\n        if not in_py2:\n            if data_element.VM == 1:\n                data_element.value = data_element.value.decode(encodings)\n            else:\n                data_element.value = [\n                    val.decode(encodings) for val in data_element.value\n                ]\n        else:\n            if data_element.VM == 1:\n                data_element.value = PersonNameUnicode(data_element.value,\n                                                       encodings)\n            else:\n                data_element.value = [\n                    PersonNameUnicode(value, encodings)\n                    for value in data_element.value\n                ]\n    if data_element.VR in text_VRs:\n        # You can't re-decode unicode (string literals in py3)\n        if data_element.VM == 1:\n            if isinstance(data_element.value, compat.text_type):\n                return\n            data_element.value = decode_string(data_element.value, encodings,\n                                               TEXT_VR_DELIMS)\n        else:\n\n            output = list()\n\n            for value in data_element.value:\n                if isinstance(value, compat.text_type):\n                    output.append(value)\n                else:\n                    output.append(decode_string(value, encodings,\n                                                TEXT_VR_DELIMS))\n\n            data_element.value = output\n", "tokens": ["pydicom", "charset", "py", "def", "decode", "data_element", "dicom_character_set", "apply", "the", "dicom", "character", "encoding", "to", "the", "data", "element", "data_element", "dataelement", "instance", "containing", "a", "value", "to", "convert", "dicom_character_set", "the", "value", "of", "specific", "character", "set", "0008", "0005", "which", "may", "be", "a", "single", "value", "a", "multiple", "value", "code", "extension", "or", "may", "also", "be", "or", "none", "if", "blank", "or", "none", "iso_ir", "6", "is", "used", "if", "not", "dicom_character_set", "dicom_character_set", "iso_ir", "6", "encodings", "convert_encodings", "dicom_character_set", "decode", "the", "string", "value", "to", "unicode", "pn", "is", "special", "case", "as", "may", "have", "3", "components", "with", "different", "chr", "sets", "if", "data_element", "vr", "pn", "if", "not", "in_py2", "if", "data_element", "vm", "1", "data_element", "value", "data_element", "value", "decode", "encodings", "else", "data_element", "value", "val", "decode", "encodings", "for", "val", "in", "data_element", "value", "else", "if", "data_element", "vm", "1", "data_element", "value", "personnameunicode", "data_element", "value", "encodings", "else", "data_element", "value", "personnameunicode", "value", "encodings", "for", "value", "in", "data_element", "value", "if", "data_element", "vr", "in", "text_vrs", "you", "can", "t", "re", "decode", "unicode", "string", "literals", "in", "py3", "if", "data_element", "vm", "1", "if", "isinstance", "data_element", "value", "compat", "text_type", "return", "data_element", "value", "decode_string", "data_element", "value", "encodings", "text_vr_delims", "else", "output", "list", "for", "value", "in", "data_element", "value", "if", "isinstance", "value", "compat", "text_type", "output", "append", "value", "else", "output", "append", "decode_string", "value", "encodings", "text_vr_delims", "data_element", "value", "output"], "doc_len": 195}
{"doc_id": "pydicom/config.py::reset_data_element_callback", "file_path": "pydicom/config.py", "class_name": null, "func_name": "reset_data_element_callback", "text": "文件路径: pydicom/config.py\ndef reset_data_element_callback():\n    global data_element_callback\n    global data_element_callback_kwargs\n    data_element_callback = None\n    data_element_callback_kwargs = {}\n", "tokens": ["pydicom", "config", "py", "def", "reset_data_element_callback", "global", "data_element_callback", "global", "data_element_callback_kwargs", "data_element_callback", "none", "data_element_callback_kwargs"], "doc_len": 12}
{"doc_id": "pydicom/config.py::DS_decimal", "file_path": "pydicom/config.py", "class_name": null, "func_name": "DS_decimal", "text": "文件路径: pydicom/config.py\ndef DS_decimal(use_Decimal_boolean=True):\n    \"\"\"Set DS class to be derived from Decimal (True) or from float (False)\n    If this function is never called, the default in pydicom >= 0.9.8\n    is for DS to be based on float.\n    \"\"\"\n    use_DS_decimal = use_Decimal_boolean\n    import pydicom.valuerep\n    if use_DS_decimal:\n        pydicom.valuerep.DSclass = pydicom.valuerep.DSdecimal\n    else:\n        pydicom.valuerep.DSclass = pydicom.valuerep.DSfloat\n", "tokens": ["pydicom", "config", "py", "def", "ds_decimal", "use_decimal_boolean", "true", "set", "ds", "class", "to", "be", "derived", "from", "decimal", "true", "or", "from", "float", "false", "if", "this", "function", "is", "never", "called", "the", "default", "in", "pydicom", "0", "9", "8", "is", "for", "ds", "to", "be", "based", "on", "float", "use_ds_decimal", "use_decimal_boolean", "import", "pydicom", "valuerep", "if", "use_ds_decimal", "pydicom", "valuerep", "dsclass", "pydicom", "valuerep", "dsdecimal", "else", "pydicom", "valuerep", "dsclass", "pydicom", "valuerep", "dsfloat"], "doc_len": 61}
{"doc_id": "pydicom/config.py::debug", "file_path": "pydicom/config.py", "class_name": null, "func_name": "debug", "text": "文件路径: pydicom/config.py\ndef debug(debug_on=True):\n    \"\"\"Turn debugging of DICOM file reading and writing on or off.\n    When debugging is on, file location and details about the\n    elements read at that location are logged to the 'pydicom'\n    logger using python's logging module.\n\n    :param debug_on: True (default) to turn on debugging,\n    False to turn off.\n    \"\"\"\n    global logger, debugging\n    if debug_on:\n        logger.setLevel(logging.DEBUG)\n        debugging = True\n    else:\n        logger.setLevel(logging.WARNING)\n        debugging = False\n", "tokens": ["pydicom", "config", "py", "def", "debug", "debug_on", "true", "turn", "debugging", "of", "dicom", "file", "reading", "and", "writing", "on", "or", "off", "when", "debugging", "is", "on", "file", "location", "and", "details", "about", "the", "elements", "read", "at", "that", "location", "are", "logged", "to", "the", "pydicom", "logger", "using", "python", "s", "logging", "module", "param", "debug_on", "true", "default", "to", "turn", "on", "debugging", "false", "to", "turn", "off", "global", "logger", "debugging", "if", "debug_on", "logger", "setlevel", "logging", "debug", "debugging", "true", "else", "logger", "setlevel", "logging", "warning", "debugging", "false"], "doc_len": 74}
{"doc_id": "pydicom/datadict.py::mask_match", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "mask_match", "text": "文件路径: pydicom/datadict.py\ndef mask_match(tag):\n    for mask_x, (mask1, mask2) in masks.items():\n        if (tag ^ mask1) & mask2 == 0:\n            return mask_x\n    return None\n", "tokens": ["pydicom", "datadict", "py", "def", "mask_match", "tag", "for", "mask_x", "mask1", "mask2", "in", "masks", "items", "if", "tag", "mask1", "mask2", "0", "return", "mask_x", "return", "none"], "doc_len": 22}
{"doc_id": "pydicom/datadict.py::add_dict_entry", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "add_dict_entry", "text": "文件路径: pydicom/datadict.py\ndef add_dict_entry(tag, VR, keyword, description, VM='1', is_retired=''):\n    \"\"\"Update pydicom's DICOM dictionary with a new entry.\n\n    Notes\n    ----\n    Does not permanently update the dictionary,\n    but only during run-time. Will replace an existing\n    entry if the tag already exists in the dictionary.\n\n    Parameters\n    ----------\n    tag : int\n        The tag number for the new dictionary entry\n    VR : str\n        DICOM value representation\n    description : str\n        The descriptive name used in printing the entry.\n        Often the same as the keyword, but with spaces between words.\n    VM : str, optional\n        DICOM value multiplicity. If not specified, then '1' is used.\n    is_retired : str, optional\n        Usually leave as blank string (default).\n        Set to 'Retired' if is a retired data element.\n\n    Raises\n    ------\n    ValueError\n        If the tag is a private tag.\n\n    See Also\n    --------\n    pydicom.examples.add_dict_entry\n        Example file which shows how to use this function\n    add_dict_entries\n        Update multiple values at once.\n\n    Examples\n    --------\n    >>> from pydicom import Dataset\n    >>> add_dict_entry(0x10021001, \"UL\", \"TestOne\", \"Test One\")\n    >>> add_dict_entry(0x10021002, \"DS\", \"TestTwo\", \"Test Two\", VM='3')\n    >>> ds = Dataset()\n    >>> ds.TestOne = 'test'\n    >>> ds.TestTwo = ['1', '2', '3']\n\n    \"\"\"\n    new_dict_val = (VR, VM, description, is_retired, keyword)\n    add_dict_entries({tag: new_dict_val})\n", "tokens": ["pydicom", "datadict", "py", "def", "add_dict_entry", "tag", "vr", "keyword", "description", "vm", "1", "is_retired", "update", "pydicom", "s", "dicom", "dictionary", "with", "a", "new", "entry", "notes", "does", "not", "permanently", "update", "the", "dictionary", "but", "only", "during", "run", "time", "will", "replace", "an", "existing", "entry", "if", "the", "tag", "already", "exists", "in", "the", "dictionary", "parameters", "tag", "int", "the", "tag", "number", "for", "the", "new", "dictionary", "entry", "vr", "str", "dicom", "value", "representation", "description", "str", "the", "descriptive", "name", "used", "in", "printing", "the", "entry", "often", "the", "same", "as", "the", "keyword", "but", "with", "spaces", "between", "words", "vm", "str", "optional", "dicom", "value", "multiplicity", "if", "not", "specified", "then", "1", "is", "used", "is_retired", "str", "optional", "usually", "leave", "as", "blank", "string", "default", "set", "to", "retired", "if", "is", "a", "retired", "data", "element", "raises", "valueerror", "if", "the", "tag", "is", "a", "private", "tag", "see", "also", "pydicom", "examples", "add_dict_entry", "example", "file", "which", "shows", "how", "to", "use", "this", "function", "add_dict_entries", "update", "multiple", "values", "at", "once", "examples", "from", "pydicom", "import", "dataset", "add_dict_entry", "0x10021001", "ul", "testone", "test", "one", "add_dict_entry", "0x10021002", "ds", "testtwo", "test", "two", "vm", "3", "ds", "dataset", "ds", "testone", "test", "ds", "testtwo", "1", "2", "3", "new_dict_val", "vr", "vm", "description", "is_retired", "keyword", "add_dict_entries", "tag", "new_dict_val"], "doc_len": 181}
{"doc_id": "pydicom/datadict.py::add_dict_entries", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "add_dict_entries", "text": "文件路径: pydicom/datadict.py\ndef add_dict_entries(new_entries_dict):\n    \"\"\"Update pydicom's DICOM dictionary with new non-private entries.\n\n    Parameters\n    ----------\n    new_entries_dict : dict\n        Dictionary of form:\n        {tag: (VR, VM, description, is_retired, keyword),...}\n        where parameters are as described in add_dict_entry\n\n    Raises\n    ------\n    ValueError\n        If one of the entries is a private tag.\n\n    See Also\n    --------\n    add_dict_entry\n        Simpler function to add a single entry to the dictionary.\n\n    Examples\n    --------\n    >>> from pydicom import Dataset\n    >>> new_dict_items = {\n    ...        0x10021001: ('UL', '1', \"Test One\", '', 'TestOne'),\n    ...        0x10021002: ('DS', '3', \"Test Two\", '', 'TestTwo'),\n    ... }\n    >>> add_dict_entries(new_dict_items)\n    >>> ds = Dataset()\n    >>> ds.TestOne = 'test'\n    >>> ds.TestTwo = ['1', '2', '3']\n\n    >>> add_dict_entry(0x10021001, \"UL\", \"TestOne\", \"Test One\")\n    >>> ds = Dataset()\n    >>> ds.TestOne = 'test'\n    \"\"\"\n\n    if any([BaseTag(tag).is_private for tag in new_entries_dict]):\n        raise ValueError(\n            'Private tags cannot be added using \"add_dict_entries\" - '\n            'use \"add_private_dict_entries\" instead')\n\n    # Update the dictionary itself\n    DicomDictionary.update(new_entries_dict)\n\n    # Update the reverse mapping from name to tag\n    new_names_dict = dict([(val[4], tag)\n                           for tag, val in new_entries_dict.items()])\n    keyword_dict.update(new_names_dict)\n", "tokens": ["pydicom", "datadict", "py", "def", "add_dict_entries", "new_entries_dict", "update", "pydicom", "s", "dicom", "dictionary", "with", "new", "non", "private", "entries", "parameters", "new_entries_dict", "dict", "dictionary", "of", "form", "tag", "vr", "vm", "description", "is_retired", "keyword", "where", "parameters", "are", "as", "described", "in", "add_dict_entry", "raises", "valueerror", "if", "one", "of", "the", "entries", "is", "a", "private", "tag", "see", "also", "add_dict_entry", "simpler", "function", "to", "add", "a", "single", "entry", "to", "the", "dictionary", "examples", "from", "pydicom", "import", "dataset", "new_dict_items", "0x10021001", "ul", "1", "test", "one", "testone", "0x10021002", "ds", "3", "test", "two", "testtwo", "add_dict_entries", "new_dict_items", "ds", "dataset", "ds", "testone", "test", "ds", "testtwo", "1", "2", "3", "add_dict_entry", "0x10021001", "ul", "testone", "test", "one", "ds", "dataset", "ds", "testone", "test", "if", "any", "basetag", "tag", "is_private", "for", "tag", "in", "new_entries_dict", "raise", "valueerror", "private", "tags", "cannot", "be", "added", "using", "add_dict_entries", "use", "add_private_dict_entries", "instead", "update", "the", "dictionary", "itself", "dicomdictionary", "update", "new_entries_dict", "update", "the", "reverse", "mapping", "from", "name", "to", "tag", "new_names_dict", "dict", "val", "4", "tag", "for", "tag", "val", "in", "new_entries_dict", "items", "keyword_dict", "update", "new_names_dict"], "doc_len": 150}
{"doc_id": "pydicom/datadict.py::add_private_dict_entry", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "add_private_dict_entry", "text": "文件路径: pydicom/datadict.py\ndef add_private_dict_entry(private_creator, tag, VR, description, VM='1'):\n    \"\"\"Update pydicom's private DICOM tag dictionary with a new entry.\n\n    Notes\n    ----\n    Behaves like `add_dict_entry`, only for a private tag entry.\n\n    Parameters\n    ----------\n    private_creator : str\n        The private creator for the new entry.\n    tag : int\n        The tag number for the new dictionary entry. Note that the\n        2 high bytes of the element part of the tag are ignored.\n    VR : str\n        DICOM value representation\n    description : str\n        The descriptive name used in printing the entry.\n    VM : str, optional\n        DICOM value multiplicity. If not specified, then '1' is used.\n\n    Raises\n    ------\n    ValueError\n        If the tag is a non-private tag.\n\n    See Also\n    --------\n    add_private_dict_entries\n        Update multiple values at once.\n    \"\"\"\n    new_dict_val = (VR, VM, description)\n    add_private_dict_entries(private_creator, {tag: new_dict_val})\n", "tokens": ["pydicom", "datadict", "py", "def", "add_private_dict_entry", "private_creator", "tag", "vr", "description", "vm", "1", "update", "pydicom", "s", "private", "dicom", "tag", "dictionary", "with", "a", "new", "entry", "notes", "behaves", "like", "add_dict_entry", "only", "for", "a", "private", "tag", "entry", "parameters", "private_creator", "str", "the", "private", "creator", "for", "the", "new", "entry", "tag", "int", "the", "tag", "number", "for", "the", "new", "dictionary", "entry", "note", "that", "the", "2", "high", "bytes", "of", "the", "element", "part", "of", "the", "tag", "are", "ignored", "vr", "str", "dicom", "value", "representation", "description", "str", "the", "descriptive", "name", "used", "in", "printing", "the", "entry", "vm", "str", "optional", "dicom", "value", "multiplicity", "if", "not", "specified", "then", "1", "is", "used", "raises", "valueerror", "if", "the", "tag", "is", "a", "non", "private", "tag", "see", "also", "add_private_dict_entries", "update", "multiple", "values", "at", "once", "new_dict_val", "vr", "vm", "description", "add_private_dict_entries", "private_creator", "tag", "new_dict_val"], "doc_len": 121}
{"doc_id": "pydicom/datadict.py::add_private_dict_entries", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "add_private_dict_entries", "text": "文件路径: pydicom/datadict.py\ndef add_private_dict_entries(private_creator, new_entries_dict):\n    \"\"\"Update pydicom's private DICOM tag dictionary with new entries.\n\n    Parameters\n    ----------\n    private_creator: str\n        The private creator for all entries in new_entries_dict\n    new_entries_dict : dict\n        Dictionary of form:\n        {tag: (VR, VM, description),...}\n        where parameters are as described in add_private_dict_entry\n\n    Raises\n    ------\n    ValueError\n        If one of the entries is a non-private tag.\n\n    See Also\n    --------\n    add_private_dict_entry\n        Function to add a single entry to the private tag dictionary.\n\n    Examples\n    --------\n    >>> new_dict_items = {\n    ...        0x00410001: ('UL', '1', \"Test One\"),\n    ...        0x00410002: ('DS', '3', \"Test Two\", '3'),\n    ... }\n    >>> add_private_dict_entries(\"ACME LTD 1.2\", new_dict_items)\n    >>> add_private_dict_entry(\"ACME LTD 1.3\", 0x00410001, \"US\", \"Test Three\")\n    \"\"\"\n\n    if not all([BaseTag(tag).is_private for tag in new_entries_dict]):\n        raise ValueError(\n            'Non-private tags cannot be added using \"add_private_dict_entries\"'\n            ' - use \"add_dict_entries\" instead')\n\n    new_entries = {'{:04x}xx{:02x}'.format(tag >> 16, tag & 0xff): value\n                   for tag, value in new_entries_dict.items()}\n    private_dictionaries.setdefault(\n        private_creator, {}).update(new_entries)\n", "tokens": ["pydicom", "datadict", "py", "def", "add_private_dict_entries", "private_creator", "new_entries_dict", "update", "pydicom", "s", "private", "dicom", "tag", "dictionary", "with", "new", "entries", "parameters", "private_creator", "str", "the", "private", "creator", "for", "all", "entries", "in", "new_entries_dict", "new_entries_dict", "dict", "dictionary", "of", "form", "tag", "vr", "vm", "description", "where", "parameters", "are", "as", "described", "in", "add_private_dict_entry", "raises", "valueerror", "if", "one", "of", "the", "entries", "is", "a", "non", "private", "tag", "see", "also", "add_private_dict_entry", "function", "to", "add", "a", "single", "entry", "to", "the", "private", "tag", "dictionary", "examples", "new_dict_items", "0x00410001", "ul", "1", "test", "one", "0x00410002", "ds", "3", "test", "two", "3", "add_private_dict_entries", "acme", "ltd", "1", "2", "new_dict_items", "add_private_dict_entry", "acme", "ltd", "1", "3", "0x00410001", "us", "test", "three", "if", "not", "all", "basetag", "tag", "is_private", "for", "tag", "in", "new_entries_dict", "raise", "valueerror", "non", "private", "tags", "cannot", "be", "added", "using", "add_private_dict_entries", "use", "add_dict_entries", "instead", "new_entries", "04x", "xx", "02x", "format", "tag", "16", "tag", "0xff", "value", "for", "tag", "value", "in", "new_entries_dict", "items", "private_dictionaries", "setdefault", "private_creator", "update", "new_entries"], "doc_len": 142}
{"doc_id": "pydicom/datadict.py::get_entry", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "get_entry", "text": "文件路径: pydicom/datadict.py\ndef get_entry(tag):\n    \"\"\"Return the tuple (VR, VM, name, is_retired, keyword)\n    from the DICOM dictionary\n\n    If the entry is not in the main dictionary,\n    check the masked ones, e.g. repeating groups like 50xx, etc.\n    \"\"\"\n    # Note: tried the lookup with 'if tag in DicomDictionary'\n    # and with DicomDictionary.get, instead of try/except\n    # Try/except was fastest using timeit if tag is valid (usual case)\n    # My test had 5.2 usec vs 8.2 for 'contains' test, vs 5.32 for dict.get\n    if not isinstance(tag, BaseTag):\n        tag = Tag(tag)\n    try:\n        return DicomDictionary[tag]\n    except KeyError:\n        if not tag.is_private:\n            mask_x = mask_match(tag)\n            if mask_x:\n                return RepeatersDictionary[mask_x]\n        raise KeyError(\"Tag {0} not found in DICOM dictionary\".format(tag))\n", "tokens": ["pydicom", "datadict", "py", "def", "get_entry", "tag", "return", "the", "tuple", "vr", "vm", "name", "is_retired", "keyword", "from", "the", "dicom", "dictionary", "if", "the", "entry", "is", "not", "in", "the", "main", "dictionary", "check", "the", "masked", "ones", "e", "g", "repeating", "groups", "like", "50xx", "etc", "note", "tried", "the", "lookup", "with", "if", "tag", "in", "dicomdictionary", "and", "with", "dicomdictionary", "get", "instead", "of", "try", "except", "try", "except", "was", "fastest", "using", "timeit", "if", "tag", "is", "valid", "usual", "case", "my", "test", "had", "5", "2", "usec", "vs", "8", "2", "for", "contains", "test", "vs", "5", "32", "for", "dict", "get", "if", "not", "isinstance", "tag", "basetag", "tag", "tag", "tag", "try", "return", "dicomdictionary", "tag", "except", "keyerror", "if", "not", "tag", "is_private", "mask_x", "mask_match", "tag", "if", "mask_x", "return", "repeatersdictionary", "mask_x", "raise", "keyerror", "tag", "0", "not", "found", "in", "dicom", "dictionary", "format", "tag"], "doc_len": 122}
{"doc_id": "pydicom/datadict.py::dictionary_is_retired", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_is_retired", "text": "文件路径: pydicom/datadict.py\ndef dictionary_is_retired(tag):\n    \"\"\"Return True if the dicom retired status\n       is 'Retired' for the given tag\"\"\"\n    if 'retired' in get_entry(tag)[3].lower():\n        return True\n    return False\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_is_retired", "tag", "return", "true", "if", "the", "dicom", "retired", "status", "is", "retired", "for", "the", "given", "tag", "if", "retired", "in", "get_entry", "tag", "3", "lower", "return", "true", "return", "false"], "doc_len": 30}
{"doc_id": "pydicom/datadict.py::dictionary_VR", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_VR", "text": "文件路径: pydicom/datadict.py\ndef dictionary_VR(tag):\n    \"\"\"Return the dicom value representation\n       for the given dicom tag.\"\"\"\n    return get_entry(tag)[0]\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_vr", "tag", "return", "the", "dicom", "value", "representation", "for", "the", "given", "dicom", "tag", "return", "get_entry", "tag", "0"], "doc_len": 20}
{"doc_id": "pydicom/datadict.py::dictionary_VM", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_VM", "text": "文件路径: pydicom/datadict.py\ndef dictionary_VM(tag):\n    \"\"\"Return the dicom value multiplicity\n       for the given dicom tag.\"\"\"\n    return get_entry(tag)[1]\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_vm", "tag", "return", "the", "dicom", "value", "multiplicity", "for", "the", "given", "dicom", "tag", "return", "get_entry", "tag", "1"], "doc_len": 20}
{"doc_id": "pydicom/datadict.py::dictionary_description", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_description", "text": "文件路径: pydicom/datadict.py\ndef dictionary_description(tag):\n    \"\"\"Return the descriptive text for the given dicom tag.\"\"\"\n    return get_entry(tag)[2]\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_description", "tag", "return", "the", "descriptive", "text", "for", "the", "given", "dicom", "tag", "return", "get_entry", "tag", "2"], "doc_len": 19}
{"doc_id": "pydicom/datadict.py::dictionary_keyword", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_keyword", "text": "文件路径: pydicom/datadict.py\ndef dictionary_keyword(tag):\n    \"\"\"Return the official DICOM standard\n      (since 2011) keyword for the tag\"\"\"\n    return get_entry(tag)[4]\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_keyword", "tag", "return", "the", "official", "dicom", "standard", "since", "2011", "keyword", "for", "the", "tag", "return", "get_entry", "tag", "4"], "doc_len": 21}
{"doc_id": "pydicom/datadict.py::dictionary_has_tag", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "dictionary_has_tag", "text": "文件路径: pydicom/datadict.py\ndef dictionary_has_tag(tag):\n    \"\"\"Return True if the dicom dictionary\n       has an entry for the given tag.\"\"\"\n    return (tag in DicomDictionary)\n", "tokens": ["pydicom", "datadict", "py", "def", "dictionary_has_tag", "tag", "return", "true", "if", "the", "dicom", "dictionary", "has", "an", "entry", "for", "the", "given", "tag", "return", "tag", "in", "dicomdictionary"], "doc_len": 23}
{"doc_id": "pydicom/datadict.py::keyword_for_tag", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "keyword_for_tag", "text": "文件路径: pydicom/datadict.py\ndef keyword_for_tag(tag):\n    \"\"\"Return the DICOM keyword for the given tag.\n\n    Will return GroupLength for group length tags,\n    and returns empty string (\"\") if the tag\n    doesn't exist in the dictionary.\n    \"\"\"\n    try:\n        return dictionary_keyword(tag)\n    except KeyError:\n        return \"\"\n", "tokens": ["pydicom", "datadict", "py", "def", "keyword_for_tag", "tag", "return", "the", "dicom", "keyword", "for", "the", "given", "tag", "will", "return", "grouplength", "for", "group", "length", "tags", "and", "returns", "empty", "string", "if", "the", "tag", "doesn", "t", "exist", "in", "the", "dictionary", "try", "return", "dictionary_keyword", "tag", "except", "keyerror", "return"], "doc_len": 41}
{"doc_id": "pydicom/datadict.py::tag_for_keyword", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "tag_for_keyword", "text": "文件路径: pydicom/datadict.py\ndef tag_for_keyword(keyword):\n    \"\"\"Return the dicom tag corresponding to keyword,\n       or None if none exist.\"\"\"\n    return keyword_dict.get(keyword)\n", "tokens": ["pydicom", "datadict", "py", "def", "tag_for_keyword", "keyword", "return", "the", "dicom", "tag", "corresponding", "to", "keyword", "or", "none", "if", "none", "exist", "return", "keyword_dict", "get", "keyword"], "doc_len": 22}
{"doc_id": "pydicom/datadict.py::tag_for_name", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "tag_for_name", "text": "文件路径: pydicom/datadict.py\ndef tag_for_name(name):\n    \"\"\"Deprecated -- use tag_for_keyword\"\"\"\n    msg = \"tag_for_name is deprecated.  Use tag_for_keyword instead\"\n    warnings.warn(msg, DeprecationWarning)\n\n    return tag_for_keyword(name)\n", "tokens": ["pydicom", "datadict", "py", "def", "tag_for_name", "name", "deprecated", "use", "tag_for_keyword", "msg", "tag_for_name", "is", "deprecated", "use", "tag_for_keyword", "instead", "warnings", "warn", "msg", "deprecationwarning", "return", "tag_for_keyword", "name"], "doc_len": 23}
{"doc_id": "pydicom/datadict.py::repeater_has_tag", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "repeater_has_tag", "text": "文件路径: pydicom/datadict.py\ndef repeater_has_tag(tag):\n    \"\"\"Return True if the DICOM repeaters dictionary\n       has an entry for `tag`.\"\"\"\n    return (mask_match(tag) in RepeatersDictionary)\n", "tokens": ["pydicom", "datadict", "py", "def", "repeater_has_tag", "tag", "return", "true", "if", "the", "dicom", "repeaters", "dictionary", "has", "an", "entry", "for", "tag", "return", "mask_match", "tag", "in", "repeatersdictionary"], "doc_len": 23}
{"doc_id": "pydicom/datadict.py::repeater_has_keyword", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "repeater_has_keyword", "text": "文件路径: pydicom/datadict.py\ndef repeater_has_keyword(keyword):\n    \"\"\"Return True if the DICOM repeaters element\n       exists with `keyword`.\"\"\"\n    return keyword in REPEATER_KEYWORDS\n", "tokens": ["pydicom", "datadict", "py", "def", "repeater_has_keyword", "keyword", "return", "true", "if", "the", "dicom", "repeaters", "element", "exists", "with", "keyword", "return", "keyword", "in", "repeater_keywords"], "doc_len": 20}
{"doc_id": "pydicom/datadict.py::get_private_entry", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "get_private_entry", "text": "文件路径: pydicom/datadict.py\ndef get_private_entry(tag, private_creator):\n    \"\"\"Return the tuple (VR, VM, name, is_retired)\n       from a private dictionary\"\"\"\n    if not isinstance(tag, BaseTag):\n        tag = Tag(tag)\n    try:\n        private_dict = private_dictionaries[private_creator]\n    except KeyError:\n        msg = \"Private creator {0} \".format(private_creator)\n        msg += \"not in private dictionary\"\n        raise KeyError(msg)\n\n    # private elements are usually agnostic for\n    # \"block\" (see PS3.5-2008 7.8.1 p44)\n    # Some elements in _private_dict are explicit;\n    # most have \"xx\" for high-byte of element\n    # Try exact key first, but then try with \"xx\" in block position\n    try:\n        dict_entry = private_dict[tag]\n    except KeyError:\n        #  so here put in the \"xx\" in the block position for key to look up\n        group_str = \"%04x\" % tag.group\n        elem_str = \"%04x\" % tag.elem\n        key = \"%sxx%s\" % (group_str, elem_str[-2:])\n        if key not in private_dict:\n            key = \"%sxxxx%s\" % (group_str[:2], elem_str[-2:])\n            if key not in private_dict:\n                msg = (\"Tag {0} not in private dictionary \"\n                       \"for private creator {1}\".format(key, private_creator))\n                raise KeyError(msg)\n        dict_entry = private_dict[key]\n    return dict_entry\n", "tokens": ["pydicom", "datadict", "py", "def", "get_private_entry", "tag", "private_creator", "return", "the", "tuple", "vr", "vm", "name", "is_retired", "from", "a", "private", "dictionary", "if", "not", "isinstance", "tag", "basetag", "tag", "tag", "tag", "try", "private_dict", "private_dictionaries", "private_creator", "except", "keyerror", "msg", "private", "creator", "0", "format", "private_creator", "msg", "not", "in", "private", "dictionary", "raise", "keyerror", "msg", "private", "elements", "are", "usually", "agnostic", "for", "block", "see", "ps3", "5", "2008", "7", "8", "1", "p44", "some", "elements", "in", "_private_dict", "are", "explicit", "most", "have", "xx", "for", "high", "byte", "of", "element", "try", "exact", "key", "first", "but", "then", "try", "with", "xx", "in", "block", "position", "try", "dict_entry", "private_dict", "tag", "except", "keyerror", "so", "here", "put", "in", "the", "xx", "in", "the", "block", "position", "for", "key", "to", "look", "up", "group_str", "04x", "tag", "group", "elem_str", "04x", "tag", "elem", "key", "sxx", "s", "group_str", "elem_str", "2", "if", "key", "not", "in", "private_dict", "key", "sxxxx", "s", "group_str", "2", "elem_str", "2", "if", "key", "not", "in", "private_dict", "msg", "tag", "0", "not", "in", "private", "dictionary", "for", "private", "creator", "1", "format", "key", "private_creator", "raise", "keyerror", "msg", "dict_entry", "private_dict", "key", "return", "dict_entry"], "doc_len": 161}
{"doc_id": "pydicom/datadict.py::private_dictionary_VR", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "private_dictionary_VR", "text": "文件路径: pydicom/datadict.py\ndef private_dictionary_VR(tag, private_creator):\n    \"\"\"Return the dicom value representation\n       for the given dicom tag.\"\"\"\n    return get_private_entry(tag, private_creator)[0]\n", "tokens": ["pydicom", "datadict", "py", "def", "private_dictionary_vr", "tag", "private_creator", "return", "the", "dicom", "value", "representation", "for", "the", "given", "dicom", "tag", "return", "get_private_entry", "tag", "private_creator", "0"], "doc_len": 22}
{"doc_id": "pydicom/datadict.py::private_dictionary_VM", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "private_dictionary_VM", "text": "文件路径: pydicom/datadict.py\ndef private_dictionary_VM(tag, private_creator):\n    \"\"\"Return the dicom value multiplicity\n       for the given dicom tag.\"\"\"\n    return get_private_entry(tag, private_creator)[1]\n", "tokens": ["pydicom", "datadict", "py", "def", "private_dictionary_vm", "tag", "private_creator", "return", "the", "dicom", "value", "multiplicity", "for", "the", "given", "dicom", "tag", "return", "get_private_entry", "tag", "private_creator", "1"], "doc_len": 22}
{"doc_id": "pydicom/datadict.py::private_dictionary_description", "file_path": "pydicom/datadict.py", "class_name": null, "func_name": "private_dictionary_description", "text": "文件路径: pydicom/datadict.py\ndef private_dictionary_description(tag, private_creator):\n    \"\"\"Return the descriptive text\n       for the given dicom tag.\"\"\"\n    return get_private_entry(tag, private_creator)[2]\n", "tokens": ["pydicom", "datadict", "py", "def", "private_dictionary_description", "tag", "private_creator", "return", "the", "descriptive", "text", "for", "the", "given", "dicom", "tag", "return", "get_private_entry", "tag", "private_creator", "2"], "doc_len": 21}
{"doc_id": "pydicom/dataelem.py::isMultiValue", "file_path": "pydicom/dataelem.py", "class_name": null, "func_name": "isMultiValue", "text": "文件路径: pydicom/dataelem.py\ndef isMultiValue(value):\n    \"\"\"Return True if `value` is list-like (iterable),\n       False otherwise.\"\"\"\n    msg = 'isMultiValue is deprecated.  Use DataElement.VM instead'\n    warnings.warn(msg, DeprecationWarning)\n    if isinstance(value, compat.char_types):\n        return False\n    try:\n        iter(value)\n    except TypeError:\n        return False\n    return True\n", "tokens": ["pydicom", "dataelem", "py", "def", "ismultivalue", "value", "return", "true", "if", "value", "is", "list", "like", "iterable", "false", "otherwise", "msg", "ismultivalue", "is", "deprecated", "use", "dataelement", "vm", "instead", "warnings", "warn", "msg", "deprecationwarning", "if", "isinstance", "value", "compat", "char_types", "return", "false", "try", "iter", "value", "except", "typeerror", "return", "false", "return", "true"], "doc_len": 44}
{"doc_id": "pydicom/dataelem.py::_is_bytes", "file_path": "pydicom/dataelem.py", "class_name": null, "func_name": "_is_bytes", "text": "文件路径: pydicom/dataelem.py\ndef _is_bytes(val):\n    \"\"\"Return True only in Python 3 if `val` is of type `bytes`.\"\"\"\n    return False if in_py2 else isinstance(val, bytes)\n", "tokens": ["pydicom", "dataelem", "py", "def", "_is_bytes", "val", "return", "true", "only", "in", "python", "3", "if", "val", "is", "of", "type", "bytes", "return", "false", "if", "in_py2", "else", "isinstance", "val", "bytes"], "doc_len": 26}
{"doc_id": "pydicom/dataelem.py::DataElement.__init__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__init__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __init__(self,\n                 tag,\n                 VR,\n                 value,\n                 file_value_tell=None,\n                 is_undefined_length=False,\n                 already_converted=False):\n        \"\"\"Create a new DataElement.\n\n        Parameters\n        ----------\n        tag\n            The DICOM (group, element) tag in any form accepted by\n            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,\n            etc.\n        VR : str\n            The 2 character DICOM value representation (see DICOM standard part\n            5, Section 6.2).\n        value\n            The value of the data element. One of the following:\n            * a single string value\n            * a number\n            * a list or tuple with all strings or all numbers\n            * a multi-value string with backslash separator\n        file_value_tell : int or None\n            Used internally by Dataset to store the write position for the\n            ReplaceDataElementValue() method. Default is None.\n        is_undefined_length : bool\n            Used internally to store whether the length field for this element\n            was 0xFFFFFFFFL, i.e. 'undefined length'. Default is False.\n        already_converted : bool\n            Used to determine whether or not `value` requires conversion to a\n            value with VM > 1. Default is False.\n        \"\"\"\n        if not isinstance(tag, BaseTag):\n            tag = Tag(tag)\n        self.tag = tag\n        self.VR = VR  # Note!: you must set VR before setting value\n        if already_converted:\n            self._value = value\n        else:\n            self.value = value  # calls property setter which will convert\n        self.file_tell = file_value_tell\n        self.is_undefined_length = is_undefined_length\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__init__", "self", "tag", "vr", "value", "file_value_tell", "none", "is_undefined_length", "false", "already_converted", "false", "create", "a", "new", "dataelement", "parameters", "tag", "the", "dicom", "group", "element", "tag", "in", "any", "form", "accepted", "by", "pydicom", "tag", "tag", "such", "as", "0x0010", "0x0010", "0x10", "0x10", "0x00100010", "etc", "vr", "str", "the", "2", "character", "dicom", "value", "representation", "see", "dicom", "standard", "part", "5", "section", "6", "2", "value", "the", "value", "of", "the", "data", "element", "one", "of", "the", "following", "a", "single", "string", "value", "a", "number", "a", "list", "or", "tuple", "with", "all", "strings", "or", "all", "numbers", "a", "multi", "value", "string", "with", "backslash", "separator", "file_value_tell", "int", "or", "none", "used", "internally", "by", "dataset", "to", "store", "the", "write", "position", "for", "the", "replacedataelementvalue", "method", "default", "is", "none", "is_undefined_length", "bool", "used", "internally", "to", "store", "whether", "the", "length", "field", "for", "this", "element", "was", "0xffffffffl", "i", "e", "undefined", "length", "default", "is", "false", "already_converted", "bool", "used", "to", "determine", "whether", "or", "not", "value", "requires", "conversion", "to", "a", "value", "with", "vm", "1", "default", "is", "false", "if", "not", "isinstance", "tag", "basetag", "tag", "tag", "tag", "self", "tag", "tag", "self", "vr", "vr", "note", "you", "must", "set", "vr", "before", "setting", "value", "if", "already_converted", "self", "_value", "value", "else", "self", "value", "value", "calls", "property", "setter", "which", "will", "convert", "self", "file_tell", "file_value_tell", "self", "is_undefined_length", "is_undefined_length"], "doc_len": 198}
{"doc_id": "pydicom/dataelem.py::DataElement.from_json", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "from_json", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def from_json(cls, dataset_class, tag, vr, value, value_key,\n                                bulk_data_uri_handler=None,\n                                encodings=None):\n        \"\"\"Creates a DataElement from JSON.\n\n        Parameters\n        ----------\n        tag: pydicom.tag.Tag\n            data element tag\n        vr: str\n            data element value representation\n        value: list\n            data element value(s)\n        value_key: Union[str, None]\n            key of the data element that contains the value\n            (options: ``{\"Value\", \"InlineBinary\", \"BulkDataURI\"}``)\n        bulk_data_uri_handler: Union[Callable, None]\n            callable that accepts the \"BulkDataURI\" of the JSON representation\n            of a data element and returns the actual value of that data element\n            (retrieved via DICOMweb WADO-RS)\n\n        Returns\n        -------\n        pydicom.dataelem.DataElement\n\n        \"\"\"\n        # TODO: test wado-rs retrieve wrapper\n        try:\n            vm = dictionary_VM(tag)\n        except KeyError:\n            # Private tag\n            vm = str(len(value))\n        if value_key == 'Value':\n            if not(isinstance(value, list)):\n                fmt = '\"{}\" of data element \"{}\" must be a list.'\n                raise TypeError(fmt.format(value_key, tag))\n        elif value_key in {'InlineBinary', 'BulkDataURI'}:\n            if isinstance(value, list):\n                fmt = '\"{}\" of data element \"{}\" must be a {}.'\n                expected_type = ('string' if value_key == 'BulkDataURI'\n                                 else 'bytes-like object')\n                raise TypeError(fmt.format(value_key, tag, expected_type))\n        if vr == 'SQ':\n            elem_value = []\n            for value_item in value:\n                ds = dataset_class()\n                if value_item:\n                    for key, val in value_item.items():\n                        if 'vr' not in val:\n                            fmt = 'Data element \"{}\" must have key \"vr\".'\n                            raise KeyError(fmt.format(tag))\n                        unique_value_keys = tuple(\n                            set(val.keys()) & set(jsonrep.JSON_VALUE_KEYS)\n                        )\n                        if len(unique_value_keys) == 0:\n                            logger.debug(\n                                'data element has neither key \"{}\".'.format(\n                                    '\" nor \"'.join(jsonrep.JSON_VALUE_KEYS)\n                                )\n                            )\n                            elem = DataElement(tag=tag, value='', VR=vr)\n                        else:\n                            value_key = unique_value_keys[0]\n                            elem = cls.from_json(\n                                dataset_class, key, val['vr'],\n                                val[value_key], value_key\n                            )\n                        ds.add(elem)\n                elem_value.append(ds)\n        elif vr == 'PN':\n            # Special case, see DICOM Part 18 Annex F2.2\n            elem_value = []\n            for v in value:\n                if not isinstance(v, dict):\n                    # Some DICOMweb services get this wrong, so we\n                    # workaround the issue and warn the user\n                    # rather than raising an error.\n                    logger.error(\n                        'value of data element \"{}\" with VR Person Name (PN) '\n                        'is not formatted correctly'.format(tag)\n                    )\n                    elem_value.append(v)\n                else:\n                    elem_value.extend(list(v.values()))\n            if vm == '1':\n                try:\n                    elem_value = elem_value[0]\n                except IndexError:\n                    elem_value = ''\n        else:\n            if vm == '1':\n                if value_key == 'InlineBinary':\n                    elem_value = base64.b64decode(value)\n                elif value_key == 'BulkDataURI':\n                    if bulk_data_uri_handler is None:\n                        logger.warning(\n                            'no bulk data URI handler provided for retrieval '\n                            'of value of data element \"{}\"'.format(tag)\n                        )\n                        elem_value = b''\n                    else:\n                        elem_value = bulk_data_uri_handler(value)\n                else:\n                    if value:\n                        elem_value = value[0]\n                    else:\n                        elem_value = value\n            else:\n                elem_value = value\n        if elem_value is None:\n            logger.warning('missing value for data element \"{}\"'.format(tag))\n            elem_value = ''\n\n        elem_value = jsonrep._convert_to_python_number(elem_value, vr)\n\n        try:\n            if compat.in_py2 and vr == \"PN\":\n\n                elem_value = PersonNameUnicode(elem_value, 'UTF8')\n            return DataElement(tag=tag, value=elem_value, VR=vr)\n        except Exception:\n            raise\n            raise ValueError(\n                'Data element \"{}\" could not be loaded from JSON: {}'.format(\n                    tag, elem_value\n                    )\n            )\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "from_json", "cls", "dataset_class", "tag", "vr", "value", "value_key", "bulk_data_uri_handler", "none", "encodings", "none", "creates", "a", "dataelement", "from", "json", "parameters", "tag", "pydicom", "tag", "tag", "data", "element", "tag", "vr", "str", "data", "element", "value", "representation", "value", "list", "data", "element", "value", "s", "value_key", "union", "str", "none", "key", "of", "the", "data", "element", "that", "contains", "the", "value", "options", "value", "inlinebinary", "bulkdatauri", "bulk_data_uri_handler", "union", "callable", "none", "callable", "that", "accepts", "the", "bulkdatauri", "of", "the", "json", "representation", "of", "a", "data", "element", "and", "returns", "the", "actual", "value", "of", "that", "data", "element", "retrieved", "via", "dicomweb", "wado", "rs", "returns", "pydicom", "dataelem", "dataelement", "todo", "test", "wado", "rs", "retrieve", "wrapper", "try", "vm", "dictionary_vm", "tag", "except", "keyerror", "private", "tag", "vm", "str", "len", "value", "if", "value_key", "value", "if", "not", "isinstance", "value", "list", "fmt", "of", "data", "element", "must", "be", "a", "list", "raise", "typeerror", "fmt", "format", "value_key", "tag", "elif", "value_key", "in", "inlinebinary", "bulkdatauri", "if", "isinstance", "value", "list", "fmt", "of", "data", "element", "must", "be", "a", "expected_type", "string", "if", "value_key", "bulkdatauri", "else", "bytes", "like", "object", "raise", "typeerror", "fmt", "format", "value_key", "tag", "expected_type", "if", "vr", "sq", "elem_value", "for", "value_item", "in", "value", "ds", "dataset_class", "if", "value_item", "for", "key", "val", "in", "value_item", "items", "if", "vr", "not", "in", "val", "fmt", "data", "element", "must", "have", "key", "vr", "raise", "keyerror", "fmt", "format", "tag", "unique_value_keys", "tuple", "set", "val", "keys", "set", "jsonrep", "json_value_keys", "if", "len", "unique_value_keys", "0", "logger", "debug", "data", "element", "has", "neither", "key", "format", "nor", "join", "jsonrep", "json_value_keys", "elem", "dataelement", "tag", "tag", "value", "vr", "vr", "else", "value_key", "unique_value_keys", "0", "elem", "cls", "from_json", "dataset_class", "key", "val", "vr", "val", "value_key", "value_key", "ds", "add", "elem", "elem_value", "append", "ds", "elif", "vr", "pn", "special", "case", "see", "dicom", "part", "18", "annex", "f2", "2", "elem_value", "for", "v", "in", "value", "if", "not", "isinstance", "v", "dict", "some", "dicomweb", "services", "get", "this", "wrong", "so", "we", "workaround", "the", "issue", "and", "warn", "the", "user", "rather", "than", "raising", "an", "error", "logger", "error", "value", "of", "data", "element", "with", "vr", "person", "name", "pn", "is", "not", "formatted", "correctly", "format", "tag", "elem_value", "append", "v", "else", "elem_value", "extend", "list", "v", "values", "if", "vm", "1", "try", "elem_value", "elem_value", "0", "except", "indexerror", "elem_value", "else", "if", "vm", "1", "if", "value_key", "inlinebinary", "elem_value", "base64", "b64decode", "value", "elif", "value_key", "bulkdatauri", "if", "bulk_data_uri_handler", "is", "none", "logger", "warning", "no", "bulk", "data", "uri", "handler", "provided", "for", "retrieval", "of", "value", "of", "data", "element", "format", "tag", "elem_value", "b", "else", "elem_value", "bulk_data_uri_handler", "value", "else", "if", "value", "elem_value", "value", "0", "else", "elem_value", "value", "else", "elem_value", "value", "if", "elem_value", "is", "none", "logger", "warning", "missing", "value", "for", "data", "element", "format", "tag", "elem_value", "elem_value", "jsonrep", "_convert_to_python_number", "elem_value", "vr", "try", "if", "compat", "in_py2", "and", "vr", "pn", "elem_value", "personnameunicode", "elem_value", "utf8", "return", "dataelement", "tag", "tag", "value", "elem_value", "vr", "vr", "except", "exception", "raise", "raise", "valueerror", "data", "element", "could", "not", "be", "loaded", "from", "json", "format", "tag", "elem_value"], "doc_len": 436}
{"doc_id": "pydicom/dataelem.py::DataElement.value", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "value", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def value(self):\n        \"\"\"Return the element's `value`.\"\"\"\n        return self._value\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "value", "self", "return", "the", "element", "s", "value", "return", "self", "_value"], "doc_len": 15}
{"doc_id": "pydicom/dataelem.py::DataElement.value", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "value", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def value(self, val):\n        \"\"\"Convert (if necessary) and set the `value` of the element.\"\"\"\n        # Check if is a string with multiple values separated by '\\'\n        # If so, turn them into a list of separate strings\n        #  Last condition covers 'US or SS' etc\n        if isinstance(val, compat.char_types) and self.VR not in \\\n                ['UT', 'ST', 'LT', 'FL', 'FD', 'AT', 'OB', 'OW', 'OF', 'SL',\n                 'SQ', 'SS', 'UL', 'OB/OW', 'OW/OB', 'OB or OW',\n                 'OW or OB', 'UN'] and 'US' not in self.VR:\n            try:\n                if _backslash_str in val:\n                    val = val.split(_backslash_str)\n            except TypeError:\n                if _backslash_byte in val:\n                    val = val.split(_backslash_byte)\n        self._value = self._convert_value(val)\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "value", "self", "val", "convert", "if", "necessary", "and", "set", "the", "value", "of", "the", "element", "check", "if", "is", "a", "string", "with", "multiple", "values", "separated", "by", "if", "so", "turn", "them", "into", "a", "list", "of", "separate", "strings", "last", "condition", "covers", "us", "or", "ss", "etc", "if", "isinstance", "val", "compat", "char_types", "and", "self", "vr", "not", "in", "ut", "st", "lt", "fl", "fd", "at", "ob", "ow", "of", "sl", "sq", "ss", "ul", "ob", "ow", "ow", "ob", "ob", "or", "ow", "ow", "or", "ob", "un", "and", "us", "not", "in", "self", "vr", "try", "if", "_backslash_str", "in", "val", "val", "val", "split", "_backslash_str", "except", "typeerror", "if", "_backslash_byte", "in", "val", "val", "val", "split", "_backslash_byte", "self", "_value", "self", "_convert_value", "val"], "doc_len": 109}
{"doc_id": "pydicom/dataelem.py::DataElement.VM", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "VM", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def VM(self):\n        \"\"\"Return the value multiplicity (as an int) of the element.\"\"\"\n        if isinstance(self.value, compat.char_types):\n            return 1\n        try:\n            iter(self.value)\n        except TypeError:\n            return 1\n        return len(self.value)\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "vm", "self", "return", "the", "value", "multiplicity", "as", "an", "int", "of", "the", "element", "if", "isinstance", "self", "value", "compat", "char_types", "return", "1", "try", "iter", "self", "value", "except", "typeerror", "return", "1", "return", "len", "self", "value"], "doc_len": 37}
{"doc_id": "pydicom/dataelem.py::DataElement._convert_value", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "_convert_value", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def _convert_value(self, val):\n        \"\"\"Convert `val` to an appropriate type and return the result.\n\n        Uses the element's VR in order to determine the conversion method and\n        resulting type.\n        \"\"\"\n        if self.VR == 'SQ':  # a sequence - leave it alone\n            from pydicom.sequence import Sequence\n            if isinstance(val, Sequence):\n                return val\n            else:\n                return Sequence(val)\n\n        # if the value is a list, convert each element\n        try:\n            val.append\n        except AttributeError:  # not a list\n            return self._convert(val)\n        else:\n            return MultiValue(lambda x: self._convert(x), val)\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "_convert_value", "self", "val", "convert", "val", "to", "an", "appropriate", "type", "and", "return", "the", "result", "uses", "the", "element", "s", "vr", "in", "order", "to", "determine", "the", "conversion", "method", "and", "resulting", "type", "if", "self", "vr", "sq", "a", "sequence", "leave", "it", "alone", "from", "pydicom", "sequence", "import", "sequence", "if", "isinstance", "val", "sequence", "return", "val", "else", "return", "sequence", "val", "if", "the", "value", "is", "a", "list", "convert", "each", "element", "try", "val", "append", "except", "attributeerror", "not", "a", "list", "return", "self", "_convert", "val", "else", "return", "multivalue", "lambda", "x", "self", "_convert", "x", "val"], "doc_len": 87}
{"doc_id": "pydicom/dataelem.py::DataElement._convert", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "_convert", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def _convert(self, val):\n        \"\"\"Convert `val` to an appropriate type for the element's VR.\"\"\"\n\n        # If the value is a byte string and has a VR that can only be encoded\n        # using the default character repertoire, we convert it to a string\n        # here to allow for byte string input in these cases\n        if _is_bytes(val) and self.VR in (\n                'AE', 'AS', 'CS', 'DA', 'DS', 'DT', 'IS', 'TM', 'UI', 'UR'):\n            val = val.decode()\n\n        if self.VR == 'IS':\n            return pydicom.valuerep.IS(val)\n        elif self.VR == 'DA' and config.datetime_conversion:\n            return pydicom.valuerep.DA(val)\n        elif self.VR == 'DS':\n            return pydicom.valuerep.DS(val)\n        elif self.VR == 'DT' and config.datetime_conversion:\n            return pydicom.valuerep.DT(val)\n        elif self.VR == 'TM' and config.datetime_conversion:\n            return pydicom.valuerep.TM(val)\n        elif self.VR == \"UI\":\n            return UID(val if val else '')\n        elif not in_py2 and self.VR == \"PN\":\n            return PersonName(val)\n        # Later may need this for PersonName as for UI,\n        #    but needs more thought\n        # elif self.VR == \"PN\":\n        #    return PersonName(val)\n        else:  # is either a string or a type 2 optionally blank string\n            return val  # this means a \"numeric\" value could be empty string \"\"\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "_convert", "self", "val", "convert", "val", "to", "an", "appropriate", "type", "for", "the", "element", "s", "vr", "if", "the", "value", "is", "a", "byte", "string", "and", "has", "a", "vr", "that", "can", "only", "be", "encoded", "using", "the", "default", "character", "repertoire", "we", "convert", "it", "to", "a", "string", "here", "to", "allow", "for", "byte", "string", "input", "in", "these", "cases", "if", "_is_bytes", "val", "and", "self", "vr", "in", "ae", "as", "cs", "da", "ds", "dt", "is", "tm", "ui", "ur", "val", "val", "decode", "if", "self", "vr", "is", "return", "pydicom", "valuerep", "is", "val", "elif", "self", "vr", "da", "and", "config", "datetime_conversion", "return", "pydicom", "valuerep", "da", "val", "elif", "self", "vr", "ds", "return", "pydicom", "valuerep", "ds", "val", "elif", "self", "vr", "dt", "and", "config", "datetime_conversion", "return", "pydicom", "valuerep", "dt", "val", "elif", "self", "vr", "tm", "and", "config", "datetime_conversion", "return", "pydicom", "valuerep", "tm", "val", "elif", "self", "vr", "ui", "return", "uid", "val", "if", "val", "else", "elif", "not", "in_py2", "and", "self", "vr", "pn", "return", "personname", "val", "later", "may", "need", "this", "for", "personname", "as", "for", "ui", "but", "needs", "more", "thought", "elif", "self", "vr", "pn", "return", "personname", "val", "else", "is", "either", "a", "string", "or", "a", "type", "2", "optionally", "blank", "string", "return", "val", "this", "means", "a", "numeric", "value", "could", "be", "empty", "string"], "doc_len": 193}
{"doc_id": "pydicom/dataelem.py::DataElement.__eq__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__eq__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __eq__(self, other):\n        \"\"\"Compare `self` and `other` for equality.\n\n        Returns\n        -------\n        bool\n            The result if `self` and `other` are the same class\n        NotImplemented\n            If `other` is not the same class as `self` then returning\n            NotImplemented delegates the result to superclass.__eq__(subclass)\n        \"\"\"\n        # Faster result if same object\n        if other is self:\n            return True\n\n        if isinstance(other, self.__class__):\n            if self.tag == other.tag and self.VR == other.VR \\\n                    and self.value == other.value:\n                return True\n\n        return NotImplemented\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__eq__", "self", "other", "compare", "self", "and", "other", "for", "equality", "returns", "bool", "the", "result", "if", "self", "and", "other", "are", "the", "same", "class", "notimplemented", "if", "other", "is", "not", "the", "same", "class", "as", "self", "then", "returning", "notimplemented", "delegates", "the", "result", "to", "superclass", "__eq__", "subclass", "faster", "result", "if", "same", "object", "if", "other", "is", "self", "return", "true", "if", "isinstance", "other", "self", "__class__", "if", "self", "tag", "other", "tag", "and", "self", "vr", "other", "vr", "and", "self", "value", "other", "value", "return", "true", "return", "notimplemented"], "doc_len": 81}
{"doc_id": "pydicom/dataelem.py::DataElement.__ne__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__ne__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __ne__(self, other):\n        \"\"\"Compare `self` and `other` for inequality.\"\"\"\n        return not (self == other)\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__ne__", "self", "other", "compare", "self", "and", "other", "for", "inequality", "return", "not", "self", "other"], "doc_len": 18}
{"doc_id": "pydicom/dataelem.py::DataElement.__str__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__str__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __str__(self):\n        \"\"\"Return str representation of the element.\"\"\"\n        repVal = self.repval\n        if self.showVR:\n            s = \"%s %-*s %s: %s\" % (str(self.tag), self.descripWidth,\n                                    self.description()[:self.descripWidth],\n                                    self.VR, repVal)\n        else:\n            s = \"%s %-*s %s\" % (str(self.tag), self.descripWidth,\n                                self.description()[:self.descripWidth], repVal)\n        return s\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__str__", "self", "return", "str", "representation", "of", "the", "element", "repval", "self", "repval", "if", "self", "showvr", "s", "s", "s", "s", "s", "str", "self", "tag", "self", "descripwidth", "self", "description", "self", "descripwidth", "self", "vr", "repval", "else", "s", "s", "s", "s", "str", "self", "tag", "self", "descripwidth", "self", "description", "self", "descripwidth", "repval", "return", "s"], "doc_len": 53}
{"doc_id": "pydicom/dataelem.py::DataElement.repval", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "repval", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def repval(self):\n        \"\"\"Return a str representation of the element's `value`.\"\"\"\n        long_VRs = {\"OB\", \"OD\", \"OF\", \"OW\", \"UN\", \"UT\"}\n        if set(self.VR.split(\" or \")) & long_VRs:\n            try:\n                length = len(self.value)\n            except TypeError:\n                pass\n            else:\n                if length > self.maxBytesToDisplay:\n                    return \"Array of %d elements\" % length\n        if self.VM > self.maxBytesToDisplay:\n            repVal = \"Array of %d elements\" % self.VM\n        elif isinstance(self.value, UID):\n            repVal = self.value.name\n        else:\n            repVal = repr(self.value)  # will tolerate unicode too\n        return repVal\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "repval", "self", "return", "a", "str", "representation", "of", "the", "element", "s", "value", "long_vrs", "ob", "od", "of", "ow", "un", "ut", "if", "set", "self", "vr", "split", "or", "long_vrs", "try", "length", "len", "self", "value", "except", "typeerror", "pass", "else", "if", "length", "self", "maxbytestodisplay", "return", "array", "of", "d", "elements", "length", "if", "self", "vm", "self", "maxbytestodisplay", "repval", "array", "of", "d", "elements", "self", "vm", "elif", "isinstance", "self", "value", "uid", "repval", "self", "value", "name", "else", "repval", "repr", "self", "value", "will", "tolerate", "unicode", "too", "return", "repval"], "doc_len": 81}
{"doc_id": "pydicom/dataelem.py::DataElement.__unicode__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__unicode__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __unicode__(self):\n        \"\"\"Return unicode representation of the element.\"\"\"\n        if isinstance(self.value, compat.text_type):\n            # start with the string rep then replace the value part\n            #   with the unicode\n            strVal = str(self)\n            strVal = strVal.replace(self.repval, \"\")\n            uniVal = compat.text_type(strVal) + self.value\n            return uniVal\n        else:\n            return compat.text_type(str(self))\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__unicode__", "self", "return", "unicode", "representation", "of", "the", "element", "if", "isinstance", "self", "value", "compat", "text_type", "start", "with", "the", "string", "rep", "then", "replace", "the", "value", "part", "with", "the", "unicode", "strval", "str", "self", "strval", "strval", "replace", "self", "repval", "unival", "compat", "text_type", "strval", "self", "value", "return", "unival", "else", "return", "compat", "text_type", "str", "self"], "doc_len": 54}
{"doc_id": "pydicom/dataelem.py::DataElement.__getitem__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__getitem__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __getitem__(self, key):\n        \"\"\"Return the value at `key` if the element's\n           `value` is indexable.\"\"\"\n        try:\n            return self.value[key]\n        except TypeError:\n            raise TypeError(\"DataElement value is unscriptable \"\n                            \"(not a Sequence)\")\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__getitem__", "self", "key", "return", "the", "value", "at", "key", "if", "the", "element", "s", "value", "is", "indexable", "try", "return", "self", "value", "key", "except", "typeerror", "raise", "typeerror", "dataelement", "value", "is", "unscriptable", "not", "a", "sequence"], "doc_len": 36}
{"doc_id": "pydicom/dataelem.py::DataElement.name", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "name", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def name(self):\n        \"\"\"Return the DICOM dictionary name for the element.\"\"\"\n        return self.description()\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "name", "self", "return", "the", "dicom", "dictionary", "name", "for", "the", "element", "return", "self", "description"], "doc_len": 18}
{"doc_id": "pydicom/dataelem.py::DataElement.description", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "description", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def description(self):\n        \"\"\"Return the DICOM dictionary name for the element.\"\"\"\n        if self.tag.is_private:\n            name = \"Private tag data\"  # default\n            if hasattr(self, 'private_creator'):\n                try:\n                    # If have name from private dictionary, use it, but\n                    #   but put in square brackets so is differentiated,\n                    #   and clear that cannot access it by name\n                    name = private_dictionary_description(\n                        self.tag, self.private_creator)\n                    name = \"[%s]\" % (name)\n                except KeyError:\n                    pass\n            elif self.tag.elem >> 8 == 0:\n                name = \"Private Creator\"\n        elif dictionary_has_tag(self.tag) or repeater_has_tag(self.tag):\n            name = dictionary_description(self.tag)\n\n        # implied Group Length dicom versions < 3\n        elif self.tag.element == 0:\n            name = \"Group Length\"\n        else:\n            name = \"\"\n        return name\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "description", "self", "return", "the", "dicom", "dictionary", "name", "for", "the", "element", "if", "self", "tag", "is_private", "name", "private", "tag", "data", "default", "if", "hasattr", "self", "private_creator", "try", "if", "have", "name", "from", "private", "dictionary", "use", "it", "but", "but", "put", "in", "square", "brackets", "so", "is", "differentiated", "and", "clear", "that", "cannot", "access", "it", "by", "name", "name", "private_dictionary_description", "self", "tag", "self", "private_creator", "name", "s", "name", "except", "keyerror", "pass", "elif", "self", "tag", "elem", "8", "0", "name", "private", "creator", "elif", "dictionary_has_tag", "self", "tag", "or", "repeater_has_tag", "self", "tag", "name", "dictionary_description", "self", "tag", "implied", "group", "length", "dicom", "versions", "3", "elif", "self", "tag", "element", "0", "name", "group", "length", "else", "name", "return", "name"], "doc_len": 105}
{"doc_id": "pydicom/dataelem.py::DataElement.is_retired", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "is_retired", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def is_retired(self):\n        \"\"\"The element's retired status.\"\"\"\n        if dictionary_has_tag(self.tag):\n            return dictionary_is_retired(self.tag)\n        else:\n            return False\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "is_retired", "self", "the", "element", "s", "retired", "status", "if", "dictionary_has_tag", "self", "tag", "return", "dictionary_is_retired", "self", "tag", "else", "return", "false"], "doc_len": 23}
{"doc_id": "pydicom/dataelem.py::DataElement.keyword", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "keyword", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def keyword(self):\n        \"\"\"The element's keyword (if known).\"\"\"\n        if dictionary_has_tag(self.tag):\n            return dictionary_keyword(self.tag)\n        else:\n            return ''\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "keyword", "self", "the", "element", "s", "keyword", "if", "known", "if", "dictionary_has_tag", "self", "tag", "return", "dictionary_keyword", "self", "tag", "else", "return"], "doc_len": 23}
{"doc_id": "pydicom/dataelem.py::DataElement.__repr__", "file_path": "pydicom/dataelem.py", "class_name": "DataElement", "func_name": "__repr__", "text": "文件路径: pydicom/dataelem.py, 类名: DataElement\n    def __repr__(self):\n        \"\"\"Return the representation of the element.\"\"\"\n        if self.VR == \"SQ\":\n            return repr(self.value)\n        else:\n            return str(self)\n", "tokens": ["pydicom", "dataelem", "py", "dataelement", "def", "__repr__", "self", "return", "the", "representation", "of", "the", "element", "if", "self", "vr", "sq", "return", "repr", "self", "value", "else", "return", "str", "self"], "doc_len": 25}
{"doc_id": "pydicom/dataelem.py::DataElement_from_raw", "file_path": "pydicom/dataelem.py", "class_name": null, "func_name": "DataElement_from_raw", "text": "文件路径: pydicom/dataelem.py\ndef DataElement_from_raw(raw_data_element, encoding=None):\n    \"\"\"Return a DataElement created from the data in `raw_data_element`.\n\n    Parameters\n    ----------\n    raw_data_element : RawDataElement namedtuple\n        The raw data to convert to a DataElement\n    encoding : str\n        The encoding of the raw data\n\n    Returns\n    -------\n    pydicom.dataelem.DataElement\n    \"\"\"\n    # XXX buried here to avoid circular import\n    # filereader->Dataset->convert_value->filereader\n    # (for SQ parsing)\n\n    if in_py2:\n        encoding = encoding or default_encoding\n    from pydicom.values import convert_value\n    raw = raw_data_element\n\n    # If user has hooked into conversion of raw values, call his/her routine\n    if config.data_element_callback:\n        data_elem = config.data_element_callback\n        raw = data_elem(raw_data_element,\n                        **config.data_element_callback_kwargs)\n    VR = raw.VR\n    if VR is None:  # Can be if was implicit VR\n        try:\n            VR = dictionary_VR(raw.tag)\n        except KeyError:\n            # just read the bytes, no way to know what they mean\n            if raw.tag.is_private:\n                # for VR for private tags see PS3.5, 6.2.2\n                if raw.tag.is_private_creator:\n                    VR = 'LO'\n                else:\n                    VR = 'UN'\n\n            # group length tag implied in versions < 3.0\n            elif raw.tag.element == 0:\n                VR = 'UL'\n            else:\n                msg = \"Unknown DICOM tag {0:s}\".format(str(raw.tag))\n                msg += \" can't look up VR\"\n                raise KeyError(msg)\n    try:\n        value = convert_value(VR, raw, encoding)\n    except NotImplementedError as e:\n        raise NotImplementedError(\"{0:s} in tag {1!r}\".format(str(e), raw.tag))\n    return DataElement(raw.tag, VR, value, raw.value_tell,\n                       raw.length == 0xFFFFFFFF, already_converted=True)\n", "tokens": ["pydicom", "dataelem", "py", "def", "dataelement_from_raw", "raw_data_element", "encoding", "none", "return", "a", "dataelement", "created", "from", "the", "data", "in", "raw_data_element", "parameters", "raw_data_element", "rawdataelement", "namedtuple", "the", "raw", "data", "to", "convert", "to", "a", "dataelement", "encoding", "str", "the", "encoding", "of", "the", "raw", "data", "returns", "pydicom", "dataelem", "dataelement", "xxx", "buried", "here", "to", "avoid", "circular", "import", "filereader", "dataset", "convert_value", "filereader", "for", "sq", "parsing", "if", "in_py2", "encoding", "encoding", "or", "default_encoding", "from", "pydicom", "values", "import", "convert_value", "raw", "raw_data_element", "if", "user", "has", "hooked", "into", "conversion", "of", "raw", "values", "call", "his", "her", "routine", "if", "config", "data_element_callback", "data_elem", "config", "data_element_callback", "raw", "data_elem", "raw_data_element", "config", "data_element_callback_kwargs", "vr", "raw", "vr", "if", "vr", "is", "none", "can", "be", "if", "was", "implicit", "vr", "try", "vr", "dictionary_vr", "raw", "tag", "except", "keyerror", "just", "read", "the", "bytes", "no", "way", "to", "know", "what", "they", "mean", "if", "raw", "tag", "is_private", "for", "vr", "for", "private", "tags", "see", "ps3", "5", "6", "2", "2", "if", "raw", "tag", "is_private_creator", "vr", "lo", "else", "vr", "un", "group", "length", "tag", "implied", "in", "versions", "3", "0", "elif", "raw", "tag", "element", "0", "vr", "ul", "else", "msg", "unknown", "dicom", "tag", "0", "s", "format", "str", "raw", "tag", "msg", "can", "t", "look", "up", "vr", "raise", "keyerror", "msg", "try", "value", "convert_value", "vr", "raw", "encoding", "except", "notimplementederror", "as", "e", "raise", "notimplementederror", "0", "s", "in", "tag", "1", "r", "format", "str", "e", "raw", "tag", "return", "dataelement", "raw", "tag", "vr", "value", "raw", "value_tell", "raw", "length", "0xffffffff", "already_converted", "true"], "doc_len": 218}
{"doc_id": "pydicom/dataset.py::PrivateBlock.__init__", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "__init__", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def __init__(self, key, dataset, private_creator_element):\n        \"\"\"Initializes an object corresponding to a private tag block.\n\n        Parameters\n        ----------\n        key : tuple (int, str)\n            The private group and private creator. The group must be an odd\n            number.\n        dataset : Dataset\n            The parent dataset.\n        private_creator_element : 32 bit int\n            The element of the private creator tag.\n        \"\"\"\n        self.group = key[0]\n        self.private_creator = key[1]\n        self.dataset = dataset\n        self.block_start = private_creator_element << 8\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "__init__", "self", "key", "dataset", "private_creator_element", "initializes", "an", "object", "corresponding", "to", "a", "private", "tag", "block", "parameters", "key", "tuple", "int", "str", "the", "private", "group", "and", "private", "creator", "the", "group", "must", "be", "an", "odd", "number", "dataset", "dataset", "the", "parent", "dataset", "private_creator_element", "32", "bit", "int", "the", "element", "of", "the", "private", "creator", "tag", "self", "group", "key", "0", "self", "private_creator", "key", "1", "self", "dataset", "dataset", "self", "block_start", "private_creator_element", "8"], "doc_len": 68}
{"doc_id": "pydicom/dataset.py::PrivateBlock.get_tag", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "get_tag", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def get_tag(self, element_offset):\n        \"\"\"Return the private tag ID for the given element offset.\n\n        Parameters\n        ----------\n        element_offset : 16 bit int\n            The lower 16 bit (e.g. 2 hex numbers) of the element tag.\n\n        Returns\n        -------\n            The tag ID defined by the private block location and the\n            given element offset.\n\n        Raises\n        ------\n        ValueError\n            If `element_offset` is too large.\n        \"\"\"\n        if element_offset > 0xff:\n            raise ValueError('Element offset must be less than 256')\n        return Tag(self.group, self.block_start + element_offset)\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "get_tag", "self", "element_offset", "return", "the", "private", "tag", "id", "for", "the", "given", "element", "offset", "parameters", "element_offset", "16", "bit", "int", "the", "lower", "16", "bit", "e", "g", "2", "hex", "numbers", "of", "the", "element", "tag", "returns", "the", "tag", "id", "defined", "by", "the", "private", "block", "location", "and", "the", "given", "element", "offset", "raises", "valueerror", "if", "element_offset", "is", "too", "large", "if", "element_offset", "0xff", "raise", "valueerror", "element", "offset", "must", "be", "less", "than", "256", "return", "tag", "self", "group", "self", "block_start", "element_offset"], "doc_len": 77}
{"doc_id": "pydicom/dataset.py::PrivateBlock.__contains__", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "__contains__", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def __contains__(self, element_offset):\n        \"\"\"Return True if the tag with given element offset is contained in\n        the parent dataset.\"\"\"\n        return self.get_tag(element_offset) in self.dataset\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "__contains__", "self", "element_offset", "return", "true", "if", "the", "tag", "with", "given", "element", "offset", "is", "contained", "in", "the", "parent", "dataset", "return", "self", "get_tag", "element_offset", "in", "self", "dataset"], "doc_len": 30}
{"doc_id": "pydicom/dataset.py::PrivateBlock.__getitem__", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "__getitem__", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def __getitem__(self, element_offset):\n        \"\"\"Return the data element in the parent dataset for the given element\n        offset.\n\n        Parameters\n        ----------\n        element_offset : 16 bit int\n            The lower 16 bit (e.g. 2 hex numbers) of the element tag.\n\n        Returns\n        -------\n            The data element of the tag in the parent dataset defined by the\n            private block location and the given element offset.\n\n        Raises\n        ------\n        ValueError\n            If `element_offset` is too large.\n        KeyError\n            If no data element exists at that offset.\n        \"\"\"\n        return self.dataset.__getitem__(self.get_tag(element_offset))\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "__getitem__", "self", "element_offset", "return", "the", "data", "element", "in", "the", "parent", "dataset", "for", "the", "given", "element", "offset", "parameters", "element_offset", "16", "bit", "int", "the", "lower", "16", "bit", "e", "g", "2", "hex", "numbers", "of", "the", "element", "tag", "returns", "the", "data", "element", "of", "the", "tag", "in", "the", "parent", "dataset", "defined", "by", "the", "private", "block", "location", "and", "the", "given", "element", "offset", "raises", "valueerror", "if", "element_offset", "is", "too", "large", "keyerror", "if", "no", "data", "element", "exists", "at", "that", "offset", "return", "self", "dataset", "__getitem__", "self", "get_tag", "element_offset"], "doc_len": 84}
{"doc_id": "pydicom/dataset.py::PrivateBlock.__delitem__", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "__delitem__", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def __delitem__(self, element_offset):\n        \"\"\"Delete the tag with the given element offset from the dataset.\n\n        Parameters\n        ----------\n        element_offset : 16 bit int\n            The lower 16 bit (e.g. 2 hex numbers) of the element tag\n            to be deleted.\n\n        Raises\n        ------\n        ValueError\n            If `element_offset` is too large.\n        KeyError\n            If no data element exists at that offset.\n        \"\"\"\n        del self.dataset[self.get_tag(element_offset)]\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "__delitem__", "self", "element_offset", "delete", "the", "tag", "with", "the", "given", "element", "offset", "from", "the", "dataset", "parameters", "element_offset", "16", "bit", "int", "the", "lower", "16", "bit", "e", "g", "2", "hex", "numbers", "of", "the", "element", "tag", "to", "be", "deleted", "raises", "valueerror", "if", "element_offset", "is", "too", "large", "keyerror", "if", "no", "data", "element", "exists", "at", "that", "offset", "del", "self", "dataset", "self", "get_tag", "element_offset"], "doc_len": 62}
{"doc_id": "pydicom/dataset.py::PrivateBlock.add_new", "file_path": "pydicom/dataset.py", "class_name": "PrivateBlock", "func_name": "add_new", "text": "文件路径: pydicom/dataset.py, 类名: PrivateBlock\n    def add_new(self, element_offset, VR, value):\n        \"\"\"Adds the private tag with the given VR and value to the\n         parent dataset at the tag ID defined by the private block\n         and the given element offset.\n\n        Parameters\n        ----------\n        element_offset : 16 bit int\n            The lower 16 bit (e.g. 2 hex numbers) of the element tag\n            to be added.\n        VR : str\n            The 2 character DICOM value representation.\n        value\n            The value of the data element.\n            See `pydicom.Dataset.add_new` for a description.\n        \"\"\"\n        self.dataset.add_new(self.get_tag(element_offset), VR, value)\n", "tokens": ["pydicom", "dataset", "py", "privateblock", "def", "add_new", "self", "element_offset", "vr", "value", "adds", "the", "private", "tag", "with", "the", "given", "vr", "and", "value", "to", "the", "parent", "dataset", "at", "the", "tag", "id", "defined", "by", "the", "private", "block", "and", "the", "given", "element", "offset", "parameters", "element_offset", "16", "bit", "int", "the", "lower", "16", "bit", "e", "g", "2", "hex", "numbers", "of", "the", "element", "tag", "to", "be", "added", "vr", "str", "the", "2", "character", "dicom", "value", "representation", "value", "the", "value", "of", "the", "data", "element", "see", "pydicom", "dataset", "add_new", "for", "a", "description", "self", "dataset", "add_new", "self", "get_tag", "element_offset", "vr", "value"], "doc_len": 89}
{"doc_id": "pydicom/dataset.py::_dict_equal", "file_path": "pydicom/dataset.py", "class_name": null, "func_name": "_dict_equal", "text": "文件路径: pydicom/dataset.py\ndef _dict_equal(a, b, exclude=None):\n    \"\"\"Common method for Dataset.__eq__ and FileDataset.__eq__\n\n    Uses .keys() as needed because Dataset iter return items not keys\n    `exclude` is used in FileDataset__eq__ ds.__dict__ compare, which\n    would also compare the wrapped _dict member (entire dataset) again.\n    \"\"\"\n    return (len(a) == len(b) and\n            all(key in b for key in a.keys()) and\n            all(a[key] == b[key] for key in a.keys()\n                if exclude is None or key not in exclude)\n            )\n", "tokens": ["pydicom", "dataset", "py", "def", "_dict_equal", "a", "b", "exclude", "none", "common", "method", "for", "dataset", "__eq__", "and", "filedataset", "__eq__", "uses", "keys", "as", "needed", "because", "dataset", "iter", "return", "items", "not", "keys", "exclude", "is", "used", "in", "filedataset__eq__", "ds", "__dict__", "compare", "which", "would", "also", "compare", "the", "wrapped", "_dict", "member", "entire", "dataset", "again", "return", "len", "a", "len", "b", "and", "all", "key", "in", "b", "for", "key", "in", "a", "keys", "and", "all", "a", "key", "b", "key", "for", "key", "in", "a", "keys", "if", "exclude", "is", "none", "or", "key", "not", "in", "exclude"], "doc_len": 82}
{"doc_id": "pydicom/dataset.py::Dataset.__init__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__init__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __init__(self, *args, **kwargs):\n        \"\"\"Create a new Dataset instance.\"\"\"\n        self._parent_encoding = kwargs.get('parent_encoding', default_encoding)\n        if not args:\n            self._dict = {}\n        elif isinstance(args[0], Dataset):\n            self._dict = args[0]._dict\n        else:\n            self._dict = args[0]\n        self.is_decompressed = False\n\n        # the following read_XXX attributes are used internally to store\n        # the properties of the dataset after read from a file\n\n        # set depending on the endianess of the read dataset\n        self.read_little_endian = None\n        # set depending on the VR handling of the read dataset\n        self.read_implicit_vr = None\n        # set to the encoding the dataset had originally\n        self.read_encoding = None\n\n        self.is_little_endian = None\n        self.is_implicit_VR = None\n\n        # the parent data set, if this dataset is a sequence item\n        self.parent = None\n\n        # known private creator blocks\n        self._private_blocks = {}\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__init__", "self", "args", "kwargs", "create", "a", "new", "dataset", "instance", "self", "_parent_encoding", "kwargs", "get", "parent_encoding", "default_encoding", "if", "not", "args", "self", "_dict", "elif", "isinstance", "args", "0", "dataset", "self", "_dict", "args", "0", "_dict", "else", "self", "_dict", "args", "0", "self", "is_decompressed", "false", "the", "following", "read_xxx", "attributes", "are", "used", "internally", "to", "store", "the", "properties", "of", "the", "dataset", "after", "read", "from", "a", "file", "set", "depending", "on", "the", "endianess", "of", "the", "read", "dataset", "self", "read_little_endian", "none", "set", "depending", "on", "the", "vr", "handling", "of", "the", "read", "dataset", "self", "read_implicit_vr", "none", "set", "to", "the", "encoding", "the", "dataset", "had", "originally", "self", "read_encoding", "none", "self", "is_little_endian", "none", "self", "is_implicit_vr", "none", "the", "parent", "data", "set", "if", "this", "dataset", "is", "a", "sequence", "item", "self", "parent", "none", "known", "private", "creator", "blocks", "self", "_private_blocks"], "doc_len": 124}
{"doc_id": "pydicom/dataset.py::Dataset.__enter__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__enter__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __enter__(self):\n        \"\"\"Method invoked on entry to a with statement.\"\"\"\n        return self\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__enter__", "self", "method", "invoked", "on", "entry", "to", "a", "with", "statement", "return", "self"], "doc_len": 17}
{"doc_id": "pydicom/dataset.py::Dataset.__exit__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__exit__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Method invoked on exit from a with statement.\"\"\"\n        # Returning False will re-raise any exceptions that occur\n        return False\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__exit__", "self", "exc_type", "exc_val", "exc_tb", "method", "invoked", "on", "exit", "from", "a", "with", "statement", "returning", "false", "will", "re", "raise", "any", "exceptions", "that", "occur", "return", "false"], "doc_len": 29}
{"doc_id": "pydicom/dataset.py::Dataset.add", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "add", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def add(self, data_element):\n        \"\"\"Add a DataElement to the Dataset.\n\n        Equivalent to ds[data_element.tag] = data_element\n\n        Parameters\n        ----------\n        data_element : pydicom.dataelem.DataElement\n            The DataElement to add to the Dataset.\n        \"\"\"\n        self[data_element.tag] = data_element\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "add", "self", "data_element", "add", "a", "dataelement", "to", "the", "dataset", "equivalent", "to", "ds", "data_element", "tag", "data_element", "parameters", "data_element", "pydicom", "dataelem", "dataelement", "the", "dataelement", "to", "add", "to", "the", "dataset", "self", "data_element", "tag", "data_element"], "doc_len": 36}
{"doc_id": "pydicom/dataset.py::Dataset.add_new", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "add_new", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def add_new(self, tag, VR, value):\n        \"\"\"Add a DataElement to the Dataset.\n\n        Parameters\n        ----------\n        tag\n            The DICOM (group, element) tag in any form accepted by\n            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,\n            etc.\n        VR : str\n            The 2 character DICOM value representation (see DICOM standard part\n            5, Section 6.2).\n        value\n            The value of the data element. One of the following:\n            * a single string or number\n            * a list or tuple with all strings or all numbers\n            * a multi-value string with backslash separator\n            * for a sequence DataElement, an empty list or list of Dataset\n        \"\"\"\n\n        data_element = DataElement(tag, VR, value)\n        # use data_element.tag since DataElement verified it\n        self._dict[data_element.tag] = data_element\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "add_new", "self", "tag", "vr", "value", "add", "a", "dataelement", "to", "the", "dataset", "parameters", "tag", "the", "dicom", "group", "element", "tag", "in", "any", "form", "accepted", "by", "pydicom", "tag", "tag", "such", "as", "0x0010", "0x0010", "0x10", "0x10", "0x00100010", "etc", "vr", "str", "the", "2", "character", "dicom", "value", "representation", "see", "dicom", "standard", "part", "5", "section", "6", "2", "value", "the", "value", "of", "the", "data", "element", "one", "of", "the", "following", "a", "single", "string", "or", "number", "a", "list", "or", "tuple", "with", "all", "strings", "or", "all", "numbers", "a", "multi", "value", "string", "with", "backslash", "separator", "for", "a", "sequence", "dataelement", "an", "empty", "list", "or", "list", "of", "dataset", "data_element", "dataelement", "tag", "vr", "value", "use", "data_element", "tag", "since", "dataelement", "verified", "it", "self", "_dict", "data_element", "tag", "data_element"], "doc_len": 116}
{"doc_id": "pydicom/dataset.py::Dataset.data_element", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "data_element", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def data_element(self, name):\n        \"\"\"Return the DataElement corresponding to the element keyword `name`.\n\n        Parameters\n        ----------\n        name : str\n            A DICOM element keyword.\n\n        Returns\n        -------\n        pydicom.dataelem.DataElement or None\n            For the given DICOM element `keyword`, return the corresponding\n            Dataset DataElement if present, None otherwise.\n        \"\"\"\n        tag = tag_for_keyword(name)\n        # Test against None as (0000,0000) is a possible tag\n        if tag is not None:\n            return self[tag]\n        return None\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "data_element", "self", "name", "return", "the", "dataelement", "corresponding", "to", "the", "element", "keyword", "name", "parameters", "name", "str", "a", "dicom", "element", "keyword", "returns", "pydicom", "dataelem", "dataelement", "or", "none", "for", "the", "given", "dicom", "element", "keyword", "return", "the", "corresponding", "dataset", "dataelement", "if", "present", "none", "otherwise", "tag", "tag_for_keyword", "name", "test", "against", "none", "as", "0000", "0000", "is", "a", "possible", "tag", "if", "tag", "is", "not", "none", "return", "self", "tag", "return", "none"], "doc_len": 68}
{"doc_id": "pydicom/dataset.py::Dataset.__contains__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__contains__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __contains__(self, name):\n        \"\"\"Simulate dict.__contains__() to handle DICOM keywords.\n\n        This is called for code like:\n        >>> ds = Dataset()\n        >>> ds.SliceLocation = '2'\n        >>> 'SliceLocation' in ds\n        True\n\n        Parameters\n        ----------\n        name : str or int or 2-tuple\n            The Element keyword or tag to search for.\n\n        Returns\n        -------\n        bool\n            True if the DataElement is in the Dataset, False otherwise.\n        \"\"\"\n        try:\n            tag = Tag(name)\n        except (ValueError, OverflowError):\n            return False\n        # Test against None as (0000,0000) is a possible tag\n        if tag is not None:\n            return tag in self._dict\n        return name in self._dict  # will no doubt raise an exception\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__contains__", "self", "name", "simulate", "dict", "__contains__", "to", "handle", "dicom", "keywords", "this", "is", "called", "for", "code", "like", "ds", "dataset", "ds", "slicelocation", "2", "slicelocation", "in", "ds", "true", "parameters", "name", "str", "or", "int", "or", "2", "tuple", "the", "element", "keyword", "or", "tag", "to", "search", "for", "returns", "bool", "true", "if", "the", "dataelement", "is", "in", "the", "dataset", "false", "otherwise", "try", "tag", "tag", "name", "except", "valueerror", "overflowerror", "return", "false", "test", "against", "none", "as", "0000", "0000", "is", "a", "possible", "tag", "if", "tag", "is", "not", "none", "return", "tag", "in", "self", "_dict", "return", "name", "in", "self", "_dict", "will", "no", "doubt", "raise", "an", "exception"], "doc_len": 98}
{"doc_id": "pydicom/dataset.py::Dataset.decode", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "decode", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def decode(self):\n        \"\"\"Apply character set decoding to all DataElements in the Dataset.\n\n        See DICOM PS3.5-2008 6.1.1.\n        \"\"\"\n        # Find specific character set. 'ISO_IR 6' is default\n        # May be multi-valued, but let pydicom.charset handle all logic on that\n        dicom_character_set = self._character_set\n\n        # Shortcut to the decode function in pydicom.charset\n        decode_data_element = pydicom.charset.decode\n\n        # Callback for walk(), to decode the chr strings if necessary\n        # This simply calls the pydicom.charset.decode function\n        def decode_callback(ds, data_element):\n            \"\"\"Callback to decode `data_element`.\"\"\"\n            if data_element.VR == 'SQ':\n                for dset in data_element.value:\n                    dset._parent_encoding = dicom_character_set\n                    dset.decode()\n            else:\n                decode_data_element(data_element, dicom_character_set)\n\n        self.walk(decode_callback, recursive=False)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "decode", "self", "apply", "character", "set", "decoding", "to", "all", "dataelements", "in", "the", "dataset", "see", "dicom", "ps3", "5", "2008", "6", "1", "1", "find", "specific", "character", "set", "iso_ir", "6", "is", "default", "may", "be", "multi", "valued", "but", "let", "pydicom", "charset", "handle", "all", "logic", "on", "that", "dicom_character_set", "self", "_character_set", "shortcut", "to", "the", "decode", "function", "in", "pydicom", "charset", "decode_data_element", "pydicom", "charset", "decode", "callback", "for", "walk", "to", "decode", "the", "chr", "strings", "if", "necessary", "this", "simply", "calls", "the", "pydicom", "charset", "decode", "function", "def", "decode_callback", "ds", "data_element", "callback", "to", "decode", "data_element", "if", "data_element", "vr", "sq", "for", "dset", "in", "data_element", "value", "dset", "_parent_encoding", "dicom_character_set", "dset", "decode", "else", "decode_data_element", "data_element", "dicom_character_set", "self", "walk", "decode_callback", "recursive", "false"], "doc_len": 110}
{"doc_id": "pydicom/dataset.py::Dataset.__delattr__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__delattr__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __delattr__(self, name):\n        \"\"\"Intercept requests to delete an attribute by `name`.\n\n        >>> ds = Dataset()\n        >>> ds.PatientName = 'foo'\n        >>> ds.some_attribute = True\n\n        If `name` is a DICOM keyword - delete the corresponding DataElement\n        >>> del ds.PatientName\n        >>> 'PatientName' in ds\n        False\n\n        If `name` is another attribute - delete it\n        >>> del ds.some_attribute\n        >>> hasattr(ds, 'some_attribute')\n        False\n\n        Parameters\n        ----------\n        name : str\n            The keyword for the DICOM element or the class attribute to delete.\n        \"\"\"\n        # First check if a valid DICOM keyword and if we have that data element\n        tag = tag_for_keyword(name)\n        if tag is not None and tag in self._dict:\n            del self._dict[tag]\n        # If not a DICOM name in this dataset, check for regular instance name\n        #   can't do delete directly, that will call __delattr__ again\n        elif name in self.__dict__:\n            del self.__dict__[name]\n        # Not found, raise an error in same style as python does\n        else:\n            raise AttributeError(name)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__delattr__", "self", "name", "intercept", "requests", "to", "delete", "an", "attribute", "by", "name", "ds", "dataset", "ds", "patientname", "foo", "ds", "some_attribute", "true", "if", "name", "is", "a", "dicom", "keyword", "delete", "the", "corresponding", "dataelement", "del", "ds", "patientname", "patientname", "in", "ds", "false", "if", "name", "is", "another", "attribute", "delete", "it", "del", "ds", "some_attribute", "hasattr", "ds", "some_attribute", "false", "parameters", "name", "str", "the", "keyword", "for", "the", "dicom", "element", "or", "the", "class", "attribute", "to", "delete", "first", "check", "if", "a", "valid", "dicom", "keyword", "and", "if", "we", "have", "that", "data", "element", "tag", "tag_for_keyword", "name", "if", "tag", "is", "not", "none", "and", "tag", "in", "self", "_dict", "del", "self", "_dict", "tag", "if", "not", "a", "dicom", "name", "in", "this", "dataset", "check", "for", "regular", "instance", "name", "can", "t", "do", "delete", "directly", "that", "will", "call", "__delattr__", "again", "elif", "name", "in", "self", "__dict__", "del", "self", "__dict__", "name", "not", "found", "raise", "an", "error", "in", "same", "style", "as", "python", "does", "else", "raise", "attributeerror", "name"], "doc_len": 148}
{"doc_id": "pydicom/dataset.py::Dataset.__delitem__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__delitem__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __delitem__(self, key):\n        \"\"\"Intercept requests to delete an attribute by key.\n\n        Examples\n        --------\n        Indexing using DataElement tag\n        >>> ds = Dataset()\n        >>> ds.CommandGroupLength = 100\n        >>> ds.PatientName = 'CITIZEN^Jan'\n        >>> del ds[0x00000000]\n        >>> ds\n        (0010, 0010) Patient's Name                      PN: 'CITIZEN^Jan'\n\n        Slicing using DataElement tag\n        >>> ds = Dataset()\n        >>> ds.CommandGroupLength = 100\n        >>> ds.SOPInstanceUID = '1.2.3'\n        >>> ds.PatientName = 'CITIZEN^Jan'\n        >>> del ds[:0x00100000]\n        >>> ds\n        (0010, 0010) Patient's Name                      PN: 'CITIZEN^Jan'\n\n        Parameters\n        ----------\n        key\n            The key for the attribute to be deleted. If a slice is used then\n            the tags matching the slice conditions will be deleted.\n        \"\"\"\n        # If passed a slice, delete the corresponding DataElements\n        if isinstance(key, slice):\n            for tag in self._slice_dataset(key.start, key.stop, key.step):\n                del self._dict[tag]\n        else:\n            # Assume is a standard tag (for speed in common case)\n            try:\n                del self._dict[key]\n            # If not a standard tag, than convert to Tag and try again\n            except KeyError:\n                tag = Tag(key)\n                del self._dict[tag]\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__delitem__", "self", "key", "intercept", "requests", "to", "delete", "an", "attribute", "by", "key", "examples", "indexing", "using", "dataelement", "tag", "ds", "dataset", "ds", "commandgrouplength", "100", "ds", "patientname", "citizen", "jan", "del", "ds", "0x00000000", "ds", "0010", "0010", "patient", "s", "name", "pn", "citizen", "jan", "slicing", "using", "dataelement", "tag", "ds", "dataset", "ds", "commandgrouplength", "100", "ds", "sopinstanceuid", "1", "2", "3", "ds", "patientname", "citizen", "jan", "del", "ds", "0x00100000", "ds", "0010", "0010", "patient", "s", "name", "pn", "citizen", "jan", "parameters", "key", "the", "key", "for", "the", "attribute", "to", "be", "deleted", "if", "a", "slice", "is", "used", "then", "the", "tags", "matching", "the", "slice", "conditions", "will", "be", "deleted", "if", "passed", "a", "slice", "delete", "the", "corresponding", "dataelements", "if", "isinstance", "key", "slice", "for", "tag", "in", "self", "_slice_dataset", "key", "start", "key", "stop", "key", "step", "del", "self", "_dict", "tag", "else", "assume", "is", "a", "standard", "tag", "for", "speed", "in", "common", "case", "try", "del", "self", "_dict", "key", "if", "not", "a", "standard", "tag", "than", "convert", "to", "tag", "and", "try", "again", "except", "keyerror", "tag", "tag", "key", "del", "self", "_dict", "tag"], "doc_len": 161}
{"doc_id": "pydicom/dataset.py::Dataset.__dir__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__dir__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __dir__(self):\n        \"\"\"Give a list of attributes available in the Dataset.\n\n        List of attributes is used, for example, in auto-completion in editors\n        or command-line environments.\n        \"\"\"\n        # Force zip object into a list in case of python3. Also backwards\n        # compatible\n        meths = set(list(zip(\n            *inspect.getmembers(self.__class__, inspect.isroutine)))[0])\n        props = set(list(zip(\n            *inspect.getmembers(self.__class__, inspect.isdatadescriptor)))[0])\n        dicom_names = set(self.dir())\n        alldir = sorted(props | meths | dicom_names)\n        return alldir\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__dir__", "self", "give", "a", "list", "of", "attributes", "available", "in", "the", "dataset", "list", "of", "attributes", "is", "used", "for", "example", "in", "auto", "completion", "in", "editors", "or", "command", "line", "environments", "force", "zip", "object", "into", "a", "list", "in", "case", "of", "python3", "also", "backwards", "compatible", "meths", "set", "list", "zip", "inspect", "getmembers", "self", "__class__", "inspect", "isroutine", "0", "props", "set", "list", "zip", "inspect", "getmembers", "self", "__class__", "inspect", "isdatadescriptor", "0", "dicom_names", "set", "self", "dir", "alldir", "sorted", "props", "meths", "dicom_names", "return", "alldir"], "doc_len": 78}
{"doc_id": "pydicom/dataset.py::Dataset.dir", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "dir", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def dir(self, *filters):\n        \"\"\"Return an alphabetical list of DataElement keywords in the Dataset.\n\n        Intended mainly for use in interactive Python sessions. Only lists the\n        DataElement keywords in the current level of the Dataset (i.e. the\n        contents of any Sequence elements are ignored).\n\n        Parameters\n        ----------\n        filters : str\n            Zero or more string arguments to the function. Used for\n            case-insensitive match to any part of the DICOM keyword.\n\n        Returns\n        -------\n        list of str\n            The matching DataElement keywords in the dataset. If no filters are\n            used then all DataElement keywords are returned.\n        \"\"\"\n        allnames = [keyword_for_tag(tag) for tag in self._dict.keys()]\n        # remove blanks - tags without valid names (e.g. private tags)\n        allnames = [x for x in allnames if x]\n        # Store found names in a dict, so duplicate names appear only once\n        matches = {}\n        for filter_ in filters:\n            filter_ = filter_.lower()\n            match = [x for x in allnames if x.lower().find(filter_) != -1]\n            matches.update(dict([(x, 1) for x in match]))\n        if filters:\n            names = sorted(matches.keys())\n            return names\n        else:\n            return sorted(allnames)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "dir", "self", "filters", "return", "an", "alphabetical", "list", "of", "dataelement", "keywords", "in", "the", "dataset", "intended", "mainly", "for", "use", "in", "interactive", "python", "sessions", "only", "lists", "the", "dataelement", "keywords", "in", "the", "current", "level", "of", "the", "dataset", "i", "e", "the", "contents", "of", "any", "sequence", "elements", "are", "ignored", "parameters", "filters", "str", "zero", "or", "more", "string", "arguments", "to", "the", "function", "used", "for", "case", "insensitive", "match", "to", "any", "part", "of", "the", "dicom", "keyword", "returns", "list", "of", "str", "the", "matching", "dataelement", "keywords", "in", "the", "dataset", "if", "no", "filters", "are", "used", "then", "all", "dataelement", "keywords", "are", "returned", "allnames", "keyword_for_tag", "tag", "for", "tag", "in", "self", "_dict", "keys", "remove", "blanks", "tags", "without", "valid", "names", "e", "g", "private", "tags", "allnames", "x", "for", "x", "in", "allnames", "if", "x", "store", "found", "names", "in", "a", "dict", "so", "duplicate", "names", "appear", "only", "once", "matches", "for", "filter_", "in", "filters", "filter_", "filter_", "lower", "match", "x", "for", "x", "in", "allnames", "if", "x", "lower", "find", "filter_", "1", "matches", "update", "dict", "x", "1", "for", "x", "in", "match", "if", "filters", "names", "sorted", "matches", "keys", "return", "names", "else", "return", "sorted", "allnames"], "doc_len": 173}
{"doc_id": "pydicom/dataset.py::Dataset.__eq__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__eq__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __eq__(self, other):\n        \"\"\"Compare `self` and `other` for equality.\n\n        Returns\n        -------\n        bool\n            The result if `self` and `other` are the same class\n        NotImplemented\n            If `other` is not the same class as `self` then returning\n            NotImplemented delegates the result to superclass.__eq__(subclass)\n        \"\"\"\n        # When comparing against self this will be faster\n        if other is self:\n            return True\n\n        if isinstance(other, self.__class__):\n            return _dict_equal(self, other)\n\n        return NotImplemented\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__eq__", "self", "other", "compare", "self", "and", "other", "for", "equality", "returns", "bool", "the", "result", "if", "self", "and", "other", "are", "the", "same", "class", "notimplemented", "if", "other", "is", "not", "the", "same", "class", "as", "self", "then", "returning", "notimplemented", "delegates", "the", "result", "to", "superclass", "__eq__", "subclass", "when", "comparing", "against", "self", "this", "will", "be", "faster", "if", "other", "is", "self", "return", "true", "if", "isinstance", "other", "self", "__class__", "return", "_dict_equal", "self", "other", "return", "notimplemented"], "doc_len": 71}
{"doc_id": "pydicom/dataset.py::Dataset.get", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "get", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def get(self, key, default=None):\n        \"\"\"Simulate dict.get() to handle DICOM DataElement tags and keywords.\n\n        Parameters\n        ----------\n        key : str or pydicom.tag.Tag\n            The element keyword or Tag or the class attribute name to get.\n        default : obj or None\n            If the DataElement or class attribute is not present, return\n            `default` (default None).\n\n        Returns\n        -------\n        value\n            If `key` is the keyword for a DataElement in the Dataset then\n            return the DataElement's value.\n        pydicom.dataelem.DataElement\n            If `key` is a tag for a DataElement in the Dataset then return the\n            DataElement instance.\n        value\n            If `key` is a class attribute then return its value.\n        \"\"\"\n        if isinstance(key, (str, compat.text_type)):\n            try:\n                return getattr(self, key)\n            except AttributeError:\n                return default\n        else:\n            # is not a string, try to make it into a tag and then hand it\n            # off to the underlying dict\n            if not isinstance(key, BaseTag):\n                try:\n                    key = Tag(key)\n                except Exception:\n                    raise TypeError(\"Dataset.get key must be a string or tag\")\n        try:\n            return self.__getitem__(key)\n        except KeyError:\n            return default\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "get", "self", "key", "default", "none", "simulate", "dict", "get", "to", "handle", "dicom", "dataelement", "tags", "and", "keywords", "parameters", "key", "str", "or", "pydicom", "tag", "tag", "the", "element", "keyword", "or", "tag", "or", "the", "class", "attribute", "name", "to", "get", "default", "obj", "or", "none", "if", "the", "dataelement", "or", "class", "attribute", "is", "not", "present", "return", "default", "default", "none", "returns", "value", "if", "key", "is", "the", "keyword", "for", "a", "dataelement", "in", "the", "dataset", "then", "return", "the", "dataelement", "s", "value", "pydicom", "dataelem", "dataelement", "if", "key", "is", "a", "tag", "for", "a", "dataelement", "in", "the", "dataset", "then", "return", "the", "dataelement", "instance", "value", "if", "key", "is", "a", "class", "attribute", "then", "return", "its", "value", "if", "isinstance", "key", "str", "compat", "text_type", "try", "return", "getattr", "self", "key", "except", "attributeerror", "return", "default", "else", "is", "not", "a", "string", "try", "to", "make", "it", "into", "a", "tag", "and", "then", "hand", "it", "off", "to", "the", "underlying", "dict", "if", "not", "isinstance", "key", "basetag", "try", "key", "tag", "key", "except", "exception", "raise", "typeerror", "dataset", "get", "key", "must", "be", "a", "string", "or", "tag", "try", "return", "self", "__getitem__", "key", "except", "keyerror", "return", "default"], "doc_len": 172}
{"doc_id": "pydicom/dataset.py::Dataset.items", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "items", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def items(self):\n        \"\"\"Return the elements in the Dataset as a list of tuple.\n\n        Returns\n        -------\n        list of tuple\n            The top-level (element tag, element) for the Dataset.\n        \"\"\"\n        return self._dict.items()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "items", "self", "return", "the", "elements", "in", "the", "dataset", "as", "a", "list", "of", "tuple", "returns", "list", "of", "tuple", "the", "top", "level", "element", "tag", "element", "for", "the", "dataset", "return", "self", "_dict", "items"], "doc_len": 35}
{"doc_id": "pydicom/dataset.py::Dataset.keys", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "keys", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def keys(self):\n        \"\"\"Return the DICOM tag keys to simulate dict.\"\"\"\n        return self._dict.keys()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "keys", "self", "return", "the", "dicom", "tag", "keys", "to", "simulate", "dict", "return", "self", "_dict", "keys"], "doc_len": 19}
{"doc_id": "pydicom/dataset.py::Dataset.values", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "values", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def values(self):\n        \"\"\"Return the DICOM tag values to simulate dict.\"\"\"\n        return self._dict.values()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "values", "self", "return", "the", "dicom", "tag", "values", "to", "simulate", "dict", "return", "self", "_dict", "values"], "doc_len": 19}
{"doc_id": "pydicom/dataset.py::Dataset.__getattr__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__getattr__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __getattr__(self, name):\n        \"\"\"Intercept requests for Dataset attribute names.\n\n        If `name` matches a DICOM keyword, return the value for the\n        DataElement with the corresponding tag.\n\n        Parameters\n        ----------\n        name\n            A DataElement keyword or tag or a class attribute name.\n\n        Returns\n        -------\n        value\n              If `name` matches a DICOM keyword, returns the corresponding\n              DataElement's value. Otherwise returns the class attribute's\n              value (if present).\n        \"\"\"\n        tag = tag_for_keyword(name)\n        if tag is None:  # `name` isn't a DICOM element keyword\n            # Try the base class attribute getter (fix for issue 332)\n            return object.__getattribute__(self, name)\n        tag = Tag(tag)\n        if tag not in self._dict:  # DICOM DataElement not in the Dataset\n            # Try the base class attribute getter (fix for issue 332)\n            return object.__getattribute__(self, name)\n        else:\n            data_elem = self[tag]\n            value = data_elem.value\n            if data_elem.VR == 'SQ':\n                # let a sequence know its parent dataset, as sequence items\n                # may need parent dataset tags to resolve ambiguous tags\n                value.parent = self\n            return value\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__getattr__", "self", "name", "intercept", "requests", "for", "dataset", "attribute", "names", "if", "name", "matches", "a", "dicom", "keyword", "return", "the", "value", "for", "the", "dataelement", "with", "the", "corresponding", "tag", "parameters", "name", "a", "dataelement", "keyword", "or", "tag", "or", "a", "class", "attribute", "name", "returns", "value", "if", "name", "matches", "a", "dicom", "keyword", "returns", "the", "corresponding", "dataelement", "s", "value", "otherwise", "returns", "the", "class", "attribute", "s", "value", "if", "present", "tag", "tag_for_keyword", "name", "if", "tag", "is", "none", "name", "isn", "t", "a", "dicom", "element", "keyword", "try", "the", "base", "class", "attribute", "getter", "fix", "for", "issue", "332", "return", "object", "__getattribute__", "self", "name", "tag", "tag", "tag", "if", "tag", "not", "in", "self", "_dict", "dicom", "dataelement", "not", "in", "the", "dataset", "try", "the", "base", "class", "attribute", "getter", "fix", "for", "issue", "332", "return", "object", "__getattribute__", "self", "name", "else", "data_elem", "self", "tag", "value", "data_elem", "value", "if", "data_elem", "vr", "sq", "let", "a", "sequence", "know", "its", "parent", "dataset", "as", "sequence", "items", "may", "need", "parent", "dataset", "tags", "to", "resolve", "ambiguous", "tags", "value", "parent", "self", "return", "value"], "doc_len": 159}
{"doc_id": "pydicom/dataset.py::Dataset._character_set", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_character_set", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _character_set(self):\n        \"\"\"The Dataset's SpecificCharacterSet value (if present).\"\"\"\n        char_set = self.get(BaseTag(0x00080005), None)\n\n        if not char_set:\n            char_set = self._parent_encoding\n        else:\n            char_set = convert_encodings(char_set)\n\n        return char_set\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_character_set", "self", "the", "dataset", "s", "specificcharacterset", "value", "if", "present", "char_set", "self", "get", "basetag", "0x00080005", "none", "if", "not", "char_set", "char_set", "self", "_parent_encoding", "else", "char_set", "convert_encodings", "char_set", "return", "char_set"], "doc_len": 32}
{"doc_id": "pydicom/dataset.py::Dataset.__getitem__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__getitem__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __getitem__(self, key):\n        \"\"\"Operator for Dataset[key] request.\n\n        Any deferred data elements will be read in and an attempt will be made\n        to correct any elements with ambiguous VRs.\n\n        Examples\n        --------\n        Indexing using DataElement tag\n        >>> ds = Dataset()\n        >>> ds.SOPInstanceUID = '1.2.3'\n        >>> ds.PatientName = 'CITIZEN^Jan'\n        >>> ds.PatientID = '12345'\n        >>> ds[0x00100010].value\n        'CITIZEN^Jan'\n\n        Slicing using DataElement tag\n        All group 0x0010 elements in the dataset\n        >>> ds[0x00100000:0x00110000]\n        (0010, 0010) Patient's Name                      PN: 'CITIZEN^Jan'\n        (0010, 0020) Patient ID                          LO: '12345'\n\n        All group 0x0002 elements in the dataset\n        >>> ds[(0x0002, 0x0000):(0x0003, 0x0000)]\n        <BLANKLINE>\n\n        Parameters\n        ----------\n        key\n            The DICOM (group, element) tag in any form accepted by\n            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,\n            etc. May also be a slice made up of DICOM tags.\n\n        Returns\n        -------\n        pydicom.dataelem.DataElement or pydicom.dataset.Dataset\n            If a single DICOM element tag is used then returns the\n            corresponding DataElement. If a slice is used then returns a\n            Dataset object containing the corresponding DataElements.\n        \"\"\"\n        # If passed a slice, return a Dataset containing the corresponding\n        #   DataElements\n        if isinstance(key, slice):\n            return self._dataset_slice(key)\n\n        if isinstance(key, BaseTag):\n            tag = key\n        else:\n            tag = Tag(key)\n        data_elem = self._dict[tag]\n\n        if isinstance(data_elem, DataElement):\n            return data_elem\n        elif isinstance(data_elem, tuple):\n            # If a deferred read, then go get the value now\n            if data_elem.value is None:\n                from pydicom.filereader import read_deferred_data_element\n                data_elem = read_deferred_data_element(\n                    self.fileobj_type, self.filename, self.timestamp,\n                    data_elem)\n\n            if tag != BaseTag(0x00080005):\n                character_set = self.read_encoding or self._character_set\n            else:\n                character_set = default_encoding\n            # Not converted from raw form read from file yet; do so now\n            self[tag] = DataElement_from_raw(data_elem, character_set)\n\n            # If the Element has an ambiguous VR, try to correct it\n            if 'or' in self[tag].VR:\n                from pydicom.filewriter import correct_ambiguous_vr_element\n                self[tag] = correct_ambiguous_vr_element(\n                    self[tag], self, data_elem[6])\n\n        return self._dict.get(tag)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__getitem__", "self", "key", "operator", "for", "dataset", "key", "request", "any", "deferred", "data", "elements", "will", "be", "read", "in", "and", "an", "attempt", "will", "be", "made", "to", "correct", "any", "elements", "with", "ambiguous", "vrs", "examples", "indexing", "using", "dataelement", "tag", "ds", "dataset", "ds", "sopinstanceuid", "1", "2", "3", "ds", "patientname", "citizen", "jan", "ds", "patientid", "12345", "ds", "0x00100010", "value", "citizen", "jan", "slicing", "using", "dataelement", "tag", "all", "group", "0x0010", "elements", "in", "the", "dataset", "ds", "0x00100000", "0x00110000", "0010", "0010", "patient", "s", "name", "pn", "citizen", "jan", "0010", "0020", "patient", "id", "lo", "12345", "all", "group", "0x0002", "elements", "in", "the", "dataset", "ds", "0x0002", "0x0000", "0x0003", "0x0000", "blankline", "parameters", "key", "the", "dicom", "group", "element", "tag", "in", "any", "form", "accepted", "by", "pydicom", "tag", "tag", "such", "as", "0x0010", "0x0010", "0x10", "0x10", "0x00100010", "etc", "may", "also", "be", "a", "slice", "made", "up", "of", "dicom", "tags", "returns", "pydicom", "dataelem", "dataelement", "or", "pydicom", "dataset", "dataset", "if", "a", "single", "dicom", "element", "tag", "is", "used", "then", "returns", "the", "corresponding", "dataelement", "if", "a", "slice", "is", "used", "then", "returns", "a", "dataset", "object", "containing", "the", "corresponding", "dataelements", "if", "passed", "a", "slice", "return", "a", "dataset", "containing", "the", "corresponding", "dataelements", "if", "isinstance", "key", "slice", "return", "self", "_dataset_slice", "key", "if", "isinstance", "key", "basetag", "tag", "key", "else", "tag", "tag", "key", "data_elem", "self", "_dict", "tag", "if", "isinstance", "data_elem", "dataelement", "return", "data_elem", "elif", "isinstance", "data_elem", "tuple", "if", "a", "deferred", "read", "then", "go", "get", "the", "value", "now", "if", "data_elem", "value", "is", "none", "from", "pydicom", "filereader", "import", "read_deferred_data_element", "data_elem", "read_deferred_data_element", "self", "fileobj_type", "self", "filename", "self", "timestamp", "data_elem", "if", "tag", "basetag", "0x00080005", "character_set", "self", "read_encoding", "or", "self", "_character_set", "else", "character_set", "default_encoding", "not", "converted", "from", "raw", "form", "read", "from", "file", "yet", "do", "so", "now", "self", "tag", "dataelement_from_raw", "data_elem", "character_set", "if", "the", "element", "has", "an", "ambiguous", "vr", "try", "to", "correct", "it", "if", "or", "in", "self", "tag", "vr", "from", "pydicom", "filewriter", "import", "correct_ambiguous_vr_element", "self", "tag", "correct_ambiguous_vr_element", "self", "tag", "self", "data_elem", "6", "return", "self", "_dict", "get", "tag"], "doc_len": 304}
{"doc_id": "pydicom/dataset.py::Dataset.private_block", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "private_block", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def private_block(self, group, private_creator, create=False):\n        \"\"\"Return the block for the given tag and private creator.\n\n        If `create` is set and the private creator does not exist,\n        the private creator tag is added.\n        Note: We ignore the unrealistic case that no free block is\n        available.\n\n        Parameters\n        ----------\n        group : 32 bit int\n            The group of the private tag to be found. Must be an odd number\n            (e.g. a private group).\n        private_creator : str\n            The private creator string associated with the tag.\n        create : bool\n            If `True` and `private_creator` does not exist, a new private\n            creator tag is added at the next free block.\n            If `False` (the default) and `private_creator` does not exist,\n            `KeyError` is raised instead.\n\n        Returns\n        -------\n        32 bit int\n            Element base for the given tag (the last 2 hex digits are always 0)\n\n        Raises\n        ------\n        ValueError\n            If `tag` is not a private tag or `private_creator` is empty.\n        KeyError\n            If the private creator tag is not found in the given group and\n            the `create` parameter is not set.\n        \"\"\"\n        def new_block():\n            block = PrivateBlock(key, self, element)\n            self._private_blocks[key] = block\n            return block\n\n        key = (group, private_creator)\n        if key in self._private_blocks:\n            return self._private_blocks[key]\n\n        if not private_creator:\n            raise ValueError('Private creator must have a value')\n\n        if group % 2 == 0:\n            raise ValueError(\n                'Tag must be private if private creator is given')\n\n        for element in range(0x10, 0x100):\n            private_creator_tag = Tag(group, element)\n            if private_creator_tag not in self._dict:\n                if create:\n                    self.add_new(private_creator_tag, 'LO', private_creator)\n                    return new_block()\n                else:\n                    break\n            if self._dict[private_creator_tag].value == private_creator:\n                return new_block()\n\n        raise KeyError(\n            \"Private creator '{}' not found\".format(private_creator))\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "private_block", "self", "group", "private_creator", "create", "false", "return", "the", "block", "for", "the", "given", "tag", "and", "private", "creator", "if", "create", "is", "set", "and", "the", "private", "creator", "does", "not", "exist", "the", "private", "creator", "tag", "is", "added", "note", "we", "ignore", "the", "unrealistic", "case", "that", "no", "free", "block", "is", "available", "parameters", "group", "32", "bit", "int", "the", "group", "of", "the", "private", "tag", "to", "be", "found", "must", "be", "an", "odd", "number", "e", "g", "a", "private", "group", "private_creator", "str", "the", "private", "creator", "string", "associated", "with", "the", "tag", "create", "bool", "if", "true", "and", "private_creator", "does", "not", "exist", "a", "new", "private", "creator", "tag", "is", "added", "at", "the", "next", "free", "block", "if", "false", "the", "default", "and", "private_creator", "does", "not", "exist", "keyerror", "is", "raised", "instead", "returns", "32", "bit", "int", "element", "base", "for", "the", "given", "tag", "the", "last", "2", "hex", "digits", "are", "always", "0", "raises", "valueerror", "if", "tag", "is", "not", "a", "private", "tag", "or", "private_creator", "is", "empty", "keyerror", "if", "the", "private", "creator", "tag", "is", "not", "found", "in", "the", "given", "group", "and", "the", "create", "parameter", "is", "not", "set", "def", "new_block", "block", "privateblock", "key", "self", "element", "self", "_private_blocks", "key", "block", "return", "block", "key", "group", "private_creator", "if", "key", "in", "self", "_private_blocks", "return", "self", "_private_blocks", "key", "if", "not", "private_creator", "raise", "valueerror", "private", "creator", "must", "have", "a", "value", "if", "group", "2", "0", "raise", "valueerror", "tag", "must", "be", "private", "if", "private", "creator", "is", "given", "for", "element", "in", "range", "0x10", "0x100", "private_creator_tag", "tag", "group", "element", "if", "private_creator_tag", "not", "in", "self", "_dict", "if", "create", "self", "add_new", "private_creator_tag", "lo", "private_creator", "return", "new_block", "else", "break", "if", "self", "_dict", "private_creator_tag", "value", "private_creator", "return", "new_block", "raise", "keyerror", "private", "creator", "not", "found", "format", "private_creator"], "doc_len": 263}
{"doc_id": "pydicom/dataset.py::Dataset.private_creators", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "private_creators", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def private_creators(self, group):\n        \"\"\"Return a list of private creator names in the given group.\n\n        This can be used to check if a given private creator exists in\n        the group of the dataset:\n        >>> ds = Dataset()\n        >>> if 'My Creator' in ds.private_creators(0x0041):\n        ...     block = ds.private_block(0x0041, 'My Creator')\n\n        Parameters\n        ----------\n        group : 32 bit int\n            The private group. Must be an odd number.\n\n        Returns\n        -------\n        list of str\n            List of all private creator names for private blocks in the group.\n\n        Raises\n        ------\n        ValueError\n            If `group` is not a private group.\n        \"\"\"\n        if group % 2 == 0:\n            raise ValueError('Group must be an odd number')\n\n        private_creators = []\n        for element in range(0x10, 0x100):\n            private_creator_tag = Tag(group, element)\n            if private_creator_tag not in self._dict:\n                break\n            private_creators.append(self._dict[private_creator_tag].value)\n        return private_creators\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "private_creators", "self", "group", "return", "a", "list", "of", "private", "creator", "names", "in", "the", "given", "group", "this", "can", "be", "used", "to", "check", "if", "a", "given", "private", "creator", "exists", "in", "the", "group", "of", "the", "dataset", "ds", "dataset", "if", "my", "creator", "in", "ds", "private_creators", "0x0041", "block", "ds", "private_block", "0x0041", "my", "creator", "parameters", "group", "32", "bit", "int", "the", "private", "group", "must", "be", "an", "odd", "number", "returns", "list", "of", "str", "list", "of", "all", "private", "creator", "names", "for", "private", "blocks", "in", "the", "group", "raises", "valueerror", "if", "group", "is", "not", "a", "private", "group", "if", "group", "2", "0", "raise", "valueerror", "group", "must", "be", "an", "odd", "number", "private_creators", "for", "element", "in", "range", "0x10", "0x100", "private_creator_tag", "tag", "group", "element", "if", "private_creator_tag", "not", "in", "self", "_dict", "break", "private_creators", "append", "self", "_dict", "private_creator_tag", "value", "return", "private_creators"], "doc_len": 128}
{"doc_id": "pydicom/dataset.py::Dataset.get_private_item", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "get_private_item", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def get_private_item(self, group, element_offset, private_creator):\n        \"\"\"Return the data element for the given private tag.\n\n        This is analogous to `__getitem__`, but only for private tags.\n        This allows to find the private tag for the correct private creator\n        without the need to add the tag to the private dictionary first.\n\n        Parameters\n        ----------\n        group : 32 bit int\n            The private group where the item is located.\n        element_offset : 16 bit int\n            The lower 16 bit (e.g. 2 hex numbers) of the element tag.\n        private_creator : str\n            The private creator for the tag. Must match the private creator\n            for the tag to be returned.\n\n        Returns\n        -------\n        pydicom.dataelem.DataElement\n\n        Raises\n        ------\n        ValueError\n            If `tag` is not a private tag or `private_creator` is empty.\n        KeyError\n            If the private creator tag is not found in the given group.\n            If the private tag is not found.\n        \"\"\"\n        block = self.private_block(group, private_creator)\n        return self.__getitem__(block.get_tag(element_offset))\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "get_private_item", "self", "group", "element_offset", "private_creator", "return", "the", "data", "element", "for", "the", "given", "private", "tag", "this", "is", "analogous", "to", "__getitem__", "but", "only", "for", "private", "tags", "this", "allows", "to", "find", "the", "private", "tag", "for", "the", "correct", "private", "creator", "without", "the", "need", "to", "add", "the", "tag", "to", "the", "private", "dictionary", "first", "parameters", "group", "32", "bit", "int", "the", "private", "group", "where", "the", "item", "is", "located", "element_offset", "16", "bit", "int", "the", "lower", "16", "bit", "e", "g", "2", "hex", "numbers", "of", "the", "element", "tag", "private_creator", "str", "the", "private", "creator", "for", "the", "tag", "must", "match", "the", "private", "creator", "for", "the", "tag", "to", "be", "returned", "returns", "pydicom", "dataelem", "dataelement", "raises", "valueerror", "if", "tag", "is", "not", "a", "private", "tag", "or", "private_creator", "is", "empty", "keyerror", "if", "the", "private", "creator", "tag", "is", "not", "found", "in", "the", "given", "group", "if", "the", "private", "tag", "is", "not", "found", "block", "self", "private_block", "group", "private_creator", "return", "self", "__getitem__", "block", "get_tag", "element_offset"], "doc_len": 150}
{"doc_id": "pydicom/dataset.py::Dataset.get_item", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "get_item", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def get_item(self, key):\n        \"\"\"Return the raw data element if possible.\n\n        It will be raw if the user has never accessed the value, or set their\n        own value. Note if the data element is a deferred-read element,\n        then it is read and converted before being returned.\n\n        Parameters\n        ----------\n        key\n            The DICOM (group, element) tag in any form accepted by\n            pydicom.tag.Tag such as [0x0010, 0x0010], (0x10, 0x10), 0x00100010,\n            etc. May also be a slice made up of DICOM tags.\n\n        Returns\n        -------\n        pydicom.dataelem.DataElement\n        \"\"\"\n        if isinstance(key, slice):\n            return self._dataset_slice(key)\n\n        if isinstance(key, BaseTag):\n            tag = key\n        else:\n            tag = Tag(key)\n        data_elem = self._dict.get(tag)\n        # If a deferred read, return using __getitem__ to read and convert it\n        if isinstance(data_elem, tuple) and data_elem.value is None:\n            return self[key]\n        return data_elem\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "get_item", "self", "key", "return", "the", "raw", "data", "element", "if", "possible", "it", "will", "be", "raw", "if", "the", "user", "has", "never", "accessed", "the", "value", "or", "set", "their", "own", "value", "note", "if", "the", "data", "element", "is", "a", "deferred", "read", "element", "then", "it", "is", "read", "and", "converted", "before", "being", "returned", "parameters", "key", "the", "dicom", "group", "element", "tag", "in", "any", "form", "accepted", "by", "pydicom", "tag", "tag", "such", "as", "0x0010", "0x0010", "0x10", "0x10", "0x00100010", "etc", "may", "also", "be", "a", "slice", "made", "up", "of", "dicom", "tags", "returns", "pydicom", "dataelem", "dataelement", "if", "isinstance", "key", "slice", "return", "self", "_dataset_slice", "key", "if", "isinstance", "key", "basetag", "tag", "key", "else", "tag", "tag", "key", "data_elem", "self", "_dict", "get", "tag", "if", "a", "deferred", "read", "return", "using", "__getitem__", "to", "read", "and", "convert", "it", "if", "isinstance", "data_elem", "tuple", "and", "data_elem", "value", "is", "none", "return", "self", "key", "return", "data_elem"], "doc_len": 137}
{"doc_id": "pydicom/dataset.py::Dataset._dataset_slice", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_dataset_slice", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _dataset_slice(self, slice):\n        \"\"\"Return a slice that has the same properties as the original\n        dataset. That includes properties related to endianess and VR handling,\n        and the specific character set. No element conversion is done, e.g.\n        elements of type RawDataElement are kept.\n        \"\"\"\n        tags = self._slice_dataset(slice.start, slice.stop, slice.step)\n        dataset = Dataset({tag: self.get_item(tag) for tag in tags})\n        dataset.is_little_endian = self.is_little_endian\n        dataset.is_implicit_VR = self.is_implicit_VR\n        dataset.set_original_encoding(self.read_implicit_vr,\n                                      self.read_little_endian,\n                                      self.read_encoding)\n        return dataset\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_dataset_slice", "self", "slice", "return", "a", "slice", "that", "has", "the", "same", "properties", "as", "the", "original", "dataset", "that", "includes", "properties", "related", "to", "endianess", "and", "vr", "handling", "and", "the", "specific", "character", "set", "no", "element", "conversion", "is", "done", "e", "g", "elements", "of", "type", "rawdataelement", "are", "kept", "tags", "self", "_slice_dataset", "slice", "start", "slice", "stop", "slice", "step", "dataset", "dataset", "tag", "self", "get_item", "tag", "for", "tag", "in", "tags", "dataset", "is_little_endian", "self", "is_little_endian", "dataset", "is_implicit_vr", "self", "is_implicit_vr", "dataset", "set_original_encoding", "self", "read_implicit_vr", "self", "read_little_endian", "self", "read_encoding", "return", "dataset"], "doc_len": 84}
{"doc_id": "pydicom/dataset.py::Dataset.is_original_encoding", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "is_original_encoding", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def is_original_encoding(self):\n        \"\"\"Return True if the properties to be used for writing are set and\n        have the same value as the ones in the dataset after reading it.\n        This includes properties related to endianess, VR handling and the\n        specific character set.\n        \"\"\"\n        return (self.is_implicit_VR is not None and\n                self.is_little_endian is not None and\n                self.read_implicit_vr == self.is_implicit_VR and\n                self.read_little_endian == self.is_little_endian and\n                self.read_encoding == self._character_set)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "is_original_encoding", "self", "return", "true", "if", "the", "properties", "to", "be", "used", "for", "writing", "are", "set", "and", "have", "the", "same", "value", "as", "the", "ones", "in", "the", "dataset", "after", "reading", "it", "this", "includes", "properties", "related", "to", "endianess", "vr", "handling", "and", "the", "specific", "character", "set", "return", "self", "is_implicit_vr", "is", "not", "none", "and", "self", "is_little_endian", "is", "not", "none", "and", "self", "read_implicit_vr", "self", "is_implicit_vr", "and", "self", "read_little_endian", "self", "is_little_endian", "and", "self", "read_encoding", "self", "_character_set"], "doc_len": 73}
{"doc_id": "pydicom/dataset.py::Dataset.set_original_encoding", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "set_original_encoding", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def set_original_encoding(self, is_implicit_vr, is_little_endian,\n                              character_encoding):\n        \"\"\"Set the values for the original transfer syntax and encoding.\n        Can be used for a dataset with raw data elements to enable\n        optimized writing (e.g. without decoding the data elements).\n        \"\"\"\n        self.read_implicit_vr = is_implicit_vr\n        self.read_little_endian = is_little_endian\n        self.read_encoding = character_encoding\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "set_original_encoding", "self", "is_implicit_vr", "is_little_endian", "character_encoding", "set", "the", "values", "for", "the", "original", "transfer", "syntax", "and", "encoding", "can", "be", "used", "for", "a", "dataset", "with", "raw", "data", "elements", "to", "enable", "optimized", "writing", "e", "g", "without", "decoding", "the", "data", "elements", "self", "read_implicit_vr", "is_implicit_vr", "self", "read_little_endian", "is_little_endian", "self", "read_encoding", "character_encoding"], "doc_len": 50}
{"doc_id": "pydicom/dataset.py::Dataset.group_dataset", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "group_dataset", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def group_dataset(self, group):\n        \"\"\"Return a Dataset containing only DataElements of a certain group.\n\n        Parameters\n        ----------\n        group : int\n            The group part of a DICOM (group, element) tag.\n\n        Returns\n        -------\n        pydicom.dataset.Dataset\n            A dataset instance containing elements of the group specified.\n        \"\"\"\n        return self[(group, 0x0000):(group + 1, 0x0000)]\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "group_dataset", "self", "group", "return", "a", "dataset", "containing", "only", "dataelements", "of", "a", "certain", "group", "parameters", "group", "int", "the", "group", "part", "of", "a", "dicom", "group", "element", "tag", "returns", "pydicom", "dataset", "dataset", "a", "dataset", "instance", "containing", "elements", "of", "the", "group", "specified", "return", "self", "group", "0x0000", "group", "1", "0x0000"], "doc_len": 50}
{"doc_id": "pydicom/dataset.py::Dataset.__iter__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__iter__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __iter__(self):\n        \"\"\"Iterate through the top-level of the Dataset, yielding DataElements.\n\n        >>> ds = Dataset()\n        >>> for elem in ds:\n        ...     print(elem)\n\n        The DataElements are returned in increasing tag value order.\n        Sequence items are returned as a single DataElement, so it is up to the\n        calling code to recurse into the Sequence items if desired.\n\n        Yields\n        ------\n        pydicom.dataelem.DataElement\n            The Dataset's DataElements, sorted by increasing tag order.\n        \"\"\"\n        # Note this is different than the underlying dict class,\n        #        which returns the key of the key:value mapping.\n        #   Here the value is returned (but data_element.tag has the key)\n        taglist = sorted(self._dict.keys())\n        for tag in taglist:\n            yield self[tag]\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__iter__", "self", "iterate", "through", "the", "top", "level", "of", "the", "dataset", "yielding", "dataelements", "ds", "dataset", "for", "elem", "in", "ds", "print", "elem", "the", "dataelements", "are", "returned", "in", "increasing", "tag", "value", "order", "sequence", "items", "are", "returned", "as", "a", "single", "dataelement", "so", "it", "is", "up", "to", "the", "calling", "code", "to", "recurse", "into", "the", "sequence", "items", "if", "desired", "yields", "pydicom", "dataelem", "dataelement", "the", "dataset", "s", "dataelements", "sorted", "by", "increasing", "tag", "order", "note", "this", "is", "different", "than", "the", "underlying", "dict", "class", "which", "returns", "the", "key", "of", "the", "key", "value", "mapping", "here", "the", "value", "is", "returned", "but", "data_element", "tag", "has", "the", "key", "taglist", "sorted", "self", "_dict", "keys", "for", "tag", "in", "taglist", "yield", "self", "tag"], "doc_len": 112}
{"doc_id": "pydicom/dataset.py::Dataset.elements", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "elements", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def elements(self):\n        \"\"\"Iterate through the top-level of the Dataset, yielding DataElements\n        or RawDataElements (no conversion done).\n\n        >>> ds = Dataset()\n        >>> for elem in ds.elements():\n        ...     print(elem)\n\n        The elements are returned in the same way as in __getitem__.\n\n        Yields\n        ------\n        pydicom.dataelem.DataElement or pydicom.dataelem.RawDataElement\n            The Dataset's DataElements, sorted by increasing tag order.\n        \"\"\"\n        taglist = sorted(self._dict.keys())\n        for tag in taglist:\n            yield self.get_item(tag)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "elements", "self", "iterate", "through", "the", "top", "level", "of", "the", "dataset", "yielding", "dataelements", "or", "rawdataelements", "no", "conversion", "done", "ds", "dataset", "for", "elem", "in", "ds", "elements", "print", "elem", "the", "elements", "are", "returned", "in", "the", "same", "way", "as", "in", "__getitem__", "yields", "pydicom", "dataelem", "dataelement", "or", "pydicom", "dataelem", "rawdataelement", "the", "dataset", "s", "dataelements", "sorted", "by", "increasing", "tag", "order", "taglist", "sorted", "self", "_dict", "keys", "for", "tag", "in", "taglist", "yield", "self", "get_item", "tag"], "doc_len": 72}
{"doc_id": "pydicom/dataset.py::Dataset.__len__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__len__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __len__(self):\n        return len(self._dict)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__len__", "self", "return", "len", "self", "_dict"], "doc_len": 11}
{"doc_id": "pydicom/dataset.py::Dataset.__ne__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__ne__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __ne__(self, other):\n        \"\"\"Compare `self` and `other` for inequality.\"\"\"\n        return not self == other\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__ne__", "self", "other", "compare", "self", "and", "other", "for", "inequality", "return", "not", "self", "other"], "doc_len": 18}
{"doc_id": "pydicom/dataset.py::Dataset.clear", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "clear", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def clear(self):\n        \"\"\"Delete all data elements.\"\"\"\n        self._dict.clear()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "clear", "self", "delete", "all", "data", "elements", "self", "_dict", "clear"], "doc_len": 14}
{"doc_id": "pydicom/dataset.py::Dataset.pop", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "pop", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def pop(self, key, *args):\n        \"\"\"Emulate dictionary `pop`, but additionally support tag ID tuple\n        and DICOM keyword.\n\n        Removes the data element for `key` if it exists and returns it,\n        otherwise returns a default value if given or raises `KeyError`.\n\n        Parameters\n        ----------\n        key: int or str or 2-tuple\n            if tuple - the group and element number of the DICOM tag\n            if int - the combined group/element number\n            if str - the DICOM keyword of the tag\n\n        *args: zero or one argument\n            defines the behavior if no tag exists for `key`: if given,\n            it defines the return value, if not given, `KeyError` is raised\n\n        Returns\n        -------\n        The data element for `key` if it exists, or the default value if given.\n\n        Raises\n        ------\n        KeyError\n            If the key is not a valid tag ID or keyword.\n            If the tag does not exist and no default is given.\n        \"\"\"\n        try:\n            tag = Tag(key)\n        except (ValueError, OverflowError):\n            return self._dict.pop(key, *args)\n        return self._dict.pop(tag, *args)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "pop", "self", "key", "args", "emulate", "dictionary", "pop", "but", "additionally", "support", "tag", "id", "tuple", "and", "dicom", "keyword", "removes", "the", "data", "element", "for", "key", "if", "it", "exists", "and", "returns", "it", "otherwise", "returns", "a", "default", "value", "if", "given", "or", "raises", "keyerror", "parameters", "key", "int", "or", "str", "or", "2", "tuple", "if", "tuple", "the", "group", "and", "element", "number", "of", "the", "dicom", "tag", "if", "int", "the", "combined", "group", "element", "number", "if", "str", "the", "dicom", "keyword", "of", "the", "tag", "args", "zero", "or", "one", "argument", "defines", "the", "behavior", "if", "no", "tag", "exists", "for", "key", "if", "given", "it", "defines", "the", "return", "value", "if", "not", "given", "keyerror", "is", "raised", "returns", "the", "data", "element", "for", "key", "if", "it", "exists", "or", "the", "default", "value", "if", "given", "raises", "keyerror", "if", "the", "key", "is", "not", "a", "valid", "tag", "id", "or", "keyword", "if", "the", "tag", "does", "not", "exist", "and", "no", "default", "is", "given", "try", "tag", "tag", "key", "except", "valueerror", "overflowerror", "return", "self", "_dict", "pop", "key", "args", "return", "self", "_dict", "pop", "tag", "args"], "doc_len": 162}
{"doc_id": "pydicom/dataset.py::Dataset.popitem", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "popitem", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def popitem(self):\n        return self._dict.popitem()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "popitem", "self", "return", "self", "_dict", "popitem"], "doc_len": 11}
{"doc_id": "pydicom/dataset.py::Dataset.setdefault", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "setdefault", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def setdefault(self, key, default=None):\n        \"\"\"Emulate dictionary `setdefault`, but additionally support\n        tag ID tuple and DICOM keyword for `key`, and data element value\n        for `default`.\n\n        .. usage:\n\n        >>> ds = Dataset()\n        >>> pname = ds.setdefault((0x0010, 0x0010), \"Test\")\n        >>> pname\n        (0010, 0010) Patient's Name                      PN: 'Test'\n        >>> pname.value\n        'Test'\n        >>> psex = ds.setdefault('PatientSex',\n        ...     DataElement(0x00100040, 'CS', 'F'))\n        >>> psex.value\n        'F'\n\n        Parameters\n        ----------\n        key: int or str or 2-tuple\n            if tuple - the group and element number of the DICOM tag\n            if int - the combined group/element number\n            if str - the DICOM keyword of the tag\n\n        default: DataElement or value type or None\n            The default value that is inserted and returned if no data\n            element exists for the given key.\n            If it is not of type DataElement, a DataElement is constructed\n            instead for the given tag ID and default as value. This is only\n            possible for known tags (e.g. tags found via the dictionary\n            lookup).\n\n        Returns\n        -------\n        The data element for `key` if it exists, or the default value if\n        it is a DataElement or None, or a DataElement constructed with\n        `default` as value.\n\n        Raises\n        ------\n        KeyError\n            If the key is not a valid tag ID or keyword.\n            If no tag exists for `key`, default is not a DataElement\n            and not None, and key is not a known DICOM tag.\n        \"\"\"\n        if key in self:\n            return self[key]\n        if default is not None:\n            if not isinstance(default, DataElement):\n                tag = Tag(key)\n                vr = datadict.dictionary_VR(tag)\n                default = DataElement(Tag(key), vr, default)\n            self[key] = default\n        return default\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "setdefault", "self", "key", "default", "none", "emulate", "dictionary", "setdefault", "but", "additionally", "support", "tag", "id", "tuple", "and", "dicom", "keyword", "for", "key", "and", "data", "element", "value", "for", "default", "usage", "ds", "dataset", "pname", "ds", "setdefault", "0x0010", "0x0010", "test", "pname", "0010", "0010", "patient", "s", "name", "pn", "test", "pname", "value", "test", "psex", "ds", "setdefault", "patientsex", "dataelement", "0x00100040", "cs", "f", "psex", "value", "f", "parameters", "key", "int", "or", "str", "or", "2", "tuple", "if", "tuple", "the", "group", "and", "element", "number", "of", "the", "dicom", "tag", "if", "int", "the", "combined", "group", "element", "number", "if", "str", "the", "dicom", "keyword", "of", "the", "tag", "default", "dataelement", "or", "value", "type", "or", "none", "the", "default", "value", "that", "is", "inserted", "and", "returned", "if", "no", "data", "element", "exists", "for", "the", "given", "key", "if", "it", "is", "not", "of", "type", "dataelement", "a", "dataelement", "is", "constructed", "instead", "for", "the", "given", "tag", "id", "and", "default", "as", "value", "this", "is", "only", "possible", "for", "known", "tags", "e", "g", "tags", "found", "via", "the", "dictionary", "lookup", "returns", "the", "data", "element", "for", "key", "if", "it", "exists", "or", "the", "default", "value", "if", "it", "is", "a", "dataelement", "or", "none", "or", "a", "dataelement", "constructed", "with", "default", "as", "value", "raises", "keyerror", "if", "the", "key", "is", "not", "a", "valid", "tag", "id", "or", "keyword", "if", "no", "tag", "exists", "for", "key", "default", "is", "not", "a", "dataelement", "and", "not", "none", "and", "key", "is", "not", "a", "known", "dicom", "tag", "if", "key", "in", "self", "return", "self", "key", "if", "default", "is", "not", "none", "if", "not", "isinstance", "default", "dataelement", "tag", "tag", "key", "vr", "datadict", "dictionary_vr", "tag", "default", "dataelement", "tag", "key", "vr", "default", "self", "key", "default", "return", "default"], "doc_len": 253}
{"doc_id": "pydicom/dataset.py::Dataset.convert_pixel_data", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "convert_pixel_data", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def convert_pixel_data(self):\n        \"\"\"Convert the Pixel Data to a numpy array internally.\n\n        Returns\n        -------\n        None\n            Converted pixel data is stored internally in the dataset.\n\n        Notes\n        -----\n        If the pixel data is in a compressed image format, the data is\n        decompressed and any related data elements are changed accordingly.\n        \"\"\"\n        # Check if already have converted to a NumPy array\n        # Also check if self.PixelData has changed. If so, get new NumPy array\n        already_have = True\n        if not hasattr(self, \"_pixel_array\"):\n            already_have = False\n        elif self._pixel_id != id(self.PixelData):\n            already_have = False\n\n        if already_have:\n            return\n\n        # Find all possible handlers that support the transfer syntax\n        transfer_syntax = self.file_meta.TransferSyntaxUID\n        possible_handlers = [hh for hh in pydicom.config.pixel_data_handlers\n                             if hh.supports_transfer_syntax(transfer_syntax)]\n\n        # No handlers support the transfer syntax\n        if not possible_handlers:\n            raise NotImplementedError(\n                \"Unable to decode pixel data with a transfer syntax UID of \"\n                \"'{0}' ({1}) as there are no pixel data handlers \"\n                \"available that support it. Please see the pydicom \"\n                \"documentation for information on supported transfer syntaxes \"\n                .format(self.file_meta.TransferSyntaxUID,\n                        self.file_meta.TransferSyntaxUID.name)\n            )\n\n        # Handlers that both support the transfer syntax and have their\n        #   dependencies met\n        available_handlers = [hh for hh in possible_handlers if\n                              hh.is_available()]\n\n        # There are handlers that support the transfer syntax but none of them\n        #   can be used as missing dependencies\n        if not available_handlers:\n            # For each of the possible handlers we want to find which\n            #   dependencies are missing\n            msg = (\n                \"The following handlers are available to decode the pixel \"\n                \"data however they are missing required dependencies: \"\n            )\n            pkg_msg = []\n            for hh in possible_handlers:\n                hh_deps = hh.DEPENDENCIES\n                # Missing packages\n                missing = [dd for dd in hh_deps if have_package(dd) is None]\n                # Package names\n                names = [hh_deps[name][1] for name in missing]\n                pkg_msg.append(\n                    \"{} (req. {})\"\n                    .format(hh.HANDLER_NAME, ', '.join(names))\n                )\n\n            raise RuntimeError(msg + ', '.join(pkg_msg))\n\n        last_exception = None\n        for handler in available_handlers:\n            try:\n                # Use the handler to get a 1D numpy array of the pixel data\n                arr = handler.get_pixeldata(self)\n                self._pixel_array = reshape_pixel_array(self, arr)\n\n                # Some handler/transfer syntax combinations may need to\n                #   convert the color space from YCbCr to RGB\n                if handler.needs_to_convert_to_RGB(self):\n                    self._pixel_array = convert_color_space(self._pixel_array,\n                                                            'YBR_FULL',\n                                                            'RGB')\n\n                self._pixel_id = id(self.PixelData)\n\n                return\n            except Exception as exc:\n                logger.debug(\n                    \"Exception raised by pixel data handler\", exc_info=exc\n                )\n                last_exception = exc\n\n        # The only way to get to this point is if we failed to get the pixel\n        #   array because all suitable handlers raised exceptions\n        self._pixel_array = None\n        self._pixel_id = None\n\n        logger.info(\n            \"Unable to decode the pixel data using the following handlers: {}.\"\n            \"Please see the list of supported Transfer Syntaxes in the \"\n            \"pydicom documentation for alternative packages that might \"\n            \"be able to decode the data\"\n            .format(\", \".join([str(hh) for hh in available_handlers]))\n        )\n\n        raise last_exception\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "convert_pixel_data", "self", "convert", "the", "pixel", "data", "to", "a", "numpy", "array", "internally", "returns", "none", "converted", "pixel", "data", "is", "stored", "internally", "in", "the", "dataset", "notes", "if", "the", "pixel", "data", "is", "in", "a", "compressed", "image", "format", "the", "data", "is", "decompressed", "and", "any", "related", "data", "elements", "are", "changed", "accordingly", "check", "if", "already", "have", "converted", "to", "a", "numpy", "array", "also", "check", "if", "self", "pixeldata", "has", "changed", "if", "so", "get", "new", "numpy", "array", "already_have", "true", "if", "not", "hasattr", "self", "_pixel_array", "already_have", "false", "elif", "self", "_pixel_id", "id", "self", "pixeldata", "already_have", "false", "if", "already_have", "return", "find", "all", "possible", "handlers", "that", "support", "the", "transfer", "syntax", "transfer_syntax", "self", "file_meta", "transfersyntaxuid", "possible_handlers", "hh", "for", "hh", "in", "pydicom", "config", "pixel_data_handlers", "if", "hh", "supports_transfer_syntax", "transfer_syntax", "no", "handlers", "support", "the", "transfer", "syntax", "if", "not", "possible_handlers", "raise", "notimplementederror", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "0", "1", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "that", "support", "it", "please", "see", "the", "pydicom", "documentation", "for", "information", "on", "supported", "transfer", "syntaxes", "format", "self", "file_meta", "transfersyntaxuid", "self", "file_meta", "transfersyntaxuid", "name", "handlers", "that", "both", "support", "the", "transfer", "syntax", "and", "have", "their", "dependencies", "met", "available_handlers", "hh", "for", "hh", "in", "possible_handlers", "if", "hh", "is_available", "there", "are", "handlers", "that", "support", "the", "transfer", "syntax", "but", "none", "of", "them", "can", "be", "used", "as", "missing", "dependencies", "if", "not", "available_handlers", "for", "each", "of", "the", "possible", "handlers", "we", "want", "to", "find", "which", "dependencies", "are", "missing", "msg", "the", "following", "handlers", "are", "available", "to", "decode", "the", "pixel", "data", "however", "they", "are", "missing", "required", "dependencies", "pkg_msg", "for", "hh", "in", "possible_handlers", "hh_deps", "hh", "dependencies", "missing", "packages", "missing", "dd", "for", "dd", "in", "hh_deps", "if", "have_package", "dd", "is", "none", "package", "names", "names", "hh_deps", "name", "1", "for", "name", "in", "missing", "pkg_msg", "append", "req", "format", "hh", "handler_name", "join", "names", "raise", "runtimeerror", "msg", "join", "pkg_msg", "last_exception", "none", "for", "handler", "in", "available_handlers", "try", "use", "the", "handler", "to", "get", "a", "1d", "numpy", "array", "of", "the", "pixel", "data", "arr", "handler", "get_pixeldata", "self", "self", "_pixel_array", "reshape_pixel_array", "self", "arr", "some", "handler", "transfer", "syntax", "combinations", "may", "need", "to", "convert", "the", "color", "space", "from", "ycbcr", "to", "rgb", "if", "handler", "needs_to_convert_to_rgb", "self", "self", "_pixel_array", "convert_color_space", "self", "_pixel_array", "ybr_full", "rgb", "self", "_pixel_id", "id", "self", "pixeldata", "return", "except", "exception", "as", "exc", "logger", "debug", "exception", "raised", "by", "pixel", "data", "handler", "exc_info", "exc", "last_exception", "exc", "the", "only", "way", "to", "get", "to", "this", "point", "is", "if", "we", "failed", "to", "get", "the", "pixel", "array", "because", "all", "suitable", "handlers", "raised", "exceptions", "self", "_pixel_array", "none", "self", "_pixel_id", "none", "logger", "info", "unable", "to", "decode", "the", "pixel", "data", "using", "the", "following", "handlers", "please", "see", "the", "list", "of", "supported", "transfer", "syntaxes", "in", "the", "pydicom", "documentation", "for", "alternative", "packages", "that", "might", "be", "able", "to", "decode", "the", "data", "format", "join", "str", "hh", "for", "hh", "in", "available_handlers", "raise", "last_exception"], "doc_len": 440}
{"doc_id": "pydicom/dataset.py::Dataset.decompress", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "decompress", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def decompress(self):\n        \"\"\"Decompresses pixel data and modifies the Dataset in-place\n\n        If not a compressed tranfer syntax, then pixel data is converted\n        to a numpy array internally, but not returned.\n\n        If compressed pixel data, then is decompressed using an image handler,\n        and internal state is updated appropriately:\n            - TransferSyntax is updated to non-compressed form\n            - is_undefined_length for pixel data is set False\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        NotImplementedError\n            If the pixel data was originally compressed but file is not\n            ExplicitVR LittleEndian as required by Dicom standard\n        \"\"\"\n        self.convert_pixel_data()\n        self.is_decompressed = True\n        # May have been undefined length pixel data, but won't be now\n        if 'PixelData' in self:\n            self[0x7fe00010].is_undefined_length = False\n\n        # Make sure correct Transfer Syntax is set\n        # According to the dicom standard PS3.5 section A.4,\n        # all compressed files must have been explicit VR, little endian\n        # First check if was a compressed file\n        if (hasattr(self, 'file_meta') and\n                self.file_meta.TransferSyntaxUID.is_compressed):\n            # Check that current file as read does match expected\n            if not self.is_little_endian or self.is_implicit_VR:\n                msg = (\"Current dataset does not match expected ExplicitVR \"\n                       \"LittleEndian transfer syntax from a compressed \"\n                       \"transfer syntax\")\n                raise NotImplementedError(msg)\n\n            # All is as expected, updated the Transfer Syntax\n            self.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "decompress", "self", "decompresses", "pixel", "data", "and", "modifies", "the", "dataset", "in", "place", "if", "not", "a", "compressed", "tranfer", "syntax", "then", "pixel", "data", "is", "converted", "to", "a", "numpy", "array", "internally", "but", "not", "returned", "if", "compressed", "pixel", "data", "then", "is", "decompressed", "using", "an", "image", "handler", "and", "internal", "state", "is", "updated", "appropriately", "transfersyntax", "is", "updated", "to", "non", "compressed", "form", "is_undefined_length", "for", "pixel", "data", "is", "set", "false", "returns", "none", "raises", "notimplementederror", "if", "the", "pixel", "data", "was", "originally", "compressed", "but", "file", "is", "not", "explicitvr", "littleendian", "as", "required", "by", "dicom", "standard", "self", "convert_pixel_data", "self", "is_decompressed", "true", "may", "have", "been", "undefined", "length", "pixel", "data", "but", "won", "t", "be", "now", "if", "pixeldata", "in", "self", "self", "0x7fe00010", "is_undefined_length", "false", "make", "sure", "correct", "transfer", "syntax", "is", "set", "according", "to", "the", "dicom", "standard", "ps3", "5", "section", "a", "4", "all", "compressed", "files", "must", "have", "been", "explicit", "vr", "little", "endian", "first", "check", "if", "was", "a", "compressed", "file", "if", "hasattr", "self", "file_meta", "and", "self", "file_meta", "transfersyntaxuid", "is_compressed", "check", "that", "current", "file", "as", "read", "does", "match", "expected", "if", "not", "self", "is_little_endian", "or", "self", "is_implicit_vr", "msg", "current", "dataset", "does", "not", "match", "expected", "explicitvr", "littleendian", "transfer", "syntax", "from", "a", "compressed", "transfer", "syntax", "raise", "notimplementederror", "msg", "all", "is", "as", "expected", "updated", "the", "transfer", "syntax", "self", "file_meta", "transfersyntaxuid", "explicitvrlittleendian"], "doc_len": 203}
{"doc_id": "pydicom/dataset.py::Dataset.pixel_array", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "pixel_array", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def pixel_array(self):\n        \"\"\"Return the Pixel Data as a NumPy array.\n\n        Returns\n        -------\n        numpy.ndarray\n            The Pixel Data (7FE0,0010) as a NumPy ndarray.\n        \"\"\"\n        self.convert_pixel_data()\n        return self._pixel_array\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "pixel_array", "self", "return", "the", "pixel", "data", "as", "a", "numpy", "array", "returns", "numpy", "ndarray", "the", "pixel", "data", "7fe0", "0010", "as", "a", "numpy", "ndarray", "self", "convert_pixel_data", "return", "self", "_pixel_array"], "doc_len": 32}
{"doc_id": "pydicom/dataset.py::Dataset.formatted_lines", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "formatted_lines", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def formatted_lines(\n            self,\n            element_format=default_element_format,\n            sequence_element_format=default_sequence_element_format,\n            indent_format=None):\n        \"\"\"Iterate through the Dataset yielding formatted str for each element.\n\n        Parameters\n        ----------\n        element_format : str\n            The string format to use for non-sequence elements. Formatting uses\n            the attributes of DataElement. Default is\n            \"%(tag)s %(name)-35.35s %(VR)s: %(repval)s\".\n        sequence_element_format : str\n            The string format to use for sequence elements. Formatting uses\n            the attributes of DataElement. Default is\n            \"%(tag)s %(name)-35.35s %(VR)s: %(repval)s\"\n        indent_format : str or None\n            Placeholder for future functionality.\n\n        Yields\n        ------\n        str\n            A string representation of a DataElement.\n        \"\"\"\n        for data_element in self.iterall():\n            # Get all the attributes possible for this data element (e.g.\n            #   gets descriptive text name too)\n            # This is the dictionary of names that can be used in the format\n            #   string\n            elem_dict = dict([(x, getattr(data_element, x)()\n                               if callable(getattr(data_element, x)) else\n                               getattr(data_element, x))\n                              for x in dir(data_element)\n                              if not x.startswith(\"_\")\n                              and x != \"from_json\"])\n            if data_element.VR == \"SQ\":\n                yield sequence_element_format % elem_dict\n            else:\n                yield element_format % elem_dict\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "formatted_lines", "self", "element_format", "default_element_format", "sequence_element_format", "default_sequence_element_format", "indent_format", "none", "iterate", "through", "the", "dataset", "yielding", "formatted", "str", "for", "each", "element", "parameters", "element_format", "str", "the", "string", "format", "to", "use", "for", "non", "sequence", "elements", "formatting", "uses", "the", "attributes", "of", "dataelement", "default", "is", "tag", "s", "name", "35", "35s", "vr", "s", "repval", "s", "sequence_element_format", "str", "the", "string", "format", "to", "use", "for", "sequence", "elements", "formatting", "uses", "the", "attributes", "of", "dataelement", "default", "is", "tag", "s", "name", "35", "35s", "vr", "s", "repval", "s", "indent_format", "str", "or", "none", "placeholder", "for", "future", "functionality", "yields", "str", "a", "string", "representation", "of", "a", "dataelement", "for", "data_element", "in", "self", "iterall", "get", "all", "the", "attributes", "possible", "for", "this", "data", "element", "e", "g", "gets", "descriptive", "text", "name", "too", "this", "is", "the", "dictionary", "of", "names", "that", "can", "be", "used", "in", "the", "format", "string", "elem_dict", "dict", "x", "getattr", "data_element", "x", "if", "callable", "getattr", "data_element", "x", "else", "getattr", "data_element", "x", "for", "x", "in", "dir", "data_element", "if", "not", "x", "startswith", "_", "and", "x", "from_json", "if", "data_element", "vr", "sq", "yield", "sequence_element_format", "elem_dict", "else", "yield", "element_format", "elem_dict"], "doc_len": 169}
{"doc_id": "pydicom/dataset.py::Dataset._pretty_str", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_pretty_str", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _pretty_str(self, indent=0, top_level_only=False):\n        \"\"\"Return a string of the DataElements in the Dataset, with indented\n        levels.\n\n        This private method is called by the __str__() method for handling\n        print statements or str(dataset), and the __repr__() method.\n        It is also used by top(), therefore the top_level_only flag.\n        This function recurses, with increasing indentation levels.\n\n        Parameters\n        ----------\n        indent : int\n            The indent level offset (default 0)\n        top_level_only : bool\n            When True, only create a string for the top level elements, i.e.\n            exclude elements within any Sequences (default False).\n\n        Returns\n        -------\n        str\n            A string representation of the Dataset.\n        \"\"\"\n        strings = []\n        indent_str = self.indent_chars * indent\n        nextindent_str = self.indent_chars * (indent + 1)\n        for data_element in self:\n            with tag_in_exception(data_element.tag):\n                if data_element.VR == \"SQ\":  # a sequence\n                    strings.append(indent_str + str(data_element.tag) +\n                                   \"  %s   %i item(s) ---- \" %\n                                   (data_element.description(),\n                                    len(data_element.value)))\n                    if not top_level_only:\n                        for dataset in data_element.value:\n                            strings.append(dataset._pretty_str(indent + 1))\n                            strings.append(nextindent_str + \"---------\")\n                else:\n                    strings.append(indent_str + repr(data_element))\n        return \"\\n\".join(strings)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_pretty_str", "self", "indent", "0", "top_level_only", "false", "return", "a", "string", "of", "the", "dataelements", "in", "the", "dataset", "with", "indented", "levels", "this", "private", "method", "is", "called", "by", "the", "__str__", "method", "for", "handling", "print", "statements", "or", "str", "dataset", "and", "the", "__repr__", "method", "it", "is", "also", "used", "by", "top", "therefore", "the", "top_level_only", "flag", "this", "function", "recurses", "with", "increasing", "indentation", "levels", "parameters", "indent", "int", "the", "indent", "level", "offset", "default", "0", "top_level_only", "bool", "when", "true", "only", "create", "a", "string", "for", "the", "top", "level", "elements", "i", "e", "exclude", "elements", "within", "any", "sequences", "default", "false", "returns", "str", "a", "string", "representation", "of", "the", "dataset", "strings", "indent_str", "self", "indent_chars", "indent", "nextindent_str", "self", "indent_chars", "indent", "1", "for", "data_element", "in", "self", "with", "tag_in_exception", "data_element", "tag", "if", "data_element", "vr", "sq", "a", "sequence", "strings", "append", "indent_str", "str", "data_element", "tag", "s", "i", "item", "s", "data_element", "description", "len", "data_element", "value", "if", "not", "top_level_only", "for", "dataset", "in", "data_element", "value", "strings", "append", "dataset", "_pretty_str", "indent", "1", "strings", "append", "nextindent_str", "else", "strings", "append", "indent_str", "repr", "data_element", "return", "n", "join", "strings"], "doc_len": 165}
{"doc_id": "pydicom/dataset.py::Dataset.remove_private_tags", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "remove_private_tags", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def remove_private_tags(self):\n        \"\"\"Remove all private DataElements in the Dataset.\"\"\"\n\n        def RemoveCallback(dataset, data_element):\n            \"\"\"Internal method to use as callback to walk() method.\"\"\"\n            if data_element.tag.is_private:\n                # can't del self[tag] - won't be right dataset on recursion\n                del dataset[data_element.tag]\n\n        self.walk(RemoveCallback)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "remove_private_tags", "self", "remove", "all", "private", "dataelements", "in", "the", "dataset", "def", "removecallback", "dataset", "data_element", "internal", "method", "to", "use", "as", "callback", "to", "walk", "method", "if", "data_element", "tag", "is_private", "can", "t", "del", "self", "tag", "won", "t", "be", "right", "dataset", "on", "recursion", "del", "dataset", "data_element", "tag", "self", "walk", "removecallback"], "doc_len": 50}
{"doc_id": "pydicom/dataset.py::Dataset.save_as", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "save_as", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def save_as(self, filename, write_like_original=True):\n        \"\"\"Write the Dataset to `filename`.\n\n        Saving a Dataset requires that the Dataset.is_implicit_VR and\n        Dataset.is_little_endian attributes exist and are set appropriately. If\n        Dataset.file_meta.TransferSyntaxUID is present then it should be set to\n        a consistent value to ensure conformance.\n\n        Conformance with DICOM File Format\n        ----------------------------------\n        If `write_like_original` is False, the Dataset will be stored in the\n        DICOM File Format in accordance with DICOM Standard Part 10 Section 7.\n        To do so requires that the `Dataset.file_meta` attribute exists and\n        contains a Dataset with the required (Type 1) File Meta Information\n        Group elements (see pydicom.filewriter.dcmwrite and\n        pydicom.filewriter.write_file_meta_info for more information).\n\n        If `write_like_original` is True then the Dataset will be written as is\n        (after minimal validation checking) and may or may not contain all or\n        parts of the File Meta Information (and hence may or may not be\n        conformant with the DICOM File Format).\n\n        Parameters\n        ----------\n        filename : str or file-like\n            Name of file or the file-like to write the new DICOM file to.\n        write_like_original : bool\n            If True (default), preserves the following information from\n            the Dataset (and may result in a non-conformant file):\n            - preamble -- if the original file has no preamble then none will\n                be written.\n            - file_meta -- if the original file was missing any required File\n                Meta Information Group elements then they will not be added or\n                written.\n                If (0002,0000) 'File Meta Information Group Length' is present\n                then it may have its value updated.\n            - seq.is_undefined_length -- if original had delimiters, write them\n                now too, instead of the more sensible length characters\n            - is_undefined_length_sequence_item -- for datasets that belong to\n                a sequence, write the undefined length delimiters if that is\n                what the original had.\n            If False, produces a file conformant with the DICOM File Format,\n            with explicit lengths for all elements.\n\n        See Also\n        --------\n        pydicom.filewriter.write_dataset\n            Write a DICOM Dataset to a file.\n        pydicom.filewriter.write_file_meta_info\n            Write the DICOM File Meta Information Group elements to a file.\n        pydicom.filewriter.dcmwrite\n            Write a DICOM file from a FileDataset instance.\n        \"\"\"\n        # Ensure is_little_endian and is_implicit_VR are set\n        if self.is_little_endian is None or self.is_implicit_VR is None:\n            raise AttributeError(\n                \"'{0}.is_little_endian' and '{0}.is_implicit_VR' must be \"\n                \"set appropriately before saving.\".format(\n                    self.__class__.__name__))\n\n        pydicom.dcmwrite(filename, self, write_like_original)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "save_as", "self", "filename", "write_like_original", "true", "write", "the", "dataset", "to", "filename", "saving", "a", "dataset", "requires", "that", "the", "dataset", "is_implicit_vr", "and", "dataset", "is_little_endian", "attributes", "exist", "and", "are", "set", "appropriately", "if", "dataset", "file_meta", "transfersyntaxuid", "is", "present", "then", "it", "should", "be", "set", "to", "a", "consistent", "value", "to", "ensure", "conformance", "conformance", "with", "dicom", "file", "format", "if", "write_like_original", "is", "false", "the", "dataset", "will", "be", "stored", "in", "the", "dicom", "file", "format", "in", "accordance", "with", "dicom", "standard", "part", "10", "section", "7", "to", "do", "so", "requires", "that", "the", "dataset", "file_meta", "attribute", "exists", "and", "contains", "a", "dataset", "with", "the", "required", "type", "1", "file", "meta", "information", "group", "elements", "see", "pydicom", "filewriter", "dcmwrite", "and", "pydicom", "filewriter", "write_file_meta_info", "for", "more", "information", "if", "write_like_original", "is", "true", "then", "the", "dataset", "will", "be", "written", "as", "is", "after", "minimal", "validation", "checking", "and", "may", "or", "may", "not", "contain", "all", "or", "parts", "of", "the", "file", "meta", "information", "and", "hence", "may", "or", "may", "not", "be", "conformant", "with", "the", "dicom", "file", "format", "parameters", "filename", "str", "or", "file", "like", "name", "of", "file", "or", "the", "file", "like", "to", "write", "the", "new", "dicom", "file", "to", "write_like_original", "bool", "if", "true", "default", "preserves", "the", "following", "information", "from", "the", "dataset", "and", "may", "result", "in", "a", "non", "conformant", "file", "preamble", "if", "the", "original", "file", "has", "no", "preamble", "then", "none", "will", "be", "written", "file_meta", "if", "the", "original", "file", "was", "missing", "any", "required", "file", "meta", "information", "group", "elements", "then", "they", "will", "not", "be", "added", "or", "written", "if", "0002", "0000", "file", "meta", "information", "group", "length", "is", "present", "then", "it", "may", "have", "its", "value", "updated", "seq", "is_undefined_length", "if", "original", "had", "delimiters", "write", "them", "now", "too", "instead", "of", "the", "more", "sensible", "length", "characters", "is_undefined_length_sequence_item", "for", "datasets", "that", "belong", "to", "a", "sequence", "write", "the", "undefined", "length", "delimiters", "if", "that", "is", "what", "the", "original", "had", "if", "false", "produces", "a", "file", "conformant", "with", "the", "dicom", "file", "format", "with", "explicit", "lengths", "for", "all", "elements", "see", "also", "pydicom", "filewriter", "write_dataset", "write", "a", "dicom", "dataset", "to", "a", "file", "pydicom", "filewriter", "write_file_meta_info", "write", "the", "dicom", "file", "meta", "information", "group", "elements", "to", "a", "file", "pydicom", "filewriter", "dcmwrite", "write", "a", "dicom", "file", "from", "a", "filedataset", "instance", "ensure", "is_little_endian", "and", "is_implicit_vr", "are", "set", "if", "self", "is_little_endian", "is", "none", "or", "self", "is_implicit_vr", "is", "none", "raise", "attributeerror", "0", "is_little_endian", "and", "0", "is_implicit_vr", "must", "be", "set", "appropriately", "before", "saving", "format", "self", "__class__", "__name__", "pydicom", "dcmwrite", "filename", "self", "write_like_original"], "doc_len": 377}
{"doc_id": "pydicom/dataset.py::Dataset.ensure_file_meta", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "ensure_file_meta", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def ensure_file_meta(self):\n        \"\"\"Create an empty file meta dataset if none exists.\"\"\"\n        self.file_meta = getattr(self, 'file_meta', Dataset())\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "ensure_file_meta", "self", "create", "an", "empty", "file", "meta", "dataset", "if", "none", "exists", "self", "file_meta", "getattr", "self", "file_meta", "dataset"], "doc_len": 22}
{"doc_id": "pydicom/dataset.py::Dataset.fix_meta_info", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "fix_meta_info", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def fix_meta_info(self, enforce_standard=True):\n        \"\"\"Ensure the file meta info exists and has the correct values\n        for transfer syntax and media storage uids.\n\n        .. warning::\n\n            The transfer syntax for is_implicit_VR = False and\n            is_little_endian = True is ambiguous and will therefore not be set.\n\n        Parameters\n        ----------\n        enforce_standard : boolean\n            If True, a check for incorrect and missing elements is performed.\n            (see pydicom.filewriter.validate_file_meta)\n\n        \"\"\"\n        self.ensure_file_meta()\n\n        if self.is_little_endian and self.is_implicit_VR:\n            self.file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        elif not self.is_little_endian and not self.is_implicit_VR:\n            self.file_meta.TransferSyntaxUID = ExplicitVRBigEndian\n        elif not self.is_little_endian and self.is_implicit_VR:\n            raise NotImplementedError(\"Implicit VR Big Endian is not a \"\n                                      \"supported Transfer Syntax.\")\n\n        if 'SOPClassUID' in self:\n            self.file_meta.MediaStorageSOPClassUID = self.SOPClassUID\n        if 'SOPInstanceUID' in self:\n            self.file_meta.MediaStorageSOPInstanceUID = self.SOPInstanceUID\n        if enforce_standard:\n            validate_file_meta(self.file_meta, enforce_standard=True)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "fix_meta_info", "self", "enforce_standard", "true", "ensure", "the", "file", "meta", "info", "exists", "and", "has", "the", "correct", "values", "for", "transfer", "syntax", "and", "media", "storage", "uids", "warning", "the", "transfer", "syntax", "for", "is_implicit_vr", "false", "and", "is_little_endian", "true", "is", "ambiguous", "and", "will", "therefore", "not", "be", "set", "parameters", "enforce_standard", "boolean", "if", "true", "a", "check", "for", "incorrect", "and", "missing", "elements", "is", "performed", "see", "pydicom", "filewriter", "validate_file_meta", "self", "ensure_file_meta", "if", "self", "is_little_endian", "and", "self", "is_implicit_vr", "self", "file_meta", "transfersyntaxuid", "implicitvrlittleendian", "elif", "not", "self", "is_little_endian", "and", "not", "self", "is_implicit_vr", "self", "file_meta", "transfersyntaxuid", "explicitvrbigendian", "elif", "not", "self", "is_little_endian", "and", "self", "is_implicit_vr", "raise", "notimplementederror", "implicit", "vr", "big", "endian", "is", "not", "a", "supported", "transfer", "syntax", "if", "sopclassuid", "in", "self", "self", "file_meta", "mediastoragesopclassuid", "self", "sopclassuid", "if", "sopinstanceuid", "in", "self", "self", "file_meta", "mediastoragesopinstanceuid", "self", "sopinstanceuid", "if", "enforce_standard", "validate_file_meta", "self", "file_meta", "enforce_standard", "true"], "doc_len": 131}
{"doc_id": "pydicom/dataset.py::Dataset.__setattr__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__setattr__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __setattr__(self, name, value):\n        \"\"\"Intercept any attempts to set a value for an instance attribute.\n\n        If name is a DICOM keyword, set the corresponding tag and DataElement.\n        Else, set an instance (python) attribute as any other class would do.\n\n        Parameters\n        ----------\n        name : str\n            The element keyword for the DataElement you wish to add/change. If\n            `name` is not a DICOM element keyword then this will be the\n            name of the attribute to be added/changed.\n        value\n            The value for the attribute to be added/changed.\n        \"\"\"\n        tag = tag_for_keyword(name)\n        if tag is not None:  # successfully mapped name to a tag\n            if tag not in self:\n                # don't have this tag yet->create the data_element instance\n                VR = dictionary_VR(tag)\n                data_element = DataElement(tag, VR, value)\n                if VR == 'SQ':\n                    # let a sequence know its parent dataset to pass it\n                    # to its items, who may need parent dataset tags\n                    # to resolve ambiguous tags\n                    data_element.parent = self\n            else:\n                # already have this data_element, just changing its value\n                data_element = self[tag]\n                data_element.value = value\n            # Now have data_element - store it in this dict\n            self[tag] = data_element\n        elif repeater_has_keyword(name):\n            # Check if `name` is repeaters element\n            raise ValueError('{} is a DICOM repeating group '\n                             'element and must be added using '\n                             'the add() or add_new() methods.'\n                             .format(name))\n        else:\n            # name not in dicom dictionary - setting a non-dicom instance\n            # attribute\n            # XXX note if user mis-spells a dicom data_element - no error!!!\n            object.__setattr__(self, name, value)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__setattr__", "self", "name", "value", "intercept", "any", "attempts", "to", "set", "a", "value", "for", "an", "instance", "attribute", "if", "name", "is", "a", "dicom", "keyword", "set", "the", "corresponding", "tag", "and", "dataelement", "else", "set", "an", "instance", "python", "attribute", "as", "any", "other", "class", "would", "do", "parameters", "name", "str", "the", "element", "keyword", "for", "the", "dataelement", "you", "wish", "to", "add", "change", "if", "name", "is", "not", "a", "dicom", "element", "keyword", "then", "this", "will", "be", "the", "name", "of", "the", "attribute", "to", "be", "added", "changed", "value", "the", "value", "for", "the", "attribute", "to", "be", "added", "changed", "tag", "tag_for_keyword", "name", "if", "tag", "is", "not", "none", "successfully", "mapped", "name", "to", "a", "tag", "if", "tag", "not", "in", "self", "don", "t", "have", "this", "tag", "yet", "create", "the", "data_element", "instance", "vr", "dictionary_vr", "tag", "data_element", "dataelement", "tag", "vr", "value", "if", "vr", "sq", "let", "a", "sequence", "know", "its", "parent", "dataset", "to", "pass", "it", "to", "its", "items", "who", "may", "need", "parent", "dataset", "tags", "to", "resolve", "ambiguous", "tags", "data_element", "parent", "self", "else", "already", "have", "this", "data_element", "just", "changing", "its", "value", "data_element", "self", "tag", "data_element", "value", "value", "now", "have", "data_element", "store", "it", "in", "this", "dict", "self", "tag", "data_element", "elif", "repeater_has_keyword", "name", "check", "if", "name", "is", "repeaters", "element", "raise", "valueerror", "is", "a", "dicom", "repeating", "group", "element", "and", "must", "be", "added", "using", "the", "add", "or", "add_new", "methods", "format", "name", "else", "name", "not", "in", "dicom", "dictionary", "setting", "a", "non", "dicom", "instance", "attribute", "xxx", "note", "if", "user", "mis", "spells", "a", "dicom", "data_element", "no", "error", "object", "__setattr__", "self", "name", "value"], "doc_len": 238}
{"doc_id": "pydicom/dataset.py::Dataset.__setitem__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__setitem__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __setitem__(self, key, value):\n        \"\"\"Operator for Dataset[key] = value.\n\n        Check consistency, and deal with private tags.\n\n        Parameters\n        ----------\n        key : int\n            The tag for the element to be added to the Dataset.\n        value : pydicom.dataelem.DataElement or pydicom.dataelem.RawDataElement\n            The element to add to the Dataset.\n\n        Raises\n        ------\n        NotImplementedError\n            If `key` is a slice.\n        ValueError\n            If the `key` value doesn't match DataElement.tag.\n        \"\"\"\n        if isinstance(key, slice):\n            raise NotImplementedError('Slicing is not supported for setting '\n                                      'Dataset elements.')\n\n        # OK if is subclass, e.g. DeferredDataElement\n        if not isinstance(value, (DataElement, RawDataElement)):\n            raise TypeError(\"Dataset contents must be DataElement instances.\")\n        if isinstance(value.tag, BaseTag):\n            tag = value.tag\n        else:\n            tag = Tag(value.tag)\n        if key != tag:\n            raise ValueError(\"DataElement.tag must match the dictionary key\")\n\n        data_element = value\n        if tag.is_private:\n            # See PS 3.5-2008 section 7.8.1 (p. 44) for how blocks are reserved\n            logger.debug(\"Setting private tag %r\" % tag)\n            private_block = tag.elem >> 8\n            private_creator_tag = Tag(tag.group, private_block)\n            if private_creator_tag in self and tag != private_creator_tag:\n                if data_element.is_raw:\n                    data_element = DataElement_from_raw(\n                        data_element, self._character_set)\n                data_element.private_creator = self[private_creator_tag].value\n        self._dict[tag] = data_element\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__setitem__", "self", "key", "value", "operator", "for", "dataset", "key", "value", "check", "consistency", "and", "deal", "with", "private", "tags", "parameters", "key", "int", "the", "tag", "for", "the", "element", "to", "be", "added", "to", "the", "dataset", "value", "pydicom", "dataelem", "dataelement", "or", "pydicom", "dataelem", "rawdataelement", "the", "element", "to", "add", "to", "the", "dataset", "raises", "notimplementederror", "if", "key", "is", "a", "slice", "valueerror", "if", "the", "key", "value", "doesn", "t", "match", "dataelement", "tag", "if", "isinstance", "key", "slice", "raise", "notimplementederror", "slicing", "is", "not", "supported", "for", "setting", "dataset", "elements", "ok", "if", "is", "subclass", "e", "g", "deferreddataelement", "if", "not", "isinstance", "value", "dataelement", "rawdataelement", "raise", "typeerror", "dataset", "contents", "must", "be", "dataelement", "instances", "if", "isinstance", "value", "tag", "basetag", "tag", "value", "tag", "else", "tag", "tag", "value", "tag", "if", "key", "tag", "raise", "valueerror", "dataelement", "tag", "must", "match", "the", "dictionary", "key", "data_element", "value", "if", "tag", "is_private", "see", "ps", "3", "5", "2008", "section", "7", "8", "1", "p", "44", "for", "how", "blocks", "are", "reserved", "logger", "debug", "setting", "private", "tag", "r", "tag", "private_block", "tag", "elem", "8", "private_creator_tag", "tag", "tag", "group", "private_block", "if", "private_creator_tag", "in", "self", "and", "tag", "private_creator_tag", "if", "data_element", "is_raw", "data_element", "dataelement_from_raw", "data_element", "self", "_character_set", "data_element", "private_creator", "self", "private_creator_tag", "value", "self", "_dict", "tag", "data_element"], "doc_len": 188}
{"doc_id": "pydicom/dataset.py::Dataset._slice_dataset", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_slice_dataset", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _slice_dataset(self, start, stop, step):\n        \"\"\"Return the element tags in the Dataset that match the slice.\n\n        Parameters\n        ----------\n        start : int or 2-tuple of int or None\n            The slice's starting element tag value, in any format accepted by\n            pydicom.tag.Tag.\n        stop : int or 2-tuple of int or None\n            The slice's stopping element tag value, in any format accepted by\n            pydicom.tag.Tag.\n        step : int or None\n            The slice's step size.\n\n        Returns\n        ------\n        list of pydicom.tag.Tag\n            The tags in the Dataset that meet the conditions of the slice.\n        \"\"\"\n        # Check the starting/stopping Tags are valid when used\n        if start is not None:\n            start = Tag(start)\n        if stop is not None:\n            stop = Tag(stop)\n\n        all_tags = sorted(self._dict.keys())\n        # If the Dataset is empty, return an empty list\n        if not all_tags:\n            return []\n\n        # Special case the common situations:\n        #   - start and/or stop are None\n        #   - step is 1\n\n        if start is None:\n            if stop is None:\n                # For step=1 avoid copying the list\n                return all_tags if step == 1 else all_tags[::step]\n            else:  # Have a stop value, get values until that point\n                step1_list = list(takewhile(lambda x: x < stop, all_tags))\n                return step1_list if step == 1 else step1_list[::step]\n\n        # Have a non-None start value.  Find its index\n        i_start = bisect_left(all_tags, start)\n        if stop is None:\n            return all_tags[i_start::step]\n        else:\n            i_stop = bisect_left(all_tags, stop)\n            return all_tags[i_start:i_stop:step]\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_slice_dataset", "self", "start", "stop", "step", "return", "the", "element", "tags", "in", "the", "dataset", "that", "match", "the", "slice", "parameters", "start", "int", "or", "2", "tuple", "of", "int", "or", "none", "the", "slice", "s", "starting", "element", "tag", "value", "in", "any", "format", "accepted", "by", "pydicom", "tag", "tag", "stop", "int", "or", "2", "tuple", "of", "int", "or", "none", "the", "slice", "s", "stopping", "element", "tag", "value", "in", "any", "format", "accepted", "by", "pydicom", "tag", "tag", "step", "int", "or", "none", "the", "slice", "s", "step", "size", "returns", "list", "of", "pydicom", "tag", "tag", "the", "tags", "in", "the", "dataset", "that", "meet", "the", "conditions", "of", "the", "slice", "check", "the", "starting", "stopping", "tags", "are", "valid", "when", "used", "if", "start", "is", "not", "none", "start", "tag", "start", "if", "stop", "is", "not", "none", "stop", "tag", "stop", "all_tags", "sorted", "self", "_dict", "keys", "if", "the", "dataset", "is", "empty", "return", "an", "empty", "list", "if", "not", "all_tags", "return", "special", "case", "the", "common", "situations", "start", "and", "or", "stop", "are", "none", "step", "is", "1", "if", "start", "is", "none", "if", "stop", "is", "none", "for", "step", "1", "avoid", "copying", "the", "list", "return", "all_tags", "if", "step", "1", "else", "all_tags", "step", "else", "have", "a", "stop", "value", "get", "values", "until", "that", "point", "step1_list", "list", "takewhile", "lambda", "x", "x", "stop", "all_tags", "return", "step1_list", "if", "step", "1", "else", "step1_list", "step", "have", "a", "non", "none", "start", "value", "find", "its", "index", "i_start", "bisect_left", "all_tags", "start", "if", "stop", "is", "none", "return", "all_tags", "i_start", "step", "else", "i_stop", "bisect_left", "all_tags", "stop", "return", "all_tags", "i_start", "i_stop", "step"], "doc_len": 234}
{"doc_id": "pydicom/dataset.py::Dataset.__str__", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "__str__", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def __str__(self):\n        \"\"\"Handle str(dataset).\"\"\"\n        return self._pretty_str()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "__str__", "self", "handle", "str", "dataset", "return", "self", "_pretty_str"], "doc_len": 13}
{"doc_id": "pydicom/dataset.py::Dataset.top", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "top", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def top(self):\n        \"\"\"Return a str of the Dataset's top level DataElements only.\"\"\"\n        return self._pretty_str(top_level_only=True)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "top", "self", "return", "a", "str", "of", "the", "dataset", "s", "top", "level", "dataelements", "only", "return", "self", "_pretty_str", "top_level_only", "true"], "doc_len": 23}
{"doc_id": "pydicom/dataset.py::Dataset.trait_names", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "trait_names", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def trait_names(self):\n        \"\"\"Return a list of valid names for auto-completion code.\n\n        Used in IPython, so that data element names can be found and offered\n        for autocompletion on the IPython command line.\n        \"\"\"\n        return dir(self)  # only valid python >=2.6, else use self.__dir__()\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "trait_names", "self", "return", "a", "list", "of", "valid", "names", "for", "auto", "completion", "code", "used", "in", "ipython", "so", "that", "data", "element", "names", "can", "be", "found", "and", "offered", "for", "autocompletion", "on", "the", "ipython", "command", "line", "return", "dir", "self", "only", "valid", "python", "2", "6", "else", "use", "self", "__dir__"], "doc_len": 49}
{"doc_id": "pydicom/dataset.py::Dataset.update", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "update", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def update(self, dictionary):\n        \"\"\"Extend dict.update() to handle DICOM keywords.\n\n        Parameters\n        ----------\n        dictionary : dict or Dataset\n            The dict or Dataset to use when updating the current object.\n        \"\"\"\n        for key, value in list(dictionary.items()):\n            if isinstance(key, (str, compat.text_type)):\n                setattr(self, key, value)\n            else:\n                self[Tag(key)] = value\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "update", "self", "dictionary", "extend", "dict", "update", "to", "handle", "dicom", "keywords", "parameters", "dictionary", "dict", "or", "dataset", "the", "dict", "or", "dataset", "to", "use", "when", "updating", "the", "current", "object", "for", "key", "value", "in", "list", "dictionary", "items", "if", "isinstance", "key", "str", "compat", "text_type", "setattr", "self", "key", "value", "else", "self", "tag", "key", "value"], "doc_len": 53}
{"doc_id": "pydicom/dataset.py::Dataset.iterall", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "iterall", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def iterall(self):\n        \"\"\"Iterate through the Dataset, yielding all DataElements.\n\n        Unlike Dataset.__iter__, this *does* recurse into sequences,\n        and so returns all data elements as if the file were \"flattened\".\n\n        Yields\n        ------\n        pydicom.dataelem.DataElement\n        \"\"\"\n        for data_element in self:\n            yield data_element\n            if data_element.VR == \"SQ\":\n                sequence = data_element.value\n                for dataset in sequence:\n                    for elem in dataset.iterall():\n                        yield elem\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "iterall", "self", "iterate", "through", "the", "dataset", "yielding", "all", "dataelements", "unlike", "dataset", "__iter__", "this", "does", "recurse", "into", "sequences", "and", "so", "returns", "all", "data", "elements", "as", "if", "the", "file", "were", "flattened", "yields", "pydicom", "dataelem", "dataelement", "for", "data_element", "in", "self", "yield", "data_element", "if", "data_element", "vr", "sq", "sequence", "data_element", "value", "for", "dataset", "in", "sequence", "for", "elem", "in", "dataset", "iterall", "yield", "elem"], "doc_len": 62}
{"doc_id": "pydicom/dataset.py::Dataset.walk", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "walk", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def walk(self, callback, recursive=True):\n        \"\"\"Iterate through the DataElements and run `callback` on each.\n\n        Visit all DataElements, possibly recursing into sequences and their\n        datasets. The callback function is called for each DataElement\n        (including SQ element). Can be used to perform an operation on certain\n        types of DataElements. E.g., `remove_private_tags`() finds all private\n        tags and deletes them. DataElement`s will come back in DICOM order (by\n        increasing tag number within their dataset).\n\n        Parameters\n        ----------\n        callback\n            A callable that takes two arguments:\n                * a Dataset\n                * a DataElement belonging to that Dataset\n        recursive : bool\n            Flag to indicate whether to recurse into Sequences.\n        \"\"\"\n        taglist = sorted(self._dict.keys())\n        for tag in taglist:\n\n            with tag_in_exception(tag):\n                data_element = self[tag]\n                callback(self, data_element)  # self = this Dataset\n                # 'tag in self' below needed in case callback deleted\n                # data_element\n                if recursive and tag in self and data_element.VR == \"SQ\":\n                    sequence = data_element.value\n                    for dataset in sequence:\n                        dataset.walk(callback)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "walk", "self", "callback", "recursive", "true", "iterate", "through", "the", "dataelements", "and", "run", "callback", "on", "each", "visit", "all", "dataelements", "possibly", "recursing", "into", "sequences", "and", "their", "datasets", "the", "callback", "function", "is", "called", "for", "each", "dataelement", "including", "sq", "element", "can", "be", "used", "to", "perform", "an", "operation", "on", "certain", "types", "of", "dataelements", "e", "g", "remove_private_tags", "finds", "all", "private", "tags", "and", "deletes", "them", "dataelement", "s", "will", "come", "back", "in", "dicom", "order", "by", "increasing", "tag", "number", "within", "their", "dataset", "parameters", "callback", "a", "callable", "that", "takes", "two", "arguments", "a", "dataset", "a", "dataelement", "belonging", "to", "that", "dataset", "recursive", "bool", "flag", "to", "indicate", "whether", "to", "recurse", "into", "sequences", "taglist", "sorted", "self", "_dict", "keys", "for", "tag", "in", "taglist", "with", "tag_in_exception", "tag", "data_element", "self", "tag", "callback", "self", "data_element", "self", "this", "dataset", "tag", "in", "self", "below", "needed", "in", "case", "callback", "deleted", "data_element", "if", "recursive", "and", "tag", "in", "self", "and", "data_element", "vr", "sq", "sequence", "data_element", "value", "for", "dataset", "in", "sequence", "dataset", "walk", "callback"], "doc_len": 154}
{"doc_id": "pydicom/dataset.py::Dataset._convert_to_python_number", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_convert_to_python_number", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _convert_to_python_number(cls, value, vr):\n        \"\"\"Makes sure that values are either ints or floats\n        based on their value representation.\n\n        Parameters\n        ----------\n        value: Union[Union[str, int, float], List[Union[str, int, float]]]\n            value of data element\n        vr: str\n            value representation of data element\n\n        Returns\n        -------\n        Union[Union[str, int, float], List[Union[str, int, float]]]\n\n        \"\"\"\n        if value is None:\n            return None\n        number_type = None\n        if vr in cls._VRs_TO_BE_INTS:\n            number_type = int\n        if vr in cls._VRs_TO_BE_FLOATS:\n            number_type = float\n        if number_type is not None:\n            if isinstance(value, (list, tuple, )):\n                value = [number_type(e) for e in value]\n            else:\n                value = number_type(value)\n        return value\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_convert_to_python_number", "cls", "value", "vr", "makes", "sure", "that", "values", "are", "either", "ints", "or", "floats", "based", "on", "their", "value", "representation", "parameters", "value", "union", "union", "str", "int", "float", "list", "union", "str", "int", "float", "value", "of", "data", "element", "vr", "str", "value", "representation", "of", "data", "element", "returns", "union", "union", "str", "int", "float", "list", "union", "str", "int", "float", "if", "value", "is", "none", "return", "none", "number_type", "none", "if", "vr", "in", "cls", "_vrs_to_be_ints", "number_type", "int", "if", "vr", "in", "cls", "_vrs_to_be_floats", "number_type", "float", "if", "number_type", "is", "not", "none", "if", "isinstance", "value", "list", "tuple", "value", "number_type", "e", "for", "e", "in", "value", "else", "value", "number_type", "value", "return", "value"], "doc_len": 102}
{"doc_id": "pydicom/dataset.py::Dataset.from_json", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "from_json", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def from_json(cls, json_dataset, bulk_data_uri_handler=None,\n                  encodings=None):\n        \"\"\"Loads DICOM Data Set in DICOM JSON format.\n        See:\n        http://dicom.nema.org/medical/dicom/current/output/chtml/part18/chapter_F.html\n\n        Parameters\n        ----------\n        json_dataset: Union[dict, str]\n            dictionary or string representing a DICOM Data Set formatted based\n            on the DICOM JSON Model (Annex F)\n        bulk_data_uri_handler: Union[Callable, None]\n            callable that accepts the \"BulkDataURI\" of the JSON representation\n            of a data element and returns the actual value of data element\n            (retrieved via DICOMweb WADO-RS)\n        encodings: Union[list, None]\n            encodings from SpecificCharacterSet, or None for default\n        Returns\n        -------\n        pydicom.dataset.Dataset\n\n        \"\"\"\n        if not isinstance(json_dataset, dict):\n            json_dataset = json.loads(json_dataset)\n        dataset = cls()\n        for tag, mapping in json_dataset.items():\n            vr = mapping['vr']\n            unique_value_keys = tuple(\n                set(mapping.keys()) & set(cls._JSON_VALUE_KEYS)\n            )\n            if len(unique_value_keys) == 0:\n                value_key = None\n                value = ['']\n            else:\n                value_key = unique_value_keys[0]\n                value = mapping[value_key]\n            data_element = DataElement.from_json(\n                cls, tag, vr, value, value_key\n            )\n            dataset.add(data_element)\n        return dataset\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "from_json", "cls", "json_dataset", "bulk_data_uri_handler", "none", "encodings", "none", "loads", "dicom", "data", "set", "in", "dicom", "json", "format", "see", "http", "dicom", "nema", "org", "medical", "dicom", "current", "output", "chtml", "part18", "chapter_f", "html", "parameters", "json_dataset", "union", "dict", "str", "dictionary", "or", "string", "representing", "a", "dicom", "data", "set", "formatted", "based", "on", "the", "dicom", "json", "model", "annex", "f", "bulk_data_uri_handler", "union", "callable", "none", "callable", "that", "accepts", "the", "bulkdatauri", "of", "the", "json", "representation", "of", "a", "data", "element", "and", "returns", "the", "actual", "value", "of", "data", "element", "retrieved", "via", "dicomweb", "wado", "rs", "encodings", "union", "list", "none", "encodings", "from", "specificcharacterset", "or", "none", "for", "default", "returns", "pydicom", "dataset", "dataset", "if", "not", "isinstance", "json_dataset", "dict", "json_dataset", "json", "loads", "json_dataset", "dataset", "cls", "for", "tag", "mapping", "in", "json_dataset", "items", "vr", "mapping", "vr", "unique_value_keys", "tuple", "set", "mapping", "keys", "set", "cls", "_json_value_keys", "if", "len", "unique_value_keys", "0", "value_key", "none", "value", "else", "value_key", "unique_value_keys", "0", "value", "mapping", "value_key", "data_element", "dataelement", "from_json", "cls", "tag", "vr", "value", "value_key", "dataset", "add", "data_element", "return", "dataset"], "doc_len": 155}
{"doc_id": "pydicom/dataset.py::Dataset._data_element_to_json", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "_data_element_to_json", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def _data_element_to_json(self, data_element,\n                              bulk_data_element_handler,\n                              bulk_data_threshold, dump_handler):\n        \"\"\"Converts a DataElement to JSON representation.\n\n        Parameters\n        ----------\n        data_element: pydicom.dataelem.DataElement\n            data element\n        bulk_data_element_handler: Union[Callable, None]\n            callable that accepts a bulk data element and returns the\n            \"BulkDataURI\" for retrieving the value of the data element\n            via DICOMweb WADO-RS\n        bulk_data_threshold: int\n            size of base64 encoded data element above which a value will be\n            provided in form of a \"BulkDataURI\" rather than \"InlineBinary\"\n\n        Returns\n        -------\n        dict\n            mapping representing a JSON encoded data element\n\n        Raises\n        ------\n        TypeError\n            when size of encoded data element exceeds `bulk_data_threshold`\n            but `bulk_data_element_handler` is ``None`` and hence not callable\n\n        \"\"\"\n        # TODO: Determine whether more VRs need to be converted to strings\n        _VRs_TO_QUOTE = ['AT', ]\n        json_element = {'vr': data_element.VR, }\n        if data_element.VR in Dataset._BINARY_VR_VALUES:\n            if data_element.value is not None:\n                binary_value = data_element.value\n                encoded_value = base64.b64encode(binary_value).decode('utf-8')\n                if len(encoded_value) > bulk_data_threshold:\n                    if bulk_data_element_handler is None:\n                        raise TypeError(\n                            'No bulk data element handler provided to generate '\n                            'URL for value of data element \"{}\".'.format(\n                                data_element.name\n                            )\n                        )\n                    json_element['BulkDataURI'] = bulk_data_element_handler(\n                        data_element\n                    )\n                else:\n                    logger.info(\n                        'encode bulk data element \"{}\" inline'.format(\n                            data_element.name\n                        )\n                    )\n                    json_element['InlineBinary'] = encoded_value\n        elif data_element.VR == 'SQ':\n            # recursive call to co-routine to format sequence contents\n            value = [\n                json.loads(e.to_json(\n                    bulk_data_element_handler=bulk_data_element_handler,\n                    bulk_data_threshold=bulk_data_threshold,\n                    dump_handler=dump_handler\n                ))\n                for e in data_element\n            ]\n            json_element['Value'] = value\n        elif data_element.VR == 'PN':\n            elem_value = data_element.value\n            if elem_value is not None:\n                if compat.in_py2:\n                    elem_value = PersonNameUnicode(elem_value, 'UTF8')\n                if len(elem_value.components) > 2:\n                    json_element['Value'] = [\n                        {'Phonetic': elem_value.components[2], },\n                    ]\n                elif len(elem_value.components) > 1:\n                    json_element['Value'] = [\n                        {'Ideographic': elem_value.components[1], },\n                    ]\n                else:\n                    json_element['Value'] = [\n                        {'Alphabetic': elem_value.components[0], },\n                    ]\n        else:\n            if data_element.value is not None:\n                is_multivalue = isinstance(data_element.value, MultiValue)\n                if data_element.VM > 1 or is_multivalue:\n                    value = data_element.value\n                else:\n                    value = [data_element.value]\n                # ensure it's a list and not another iterable\n                # (e.g. tuple), which would not be JSON serializable\n                if data_element.VR in _VRs_TO_QUOTE:\n                    json_element['Value'] = [str(v) for v in value]\n                else:\n                    json_element['Value'] = [v for v in value]\n        if hasattr(json_element, 'Value'):\n            json_element['Value'] = self._convert_to_python_number(\n                json_element['Value'], data_element.VR\n            )\n        return json_element\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "_data_element_to_json", "self", "data_element", "bulk_data_element_handler", "bulk_data_threshold", "dump_handler", "converts", "a", "dataelement", "to", "json", "representation", "parameters", "data_element", "pydicom", "dataelem", "dataelement", "data", "element", "bulk_data_element_handler", "union", "callable", "none", "callable", "that", "accepts", "a", "bulk", "data", "element", "and", "returns", "the", "bulkdatauri", "for", "retrieving", "the", "value", "of", "the", "data", "element", "via", "dicomweb", "wado", "rs", "bulk_data_threshold", "int", "size", "of", "base64", "encoded", "data", "element", "above", "which", "a", "value", "will", "be", "provided", "in", "form", "of", "a", "bulkdatauri", "rather", "than", "inlinebinary", "returns", "dict", "mapping", "representing", "a", "json", "encoded", "data", "element", "raises", "typeerror", "when", "size", "of", "encoded", "data", "element", "exceeds", "bulk_data_threshold", "but", "bulk_data_element_handler", "is", "none", "and", "hence", "not", "callable", "todo", "determine", "whether", "more", "vrs", "need", "to", "be", "converted", "to", "strings", "_vrs_to_quote", "at", "json_element", "vr", "data_element", "vr", "if", "data_element", "vr", "in", "dataset", "_binary_vr_values", "if", "data_element", "value", "is", "not", "none", "binary_value", "data_element", "value", "encoded_value", "base64", "b64encode", "binary_value", "decode", "utf", "8", "if", "len", "encoded_value", "bulk_data_threshold", "if", "bulk_data_element_handler", "is", "none", "raise", "typeerror", "no", "bulk", "data", "element", "handler", "provided", "to", "generate", "url", "for", "value", "of", "data", "element", "format", "data_element", "name", "json_element", "bulkdatauri", "bulk_data_element_handler", "data_element", "else", "logger", "info", "encode", "bulk", "data", "element", "inline", "format", "data_element", "name", "json_element", "inlinebinary", "encoded_value", "elif", "data_element", "vr", "sq", "recursive", "call", "to", "co", "routine", "to", "format", "sequence", "contents", "value", "json", "loads", "e", "to_json", "bulk_data_element_handler", "bulk_data_element_handler", "bulk_data_threshold", "bulk_data_threshold", "dump_handler", "dump_handler", "for", "e", "in", "data_element", "json_element", "value", "value", "elif", "data_element", "vr", "pn", "elem_value", "data_element", "value", "if", "elem_value", "is", "not", "none", "if", "compat", "in_py2", "elem_value", "personnameunicode", "elem_value", "utf8", "if", "len", "elem_value", "components", "2", "json_element", "value", "phonetic", "elem_value", "components", "2", "elif", "len", "elem_value", "components", "1", "json_element", "value", "ideographic", "elem_value", "components", "1", "else", "json_element", "value", "alphabetic", "elem_value", "components", "0", "else", "if", "data_element", "value", "is", "not", "none", "is_multivalue", "isinstance", "data_element", "value", "multivalue", "if", "data_element", "vm", "1", "or", "is_multivalue", "value", "data_element", "value", "else", "value", "data_element", "value", "ensure", "it", "s", "a", "list", "and", "not", "another", "iterable", "e", "g", "tuple", "which", "would", "not", "be", "json", "serializable", "if", "data_element", "vr", "in", "_vrs_to_quote", "json_element", "value", "str", "v", "for", "v", "in", "value", "else", "json_element", "value", "v", "for", "v", "in", "value", "if", "hasattr", "json_element", "value", "json_element", "value", "self", "_convert_to_python_number", "json_element", "value", "data_element", "vr", "return", "json_element"], "doc_len": 342}
{"doc_id": "pydicom/dataset.py::Dataset.to_json", "file_path": "pydicom/dataset.py", "class_name": "Dataset", "func_name": "to_json", "text": "文件路径: pydicom/dataset.py, 类名: Dataset\n    def to_json(self, bulk_data_threshold=1, bulk_data_element_handler=None,\n                dump_handler=None):\n        \"\"\"Converts the data set into JSON representation based on the\n        DICOM JSON Model\n        http://dicom.nema.org/medical/dicom/current/output/chtml/part18/chapter_F.html.\n\n        Parameters\n        ----------\n        bulk_data_threshold: int, optional\n            threshold for the length of a base64-encoded binary data element\n            above which the element should be considered bulk data and the value\n            provided as a URI rather than included inline (default: ``1``)\n        bulk_data_element_handler: Union[Callable, None], optional\n            callable that accepts a bulk data element and returns a JSON\n            representation of the data element (dictionary including the \"vr\"\n            key and either the \"InlineBinary\" or the \"BulkDataURI\" key)\n        dump_handler: Union[Callable, None], optional\n            callable that accepts a dict and returns the serialized (dumped)\n            JSON string (by default uses ``json.dumps()``)\n\n        Returns\n        -------\n        str\n            data set serialized into a string based on the DICOM JSON Model\n\n        Examples\n        --------\n        >>> def my_json_dumps(data):\n        ...     return json.dumps(data, indent=4)\n        >>> dataset.to_json(dump_handler=my_json_dumps)\n\n        \"\"\"\n        if dump_handler is None:\n            logger.debug('using default json.dumps function')\n            dump_handler = json.dumps\n        json_dataset = {}\n        for key in self.keys():\n            json_key = '{0:04x}{1:04x}'.format(key.group, key.element).upper()\n            # FIXME: with pydicom 1.x the referenced image sequence\n            # causes a recursion error\n            if json_key == '00081140':\n                logger.warning(\n                    'currently can\\'t serialize data element \"{}\"'.format(key)\n                )\n                continue\n            data_element = self[key]\n            json_dataset[json_key] = self._data_element_to_json(\n                data_element,\n                bulk_data_element_handler=bulk_data_element_handler,\n                bulk_data_threshold=bulk_data_threshold,\n                dump_handler=dump_handler\n            )\n        return dump_handler(json_dataset)\n", "tokens": ["pydicom", "dataset", "py", "dataset", "def", "to_json", "self", "bulk_data_threshold", "1", "bulk_data_element_handler", "none", "dump_handler", "none", "converts", "the", "data", "set", "into", "json", "representation", "based", "on", "the", "dicom", "json", "model", "http", "dicom", "nema", "org", "medical", "dicom", "current", "output", "chtml", "part18", "chapter_f", "html", "parameters", "bulk_data_threshold", "int", "optional", "threshold", "for", "the", "length", "of", "a", "base64", "encoded", "binary", "data", "element", "above", "which", "the", "element", "should", "be", "considered", "bulk", "data", "and", "the", "value", "provided", "as", "a", "uri", "rather", "than", "included", "inline", "default", "1", "bulk_data_element_handler", "union", "callable", "none", "optional", "callable", "that", "accepts", "a", "bulk", "data", "element", "and", "returns", "a", "json", "representation", "of", "the", "data", "element", "dictionary", "including", "the", "vr", "key", "and", "either", "the", "inlinebinary", "or", "the", "bulkdatauri", "key", "dump_handler", "union", "callable", "none", "optional", "callable", "that", "accepts", "a", "dict", "and", "returns", "the", "serialized", "dumped", "json", "string", "by", "default", "uses", "json", "dumps", "returns", "str", "data", "set", "serialized", "into", "a", "string", "based", "on", "the", "dicom", "json", "model", "examples", "def", "my_json_dumps", "data", "return", "json", "dumps", "data", "indent", "4", "dataset", "to_json", "dump_handler", "my_json_dumps", "if", "dump_handler", "is", "none", "logger", "debug", "using", "default", "json", "dumps", "function", "dump_handler", "json", "dumps", "json_dataset", "for", "key", "in", "self", "keys", "json_key", "0", "04x", "1", "04x", "format", "key", "group", "key", "element", "upper", "fixme", "with", "pydicom", "1", "x", "the", "referenced", "image", "sequence", "causes", "a", "recursion", "error", "if", "json_key", "00081140", "logger", "warning", "currently", "can", "t", "serialize", "data", "element", "format", "key", "continue", "data_element", "self", "key", "json_dataset", "json_key", "self", "_data_element_to_json", "data_element", "bulk_data_element_handler", "bulk_data_element_handler", "bulk_data_threshold", "bulk_data_threshold", "dump_handler", "dump_handler", "return", "dump_handler", "json_dataset"], "doc_len": 234}
{"doc_id": "pydicom/dataset.py::FileDataset.__init__", "file_path": "pydicom/dataset.py", "class_name": "FileDataset", "func_name": "__init__", "text": "文件路径: pydicom/dataset.py, 类名: FileDataset\n    def __init__(self,\n                 filename_or_obj,\n                 dataset,\n                 preamble=None,\n                 file_meta=None,\n                 is_implicit_VR=True,\n                 is_little_endian=True):\n        \"\"\"Initialize a Dataset read from a DICOM file.\n\n        Parameters\n        ----------\n        filename_or_obj : str or BytesIO or None\n            Full path and filename to the file, memory buffer object, or None\n            if is a BytesIO.\n        dataset : Dataset or dict\n            Some form of dictionary, usually a Dataset from read_dataset().\n        preamble : bytes or str, optional\n            The 128-byte DICOM preamble.\n        file_meta : Dataset, optional\n            The file meta info dataset, as returned by _read_file_meta,\n            or an empty dataset if no file meta information is in the file.\n        is_implicit_VR : bool, optional\n            True (default) if implicit VR transfer syntax used; False if\n            explicit VR.\n        is_little_endian : boolean\n            True (default) if little-endian transfer syntax used; False if\n            big-endian.\n        \"\"\"\n        Dataset.__init__(self, dataset)\n        self.preamble = preamble\n        self.file_meta = file_meta\n        self.is_implicit_VR = is_implicit_VR\n        self.is_little_endian = is_little_endian\n        if isinstance(filename_or_obj, compat.string_types):\n            self.filename = filename_or_obj\n            self.fileobj_type = open\n        elif isinstance(filename_or_obj, io.BufferedReader):\n            self.filename = filename_or_obj.name\n            # This is the appropriate constructor for io.BufferedReader\n            self.fileobj_type = open\n        else:\n            # use __class__ python <2.7?;\n            # http://docs.python.org/reference/datamodel.html\n            self.fileobj_type = filename_or_obj.__class__\n            if getattr(filename_or_obj, \"name\", False):\n                self.filename = filename_or_obj.name\n            elif getattr(filename_or_obj, \"filename\",\n                         False):  # gzip python <2.7?\n                self.filename = filename_or_obj.filename\n            else:\n                # e.g. came from BytesIO or something file-like\n                self.filename = None\n        self.timestamp = None\n        if self.filename and os.path.exists(self.filename):\n            statinfo = os.stat(self.filename)\n            self.timestamp = statinfo.st_mtime\n", "tokens": ["pydicom", "dataset", "py", "filedataset", "def", "__init__", "self", "filename_or_obj", "dataset", "preamble", "none", "file_meta", "none", "is_implicit_vr", "true", "is_little_endian", "true", "initialize", "a", "dataset", "read", "from", "a", "dicom", "file", "parameters", "filename_or_obj", "str", "or", "bytesio", "or", "none", "full", "path", "and", "filename", "to", "the", "file", "memory", "buffer", "object", "or", "none", "if", "is", "a", "bytesio", "dataset", "dataset", "or", "dict", "some", "form", "of", "dictionary", "usually", "a", "dataset", "from", "read_dataset", "preamble", "bytes", "or", "str", "optional", "the", "128", "byte", "dicom", "preamble", "file_meta", "dataset", "optional", "the", "file", "meta", "info", "dataset", "as", "returned", "by", "_read_file_meta", "or", "an", "empty", "dataset", "if", "no", "file", "meta", "information", "is", "in", "the", "file", "is_implicit_vr", "bool", "optional", "true", "default", "if", "implicit", "vr", "transfer", "syntax", "used", "false", "if", "explicit", "vr", "is_little_endian", "boolean", "true", "default", "if", "little", "endian", "transfer", "syntax", "used", "false", "if", "big", "endian", "dataset", "__init__", "self", "dataset", "self", "preamble", "preamble", "self", "file_meta", "file_meta", "self", "is_implicit_vr", "is_implicit_vr", "self", "is_little_endian", "is_little_endian", "if", "isinstance", "filename_or_obj", "compat", "string_types", "self", "filename", "filename_or_obj", "self", "fileobj_type", "open", "elif", "isinstance", "filename_or_obj", "io", "bufferedreader", "self", "filename", "filename_or_obj", "name", "this", "is", "the", "appropriate", "constructor", "for", "io", "bufferedreader", "self", "fileobj_type", "open", "else", "use", "__class__", "python", "2", "7", "http", "docs", "python", "org", "reference", "datamodel", "html", "self", "fileobj_type", "filename_or_obj", "__class__", "if", "getattr", "filename_or_obj", "name", "false", "self", "filename", "filename_or_obj", "name", "elif", "getattr", "filename_or_obj", "filename", "false", "gzip", "python", "2", "7", "self", "filename", "filename_or_obj", "filename", "else", "e", "g", "came", "from", "bytesio", "or", "something", "file", "like", "self", "filename", "none", "self", "timestamp", "none", "if", "self", "filename", "and", "os", "path", "exists", "self", "filename", "statinfo", "os", "stat", "self", "filename", "self", "timestamp", "statinfo", "st_mtime"], "doc_len": 245}
{"doc_id": "pydicom/dataset.py::FileDataset.__eq__", "file_path": "pydicom/dataset.py", "class_name": "FileDataset", "func_name": "__eq__", "text": "文件路径: pydicom/dataset.py, 类名: FileDataset\n    def __eq__(self, other):\n        \"\"\"Compare `self` and `other` for equality.\n\n        Returns\n        -------\n        bool\n            The result if `self` and `other` are the same class\n        NotImplemented\n            If `other` is not the same class as `self` then returning\n            NotImplemented delegates the result to superclass.__eq__(subclass)\n        \"\"\"\n        # When comparing against self this will be faster\n        if other is self:\n            return True\n\n        if isinstance(other, self.__class__):\n            return (_dict_equal(self, other) and\n                    _dict_equal(self.__dict__, other.__dict__,\n                                exclude=['_dict'])\n                    )\n\n        return NotImplemented\n", "tokens": ["pydicom", "dataset", "py", "filedataset", "def", "__eq__", "self", "other", "compare", "self", "and", "other", "for", "equality", "returns", "bool", "the", "result", "if", "self", "and", "other", "are", "the", "same", "class", "notimplemented", "if", "other", "is", "not", "the", "same", "class", "as", "self", "then", "returning", "notimplemented", "delegates", "the", "result", "to", "superclass", "__eq__", "subclass", "when", "comparing", "against", "self", "this", "will", "be", "faster", "if", "other", "is", "self", "return", "true", "if", "isinstance", "other", "self", "__class__", "return", "_dict_equal", "self", "other", "and", "_dict_equal", "self", "__dict__", "other", "__dict__", "exclude", "_dict", "return", "notimplemented"], "doc_len": 79}
{"doc_id": "pydicom/dataset.py::validate_file_meta", "file_path": "pydicom/dataset.py", "class_name": null, "func_name": "validate_file_meta", "text": "文件路径: pydicom/dataset.py\ndef validate_file_meta(file_meta, enforce_standard=True):\n    \"\"\"Validates the File Meta Information elements in `file_meta` and\n    adds some tags if missing and `enforce_standard` is True.\n\n    Parameters\n    ----------\n    file_meta : pydicom.dataset.Dataset\n        The File Meta Information data elements.\n    enforce_standard : bool\n        If False, then only a check for invalid elements is performed.\n        If True, the following elements will be added if not already present:\n            * (0002,0001) FileMetaInformationVersion\n            * (0002,0012) ImplementationClassUID\n            * (0002,0013) ImplementationVersionName\n        and the following elements will be checked:\n            * (0002,0002) MediaStorageSOPClassUID\n            * (0002,0003) MediaStorageSOPInstanceUID\n            * (0002,0010) TransferSyntaxUID\n\n    Raises\n    ------\n    ValueError\n        If `enforce_standard` is True and any of the checked File Meta\n        Information elements are missing from `file_meta`.\n    ValueError\n        If any non-Group 2 Elements are present in `file_meta`.\n    \"\"\"\n    # Check that no non-Group 2 Elements are present\n    for elem in file_meta.elements():\n        if elem.tag.group != 0x0002:\n            raise ValueError(\"Only File Meta Information Group (0002,eeee) \"\n                             \"elements must be present in 'file_meta'.\")\n\n    if enforce_standard:\n        if 'FileMetaInformationVersion' not in file_meta:\n            file_meta.FileMetaInformationVersion = b'\\x00\\x01'\n\n        if 'ImplementationClassUID' not in file_meta:\n            file_meta.ImplementationClassUID = PYDICOM_IMPLEMENTATION_UID\n\n        if 'ImplementationVersionName' not in file_meta:\n            file_meta.ImplementationVersionName = (\n                'PYDICOM ' + \".\".join(str(x) for x in __version_info__))\n\n        # Check that required File Meta Information elements are present\n        missing = []\n        for element in [0x0002, 0x0003, 0x0010]:\n            if Tag(0x0002, element) not in file_meta:\n                missing.append(Tag(0x0002, element))\n        if missing:\n            msg = (\"Missing required File Meta Information elements from \"\n                   \"'file_meta':\\n\")\n            for tag in missing:\n                msg += '\\t{0} {1}\\n'.format(tag, keyword_for_tag(tag))\n            raise ValueError(msg[:-1])  # Remove final newline\n", "tokens": ["pydicom", "dataset", "py", "def", "validate_file_meta", "file_meta", "enforce_standard", "true", "validates", "the", "file", "meta", "information", "elements", "in", "file_meta", "and", "adds", "some", "tags", "if", "missing", "and", "enforce_standard", "is", "true", "parameters", "file_meta", "pydicom", "dataset", "dataset", "the", "file", "meta", "information", "data", "elements", "enforce_standard", "bool", "if", "false", "then", "only", "a", "check", "for", "invalid", "elements", "is", "performed", "if", "true", "the", "following", "elements", "will", "be", "added", "if", "not", "already", "present", "0002", "0001", "filemetainformationversion", "0002", "0012", "implementationclassuid", "0002", "0013", "implementationversionname", "and", "the", "following", "elements", "will", "be", "checked", "0002", "0002", "mediastoragesopclassuid", "0002", "0003", "mediastoragesopinstanceuid", "0002", "0010", "transfersyntaxuid", "raises", "valueerror", "if", "enforce_standard", "is", "true", "and", "any", "of", "the", "checked", "file", "meta", "information", "elements", "are", "missing", "from", "file_meta", "valueerror", "if", "any", "non", "group", "2", "elements", "are", "present", "in", "file_meta", "check", "that", "no", "non", "group", "2", "elements", "are", "present", "for", "elem", "in", "file_meta", "elements", "if", "elem", "tag", "group", "0x0002", "raise", "valueerror", "only", "file", "meta", "information", "group", "0002", "eeee", "elements", "must", "be", "present", "in", "file_meta", "if", "enforce_standard", "if", "filemetainformationversion", "not", "in", "file_meta", "file_meta", "filemetainformationversion", "b", "x00", "x01", "if", "implementationclassuid", "not", "in", "file_meta", "file_meta", "implementationclassuid", "pydicom_implementation_uid", "if", "implementationversionname", "not", "in", "file_meta", "file_meta", "implementationversionname", "pydicom", "join", "str", "x", "for", "x", "in", "__version_info__", "check", "that", "required", "file", "meta", "information", "elements", "are", "present", "missing", "for", "element", "in", "0x0002", "0x0003", "0x0010", "if", "tag", "0x0002", "element", "not", "in", "file_meta", "missing", "append", "tag", "0x0002", "element", "if", "missing", "msg", "missing", "required", "file", "meta", "information", "elements", "from", "file_meta", "n", "for", "tag", "in", "missing", "msg", "t", "0", "1", "n", "format", "tag", "keyword_for_tag", "tag", "raise", "valueerror", "msg", "1", "remove", "final", "newline"], "doc_len": 246}
{"doc_id": "pydicom/dicomdir.py::DicomDir.__init__", "file_path": "pydicom/dicomdir.py", "class_name": "DicomDir", "func_name": "__init__", "text": "文件路径: pydicom/dicomdir.py, 类名: DicomDir\n    def __init__(self,\n                 filename_or_obj,\n                 dataset,\n                 preamble=None,\n                 file_meta=None,\n                 is_implicit_VR=True,\n                 is_little_endian=True):\n        \"\"\"Initialize a DICOMDIR dataset read from a DICOM file\n        Carries forward all the initialization from\n        FileDataset class\n\n        :param filename_or_obj: full path and filename to the file.\n        Use None if is a BytesIO.\n        :param dataset: some form of dictionary, usually\n                        a Dataset from read_dataset()\n        :param preamble: the 128-byte DICOM preamble\n        :param file_meta: the file meta info dataset,\n                          as returned by _read_file_meta,\n                          or an empty dataset if no file meta\n                          information is in the file\n        :param is_implicit_VR: True if implicit VR transfer syntax used;\n                               False if explicit VR. Default is True.\n        :param is_little_endian: True if little-endian transfer syntax used;\n                                 False if big-endian. Default is True.\n        \"\"\"\n        # Usually this class is created through filereader.read_partial,\n        # and it checks class SOP, but in case of direct creation,\n        # check here also\n        if file_meta:\n            class_uid = file_meta.MediaStorageSOPClassUID\n            if not class_uid.name == \"Media Storage Directory Storage\":\n                msg = \"SOP Class is not Media Storage Directory (DICOMDIR)\"\n                raise InvalidDicomError(msg)\n        FileDataset.__init__(\n            self,\n            filename_or_obj,\n            dataset,\n            preamble,\n            file_meta,\n            is_implicit_VR=is_implicit_VR,\n            is_little_endian=is_little_endian)\n        self.parse_records()\n", "tokens": ["pydicom", "dicomdir", "py", "dicomdir", "def", "__init__", "self", "filename_or_obj", "dataset", "preamble", "none", "file_meta", "none", "is_implicit_vr", "true", "is_little_endian", "true", "initialize", "a", "dicomdir", "dataset", "read", "from", "a", "dicom", "file", "carries", "forward", "all", "the", "initialization", "from", "filedataset", "class", "param", "filename_or_obj", "full", "path", "and", "filename", "to", "the", "file", "use", "none", "if", "is", "a", "bytesio", "param", "dataset", "some", "form", "of", "dictionary", "usually", "a", "dataset", "from", "read_dataset", "param", "preamble", "the", "128", "byte", "dicom", "preamble", "param", "file_meta", "the", "file", "meta", "info", "dataset", "as", "returned", "by", "_read_file_meta", "or", "an", "empty", "dataset", "if", "no", "file", "meta", "information", "is", "in", "the", "file", "param", "is_implicit_vr", "true", "if", "implicit", "vr", "transfer", "syntax", "used", "false", "if", "explicit", "vr", "default", "is", "true", "param", "is_little_endian", "true", "if", "little", "endian", "transfer", "syntax", "used", "false", "if", "big", "endian", "default", "is", "true", "usually", "this", "class", "is", "created", "through", "filereader", "read_partial", "and", "it", "checks", "class", "sop", "but", "in", "case", "of", "direct", "creation", "check", "here", "also", "if", "file_meta", "class_uid", "file_meta", "mediastoragesopclassuid", "if", "not", "class_uid", "name", "media", "storage", "directory", "storage", "msg", "sop", "class", "is", "not", "media", "storage", "directory", "dicomdir", "raise", "invaliddicomerror", "msg", "filedataset", "__init__", "self", "filename_or_obj", "dataset", "preamble", "file_meta", "is_implicit_vr", "is_implicit_vr", "is_little_endian", "is_little_endian", "self", "parse_records"], "doc_len": 183}
{"doc_id": "pydicom/dicomdir.py::DicomDir.parse_records", "file_path": "pydicom/dicomdir.py", "class_name": "DicomDir", "func_name": "parse_records", "text": "文件路径: pydicom/dicomdir.py, 类名: DicomDir\n    def parse_records(self):\n        \"\"\"Build the hierarchy of given directory records, and structure\n        into Patient, Studies, Series, Images hierarchy.\n\n        This is intended for initial read of file only,\n        it will not reorganize correctly if records are changed.\n\n        :return: None\n        \"\"\"\n\n        # Define a helper function for organizing the records\n        def get_siblings(record, map_offset_to_record):\n            \"\"\"Return a list of all siblings of the given directory record,\n            including itself.\n            \"\"\"\n            sibling_list = [record]\n            current_record = record\n            while current_record.OffsetOfTheNextDirectoryRecord:\n                offset_of_next = current_record.OffsetOfTheNextDirectoryRecord\n                sibling = map_offset_to_record[offset_of_next]\n                sibling_list.append(sibling)\n                current_record = sibling\n            return sibling_list\n\n        # Build the mapping from file offsets to records\n        records = self.DirectoryRecordSequence\n        map_offset_to_record = {}\n        for record in records:\n            offset = record.seq_item_tell\n            map_offset_to_record[offset] = record\n        # logging.debug(\"Record offsets: \" + map_offset_to_record.keys())\n\n        # Find the children of each record\n        for record in records:\n            child_offset = record.OffsetOfReferencedLowerLevelDirectoryEntity\n            if child_offset:\n                child = map_offset_to_record[child_offset]\n                record.children = get_siblings(child, map_offset_to_record)\n            else:\n                record.children = []\n\n        # Find the top-level records : siblings of the first record\n        self.patient_records = get_siblings(records[0], map_offset_to_record)\n", "tokens": ["pydicom", "dicomdir", "py", "dicomdir", "def", "parse_records", "self", "build", "the", "hierarchy", "of", "given", "directory", "records", "and", "structure", "into", "patient", "studies", "series", "images", "hierarchy", "this", "is", "intended", "for", "initial", "read", "of", "file", "only", "it", "will", "not", "reorganize", "correctly", "if", "records", "are", "changed", "return", "none", "define", "a", "helper", "function", "for", "organizing", "the", "records", "def", "get_siblings", "record", "map_offset_to_record", "return", "a", "list", "of", "all", "siblings", "of", "the", "given", "directory", "record", "including", "itself", "sibling_list", "record", "current_record", "record", "while", "current_record", "offsetofthenextdirectoryrecord", "offset_of_next", "current_record", "offsetofthenextdirectoryrecord", "sibling", "map_offset_to_record", "offset_of_next", "sibling_list", "append", "sibling", "current_record", "sibling", "return", "sibling_list", "build", "the", "mapping", "from", "file", "offsets", "to", "records", "records", "self", "directoryrecordsequence", "map_offset_to_record", "for", "record", "in", "records", "offset", "record", "seq_item_tell", "map_offset_to_record", "offset", "record", "logging", "debug", "record", "offsets", "map_offset_to_record", "keys", "find", "the", "children", "of", "each", "record", "for", "record", "in", "records", "child_offset", "record", "offsetofreferencedlowerleveldirectoryentity", "if", "child_offset", "child", "map_offset_to_record", "child_offset", "record", "children", "get_siblings", "child", "map_offset_to_record", "else", "record", "children", "find", "the", "top", "level", "records", "siblings", "of", "the", "first", "record", "self", "patient_records", "get_siblings", "records", "0", "map_offset_to_record"], "doc_len": 157}
{"doc_id": "pydicom/encaps.py::get_frame_offsets", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "get_frame_offsets", "text": "文件路径: pydicom/encaps.py\ndef get_frame_offsets(fp):\n    \"\"\"Return a list of the fragment offsets from the Basic Offset Table.\n\n    **Basic Offset Table**\n\n    The Basic Offset Table Item must be present and have a tag (FFFE,E000) and\n    a length, however it may or may not have a value.\n\n    Basic Offset Table with no value\n    ::\n\n        Item Tag   | Length    |\n        FE FF 00 E0 00 00 00 00\n\n    Basic Offset Table with value (2 frames)\n    ::\n\n        Item Tag   | Length    | Offset 1  | Offset 2  |\n        FE FF 00 E0 08 00 00 00 00 00 00 00 10 00 00 00\n\n    For single or multi-frame images with only one frame, the Basic Offset\n    Table may or may not have a value. When it has no value then its length\n    shall be ``0x00000000``.\n\n    For multi-frame images with more than one frame, the Basic Offset Table\n    should have a value containing concatenated 32-bit unsigned integer values\n    that are the byte offsets to the first byte of the Item tag of the first\n    fragment of each frame as measured from the first byte of the first item\n    tag following the Basic Offset Table Item.\n\n    All decoders, both for single and multi-frame images should accept both\n    an empty Basic Offset Table and one containing offset values.\n\n    Parameters\n    ----------\n    fp : pydicom.filebase.DicomBytesIO\n        The encapsulated pixel data positioned at the start of the Basic Offset\n        Table. ``fp.is_little_endian`` should be set to True.\n\n    Returns\n    -------\n    list of int\n        The byte offsets to the first fragment of each frame, as measured from\n        the start of the first item following the Basic Offset Table item.\n\n    Raises\n    ------\n    ValueError\n        If the Basic Offset Table item's tag is not (FFEE,E000) or if the\n        length in bytes of the item's value is not a multiple of 4.\n\n    References\n    ----------\n    DICOM Standard Part 5, Annex A.4\n    \"\"\"\n    if not fp.is_little_endian:\n        raise ValueError(\"'fp.is_little_endian' must be True\")\n\n    tag = Tag(fp.read_tag())\n\n    if tag != 0xfffee000:\n        raise ValueError(\"Unexpected tag '{}' when parsing the Basic Table \"\n                         \"Offset item.\".format(tag))\n\n    length = fp.read_UL()\n    if length % 4:\n        raise ValueError(\"The length of the Basic Offset Table item is not \"\n                         \"a multiple of 4.\")\n\n    offsets = []\n    # Always return at least a 0 offset\n    if length == 0:\n        offsets.append(0)\n\n    for ii in range(length // 4):\n        offsets.append(fp.read_UL())\n\n    return offsets\n", "tokens": ["pydicom", "encaps", "py", "def", "get_frame_offsets", "fp", "return", "a", "list", "of", "the", "fragment", "offsets", "from", "the", "basic", "offset", "table", "basic", "offset", "table", "the", "basic", "offset", "table", "item", "must", "be", "present", "and", "have", "a", "tag", "fffe", "e000", "and", "a", "length", "however", "it", "may", "or", "may", "not", "have", "a", "value", "basic", "offset", "table", "with", "no", "value", "item", "tag", "length", "fe", "ff", "00", "e0", "00", "00", "00", "00", "basic", "offset", "table", "with", "value", "2", "frames", "item", "tag", "length", "offset", "1", "offset", "2", "fe", "ff", "00", "e0", "08", "00", "00", "00", "00", "00", "00", "00", "10", "00", "00", "00", "for", "single", "or", "multi", "frame", "images", "with", "only", "one", "frame", "the", "basic", "offset", "table", "may", "or", "may", "not", "have", "a", "value", "when", "it", "has", "no", "value", "then", "its", "length", "shall", "be", "0x00000000", "for", "multi", "frame", "images", "with", "more", "than", "one", "frame", "the", "basic", "offset", "table", "should", "have", "a", "value", "containing", "concatenated", "32", "bit", "unsigned", "integer", "values", "that", "are", "the", "byte", "offsets", "to", "the", "first", "byte", "of", "the", "item", "tag", "of", "the", "first", "fragment", "of", "each", "frame", "as", "measured", "from", "the", "first", "byte", "of", "the", "first", "item", "tag", "following", "the", "basic", "offset", "table", "item", "all", "decoders", "both", "for", "single", "and", "multi", "frame", "images", "should", "accept", "both", "an", "empty", "basic", "offset", "table", "and", "one", "containing", "offset", "values", "parameters", "fp", "pydicom", "filebase", "dicombytesio", "the", "encapsulated", "pixel", "data", "positioned", "at", "the", "start", "of", "the", "basic", "offset", "table", "fp", "is_little_endian", "should", "be", "set", "to", "true", "returns", "list", "of", "int", "the", "byte", "offsets", "to", "the", "first", "fragment", "of", "each", "frame", "as", "measured", "from", "the", "start", "of", "the", "first", "item", "following", "the", "basic", "offset", "table", "item", "raises", "valueerror", "if", "the", "basic", "offset", "table", "item", "s", "tag", "is", "not", "ffee", "e000", "or", "if", "the", "length", "in", "bytes", "of", "the", "item", "s", "value", "is", "not", "a", "multiple", "of", "4", "references", "dicom", "standard", "part", "5", "annex", "a", "4", "if", "not", "fp", "is_little_endian", "raise", "valueerror", "fp", "is_little_endian", "must", "be", "true", "tag", "tag", "fp", "read_tag", "if", "tag", "0xfffee000", "raise", "valueerror", "unexpected", "tag", "when", "parsing", "the", "basic", "table", "offset", "item", "format", "tag", "length", "fp", "read_ul", "if", "length", "4", "raise", "valueerror", "the", "length", "of", "the", "basic", "offset", "table", "item", "is", "not", "a", "multiple", "of", "4", "offsets", "always", "return", "at", "least", "a", "0", "offset", "if", "length", "0", "offsets", "append", "0", "for", "ii", "in", "range", "length", "4", "offsets", "append", "fp", "read_ul", "return", "offsets"], "doc_len": 381}
{"doc_id": "pydicom/encaps.py::generate_pixel_data_fragment", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "generate_pixel_data_fragment", "text": "文件路径: pydicom/encaps.py\ndef generate_pixel_data_fragment(fp):\n    \"\"\"Yield the encapsulated pixel data fragments as bytes.\n\n    For compressed (encapsulated) Transfer Syntaxes, the (7fe0,0010) 'Pixel\n    Data' element is encoded in an encapsulated format.\n\n    **Encapsulation**\n\n    The encoded pixel data stream is fragmented into one or more Items. The\n    stream may represent a single or multi-frame image.\n\n    Each *Data Stream Fragment* shall have tag of (fffe,e000), followed by a 4\n    byte *Item Length* field encoding the explicit number of bytes in the Item.\n    All Items containing an encoded fragment shall have an even number of bytes\n    greater than or equal to 2, with the last fragment being padded if\n    necessary.\n\n    The first Item in the Sequence of Items shall be a 'Basic Offset Table',\n    however the Basic Offset Table item value is not required to be present.\n    It is assumed that the Basic Offset Table item has already been read prior\n    to calling this function (and that ``fp`` is positioned past this item).\n\n    The remaining items in the Sequence of Items are the pixel data fragments\n    and it is these items that will be read and returned by this function.\n\n    The Sequence of Items is terminated by a Sequence Delimiter Item with tag\n    (fffe,e0dd) and an Item Length field of value ``0x00000000``. The presence\n    or absence of the Sequence Delimiter Item in `fp` has no effect on the\n    returned fragments.\n\n    Encoding\n    ~~~~~~~~\n    The encoding of the data shall be little endian.\n\n    Parameters\n    ----------\n    fp : pydicom.filebase.DicomBytesIO\n        The encoded (7fe0,0010) *Pixel Data* element value, positioned at the\n        start of the item tag for the first item after the Basic Offset Table\n        item. ``fp.is_little_endian`` should be set to True.\n\n    Yields\n    ------\n    bytes\n        A pixel data fragment.\n\n    Raises\n    ------\n    ValueError\n        If the data contains an item with an undefined length or an unknown\n        tag.\n\n    References\n    ----------\n    DICOM Standard Part 5, Annex A.4\n    \"\"\"\n    if not fp.is_little_endian:\n        raise ValueError(\"'fp.is_little_endian' must be True\")\n\n    # We should be positioned at the start of the Item Tag for the first\n    # fragment after the Basic Offset Table\n    while True:\n        try:\n            tag = Tag(fp.read_tag())\n        except EOFError:\n            break\n\n        if tag == 0xFFFEE000:\n            # Item\n            length = fp.read_UL()\n            if length == 0xFFFFFFFF:\n                raise ValueError(\"Undefined item length at offset {} when \"\n                                 \"parsing the encapsulated pixel data \"\n                                 \"fragments.\".format(fp.tell() - 4))\n            yield fp.read(length)\n        elif tag == 0xFFFEE0DD:\n            # Sequence Delimiter\n            # Behave nicely and rewind back to the end of the items\n            fp.seek(-4, 1)\n            break\n        else:\n            raise ValueError(\"Unexpected tag '{0}' at offset {1} when parsing \"\n                             \"the encapsulated pixel data fragment items.\"\n                             .format(tag, fp.tell() - 4))\n", "tokens": ["pydicom", "encaps", "py", "def", "generate_pixel_data_fragment", "fp", "yield", "the", "encapsulated", "pixel", "data", "fragments", "as", "bytes", "for", "compressed", "encapsulated", "transfer", "syntaxes", "the", "7fe0", "0010", "pixel", "data", "element", "is", "encoded", "in", "an", "encapsulated", "format", "encapsulation", "the", "encoded", "pixel", "data", "stream", "is", "fragmented", "into", "one", "or", "more", "items", "the", "stream", "may", "represent", "a", "single", "or", "multi", "frame", "image", "each", "data", "stream", "fragment", "shall", "have", "tag", "of", "fffe", "e000", "followed", "by", "a", "4", "byte", "item", "length", "field", "encoding", "the", "explicit", "number", "of", "bytes", "in", "the", "item", "all", "items", "containing", "an", "encoded", "fragment", "shall", "have", "an", "even", "number", "of", "bytes", "greater", "than", "or", "equal", "to", "2", "with", "the", "last", "fragment", "being", "padded", "if", "necessary", "the", "first", "item", "in", "the", "sequence", "of", "items", "shall", "be", "a", "basic", "offset", "table", "however", "the", "basic", "offset", "table", "item", "value", "is", "not", "required", "to", "be", "present", "it", "is", "assumed", "that", "the", "basic", "offset", "table", "item", "has", "already", "been", "read", "prior", "to", "calling", "this", "function", "and", "that", "fp", "is", "positioned", "past", "this", "item", "the", "remaining", "items", "in", "the", "sequence", "of", "items", "are", "the", "pixel", "data", "fragments", "and", "it", "is", "these", "items", "that", "will", "be", "read", "and", "returned", "by", "this", "function", "the", "sequence", "of", "items", "is", "terminated", "by", "a", "sequence", "delimiter", "item", "with", "tag", "fffe", "e0dd", "and", "an", "item", "length", "field", "of", "value", "0x00000000", "the", "presence", "or", "absence", "of", "the", "sequence", "delimiter", "item", "in", "fp", "has", "no", "effect", "on", "the", "returned", "fragments", "encoding", "the", "encoding", "of", "the", "data", "shall", "be", "little", "endian", "parameters", "fp", "pydicom", "filebase", "dicombytesio", "the", "encoded", "7fe0", "0010", "pixel", "data", "element", "value", "positioned", "at", "the", "start", "of", "the", "item", "tag", "for", "the", "first", "item", "after", "the", "basic", "offset", "table", "item", "fp", "is_little_endian", "should", "be", "set", "to", "true", "yields", "bytes", "a", "pixel", "data", "fragment", "raises", "valueerror", "if", "the", "data", "contains", "an", "item", "with", "an", "undefined", "length", "or", "an", "unknown", "tag", "references", "dicom", "standard", "part", "5", "annex", "a", "4", "if", "not", "fp", "is_little_endian", "raise", "valueerror", "fp", "is_little_endian", "must", "be", "true", "we", "should", "be", "positioned", "at", "the", "start", "of", "the", "item", "tag", "for", "the", "first", "fragment", "after", "the", "basic", "offset", "table", "while", "true", "try", "tag", "tag", "fp", "read_tag", "except", "eoferror", "break", "if", "tag", "0xfffee000", "item", "length", "fp", "read_ul", "if", "length", "0xffffffff", "raise", "valueerror", "undefined", "item", "length", "at", "offset", "when", "parsing", "the", "encapsulated", "pixel", "data", "fragments", "format", "fp", "tell", "4", "yield", "fp", "read", "length", "elif", "tag", "0xfffee0dd", "sequence", "delimiter", "behave", "nicely", "and", "rewind", "back", "to", "the", "end", "of", "the", "items", "fp", "seek", "4", "1", "break", "else", "raise", "valueerror", "unexpected", "tag", "0", "at", "offset", "1", "when", "parsing", "the", "encapsulated", "pixel", "data", "fragment", "items", "format", "tag", "fp", "tell", "4"], "doc_len": 423}
{"doc_id": "pydicom/encaps.py::generate_pixel_data_frame", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "generate_pixel_data_frame", "text": "文件路径: pydicom/encaps.py\ndef generate_pixel_data_frame(bytestream):\n    \"\"\"Yield an encapsulated pixel data frame as bytes.\n\n    Parameters\n    ----------\n    bytestream : bytes\n        The value of the (7fe0, 0010) *Pixel Data* element from an encapsulated\n        dataset. The Basic Offset Table item should be present and the\n        Sequence Delimiter item may or may not be present.\n\n    Yields\n    ------\n    bytes\n        A frame contained in the encapsulated pixel data.\n\n    References\n    ----------\n    DICOM Standard Part 5, Annex A\n    \"\"\"\n    for fragmented_frame in generate_pixel_data(bytestream):\n        yield b''.join(fragmented_frame)\n", "tokens": ["pydicom", "encaps", "py", "def", "generate_pixel_data_frame", "bytestream", "yield", "an", "encapsulated", "pixel", "data", "frame", "as", "bytes", "parameters", "bytestream", "bytes", "the", "value", "of", "the", "7fe0", "0010", "pixel", "data", "element", "from", "an", "encapsulated", "dataset", "the", "basic", "offset", "table", "item", "should", "be", "present", "and", "the", "sequence", "delimiter", "item", "may", "or", "may", "not", "be", "present", "yields", "bytes", "a", "frame", "contained", "in", "the", "encapsulated", "pixel", "data", "references", "dicom", "standard", "part", "5", "annex", "a", "for", "fragmented_frame", "in", "generate_pixel_data", "bytestream", "yield", "b", "join", "fragmented_frame"], "doc_len": 75}
{"doc_id": "pydicom/encaps.py::generate_pixel_data", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "generate_pixel_data", "text": "文件路径: pydicom/encaps.py\ndef generate_pixel_data(bytestream):\n    \"\"\"Yield an encapsulated pixel data frame as a tuples of bytes.\n\n    For the following transfer syntaxes, a fragment may not contain encoded\n    data from more than one frame. However data from one frame may span\n    multiple fragments.\n\n    * 1.2.840.10008.1.2.4.50 - JPEG Baseline (Process 1)\n    * 1.2.840.10008.1.2.4.51 - JPEG Baseline (Process 2 and 4)\n    * 1.2.840.10008.1.2.4.57 - JPEG Lossless, Non-Hierarchical (Process 14)\n    * 1.2.840.10008.1.2.4.70 - JPEG Lossless, Non-Hierarchical, First-Order\n      Prediction (Process 14 [Selection Value 1])\n    * 1.2.840.10008.1.2.4.80 - JPEG-LS Lossless Image Compression\n    * 1.2.840.10008.1.2.4.81 - JPEG-LS Lossy (Near-Lossless) Image Compression\n    * 1.2.840.10008.1.2.4.90 - JPEG 2000 Image Compression (Lossless Only)\n    * 1.2.840.10008.1.2.4.91 - JPEG 2000 Image Compression\n    * 1.2.840.10008.1.2.4.92 - JPEG 2000 Part 2 Multi-component Image\n      Compression (Lossless Only)\n    * 1.2.840.10008.1.2.4.93 - JPEG 2000 Part 2 Multi-component Image\n      Compression\n\n    For the following transfer syntaxes, each frame shall be encoded in one and\n    only one fragment.\n\n    * 1.2.840.10008.1.2.5 - RLE Lossless\n\n    Parameters\n    ----------\n    bytestream : bytes\n        The value of the (7fe0, 0010) *Pixel Data* element from an encapsulated\n        dataset. The Basic Offset Table item should be present and the\n        Sequence Delimiter item may or may not be present.\n\n    Yields\n    -------\n    tuple of bytes\n        A tuple representing an encapsulated pixel data frame, with the\n        contents of the tuple the frame's fragmented data.\n\n    References\n    ----------\n    DICOM Standard Part 5, Annex A\n    \"\"\"\n    fp = DicomBytesIO(bytestream)\n    fp.is_little_endian = True\n\n    # `offsets` is a list of the offsets to the first fragment in each frame\n    offsets = get_frame_offsets(fp)\n    # Doesn't actually matter what the last offset value is, as long as its\n    # greater than the total number of bytes in the fragments\n    offsets.append(len(bytestream))\n\n    frame = []\n    frame_length = 0\n    frame_number = 0\n    for fragment in generate_pixel_data_fragment(fp):\n        if frame_length < offsets[frame_number + 1]:\n            frame.append(fragment)\n        else:\n            yield tuple(frame)\n            frame = [fragment]\n            frame_number += 1\n\n        frame_length += len(fragment) + 8\n\n    # Yield the final frame - required here because the frame_length will\n    # never be greater than offsets[-1] and thus never trigger the final yield\n    # within the for block\n    yield tuple(frame)\n", "tokens": ["pydicom", "encaps", "py", "def", "generate_pixel_data", "bytestream", "yield", "an", "encapsulated", "pixel", "data", "frame", "as", "a", "tuples", "of", "bytes", "for", "the", "following", "transfer", "syntaxes", "a", "fragment", "may", "not", "contain", "encoded", "data", "from", "more", "than", "one", "frame", "however", "data", "from", "one", "frame", "may", "span", "multiple", "fragments", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "1", "2", "840", "10008", "1", "2", "4", "51", "jpeg", "baseline", "process", "2", "and", "4", "1", "2", "840", "10008", "1", "2", "4", "57", "jpeg", "lossless", "non", "hierarchical", "process", "14", "1", "2", "840", "10008", "1", "2", "4", "70", "jpeg", "lossless", "non", "hierarchical", "first", "order", "prediction", "process", "14", "selection", "value", "1", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "1", "2", "840", "10008", "1", "2", "4", "81", "jpeg", "ls", "lossy", "near", "lossless", "image", "compression", "1", "2", "840", "10008", "1", "2", "4", "90", "jpeg", "2000", "image", "compression", "lossless", "only", "1", "2", "840", "10008", "1", "2", "4", "91", "jpeg", "2000", "image", "compression", "1", "2", "840", "10008", "1", "2", "4", "92", "jpeg", "2000", "part", "2", "multi", "component", "image", "compression", "lossless", "only", "1", "2", "840", "10008", "1", "2", "4", "93", "jpeg", "2000", "part", "2", "multi", "component", "image", "compression", "for", "the", "following", "transfer", "syntaxes", "each", "frame", "shall", "be", "encoded", "in", "one", "and", "only", "one", "fragment", "1", "2", "840", "10008", "1", "2", "5", "rle", "lossless", "parameters", "bytestream", "bytes", "the", "value", "of", "the", "7fe0", "0010", "pixel", "data", "element", "from", "an", "encapsulated", "dataset", "the", "basic", "offset", "table", "item", "should", "be", "present", "and", "the", "sequence", "delimiter", "item", "may", "or", "may", "not", "be", "present", "yields", "tuple", "of", "bytes", "a", "tuple", "representing", "an", "encapsulated", "pixel", "data", "frame", "with", "the", "contents", "of", "the", "tuple", "the", "frame", "s", "fragmented", "data", "references", "dicom", "standard", "part", "5", "annex", "a", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "offsets", "is", "a", "list", "of", "the", "offsets", "to", "the", "first", "fragment", "in", "each", "frame", "offsets", "get_frame_offsets", "fp", "doesn", "t", "actually", "matter", "what", "the", "last", "offset", "value", "is", "as", "long", "as", "its", "greater", "than", "the", "total", "number", "of", "bytes", "in", "the", "fragments", "offsets", "append", "len", "bytestream", "frame", "frame_length", "0", "frame_number", "0", "for", "fragment", "in", "generate_pixel_data_fragment", "fp", "if", "frame_length", "offsets", "frame_number", "1", "frame", "append", "fragment", "else", "yield", "tuple", "frame", "frame", "fragment", "frame_number", "1", "frame_length", "len", "fragment", "8", "yield", "the", "final", "frame", "required", "here", "because", "the", "frame_length", "will", "never", "be", "greater", "than", "offsets", "1", "and", "thus", "never", "trigger", "the", "final", "yield", "within", "the", "for", "block", "yield", "tuple", "frame"], "doc_len": 392}
{"doc_id": "pydicom/encaps.py::decode_data_sequence", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "decode_data_sequence", "text": "文件路径: pydicom/encaps.py\ndef decode_data_sequence(data):\n    \"\"\"Read encapsulated data and return a list of strings.\n\n    Parameters\n    ----------\n    data : str\n        String of encapsulated data, typically dataset.PixelData\n\n    Returns\n    -------\n    list of bytes\n        All fragments in a list of byte strings\n    \"\"\"\n    # Convert data into a memory-mapped file\n    with DicomBytesIO(data) as fp:\n\n        # DICOM standard requires this\n        fp.is_little_endian = True\n        BasicOffsetTable = read_item(fp)  # NOQA\n        seq = []\n\n        while True:\n            item = read_item(fp)\n\n            # None is returned if get to Sequence Delimiter\n            if not item:\n                break\n            seq.append(item)\n\n        # XXX should\n        return seq\n", "tokens": ["pydicom", "encaps", "py", "def", "decode_data_sequence", "data", "read", "encapsulated", "data", "and", "return", "a", "list", "of", "strings", "parameters", "data", "str", "string", "of", "encapsulated", "data", "typically", "dataset", "pixeldata", "returns", "list", "of", "bytes", "all", "fragments", "in", "a", "list", "of", "byte", "strings", "convert", "data", "into", "a", "memory", "mapped", "file", "with", "dicombytesio", "data", "as", "fp", "dicom", "standard", "requires", "this", "fp", "is_little_endian", "true", "basicoffsettable", "read_item", "fp", "noqa", "seq", "while", "true", "item", "read_item", "fp", "none", "is", "returned", "if", "get", "to", "sequence", "delimiter", "if", "not", "item", "break", "seq", "append", "item", "xxx", "should", "return", "seq"], "doc_len": 85}
{"doc_id": "pydicom/encaps.py::defragment_data", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "defragment_data", "text": "文件路径: pydicom/encaps.py\ndef defragment_data(data):\n    \"\"\"Read encapsulated data and return the fragments as one continuous string.\n\n    Parameters\n    ----------\n    data : list of bytes\n        The encapsulated pixel data fragments.\n\n    Returns\n    -------\n    bytes\n        All fragments concatenated together.\n    \"\"\"\n    return b\"\".join(decode_data_sequence(data))\n", "tokens": ["pydicom", "encaps", "py", "def", "defragment_data", "data", "read", "encapsulated", "data", "and", "return", "the", "fragments", "as", "one", "continuous", "string", "parameters", "data", "list", "of", "bytes", "the", "encapsulated", "pixel", "data", "fragments", "returns", "bytes", "all", "fragments", "concatenated", "together", "return", "b", "join", "decode_data_sequence", "data"], "doc_len": 38}
{"doc_id": "pydicom/encaps.py::read_item", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "read_item", "text": "文件路径: pydicom/encaps.py\ndef read_item(fp):\n    \"\"\"Read and return a single Item in the fragmented data stream.\n\n    Parameters\n    ----------\n    fp : pydicom.filebase.DicomIO\n        The file-like to read the item from.\n\n    Returns\n    -------\n    bytes\n        The Item's raw bytes (value?).\n    \"\"\"\n\n    logger = pydicom.config.logger\n    try:\n        tag = fp.read_tag()\n\n    # already read delimiter before passing data here\n    # so should just run out\n    except EOFError:\n        return None\n\n    # No more items, time for sequence to stop reading\n    if tag == SequenceDelimiterTag:\n        length = fp.read_UL()\n        logger.debug(\n            \"%04x: Sequence Delimiter, length 0x%x\",\n            fp.tell() - 8,\n            length)\n\n        if length != 0:\n            logger.warning(\n                \"Expected 0x00000000 after delimiter, found 0x%x,\"\n                \" at data position 0x%x\",\n                length,\n                fp.tell() - 4)\n        return None\n\n    if tag != ItemTag:\n        logger.warning(\n            \"Expected Item with tag %s at data position 0x%x\",\n            ItemTag,\n            fp.tell() - 4)\n        length = fp.read_UL()\n    else:\n        length = fp.read_UL()\n        logger.debug(\n            \"%04x: Item, length 0x%x\",\n            fp.tell() - 8,\n            length)\n\n    if length == 0xFFFFFFFF:\n        raise ValueError(\n            \"Encapsulated data fragment had Undefined Length\"\n            \" at data position 0x%x\" % (fp.tell() - 4, ))\n\n    item_data = fp.read(length)\n    return item_data\n", "tokens": ["pydicom", "encaps", "py", "def", "read_item", "fp", "read", "and", "return", "a", "single", "item", "in", "the", "fragmented", "data", "stream", "parameters", "fp", "pydicom", "filebase", "dicomio", "the", "file", "like", "to", "read", "the", "item", "from", "returns", "bytes", "the", "item", "s", "raw", "bytes", "value", "logger", "pydicom", "config", "logger", "try", "tag", "fp", "read_tag", "already", "read", "delimiter", "before", "passing", "data", "here", "so", "should", "just", "run", "out", "except", "eoferror", "return", "none", "no", "more", "items", "time", "for", "sequence", "to", "stop", "reading", "if", "tag", "sequencedelimitertag", "length", "fp", "read_ul", "logger", "debug", "04x", "sequence", "delimiter", "length", "0x", "x", "fp", "tell", "8", "length", "if", "length", "0", "logger", "warning", "expected", "0x00000000", "after", "delimiter", "found", "0x", "x", "at", "data", "position", "0x", "x", "length", "fp", "tell", "4", "return", "none", "if", "tag", "itemtag", "logger", "warning", "expected", "item", "with", "tag", "s", "at", "data", "position", "0x", "x", "itemtag", "fp", "tell", "4", "length", "fp", "read_ul", "else", "length", "fp", "read_ul", "logger", "debug", "04x", "item", "length", "0x", "x", "fp", "tell", "8", "length", "if", "length", "0xffffffff", "raise", "valueerror", "encapsulated", "data", "fragment", "had", "undefined", "length", "at", "data", "position", "0x", "x", "fp", "tell", "4", "item_data", "fp", "read", "length", "return", "item_data"], "doc_len": 174}
{"doc_id": "pydicom/encaps.py::fragment_frame", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "fragment_frame", "text": "文件路径: pydicom/encaps.py\ndef fragment_frame(frame, nr_fragments=1):\n    \"\"\"Yield one or more fragments from `frame`.\n\n    Parameters\n    ----------\n    frame : bytes\n        The data to fragment.\n    nr_fragments : int, optional\n        The number of fragments (default 1).\n\n    Yields\n    ------\n    bytes\n        The fragmented data, with all fragments as an even number of bytes\n        greater than or equal to two.\n\n    Notes\n    -----\n\n    * All items containing an encoded fragment shall be made of an even number\n      of bytes greater than or equal to two.\n    * The last fragment of a frame may be padded, if necessary to meet the\n      sequence item format requirements of the DICOM Standard.\n    * Any necessary padding may be appended after the end of image marker.\n    * Encapsulated Pixel Data has the Value Representation OB.\n    * Values with a VR of OB shall be padded with a single trailing NULL byte\n      value (0x00) to achieve even length.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Section 6.2 and Annex A.4\n    \"\"\"\n    frame_length = len(frame)\n    # Add 1 to fix odd length frames not being caught\n    if nr_fragments > (frame_length + 1) / 2.0:\n        raise ValueError('Too many fragments requested (the minimum fragment '\n                         'size is 2 bytes)')\n\n    length = int(frame_length / nr_fragments)\n\n    # Each item shall be an even number of bytes\n    if length % 2:\n        length += 1\n\n    # 1st to (N-1)th fragment\n    for offset in range(0, length * (nr_fragments - 1), length):\n        yield frame[offset:offset + length]\n\n    # Nth fragment\n    offset = length * (nr_fragments - 1)\n    fragment = frame[offset:]\n\n    # Pad last fragment if needed to make it even\n    if (frame_length - offset) % 2:\n        fragment += b'\\x00'\n\n    yield fragment\n", "tokens": ["pydicom", "encaps", "py", "def", "fragment_frame", "frame", "nr_fragments", "1", "yield", "one", "or", "more", "fragments", "from", "frame", "parameters", "frame", "bytes", "the", "data", "to", "fragment", "nr_fragments", "int", "optional", "the", "number", "of", "fragments", "default", "1", "yields", "bytes", "the", "fragmented", "data", "with", "all", "fragments", "as", "an", "even", "number", "of", "bytes", "greater", "than", "or", "equal", "to", "two", "notes", "all", "items", "containing", "an", "encoded", "fragment", "shall", "be", "made", "of", "an", "even", "number", "of", "bytes", "greater", "than", "or", "equal", "to", "two", "the", "last", "fragment", "of", "a", "frame", "may", "be", "padded", "if", "necessary", "to", "meet", "the", "sequence", "item", "format", "requirements", "of", "the", "dicom", "standard", "any", "necessary", "padding", "may", "be", "appended", "after", "the", "end", "of", "image", "marker", "encapsulated", "pixel", "data", "has", "the", "value", "representation", "ob", "values", "with", "a", "vr", "of", "ob", "shall", "be", "padded", "with", "a", "single", "trailing", "null", "byte", "value", "0x00", "to", "achieve", "even", "length", "references", "dicom", "standard", "part", "5", "section", "6", "2", "and", "annex", "a", "4", "frame_length", "len", "frame", "add", "1", "to", "fix", "odd", "length", "frames", "not", "being", "caught", "if", "nr_fragments", "frame_length", "1", "2", "0", "raise", "valueerror", "too", "many", "fragments", "requested", "the", "minimum", "fragment", "size", "is", "2", "bytes", "length", "int", "frame_length", "nr_fragments", "each", "item", "shall", "be", "an", "even", "number", "of", "bytes", "if", "length", "2", "length", "1", "1st", "to", "n", "1", "th", "fragment", "for", "offset", "in", "range", "0", "length", "nr_fragments", "1", "length", "yield", "frame", "offset", "offset", "length", "nth", "fragment", "offset", "length", "nr_fragments", "1", "fragment", "frame", "offset", "pad", "last", "fragment", "if", "needed", "to", "make", "it", "even", "if", "frame_length", "offset", "2", "fragment", "b", "x00", "yield", "fragment"], "doc_len": 245}
{"doc_id": "pydicom/encaps.py::itemise_fragment", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "itemise_fragment", "text": "文件路径: pydicom/encaps.py\ndef itemise_fragment(fragment):\n    \"\"\"Return an itemised `fragment`.\n\n    Parameters\n    ----------\n    fragment : bytes\n        The fragment to itemise.\n\n    Returns\n    -------\n    bytes\n        The itemised fragment.\n\n    Notes\n    -----\n\n    * The encoding of the item shall be in Little Endian.\n    * Each fragment is encapsulated as a DICOM Item with tag (FFFE,E000), then\n      a 4 byte length.\n    \"\"\"\n    # item tag (fffe,e000)\n    item = bytes(b'\\xFE\\xFF\\x00\\xE0')\n    # fragment length '<I' little endian, 4 byte unsigned int\n    item += pack('<I', len(fragment))\n    # fragment data\n    item += fragment\n\n    return item\n", "tokens": ["pydicom", "encaps", "py", "def", "itemise_fragment", "fragment", "return", "an", "itemised", "fragment", "parameters", "fragment", "bytes", "the", "fragment", "to", "itemise", "returns", "bytes", "the", "itemised", "fragment", "notes", "the", "encoding", "of", "the", "item", "shall", "be", "in", "little", "endian", "each", "fragment", "is", "encapsulated", "as", "a", "dicom", "item", "with", "tag", "fffe", "e000", "then", "a", "4", "byte", "length", "item", "tag", "fffe", "e000", "item", "bytes", "b", "xfe", "xff", "x00", "xe0", "fragment", "length", "i", "little", "endian", "4", "byte", "unsigned", "int", "item", "pack", "i", "len", "fragment", "fragment", "data", "item", "fragment", "return", "item"], "doc_len": 81}
{"doc_id": "pydicom/encaps.py::itemise_frame", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "itemise_frame", "text": "文件路径: pydicom/encaps.py\ndef itemise_frame(frame, nr_fragments=1):\n    \"\"\"Yield items generated from `frame`.\n\n    Parameters\n    ----------\n    frame : bytes\n        The data to fragment and itemise.\n    nr_fragments : int, optional\n        The number of fragments/items (default 1).\n\n    Yields\n    ------\n    bytes\n        An itemised fragment of the frame, encoded as little endian.\n\n    Notes\n    -----\n\n    * The encoding of the items shall be in Little Endian.\n    * Each fragment is encapsulated as a DICOM Item with tag (FFFE,E000), then\n      a 4 byte length.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Section 7.5 and Annex A.4\n    \"\"\"\n    for fragment in fragment_frame(frame, nr_fragments):\n        yield itemise_fragment(fragment)\n", "tokens": ["pydicom", "encaps", "py", "def", "itemise_frame", "frame", "nr_fragments", "1", "yield", "items", "generated", "from", "frame", "parameters", "frame", "bytes", "the", "data", "to", "fragment", "and", "itemise", "nr_fragments", "int", "optional", "the", "number", "of", "fragments", "items", "default", "1", "yields", "bytes", "an", "itemised", "fragment", "of", "the", "frame", "encoded", "as", "little", "endian", "notes", "the", "encoding", "of", "the", "items", "shall", "be", "in", "little", "endian", "each", "fragment", "is", "encapsulated", "as", "a", "dicom", "item", "with", "tag", "fffe", "e000", "then", "a", "4", "byte", "length", "references", "dicom", "standard", "part", "5", "section", "7", "5", "and", "annex", "a", "4", "for", "fragment", "in", "fragment_frame", "frame", "nr_fragments", "yield", "itemise_fragment", "fragment"], "doc_len": 93}
{"doc_id": "pydicom/encaps.py::encapsulate", "file_path": "pydicom/encaps.py", "class_name": null, "func_name": "encapsulate", "text": "文件路径: pydicom/encaps.py\ndef encapsulate(frames, fragments_per_frame=1, has_bot=True):\n    \"\"\"Return encapsulated `frames`.\n\n    Data will be encapsulated with a Basic Offset Table Item at the beginning,\n    then one or more fragment Items. Each item will be of even length and the\n    final fragment of each frame may be padded with 0x00 if required.\n\n    Parameters\n    ----------\n    frames : list of bytes\n        The frame data to encapsulate.\n    fragments_per_frame : int, optional\n        The number of fragments to use for each frame (default 1).\n    has_bot : bool, optional\n        True to include values in the Basic Offset Table, False otherwise\n        (default True). If `fragments_per_frame` is not 1 then its strongly\n        recommended that this be True.\n\n    Returns\n    -------\n    bytes\n        The encapsulated data.\n\n    Notes\n    -----\n\n    * The encoding shall be in Little Endian.\n    * Each fragment is encapsulated as a DICOM Item with tag (FFFE,E000), then\n      a 4 byte length.\n    * The first item shall be a Basic Offset Table item.\n    * The Basic Offset Table item, however, is not required to have a value.\n    * If no value is present, the Basic Offset Table length is 0.\n    * If the value is present, it shall contain concatenated 32-bit\n      unsigned integer values that are byte offsets to the first byte of the\n      Item tag of the first fragment in each frame as measured from the first\n      byte of the first Item tag following the Basic Offset Table Item.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Section 7.5 and Annex A.4\n    \"\"\"\n    no_frames = len(frames)\n    output = bytearray()\n\n    # Add the Basic Offset Table Item\n    # Add the tag\n    output.extend(b'\\xFE\\xFF\\x00\\xE0')\n    if has_bot:\n        # Add the length\n        output.extend(pack('<I', 4 * no_frames))\n        # Reserve 4 x len(frames) bytes for the offsets\n        output.extend(b'\\xFF\\xFF\\xFF\\xFF' * no_frames)\n    else:\n        # Add the length\n        output.extend(pack('<I', 0))\n\n    bot_offsets = [0]\n    for ii, frame in enumerate(frames):\n        # `itemised_length` is the total length of each itemised frame\n        itemised_length = 0\n        for item in itemise_frame(frame, fragments_per_frame):\n            itemised_length += len(item)\n            output.extend(item)\n\n        # Update the list of frame offsets\n        bot_offsets.append(bot_offsets[ii] + itemised_length)\n\n    if has_bot:\n        # Go back and write the frame offsets - don't need the last offset\n        output[8:8 + 4 * no_frames] = pack('<{}I'.format(no_frames),\n                                           *bot_offsets[:-1])\n\n    return bytes(output)\n", "tokens": ["pydicom", "encaps", "py", "def", "encapsulate", "frames", "fragments_per_frame", "1", "has_bot", "true", "return", "encapsulated", "frames", "data", "will", "be", "encapsulated", "with", "a", "basic", "offset", "table", "item", "at", "the", "beginning", "then", "one", "or", "more", "fragment", "items", "each", "item", "will", "be", "of", "even", "length", "and", "the", "final", "fragment", "of", "each", "frame", "may", "be", "padded", "with", "0x00", "if", "required", "parameters", "frames", "list", "of", "bytes", "the", "frame", "data", "to", "encapsulate", "fragments_per_frame", "int", "optional", "the", "number", "of", "fragments", "to", "use", "for", "each", "frame", "default", "1", "has_bot", "bool", "optional", "true", "to", "include", "values", "in", "the", "basic", "offset", "table", "false", "otherwise", "default", "true", "if", "fragments_per_frame", "is", "not", "1", "then", "its", "strongly", "recommended", "that", "this", "be", "true", "returns", "bytes", "the", "encapsulated", "data", "notes", "the", "encoding", "shall", "be", "in", "little", "endian", "each", "fragment", "is", "encapsulated", "as", "a", "dicom", "item", "with", "tag", "fffe", "e000", "then", "a", "4", "byte", "length", "the", "first", "item", "shall", "be", "a", "basic", "offset", "table", "item", "the", "basic", "offset", "table", "item", "however", "is", "not", "required", "to", "have", "a", "value", "if", "no", "value", "is", "present", "the", "basic", "offset", "table", "length", "is", "0", "if", "the", "value", "is", "present", "it", "shall", "contain", "concatenated", "32", "bit", "unsigned", "integer", "values", "that", "are", "byte", "offsets", "to", "the", "first", "byte", "of", "the", "item", "tag", "of", "the", "first", "fragment", "in", "each", "frame", "as", "measured", "from", "the", "first", "byte", "of", "the", "first", "item", "tag", "following", "the", "basic", "offset", "table", "item", "references", "dicom", "standard", "part", "5", "section", "7", "5", "and", "annex", "a", "4", "no_frames", "len", "frames", "output", "bytearray", "add", "the", "basic", "offset", "table", "item", "add", "the", "tag", "output", "extend", "b", "xfe", "xff", "x00", "xe0", "if", "has_bot", "add", "the", "length", "output", "extend", "pack", "i", "4", "no_frames", "reserve", "4", "x", "len", "frames", "bytes", "for", "the", "offsets", "output", "extend", "b", "xff", "xff", "xff", "xff", "no_frames", "else", "add", "the", "length", "output", "extend", "pack", "i", "0", "bot_offsets", "0", "for", "ii", "frame", "in", "enumerate", "frames", "itemised_length", "is", "the", "total", "length", "of", "each", "itemised", "frame", "itemised_length", "0", "for", "item", "in", "itemise_frame", "frame", "fragments_per_frame", "itemised_length", "len", "item", "output", "extend", "item", "update", "the", "list", "of", "frame", "offsets", "bot_offsets", "append", "bot_offsets", "ii", "itemised_length", "if", "has_bot", "go", "back", "and", "write", "the", "frame", "offsets", "don", "t", "need", "the", "last", "offset", "output", "8", "8", "4", "no_frames", "pack", "i", "format", "no_frames", "bot_offsets", "1", "return", "bytes", "output"], "doc_len": 362}
{"doc_id": "pydicom/errors.py::InvalidDicomError.__init__", "file_path": "pydicom/errors.py", "class_name": "InvalidDicomError", "func_name": "__init__", "text": "文件路径: pydicom/errors.py, 类名: InvalidDicomError\n    def __init__(self, *args):\n        if not args:\n            args = ('The specified file is not a valid DICOM file.', )\n        Exception.__init__(self, *args)\n", "tokens": ["pydicom", "errors", "py", "invaliddicomerror", "def", "__init__", "self", "args", "if", "not", "args", "args", "the", "specified", "file", "is", "not", "a", "valid", "dicom", "file", "exception", "__init__", "self", "args"], "doc_len": 25}
{"doc_id": "pydicom/filebase.py::DicomIO.__init__", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "__init__", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def __init__(self, *args, **kwargs):\n        # start with this by default\n        self._implicit_VR = True\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "__init__", "self", "args", "kwargs", "start", "with", "this", "by", "default", "self", "_implicit_vr", "true"], "doc_len": 17}
{"doc_id": "pydicom/filebase.py::DicomIO.read_le_tag", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_le_tag", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_le_tag(self):\n        \"\"\"Read and return two unsigned shorts (little endian)\n           from the file.\"\"\"\n        bytes_read = self.read(4, need_exact_length=True)\n        return unpack(b\"<HH\", bytes_read)\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_le_tag", "self", "read", "and", "return", "two", "unsigned", "shorts", "little", "endian", "from", "the", "file", "bytes_read", "self", "read", "4", "need_exact_length", "true", "return", "unpack", "b", "hh", "bytes_read"], "doc_len": 29}
{"doc_id": "pydicom/filebase.py::DicomIO.read_be_tag", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_be_tag", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_be_tag(self):\n        \"\"\"Read and return two unsigned shorts (big endian)\n           from the file.\"\"\"\n        bytes_read = self.read(4, need_exact_length=True)\n        return unpack(b\">HH\", bytes_read)\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_be_tag", "self", "read", "and", "return", "two", "unsigned", "shorts", "big", "endian", "from", "the", "file", "bytes_read", "self", "read", "4", "need_exact_length", "true", "return", "unpack", "b", "hh", "bytes_read"], "doc_len": 29}
{"doc_id": "pydicom/filebase.py::DicomIO.write_tag", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "write_tag", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def write_tag(self, tag):\n        \"\"\"Write a dicom tag (two unsigned shorts) to the file.\"\"\"\n        # make sure is an instance of class, not just a tuple or int\n        if not isinstance(tag, BaseTag):\n            tag = Tag(tag)\n        self.write_US(tag.group)\n        self.write_US(tag.element)\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "write_tag", "self", "tag", "write", "a", "dicom", "tag", "two", "unsigned", "shorts", "to", "the", "file", "make", "sure", "is", "an", "instance", "of", "class", "not", "just", "a", "tuple", "or", "int", "if", "not", "isinstance", "tag", "basetag", "tag", "tag", "tag", "self", "write_us", "tag", "group", "self", "write_us", "tag", "element"], "doc_len": 47}
{"doc_id": "pydicom/filebase.py::DicomIO.read_leUS", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_leUS", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_leUS(self):\n        \"\"\"Return an unsigned short from the file\n           with little endian byte order\"\"\"\n        return unpack(b\"<H\", self.read(2))[0]\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_leus", "self", "return", "an", "unsigned", "short", "from", "the", "file", "with", "little", "endian", "byte", "order", "return", "unpack", "b", "h", "self", "read", "2", "0"], "doc_len": 27}
{"doc_id": "pydicom/filebase.py::DicomIO.read_beUS", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_beUS", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_beUS(self):\n        \"\"\"Return an unsigned short from the file\n           with big endian byte order\"\"\"\n        return unpack(b\">H\", self.read(2))[0]\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_beus", "self", "return", "an", "unsigned", "short", "from", "the", "file", "with", "big", "endian", "byte", "order", "return", "unpack", "b", "h", "self", "read", "2", "0"], "doc_len": 27}
{"doc_id": "pydicom/filebase.py::DicomIO.read_leUL", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_leUL", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_leUL(self):\n        \"\"\"Return an unsigned long read with\n           little endian byte order\"\"\"\n        return unpack(b\"<L\", self.read(4))[0]\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_leul", "self", "return", "an", "unsigned", "long", "read", "with", "little", "endian", "byte", "order", "return", "unpack", "b", "l", "self", "read", "4", "0"], "doc_len": 25}
{"doc_id": "pydicom/filebase.py::DicomIO.read", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read(self, length=None, need_exact_length=False):\n        \"\"\"Reads the required length, returns\n        EOFError if gets less\n\n        If length is None, then read all bytes\n        \"\"\"\n        parent_read = self.parent_read  # super(DicomIO, self).read\n        if length is None:\n            return parent_read()  # get all of it\n        bytes_read = parent_read(length)\n        if len(bytes_read) < length and need_exact_length:\n            # Didn't get all the desired bytes. Keep trying to get the rest.\n            # If reading across network, might want to add a delay here\n            attempts = 0\n            max_reads = self.max_read_attempts\n            while attempts < max_reads and len(bytes_read) < length:\n                bytes_read += parent_read(length - len(bytes_read))\n                attempts += 1\n            num_bytes = len(bytes_read)\n            if num_bytes < length:\n                start_pos = self.tell() - num_bytes\n                msg = (\"Unexpected end of file. Read {0} bytes of {1} \"\n                       \"expected starting at position 0x{2:x}\".format(\n                           len(bytes_read), length, start_pos))\n                raise EOFError(msg)\n        return bytes_read\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read", "self", "length", "none", "need_exact_length", "false", "reads", "the", "required", "length", "returns", "eoferror", "if", "gets", "less", "if", "length", "is", "none", "then", "read", "all", "bytes", "parent_read", "self", "parent_read", "super", "dicomio", "self", "read", "if", "length", "is", "none", "return", "parent_read", "get", "all", "of", "it", "bytes_read", "parent_read", "length", "if", "len", "bytes_read", "length", "and", "need_exact_length", "didn", "t", "get", "all", "the", "desired", "bytes", "keep", "trying", "to", "get", "the", "rest", "if", "reading", "across", "network", "might", "want", "to", "add", "a", "delay", "here", "attempts", "0", "max_reads", "self", "max_read_attempts", "while", "attempts", "max_reads", "and", "len", "bytes_read", "length", "bytes_read", "parent_read", "length", "len", "bytes_read", "attempts", "1", "num_bytes", "len", "bytes_read", "if", "num_bytes", "length", "start_pos", "self", "tell", "num_bytes", "msg", "unexpected", "end", "of", "file", "read", "0", "bytes", "of", "1", "expected", "starting", "at", "position", "0x", "2", "x", "format", "len", "bytes_read", "length", "start_pos", "raise", "eoferror", "msg", "return", "bytes_read"], "doc_len": 134}
{"doc_id": "pydicom/filebase.py::DicomIO.write_leUS", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "write_leUS", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def write_leUS(self, val):\n        \"\"\"Write an unsigned short with little endian byte order\"\"\"\n        self.write(pack(b\"<H\", val))\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "write_leus", "self", "val", "write", "an", "unsigned", "short", "with", "little", "endian", "byte", "order", "self", "write", "pack", "b", "h", "val"], "doc_len": 23}
{"doc_id": "pydicom/filebase.py::DicomIO.write_leUL", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "write_leUL", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def write_leUL(self, val):\n        \"\"\"Write an unsigned long with little endian byte order\"\"\"\n        self.write(pack(b\"<L\", val))\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "write_leul", "self", "val", "write", "an", "unsigned", "long", "with", "little", "endian", "byte", "order", "self", "write", "pack", "b", "l", "val"], "doc_len": 23}
{"doc_id": "pydicom/filebase.py::DicomIO.write_beUS", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "write_beUS", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def write_beUS(self, val):\n        \"\"\"Write an unsigned short with big endian byte order\"\"\"\n        self.write(pack(b\">H\", val))\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "write_beus", "self", "val", "write", "an", "unsigned", "short", "with", "big", "endian", "byte", "order", "self", "write", "pack", "b", "h", "val"], "doc_len": 23}
{"doc_id": "pydicom/filebase.py::DicomIO.write_beUL", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "write_beUL", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def write_beUL(self, val):\n        \"\"\"Write an unsigned long with big endian byte order\"\"\"\n        self.write(pack(b\">L\", val))\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "write_beul", "self", "val", "write", "an", "unsigned", "long", "with", "big", "endian", "byte", "order", "self", "write", "pack", "b", "l", "val"], "doc_len": 23}
{"doc_id": "pydicom/filebase.py::DicomIO.read_beUL", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "read_beUL", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def read_beUL(self):\n        \"\"\"Return an unsigned long read with big endian byte order\"\"\"\n        return unpack(b\">L\", self.read(4))[0]\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "read_beul", "self", "return", "an", "unsigned", "long", "read", "with", "big", "endian", "byte", "order", "return", "unpack", "b", "l", "self", "read", "4", "0"], "doc_len": 25}
{"doc_id": "pydicom/filebase.py::DicomIO.is_little_endian", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "is_little_endian", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def is_little_endian(self):\n        return self._little_endian\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "is_little_endian", "self", "return", "self", "_little_endian"], "doc_len": 10}
{"doc_id": "pydicom/filebase.py::DicomIO.is_little_endian", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "is_little_endian", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def is_little_endian(self, value):\n        self._little_endian = value\n        if value:  # Little Endian\n            self.read_US = self.read_leUS\n            self.read_UL = self.read_leUL\n            self.write_US = self.write_leUS\n            self.write_UL = self.write_leUL\n            self.read_tag = self.read_le_tag\n        else:  # Big Endian\n            self.read_US = self.read_beUS\n            self.read_UL = self.read_beUL\n            self.write_US = self.write_beUS\n            self.write_UL = self.write_beUL\n            self.read_tag = self.read_be_tag\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "is_little_endian", "self", "value", "self", "_little_endian", "value", "if", "value", "little", "endian", "self", "read_us", "self", "read_leus", "self", "read_ul", "self", "read_leul", "self", "write_us", "self", "write_leus", "self", "write_ul", "self", "write_leul", "self", "read_tag", "self", "read_le_tag", "else", "big", "endian", "self", "read_us", "self", "read_beus", "self", "read_ul", "self", "read_beul", "self", "write_us", "self", "write_beus", "self", "write_ul", "self", "write_beul", "self", "read_tag", "self", "read_be_tag"], "doc_len": 58}
{"doc_id": "pydicom/filebase.py::DicomIO.is_implicit_VR", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "is_implicit_VR", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def is_implicit_VR(self):\n        return self._implicit_VR\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "is_implicit_vr", "self", "return", "self", "_implicit_vr"], "doc_len": 10}
{"doc_id": "pydicom/filebase.py::DicomIO.is_implicit_VR", "file_path": "pydicom/filebase.py", "class_name": "DicomIO", "func_name": "is_implicit_VR", "text": "文件路径: pydicom/filebase.py, 类名: DicomIO\n    def is_implicit_VR(self, value):\n        self._implicit_VR = value\n", "tokens": ["pydicom", "filebase", "py", "dicomio", "def", "is_implicit_vr", "self", "value", "self", "_implicit_vr", "value"], "doc_len": 11}
{"doc_id": "pydicom/filebase.py::DicomFileLike.__init__", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "__init__", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def __init__(self, file_like_obj, *args, **kwargs):\n        super(DicomFileLike, self).__init__(*args, **kwargs)\n        self.parent = file_like_obj\n        self.parent_read = getattr(file_like_obj, \"read\", self.no_read)\n        self.write = getattr(file_like_obj, \"write\", self.no_write)\n        self.seek = getattr(file_like_obj, \"seek\", self.no_seek)\n        self.tell = file_like_obj.tell\n        self.close = file_like_obj.close\n        self.name = getattr(file_like_obj, 'name', '<no filename>')\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "__init__", "self", "file_like_obj", "args", "kwargs", "super", "dicomfilelike", "self", "__init__", "args", "kwargs", "self", "parent", "file_like_obj", "self", "parent_read", "getattr", "file_like_obj", "read", "self", "no_read", "self", "write", "getattr", "file_like_obj", "write", "self", "no_write", "self", "seek", "getattr", "file_like_obj", "seek", "self", "no_seek", "self", "tell", "file_like_obj", "tell", "self", "close", "file_like_obj", "close", "self", "name", "getattr", "file_like_obj", "name", "no", "filename"], "doc_len": 55}
{"doc_id": "pydicom/filebase.py::DicomFileLike.no_write", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "no_write", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def no_write(self, bytes_read):\n        \"\"\"Used for file-like objects where no write is available\"\"\"\n        raise IOError(\"This DicomFileLike object has no write() method\")\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "no_write", "self", "bytes_read", "used", "for", "file", "like", "objects", "where", "no", "write", "is", "available", "raise", "ioerror", "this", "dicomfilelike", "object", "has", "no", "write", "method"], "doc_len": 27}
{"doc_id": "pydicom/filebase.py::DicomFileLike.no_read", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "no_read", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def no_read(self, bytes_read):\n        \"\"\"Used for file-like objects where no read is available\"\"\"\n        raise IOError(\"This DicomFileLike object has no read() method\")\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "no_read", "self", "bytes_read", "used", "for", "file", "like", "objects", "where", "no", "read", "is", "available", "raise", "ioerror", "this", "dicomfilelike", "object", "has", "no", "read", "method"], "doc_len": 27}
{"doc_id": "pydicom/filebase.py::DicomFileLike.no_seek", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "no_seek", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def no_seek(self, offset, from_what):\n        \"\"\"Used for file-like objects where no seek is available\"\"\"\n        raise IOError(\"This DicomFileLike object has no seek() method\")\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "no_seek", "self", "offset", "from_what", "used", "for", "file", "like", "objects", "where", "no", "seek", "is", "available", "raise", "ioerror", "this", "dicomfilelike", "object", "has", "no", "seek", "method"], "doc_len": 28}
{"doc_id": "pydicom/filebase.py::DicomFileLike.__enter__", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "__enter__", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def __enter__(self):\n        return self\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "__enter__", "self", "return", "self"], "doc_len": 9}
{"doc_id": "pydicom/filebase.py::DicomFileLike.__exit__", "file_path": "pydicom/filebase.py", "class_name": "DicomFileLike", "func_name": "__exit__", "text": "文件路径: pydicom/filebase.py, 类名: DicomFileLike\n    def __exit__(self, *exc_info):\n        self.close()\n", "tokens": ["pydicom", "filebase", "py", "dicomfilelike", "def", "__exit__", "self", "exc_info", "self", "close"], "doc_len": 10}
{"doc_id": "pydicom/filebase.py::DicomFile", "file_path": "pydicom/filebase.py", "class_name": null, "func_name": "DicomFile", "text": "文件路径: pydicom/filebase.py\ndef DicomFile(*args, **kwargs):\n    return DicomFileLike(open(*args, **kwargs))\n", "tokens": ["pydicom", "filebase", "py", "def", "dicomfile", "args", "kwargs", "return", "dicomfilelike", "open", "args", "kwargs"], "doc_len": 12}
{"doc_id": "pydicom/filebase.py::DicomBytesIO.__init__", "file_path": "pydicom/filebase.py", "class_name": "DicomBytesIO", "func_name": "__init__", "text": "文件路径: pydicom/filebase.py, 类名: DicomBytesIO\n    def __init__(self, *args, **kwargs):\n        super(DicomBytesIO, self).__init__(BytesIO(*args, **kwargs))\n", "tokens": ["pydicom", "filebase", "py", "dicombytesio", "def", "__init__", "self", "args", "kwargs", "super", "dicombytesio", "self", "__init__", "bytesio", "args", "kwargs"], "doc_len": 16}
{"doc_id": "pydicom/filebase.py::DicomBytesIO.getvalue", "file_path": "pydicom/filebase.py", "class_name": "DicomBytesIO", "func_name": "getvalue", "text": "文件路径: pydicom/filebase.py, 类名: DicomBytesIO\n    def getvalue(self):\n        return self.parent.getvalue()\n", "tokens": ["pydicom", "filebase", "py", "dicombytesio", "def", "getvalue", "self", "return", "self", "parent", "getvalue"], "doc_len": 11}
{"doc_id": "pydicom/filereader.py::data_element_generator", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "data_element_generator", "text": "文件路径: pydicom/filereader.py\ndef data_element_generator(fp,\n                           is_implicit_VR,\n                           is_little_endian,\n                           stop_when=None,\n                           defer_size=None,\n                           encoding=default_encoding,\n                           specific_tags=None):\n\n    \"\"\"Create a generator to efficiently return the raw data elements.\n\n    Parameters\n    ----------\n    fp : file-like object\n    is_implicit_VR : boolean\n    is_little_endian : boolean\n    stop_when : None, callable, optional\n        If None (default), then the whole file is read.\n        A callable which takes tag, VR, length,\n        and returns True or False. If it returns True,\n        read_data_element will just return.\n    defer_size : int, str, None, optional\n        See ``dcmread`` for parameter info.\n    encoding :\n        Encoding scheme\n    specific_tags : list or None\n        See ``dcmread`` for parameter info.\n\n    Returns\n    -------\n    VR : None if implicit VR, otherwise the VR read from the file\n    length :\n        the length as in the DICOM data element (could be\n        DICOM \"undefined length\" 0xffffffffL)\n    value_bytes :\n        the raw bytes from the DICOM file\n        (not parsed into python types)\n    is_little_endian : boolean\n        True if transfer syntax is little endian; else False.\n    \"\"\"\n    # Summary of DICOM standard PS3.5-2008 chapter 7:\n    # If Implicit VR, data element is:\n    #    tag, 4-byte length, value.\n    #        The 4-byte length can be FFFFFFFF (undefined length)*\n    #\n    # If Explicit VR:\n    #    if OB, OW, OF, SQ, UN, or UT:\n    #       tag, VR, 2-bytes reserved (both zero), 4-byte length, value\n    #           For all but UT, the length can be FFFFFFFF (undefined length)*\n    #   else: (any other VR)\n    #       tag, VR, (2 byte length), value\n    # * for undefined length, a Sequence Delimitation Item marks the end\n    #        of the Value Field.\n    # Note, except for the special_VRs, both impl and expl VR use 8 bytes;\n    #    the special VRs follow the 8 bytes with a 4-byte length\n\n    # With a generator, state is stored, so we can break down\n    #    into the individual cases, and not have to check them again for each\n    #    data element\n\n    if is_little_endian:\n        endian_chr = \"<\"\n    else:\n        endian_chr = \">\"\n    if is_implicit_VR:\n        element_struct = Struct(endian_chr + \"HHL\")\n    else:  # Explicit VR\n        # tag, VR, 2-byte length (or 0 if special VRs)\n        element_struct = Struct(endian_chr + \"HH2sH\")\n        extra_length_struct = Struct(endian_chr + \"L\")  # for special VRs\n        extra_length_unpack = extra_length_struct.unpack  # for lookup speed\n\n    # Make local variables so have faster lookup\n    fp_read = fp.read\n    fp_tell = fp.tell\n    logger_debug = logger.debug\n    debugging = config.debugging\n    element_struct_unpack = element_struct.unpack\n    defer_size = size_in_bytes(defer_size)\n\n    tag_set = set()\n    if specific_tags is not None:\n        for tag in specific_tags:\n            if isinstance(tag, (str, compat.text_type)):\n                tag = Tag(tag_for_keyword(tag))\n            if isinstance(tag, BaseTag):\n                tag_set.add(tag)\n        tag_set.add(Tag(0x08, 0x05))\n    has_tag_set = len(tag_set) > 0\n\n    while True:\n        # Read tag, VR, length, get ready to read value\n        bytes_read = fp_read(8)\n        if len(bytes_read) < 8:\n            return  # at end of file\n        if debugging:\n            debug_msg = \"{0:08x}: {1}\".format(fp.tell() - 8,\n                                              bytes2hex(bytes_read))\n\n        if is_implicit_VR:\n            # must reset VR each time; could have set last iteration (e.g. SQ)\n            VR = None\n            group, elem, length = element_struct_unpack(bytes_read)\n        else:  # explicit VR\n            group, elem, VR, length = element_struct_unpack(bytes_read)\n            if not in_py2:\n                VR = VR.decode(default_encoding)\n            if VR in extra_length_VRs:\n                bytes_read = fp_read(4)\n                length = extra_length_unpack(bytes_read)[0]\n                if debugging:\n                    debug_msg += \" \" + bytes2hex(bytes_read)\n        if debugging:\n            debug_msg = \"%-47s  (%04x, %04x)\" % (debug_msg, group, elem)\n            if not is_implicit_VR:\n                debug_msg += \" %s \" % VR\n            if length != 0xFFFFFFFF:\n                debug_msg += \"Length: %d\" % length\n            else:\n                debug_msg += \"Length: Undefined length (FFFFFFFF)\"\n            logger_debug(debug_msg)\n\n        # Positioned to read the value, but may not want to -- check stop_when\n        value_tell = fp_tell()\n        tag = TupleTag((group, elem))\n        if stop_when is not None:\n            # XXX VR may be None here!! Should stop_when just take tag?\n            if stop_when(tag, VR, length):\n                if debugging:\n                    logger_debug(\"Reading ended by stop_when callback. \"\n                                 \"Rewinding to start of data element.\")\n                rewind_length = 8\n                if not is_implicit_VR and VR in extra_length_VRs:\n                    rewind_length += 4\n                fp.seek(value_tell - rewind_length)\n                return\n\n        # Reading the value\n        # First case (most common): reading a value with a defined length\n        if length != 0xFFFFFFFF:\n            # don't defer loading of Specific Character Set value as it is\n            # needed immediately to get the character encoding for other tags\n            if has_tag_set and tag not in tag_set:\n                # skip the tag if not in specific tags\n                fp.seek(fp_tell() + length)\n                continue\n\n            if (defer_size is not None and length > defer_size and\n                    tag != BaseTag(0x00080005)):\n                # Flag as deferred by setting value to None, and skip bytes\n                value = None\n                logger_debug(\"Defer size exceeded. \"\n                             \"Skipping forward to next data element.\")\n                fp.seek(fp_tell() + length)\n            else:\n                value = fp_read(length)\n                if debugging:\n                    dotdot = \"   \"\n                    if length > 12:\n                        dotdot = \"...\"\n                    logger_debug(\"%08x: %-34s %s %r %s\" % (value_tell,\n                                                           bytes2hex(\n                                                               value[:12]),\n                                                           dotdot,\n                                                           value[:12], dotdot))\n\n            # If the tag is (0008,0005) Specific Character Set, then store it\n            if tag == BaseTag(0x00080005):\n                from pydicom.values import convert_string\n                encoding = convert_string(value, is_little_endian)\n                # Store the encoding value in the generator\n                # for use with future elements (SQs)\n                encoding = convert_encodings(encoding)\n\n            yield RawDataElement(tag, VR, length, value, value_tell,\n                                 is_implicit_VR, is_little_endian)\n\n        # Second case: undefined length - must seek to delimiter,\n        # unless is SQ type, in which case is easier to parse it, because\n        # undefined length SQs and items of undefined lengths can be nested\n        # and it would be error-prone to read to the correct outer delimiter\n        else:\n            # Try to look up type to see if is a SQ\n            # if private tag, won't be able to look it up in dictionary,\n            #   in which case just ignore it and read the bytes unless it is\n            #   identified as a Sequence\n            if VR is None:\n                try:\n                    VR = dictionary_VR(tag)\n                except KeyError:\n                    # Look ahead to see if it consists of items\n                    # and is thus a SQ\n                    next_tag = TupleTag(unpack(endian_chr + \"HH\", fp_read(4)))\n                    # Rewind the file\n                    fp.seek(fp_tell() - 4)\n                    if next_tag == ItemTag:\n                        VR = 'SQ'\n\n            if VR == 'SQ':\n                if debugging:\n                    msg = \"{0:08x}: Reading/parsing undefined length sequence\"\n                    logger_debug(msg.format(fp_tell()))\n                seq = read_sequence(fp, is_implicit_VR,\n                                    is_little_endian, length, encoding)\n                if has_tag_set and tag not in tag_set:\n                    continue\n                yield DataElement(tag, VR, seq, value_tell,\n                                  is_undefined_length=True)\n            else:\n                delimiter = SequenceDelimiterTag\n                if debugging:\n                    logger_debug(\"Reading undefined length data element\")\n                value = read_undefined_length_value(fp, is_little_endian,\n                                                    delimiter, defer_size)\n\n                # If the tag is (0008,0005) Specific Character Set,\n                # then store it\n                if tag == (0x08, 0x05):\n                    from pydicom.values import convert_string\n                    encoding = convert_string(value, is_little_endian)\n                    # Store the encoding value in the generator for use\n                    # with future elements (SQs)\n                    encoding = convert_encodings(encoding)\n\n                # tags with undefined length are skipped after read\n                if has_tag_set and tag not in tag_set:\n                    continue\n                yield RawDataElement(tag, VR, length, value, value_tell,\n                                     is_implicit_VR, is_little_endian)\n", "tokens": ["pydicom", "filereader", "py", "def", "data_element_generator", "fp", "is_implicit_vr", "is_little_endian", "stop_when", "none", "defer_size", "none", "encoding", "default_encoding", "specific_tags", "none", "create", "a", "generator", "to", "efficiently", "return", "the", "raw", "data", "elements", "parameters", "fp", "file", "like", "object", "is_implicit_vr", "boolean", "is_little_endian", "boolean", "stop_when", "none", "callable", "optional", "if", "none", "default", "then", "the", "whole", "file", "is", "read", "a", "callable", "which", "takes", "tag", "vr", "length", "and", "returns", "true", "or", "false", "if", "it", "returns", "true", "read_data_element", "will", "just", "return", "defer_size", "int", "str", "none", "optional", "see", "dcmread", "for", "parameter", "info", "encoding", "encoding", "scheme", "specific_tags", "list", "or", "none", "see", "dcmread", "for", "parameter", "info", "returns", "vr", "none", "if", "implicit", "vr", "otherwise", "the", "vr", "read", "from", "the", "file", "length", "the", "length", "as", "in", "the", "dicom", "data", "element", "could", "be", "dicom", "undefined", "length", "0xffffffffl", "value_bytes", "the", "raw", "bytes", "from", "the", "dicom", "file", "not", "parsed", "into", "python", "types", "is_little_endian", "boolean", "true", "if", "transfer", "syntax", "is", "little", "endian", "else", "false", "summary", "of", "dicom", "standard", "ps3", "5", "2008", "chapter", "7", "if", "implicit", "vr", "data", "element", "is", "tag", "4", "byte", "length", "value", "the", "4", "byte", "length", "can", "be", "ffffffff", "undefined", "length", "if", "explicit", "vr", "if", "ob", "ow", "of", "sq", "un", "or", "ut", "tag", "vr", "2", "bytes", "reserved", "both", "zero", "4", "byte", "length", "value", "for", "all", "but", "ut", "the", "length", "can", "be", "ffffffff", "undefined", "length", "else", "any", "other", "vr", "tag", "vr", "2", "byte", "length", "value", "for", "undefined", "length", "a", "sequence", "delimitation", "item", "marks", "the", "end", "of", "the", "value", "field", "note", "except", "for", "the", "special_vrs", "both", "impl", "and", "expl", "vr", "use", "8", "bytes", "the", "special", "vrs", "follow", "the", "8", "bytes", "with", "a", "4", "byte", "length", "with", "a", "generator", "state", "is", "stored", "so", "we", "can", "break", "down", "into", "the", "individual", "cases", "and", "not", "have", "to", "check", "them", "again", "for", "each", "data", "element", "if", "is_little_endian", "endian_chr", "else", "endian_chr", "if", "is_implicit_vr", "element_struct", "struct", "endian_chr", "hhl", "else", "explicit", "vr", "tag", "vr", "2", "byte", "length", "or", "0", "if", "special", "vrs", "element_struct", "struct", "endian_chr", "hh2sh", "extra_length_struct", "struct", "endian_chr", "l", "for", "special", "vrs", "extra_length_unpack", "extra_length_struct", "unpack", "for", "lookup", "speed", "make", "local", "variables", "so", "have", "faster", "lookup", "fp_read", "fp", "read", "fp_tell", "fp", "tell", "logger_debug", "logger", "debug", "debugging", "config", "debugging", "element_struct_unpack", "element_struct", "unpack", "defer_size", "size_in_bytes", "defer_size", "tag_set", "set", "if", "specific_tags", "is", "not", "none", "for", "tag", "in", "specific_tags", "if", "isinstance", "tag", "str", "compat", "text_type", "tag", "tag", "tag_for_keyword", "tag", "if", "isinstance", "tag", "basetag", "tag_set", "add", "tag", "tag_set", "add", "tag", "0x08", "0x05", "has_tag_set", "len", "tag_set", "0", "while", "true", "read", "tag", "vr", "length", "get", "ready", "to", "read", "value", "bytes_read", "fp_read", "8", "if", "len", "bytes_read", "8", "return", "at", "end", "of", "file", "if", "debugging", "debug_msg", "0", "08x", "1", "format", "fp", "tell", "8", "bytes2hex", "bytes_read", "if", "is_implicit_vr", "must", "reset", "vr", "each", "time", "could", "have", "set", "last", "iteration", "e", "g", "sq", "vr", "none", "group", "elem", "length", "element_struct_unpack", "bytes_read", "else", "explicit", "vr", "group", "elem", "vr", "length", "element_struct_unpack", "bytes_read", "if", "not", "in_py2", "vr", "vr", "decode", "default_encoding", "if", "vr", "in", "extra_length_vrs", "bytes_read", "fp_read", "4", "length", "extra_length_unpack", "bytes_read", "0", "if", "debugging", "debug_msg", "bytes2hex", "bytes_read", "if", "debugging", "debug_msg", "47s", "04x", "04x", "debug_msg", "group", "elem", "if", "not", "is_implicit_vr", "debug_msg", "s", "vr", "if", "length", "0xffffffff", "debug_msg", "length", "d", "length", "else", "debug_msg", "length", "undefined", "length", "ffffffff", "logger_debug", "debug_msg", "positioned", "to", "read", "the", "value", "but", "may", "not", "want", "to", "check", "stop_when", "value_tell", "fp_tell", "tag", "tupletag", "group", "elem", "if", "stop_when", "is", "not", "none", "xxx", "vr", "may", "be", "none", "here", "should", "stop_when", "just", "take", "tag", "if", "stop_when", "tag", "vr", "length", "if", "debugging", "logger_debug", "reading", "ended", "by", "stop_when", "callback", "rewinding", "to", "start", "of", "data", "element", "rewind_length", "8", "if", "not", "is_implicit_vr", "and", "vr", "in", "extra_length_vrs", "rewind_length", "4", "fp", "seek", "value_tell", "rewind_length", "return", "reading", "the", "value", "first", "case", "most", "common", "reading", "a", "value", "with", "a", "defined", "length", "if", "length", "0xffffffff", "don", "t", "defer", "loading", "of", "specific", "character", "set", "value", "as", "it", "is", "needed", "immediately", "to", "get", "the", "character", "encoding", "for", "other", "tags", "if", "has_tag_set", "and", "tag", "not", "in", "tag_set", "skip", "the", "tag", "if", "not", "in", "specific", "tags", "fp", "seek", "fp_tell", "length", "continue", "if", "defer_size", "is", "not", "none", "and", "length", "defer_size", "and", "tag", "basetag", "0x00080005", "flag", "as", "deferred", "by", "setting", "value", "to", "none", "and", "skip", "bytes", "value", "none", "logger_debug", "defer", "size", "exceeded", "skipping", "forward", "to", "next", "data", "element", "fp", "seek", "fp_tell", "length", "else", "value", "fp_read", "length", "if", "debugging", "dotdot", "if", "length", "12", "dotdot", "logger_debug", "08x", "34s", "s", "r", "s", "value_tell", "bytes2hex", "value", "12", "dotdot", "value", "12", "dotdot", "if", "the", "tag", "is", "0008", "0005", "specific", "character", "set", "then", "store", "it", "if", "tag", "basetag", "0x00080005", "from", "pydicom", "values", "import", "convert_string", "encoding", "convert_string", "value", "is_little_endian", "store", "the", "encoding", "value", "in", "the", "generator", "for", "use", "with", "future", "elements", "sqs", "encoding", "convert_encodings", "encoding", "yield", "rawdataelement", "tag", "vr", "length", "value", "value_tell", "is_implicit_vr", "is_little_endian", "second", "case", "undefined", "length", "must", "seek", "to", "delimiter", "unless", "is", "sq", "type", "in", "which", "case", "is", "easier", "to", "parse", "it", "because", "undefined", "length", "sqs", "and", "items", "of", "undefined", "lengths", "can", "be", "nested", "and", "it", "would", "be", "error", "prone", "to", "read", "to", "the", "correct", "outer", "delimiter", "else", "try", "to", "look", "up", "type", "to", "see", "if", "is", "a", "sq", "if", "private", "tag", "won", "t", "be", "able", "to", "look", "it", "up", "in", "dictionary", "in", "which", "case", "just", "ignore", "it", "and", "read", "the", "bytes", "unless", "it", "is", "identified", "as", "a", "sequence", "if", "vr", "is", "none", "try", "vr", "dictionary_vr", "tag", "except", "keyerror", "look", "ahead", "to", "see", "if", "it", "consists", "of", "items", "and", "is", "thus", "a", "sq", "next_tag", "tupletag", "unpack", "endian_chr", "hh", "fp_read", "4", "rewind", "the", "file", "fp", "seek", "fp_tell", "4", "if", "next_tag", "itemtag", "vr", "sq", "if", "vr", "sq", "if", "debugging", "msg", "0", "08x", "reading", "parsing", "undefined", "length", "sequence", "logger_debug", "msg", "format", "fp_tell", "seq", "read_sequence", "fp", "is_implicit_vr", "is_little_endian", "length", "encoding", "if", "has_tag_set", "and", "tag", "not", "in", "tag_set", "continue", "yield", "dataelement", "tag", "vr", "seq", "value_tell", "is_undefined_length", "true", "else", "delimiter", "sequencedelimitertag", "if", "debugging", "logger_debug", "reading", "undefined", "length", "data", "element", "value", "read_undefined_length_value", "fp", "is_little_endian", "delimiter", "defer_size", "if", "the", "tag", "is", "0008", "0005", "specific", "character", "set", "then", "store", "it", "if", "tag", "0x08", "0x05", "from", "pydicom", "values", "import", "convert_string", "encoding", "convert_string", "value", "is_little_endian", "store", "the", "encoding", "value", "in", "the", "generator", "for", "use", "with", "future", "elements", "sqs", "encoding", "convert_encodings", "encoding", "tags", "with", "undefined", "length", "are", "skipped", "after", "read", "if", "has_tag_set", "and", "tag", "not", "in", "tag_set", "continue", "yield", "rawdataelement", "tag", "vr", "length", "value", "value_tell", "is_implicit_vr", "is_little_endian"], "doc_len": 996}
{"doc_id": "pydicom/filereader.py::_is_implicit_vr", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "_is_implicit_vr", "text": "文件路径: pydicom/filereader.py\ndef _is_implicit_vr(fp, implicit_vr_is_assumed, is_little_endian, stop_when):\n    \"\"\"Check if the real VR is explicit or implicit.\n\n    Parameters\n    ----------\n    fp : an opened file object\n    implicit_vr_is_assumed : boolean\n        True if implicit VR is assumed.\n        If this does not match with the real transfer syntax, a user warning\n        will be issued.\n    is_little_endian : boolean\n        True if file has little endian transfer syntax.\n        Needed to interpret the first tag.\n    stop_when : None, optional\n        Optional call_back function which can terminate reading.\n        Needed to check if the next tag still belongs to the read dataset.\n\n    Returns\n    -------\n    True if implicit VR is used, False otherwise.\n    \"\"\"\n    tag_bytes = fp.read(4)\n    vr = fp.read(2)\n    if len(vr) < 2:\n        return implicit_vr_is_assumed\n\n    # it is sufficient to check if the VR is in valid ASCII range, as it is\n    # extremely unlikely that the tag length accidentally has such a\n    # representation - this would need the first tag to be longer than 16kB\n    # (e.g. it should be > 0x4141 = 16705 bytes)\n    vr1 = ord(vr[0]) if in_py2 else vr[0]\n    vr2 = ord(vr[1]) if in_py2 else vr[1]\n    found_implicit = not (0x40 < vr1 < 0x5B and 0x40 < vr2 < 0x5B)\n\n    if found_implicit != implicit_vr_is_assumed:\n        # first check if the tag still belongs to the dataset if stop_when\n        # is given - if not, the dataset is empty and we just return\n        endian_chr = \"<\" if is_little_endian else \">\"\n        tag = TupleTag(unpack(endian_chr + \"HH\", tag_bytes))\n        if stop_when is not None and stop_when(tag, vr, 0):\n            return found_implicit\n\n        # got to the real problem - warn or raise depending on config\n        found_vr = 'implicit' if found_implicit else 'explicit'\n        expected_vr = 'implicit' if not found_implicit else 'explicit'\n        message = ('Expected {0} VR, but found {1} VR - using {1} VR for '\n                   'reading'.format(expected_vr, found_vr))\n        if config.enforce_valid_values:\n            raise InvalidDicomError(message)\n        warnings.warn(message, UserWarning)\n    return found_implicit\n", "tokens": ["pydicom", "filereader", "py", "def", "_is_implicit_vr", "fp", "implicit_vr_is_assumed", "is_little_endian", "stop_when", "check", "if", "the", "real", "vr", "is", "explicit", "or", "implicit", "parameters", "fp", "an", "opened", "file", "object", "implicit_vr_is_assumed", "boolean", "true", "if", "implicit", "vr", "is", "assumed", "if", "this", "does", "not", "match", "with", "the", "real", "transfer", "syntax", "a", "user", "warning", "will", "be", "issued", "is_little_endian", "boolean", "true", "if", "file", "has", "little", "endian", "transfer", "syntax", "needed", "to", "interpret", "the", "first", "tag", "stop_when", "none", "optional", "optional", "call_back", "function", "which", "can", "terminate", "reading", "needed", "to", "check", "if", "the", "next", "tag", "still", "belongs", "to", "the", "read", "dataset", "returns", "true", "if", "implicit", "vr", "is", "used", "false", "otherwise", "tag_bytes", "fp", "read", "4", "vr", "fp", "read", "2", "if", "len", "vr", "2", "return", "implicit_vr_is_assumed", "it", "is", "sufficient", "to", "check", "if", "the", "vr", "is", "in", "valid", "ascii", "range", "as", "it", "is", "extremely", "unlikely", "that", "the", "tag", "length", "accidentally", "has", "such", "a", "representation", "this", "would", "need", "the", "first", "tag", "to", "be", "longer", "than", "16kb", "e", "g", "it", "should", "be", "0x4141", "16705", "bytes", "vr1", "ord", "vr", "0", "if", "in_py2", "else", "vr", "0", "vr2", "ord", "vr", "1", "if", "in_py2", "else", "vr", "1", "found_implicit", "not", "0x40", "vr1", "0x5b", "and", "0x40", "vr2", "0x5b", "if", "found_implicit", "implicit_vr_is_assumed", "first", "check", "if", "the", "tag", "still", "belongs", "to", "the", "dataset", "if", "stop_when", "is", "given", "if", "not", "the", "dataset", "is", "empty", "and", "we", "just", "return", "endian_chr", "if", "is_little_endian", "else", "tag", "tupletag", "unpack", "endian_chr", "hh", "tag_bytes", "if", "stop_when", "is", "not", "none", "and", "stop_when", "tag", "vr", "0", "return", "found_implicit", "got", "to", "the", "real", "problem", "warn", "or", "raise", "depending", "on", "config", "found_vr", "implicit", "if", "found_implicit", "else", "explicit", "expected_vr", "implicit", "if", "not", "found_implicit", "else", "explicit", "message", "expected", "0", "vr", "but", "found", "1", "vr", "using", "1", "vr", "for", "reading", "format", "expected_vr", "found_vr", "if", "config", "enforce_valid_values", "raise", "invaliddicomerror", "message", "warnings", "warn", "message", "userwarning", "return", "found_implicit"], "doc_len": 284}
{"doc_id": "pydicom/filereader.py::read_dataset", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_dataset", "text": "文件路径: pydicom/filereader.py\ndef read_dataset(fp, is_implicit_VR, is_little_endian, bytelength=None,\n                 stop_when=None, defer_size=None,\n                 parent_encoding=default_encoding, specific_tags=None):\n    \"\"\"Return a Dataset instance containing the next dataset in the file.\n\n    Parameters\n    ----------\n    fp : an opened file object\n    is_implicit_VR : boolean\n        True if file transfer syntax is implicit VR.\n    is_little_endian : boolean\n        True if file has little endian transfer syntax.\n    bytelength : int, None, optional\n        None to read until end of file or ItemDeliterTag, else\n        a fixed number of bytes to read\n    stop_when : None, optional\n        optional call_back function which can terminate reading.\n        See help for data_element_generator for details\n    defer_size : int, None, optional\n        Size to avoid loading large elements in memory.\n        See ``dcmread`` for more parameter info.\n    parent_encoding :\n        optional encoding to use as a default in case\n        a Specific Character Set (0008,0005) isn't specified\n    specific_tags : list or None\n        See ``dcmread`` for parameter info.\n\n    Returns\n    -------\n    a Dataset instance\n\n    See Also\n    --------\n    pydicom.dataset.Dataset\n        A collection (dictionary) of Dicom `DataElement` instances.\n    \"\"\"\n    raw_data_elements = dict()\n    fp_start = fp.tell()\n    is_implicit_VR = _is_implicit_vr(\n        fp, is_implicit_VR, is_little_endian, stop_when)\n    fp.seek(fp_start)\n    de_gen = data_element_generator(fp, is_implicit_VR, is_little_endian,\n                                    stop_when, defer_size, parent_encoding,\n                                    specific_tags)\n    try:\n        while (bytelength is None) or (fp.tell() - fp_start < bytelength):\n            raw_data_element = next(de_gen)\n            # Read data elements. Stop on some errors, but return what was read\n            tag = raw_data_element.tag\n            # Check for ItemDelimiterTag --dataset is an item in a sequence\n            if tag == BaseTag(0xFFFEE00D):\n                break\n            raw_data_elements[tag] = raw_data_element\n    except StopIteration:\n        pass\n    except EOFError as details:\n        # XXX is this error visible enough to user code with just logging?\n        logger.error(str(details) + \" in file \" +\n                     getattr(fp, \"name\", \"<no filename>\"))\n    except NotImplementedError as details:\n        logger.error(details)\n\n    ds = Dataset(raw_data_elements)\n    if 0x00080005 in raw_data_elements:\n        char_set = DataElement_from_raw(raw_data_elements[0x00080005])\n        encoding = convert_encodings(char_set)\n    else:\n        encoding = parent_encoding\n    ds.set_original_encoding(is_implicit_VR, is_little_endian, encoding)\n    return ds\n", "tokens": ["pydicom", "filereader", "py", "def", "read_dataset", "fp", "is_implicit_vr", "is_little_endian", "bytelength", "none", "stop_when", "none", "defer_size", "none", "parent_encoding", "default_encoding", "specific_tags", "none", "return", "a", "dataset", "instance", "containing", "the", "next", "dataset", "in", "the", "file", "parameters", "fp", "an", "opened", "file", "object", "is_implicit_vr", "boolean", "true", "if", "file", "transfer", "syntax", "is", "implicit", "vr", "is_little_endian", "boolean", "true", "if", "file", "has", "little", "endian", "transfer", "syntax", "bytelength", "int", "none", "optional", "none", "to", "read", "until", "end", "of", "file", "or", "itemdelitertag", "else", "a", "fixed", "number", "of", "bytes", "to", "read", "stop_when", "none", "optional", "optional", "call_back", "function", "which", "can", "terminate", "reading", "see", "help", "for", "data_element_generator", "for", "details", "defer_size", "int", "none", "optional", "size", "to", "avoid", "loading", "large", "elements", "in", "memory", "see", "dcmread", "for", "more", "parameter", "info", "parent_encoding", "optional", "encoding", "to", "use", "as", "a", "default", "in", "case", "a", "specific", "character", "set", "0008", "0005", "isn", "t", "specified", "specific_tags", "list", "or", "none", "see", "dcmread", "for", "parameter", "info", "returns", "a", "dataset", "instance", "see", "also", "pydicom", "dataset", "dataset", "a", "collection", "dictionary", "of", "dicom", "dataelement", "instances", "raw_data_elements", "dict", "fp_start", "fp", "tell", "is_implicit_vr", "_is_implicit_vr", "fp", "is_implicit_vr", "is_little_endian", "stop_when", "fp", "seek", "fp_start", "de_gen", "data_element_generator", "fp", "is_implicit_vr", "is_little_endian", "stop_when", "defer_size", "parent_encoding", "specific_tags", "try", "while", "bytelength", "is", "none", "or", "fp", "tell", "fp_start", "bytelength", "raw_data_element", "next", "de_gen", "read", "data", "elements", "stop", "on", "some", "errors", "but", "return", "what", "was", "read", "tag", "raw_data_element", "tag", "check", "for", "itemdelimitertag", "dataset", "is", "an", "item", "in", "a", "sequence", "if", "tag", "basetag", "0xfffee00d", "break", "raw_data_elements", "tag", "raw_data_element", "except", "stopiteration", "pass", "except", "eoferror", "as", "details", "xxx", "is", "this", "error", "visible", "enough", "to", "user", "code", "with", "just", "logging", "logger", "error", "str", "details", "in", "file", "getattr", "fp", "name", "no", "filename", "except", "notimplementederror", "as", "details", "logger", "error", "details", "ds", "dataset", "raw_data_elements", "if", "0x00080005", "in", "raw_data_elements", "char_set", "dataelement_from_raw", "raw_data_elements", "0x00080005", "encoding", "convert_encodings", "char_set", "else", "encoding", "parent_encoding", "ds", "set_original_encoding", "is_implicit_vr", "is_little_endian", "encoding", "return", "ds"], "doc_len": 284}
{"doc_id": "pydicom/filereader.py::read_sequence", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_sequence", "text": "文件路径: pydicom/filereader.py\ndef read_sequence(fp, is_implicit_VR, is_little_endian, bytelength, encoding,\n                  offset=0):\n    \"\"\"Read and return a Sequence -- i.e. a list of Datasets\"\"\"\n\n    seq = []  # use builtin list to start for speed, convert to Sequence at end\n    is_undefined_length = False\n    if bytelength != 0:  # SQ of length 0 possible (PS 3.5-2008 7.5.1a (p.40)\n        if bytelength == 0xffffffff:\n            is_undefined_length = True\n            bytelength = None\n        fp_tell = fp.tell  # for speed in loop\n        fpStart = fp_tell()\n        while (not bytelength) or (fp_tell() - fpStart < bytelength):\n            file_tell = fp.tell()\n            dataset = read_sequence_item(fp, is_implicit_VR, is_little_endian,\n                                         encoding, offset)\n            if dataset is None:  # None is returned if hit Sequence Delimiter\n                break\n            dataset.file_tell = file_tell + offset\n            seq.append(dataset)\n    seq = Sequence(seq)\n    seq.is_undefined_length = is_undefined_length\n    return seq\n", "tokens": ["pydicom", "filereader", "py", "def", "read_sequence", "fp", "is_implicit_vr", "is_little_endian", "bytelength", "encoding", "offset", "0", "read", "and", "return", "a", "sequence", "i", "e", "a", "list", "of", "datasets", "seq", "use", "builtin", "list", "to", "start", "for", "speed", "convert", "to", "sequence", "at", "end", "is_undefined_length", "false", "if", "bytelength", "0", "sq", "of", "length", "0", "possible", "ps", "3", "5", "2008", "7", "5", "1a", "p", "40", "if", "bytelength", "0xffffffff", "is_undefined_length", "true", "bytelength", "none", "fp_tell", "fp", "tell", "for", "speed", "in", "loop", "fpstart", "fp_tell", "while", "not", "bytelength", "or", "fp_tell", "fpstart", "bytelength", "file_tell", "fp", "tell", "dataset", "read_sequence_item", "fp", "is_implicit_vr", "is_little_endian", "encoding", "offset", "if", "dataset", "is", "none", "none", "is", "returned", "if", "hit", "sequence", "delimiter", "break", "dataset", "file_tell", "file_tell", "offset", "seq", "append", "dataset", "seq", "sequence", "seq", "seq", "is_undefined_length", "is_undefined_length", "return", "seq"], "doc_len": 115}
{"doc_id": "pydicom/filereader.py::read_sequence_item", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_sequence_item", "text": "文件路径: pydicom/filereader.py\ndef read_sequence_item(fp, is_implicit_VR, is_little_endian, encoding,\n                       offset=0):\n    \"\"\"Read and return a single sequence item, i.e. a Dataset\"\"\"\n    seq_item_tell = fp.tell() + offset\n    if is_little_endian:\n        tag_length_format = \"<HHL\"\n    else:\n        tag_length_format = \">HHL\"\n    try:\n        bytes_read = fp.read(8)\n        group, element, length = unpack(tag_length_format, bytes_read)\n    except BaseException:\n        raise IOError(\"No tag to read at file position \"\n                      \"{0:05x}\".format(fp.tell() + offset))\n    tag = (group, element)\n    if tag == SequenceDelimiterTag:  # No more items, time to stop reading\n        logger.debug(\n            \"{0:08x}: {1}\".format(fp.tell() - 8 + offset, \"End of Sequence\"))\n        if length != 0:\n            logger.warning(\"Expected 0x00000000 after delimiter, found 0x%x, \"\n                           \"at position 0x%x\" % (\n                               length, fp.tell() - 4 + offset))\n        return None\n    if tag != ItemTag:\n        logger.warning(\"Expected sequence item with tag %s at file position \"\n                       \"0x%x\" % (ItemTag, fp.tell() - 4 + offset))\n    else:\n        logger.debug(\"{0:08x}: {1}  Found Item tag (start of item)\".format(\n            fp.tell() - 4 + offset, bytes2hex(bytes_read)))\n    if length == 0xFFFFFFFF:\n        ds = read_dataset(fp, is_implicit_VR, is_little_endian,\n                          bytelength=None, parent_encoding=encoding)\n        ds.is_undefined_length_sequence_item = True\n    else:\n        ds = read_dataset(fp, is_implicit_VR, is_little_endian, length,\n                          parent_encoding=encoding)\n        ds.is_undefined_length_sequence_item = False\n        logger.debug(\"%08x: Finished sequence item\" % (fp.tell() + offset,))\n    ds.seq_item_tell = seq_item_tell\n    return ds\n", "tokens": ["pydicom", "filereader", "py", "def", "read_sequence_item", "fp", "is_implicit_vr", "is_little_endian", "encoding", "offset", "0", "read", "and", "return", "a", "single", "sequence", "item", "i", "e", "a", "dataset", "seq_item_tell", "fp", "tell", "offset", "if", "is_little_endian", "tag_length_format", "hhl", "else", "tag_length_format", "hhl", "try", "bytes_read", "fp", "read", "8", "group", "element", "length", "unpack", "tag_length_format", "bytes_read", "except", "baseexception", "raise", "ioerror", "no", "tag", "to", "read", "at", "file", "position", "0", "05x", "format", "fp", "tell", "offset", "tag", "group", "element", "if", "tag", "sequencedelimitertag", "no", "more", "items", "time", "to", "stop", "reading", "logger", "debug", "0", "08x", "1", "format", "fp", "tell", "8", "offset", "end", "of", "sequence", "if", "length", "0", "logger", "warning", "expected", "0x00000000", "after", "delimiter", "found", "0x", "x", "at", "position", "0x", "x", "length", "fp", "tell", "4", "offset", "return", "none", "if", "tag", "itemtag", "logger", "warning", "expected", "sequence", "item", "with", "tag", "s", "at", "file", "position", "0x", "x", "itemtag", "fp", "tell", "4", "offset", "else", "logger", "debug", "0", "08x", "1", "found", "item", "tag", "start", "of", "item", "format", "fp", "tell", "4", "offset", "bytes2hex", "bytes_read", "if", "length", "0xffffffff", "ds", "read_dataset", "fp", "is_implicit_vr", "is_little_endian", "bytelength", "none", "parent_encoding", "encoding", "ds", "is_undefined_length_sequence_item", "true", "else", "ds", "read_dataset", "fp", "is_implicit_vr", "is_little_endian", "length", "parent_encoding", "encoding", "ds", "is_undefined_length_sequence_item", "false", "logger", "debug", "08x", "finished", "sequence", "item", "fp", "tell", "offset", "ds", "seq_item_tell", "seq_item_tell", "return", "ds"], "doc_len": 191}
{"doc_id": "pydicom/filereader.py::_read_command_set_elements", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "_read_command_set_elements", "text": "文件路径: pydicom/filereader.py\ndef _read_command_set_elements(fp):\n    \"\"\"Return a Dataset containing any Command Set (0000,eeee) elements\n    in `fp`.\n\n    Command Set elements are always Implicit VR Little Endian (as per PS3.7\n    Section 6.3). Once any Command Set elements are read `fp` will be\n    positioned at the start of the next group of elements.\n\n    Parameters\n    ----------\n    fp : file-like\n        The file-like positioned at the start of any command set elements.\n\n    Returns\n    -------\n    pydicom.dataset.Dataset\n        The command set elements as a Dataset instance. May be empty if no\n        command set elements are present.\n    \"\"\"\n\n    def _not_group_0000(tag, VR, length):\n        \"\"\"Return True if the tag is not in group 0x0000, False otherwise.\"\"\"\n        return (tag.group != 0)\n\n    command_set = read_dataset(fp, is_implicit_VR=True, is_little_endian=True,\n                               stop_when=_not_group_0000)\n    return command_set\n", "tokens": ["pydicom", "filereader", "py", "def", "_read_command_set_elements", "fp", "return", "a", "dataset", "containing", "any", "command", "set", "0000", "eeee", "elements", "in", "fp", "command", "set", "elements", "are", "always", "implicit", "vr", "little", "endian", "as", "per", "ps3", "7", "section", "6", "3", "once", "any", "command", "set", "elements", "are", "read", "fp", "will", "be", "positioned", "at", "the", "start", "of", "the", "next", "group", "of", "elements", "parameters", "fp", "file", "like", "the", "file", "like", "positioned", "at", "the", "start", "of", "any", "command", "set", "elements", "returns", "pydicom", "dataset", "dataset", "the", "command", "set", "elements", "as", "a", "dataset", "instance", "may", "be", "empty", "if", "no", "command", "set", "elements", "are", "present", "def", "_not_group_0000", "tag", "vr", "length", "return", "true", "if", "the", "tag", "is", "not", "in", "group", "0x0000", "false", "otherwise", "return", "tag", "group", "0", "command_set", "read_dataset", "fp", "is_implicit_vr", "true", "is_little_endian", "true", "stop_when", "_not_group_0000", "return", "command_set"], "doc_len": 124}
{"doc_id": "pydicom/filereader.py::_read_file_meta_info", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "_read_file_meta_info", "text": "文件路径: pydicom/filereader.py\ndef _read_file_meta_info(fp):\n    \"\"\"Return a Dataset containing any File Meta (0002,eeee) elements in `fp`.\n\n    File Meta elements are always Explicit VR Little Endian (as per PS3.10\n    Section 7). Once any File Meta elements are read `fp` will be positioned\n    at the start of the next group of elements.\n\n    Parameters\n    ----------\n    fp : file-like\n        The file-like positioned at the start of any File Meta Information\n        group elements.\n\n    Returns\n    -------\n    pydicom.dataset.Dataset\n        The File Meta elements as a Dataset instance. May be empty if no\n        File Meta are present.\n    \"\"\"\n\n    def _not_group_0002(tag, VR, length):\n        \"\"\"Return True if the tag is not in group 0x0002, False otherwise.\"\"\"\n        return tag.group != 2\n\n    start_file_meta = fp.tell()\n    file_meta = read_dataset(fp, is_implicit_VR=False, is_little_endian=True,\n                             stop_when=_not_group_0002)\n    if not file_meta._dict:\n        return file_meta\n\n    # Test the file meta for correct interpretation by requesting the first\n    #   data element: if it fails, retry loading the file meta with an\n    #   implicit VR (issue #503)\n    try:\n        file_meta[list(file_meta.elements())[0].tag]\n    except NotImplementedError:\n        fp.seek(start_file_meta)\n        file_meta = read_dataset(fp, is_implicit_VR=True,\n                                 is_little_endian=True,\n                                 stop_when=_not_group_0002)\n\n    # Log if the Group Length doesn't match actual length\n    if 'FileMetaInformationGroupLength' in file_meta:\n        # FileMetaInformationGroupLength must be 12 bytes long and its value\n        #   counts from the beginning of the next element to the end of the\n        #   file meta elements\n        length_file_meta = fp.tell() - (start_file_meta + 12)\n        if file_meta.FileMetaInformationGroupLength != length_file_meta:\n            logger.info(\"_read_file_meta_info: (0002,0000) 'File Meta \"\n                        \"Information Group Length' value doesn't match the \"\n                        \"actual File Meta Information length ({0} vs {1} \"\n                        \"bytes).\"\n                        .format(file_meta.FileMetaInformationGroupLength,\n                                length_file_meta))\n\n    return file_meta\n", "tokens": ["pydicom", "filereader", "py", "def", "_read_file_meta_info", "fp", "return", "a", "dataset", "containing", "any", "file", "meta", "0002", "eeee", "elements", "in", "fp", "file", "meta", "elements", "are", "always", "explicit", "vr", "little", "endian", "as", "per", "ps3", "10", "section", "7", "once", "any", "file", "meta", "elements", "are", "read", "fp", "will", "be", "positioned", "at", "the", "start", "of", "the", "next", "group", "of", "elements", "parameters", "fp", "file", "like", "the", "file", "like", "positioned", "at", "the", "start", "of", "any", "file", "meta", "information", "group", "elements", "returns", "pydicom", "dataset", "dataset", "the", "file", "meta", "elements", "as", "a", "dataset", "instance", "may", "be", "empty", "if", "no", "file", "meta", "are", "present", "def", "_not_group_0002", "tag", "vr", "length", "return", "true", "if", "the", "tag", "is", "not", "in", "group", "0x0002", "false", "otherwise", "return", "tag", "group", "2", "start_file_meta", "fp", "tell", "file_meta", "read_dataset", "fp", "is_implicit_vr", "false", "is_little_endian", "true", "stop_when", "_not_group_0002", "if", "not", "file_meta", "_dict", "return", "file_meta", "test", "the", "file", "meta", "for", "correct", "interpretation", "by", "requesting", "the", "first", "data", "element", "if", "it", "fails", "retry", "loading", "the", "file", "meta", "with", "an", "implicit", "vr", "issue", "503", "try", "file_meta", "list", "file_meta", "elements", "0", "tag", "except", "notimplementederror", "fp", "seek", "start_file_meta", "file_meta", "read_dataset", "fp", "is_implicit_vr", "true", "is_little_endian", "true", "stop_when", "_not_group_0002", "log", "if", "the", "group", "length", "doesn", "t", "match", "actual", "length", "if", "filemetainformationgrouplength", "in", "file_meta", "filemetainformationgrouplength", "must", "be", "12", "bytes", "long", "and", "its", "value", "counts", "from", "the", "beginning", "of", "the", "next", "element", "to", "the", "end", "of", "the", "file", "meta", "elements", "length_file_meta", "fp", "tell", "start_file_meta", "12", "if", "file_meta", "filemetainformationgrouplength", "length_file_meta", "logger", "info", "_read_file_meta_info", "0002", "0000", "file", "meta", "information", "group", "length", "value", "doesn", "t", "match", "the", "actual", "file", "meta", "information", "length", "0", "vs", "1", "bytes", "format", "file_meta", "filemetainformationgrouplength", "length_file_meta", "return", "file_meta"], "doc_len": 257}
{"doc_id": "pydicom/filereader.py::read_file_meta_info", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_file_meta_info", "text": "文件路径: pydicom/filereader.py\ndef read_file_meta_info(filename):\n    \"\"\"Read and return the DICOM file meta information only.\n\n    This function is meant to be used in user code, for quickly going through\n    a series of files to find one which is referenced to a particular SOP,\n    without having to read the entire files.\n    \"\"\"\n    with DicomFile(filename, 'rb') as fp:\n        read_preamble(fp, False)  # if no header, raise exception\n        return _read_file_meta_info(fp)\n", "tokens": ["pydicom", "filereader", "py", "def", "read_file_meta_info", "filename", "read", "and", "return", "the", "dicom", "file", "meta", "information", "only", "this", "function", "is", "meant", "to", "be", "used", "in", "user", "code", "for", "quickly", "going", "through", "a", "series", "of", "files", "to", "find", "one", "which", "is", "referenced", "to", "a", "particular", "sop", "without", "having", "to", "read", "the", "entire", "files", "with", "dicomfile", "filename", "rb", "as", "fp", "read_preamble", "fp", "false", "if", "no", "header", "raise", "exception", "return", "_read_file_meta_info", "fp"], "doc_len": 67}
{"doc_id": "pydicom/filereader.py::read_preamble", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_preamble", "text": "文件路径: pydicom/filereader.py\ndef read_preamble(fp, force):\n    \"\"\"Return the 128-byte DICOM preamble in `fp` if present.\n\n    `fp` should be positioned at the start of the file-like. If the preamble\n    and prefix are found then after reading `fp` will be positioned at the\n    first byte after the prefix (byte offset 133). If either the preamble or\n    prefix are missing and `force` is True then after reading `fp` will be\n    positioned at the start of the file-like.\n\n    Parameters\n    ----------\n    fp : file-like object\n        The file-like to read the preamble from.\n    force : bool\n        Flag to force reading of a file even if no header is found.\n\n    Returns\n    -------\n    preamble : str/bytes or None\n        The 128-byte DICOM preamble will be returned if the appropriate prefix\n        ('DICM') is found at byte offset 128. Returns None if the 'DICM' prefix\n        is not found and `force` is True.\n\n    Raises\n    ------\n    InvalidDicomError\n        If `force` is False and no appropriate header information found.\n\n    Notes\n    -----\n    Also reads past the 'DICM' marker. Rewinds file to the beginning if\n    no header found.\n    \"\"\"\n    logger.debug(\"Reading File Meta Information preamble...\")\n    preamble = fp.read(128)\n    if config.debugging:\n        sample = bytes2hex(preamble[:8]) + \"...\" + bytes2hex(preamble[-8:])\n        logger.debug(\"{0:08x}: {1}\".format(fp.tell() - 128, sample))\n\n    logger.debug(\"Reading File Meta Information prefix...\")\n    magic = fp.read(4)\n    if magic != b\"DICM\" and force:\n        logger.info(\n            \"File is not conformant with the DICOM File Format: 'DICM' \"\n            \"prefix is missing from the File Meta Information header \"\n            \"or the header itself is missing. Assuming no header and \"\n            \"continuing.\")\n        preamble = None\n        fp.seek(0)\n    elif magic != b\"DICM\" and not force:\n        raise InvalidDicomError(\"File is missing DICOM File Meta Information \"\n                                \"header or the 'DICM' prefix is missing from \"\n                                \"the header. Use force=True to force reading.\")\n    else:\n        logger.debug(\"{0:08x}: 'DICM' prefix found\".format(fp.tell() - 4))\n    return preamble\n", "tokens": ["pydicom", "filereader", "py", "def", "read_preamble", "fp", "force", "return", "the", "128", "byte", "dicom", "preamble", "in", "fp", "if", "present", "fp", "should", "be", "positioned", "at", "the", "start", "of", "the", "file", "like", "if", "the", "preamble", "and", "prefix", "are", "found", "then", "after", "reading", "fp", "will", "be", "positioned", "at", "the", "first", "byte", "after", "the", "prefix", "byte", "offset", "133", "if", "either", "the", "preamble", "or", "prefix", "are", "missing", "and", "force", "is", "true", "then", "after", "reading", "fp", "will", "be", "positioned", "at", "the", "start", "of", "the", "file", "like", "parameters", "fp", "file", "like", "object", "the", "file", "like", "to", "read", "the", "preamble", "from", "force", "bool", "flag", "to", "force", "reading", "of", "a", "file", "even", "if", "no", "header", "is", "found", "returns", "preamble", "str", "bytes", "or", "none", "the", "128", "byte", "dicom", "preamble", "will", "be", "returned", "if", "the", "appropriate", "prefix", "dicm", "is", "found", "at", "byte", "offset", "128", "returns", "none", "if", "the", "dicm", "prefix", "is", "not", "found", "and", "force", "is", "true", "raises", "invaliddicomerror", "if", "force", "is", "false", "and", "no", "appropriate", "header", "information", "found", "notes", "also", "reads", "past", "the", "dicm", "marker", "rewinds", "file", "to", "the", "beginning", "if", "no", "header", "found", "logger", "debug", "reading", "file", "meta", "information", "preamble", "preamble", "fp", "read", "128", "if", "config", "debugging", "sample", "bytes2hex", "preamble", "8", "bytes2hex", "preamble", "8", "logger", "debug", "0", "08x", "1", "format", "fp", "tell", "128", "sample", "logger", "debug", "reading", "file", "meta", "information", "prefix", "magic", "fp", "read", "4", "if", "magic", "b", "dicm", "and", "force", "logger", "info", "file", "is", "not", "conformant", "with", "the", "dicom", "file", "format", "dicm", "prefix", "is", "missing", "from", "the", "file", "meta", "information", "header", "or", "the", "header", "itself", "is", "missing", "assuming", "no", "header", "and", "continuing", "preamble", "none", "fp", "seek", "0", "elif", "magic", "b", "dicm", "and", "not", "force", "raise", "invaliddicomerror", "file", "is", "missing", "dicom", "file", "meta", "information", "header", "or", "the", "dicm", "prefix", "is", "missing", "from", "the", "header", "use", "force", "true", "to", "force", "reading", "else", "logger", "debug", "0", "08x", "dicm", "prefix", "found", "format", "fp", "tell", "4", "return", "preamble"], "doc_len": 303}
{"doc_id": "pydicom/filereader.py::_at_pixel_data", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "_at_pixel_data", "text": "文件路径: pydicom/filereader.py\ndef _at_pixel_data(tag, VR, length):\n    return tag == (0x7fe0, 0x0010)\n", "tokens": ["pydicom", "filereader", "py", "def", "_at_pixel_data", "tag", "vr", "length", "return", "tag", "0x7fe0", "0x0010"], "doc_len": 12}
{"doc_id": "pydicom/filereader.py::read_partial", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_partial", "text": "文件路径: pydicom/filereader.py\ndef read_partial(fileobj, stop_when=None, defer_size=None,\n                 force=False, specific_tags=None):\n    \"\"\"Parse a DICOM file until a condition is met.\n\n    Parameters\n    ----------\n    fileobj : a file-like object\n        Note that the file will not close when the function returns.\n    stop_when :\n        Stop condition. See ``read_dataset`` for more info.\n    defer_size : int, str, None, optional\n        See ``dcmread`` for parameter info.\n    force : boolean\n        See ``dcmread`` for parameter info.\n    specific_tags : list or None\n        See ``dcmread`` for parameter info.\n\n    Notes\n    -----\n    Use ``dcmread`` unless you need to stop on some condition other than\n    reaching pixel data.\n\n    Returns\n    -------\n    FileDataset instance or DicomDir instance.\n\n    See Also\n    --------\n    dcmread\n        More generic file reading function.\n    \"\"\"\n    # Read File Meta Information\n\n    # Read preamble (if present)\n    preamble = read_preamble(fileobj, force)\n    # Read any File Meta Information group (0002,eeee) elements (if present)\n    file_meta_dataset = _read_file_meta_info(fileobj)\n\n    # Read Dataset\n\n    # Read any Command Set group (0000,eeee) elements (if present)\n    command_set = _read_command_set_elements(fileobj)\n\n    # Check to see if there's anything left to read\n    peek = fileobj.read(1)\n    if peek != b'':\n        fileobj.seek(-1, 1)\n\n    # `filobj` should be positioned at the start of the dataset by this point.\n    # Ensure we have appropriate values for `is_implicit_VR` and\n    # `is_little_endian` before we try decoding. We assume an initial\n    # transfer syntax of implicit VR little endian and correct it as necessary\n    is_implicit_VR = True\n    is_little_endian = True\n    transfer_syntax = file_meta_dataset.get(\"TransferSyntaxUID\")\n    if peek == b'':  # EOF\n        pass\n    elif transfer_syntax is None:  # issue 258\n        # If no TransferSyntaxUID element then we have to try and figure out\n        #   the correct values for `is_little_endian` and `is_implicit_VR`.\n        # Peek at the first 6 bytes to get the first element's tag group and\n        #   (possibly) VR\n        group, _, VR = unpack(\"<HH2s\", fileobj.read(6))\n        fileobj.seek(-6, 1)\n\n        # Test the VR to see if it's valid, and if so then assume explicit VR\n        from pydicom.values import converters\n        if not in_py2:\n            VR = VR.decode(default_encoding)\n        if VR in converters.keys():\n            is_implicit_VR = False\n            # Big endian encoding can only be explicit VR\n            #   Big endian 0x0004 decoded as little endian will be 1024\n            #   Big endian 0x0100 decoded as little endian will be 1\n            # Therefore works for big endian tag groups up to 0x00FF after\n            #   which it will fail, in which case we leave it as little endian\n            #   and hope for the best (big endian is retired anyway)\n            if group >= 1024:\n                is_little_endian = False\n    elif transfer_syntax == pydicom.uid.ImplicitVRLittleEndian:\n        pass\n    elif transfer_syntax == pydicom.uid.ExplicitVRLittleEndian:\n        is_implicit_VR = False\n    elif transfer_syntax == pydicom.uid.ExplicitVRBigEndian:\n        is_implicit_VR = False\n        is_little_endian = False\n    elif transfer_syntax == pydicom.uid.DeflatedExplicitVRLittleEndian:\n        # See PS3.6-2008 A.5 (p 71)\n        # when written, the entire dataset following\n        #     the file metadata was prepared the normal way,\n        #     then \"deflate\" compression applied.\n        #  All that is needed here is to decompress and then\n        #     use as normal in a file-like object\n        zipped = fileobj.read()\n        # -MAX_WBITS part is from comp.lang.python answer:\n        # groups.google.com/group/comp.lang.python/msg/e95b3b38a71e6799\n        unzipped = zlib.decompress(zipped, -zlib.MAX_WBITS)\n        fileobj = BytesIO(unzipped)  # a file-like object\n        is_implicit_VR = False\n    else:\n        # Any other syntax should be Explicit VR Little Endian,\n        #   e.g. all Encapsulated (JPEG etc) are ExplVR-LE\n        #        by Standard PS 3.5-2008 A.4 (p63)\n        is_implicit_VR = False\n\n    # Try and decode the dataset\n    #   By this point we should be at the start of the dataset and have\n    #   the transfer syntax (whether read from the file meta or guessed at)\n    try:\n        dataset = read_dataset(fileobj, is_implicit_VR, is_little_endian,\n                               stop_when=stop_when, defer_size=defer_size,\n                               specific_tags=specific_tags)\n    except EOFError:\n        pass  # error already logged in read_dataset\n\n    # Add the command set elements to the dataset (if any)\n    dataset.update(command_set._dict)\n\n    class_uid = file_meta_dataset.get(\"MediaStorageSOPClassUID\", None)\n    if class_uid and class_uid.name == \"Media Storage Directory Storage\":\n        dataset_class = DicomDir\n    else:\n        dataset_class = FileDataset\n    new_dataset = dataset_class(fileobj, dataset, preamble, file_meta_dataset,\n                                is_implicit_VR, is_little_endian)\n    # save the originally read transfer syntax properties in the dataset\n    new_dataset.set_original_encoding(is_implicit_VR, is_little_endian,\n                                      dataset._character_set)\n    return new_dataset\n", "tokens": ["pydicom", "filereader", "py", "def", "read_partial", "fileobj", "stop_when", "none", "defer_size", "none", "force", "false", "specific_tags", "none", "parse", "a", "dicom", "file", "until", "a", "condition", "is", "met", "parameters", "fileobj", "a", "file", "like", "object", "note", "that", "the", "file", "will", "not", "close", "when", "the", "function", "returns", "stop_when", "stop", "condition", "see", "read_dataset", "for", "more", "info", "defer_size", "int", "str", "none", "optional", "see", "dcmread", "for", "parameter", "info", "force", "boolean", "see", "dcmread", "for", "parameter", "info", "specific_tags", "list", "or", "none", "see", "dcmread", "for", "parameter", "info", "notes", "use", "dcmread", "unless", "you", "need", "to", "stop", "on", "some", "condition", "other", "than", "reaching", "pixel", "data", "returns", "filedataset", "instance", "or", "dicomdir", "instance", "see", "also", "dcmread", "more", "generic", "file", "reading", "function", "read", "file", "meta", "information", "read", "preamble", "if", "present", "preamble", "read_preamble", "fileobj", "force", "read", "any", "file", "meta", "information", "group", "0002", "eeee", "elements", "if", "present", "file_meta_dataset", "_read_file_meta_info", "fileobj", "read", "dataset", "read", "any", "command", "set", "group", "0000", "eeee", "elements", "if", "present", "command_set", "_read_command_set_elements", "fileobj", "check", "to", "see", "if", "there", "s", "anything", "left", "to", "read", "peek", "fileobj", "read", "1", "if", "peek", "b", "fileobj", "seek", "1", "1", "filobj", "should", "be", "positioned", "at", "the", "start", "of", "the", "dataset", "by", "this", "point", "ensure", "we", "have", "appropriate", "values", "for", "is_implicit_vr", "and", "is_little_endian", "before", "we", "try", "decoding", "we", "assume", "an", "initial", "transfer", "syntax", "of", "implicit", "vr", "little", "endian", "and", "correct", "it", "as", "necessary", "is_implicit_vr", "true", "is_little_endian", "true", "transfer_syntax", "file_meta_dataset", "get", "transfersyntaxuid", "if", "peek", "b", "eof", "pass", "elif", "transfer_syntax", "is", "none", "issue", "258", "if", "no", "transfersyntaxuid", "element", "then", "we", "have", "to", "try", "and", "figure", "out", "the", "correct", "values", "for", "is_little_endian", "and", "is_implicit_vr", "peek", "at", "the", "first", "6", "bytes", "to", "get", "the", "first", "element", "s", "tag", "group", "and", "possibly", "vr", "group", "_", "vr", "unpack", "hh2s", "fileobj", "read", "6", "fileobj", "seek", "6", "1", "test", "the", "vr", "to", "see", "if", "it", "s", "valid", "and", "if", "so", "then", "assume", "explicit", "vr", "from", "pydicom", "values", "import", "converters", "if", "not", "in_py2", "vr", "vr", "decode", "default_encoding", "if", "vr", "in", "converters", "keys", "is_implicit_vr", "false", "big", "endian", "encoding", "can", "only", "be", "explicit", "vr", "big", "endian", "0x0004", "decoded", "as", "little", "endian", "will", "be", "1024", "big", "endian", "0x0100", "decoded", "as", "little", "endian", "will", "be", "1", "therefore", "works", "for", "big", "endian", "tag", "groups", "up", "to", "0x00ff", "after", "which", "it", "will", "fail", "in", "which", "case", "we", "leave", "it", "as", "little", "endian", "and", "hope", "for", "the", "best", "big", "endian", "is", "retired", "anyway", "if", "group", "1024", "is_little_endian", "false", "elif", "transfer_syntax", "pydicom", "uid", "implicitvrlittleendian", "pass", "elif", "transfer_syntax", "pydicom", "uid", "explicitvrlittleendian", "is_implicit_vr", "false", "elif", "transfer_syntax", "pydicom", "uid", "explicitvrbigendian", "is_implicit_vr", "false", "is_little_endian", "false", "elif", "transfer_syntax", "pydicom", "uid", "deflatedexplicitvrlittleendian", "see", "ps3", "6", "2008", "a", "5", "p", "71", "when", "written", "the", "entire", "dataset", "following", "the", "file", "metadata", "was", "prepared", "the", "normal", "way", "then", "deflate", "compression", "applied", "all", "that", "is", "needed", "here", "is", "to", "decompress", "and", "then", "use", "as", "normal", "in", "a", "file", "like", "object", "zipped", "fileobj", "read", "max_wbits", "part", "is", "from", "comp", "lang", "python", "answer", "groups", "google", "com", "group", "comp", "lang", "python", "msg", "e95b3b38a71e6799", "unzipped", "zlib", "decompress", "zipped", "zlib", "max_wbits", "fileobj", "bytesio", "unzipped", "a", "file", "like", "object", "is_implicit_vr", "false", "else", "any", "other", "syntax", "should", "be", "explicit", "vr", "little", "endian", "e", "g", "all", "encapsulated", "jpeg", "etc", "are", "explvr", "le", "by", "standard", "ps", "3", "5", "2008", "a", "4", "p63", "is_implicit_vr", "false", "try", "and", "decode", "the", "dataset", "by", "this", "point", "we", "should", "be", "at", "the", "start", "of", "the", "dataset", "and", "have", "the", "transfer", "syntax", "whether", "read", "from", "the", "file", "meta", "or", "guessed", "at", "try", "dataset", "read_dataset", "fileobj", "is_implicit_vr", "is_little_endian", "stop_when", "stop_when", "defer_size", "defer_size", "specific_tags", "specific_tags", "except", "eoferror", "pass", "error", "already", "logged", "in", "read_dataset", "add", "the", "command", "set", "elements", "to", "the", "dataset", "if", "any", "dataset", "update", "command_set", "_dict", "class_uid", "file_meta_dataset", "get", "mediastoragesopclassuid", "none", "if", "class_uid", "and", "class_uid", "name", "media", "storage", "directory", "storage", "dataset_class", "dicomdir", "else", "dataset_class", "filedataset", "new_dataset", "dataset_class", "fileobj", "dataset", "preamble", "file_meta_dataset", "is_implicit_vr", "is_little_endian", "save", "the", "originally", "read", "transfer", "syntax", "properties", "in", "the", "dataset", "new_dataset", "set_original_encoding", "is_implicit_vr", "is_little_endian", "dataset", "_character_set", "return", "new_dataset"], "doc_len": 623}
{"doc_id": "pydicom/filereader.py::dcmread", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "dcmread", "text": "文件路径: pydicom/filereader.py\ndef dcmread(fp, defer_size=None, stop_before_pixels=False,\n            force=False, specific_tags=None):\n    \"\"\"Read and parse a DICOM dataset stored in the DICOM File Format.\n\n    Read a DICOM dataset stored in accordance with the DICOM File Format\n    (DICOM Standard Part 10 Section 7). If the dataset is not stored in\n    accordance with the File Format (i.e. the preamble and prefix are missing,\n    there are missing required Type 1 File Meta Information Group elements\n    or the entire File Meta Information is missing) then you will have to\n    set `force` to True.\n\n    Parameters\n    ----------\n    fp : str or file-like\n        Either a file-like object, or a string containing the file name. If a\n        file-like object, the caller is responsible for closing it.\n    defer_size : int or str or None\n        If None (default), all elements read into memory. If specified, then if\n        a data element's stored value is larger than `defer_size`, the value is\n        not read into memory until it is accessed in code. Specify an integer\n        (bytes), or a string value with units, e.g. \"512 KB\", \"2 MB\".\n    stop_before_pixels : bool\n        If False (default), the full file will be read and parsed. Set True to\n        stop before reading (7FE0,0010) 'Pixel Data' (and all subsequent\n        elements).\n    force : bool\n        If False (default), raises an InvalidDicomError if the file is missing\n        the File Meta Information header. Set to True to force reading even if\n        no File Meta Information header is found.\n    specific_tags : list or None\n        If not None, only the tags in the list are returned. The list\n        elements can be tags or tag names. Note that the tag Specific\n        Character Set is always returned if present - this ensures correct\n        decoding of returned text values.\n\n    Returns\n    -------\n    FileDataset\n        An instance of FileDataset that represents a parsed DICOM file.\n\n    Raises\n    ------\n    InvalidDicomError\n        If `force` is True and the file is not a valid DICOM file.\n\n    See Also\n    --------\n    pydicom.dataset.FileDataset\n        Data class that is returned.\n    pydicom.filereader.read_partial\n        Only read part of a DICOM file, stopping on given conditions.\n\n    Examples\n    --------\n    Read and return a dataset stored in accordance with the DICOM File Format:\n\n    >>> ds = pydicom.dcmread(\"rtplan.dcm\")\n    >>> ds.PatientName\n\n    Read and return a dataset not in accordance with the DICOM File Format:\n\n    >>> ds = pydicom.dcmread(\"rtplan.dcm\", force=True)\n    >>> ds.PatientName\n\n    Use within a context manager:\n\n    >>> with pydicom.dcmread(\"rtplan.dcm\") as ds:\n    >>>     ds.PatientName\n    \"\"\"\n    # Open file if not already a file object\n    caller_owns_file = True\n    if isinstance(fp, compat.string_types):\n        # caller provided a file name; we own the file handle\n        caller_owns_file = False\n        try:\n            logger.debug(u\"Reading file '{0}'\".format(fp))\n        except Exception:\n            logger.debug(\"Reading file '{0}'\".format(fp))\n        fp = open(fp, 'rb')\n\n    if config.debugging:\n        logger.debug(\"\\n\" + \"-\" * 80)\n        logger.debug(\"Call to dcmread()\")\n        msg = (\"filename:'%s', defer_size='%s', \"\n               \"stop_before_pixels=%s, force=%s, specific_tags=%s\")\n        logger.debug(msg % (fp.name, defer_size, stop_before_pixels,\n                            force, specific_tags))\n        if caller_owns_file:\n            logger.debug(\"Caller passed file object\")\n        else:\n            logger.debug(\"Caller passed file name\")\n        logger.debug(\"-\" * 80)\n\n    # Convert size to defer reading into bytes\n    defer_size = size_in_bytes(defer_size)\n\n    # Iterate through all items and store them --include file meta if present\n    stop_when = None\n    if stop_before_pixels:\n        stop_when = _at_pixel_data\n    try:\n        dataset = read_partial(fp, stop_when, defer_size=defer_size,\n                               force=force, specific_tags=specific_tags)\n    finally:\n        if not caller_owns_file:\n            fp.close()\n    # XXX need to store transfer syntax etc.\n    return dataset\n", "tokens": ["pydicom", "filereader", "py", "def", "dcmread", "fp", "defer_size", "none", "stop_before_pixels", "false", "force", "false", "specific_tags", "none", "read", "and", "parse", "a", "dicom", "dataset", "stored", "in", "the", "dicom", "file", "format", "read", "a", "dicom", "dataset", "stored", "in", "accordance", "with", "the", "dicom", "file", "format", "dicom", "standard", "part", "10", "section", "7", "if", "the", "dataset", "is", "not", "stored", "in", "accordance", "with", "the", "file", "format", "i", "e", "the", "preamble", "and", "prefix", "are", "missing", "there", "are", "missing", "required", "type", "1", "file", "meta", "information", "group", "elements", "or", "the", "entire", "file", "meta", "information", "is", "missing", "then", "you", "will", "have", "to", "set", "force", "to", "true", "parameters", "fp", "str", "or", "file", "like", "either", "a", "file", "like", "object", "or", "a", "string", "containing", "the", "file", "name", "if", "a", "file", "like", "object", "the", "caller", "is", "responsible", "for", "closing", "it", "defer_size", "int", "or", "str", "or", "none", "if", "none", "default", "all", "elements", "read", "into", "memory", "if", "specified", "then", "if", "a", "data", "element", "s", "stored", "value", "is", "larger", "than", "defer_size", "the", "value", "is", "not", "read", "into", "memory", "until", "it", "is", "accessed", "in", "code", "specify", "an", "integer", "bytes", "or", "a", "string", "value", "with", "units", "e", "g", "512", "kb", "2", "mb", "stop_before_pixels", "bool", "if", "false", "default", "the", "full", "file", "will", "be", "read", "and", "parsed", "set", "true", "to", "stop", "before", "reading", "7fe0", "0010", "pixel", "data", "and", "all", "subsequent", "elements", "force", "bool", "if", "false", "default", "raises", "an", "invaliddicomerror", "if", "the", "file", "is", "missing", "the", "file", "meta", "information", "header", "set", "to", "true", "to", "force", "reading", "even", "if", "no", "file", "meta", "information", "header", "is", "found", "specific_tags", "list", "or", "none", "if", "not", "none", "only", "the", "tags", "in", "the", "list", "are", "returned", "the", "list", "elements", "can", "be", "tags", "or", "tag", "names", "note", "that", "the", "tag", "specific", "character", "set", "is", "always", "returned", "if", "present", "this", "ensures", "correct", "decoding", "of", "returned", "text", "values", "returns", "filedataset", "an", "instance", "of", "filedataset", "that", "represents", "a", "parsed", "dicom", "file", "raises", "invaliddicomerror", "if", "force", "is", "true", "and", "the", "file", "is", "not", "a", "valid", "dicom", "file", "see", "also", "pydicom", "dataset", "filedataset", "data", "class", "that", "is", "returned", "pydicom", "filereader", "read_partial", "only", "read", "part", "of", "a", "dicom", "file", "stopping", "on", "given", "conditions", "examples", "read", "and", "return", "a", "dataset", "stored", "in", "accordance", "with", "the", "dicom", "file", "format", "ds", "pydicom", "dcmread", "rtplan", "dcm", "ds", "patientname", "read", "and", "return", "a", "dataset", "not", "in", "accordance", "with", "the", "dicom", "file", "format", "ds", "pydicom", "dcmread", "rtplan", "dcm", "force", "true", "ds", "patientname", "use", "within", "a", "context", "manager", "with", "pydicom", "dcmread", "rtplan", "dcm", "as", "ds", "ds", "patientname", "open", "file", "if", "not", "already", "a", "file", "object", "caller_owns_file", "true", "if", "isinstance", "fp", "compat", "string_types", "caller", "provided", "a", "file", "name", "we", "own", "the", "file", "handle", "caller_owns_file", "false", "try", "logger", "debug", "u", "reading", "file", "0", "format", "fp", "except", "exception", "logger", "debug", "reading", "file", "0", "format", "fp", "fp", "open", "fp", "rb", "if", "config", "debugging", "logger", "debug", "n", "80", "logger", "debug", "call", "to", "dcmread", "msg", "filename", "s", "defer_size", "s", "stop_before_pixels", "s", "force", "s", "specific_tags", "s", "logger", "debug", "msg", "fp", "name", "defer_size", "stop_before_pixels", "force", "specific_tags", "if", "caller_owns_file", "logger", "debug", "caller", "passed", "file", "object", "else", "logger", "debug", "caller", "passed", "file", "name", "logger", "debug", "80", "convert", "size", "to", "defer", "reading", "into", "bytes", "defer_size", "size_in_bytes", "defer_size", "iterate", "through", "all", "items", "and", "store", "them", "include", "file", "meta", "if", "present", "stop_when", "none", "if", "stop_before_pixels", "stop_when", "_at_pixel_data", "try", "dataset", "read_partial", "fp", "stop_when", "defer_size", "defer_size", "force", "force", "specific_tags", "specific_tags", "finally", "if", "not", "caller_owns_file", "fp", "close", "xxx", "need", "to", "store", "transfer", "syntax", "etc", "return", "dataset"], "doc_len": 544}
{"doc_id": "pydicom/filereader.py::read_dicomdir", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_dicomdir", "text": "文件路径: pydicom/filereader.py\ndef read_dicomdir(filename=\"DICOMDIR\"):\n    \"\"\"Read a DICOMDIR file and return a DicomDir instance.\n\n    This is a wrapper around dcmread, which gives a default file name.\n\n    Parameters\n    ----------\n    filename : str, optional\n        Full path and name to DICOMDIR file to open\n\n    Returns\n    -------\n    DicomDir\n\n    Raises\n    ------\n    InvalidDicomError\n        Raised if filename is not a DICOMDIR file.\n    \"\"\"\n    # dcmread will return a DicomDir instance if file is one.\n\n    # Read the file as usual.\n    ds = dcmread(filename)\n    # Here, check that it is in fact DicomDir\n    if not isinstance(ds, DicomDir):\n        msg = u\"File '{0}' is not a Media Storage Directory file\".format(\n            filename)\n        raise InvalidDicomError(msg)\n    return ds\n", "tokens": ["pydicom", "filereader", "py", "def", "read_dicomdir", "filename", "dicomdir", "read", "a", "dicomdir", "file", "and", "return", "a", "dicomdir", "instance", "this", "is", "a", "wrapper", "around", "dcmread", "which", "gives", "a", "default", "file", "name", "parameters", "filename", "str", "optional", "full", "path", "and", "name", "to", "dicomdir", "file", "to", "open", "returns", "dicomdir", "raises", "invaliddicomerror", "raised", "if", "filename", "is", "not", "a", "dicomdir", "file", "dcmread", "will", "return", "a", "dicomdir", "instance", "if", "file", "is", "one", "read", "the", "file", "as", "usual", "ds", "dcmread", "filename", "here", "check", "that", "it", "is", "in", "fact", "dicomdir", "if", "not", "isinstance", "ds", "dicomdir", "msg", "u", "file", "0", "is", "not", "a", "media", "storage", "directory", "file", "format", "filename", "raise", "invaliddicomerror", "msg", "return", "ds"], "doc_len": 102}
{"doc_id": "pydicom/filereader.py::data_element_offset_to_value", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "data_element_offset_to_value", "text": "文件路径: pydicom/filereader.py\ndef data_element_offset_to_value(is_implicit_VR, VR):\n    \"\"\"Return number of bytes from start of data element to start of value\"\"\"\n    if is_implicit_VR:\n        offset = 8  # tag of 4 plus 4-byte length\n    else:\n        if VR in extra_length_VRs:\n            offset = 12  # tag 4 + 2 VR + 2 reserved + 4 length\n        else:\n            offset = 8  # tag 4 + 2 VR + 2 length\n    return offset\n", "tokens": ["pydicom", "filereader", "py", "def", "data_element_offset_to_value", "is_implicit_vr", "vr", "return", "number", "of", "bytes", "from", "start", "of", "data", "element", "to", "start", "of", "value", "if", "is_implicit_vr", "offset", "8", "tag", "of", "4", "plus", "4", "byte", "length", "else", "if", "vr", "in", "extra_length_vrs", "offset", "12", "tag", "4", "2", "vr", "2", "reserved", "4", "length", "else", "offset", "8", "tag", "4", "2", "vr", "2", "length", "return", "offset"], "doc_len": 57}
{"doc_id": "pydicom/filereader.py::read_deferred_data_element", "file_path": "pydicom/filereader.py", "class_name": null, "func_name": "read_deferred_data_element", "text": "文件路径: pydicom/filereader.py\ndef read_deferred_data_element(fileobj_type, filename, timestamp,\n                               raw_data_elem):\n    \"\"\"Read the previously deferred value from the file into memory\n    and return a raw data element\"\"\"\n    logger.debug(\"Reading deferred element %r\" % str(raw_data_elem.tag))\n    # If it wasn't read from a file, then return an error\n    if filename is None:\n        raise IOError(\"Deferred read -- original filename not stored. \"\n                      \"Cannot re-open\")\n    # Check that the file is the same as when originally read\n    if not os.path.exists(filename):\n        raise IOError(u\"Deferred read -- original file \"\n                      \"{0:s} is missing\".format(filename))\n    if timestamp is not None:\n        statinfo = os.stat(filename)\n        if statinfo.st_mtime != timestamp:\n            warnings.warn(\"Deferred read warning -- file modification time \"\n                          \"has changed.\")\n\n    # Open the file, position to the right place\n    # fp = self.typefileobj(self.filename, \"rb\")\n    fp = fileobj_type(filename, 'rb')\n    is_implicit_VR = raw_data_elem.is_implicit_VR\n    is_little_endian = raw_data_elem.is_little_endian\n    offset = data_element_offset_to_value(is_implicit_VR, raw_data_elem.VR)\n    fp.seek(raw_data_elem.value_tell - offset)\n    elem_gen = data_element_generator(fp, is_implicit_VR, is_little_endian,\n                                      defer_size=None)\n\n    # Read the data element and check matches what was stored before\n    data_elem = next(elem_gen)\n    fp.close()\n    if data_elem.VR != raw_data_elem.VR:\n        raise ValueError(\"Deferred read VR {0:s} does not match \"\n                         \"original {1:s}\".format(data_elem.VR,\n                                                 raw_data_elem.VR))\n    if data_elem.tag != raw_data_elem.tag:\n        raise ValueError(\"Deferred read tag {0!r} does not match \"\n                         \"original {1!r}\".format(data_elem.tag,\n                                                 raw_data_elem.tag))\n\n    # Everything is ok, now this object should act like usual DataElement\n    return data_elem\n", "tokens": ["pydicom", "filereader", "py", "def", "read_deferred_data_element", "fileobj_type", "filename", "timestamp", "raw_data_elem", "read", "the", "previously", "deferred", "value", "from", "the", "file", "into", "memory", "and", "return", "a", "raw", "data", "element", "logger", "debug", "reading", "deferred", "element", "r", "str", "raw_data_elem", "tag", "if", "it", "wasn", "t", "read", "from", "a", "file", "then", "return", "an", "error", "if", "filename", "is", "none", "raise", "ioerror", "deferred", "read", "original", "filename", "not", "stored", "cannot", "re", "open", "check", "that", "the", "file", "is", "the", "same", "as", "when", "originally", "read", "if", "not", "os", "path", "exists", "filename", "raise", "ioerror", "u", "deferred", "read", "original", "file", "0", "s", "is", "missing", "format", "filename", "if", "timestamp", "is", "not", "none", "statinfo", "os", "stat", "filename", "if", "statinfo", "st_mtime", "timestamp", "warnings", "warn", "deferred", "read", "warning", "file", "modification", "time", "has", "changed", "open", "the", "file", "position", "to", "the", "right", "place", "fp", "self", "typefileobj", "self", "filename", "rb", "fp", "fileobj_type", "filename", "rb", "is_implicit_vr", "raw_data_elem", "is_implicit_vr", "is_little_endian", "raw_data_elem", "is_little_endian", "offset", "data_element_offset_to_value", "is_implicit_vr", "raw_data_elem", "vr", "fp", "seek", "raw_data_elem", "value_tell", "offset", "elem_gen", "data_element_generator", "fp", "is_implicit_vr", "is_little_endian", "defer_size", "none", "read", "the", "data", "element", "and", "check", "matches", "what", "was", "stored", "before", "data_elem", "next", "elem_gen", "fp", "close", "if", "data_elem", "vr", "raw_data_elem", "vr", "raise", "valueerror", "deferred", "read", "vr", "0", "s", "does", "not", "match", "original", "1", "s", "format", "data_elem", "vr", "raw_data_elem", "vr", "if", "data_elem", "tag", "raw_data_elem", "tag", "raise", "valueerror", "deferred", "read", "tag", "0", "r", "does", "not", "match", "original", "1", "r", "format", "data_elem", "tag", "raw_data_elem", "tag", "everything", "is", "ok", "now", "this", "object", "should", "act", "like", "usual", "dataelement", "return", "data_elem"], "doc_len": 230}
{"doc_id": "pydicom/fileutil.py::absorb_delimiter_item", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "absorb_delimiter_item", "text": "文件路径: pydicom/fileutil.py\ndef absorb_delimiter_item(fp, is_little_endian, delimiter):\n    \"\"\"Read (and ignore) undefined length sequence or item terminators.\"\"\"\n    if is_little_endian:\n        struct_format = \"<HHL\"\n    else:\n        struct_format = \">HHL\"\n    group, elem, length = unpack(struct_format, fp.read(8))\n    tag = TupleTag((group, elem))\n    if tag != delimiter:\n        msg = (\"Did not find expected delimiter '%s'\" %\n               dictionary_description(delimiter))\n        msg += \", instead found %s at file position 0x%x\" % (\n            str(tag), fp.tell() - 8)\n        logger.warn(msg)\n        fp.seek(fp.tell() - 8)\n        return\n    logger.debug(\"%04x: Found Delimiter '%s'\", fp.tell() - 8,\n                 dictionary_description(delimiter))\n    if length == 0:\n        logger.debug(\"%04x: Read 0 bytes after delimiter\", fp.tell() - 4)\n    else:\n        logger.debug(\"%04x: Expected 0x00000000 after delimiter, found 0x%x\",\n                     fp.tell() - 4, length)\n", "tokens": ["pydicom", "fileutil", "py", "def", "absorb_delimiter_item", "fp", "is_little_endian", "delimiter", "read", "and", "ignore", "undefined", "length", "sequence", "or", "item", "terminators", "if", "is_little_endian", "struct_format", "hhl", "else", "struct_format", "hhl", "group", "elem", "length", "unpack", "struct_format", "fp", "read", "8", "tag", "tupletag", "group", "elem", "if", "tag", "delimiter", "msg", "did", "not", "find", "expected", "delimiter", "s", "dictionary_description", "delimiter", "msg", "instead", "found", "s", "at", "file", "position", "0x", "x", "str", "tag", "fp", "tell", "8", "logger", "warn", "msg", "fp", "seek", "fp", "tell", "8", "return", "logger", "debug", "04x", "found", "delimiter", "s", "fp", "tell", "8", "dictionary_description", "delimiter", "if", "length", "0", "logger", "debug", "04x", "read", "0", "bytes", "after", "delimiter", "fp", "tell", "4", "else", "logger", "debug", "04x", "expected", "0x00000000", "after", "delimiter", "found", "0x", "x", "fp", "tell", "4", "length"], "doc_len": 111}
{"doc_id": "pydicom/fileutil.py::find_bytes", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "find_bytes", "text": "文件路径: pydicom/fileutil.py\ndef find_bytes(fp, bytes_to_find, read_size=128, rewind=True):\n    \"\"\"Read in the file until a specific byte sequence found.\n\n    Parameters\n    ----------\n    fp : file-like object\n    bytes_to_find : str\n        Contains the bytes to find. Must be in correct\n        endian order already.\n    read_size : int\n        Number of bytes to read at a time.\n    rewind : boolean\n        Flag to rewind file reading position.\n\n    Returns\n    -------\n    found_at : byte, None\n        Position where byte sequence was found, else None.\n    \"\"\"\n\n    data_start = fp.tell()\n    search_rewind = len(bytes_to_find) - 1\n\n    found = False\n    eof = False\n    while not found:\n        chunk_start = fp.tell()\n        bytes_read = fp.read(read_size)\n        if len(bytes_read) < read_size:\n            # try again - if still don't get required amount,\n            # this is the last block\n            new_bytes = fp.read(read_size - len(bytes_read))\n            bytes_read += new_bytes\n            if len(bytes_read) < read_size:\n                eof = True  # but will still check whatever we did get\n        index = bytes_read.find(bytes_to_find)\n        if index != -1:\n            found = True\n        elif eof:\n            if rewind:\n                fp.seek(data_start)\n            return None\n        else:\n            # rewind a bit in case delimiter crossed read_size boundary\n            fp.seek(fp.tell() - search_rewind)\n    # if get here then have found the byte string\n    found_at = chunk_start + index\n    if rewind:\n        fp.seek(data_start)\n    else:\n        fp.seek(found_at + len(bytes_to_find))\n    return found_at\n", "tokens": ["pydicom", "fileutil", "py", "def", "find_bytes", "fp", "bytes_to_find", "read_size", "128", "rewind", "true", "read", "in", "the", "file", "until", "a", "specific", "byte", "sequence", "found", "parameters", "fp", "file", "like", "object", "bytes_to_find", "str", "contains", "the", "bytes", "to", "find", "must", "be", "in", "correct", "endian", "order", "already", "read_size", "int", "number", "of", "bytes", "to", "read", "at", "a", "time", "rewind", "boolean", "flag", "to", "rewind", "file", "reading", "position", "returns", "found_at", "byte", "none", "position", "where", "byte", "sequence", "was", "found", "else", "none", "data_start", "fp", "tell", "search_rewind", "len", "bytes_to_find", "1", "found", "false", "eof", "false", "while", "not", "found", "chunk_start", "fp", "tell", "bytes_read", "fp", "read", "read_size", "if", "len", "bytes_read", "read_size", "try", "again", "if", "still", "don", "t", "get", "required", "amount", "this", "is", "the", "last", "block", "new_bytes", "fp", "read", "read_size", "len", "bytes_read", "bytes_read", "new_bytes", "if", "len", "bytes_read", "read_size", "eof", "true", "but", "will", "still", "check", "whatever", "we", "did", "get", "index", "bytes_read", "find", "bytes_to_find", "if", "index", "1", "found", "true", "elif", "eof", "if", "rewind", "fp", "seek", "data_start", "return", "none", "else", "rewind", "a", "bit", "in", "case", "delimiter", "crossed", "read_size", "boundary", "fp", "seek", "fp", "tell", "search_rewind", "if", "get", "here", "then", "have", "found", "the", "byte", "string", "found_at", "chunk_start", "index", "if", "rewind", "fp", "seek", "data_start", "else", "fp", "seek", "found_at", "len", "bytes_to_find", "return", "found_at"], "doc_len": 189}
{"doc_id": "pydicom/fileutil.py::read_undefined_length_value", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "read_undefined_length_value", "text": "文件路径: pydicom/fileutil.py\ndef read_undefined_length_value(fp,\n                                is_little_endian,\n                                delimiter_tag,\n                                defer_size=None,\n                                read_size=1024*8):\n    \"\"\"Read until the delimiter tag found and return the value;\n     ignore the delimiter.\n\n    On completion, the file will be set to the first byte after the delimiter\n    and its following four zero bytes.\n\n    Parameters\n    ----------\n    fp : a file-like object\n    is_little_endian : boolean\n        True if file transfer syntax is little endian, else False.\n    delimiter_tag : BaseTag\n        tag used as and marker for reading\n    defer_size : int, None, optional\n        Size to avoid loading large elements in memory.\n        See ``filereader.dcmread`` for more parameter info.\n    read_size : int\n        Number of bytes to read at one time.\n\n    Returns\n    -------\n    delimiter : str, None\n        The file delimiter\n\n    Raises\n    ------\n    EOFError\n        If EOF is reached before delimiter found.\n    \"\"\"\n    data_start = fp.tell()\n    search_rewind = 3\n\n    if is_little_endian:\n        bytes_format = b\"<HH\"\n    else:\n        bytes_format = b\">HH\"\n    bytes_to_find = pack(bytes_format, delimiter_tag.group, delimiter_tag.elem)\n\n    found = False\n    eof = False\n    value_chunks = []\n    defer_size = size_in_bytes(defer_size)\n    byte_count = 0  # for defer_size checks\n    while not found:\n        chunk_start = fp.tell()\n        bytes_read = fp.read(read_size)\n        if len(bytes_read) < read_size:\n            # try again - if still don't get required amount,\n            # this is the last block\n            new_bytes = fp.read(read_size - len(bytes_read))\n            bytes_read += new_bytes\n            if len(bytes_read) < read_size:\n                eof = True  # but will still check whatever we did get\n        index = bytes_read.find(bytes_to_find)\n        if index != -1:\n            found = True\n            new_bytes = bytes_read[:index]\n            byte_count += len(new_bytes)\n            if defer_size is None or byte_count < defer_size:\n                value_chunks.append(bytes_read[:index])\n            fp.seek(chunk_start + index + 4)  # rewind to end of delimiter\n            length = fp.read(4)\n            if length != b\"\\0\\0\\0\\0\":\n                msg = (\"Expected 4 zero bytes after undefined length delimiter\"\n                       \" at pos {0:04x}\")\n                logger.error(msg.format(fp.tell() - 4))\n        elif eof:\n            fp.seek(data_start)\n            raise EOFError(\"End of file reached before delimiter {0!r} found\".\n                           format(delimiter_tag))\n        else:\n            # rewind a bit in case delimiter crossed read_size boundary\n            fp.seek(fp.tell() - search_rewind)\n            # accumulate the bytes read (not including the rewind)\n            new_bytes = bytes_read[:-search_rewind]\n            byte_count += len(new_bytes)\n            if defer_size is None or byte_count < defer_size:\n                value_chunks.append(new_bytes)\n    # if get here then have found the byte string\n    if defer_size is not None and byte_count >= defer_size:\n        return None\n    else:\n        return b\"\".join(value_chunks)\n", "tokens": ["pydicom", "fileutil", "py", "def", "read_undefined_length_value", "fp", "is_little_endian", "delimiter_tag", "defer_size", "none", "read_size", "1024", "8", "read", "until", "the", "delimiter", "tag", "found", "and", "return", "the", "value", "ignore", "the", "delimiter", "on", "completion", "the", "file", "will", "be", "set", "to", "the", "first", "byte", "after", "the", "delimiter", "and", "its", "following", "four", "zero", "bytes", "parameters", "fp", "a", "file", "like", "object", "is_little_endian", "boolean", "true", "if", "file", "transfer", "syntax", "is", "little", "endian", "else", "false", "delimiter_tag", "basetag", "tag", "used", "as", "and", "marker", "for", "reading", "defer_size", "int", "none", "optional", "size", "to", "avoid", "loading", "large", "elements", "in", "memory", "see", "filereader", "dcmread", "for", "more", "parameter", "info", "read_size", "int", "number", "of", "bytes", "to", "read", "at", "one", "time", "returns", "delimiter", "str", "none", "the", "file", "delimiter", "raises", "eoferror", "if", "eof", "is", "reached", "before", "delimiter", "found", "data_start", "fp", "tell", "search_rewind", "3", "if", "is_little_endian", "bytes_format", "b", "hh", "else", "bytes_format", "b", "hh", "bytes_to_find", "pack", "bytes_format", "delimiter_tag", "group", "delimiter_tag", "elem", "found", "false", "eof", "false", "value_chunks", "defer_size", "size_in_bytes", "defer_size", "byte_count", "0", "for", "defer_size", "checks", "while", "not", "found", "chunk_start", "fp", "tell", "bytes_read", "fp", "read", "read_size", "if", "len", "bytes_read", "read_size", "try", "again", "if", "still", "don", "t", "get", "required", "amount", "this", "is", "the", "last", "block", "new_bytes", "fp", "read", "read_size", "len", "bytes_read", "bytes_read", "new_bytes", "if", "len", "bytes_read", "read_size", "eof", "true", "but", "will", "still", "check", "whatever", "we", "did", "get", "index", "bytes_read", "find", "bytes_to_find", "if", "index", "1", "found", "true", "new_bytes", "bytes_read", "index", "byte_count", "len", "new_bytes", "if", "defer_size", "is", "none", "or", "byte_count", "defer_size", "value_chunks", "append", "bytes_read", "index", "fp", "seek", "chunk_start", "index", "4", "rewind", "to", "end", "of", "delimiter", "length", "fp", "read", "4", "if", "length", "b", "0", "0", "0", "0", "msg", "expected", "4", "zero", "bytes", "after", "undefined", "length", "delimiter", "at", "pos", "0", "04x", "logger", "error", "msg", "format", "fp", "tell", "4", "elif", "eof", "fp", "seek", "data_start", "raise", "eoferror", "end", "of", "file", "reached", "before", "delimiter", "0", "r", "found", "format", "delimiter_tag", "else", "rewind", "a", "bit", "in", "case", "delimiter", "crossed", "read_size", "boundary", "fp", "seek", "fp", "tell", "search_rewind", "accumulate", "the", "bytes", "read", "not", "including", "the", "rewind", "new_bytes", "bytes_read", "search_rewind", "byte_count", "len", "new_bytes", "if", "defer_size", "is", "none", "or", "byte_count", "defer_size", "value_chunks", "append", "new_bytes", "if", "get", "here", "then", "have", "found", "the", "byte", "string", "if", "defer_size", "is", "not", "none", "and", "byte_count", "defer_size", "return", "none", "else", "return", "b", "join", "value_chunks"], "doc_len": 350}
{"doc_id": "pydicom/fileutil.py::find_delimiter", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "find_delimiter", "text": "文件路径: pydicom/fileutil.py\ndef find_delimiter(fp, delimiter, is_little_endian, read_size=128,\n                   rewind=True):\n    \"\"\"Return file position where 4-byte delimiter is located.\n\n    Parameters\n    ----------\n    delimiter :\n    is_little_endian : boolean\n    read_size : int\n        See ``find_bytes`` for parameter info.\n    rewind : boolean\n        Flag to rewind to initial position after searching.\n\n    Returns\n    -------\n    file position of delimiter, None\n        Returns None if end of file is reached without finding the delimiter.\n    \"\"\"\n    struct_format = \"<H\"\n    if not is_little_endian:\n        struct_format = \">H\"\n    delimiter = Tag(delimiter)\n    bytes_to_find = pack(struct_format, delimiter.group) + pack(\n        struct_format, delimiter.elem)\n    return find_bytes(fp, bytes_to_find, read_size=read_size, rewind=rewind)\n", "tokens": ["pydicom", "fileutil", "py", "def", "find_delimiter", "fp", "delimiter", "is_little_endian", "read_size", "128", "rewind", "true", "return", "file", "position", "where", "4", "byte", "delimiter", "is", "located", "parameters", "delimiter", "is_little_endian", "boolean", "read_size", "int", "see", "find_bytes", "for", "parameter", "info", "rewind", "boolean", "flag", "to", "rewind", "to", "initial", "position", "after", "searching", "returns", "file", "position", "of", "delimiter", "none", "returns", "none", "if", "end", "of", "file", "is", "reached", "without", "finding", "the", "delimiter", "struct_format", "h", "if", "not", "is_little_endian", "struct_format", "h", "delimiter", "tag", "delimiter", "bytes_to_find", "pack", "struct_format", "delimiter", "group", "pack", "struct_format", "delimiter", "elem", "return", "find_bytes", "fp", "bytes_to_find", "read_size", "read_size", "rewind", "rewind"], "doc_len": 87}
{"doc_id": "pydicom/fileutil.py::length_of_undefined_length", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "length_of_undefined_length", "text": "文件路径: pydicom/fileutil.py\ndef length_of_undefined_length(fp,\n                               delimiter,\n                               is_little_endian,\n                               read_size=128,\n                               rewind=True):\n    \"\"\"Search through the file to find the delimiter and return the length\n    of the data element.\n\n    Parameters\n    ----------\n    fp : file-like object\n    delimiter :\n        See ``find_delimiter`` for parameter info.\n    is_little_endian : boolean\n    read_size : int\n        See ``find_bytes`` for parameter info.\n    rewind : boolean\n        Flag to rewind to initial position after searching.\n\n    Returns\n    -------\n    length to delimiter\n\n    Notes\n    -----\n    Note the data element that the delimiter starts is not read here,\n    the calling routine must handle that. Delimiter must be 4 bytes long.\n    \"\"\"\n    data_start = fp.tell()\n    delimiter_pos = find_delimiter(\n        fp, delimiter, is_little_endian, rewind=rewind)\n    length = delimiter_pos - data_start\n    return length\n", "tokens": ["pydicom", "fileutil", "py", "def", "length_of_undefined_length", "fp", "delimiter", "is_little_endian", "read_size", "128", "rewind", "true", "search", "through", "the", "file", "to", "find", "the", "delimiter", "and", "return", "the", "length", "of", "the", "data", "element", "parameters", "fp", "file", "like", "object", "delimiter", "see", "find_delimiter", "for", "parameter", "info", "is_little_endian", "boolean", "read_size", "int", "see", "find_bytes", "for", "parameter", "info", "rewind", "boolean", "flag", "to", "rewind", "to", "initial", "position", "after", "searching", "returns", "length", "to", "delimiter", "notes", "note", "the", "data", "element", "that", "the", "delimiter", "starts", "is", "not", "read", "here", "the", "calling", "routine", "must", "handle", "that", "delimiter", "must", "be", "4", "bytes", "long", "data_start", "fp", "tell", "delimiter_pos", "find_delimiter", "fp", "delimiter", "is_little_endian", "rewind", "rewind", "length", "delimiter_pos", "data_start", "return", "length"], "doc_len": 102}
{"doc_id": "pydicom/fileutil.py::read_delimiter_item", "file_path": "pydicom/fileutil.py", "class_name": null, "func_name": "read_delimiter_item", "text": "文件路径: pydicom/fileutil.py\ndef read_delimiter_item(fp, delimiter):\n    \"\"\"Read and ignore an expected delimiter.\n\n    If the delimiter is not found or correctly formed, a warning is logged.\n    \"\"\"\n    found = fp.read(4)\n    if found != delimiter:\n        logger.warn(\"Expected delimitor %s, got %s at file position 0x%x\",\n                    Tag(delimiter), Tag(found), fp.tell() - 4)\n    length = fp.read_UL()\n    if length != 0:\n        logger.warn(\"Expected delimiter item to have length 0, \"\n                    \"got %d at file position 0x%x\", length, fp.tell() - 4)\n", "tokens": ["pydicom", "fileutil", "py", "def", "read_delimiter_item", "fp", "delimiter", "read", "and", "ignore", "an", "expected", "delimiter", "if", "the", "delimiter", "is", "not", "found", "or", "correctly", "formed", "a", "warning", "is", "logged", "found", "fp", "read", "4", "if", "found", "delimiter", "logger", "warn", "expected", "delimitor", "s", "got", "s", "at", "file", "position", "0x", "x", "tag", "delimiter", "tag", "found", "fp", "tell", "4", "length", "fp", "read_ul", "if", "length", "0", "logger", "warn", "expected", "delimiter", "item", "to", "have", "length", "0", "got", "d", "at", "file", "position", "0x", "x", "length", "fp", "tell", "4"], "doc_len": 78}
{"doc_id": "pydicom/filewriter.py::_correct_ambiguous_vr_element", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_correct_ambiguous_vr_element", "text": "文件路径: pydicom/filewriter.py\ndef _correct_ambiguous_vr_element(elem, ds, is_little_endian):\n    \"\"\"Implementation for `correct_ambiguous_vr_element`.\n    See `correct_ambiguous_vr_element` for description.\n    \"\"\"\n    # 'OB or OW': 7fe0,0010 PixelData\n    if elem.tag == 0x7fe00010:\n        # Compressed Pixel Data\n        # PS3.5 Annex A.4\n        #   If encapsulated, VR is OB and length is undefined\n        if elem.is_undefined_length:\n            elem.VR = 'OB'\n        # Non-compressed Pixel Data - Implicit Little Endian\n        # PS3.5 Annex A1: VR is always OW\n        elif ds.is_implicit_VR:\n            elem.VR = 'OW'\n        else:\n            # Non-compressed Pixel Data - Explicit VR\n            # PS3.5 Annex A.2:\n            # If BitsAllocated is > 8 then VR shall be OW,\n            # else may be OB or OW.\n            # If we get here, the data has not been written before\n            # or has been converted from Implicit Little Endian,\n            # so we default to OB for BitsAllocated 1 or 8\n            elem.VR = 'OW' if ds.BitsAllocated > 8 else 'OB'\n\n    # 'US or SS' and dependent on PixelRepresentation\n    # (0018,9810) Zero Velocity Pixel Value\n    # (0022,1452) Mapped Pixel Value\n    # (0028,0104)/(0028,0105) Smallest/Largest Valid Pixel Value\n    # (0028,0106)/(0028,0107) Smallest/Largest Image Pixel Value\n    # (0028,0108)/(0028,0109) Smallest/Largest Pixel Value in Series\n    # (0028,0110)/(0028,0111) Smallest/Largest Image Pixel Value in Plane\n    # (0028,0120) Pixel Padding Value\n    # (0028,0121) Pixel Padding Range Limit\n    # (0028,1101-1103) Red/Green/Blue Palette Color Lookup Table Descriptor\n    # (0028,3002) LUT Descriptor\n    # (0040,9216)/(0040,9211) Real World Value First/Last Value Mapped\n    # (0060,3004)/(0060,3006) Histogram First/Last Bin Value\n    elif elem.tag in [\n            0x00189810, 0x00221452, 0x00280104, 0x00280105, 0x00280106,\n            0x00280107, 0x00280108, 0x00280109, 0x00280110, 0x00280111,\n            0x00280120, 0x00280121, 0x00281101, 0x00281102, 0x00281103,\n            0x00283002, 0x00409211, 0x00409216, 0x00603004, 0x00603006\n    ]:\n        # US if PixelRepresentation value is 0x0000, else SS\n        #   For references, see the list at\n        #   https://github.com/darcymason/pydicom/pull/298\n        # PixelRepresentation is usually set in the root dataset\n        while 'PixelRepresentation' not in ds and ds.parent:\n            ds = ds.parent\n        # if no pixel data is present, none if these tags is used,\n        # so we can just ignore a missing PixelRepresentation in this case\n        if ('PixelRepresentation' not in ds and 'PixelData' not in ds or\n                ds.PixelRepresentation == 0):\n            elem.VR = 'US'\n            byte_type = 'H'\n        else:\n            elem.VR = 'SS'\n            byte_type = 'h'\n\n        # Need to handle type check for elements with VM > 1\n        elem_value = elem.value if elem.VM == 1 else elem.value[0]\n        if not isinstance(elem_value, int):\n            elem.value = convert_numbers(elem.value, is_little_endian,\n                                         byte_type)\n\n    # 'OB or OW' and dependent on WaveformBitsAllocated\n    # (5400, 0110) Channel Minimum Value\n    # (5400, 0112) Channel Maximum Value\n    # (5400, 100A) Waveform Padding Data\n    # (5400, 1010) Waveform Data\n    elif elem.tag in [0x54000110, 0x54000112, 0x5400100A, 0x54001010]:\n        # If WaveformBitsAllocated is > 8 then OW, otherwise may be\n        #   OB or OW.\n        #   See PS3.3 C.10.9.1.\n        if ds.is_implicit_VR:\n            elem.VR = 'OW'\n        else:\n            elem.VR = 'OW' if ds.WaveformBitsAllocated > 8 else 'OB'\n\n    # 'US or OW': 0028,3006 LUTData\n    elif elem.tag == 0x00283006:\n        # First value in LUT Descriptor is how many values in\n        #   LUTData, if there's only one value then must be US\n        # As per PS3.3 C.11.1.1.1\n        if ds.LUTDescriptor[0] == 1:\n            elem.VR = 'US'\n            elem_value = elem.value if elem.VM == 1 else elem.value[0]\n            if not isinstance(elem_value, int):\n                elem.value = convert_numbers(elem.value, is_little_endian,\n                                             'H')\n        else:\n            elem.VR = 'OW'\n\n    # 'OB or OW': 60xx,3000 OverlayData and dependent on Transfer Syntax\n    elif (elem.tag.group in range(0x6000, 0x601F, 2)\n          and elem.tag.elem == 0x3000):\n        # Implicit VR must be OW, explicit VR may be OB or OW\n        #   as per PS3.5 Section 8.1.2 and Annex A\n        elem.VR = 'OW'\n\n    return elem\n", "tokens": ["pydicom", "filewriter", "py", "def", "_correct_ambiguous_vr_element", "elem", "ds", "is_little_endian", "implementation", "for", "correct_ambiguous_vr_element", "see", "correct_ambiguous_vr_element", "for", "description", "ob", "or", "ow", "7fe0", "0010", "pixeldata", "if", "elem", "tag", "0x7fe00010", "compressed", "pixel", "data", "ps3", "5", "annex", "a", "4", "if", "encapsulated", "vr", "is", "ob", "and", "length", "is", "undefined", "if", "elem", "is_undefined_length", "elem", "vr", "ob", "non", "compressed", "pixel", "data", "implicit", "little", "endian", "ps3", "5", "annex", "a1", "vr", "is", "always", "ow", "elif", "ds", "is_implicit_vr", "elem", "vr", "ow", "else", "non", "compressed", "pixel", "data", "explicit", "vr", "ps3", "5", "annex", "a", "2", "if", "bitsallocated", "is", "8", "then", "vr", "shall", "be", "ow", "else", "may", "be", "ob", "or", "ow", "if", "we", "get", "here", "the", "data", "has", "not", "been", "written", "before", "or", "has", "been", "converted", "from", "implicit", "little", "endian", "so", "we", "default", "to", "ob", "for", "bitsallocated", "1", "or", "8", "elem", "vr", "ow", "if", "ds", "bitsallocated", "8", "else", "ob", "us", "or", "ss", "and", "dependent", "on", "pixelrepresentation", "0018", "9810", "zero", "velocity", "pixel", "value", "0022", "1452", "mapped", "pixel", "value", "0028", "0104", "0028", "0105", "smallest", "largest", "valid", "pixel", "value", "0028", "0106", "0028", "0107", "smallest", "largest", "image", "pixel", "value", "0028", "0108", "0028", "0109", "smallest", "largest", "pixel", "value", "in", "series", "0028", "0110", "0028", "0111", "smallest", "largest", "image", "pixel", "value", "in", "plane", "0028", "0120", "pixel", "padding", "value", "0028", "0121", "pixel", "padding", "range", "limit", "0028", "1101", "1103", "red", "green", "blue", "palette", "color", "lookup", "table", "descriptor", "0028", "3002", "lut", "descriptor", "0040", "9216", "0040", "9211", "real", "world", "value", "first", "last", "value", "mapped", "0060", "3004", "0060", "3006", "histogram", "first", "last", "bin", "value", "elif", "elem", "tag", "in", "0x00189810", "0x00221452", "0x00280104", "0x00280105", "0x00280106", "0x00280107", "0x00280108", "0x00280109", "0x00280110", "0x00280111", "0x00280120", "0x00280121", "0x00281101", "0x00281102", "0x00281103", "0x00283002", "0x00409211", "0x00409216", "0x00603004", "0x00603006", "us", "if", "pixelrepresentation", "value", "is", "0x0000", "else", "ss", "for", "references", "see", "the", "list", "at", "https", "github", "com", "darcymason", "pydicom", "pull", "298", "pixelrepresentation", "is", "usually", "set", "in", "the", "root", "dataset", "while", "pixelrepresentation", "not", "in", "ds", "and", "ds", "parent", "ds", "ds", "parent", "if", "no", "pixel", "data", "is", "present", "none", "if", "these", "tags", "is", "used", "so", "we", "can", "just", "ignore", "a", "missing", "pixelrepresentation", "in", "this", "case", "if", "pixelrepresentation", "not", "in", "ds", "and", "pixeldata", "not", "in", "ds", "or", "ds", "pixelrepresentation", "0", "elem", "vr", "us", "byte_type", "h", "else", "elem", "vr", "ss", "byte_type", "h", "need", "to", "handle", "type", "check", "for", "elements", "with", "vm", "1", "elem_value", "elem", "value", "if", "elem", "vm", "1", "else", "elem", "value", "0", "if", "not", "isinstance", "elem_value", "int", "elem", "value", "convert_numbers", "elem", "value", "is_little_endian", "byte_type", "ob", "or", "ow", "and", "dependent", "on", "waveformbitsallocated", "5400", "0110", "channel", "minimum", "value", "5400", "0112", "channel", "maximum", "value", "5400", "100a", "waveform", "padding", "data", "5400", "1010", "waveform", "data", "elif", "elem", "tag", "in", "0x54000110", "0x54000112", "0x5400100a", "0x54001010", "if", "waveformbitsallocated", "is", "8", "then", "ow", "otherwise", "may", "be", "ob", "or", "ow", "see", "ps3", "3", "c", "10", "9", "1", "if", "ds", "is_implicit_vr", "elem", "vr", "ow", "else", "elem", "vr", "ow", "if", "ds", "waveformbitsallocated", "8", "else", "ob", "us", "or", "ow", "0028", "3006", "lutdata", "elif", "elem", "tag", "0x00283006", "first", "value", "in", "lut", "descriptor", "is", "how", "many", "values", "in", "lutdata", "if", "there", "s", "only", "one", "value", "then", "must", "be", "us", "as", "per", "ps3", "3", "c", "11", "1", "1", "1", "if", "ds", "lutdescriptor", "0", "1", "elem", "vr", "us", "elem_value", "elem", "value", "if", "elem", "vm", "1", "else", "elem", "value", "0", "if", "not", "isinstance", "elem_value", "int", "elem", "value", "convert_numbers", "elem", "value", "is_little_endian", "h", "else", "elem", "vr", "ow", "ob", "or", "ow", "60xx", "3000", "overlaydata", "and", "dependent", "on", "transfer", "syntax", "elif", "elem", "tag", "group", "in", "range", "0x6000", "0x601f", "2", "and", "elem", "tag", "elem", "0x3000", "implicit", "vr", "must", "be", "ow", "explicit", "vr", "may", "be", "ob", "or", "ow", "as", "per", "ps3", "5", "section", "8", "1", "2", "and", "annex", "a", "elem", "vr", "ow", "return", "elem"], "doc_len": 579}
{"doc_id": "pydicom/filewriter.py::correct_ambiguous_vr_element", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "correct_ambiguous_vr_element", "text": "文件路径: pydicom/filewriter.py\ndef correct_ambiguous_vr_element(elem, ds, is_little_endian):\n    \"\"\"Attempt to correct the ambiguous VR element `elem`.\n\n    When it's not possible to correct the VR, the element will be returned\n    unchanged. Currently the only ambiguous VR elements not corrected for are\n    all retired or part of DICONDE.\n\n    If the VR is corrected and is 'US' or 'SS' then the value will be updated\n    using the pydicom.values.convert_numbers() method.\n\n    Parameters\n    ----------\n    elem : pydicom.dataelem.DataElement\n        The element with an ambiguous VR.\n    ds : pydicom.dataset.Dataset\n        The dataset containing `elem`.\n    is_little_endian : bool\n        The byte ordering of the values in the dataset.\n\n    Returns\n    -------\n    elem : pydicom.dataelem.DataElement\n        The corrected element\n    \"\"\"\n    if 'or' in elem.VR:\n        # convert raw data elements before handling them\n        if elem.is_raw:\n            elem = DataElement_from_raw(elem)\n            ds.__setitem__(elem.tag, elem)\n\n        try:\n            _correct_ambiguous_vr_element(elem, ds, is_little_endian)\n        except AttributeError as e:\n            reason = ('Failed to resolve ambiguous VR for tag'\n                      ' {}: '.format(elem.tag)) + str(e)\n            raise AttributeError(reason)\n\n    return elem\n", "tokens": ["pydicom", "filewriter", "py", "def", "correct_ambiguous_vr_element", "elem", "ds", "is_little_endian", "attempt", "to", "correct", "the", "ambiguous", "vr", "element", "elem", "when", "it", "s", "not", "possible", "to", "correct", "the", "vr", "the", "element", "will", "be", "returned", "unchanged", "currently", "the", "only", "ambiguous", "vr", "elements", "not", "corrected", "for", "are", "all", "retired", "or", "part", "of", "diconde", "if", "the", "vr", "is", "corrected", "and", "is", "us", "or", "ss", "then", "the", "value", "will", "be", "updated", "using", "the", "pydicom", "values", "convert_numbers", "method", "parameters", "elem", "pydicom", "dataelem", "dataelement", "the", "element", "with", "an", "ambiguous", "vr", "ds", "pydicom", "dataset", "dataset", "the", "dataset", "containing", "elem", "is_little_endian", "bool", "the", "byte", "ordering", "of", "the", "values", "in", "the", "dataset", "returns", "elem", "pydicom", "dataelem", "dataelement", "the", "corrected", "element", "if", "or", "in", "elem", "vr", "convert", "raw", "data", "elements", "before", "handling", "them", "if", "elem", "is_raw", "elem", "dataelement_from_raw", "elem", "ds", "__setitem__", "elem", "tag", "elem", "try", "_correct_ambiguous_vr_element", "elem", "ds", "is_little_endian", "except", "attributeerror", "as", "e", "reason", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "format", "elem", "tag", "str", "e", "raise", "attributeerror", "reason", "return", "elem"], "doc_len": 157}
{"doc_id": "pydicom/filewriter.py::correct_ambiguous_vr", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "correct_ambiguous_vr", "text": "文件路径: pydicom/filewriter.py\ndef correct_ambiguous_vr(ds, is_little_endian):\n    \"\"\"Iterate through `ds` correcting ambiguous VR elements (if possible).\n\n    When it's not possible to correct the VR, the element will be returned\n    unchanged. Currently the only ambiguous VR elements not corrected for are\n    all retired or part of DICONDE.\n\n    If the VR is corrected and is 'US' or 'SS' then the value will be updated\n    using the pydicom.values.convert_numbers() method.\n\n    Parameters\n    ----------\n    ds : pydicom.dataset.Dataset\n        The dataset containing ambiguous VR elements.\n    is_little_endian : bool\n        The byte ordering of the values in the dataset.\n\n    Returns\n    -------\n    ds : pydicom.dataset.Dataset\n        The corrected dataset\n\n    Raises\n    ------\n    AttributeError\n        If a tag is missing in `ds` that is required to resolve the ambiguity.\n    \"\"\"\n    # Iterate through the elements\n    for elem in ds:\n        # raw data element sequences can be written as they are, because we\n        # have ensured that the transfer syntax has not changed at this point\n        if elem.VR == 'SQ':\n            for item in elem:\n                correct_ambiguous_vr(item, is_little_endian)\n        elif 'or' in elem.VR:\n            correct_ambiguous_vr_element(elem, ds, is_little_endian)\n    return ds\n", "tokens": ["pydicom", "filewriter", "py", "def", "correct_ambiguous_vr", "ds", "is_little_endian", "iterate", "through", "ds", "correcting", "ambiguous", "vr", "elements", "if", "possible", "when", "it", "s", "not", "possible", "to", "correct", "the", "vr", "the", "element", "will", "be", "returned", "unchanged", "currently", "the", "only", "ambiguous", "vr", "elements", "not", "corrected", "for", "are", "all", "retired", "or", "part", "of", "diconde", "if", "the", "vr", "is", "corrected", "and", "is", "us", "or", "ss", "then", "the", "value", "will", "be", "updated", "using", "the", "pydicom", "values", "convert_numbers", "method", "parameters", "ds", "pydicom", "dataset", "dataset", "the", "dataset", "containing", "ambiguous", "vr", "elements", "is_little_endian", "bool", "the", "byte", "ordering", "of", "the", "values", "in", "the", "dataset", "returns", "ds", "pydicom", "dataset", "dataset", "the", "corrected", "dataset", "raises", "attributeerror", "if", "a", "tag", "is", "missing", "in", "ds", "that", "is", "required", "to", "resolve", "the", "ambiguity", "iterate", "through", "the", "elements", "for", "elem", "in", "ds", "raw", "data", "element", "sequences", "can", "be", "written", "as", "they", "are", "because", "we", "have", "ensured", "that", "the", "transfer", "syntax", "has", "not", "changed", "at", "this", "point", "if", "elem", "vr", "sq", "for", "item", "in", "elem", "correct_ambiguous_vr", "item", "is_little_endian", "elif", "or", "in", "elem", "vr", "correct_ambiguous_vr_element", "elem", "ds", "is_little_endian", "return", "ds"], "doc_len": 169}
{"doc_id": "pydicom/filewriter.py::write_numbers", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_numbers", "text": "文件路径: pydicom/filewriter.py\ndef write_numbers(fp, data_element, struct_format):\n    \"\"\"Write a \"value\" of type struct_format from the dicom file.\n\n    \"Value\" can be more than one number.\n\n    struct_format -- the character format as used by the struct module.\n\n    \"\"\"\n    endianChar = '><' [fp.is_little_endian]\n    value = data_element.value\n    if value == \"\":\n        return  # don't need to write anything for empty string\n\n    format_string = endianChar + struct_format\n    try:\n        try:\n            value.append  # works only if list, not if string or number\n        except AttributeError:  # is a single value - the usual case\n            fp.write(pack(format_string, value))\n        else:\n            for val in value:\n                fp.write(pack(format_string, val))\n    except Exception as e:\n        raise IOError(\n            \"{0}\\nfor data_element:\\n{1}\".format(str(e), str(data_element)))\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_numbers", "fp", "data_element", "struct_format", "write", "a", "value", "of", "type", "struct_format", "from", "the", "dicom", "file", "value", "can", "be", "more", "than", "one", "number", "struct_format", "the", "character", "format", "as", "used", "by", "the", "struct", "module", "endianchar", "fp", "is_little_endian", "value", "data_element", "value", "if", "value", "return", "don", "t", "need", "to", "write", "anything", "for", "empty", "string", "format_string", "endianchar", "struct_format", "try", "try", "value", "append", "works", "only", "if", "list", "not", "if", "string", "or", "number", "except", "attributeerror", "is", "a", "single", "value", "the", "usual", "case", "fp", "write", "pack", "format_string", "value", "else", "for", "val", "in", "value", "fp", "write", "pack", "format_string", "val", "except", "exception", "as", "e", "raise", "ioerror", "0", "nfor", "data_element", "n", "1", "format", "str", "e", "str", "data_element"], "doc_len": 109}
{"doc_id": "pydicom/filewriter.py::write_OBvalue", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_OBvalue", "text": "文件路径: pydicom/filewriter.py\ndef write_OBvalue(fp, data_element):\n    \"\"\"Write a data_element with VR of 'other byte' (OB).\"\"\"\n    fp.write(data_element.value)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_obvalue", "fp", "data_element", "write", "a", "data_element", "with", "vr", "of", "other", "byte", "ob", "fp", "write", "data_element", "value"], "doc_len": 20}
{"doc_id": "pydicom/filewriter.py::write_OWvalue", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_OWvalue", "text": "文件路径: pydicom/filewriter.py\ndef write_OWvalue(fp, data_element):\n    \"\"\"Write a data_element with VR of 'other word' (OW).\n\n    Note: This **does not currently do the byte swapping** for Endian state.\n    \"\"\"\n    # XXX for now just write the raw bytes without endian swapping\n    fp.write(data_element.value)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_owvalue", "fp", "data_element", "write", "a", "data_element", "with", "vr", "of", "other", "word", "ow", "note", "this", "does", "not", "currently", "do", "the", "byte", "swapping", "for", "endian", "state", "xxx", "for", "now", "just", "write", "the", "raw", "bytes", "without", "endian", "swapping", "fp", "write", "data_element", "value"], "doc_len": 43}
{"doc_id": "pydicom/filewriter.py::write_UI", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_UI", "text": "文件路径: pydicom/filewriter.py\ndef write_UI(fp, data_element):\n    \"\"\"Write a data_element with VR of 'unique identifier' (UI).\"\"\"\n    write_string(fp, data_element, '\\0')  # pad with 0-byte to even length\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_ui", "fp", "data_element", "write", "a", "data_element", "with", "vr", "of", "unique", "identifier", "ui", "write_string", "fp", "data_element", "0", "pad", "with", "0", "byte", "to", "even", "length"], "doc_len": 27}
{"doc_id": "pydicom/filewriter.py::_is_multi_value", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_is_multi_value", "text": "文件路径: pydicom/filewriter.py\ndef _is_multi_value(val):\n    \"\"\"Return True if `val` is a multi-value container.\"\"\"\n    return isinstance(val, (MultiValue, list, tuple))\n", "tokens": ["pydicom", "filewriter", "py", "def", "_is_multi_value", "val", "return", "true", "if", "val", "is", "a", "multi", "value", "container", "return", "isinstance", "val", "multivalue", "list", "tuple"], "doc_len": 21}
{"doc_id": "pydicom/filewriter.py::multi_string", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "multi_string", "text": "文件路径: pydicom/filewriter.py\ndef multi_string(val):\n    \"\"\"Put a string together with delimiter if has more than one value\"\"\"\n    if _is_multi_value(val):\n        return \"\\\\\".join(val)\n    else:\n        return val\n", "tokens": ["pydicom", "filewriter", "py", "def", "multi_string", "val", "put", "a", "string", "together", "with", "delimiter", "if", "has", "more", "than", "one", "value", "if", "_is_multi_value", "val", "return", "join", "val", "else", "return", "val"], "doc_len": 27}
{"doc_id": "pydicom/filewriter.py::write_PN", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_PN", "text": "文件路径: pydicom/filewriter.py\ndef write_PN(fp, data_element, encodings=None):\n    if not encodings:\n        encodings = [default_encoding]\n\n    if data_element.VM == 1:\n        val = [data_element.value, ]\n    else:\n        val = data_element.value\n\n    if isinstance(val[0], compat.text_type) or not in_py2:\n        try:\n            val = [elem.encode(encodings) for elem in val]\n        except TypeError:\n            # we get here in Python 2 if val is a unicode string\n            val = [PersonNameUnicode(elem, encodings) for elem in val]\n            val = [elem.encode(encodings) for elem in val]\n\n    val = b'\\\\'.join(val)\n\n    if len(val) % 2 != 0:\n        val = val + b' '\n\n    fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_pn", "fp", "data_element", "encodings", "none", "if", "not", "encodings", "encodings", "default_encoding", "if", "data_element", "vm", "1", "val", "data_element", "value", "else", "val", "data_element", "value", "if", "isinstance", "val", "0", "compat", "text_type", "or", "not", "in_py2", "try", "val", "elem", "encode", "encodings", "for", "elem", "in", "val", "except", "typeerror", "we", "get", "here", "in", "python", "2", "if", "val", "is", "a", "unicode", "string", "val", "personnameunicode", "elem", "encodings", "for", "elem", "in", "val", "val", "elem", "encode", "encodings", "for", "elem", "in", "val", "val", "b", "join", "val", "if", "len", "val", "2", "0", "val", "val", "b", "fp", "write", "val"], "doc_len": 88}
{"doc_id": "pydicom/filewriter.py::write_string", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_string", "text": "文件路径: pydicom/filewriter.py\ndef write_string(fp, data_element, padding=' '):\n    \"\"\"Write a single or multivalued ASCII string.\"\"\"\n    val = multi_string(data_element.value)\n    if val is not None:\n        if len(val) % 2 != 0:\n            val = val + padding  # pad to even length\n        if isinstance(val, compat.text_type):\n            val = val.encode(default_encoding)\n        fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_string", "fp", "data_element", "padding", "write", "a", "single", "or", "multivalued", "ascii", "string", "val", "multi_string", "data_element", "value", "if", "val", "is", "not", "none", "if", "len", "val", "2", "0", "val", "val", "padding", "pad", "to", "even", "length", "if", "isinstance", "val", "compat", "text_type", "val", "val", "encode", "default_encoding", "fp", "write", "val"], "doc_len": 48}
{"doc_id": "pydicom/filewriter.py::write_text", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_text", "text": "文件路径: pydicom/filewriter.py\ndef write_text(fp, data_element, encodings=None):\n    \"\"\"Write a single or multivalued text string.\"\"\"\n    val = data_element.value\n    if val is not None:\n        encodings = encodings or [default_encoding]\n        if _is_multi_value(val):\n            if val and isinstance(val[0], compat.text_type):\n                val = b'\\\\'.join([encode_string(val, encodings)\n                                  for val in val])\n            else:\n                val = b'\\\\'.join([val for val in val])\n        else:\n            if isinstance(val, compat.text_type):\n                val = encode_string(val, encodings)\n\n        if len(val) % 2 != 0:\n            val = val + b' '  # pad to even length\n        fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_text", "fp", "data_element", "encodings", "none", "write", "a", "single", "or", "multivalued", "text", "string", "val", "data_element", "value", "if", "val", "is", "not", "none", "encodings", "encodings", "or", "default_encoding", "if", "_is_multi_value", "val", "if", "val", "and", "isinstance", "val", "0", "compat", "text_type", "val", "b", "join", "encode_string", "val", "encodings", "for", "val", "in", "val", "else", "val", "b", "join", "val", "for", "val", "in", "val", "else", "if", "isinstance", "val", "compat", "text_type", "val", "encode_string", "val", "encodings", "if", "len", "val", "2", "0", "val", "val", "b", "pad", "to", "even", "length", "fp", "write", "val"], "doc_len": 83}
{"doc_id": "pydicom/filewriter.py::write_number_string", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_number_string", "text": "文件路径: pydicom/filewriter.py\ndef write_number_string(fp, data_element):\n    \"\"\"Handle IS or DS VR - write a number stored as a string of digits.\"\"\"\n    # If the DS or IS has an original_string attribute, use that, so that\n    # unchanged data elements are written with exact string as when read from\n    # file\n    val = data_element.value\n\n    if _is_multi_value(val):\n        val = \"\\\\\".join((x.original_string\n                         if hasattr(x, 'original_string') else str(x)\n                         for x in val))\n    else:\n        if hasattr(val, 'original_string'):\n            val = val.original_string\n        else:\n            val = str(val)\n\n    if len(val) % 2 != 0:\n        val = val + ' '  # pad to even length\n\n    if not in_py2:\n        val = bytes(val, default_encoding)\n\n    fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_number_string", "fp", "data_element", "handle", "is", "or", "ds", "vr", "write", "a", "number", "stored", "as", "a", "string", "of", "digits", "if", "the", "ds", "or", "is", "has", "an", "original_string", "attribute", "use", "that", "so", "that", "unchanged", "data", "elements", "are", "written", "with", "exact", "string", "as", "when", "read", "from", "file", "val", "data_element", "value", "if", "_is_multi_value", "val", "val", "join", "x", "original_string", "if", "hasattr", "x", "original_string", "else", "str", "x", "for", "x", "in", "val", "else", "if", "hasattr", "val", "original_string", "val", "val", "original_string", "else", "val", "str", "val", "if", "len", "val", "2", "0", "val", "val", "pad", "to", "even", "length", "if", "not", "in_py2", "val", "bytes", "val", "default_encoding", "fp", "write", "val"], "doc_len": 101}
{"doc_id": "pydicom/filewriter.py::_format_DA", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_format_DA", "text": "文件路径: pydicom/filewriter.py\ndef _format_DA(val):\n    if val is None:\n        return ''\n    elif hasattr(val, 'original_string'):\n        return val.original_string\n    else:\n        return val.strftime(\"%Y%m%d\")\n", "tokens": ["pydicom", "filewriter", "py", "def", "_format_da", "val", "if", "val", "is", "none", "return", "elif", "hasattr", "val", "original_string", "return", "val", "original_string", "else", "return", "val", "strftime", "y", "m", "d"], "doc_len": 25}
{"doc_id": "pydicom/filewriter.py::write_DA", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_DA", "text": "文件路径: pydicom/filewriter.py\ndef write_DA(fp, data_element):\n    val = data_element.value\n    if isinstance(val, (str, compat.string_types)):\n        write_string(fp, data_element)\n    else:\n        if _is_multi_value(val):\n            val = \"\\\\\".join((x if isinstance(x, (str, compat.string_types))\n                             else _format_DA(x) for x in val))\n        else:\n            val = _format_DA(val)\n        if len(val) % 2 != 0:\n            val = val + ' '  # pad to even length\n\n        if isinstance(val, compat.string_types):\n            val = val.encode(default_encoding)\n\n        fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_da", "fp", "data_element", "val", "data_element", "value", "if", "isinstance", "val", "str", "compat", "string_types", "write_string", "fp", "data_element", "else", "if", "_is_multi_value", "val", "val", "join", "x", "if", "isinstance", "x", "str", "compat", "string_types", "else", "_format_da", "x", "for", "x", "in", "val", "else", "val", "_format_da", "val", "if", "len", "val", "2", "0", "val", "val", "pad", "to", "even", "length", "if", "isinstance", "val", "compat", "string_types", "val", "val", "encode", "default_encoding", "fp", "write", "val"], "doc_len": 66}
{"doc_id": "pydicom/filewriter.py::_format_DT", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_format_DT", "text": "文件路径: pydicom/filewriter.py\ndef _format_DT(val):\n    if hasattr(val, 'original_string'):\n        return val.original_string\n    elif val.microsecond > 0:\n        return val.strftime(\"%Y%m%d%H%M%S.%f%z\")\n    else:\n        return val.strftime(\"%Y%m%d%H%M%S%z\")\n", "tokens": ["pydicom", "filewriter", "py", "def", "_format_dt", "val", "if", "hasattr", "val", "original_string", "return", "val", "original_string", "elif", "val", "microsecond", "0", "return", "val", "strftime", "y", "m", "d", "h", "m", "s", "f", "z", "else", "return", "val", "strftime", "y", "m", "d", "h", "m", "s", "z"], "doc_len": 39}
{"doc_id": "pydicom/filewriter.py::write_DT", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_DT", "text": "文件路径: pydicom/filewriter.py\ndef write_DT(fp, data_element):\n    val = data_element.value\n    if isinstance(val, (str, compat.string_types)):\n        write_string(fp, data_element)\n    else:\n        if _is_multi_value(val):\n            val = \"\\\\\".join((x if isinstance(x, (str, compat.string_types))\n                             else _format_DT(x) for x in val))\n        else:\n            val = _format_DT(val)\n        if len(val) % 2 != 0:\n            val = val + ' '  # pad to even length\n\n        if isinstance(val, compat.string_types):\n            val = val.encode(default_encoding)\n\n        fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_dt", "fp", "data_element", "val", "data_element", "value", "if", "isinstance", "val", "str", "compat", "string_types", "write_string", "fp", "data_element", "else", "if", "_is_multi_value", "val", "val", "join", "x", "if", "isinstance", "x", "str", "compat", "string_types", "else", "_format_dt", "x", "for", "x", "in", "val", "else", "val", "_format_dt", "val", "if", "len", "val", "2", "0", "val", "val", "pad", "to", "even", "length", "if", "isinstance", "val", "compat", "string_types", "val", "val", "encode", "default_encoding", "fp", "write", "val"], "doc_len": 66}
{"doc_id": "pydicom/filewriter.py::_format_TM", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_format_TM", "text": "文件路径: pydicom/filewriter.py\ndef _format_TM(val):\n    if val is None:\n        return ''\n    elif hasattr(val, 'original_string'):\n        return val.original_string\n    elif val.microsecond > 0:\n        return val.strftime(\"%H%M%S.%f\")\n    else:\n        return val.strftime(\"%H%M%S\")\n", "tokens": ["pydicom", "filewriter", "py", "def", "_format_tm", "val", "if", "val", "is", "none", "return", "elif", "hasattr", "val", "original_string", "return", "val", "original_string", "elif", "val", "microsecond", "0", "return", "val", "strftime", "h", "m", "s", "f", "else", "return", "val", "strftime", "h", "m", "s"], "doc_len": 36}
{"doc_id": "pydicom/filewriter.py::write_TM", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_TM", "text": "文件路径: pydicom/filewriter.py\ndef write_TM(fp, data_element):\n    val = data_element.value\n    if isinstance(val, (str, compat.string_types)):\n        write_string(fp, data_element)\n    else:\n        if _is_multi_value(val):\n            val = \"\\\\\".join((x if isinstance(x, (str, compat.string_types))\n                             else _format_TM(x) for x in val))\n        else:\n            val = _format_TM(val)\n        if len(val) % 2 != 0:\n            val = val + ' '  # pad to even length\n\n        if isinstance(val, compat.string_types):\n            val = val.encode(default_encoding)\n\n        fp.write(val)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_tm", "fp", "data_element", "val", "data_element", "value", "if", "isinstance", "val", "str", "compat", "string_types", "write_string", "fp", "data_element", "else", "if", "_is_multi_value", "val", "val", "join", "x", "if", "isinstance", "x", "str", "compat", "string_types", "else", "_format_tm", "x", "for", "x", "in", "val", "else", "val", "_format_tm", "val", "if", "len", "val", "2", "0", "val", "val", "pad", "to", "even", "length", "if", "isinstance", "val", "compat", "string_types", "val", "val", "encode", "default_encoding", "fp", "write", "val"], "doc_len": 66}
{"doc_id": "pydicom/filewriter.py::write_data_element", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_data_element", "text": "文件路径: pydicom/filewriter.py\ndef write_data_element(fp, data_element, encodings=None):\n    \"\"\"Write the data_element to file fp according to\n    dicom media storage rules.\n    \"\"\"\n    # Write element's tag\n    fp.write_tag(data_element.tag)\n\n    # If explicit VR, write the VR\n    VR = data_element.VR\n    if not fp.is_implicit_VR:\n        if len(VR) != 2:\n            msg = (\"Cannot write ambiguous VR of '{}' for data element with \"\n                   \"tag {}.\\nSet the correct VR before writing, or use an \"\n                   \"implicit VR transfer syntax\".format(\n                       VR, repr(data_element.tag)))\n            raise ValueError(msg)\n        if not in_py2:\n            fp.write(bytes(VR, default_encoding))\n        else:\n            fp.write(VR)\n        if VR in extra_length_VRs:\n            fp.write_US(0)  # reserved 2 bytes\n\n    # write into a buffer to avoid seeking back which can be expansive\n    buffer = DicomBytesIO()\n    buffer.is_little_endian = fp.is_little_endian\n    buffer.is_implicit_VR = fp.is_implicit_VR\n\n    if data_element.is_raw:\n        # raw data element values can be written as they are\n        buffer.write(data_element.value)\n        is_undefined_length = data_element.length == 0xFFFFFFFF\n    else:\n        if VR not in writers:\n            raise NotImplementedError(\n                \"write_data_element: unknown Value Representation \"\n                \"'{0}'\".format(VR))\n\n        encodings = encodings or [default_encoding]\n        encodings = convert_encodings(encodings)\n        writer_function, writer_param = writers[VR]\n        is_undefined_length = data_element.is_undefined_length\n        if VR in text_VRs or VR in ('PN', 'SQ'):\n            writer_function(buffer, data_element, encodings=encodings)\n        else:\n            # Many numeric types use the same writer but with numeric format\n            # parameter\n            if writer_param is not None:\n                writer_function(buffer, data_element, writer_param)\n            else:\n                writer_function(buffer, data_element)\n\n    # valid pixel data with undefined length shall contain encapsulated\n    # data, e.g. sequence items - raise ValueError otherwise (see #238)\n    if is_undefined_length and data_element.tag == 0x7fe00010:\n        val = data_element.value\n        if (fp.is_little_endian and not\n                val.startswith(b'\\xfe\\xff\\x00\\xe0') or\n                not fp.is_little_endian and\n                not val.startswith(b'\\xff\\xfe\\xe0\\x00')):\n            raise ValueError('Pixel Data with undefined length must '\n                             'start with an item tag')\n\n    value_length = buffer.tell()\n    if (not fp.is_implicit_VR and VR not in extra_length_VRs and\n            not is_undefined_length):\n        try:\n            fp.write_US(value_length)  # Explicit VR length field is 2 bytes\n        except struct.error:\n            msg = ('The value for the data element {} exceeds the size '\n                   'of 64 kByte and cannot be written in an explicit transfer '\n                   'syntax. You can save it using Implicit Little Endian '\n                   'transfer syntax, or you have to truncate the value to not '\n                   'exceed the maximum size of 64 kByte.'\n                   .format(data_element.tag))\n            raise ValueError(msg)\n    else:\n        # write the proper length of the data_element in the length slot,\n        # unless is SQ with undefined length.\n        fp.write_UL(0xFFFFFFFF if is_undefined_length else value_length)\n\n    fp.write(buffer.getvalue())\n    if is_undefined_length:\n        fp.write_tag(SequenceDelimiterTag)\n        fp.write_UL(0)  # 4-byte 'length' of delimiter data item\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_data_element", "fp", "data_element", "encodings", "none", "write", "the", "data_element", "to", "file", "fp", "according", "to", "dicom", "media", "storage", "rules", "write", "element", "s", "tag", "fp", "write_tag", "data_element", "tag", "if", "explicit", "vr", "write", "the", "vr", "vr", "data_element", "vr", "if", "not", "fp", "is_implicit_vr", "if", "len", "vr", "2", "msg", "cannot", "write", "ambiguous", "vr", "of", "for", "data", "element", "with", "tag", "nset", "the", "correct", "vr", "before", "writing", "or", "use", "an", "implicit", "vr", "transfer", "syntax", "format", "vr", "repr", "data_element", "tag", "raise", "valueerror", "msg", "if", "not", "in_py2", "fp", "write", "bytes", "vr", "default_encoding", "else", "fp", "write", "vr", "if", "vr", "in", "extra_length_vrs", "fp", "write_us", "0", "reserved", "2", "bytes", "write", "into", "a", "buffer", "to", "avoid", "seeking", "back", "which", "can", "be", "expansive", "buffer", "dicombytesio", "buffer", "is_little_endian", "fp", "is_little_endian", "buffer", "is_implicit_vr", "fp", "is_implicit_vr", "if", "data_element", "is_raw", "raw", "data", "element", "values", "can", "be", "written", "as", "they", "are", "buffer", "write", "data_element", "value", "is_undefined_length", "data_element", "length", "0xffffffff", "else", "if", "vr", "not", "in", "writers", "raise", "notimplementederror", "write_data_element", "unknown", "value", "representation", "0", "format", "vr", "encodings", "encodings", "or", "default_encoding", "encodings", "convert_encodings", "encodings", "writer_function", "writer_param", "writers", "vr", "is_undefined_length", "data_element", "is_undefined_length", "if", "vr", "in", "text_vrs", "or", "vr", "in", "pn", "sq", "writer_function", "buffer", "data_element", "encodings", "encodings", "else", "many", "numeric", "types", "use", "the", "same", "writer", "but", "with", "numeric", "format", "parameter", "if", "writer_param", "is", "not", "none", "writer_function", "buffer", "data_element", "writer_param", "else", "writer_function", "buffer", "data_element", "valid", "pixel", "data", "with", "undefined", "length", "shall", "contain", "encapsulated", "data", "e", "g", "sequence", "items", "raise", "valueerror", "otherwise", "see", "238", "if", "is_undefined_length", "and", "data_element", "tag", "0x7fe00010", "val", "data_element", "value", "if", "fp", "is_little_endian", "and", "not", "val", "startswith", "b", "xfe", "xff", "x00", "xe0", "or", "not", "fp", "is_little_endian", "and", "not", "val", "startswith", "b", "xff", "xfe", "xe0", "x00", "raise", "valueerror", "pixel", "data", "with", "undefined", "length", "must", "start", "with", "an", "item", "tag", "value_length", "buffer", "tell", "if", "not", "fp", "is_implicit_vr", "and", "vr", "not", "in", "extra_length_vrs", "and", "not", "is_undefined_length", "try", "fp", "write_us", "value_length", "explicit", "vr", "length", "field", "is", "2", "bytes", "except", "struct", "error", "msg", "the", "value", "for", "the", "data", "element", "exceeds", "the", "size", "of", "64", "kbyte", "and", "cannot", "be", "written", "in", "an", "explicit", "transfer", "syntax", "you", "can", "save", "it", "using", "implicit", "little", "endian", "transfer", "syntax", "or", "you", "have", "to", "truncate", "the", "value", "to", "not", "exceed", "the", "maximum", "size", "of", "64", "kbyte", "format", "data_element", "tag", "raise", "valueerror", "msg", "else", "write", "the", "proper", "length", "of", "the", "data_element", "in", "the", "length", "slot", "unless", "is", "sq", "with", "undefined", "length", "fp", "write_ul", "0xffffffff", "if", "is_undefined_length", "else", "value_length", "fp", "write", "buffer", "getvalue", "if", "is_undefined_length", "fp", "write_tag", "sequencedelimitertag", "fp", "write_ul", "0", "4", "byte", "length", "of", "delimiter", "data", "item"], "doc_len": 405}
{"doc_id": "pydicom/filewriter.py::write_dataset", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_dataset", "text": "文件路径: pydicom/filewriter.py\ndef write_dataset(fp, dataset, parent_encoding=default_encoding):\n    \"\"\"Write a Dataset dictionary to the file. Return the total length written.\n    \"\"\"\n    _harmonize_properties(dataset, fp)\n\n    if not dataset.is_original_encoding:\n        dataset = correct_ambiguous_vr(dataset, fp.is_little_endian)\n\n    dataset_encoding = dataset.get('SpecificCharacterSet', parent_encoding)\n\n    fpStart = fp.tell()\n    # data_elements must be written in tag order\n    tags = sorted(dataset.keys())\n\n    for tag in tags:\n        # do not write retired Group Length (see PS3.5, 7.2)\n        if tag.element == 0 and tag.group > 6:\n            continue\n        with tag_in_exception(tag):\n            write_data_element(fp, dataset.get_item(tag), dataset_encoding)\n\n    return fp.tell() - fpStart\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_dataset", "fp", "dataset", "parent_encoding", "default_encoding", "write", "a", "dataset", "dictionary", "to", "the", "file", "return", "the", "total", "length", "written", "_harmonize_properties", "dataset", "fp", "if", "not", "dataset", "is_original_encoding", "dataset", "correct_ambiguous_vr", "dataset", "fp", "is_little_endian", "dataset_encoding", "dataset", "get", "specificcharacterset", "parent_encoding", "fpstart", "fp", "tell", "data_elements", "must", "be", "written", "in", "tag", "order", "tags", "sorted", "dataset", "keys", "for", "tag", "in", "tags", "do", "not", "write", "retired", "group", "length", "see", "ps3", "5", "7", "2", "if", "tag", "element", "0", "and", "tag", "group", "6", "continue", "with", "tag_in_exception", "tag", "write_data_element", "fp", "dataset", "get_item", "tag", "dataset_encoding", "return", "fp", "tell", "fpstart"], "doc_len": 89}
{"doc_id": "pydicom/filewriter.py::_harmonize_properties", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "_harmonize_properties", "text": "文件路径: pydicom/filewriter.py\ndef _harmonize_properties(dataset, fp):\n    \"\"\"Make sure the properties in the dataset and the file pointer are\n    consistent, so the user can set both with the same effect.\n    Properties set on the destination file object always have preference.\n    \"\"\"\n    # ensure preference of fp over dataset\n    if hasattr(fp, 'is_little_endian'):\n        dataset.is_little_endian = fp.is_little_endian\n    if hasattr(fp, 'is_implicit_VR'):\n        dataset.is_implicit_VR = fp.is_implicit_VR\n\n    # write the properties back to have a consistent state\n    fp.is_implicit_VR = dataset.is_implicit_VR\n    fp.is_little_endian = dataset.is_little_endian\n", "tokens": ["pydicom", "filewriter", "py", "def", "_harmonize_properties", "dataset", "fp", "make", "sure", "the", "properties", "in", "the", "dataset", "and", "the", "file", "pointer", "are", "consistent", "so", "the", "user", "can", "set", "both", "with", "the", "same", "effect", "properties", "set", "on", "the", "destination", "file", "object", "always", "have", "preference", "ensure", "preference", "of", "fp", "over", "dataset", "if", "hasattr", "fp", "is_little_endian", "dataset", "is_little_endian", "fp", "is_little_endian", "if", "hasattr", "fp", "is_implicit_vr", "dataset", "is_implicit_vr", "fp", "is_implicit_vr", "write", "the", "properties", "back", "to", "have", "a", "consistent", "state", "fp", "is_implicit_vr", "dataset", "is_implicit_vr", "fp", "is_little_endian", "dataset", "is_little_endian"], "doc_len": 79}
{"doc_id": "pydicom/filewriter.py::write_sequence", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_sequence", "text": "文件路径: pydicom/filewriter.py\ndef write_sequence(fp, data_element, encodings):\n    \"\"\"Write a dicom Sequence contained in data_element to the file fp.\"\"\"\n    # write_data_element has already written the VR='SQ' (if needed) and\n    #    a placeholder for length\"\"\"\n    sequence = data_element.value\n    for dataset in sequence:\n        write_sequence_item(fp, dataset, encodings)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_sequence", "fp", "data_element", "encodings", "write", "a", "dicom", "sequence", "contained", "in", "data_element", "to", "the", "file", "fp", "write_data_element", "has", "already", "written", "the", "vr", "sq", "if", "needed", "and", "a", "placeholder", "for", "length", "sequence", "data_element", "value", "for", "dataset", "in", "sequence", "write_sequence_item", "fp", "dataset", "encodings"], "doc_len": 44}
{"doc_id": "pydicom/filewriter.py::write_sequence_item", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_sequence_item", "text": "文件路径: pydicom/filewriter.py\ndef write_sequence_item(fp, dataset, encodings):\n    \"\"\"Write an item (dataset) in a dicom Sequence to the dicom file fp.\n\n    This is similar to writing a data_element, but with a specific tag for\n    Sequence Item\n\n    see Dicom standard Part 5, p. 39 ('03 version)\n    \"\"\"\n    fp.write_tag(ItemTag)  # marker for start of Sequence Item\n    length_location = fp.tell()  # save location for later.\n    # will fill in real value later if not undefined length\n    fp.write_UL(0xffffffff)\n    write_dataset(fp, dataset, parent_encoding=encodings)\n    if getattr(dataset, \"is_undefined_length_sequence_item\", False):\n        fp.write_tag(ItemDelimiterTag)\n        fp.write_UL(0)  # 4-bytes 'length' field for delimiter item\n    else:  # we will be nice and set the lengths for the reader of this file\n        location = fp.tell()\n        fp.seek(length_location)\n        fp.write_UL(location - length_location - 4)  # 4 is length of UL\n        fp.seek(location)  # ready for next data_element\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_sequence_item", "fp", "dataset", "encodings", "write", "an", "item", "dataset", "in", "a", "dicom", "sequence", "to", "the", "dicom", "file", "fp", "this", "is", "similar", "to", "writing", "a", "data_element", "but", "with", "a", "specific", "tag", "for", "sequence", "item", "see", "dicom", "standard", "part", "5", "p", "39", "03", "version", "fp", "write_tag", "itemtag", "marker", "for", "start", "of", "sequence", "item", "length_location", "fp", "tell", "save", "location", "for", "later", "will", "fill", "in", "real", "value", "later", "if", "not", "undefined", "length", "fp", "write_ul", "0xffffffff", "write_dataset", "fp", "dataset", "parent_encoding", "encodings", "if", "getattr", "dataset", "is_undefined_length_sequence_item", "false", "fp", "write_tag", "itemdelimitertag", "fp", "write_ul", "0", "4", "bytes", "length", "field", "for", "delimiter", "item", "else", "we", "will", "be", "nice", "and", "set", "the", "lengths", "for", "the", "reader", "of", "this", "file", "location", "fp", "tell", "fp", "seek", "length_location", "fp", "write_ul", "location", "length_location", "4", "4", "is", "length", "of", "ul", "fp", "seek", "location", "ready", "for", "next", "data_element"], "doc_len": 135}
{"doc_id": "pydicom/filewriter.py::write_UN", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_UN", "text": "文件路径: pydicom/filewriter.py\ndef write_UN(fp, data_element):\n    \"\"\"Write a byte string for an DataElement of value 'UN' (unknown).\"\"\"\n    fp.write(data_element.value)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_un", "fp", "data_element", "write", "a", "byte", "string", "for", "an", "dataelement", "of", "value", "un", "unknown", "fp", "write", "data_element", "value"], "doc_len": 22}
{"doc_id": "pydicom/filewriter.py::write_ATvalue", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_ATvalue", "text": "文件路径: pydicom/filewriter.py\ndef write_ATvalue(fp, data_element):\n    \"\"\"Write a data_element tag to a file.\"\"\"\n    try:\n        iter(data_element.value)  # see if is multi-valued AT;\n        # Note will fail if Tag ever derived from true tuple rather than being\n        # a long\n    except TypeError:\n        # make sure is expressed as a Tag instance\n        tag = Tag(data_element.value)\n        fp.write_tag(tag)\n    else:\n        tags = [Tag(tag) for tag in data_element.value]\n        for tag in tags:\n            fp.write_tag(tag)\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_atvalue", "fp", "data_element", "write", "a", "data_element", "tag", "to", "a", "file", "try", "iter", "data_element", "value", "see", "if", "is", "multi", "valued", "at", "note", "will", "fail", "if", "tag", "ever", "derived", "from", "true", "tuple", "rather", "than", "being", "a", "long", "except", "typeerror", "make", "sure", "is", "expressed", "as", "a", "tag", "instance", "tag", "tag", "data_element", "value", "fp", "write_tag", "tag", "else", "tags", "tag", "tag", "for", "tag", "in", "data_element", "value", "for", "tag", "in", "tags", "fp", "write_tag", "tag"], "doc_len": 72}
{"doc_id": "pydicom/filewriter.py::write_file_meta_info", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "write_file_meta_info", "text": "文件路径: pydicom/filewriter.py\ndef write_file_meta_info(fp, file_meta, enforce_standard=True):\n    \"\"\"Write the File Meta Information elements in `file_meta` to `fp`.\n\n    If `enforce_standard` is True then the file-like `fp` should be positioned\n    past the 128 byte preamble + 4 byte prefix (which should already have been\n    written).\n\n    DICOM File Meta Information Group Elements\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    From the DICOM standard, Part 10 Section 7.1, any DICOM file shall contain\n    a 128-byte preamble, a 4-byte DICOM prefix 'DICM' and (at a minimum) the\n    following Type 1 DICOM Elements (from Table 7.1-1):\n        * (0002,0000) FileMetaInformationGroupLength, UL, 4\n        * (0002,0001) FileMetaInformationVersion, OB, 2\n        * (0002,0002) MediaStorageSOPClassUID, UI, N\n        * (0002,0003) MediaStorageSOPInstanceUID, UI, N\n        * (0002,0010) TransferSyntaxUID, UI, N\n        * (0002,0012) ImplementationClassUID, UI, N\n\n    If `enforce_standard` is True then (0002,0000) will be added/updated,\n    (0002,0001) and (0002,0012) will be added if not already present and the\n    other required elements will be checked to see if they exist. If\n    `enforce_standard` is False then `file_meta` will be written as is after\n    minimal validation checking.\n\n    The following Type 3/1C Elements may also be present:\n        * (0002,0013) ImplementationVersionName, SH, N\n        * (0002,0016) SourceApplicationEntityTitle, AE, N\n        * (0002,0017) SendingApplicationEntityTitle, AE, N\n        * (0002,0018) ReceivingApplicationEntityTitle, AE, N\n        * (0002,0100) PrivateInformationCreatorUID, UI, N\n        * (0002,0102) PrivateInformation, OB, N\n\n    If `enforce_standard` is True then (0002,0013) will be added/updated.\n\n    Encoding\n    ~~~~~~~~\n    The encoding of the File Meta Information shall be Explicit VR Little\n    Endian\n\n    Parameters\n    ----------\n    fp : file-like\n        The file-like to write the File Meta Information to.\n    file_meta : pydicom.dataset.Dataset\n        The File Meta Information DataElements.\n    enforce_standard : bool\n        If False, then only the File Meta Information elements already in\n        `file_meta` will be written to `fp`. If True (default) then a DICOM\n        Standards conformant File Meta will be written to `fp`.\n\n    Raises\n    ------\n    ValueError\n        If `enforce_standard` is True and any of the required File Meta\n        Information elements are missing from `file_meta`, with the\n        exception of (0002,0000), (0002,0001) and (0002,0012).\n    ValueError\n        If any non-Group 2 Elements are present in `file_meta`.\n    \"\"\"\n    validate_file_meta(file_meta, enforce_standard)\n\n    if enforce_standard and 'FileMetaInformationGroupLength' not in file_meta:\n        # Will be updated with the actual length later\n        file_meta.FileMetaInformationGroupLength = 0\n\n    # Write the File Meta Information Group elements\n    # first write into a buffer to avoid seeking back, that can be\n    # expansive and is not allowed if writing into a zip file\n    buffer = DicomBytesIO()\n    buffer.is_little_endian = True\n    buffer.is_implicit_VR = False\n    write_dataset(buffer, file_meta)\n\n    # If FileMetaInformationGroupLength is present it will be the first written\n    #   element and we must update its value to the correct length.\n    if 'FileMetaInformationGroupLength' in file_meta:\n        # Update the FileMetaInformationGroupLength value, which is the number\n        #   of bytes from the end of the FileMetaInformationGroupLength element\n        #   to the end of all the File Meta Information elements.\n        # FileMetaInformationGroupLength has a VR of 'UL' and so has a value\n        #   that is 4 bytes fixed. The total length of when encoded as\n        #   Explicit VR must therefore be 12 bytes.\n        file_meta.FileMetaInformationGroupLength = buffer.tell() - 12\n        buffer.seek(0)\n        write_data_element(buffer, file_meta[0x00020000])\n\n    fp.write(buffer.getvalue())\n", "tokens": ["pydicom", "filewriter", "py", "def", "write_file_meta_info", "fp", "file_meta", "enforce_standard", "true", "write", "the", "file", "meta", "information", "elements", "in", "file_meta", "to", "fp", "if", "enforce_standard", "is", "true", "then", "the", "file", "like", "fp", "should", "be", "positioned", "past", "the", "128", "byte", "preamble", "4", "byte", "prefix", "which", "should", "already", "have", "been", "written", "dicom", "file", "meta", "information", "group", "elements", "from", "the", "dicom", "standard", "part", "10", "section", "7", "1", "any", "dicom", "file", "shall", "contain", "a", "128", "byte", "preamble", "a", "4", "byte", "dicom", "prefix", "dicm", "and", "at", "a", "minimum", "the", "following", "type", "1", "dicom", "elements", "from", "table", "7", "1", "1", "0002", "0000", "filemetainformationgrouplength", "ul", "4", "0002", "0001", "filemetainformationversion", "ob", "2", "0002", "0002", "mediastoragesopclassuid", "ui", "n", "0002", "0003", "mediastoragesopinstanceuid", "ui", "n", "0002", "0010", "transfersyntaxuid", "ui", "n", "0002", "0012", "implementationclassuid", "ui", "n", "if", "enforce_standard", "is", "true", "then", "0002", "0000", "will", "be", "added", "updated", "0002", "0001", "and", "0002", "0012", "will", "be", "added", "if", "not", "already", "present", "and", "the", "other", "required", "elements", "will", "be", "checked", "to", "see", "if", "they", "exist", "if", "enforce_standard", "is", "false", "then", "file_meta", "will", "be", "written", "as", "is", "after", "minimal", "validation", "checking", "the", "following", "type", "3", "1c", "elements", "may", "also", "be", "present", "0002", "0013", "implementationversionname", "sh", "n", "0002", "0016", "sourceapplicationentitytitle", "ae", "n", "0002", "0017", "sendingapplicationentitytitle", "ae", "n", "0002", "0018", "receivingapplicationentitytitle", "ae", "n", "0002", "0100", "privateinformationcreatoruid", "ui", "n", "0002", "0102", "privateinformation", "ob", "n", "if", "enforce_standard", "is", "true", "then", "0002", "0013", "will", "be", "added", "updated", "encoding", "the", "encoding", "of", "the", "file", "meta", "information", "shall", "be", "explicit", "vr", "little", "endian", "parameters", "fp", "file", "like", "the", "file", "like", "to", "write", "the", "file", "meta", "information", "to", "file_meta", "pydicom", "dataset", "dataset", "the", "file", "meta", "information", "dataelements", "enforce_standard", "bool", "if", "false", "then", "only", "the", "file", "meta", "information", "elements", "already", "in", "file_meta", "will", "be", "written", "to", "fp", "if", "true", "default", "then", "a", "dicom", "standards", "conformant", "file", "meta", "will", "be", "written", "to", "fp", "raises", "valueerror", "if", "enforce_standard", "is", "true", "and", "any", "of", "the", "required", "file", "meta", "information", "elements", "are", "missing", "from", "file_meta", "with", "the", "exception", "of", "0002", "0000", "0002", "0001", "and", "0002", "0012", "valueerror", "if", "any", "non", "group", "2", "elements", "are", "present", "in", "file_meta", "validate_file_meta", "file_meta", "enforce_standard", "if", "enforce_standard", "and", "filemetainformationgrouplength", "not", "in", "file_meta", "will", "be", "updated", "with", "the", "actual", "length", "later", "file_meta", "filemetainformationgrouplength", "0", "write", "the", "file", "meta", "information", "group", "elements", "first", "write", "into", "a", "buffer", "to", "avoid", "seeking", "back", "that", "can", "be", "expansive", "and", "is", "not", "allowed", "if", "writing", "into", "a", "zip", "file", "buffer", "dicombytesio", "buffer", "is_little_endian", "true", "buffer", "is_implicit_vr", "false", "write_dataset", "buffer", "file_meta", "if", "filemetainformationgrouplength", "is", "present", "it", "will", "be", "the", "first", "written", "element", "and", "we", "must", "update", "its", "value", "to", "the", "correct", "length", "if", "filemetainformationgrouplength", "in", "file_meta", "update", "the", "filemetainformationgrouplength", "value", "which", "is", "the", "number", "of", "bytes", "from", "the", "end", "of", "the", "filemetainformationgrouplength", "element", "to", "the", "end", "of", "all", "the", "file", "meta", "information", "elements", "filemetainformationgrouplength", "has", "a", "vr", "of", "ul", "and", "so", "has", "a", "value", "that", "is", "4", "bytes", "fixed", "the", "total", "length", "of", "when", "encoded", "as", "explicit", "vr", "must", "therefore", "be", "12", "bytes", "file_meta", "filemetainformationgrouplength", "buffer", "tell", "12", "buffer", "seek", "0", "write_data_element", "buffer", "file_meta", "0x00020000", "fp", "write", "buffer", "getvalue"], "doc_len": 494}
{"doc_id": "pydicom/filewriter.py::dcmwrite", "file_path": "pydicom/filewriter.py", "class_name": null, "func_name": "dcmwrite", "text": "文件路径: pydicom/filewriter.py\ndef dcmwrite(filename, dataset, write_like_original=True):\n    \"\"\"Write `dataset` to the `filename` specified.\n\n    If `write_like_original` is True then `dataset` will be written as is\n    (after minimal validation checking) and may or may not contain all or parts\n    of the File Meta Information (and hence may or may not be conformant with\n    the DICOM File Format).\n    If `write_like_original` is False, `dataset` will be stored in the DICOM\n    File Format in accordance with DICOM Standard Part 10 Section 7. The byte\n    stream of the `dataset` will be placed into the file after the DICOM File\n    Meta Information.\n\n    File Meta Information\n    ---------------------\n    The File Meta Information consists of a 128-byte preamble, followed by a 4\n    byte DICOM prefix, followed by the File Meta Information Group elements.\n\n    Preamble and Prefix\n    ~~~~~~~~~~~~~~~~~~~\n    The `dataset.preamble` attribute shall be 128-bytes long or None and is\n    available for use as defined by the Application Profile or specific\n    implementations. If the preamble is not used by an Application Profile or\n    specific implementation then all 128 bytes should be set to 0x00. The\n    actual preamble written depends on `write_like_original` and\n    `dataset.preamble` (see the table below).\n\n    +------------------+------------------------------+\n    |                  | write_like_original          |\n    +------------------+-------------+----------------+\n    | dataset.preamble | True        | False          |\n    +==================+=============+================+\n    | None             | no preamble | 128 0x00 bytes |\n    +------------------+------------------------------+\n    | 128 bytes        | dataset.preamble             |\n    +------------------+------------------------------+\n\n    The prefix shall be the string 'DICM' and will be written if and only if\n    the preamble is present.\n\n    File Meta Information Group Elements\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    The preamble and prefix are followed by a set of DICOM Elements from the\n    (0002,eeee) group. Some of these elements are required (Type 1) while\n    others are optional (Type 3/1C). If `write_like_original` is True then the\n    File Meta Information Group elements are all optional. See\n    pydicom.filewriter.write_file_meta_info for more information on which\n    elements are required.\n\n    The File Meta Information Group elements should be included within their\n    own Dataset in the `dataset.file_meta` attribute.\n\n    If (0002,0010) 'Transfer Syntax UID' is included then the user must ensure\n    it's value is compatible with the values for the `dataset.is_little_endian`\n    and `dataset.is_implicit_VR` attributes. For example, if is_little_endian\n    and is_implicit_VR are both True then the Transfer Syntax UID must be\n    1.2.840.10008.1.2 'Implicit VR Little Endian'. See the DICOM standard\n    Part 5 Section 10 for more information on Transfer Syntaxes.\n\n    Encoding\n    ~~~~~~~~\n    The preamble and prefix are encoding independent. The File Meta Elements\n    are encoded as Explicit VR Little Endian as required by the DICOM standard.\n\n    Dataset\n    -------\n    A DICOM Dataset representing a SOP Instance related to a DICOM Information\n    Object Definition. It is up to the user to ensure the `dataset` conforms\n    to the DICOM standard.\n\n    Encoding\n    ~~~~~~~~\n    The `dataset` is encoded as specified by the `dataset.is_little_endian`\n    and `dataset.is_implicit_VR` attributes. It's up to the user to ensure\n    these attributes are set correctly (as well as setting an appropriate value\n    for `dataset.file_meta.TransferSyntaxUID` if present).\n\n    Parameters\n    ----------\n    filename : str or file-like\n        Name of file or the file-like to write the new DICOM file to.\n    dataset : pydicom.dataset.FileDataset\n        Dataset holding the DICOM information; e.g. an object read with\n        pydicom.dcmread().\n    write_like_original : bool\n        If True (default), preserves the following information from\n        the Dataset (and may result in a non-conformant file):\n        - preamble -- if the original file has no preamble then none will be\n            written.\n        - file_meta -- if the original file was missing any required File Meta\n            Information Group elements then they will not be added or written.\n            If (0002,0000) 'File Meta Information Group Length' is present then\n            it may have its value updated.\n        - seq.is_undefined_length -- if original had delimiters, write them now\n            too, instead of the more sensible length characters\n        - is_undefined_length_sequence_item -- for datasets that belong to a\n            sequence, write the undefined length delimiters if that is\n            what the original had.\n        If False, produces a file conformant with the DICOM File Format, with\n        explicit lengths for all elements.\n\n    See Also\n    --------\n    pydicom.dataset.FileDataset\n        Dataset class with relevant attributes and information.\n    pydicom.dataset.Dataset.save_as\n        Write a DICOM file from a dataset that was read in with dcmread().\n        save_as wraps dcmwrite.\n    \"\"\"\n    # Check that dataset's group 0x0002 elements are only present in the\n    #   `dataset.file_meta` Dataset - user may have added them to the wrong\n    #   place\n    if dataset.group_dataset(0x0002) != Dataset():\n        raise ValueError(\"File Meta Information Group Elements (0002,eeee) \"\n                         \"should be in their own Dataset object in the \"\n                         \"'{0}.file_meta' \"\n                         \"attribute.\".format(dataset.__class__.__name__))\n\n    # A preamble is required under the DICOM standard, however if\n    #   `write_like_original` is True we treat it as optional\n    preamble = getattr(dataset, 'preamble', None)\n    if preamble and len(preamble) != 128:\n        raise ValueError(\"'{0}.preamble' must be 128-bytes \"\n                         \"long.\".format(dataset.__class__.__name__))\n    if not preamble and not write_like_original:\n        # The default preamble is 128 0x00 bytes.\n        preamble = b'\\x00' * 128\n\n    # File Meta Information is required under the DICOM standard, however if\n    #   `write_like_original` is True we treat it as optional\n    if not write_like_original:\n        # the checks will be done in write_file_meta_info()\n        dataset.fix_meta_info(enforce_standard=False)\n    else:\n        dataset.ensure_file_meta()\n\n    # Check for decompression, give warnings if inconsistencies\n    # If decompressed, then pixel_array is now used instead of PixelData\n    if dataset.is_decompressed:\n        xfer = dataset.file_meta.TransferSyntaxUID\n        if xfer not in UncompressedPixelTransferSyntaxes:\n            raise ValueError(\"file_meta transfer SyntaxUID is compressed type \"\n                             \"but pixel data has been decompressed\")\n\n        # Force PixelData to the decompressed version\n        dataset.PixelData = dataset.pixel_array.tobytes()\n\n    caller_owns_file = True\n    # Open file if not already a file object\n    if isinstance(filename, compat.string_types):\n        fp = DicomFile(filename, 'wb')\n        # caller provided a file name; we own the file handle\n        caller_owns_file = False\n    else:\n        fp = DicomFileLike(filename)\n\n    # if we want to write with the same endianess and VR handling as\n    # the read dataset we want to preserve raw data elements for\n    # performance reasons (which is done by get_item);\n    # otherwise we use the default converting item getter\n    if dataset.is_original_encoding:\n        get_item = Dataset.get_item\n    else:\n        get_item = Dataset.__getitem__\n\n    try:\n        # WRITE FILE META INFORMATION\n        if preamble:\n            # Write the 'DICM' prefix if and only if we write the preamble\n            fp.write(preamble)\n            fp.write(b'DICM')\n\n        if dataset.file_meta:  # May be an empty Dataset\n            # If we want to `write_like_original`, don't enforce_standard\n            write_file_meta_info(fp, dataset.file_meta,\n                                 enforce_standard=not write_like_original)\n\n        # WRITE DATASET\n        # The transfer syntax used to encode the dataset can't be changed\n        #   within the dataset.\n        # Write any Command Set elements now as elements must be in tag order\n        #   Mixing Command Set with other elements is non-conformant so we\n        #   require `write_like_original` to be True\n        command_set = get_item(dataset, slice(0x00000000, 0x00010000))\n        if command_set and write_like_original:\n            fp.is_implicit_VR = True\n            fp.is_little_endian = True\n            write_dataset(fp, command_set)\n\n        # Set file VR and endianness. MUST BE AFTER writing META INFO (which\n        #   requires Explicit VR Little Endian) and COMMAND SET (which requires\n        #   Implicit VR Little Endian)\n        fp.is_implicit_VR = dataset.is_implicit_VR\n        fp.is_little_endian = dataset.is_little_endian\n\n        # Write non-Command Set elements now\n        write_dataset(fp, get_item(dataset, slice(0x00010000, None)))\n    finally:\n        if not caller_owns_file:\n            fp.close()\n", "tokens": ["pydicom", "filewriter", "py", "def", "dcmwrite", "filename", "dataset", "write_like_original", "true", "write", "dataset", "to", "the", "filename", "specified", "if", "write_like_original", "is", "true", "then", "dataset", "will", "be", "written", "as", "is", "after", "minimal", "validation", "checking", "and", "may", "or", "may", "not", "contain", "all", "or", "parts", "of", "the", "file", "meta", "information", "and", "hence", "may", "or", "may", "not", "be", "conformant", "with", "the", "dicom", "file", "format", "if", "write_like_original", "is", "false", "dataset", "will", "be", "stored", "in", "the", "dicom", "file", "format", "in", "accordance", "with", "dicom", "standard", "part", "10", "section", "7", "the", "byte", "stream", "of", "the", "dataset", "will", "be", "placed", "into", "the", "file", "after", "the", "dicom", "file", "meta", "information", "file", "meta", "information", "the", "file", "meta", "information", "consists", "of", "a", "128", "byte", "preamble", "followed", "by", "a", "4", "byte", "dicom", "prefix", "followed", "by", "the", "file", "meta", "information", "group", "elements", "preamble", "and", "prefix", "the", "dataset", "preamble", "attribute", "shall", "be", "128", "bytes", "long", "or", "none", "and", "is", "available", "for", "use", "as", "defined", "by", "the", "application", "profile", "or", "specific", "implementations", "if", "the", "preamble", "is", "not", "used", "by", "an", "application", "profile", "or", "specific", "implementation", "then", "all", "128", "bytes", "should", "be", "set", "to", "0x00", "the", "actual", "preamble", "written", "depends", "on", "write_like_original", "and", "dataset", "preamble", "see", "the", "table", "below", "write_like_original", "dataset", "preamble", "true", "false", "none", "no", "preamble", "128", "0x00", "bytes", "128", "bytes", "dataset", "preamble", "the", "prefix", "shall", "be", "the", "string", "dicm", "and", "will", "be", "written", "if", "and", "only", "if", "the", "preamble", "is", "present", "file", "meta", "information", "group", "elements", "the", "preamble", "and", "prefix", "are", "followed", "by", "a", "set", "of", "dicom", "elements", "from", "the", "0002", "eeee", "group", "some", "of", "these", "elements", "are", "required", "type", "1", "while", "others", "are", "optional", "type", "3", "1c", "if", "write_like_original", "is", "true", "then", "the", "file", "meta", "information", "group", "elements", "are", "all", "optional", "see", "pydicom", "filewriter", "write_file_meta_info", "for", "more", "information", "on", "which", "elements", "are", "required", "the", "file", "meta", "information", "group", "elements", "should", "be", "included", "within", "their", "own", "dataset", "in", "the", "dataset", "file_meta", "attribute", "if", "0002", "0010", "transfer", "syntax", "uid", "is", "included", "then", "the", "user", "must", "ensure", "it", "s", "value", "is", "compatible", "with", "the", "values", "for", "the", "dataset", "is_little_endian", "and", "dataset", "is_implicit_vr", "attributes", "for", "example", "if", "is_little_endian", "and", "is_implicit_vr", "are", "both", "true", "then", "the", "transfer", "syntax", "uid", "must", "be", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "see", "the", "dicom", "standard", "part", "5", "section", "10", "for", "more", "information", "on", "transfer", "syntaxes", "encoding", "the", "preamble", "and", "prefix", "are", "encoding", "independent", "the", "file", "meta", "elements", "are", "encoded", "as", "explicit", "vr", "little", "endian", "as", "required", "by", "the", "dicom", "standard", "dataset", "a", "dicom", "dataset", "representing", "a", "sop", "instance", "related", "to", "a", "dicom", "information", "object", "definition", "it", "is", "up", "to", "the", "user", "to", "ensure", "the", "dataset", "conforms", "to", "the", "dicom", "standard", "encoding", "the", "dataset", "is", "encoded", "as", "specified", "by", "the", "dataset", "is_little_endian", "and", "dataset", "is_implicit_vr", "attributes", "it", "s", "up", "to", "the", "user", "to", "ensure", "these", "attributes", "are", "set", "correctly", "as", "well", "as", "setting", "an", "appropriate", "value", "for", "dataset", "file_meta", "transfersyntaxuid", "if", "present", "parameters", "filename", "str", "or", "file", "like", "name", "of", "file", "or", "the", "file", "like", "to", "write", "the", "new", "dicom", "file", "to", "dataset", "pydicom", "dataset", "filedataset", "dataset", "holding", "the", "dicom", "information", "e", "g", "an", "object", "read", "with", "pydicom", "dcmread", "write_like_original", "bool", "if", "true", "default", "preserves", "the", "following", "information", "from", "the", "dataset", "and", "may", "result", "in", "a", "non", "conformant", "file", "preamble", "if", "the", "original", "file", "has", "no", "preamble", "then", "none", "will", "be", "written", "file_meta", "if", "the", "original", "file", "was", "missing", "any", "required", "file", "meta", "information", "group", "elements", "then", "they", "will", "not", "be", "added", "or", "written", "if", "0002", "0000", "file", "meta", "information", "group", "length", "is", "present", "then", "it", "may", "have", "its", "value", "updated", "seq", "is_undefined_length", "if", "original", "had", "delimiters", "write", "them", "now", "too", "instead", "of", "the", "more", "sensible", "length", "characters", "is_undefined_length_sequence_item", "for", "datasets", "that", "belong", "to", "a", "sequence", "write", "the", "undefined", "length", "delimiters", "if", "that", "is", "what", "the", "original", "had", "if", "false", "produces", "a", "file", "conformant", "with", "the", "dicom", "file", "format", "with", "explicit", "lengths", "for", "all", "elements", "see", "also", "pydicom", "dataset", "filedataset", "dataset", "class", "with", "relevant", "attributes", "and", "information", "pydicom", "dataset", "dataset", "save_as", "write", "a", "dicom", "file", "from", "a", "dataset", "that", "was", "read", "in", "with", "dcmread", "save_as", "wraps", "dcmwrite", "check", "that", "dataset", "s", "group", "0x0002", "elements", "are", "only", "present", "in", "the", "dataset", "file_meta", "dataset", "user", "may", "have", "added", "them", "to", "the", "wrong", "place", "if", "dataset", "group_dataset", "0x0002", "dataset", "raise", "valueerror", "file", "meta", "information", "group", "elements", "0002", "eeee", "should", "be", "in", "their", "own", "dataset", "object", "in", "the", "0", "file_meta", "attribute", "format", "dataset", "__class__", "__name__", "a", "preamble", "is", "required", "under", "the", "dicom", "standard", "however", "if", "write_like_original", "is", "true", "we", "treat", "it", "as", "optional", "preamble", "getattr", "dataset", "preamble", "none", "if", "preamble", "and", "len", "preamble", "128", "raise", "valueerror", "0", "preamble", "must", "be", "128", "bytes", "long", "format", "dataset", "__class__", "__name__", "if", "not", "preamble", "and", "not", "write_like_original", "the", "default", "preamble", "is", "128", "0x00", "bytes", "preamble", "b", "x00", "128", "file", "meta", "information", "is", "required", "under", "the", "dicom", "standard", "however", "if", "write_like_original", "is", "true", "we", "treat", "it", "as", "optional", "if", "not", "write_like_original", "the", "checks", "will", "be", "done", "in", "write_file_meta_info", "dataset", "fix_meta_info", "enforce_standard", "false", "else", "dataset", "ensure_file_meta", "check", "for", "decompression", "give", "warnings", "if", "inconsistencies", "if", "decompressed", "then", "pixel_array", "is", "now", "used", "instead", "of", "pixeldata", "if", "dataset", "is_decompressed", "xfer", "dataset", "file_meta", "transfersyntaxuid", "if", "xfer", "not", "in", "uncompressedpixeltransfersyntaxes", "raise", "valueerror", "file_meta", "transfer", "syntaxuid", "is", "compressed", "type", "but", "pixel", "data", "has", "been", "decompressed", "force", "pixeldata", "to", "the", "decompressed", "version", "dataset", "pixeldata", "dataset", "pixel_array", "tobytes", "caller_owns_file", "true", "open", "file", "if", "not", "already", "a", "file", "object", "if", "isinstance", "filename", "compat", "string_types", "fp", "dicomfile", "filename", "wb", "caller", "provided", "a", "file", "name", "we", "own", "the", "file", "handle", "caller_owns_file", "false", "else", "fp", "dicomfilelike", "filename", "if", "we", "want", "to", "write", "with", "the", "same", "endianess", "and", "vr", "handling", "as", "the", "read", "dataset", "we", "want", "to", "preserve", "raw", "data", "elements", "for", "performance", "reasons", "which", "is", "done", "by", "get_item", "otherwise", "we", "use", "the", "default", "converting", "item", "getter", "if", "dataset", "is_original_encoding", "get_item", "dataset", "get_item", "else", "get_item", "dataset", "__getitem__", "try", "write", "file", "meta", "information", "if", "preamble", "write", "the", "dicm", "prefix", "if", "and", "only", "if", "we", "write", "the", "preamble", "fp", "write", "preamble", "fp", "write", "b", "dicm", "if", "dataset", "file_meta", "may", "be", "an", "empty", "dataset", "if", "we", "want", "to", "write_like_original", "don", "t", "enforce_standard", "write_file_meta_info", "fp", "dataset", "file_meta", "enforce_standard", "not", "write_like_original", "write", "dataset", "the", "transfer", "syntax", "used", "to", "encode", "the", "dataset", "can", "t", "be", "changed", "within", "the", "dataset", "write", "any", "command", "set", "elements", "now", "as", "elements", "must", "be", "in", "tag", "order", "mixing", "command", "set", "with", "other", "elements", "is", "non", "conformant", "so", "we", "require", "write_like_original", "to", "be", "true", "command_set", "get_item", "dataset", "slice", "0x00000000", "0x00010000", "if", "command_set", "and", "write_like_original", "fp", "is_implicit_vr", "true", "fp", "is_little_endian", "true", "write_dataset", "fp", "command_set", "set", "file", "vr", "and", "endianness", "must", "be", "after", "writing", "meta", "info", "which", "requires", "explicit", "vr", "little", "endian", "and", "command", "set", "which", "requires", "implicit", "vr", "little", "endian", "fp", "is_implicit_vr", "dataset", "is_implicit_vr", "fp", "is_little_endian", "dataset", "is_little_endian", "write", "non", "command", "set", "elements", "now", "write_dataset", "fp", "get_item", "dataset", "slice", "0x00010000", "none", "finally", "if", "not", "caller_owns_file", "fp", "close"], "doc_len": 1118}
{"doc_id": "pydicom/jsonrep.py::_convert_to_python_number", "file_path": "pydicom/jsonrep.py", "class_name": null, "func_name": "_convert_to_python_number", "text": "文件路径: pydicom/jsonrep.py\ndef _convert_to_python_number(value, vr):\n    \"\"\"Makes sure that values are either ints or floats\n    based on their value representation.\n\n    Parameters\n    ----------\n    value: Union[Union[str, int, float], List[Union[str, int, float]]]\n        value of data element\n    vr: str\n        value representation of data element\n\n    Returns\n    -------\n    Union[Union[str, int, float], List[Union[str, int, float]]]\n\n    \"\"\"\n    if value is None:\n        return None\n    number_type = None\n    if vr in VRs_TO_BE_INTS:\n        number_type = int\n    if vr in VRs_TO_BE_FLOATS:\n        number_type = float\n    if number_type is not None:\n        if isinstance(value, (list, tuple, )):\n            value = [number_type(e) for e in value]\n        else:\n            value = number_type(value)\n    return value\n", "tokens": ["pydicom", "jsonrep", "py", "def", "_convert_to_python_number", "value", "vr", "makes", "sure", "that", "values", "are", "either", "ints", "or", "floats", "based", "on", "their", "value", "representation", "parameters", "value", "union", "union", "str", "int", "float", "list", "union", "str", "int", "float", "value", "of", "data", "element", "vr", "str", "value", "representation", "of", "data", "element", "returns", "union", "union", "str", "int", "float", "list", "union", "str", "int", "float", "if", "value", "is", "none", "return", "none", "number_type", "none", "if", "vr", "in", "vrs_to_be_ints", "number_type", "int", "if", "vr", "in", "vrs_to_be_floats", "number_type", "float", "if", "number_type", "is", "not", "none", "if", "isinstance", "value", "list", "tuple", "value", "number_type", "e", "for", "e", "in", "value", "else", "value", "number_type", "value", "return", "value"], "doc_len": 98}
{"doc_id": "pydicom/misc.py::size_in_bytes", "file_path": "pydicom/misc.py", "class_name": null, "func_name": "size_in_bytes", "text": "文件路径: pydicom/misc.py\ndef size_in_bytes(expr):\n    \"\"\"Return the number of bytes for a defer_size argument to dcmread()\n    \"\"\"\n    if expr is None or expr == float('inf'):\n        return None\n    try:\n        return int(expr)\n    except ValueError:\n        unit = expr[-2:].upper()\n        if unit in _size_factors.keys():\n            val = float(expr[:-2]) * _size_factors[unit]\n            return val\n        else:\n            raise ValueError(\n                \"Unable to parse length with unit '{0:s}'\".format(unit))\n", "tokens": ["pydicom", "misc", "py", "def", "size_in_bytes", "expr", "return", "the", "number", "of", "bytes", "for", "a", "defer_size", "argument", "to", "dcmread", "if", "expr", "is", "none", "or", "expr", "float", "inf", "return", "none", "try", "return", "int", "expr", "except", "valueerror", "unit", "expr", "2", "upper", "if", "unit", "in", "_size_factors", "keys", "val", "float", "expr", "2", "_size_factors", "unit", "return", "val", "else", "raise", "valueerror", "unable", "to", "parse", "length", "with", "unit", "0", "s", "format", "unit"], "doc_len": 63}
{"doc_id": "pydicom/misc.py::is_dicom", "file_path": "pydicom/misc.py", "class_name": null, "func_name": "is_dicom", "text": "文件路径: pydicom/misc.py\ndef is_dicom(file_path):\n    \"\"\"Boolean specifying if file is a proper DICOM file.\n\n    This function is a pared down version of read_preamble meant for a\n    fast return.\n    The file is read for a proper preamble ('DICM'), returning True if so,\n    and False otherwise. This is a conservative approach.\n\n    Parameters\n    ----------\n    file_path : str\n        The path to the file.\n\n    See Also\n    --------\n    filereader.read_preamble\n    filereader.read_partial\n    \"\"\"\n    with open(file_path, 'rb') as fp:\n        fp.read(0x80)  # preamble\n        magic = fp.read(4)\n    return magic == b\"DICM\"\n", "tokens": ["pydicom", "misc", "py", "def", "is_dicom", "file_path", "boolean", "specifying", "if", "file", "is", "a", "proper", "dicom", "file", "this", "function", "is", "a", "pared", "down", "version", "of", "read_preamble", "meant", "for", "a", "fast", "return", "the", "file", "is", "read", "for", "a", "proper", "preamble", "dicm", "returning", "true", "if", "so", "and", "false", "otherwise", "this", "is", "a", "conservative", "approach", "parameters", "file_path", "str", "the", "path", "to", "the", "file", "see", "also", "filereader", "read_preamble", "filereader", "read_partial", "with", "open", "file_path", "rb", "as", "fp", "fp", "read", "0x80", "preamble", "magic", "fp", "read", "4", "return", "magic", "b", "dicm"], "doc_len": 82}
{"doc_id": "pydicom/multival.py::MultiValue.__init__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__init__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __init__(self, type_constructor, iterable):\n        \"\"\"Initialize the list of values\n\n        :param type_constructor: a constructor for the required\n                           type for all list items. Could be the\n                           class, or a factory function. For DICOM\n                           multi-value data elements, this will be the\n                           class or type corresponding to the VR.\n        :param iterable: an iterable (e.g. list, tuple) of items\n                        to initialize the MultiValue list\n        \"\"\"\n        from pydicom.valuerep import DSfloat, DSdecimal, IS\n\n        def number_string_type_constructor(x):\n            return self.type_constructor(x) if x != '' else x\n\n        self._list = list()\n        self.type_constructor = type_constructor\n        if type_constructor in (DSfloat, IS, DSdecimal):\n            type_constructor = number_string_type_constructor\n        for x in iterable:\n            self._list.append(type_constructor(x))\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__init__", "self", "type_constructor", "iterable", "initialize", "the", "list", "of", "values", "param", "type_constructor", "a", "constructor", "for", "the", "required", "type", "for", "all", "list", "items", "could", "be", "the", "class", "or", "a", "factory", "function", "for", "dicom", "multi", "value", "data", "elements", "this", "will", "be", "the", "class", "or", "type", "corresponding", "to", "the", "vr", "param", "iterable", "an", "iterable", "e", "g", "list", "tuple", "of", "items", "to", "initialize", "the", "multivalue", "list", "from", "pydicom", "valuerep", "import", "dsfloat", "dsdecimal", "is", "def", "number_string_type_constructor", "x", "return", "self", "type_constructor", "x", "if", "x", "else", "x", "self", "_list", "list", "self", "type_constructor", "type_constructor", "if", "type_constructor", "in", "dsfloat", "is", "dsdecimal", "type_constructor", "number_string_type_constructor", "for", "x", "in", "iterable", "self", "_list", "append", "type_constructor", "x"], "doc_len": 107}
{"doc_id": "pydicom/multival.py::MultiValue.insert", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "insert", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def insert(self, position, val):\n        self._list.insert(position, self.type_constructor(val))\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "insert", "self", "position", "val", "self", "_list", "insert", "position", "self", "type_constructor", "val"], "doc_len": 16}
{"doc_id": "pydicom/multival.py::MultiValue.__setitem__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__setitem__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __setitem__(self, i, val):\n        \"\"\"Set an item of the list, making sure it is of the right VR type\"\"\"\n        if isinstance(i, slice):\n            val = [self.type_constructor(v) for v in val]\n            self._list.__setitem__(i, val)\n        else:\n            self._list.__setitem__(i, self.type_constructor(val))\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__setitem__", "self", "i", "val", "set", "an", "item", "of", "the", "list", "making", "sure", "it", "is", "of", "the", "right", "vr", "type", "if", "isinstance", "i", "slice", "val", "self", "type_constructor", "v", "for", "v", "in", "val", "self", "_list", "__setitem__", "i", "val", "else", "self", "_list", "__setitem__", "i", "self", "type_constructor", "val"], "doc_len": 49}
{"doc_id": "pydicom/multival.py::MultiValue.__str__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__str__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __str__(self):\n        if not self:\n            return ''\n        lines = [\"'{}'\".format(x) if isinstance(x, compat.char_types)\n                 else str(x) for x in self]\n        return \"[\" + \", \".join(lines) + \"]\"\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__str__", "self", "if", "not", "self", "return", "lines", "format", "x", "if", "isinstance", "x", "compat", "char_types", "else", "str", "x", "for", "x", "in", "self", "return", "join", "lines"], "doc_len": 29}
{"doc_id": "pydicom/multival.py::MultiValue.__len__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__len__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __len__(self):\n        return len(self._list)\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__len__", "self", "return", "len", "self", "_list"], "doc_len": 11}
{"doc_id": "pydicom/multival.py::MultiValue.__getitem__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__getitem__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __getitem__(self, index):\n        return self._list[index]\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__getitem__", "self", "index", "return", "self", "_list", "index"], "doc_len": 12}
{"doc_id": "pydicom/multival.py::MultiValue.__delitem__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__delitem__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __delitem__(self, index):\n        del self._list[index]\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__delitem__", "self", "index", "del", "self", "_list", "index"], "doc_len": 12}
{"doc_id": "pydicom/multival.py::MultiValue.__iter__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__iter__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __iter__(self):\n        return iter(self._list)\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__iter__", "self", "return", "iter", "self", "_list"], "doc_len": 11}
{"doc_id": "pydicom/multival.py::MultiValue.__eq__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__eq__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __eq__(self, other):\n        return self._list == other\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__eq__", "self", "other", "return", "self", "_list", "other"], "doc_len": 12}
{"doc_id": "pydicom/multival.py::MultiValue.__ne__", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "__ne__", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def __ne__(self, other):\n        return self._list != other\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "__ne__", "self", "other", "return", "self", "_list", "other"], "doc_len": 12}
{"doc_id": "pydicom/multival.py::MultiValue.sort", "file_path": "pydicom/multival.py", "class_name": "MultiValue", "func_name": "sort", "text": "文件路径: pydicom/multival.py, 类名: MultiValue\n    def sort(self, key=None, reverse=False):\n        self._list.sort(key=key, reverse=reverse)\n", "tokens": ["pydicom", "multival", "py", "multivalue", "def", "sort", "self", "key", "none", "reverse", "false", "self", "_list", "sort", "key", "key", "reverse", "reverse"], "doc_len": 18}
{"doc_id": "pydicom/sequence.py::validate_dataset", "file_path": "pydicom/sequence.py", "class_name": null, "func_name": "validate_dataset", "text": "文件路径: pydicom/sequence.py\ndef validate_dataset(elem):\n    \"\"\"Check that `elem` is a Dataset instance.\"\"\"\n    if not isinstance(elem, Dataset):\n        raise TypeError('Sequence contents must be Dataset instances.')\n\n    return elem\n", "tokens": ["pydicom", "sequence", "py", "def", "validate_dataset", "elem", "check", "that", "elem", "is", "a", "dataset", "instance", "if", "not", "isinstance", "elem", "dataset", "raise", "typeerror", "sequence", "contents", "must", "be", "dataset", "instances", "return", "elem"], "doc_len": 28}
{"doc_id": "pydicom/sequence.py::Sequence.__init__", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "__init__", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def __init__(self, iterable=None):\n        \"\"\"Initialize a list of Datasets.\n\n        Parameters\n        ----------\n        iterable : list-like of pydicom.dataset.Dataset, optional\n            An iterable object (e.g. list, tuple) containing\n            Datasets. If not used then an empty Sequence is generated.\n        \"\"\"\n        # We add this extra check to throw a relevant error. Without it, the\n        # error will be simply that a Sequence must contain Datasets (since a\n        # Dataset IS iterable). This error, however, doesn't inform the user\n        # that the actual issue is that their Dataset needs to be INSIDE an\n        # iterable object\n        if isinstance(iterable, Dataset):\n            raise TypeError('The Sequence constructor requires an iterable')\n\n        # the parent dataset\n        self._parent = None\n\n        # If no inputs are provided, we create an empty Sequence\n        if not iterable:\n            iterable = list()\n\n        # validate_dataset is used as a pseudo type_constructor\n        super(Sequence, self).__init__(validate_dataset, iterable)\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "__init__", "self", "iterable", "none", "initialize", "a", "list", "of", "datasets", "parameters", "iterable", "list", "like", "of", "pydicom", "dataset", "dataset", "optional", "an", "iterable", "object", "e", "g", "list", "tuple", "containing", "datasets", "if", "not", "used", "then", "an", "empty", "sequence", "is", "generated", "we", "add", "this", "extra", "check", "to", "throw", "a", "relevant", "error", "without", "it", "the", "error", "will", "be", "simply", "that", "a", "sequence", "must", "contain", "datasets", "since", "a", "dataset", "is", "iterable", "this", "error", "however", "doesn", "t", "inform", "the", "user", "that", "the", "actual", "issue", "is", "that", "their", "dataset", "needs", "to", "be", "inside", "an", "iterable", "object", "if", "isinstance", "iterable", "dataset", "raise", "typeerror", "the", "sequence", "constructor", "requires", "an", "iterable", "the", "parent", "dataset", "self", "_parent", "none", "if", "no", "inputs", "are", "provided", "we", "create", "an", "empty", "sequence", "if", "not", "iterable", "iterable", "list", "validate_dataset", "is", "used", "as", "a", "pseudo", "type_constructor", "super", "sequence", "self", "__init__", "validate_dataset", "iterable"], "doc_len": 138}
{"doc_id": "pydicom/sequence.py::Sequence.parent", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "parent", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def parent(self):\n        \"\"\"Return the parent dataset.\"\"\"\n        return self._parent\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "parent", "self", "return", "the", "parent", "dataset", "return", "self", "_parent"], "doc_len": 14}
{"doc_id": "pydicom/sequence.py::Sequence.parent", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "parent", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def parent(self, value):\n        \"\"\"Set the parent dataset and pass it to all items.\"\"\"\n        if value != self._parent:\n            self._parent = value\n            for item in self._list:\n                item.parent = self._parent\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "parent", "self", "value", "set", "the", "parent", "dataset", "and", "pass", "it", "to", "all", "items", "if", "value", "self", "_parent", "self", "_parent", "value", "for", "item", "in", "self", "_list", "item", "parent", "self", "_parent"], "doc_len": 34}
{"doc_id": "pydicom/sequence.py::Sequence.__setitem__", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "__setitem__", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def __setitem__(self, i, val):\n        \"\"\"Set the parent dataset to the new sequence item\"\"\"\n        super(Sequence, self).__setitem__(i, val)\n        val.parent = self._parent\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "__setitem__", "self", "i", "val", "set", "the", "parent", "dataset", "to", "the", "new", "sequence", "item", "super", "sequence", "self", "__setitem__", "i", "val", "val", "parent", "self", "_parent"], "doc_len": 28}
{"doc_id": "pydicom/sequence.py::Sequence.__str__", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "__str__", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def __str__(self):\n        \"\"\"String description of the Sequence.\"\"\"\n        lines = [str(x) for x in self]\n        return \"[\" + \"\".join(lines) + \"]\"\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "__str__", "self", "string", "description", "of", "the", "sequence", "lines", "str", "x", "for", "x", "in", "self", "return", "join", "lines"], "doc_len": 22}
{"doc_id": "pydicom/sequence.py::Sequence.__repr__", "file_path": "pydicom/sequence.py", "class_name": "Sequence", "func_name": "__repr__", "text": "文件路径: pydicom/sequence.py, 类名: Sequence\n    def __repr__(self):\n        \"\"\"String representation of the Sequence.\"\"\"\n        formatstr = \"<%(classname)s, length %(count)d>\"\n        return formatstr % {\n            'classname': self.__class__.__name__,\n            'count': len(self)\n        }\n", "tokens": ["pydicom", "sequence", "py", "sequence", "def", "__repr__", "self", "string", "representation", "of", "the", "sequence", "formatstr", "classname", "s", "length", "count", "d", "return", "formatstr", "classname", "self", "__class__", "__name__", "count", "len", "self"], "doc_len": 27}
{"doc_id": "pydicom/tag.py::tag_in_exception", "file_path": "pydicom/tag.py", "class_name": null, "func_name": "tag_in_exception", "text": "文件路径: pydicom/tag.py\ndef tag_in_exception(tag):\n    \"\"\"Use `tag` within a context.\n\n    Used to include the tag details in the traceback message when an exception\n    is raised within the context.\n\n    Parameters\n    ----------\n    tag : pydicom.tag.Tag\n        The tag to use in the context.\n    \"\"\"\n    try:\n        yield\n    except Exception as ex:\n        stack_trace = traceback.format_exc()\n        msg = 'With tag {0} got exception: {1}\\n{2}'.format(\n            tag,\n            str(ex),\n            stack_trace)\n        raise type(ex)(msg)\n", "tokens": ["pydicom", "tag", "py", "def", "tag_in_exception", "tag", "use", "tag", "within", "a", "context", "used", "to", "include", "the", "tag", "details", "in", "the", "traceback", "message", "when", "an", "exception", "is", "raised", "within", "the", "context", "parameters", "tag", "pydicom", "tag", "tag", "the", "tag", "to", "use", "in", "the", "context", "try", "yield", "except", "exception", "as", "ex", "stack_trace", "traceback", "format_exc", "msg", "with", "tag", "0", "got", "exception", "1", "n", "2", "format", "tag", "str", "ex", "stack_trace", "raise", "type", "ex", "msg"], "doc_len": 68}
{"doc_id": "pydicom/tag.py::Tag", "file_path": "pydicom/tag.py", "class_name": null, "func_name": "Tag", "text": "文件路径: pydicom/tag.py\ndef Tag(arg, arg2=None):\n    \"\"\"Create a Tag.\n\n    General function for creating a Tag in any of the standard forms:\n\n    * Tag(0x00100015)\n    * Tag('0x00100015')\n    * Tag((0x10, 0x50))\n    * Tag(('0x10', '0x50'))\n    * Tag(0x0010, 0x0015)\n    * Tag(0x10, 0x15)\n    * Tag(2341, 0x10)\n    * Tag('0xFE', '0x0010')\n    * Tag(\"PatientName\")\n\n    Parameters\n    ----------\n    arg : int or str or 2-tuple/list\n        If int or str, then either the group or the combined\n        group/element number of the DICOM tag. If 2-tuple/list\n        then the (group, element) numbers as int or str.\n    arg2 : int or str, optional\n        The element number of the DICOM tag, required when\n        `arg` only contains the group number of the tag.\n\n    Returns\n    -------\n    pydicom.tag.BaseTag\n    \"\"\"\n    if isinstance(arg, BaseTag):\n        return arg\n\n    if arg2 is not None:\n        arg = (arg, arg2)  # act as if was passed a single tuple\n\n    if isinstance(arg, (tuple, list)):\n        if len(arg) != 2:\n            raise ValueError(\"Tag must be an int or a 2-tuple\")\n\n        valid = False\n        if isinstance(arg[0], compat.string_types):\n            valid = isinstance(arg[1], (str, compat.string_types))\n            if valid:\n                arg = (int(arg[0], 16), int(arg[1], 16))\n        elif isinstance(arg[0], compat.number_types):\n            valid = isinstance(arg[1], compat.number_types)\n        if not valid:\n            raise ValueError(\"Both arguments for Tag must be the same type, \"\n                             \"either string or int.\")\n\n        if arg[0] > 0xFFFF or arg[1] > 0xFFFF:\n            raise OverflowError(\"Groups and elements of tags must each \"\n                                \"be <=2 byte integers\")\n\n        long_value = (arg[0] << 16) | arg[1]\n\n    # Single str parameter\n    elif isinstance(arg, (str, compat.text_type)):\n        try:\n            long_value = int(arg, 16)\n            if long_value > 0xFFFFFFFF:\n                raise OverflowError(\"Tags are limited to 32-bit length; \"\n                                    \"tag {0!r}\"\n                                    .format(long_value))\n        except ValueError:\n            # Try a DICOM keyword\n            from pydicom.datadict import tag_for_keyword\n            long_value = tag_for_keyword(arg)\n            if long_value is None:\n                raise ValueError(\"'{}' is not a valid int or DICOM keyword\"\n                                 .format(arg))\n    # Single int parameter\n    else:\n        long_value = arg\n        if long_value > 0xFFFFFFFF:\n            raise OverflowError(\"Tags are limited to 32-bit length; tag {0!r}\"\n                                .format(long_value))\n\n    if long_value < 0:\n        raise ValueError(\"Tags must be positive.\")\n\n    return BaseTag(long_value)\n", "tokens": ["pydicom", "tag", "py", "def", "tag", "arg", "arg2", "none", "create", "a", "tag", "general", "function", "for", "creating", "a", "tag", "in", "any", "of", "the", "standard", "forms", "tag", "0x00100015", "tag", "0x00100015", "tag", "0x10", "0x50", "tag", "0x10", "0x50", "tag", "0x0010", "0x0015", "tag", "0x10", "0x15", "tag", "2341", "0x10", "tag", "0xfe", "0x0010", "tag", "patientname", "parameters", "arg", "int", "or", "str", "or", "2", "tuple", "list", "if", "int", "or", "str", "then", "either", "the", "group", "or", "the", "combined", "group", "element", "number", "of", "the", "dicom", "tag", "if", "2", "tuple", "list", "then", "the", "group", "element", "numbers", "as", "int", "or", "str", "arg2", "int", "or", "str", "optional", "the", "element", "number", "of", "the", "dicom", "tag", "required", "when", "arg", "only", "contains", "the", "group", "number", "of", "the", "tag", "returns", "pydicom", "tag", "basetag", "if", "isinstance", "arg", "basetag", "return", "arg", "if", "arg2", "is", "not", "none", "arg", "arg", "arg2", "act", "as", "if", "was", "passed", "a", "single", "tuple", "if", "isinstance", "arg", "tuple", "list", "if", "len", "arg", "2", "raise", "valueerror", "tag", "must", "be", "an", "int", "or", "a", "2", "tuple", "valid", "false", "if", "isinstance", "arg", "0", "compat", "string_types", "valid", "isinstance", "arg", "1", "str", "compat", "string_types", "if", "valid", "arg", "int", "arg", "0", "16", "int", "arg", "1", "16", "elif", "isinstance", "arg", "0", "compat", "number_types", "valid", "isinstance", "arg", "1", "compat", "number_types", "if", "not", "valid", "raise", "valueerror", "both", "arguments", "for", "tag", "must", "be", "the", "same", "type", "either", "string", "or", "int", "if", "arg", "0", "0xffff", "or", "arg", "1", "0xffff", "raise", "overflowerror", "groups", "and", "elements", "of", "tags", "must", "each", "be", "2", "byte", "integers", "long_value", "arg", "0", "16", "arg", "1", "single", "str", "parameter", "elif", "isinstance", "arg", "str", "compat", "text_type", "try", "long_value", "int", "arg", "16", "if", "long_value", "0xffffffff", "raise", "overflowerror", "tags", "are", "limited", "to", "32", "bit", "length", "tag", "0", "r", "format", "long_value", "except", "valueerror", "try", "a", "dicom", "keyword", "from", "pydicom", "datadict", "import", "tag_for_keyword", "long_value", "tag_for_keyword", "arg", "if", "long_value", "is", "none", "raise", "valueerror", "is", "not", "a", "valid", "int", "or", "dicom", "keyword", "format", "arg", "single", "int", "parameter", "else", "long_value", "arg", "if", "long_value", "0xffffffff", "raise", "overflowerror", "tags", "are", "limited", "to", "32", "bit", "length", "tag", "0", "r", "format", "long_value", "if", "long_value", "0", "raise", "valueerror", "tags", "must", "be", "positive", "return", "basetag", "long_value"], "doc_len": 335}
{"doc_id": "pydicom/tag.py::BaseTag.__le__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__le__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __le__(self, other):\n        \"\"\"Return True if `self`  is less than or equal to `other`.\"\"\"\n        return self == other or self < other\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__le__", "self", "other", "return", "true", "if", "self", "is", "less", "than", "or", "equal", "to", "other", "return", "self", "other", "or", "self", "other"], "doc_len": 25}
{"doc_id": "pydicom/tag.py::BaseTag.__lt__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__lt__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __lt__(self, other):\n        \"\"\"Return True if `self` is less than `other`.\"\"\"\n        # Check if comparing with another Tag object; if not, create a temp one\n        if not isinstance(other, BaseTag):\n            try:\n                other = Tag(other)\n            except Exception:\n                raise TypeError(\"Cannot compare Tag with non-Tag item\")\n\n        return BaseTag_base_class(self) < BaseTag_base_class(other)\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__lt__", "self", "other", "return", "true", "if", "self", "is", "less", "than", "other", "check", "if", "comparing", "with", "another", "tag", "object", "if", "not", "create", "a", "temp", "one", "if", "not", "isinstance", "other", "basetag", "try", "other", "tag", "other", "except", "exception", "raise", "typeerror", "cannot", "compare", "tag", "with", "non", "tag", "item", "return", "basetag_base_class", "self", "basetag_base_class", "other"], "doc_len": 54}
{"doc_id": "pydicom/tag.py::BaseTag.__ge__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__ge__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __ge__(self, other):\n        \"\"\"Return True if `self` is greater than or equal to `other`.\"\"\"\n        return self == other or self > other\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__ge__", "self", "other", "return", "true", "if", "self", "is", "greater", "than", "or", "equal", "to", "other", "return", "self", "other", "or", "self", "other"], "doc_len": 25}
{"doc_id": "pydicom/tag.py::BaseTag.__gt__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__gt__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __gt__(self, other):\n        \"\"\"Return True if `self` is greater than `other`.\"\"\"\n        return not (self == other or self < other)\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__gt__", "self", "other", "return", "true", "if", "self", "is", "greater", "than", "other", "return", "not", "self", "other", "or", "self", "other"], "doc_len": 23}
{"doc_id": "pydicom/tag.py::BaseTag.__eq__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__eq__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __eq__(self, other):\n        \"\"\"Return True if `self` equals `other`.\"\"\"\n        # Check if comparing with another Tag object; if not, create a temp one\n        if not isinstance(other, BaseTag_base_class):\n            try:\n                other = Tag(other)\n            except Exception:\n                raise TypeError(\"Cannot compare Tag with non-Tag item\")\n\n        return BaseTag_base_class(self) == BaseTag_base_class(other)\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__eq__", "self", "other", "return", "true", "if", "self", "equals", "other", "check", "if", "comparing", "with", "another", "tag", "object", "if", "not", "create", "a", "temp", "one", "if", "not", "isinstance", "other", "basetag_base_class", "try", "other", "tag", "other", "except", "exception", "raise", "typeerror", "cannot", "compare", "tag", "with", "non", "tag", "item", "return", "basetag_base_class", "self", "basetag_base_class", "other"], "doc_len": 52}
{"doc_id": "pydicom/tag.py::BaseTag.__ne__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__ne__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __ne__(self, other):\n        \"\"\"Return True if `self` does not equal `other`.\"\"\"\n        return not self == other\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__ne__", "self", "other", "return", "true", "if", "self", "does", "not", "equal", "other", "return", "not", "self", "other"], "doc_len": 20}
{"doc_id": "pydicom/tag.py::BaseTag.__str__", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "__str__", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def __str__(self):\n        \"\"\"Return the tag value as a hex string '(gggg, eeee)'.\"\"\"\n        return \"({0:04x}, {1:04x})\".format(self.group, self.element)\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "__str__", "self", "return", "the", "tag", "value", "as", "a", "hex", "string", "gggg", "eeee", "return", "0", "04x", "1", "04x", "format", "self", "group", "self", "element"], "doc_len": 27}
{"doc_id": "pydicom/tag.py::BaseTag.group", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "group", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def group(self):\n        \"\"\"Return the tag's group number.\"\"\"\n        return self >> 16\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "group", "self", "return", "the", "tag", "s", "group", "number", "return", "self", "16"], "doc_len": 16}
{"doc_id": "pydicom/tag.py::BaseTag.element", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "element", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def element(self):\n        \"\"\"Return the tag's element number.\"\"\"\n        return self & 0xffff\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "element", "self", "return", "the", "tag", "s", "element", "number", "return", "self", "0xffff"], "doc_len": 16}
{"doc_id": "pydicom/tag.py::BaseTag.is_private", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "is_private", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def is_private(self):\n        \"\"\"Return True if the tag is private (has an odd group number).\"\"\"\n        return self.group % 2 == 1\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "is_private", "self", "return", "true", "if", "the", "tag", "is", "private", "has", "an", "odd", "group", "number", "return", "self", "group", "2", "1"], "doc_len": 24}
{"doc_id": "pydicom/tag.py::BaseTag.is_private_creator", "file_path": "pydicom/tag.py", "class_name": "BaseTag", "func_name": "is_private_creator", "text": "文件路径: pydicom/tag.py, 类名: BaseTag\n    def is_private_creator(self):\n        \"\"\"Return True if the tag is a private creator.\"\"\"\n        return self.is_private and 0x0010 <= self.element < 0x0100\n", "tokens": ["pydicom", "tag", "py", "basetag", "def", "is_private_creator", "self", "return", "true", "if", "the", "tag", "is", "a", "private", "creator", "return", "self", "is_private", "and", "0x0010", "self", "element", "0x0100"], "doc_len": 24}
{"doc_id": "pydicom/tag.py::TupleTag", "file_path": "pydicom/tag.py", "class_name": null, "func_name": "TupleTag", "text": "文件路径: pydicom/tag.py\ndef TupleTag(group_elem):\n    \"\"\"Fast factory for BaseTag object with known safe (group, elem) tuple\"\"\"\n    long_value = group_elem[0] << 16 | group_elem[1]\n    return BaseTag(long_value)\n", "tokens": ["pydicom", "tag", "py", "def", "tupletag", "group_elem", "fast", "factory", "for", "basetag", "object", "with", "known", "safe", "group", "elem", "tuple", "long_value", "group_elem", "0", "16", "group_elem", "1", "return", "basetag", "long_value"], "doc_len": 26}
{"doc_id": "pydicom/uid.py::UID.__new__", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "__new__", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def __new__(cls, val):\n        \"\"\"Setup new instance of the class.\n\n        Parameters\n        ----------\n        val : str or pydicom.uid.UID\n            The UID string to use to create the UID object.\n\n        Returns\n        -------\n        pydicom.uid.UID\n            The UID object.\n        \"\"\"\n        # Don't repeat if already a UID class then may get the name that\n        #   str(uid) gives rather than the dotted number\n        if isinstance(val, UID):\n            return val\n\n        if isinstance(val, compat.string_types):\n            return super(UID, cls).__new__(cls, val.strip())\n\n        raise TypeError(\"UID must be a string\")\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "__new__", "cls", "val", "setup", "new", "instance", "of", "the", "class", "parameters", "val", "str", "or", "pydicom", "uid", "uid", "the", "uid", "string", "to", "use", "to", "create", "the", "uid", "object", "returns", "pydicom", "uid", "uid", "the", "uid", "object", "don", "t", "repeat", "if", "already", "a", "uid", "class", "then", "may", "get", "the", "name", "that", "str", "uid", "gives", "rather", "than", "the", "dotted", "number", "if", "isinstance", "val", "uid", "return", "val", "if", "isinstance", "val", "compat", "string_types", "return", "super", "uid", "cls", "__new__", "cls", "val", "strip", "raise", "typeerror", "uid", "must", "be", "a", "string"], "doc_len": 86}
{"doc_id": "pydicom/uid.py::UID.is_implicit_VR", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_implicit_VR", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_implicit_VR(self):\n        \"\"\"Return True if an implicit VR transfer syntax UID.\"\"\"\n        if self.is_transfer_syntax:\n            # Implicit VR Little Endian\n            if self == '1.2.840.10008.1.2':\n                return True\n\n            # Explicit VR Little Endian\n            # Explicit VR Big Endian\n            # Deflated Explicit VR Little Endian\n            # All encapsulated transfer syntaxes\n            return False\n\n        raise ValueError('UID is not a transfer syntax.')\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_implicit_vr", "self", "return", "true", "if", "an", "implicit", "vr", "transfer", "syntax", "uid", "if", "self", "is_transfer_syntax", "implicit", "vr", "little", "endian", "if", "self", "1", "2", "840", "10008", "1", "2", "return", "true", "explicit", "vr", "little", "endian", "explicit", "vr", "big", "endian", "deflated", "explicit", "vr", "little", "endian", "all", "encapsulated", "transfer", "syntaxes", "return", "false", "raise", "valueerror", "uid", "is", "not", "a", "transfer", "syntax"], "doc_len": 60}
{"doc_id": "pydicom/uid.py::UID.is_little_endian", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_little_endian", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_little_endian(self):\n        \"\"\"Return True if a little endian transfer syntax UID.\"\"\"\n        if self.is_transfer_syntax:\n            # Explicit VR Big Endian\n            if self == '1.2.840.10008.1.2.2':\n                return False\n\n            # Explicit VR Little Endian\n            # Implicit VR Little Endian\n            # Deflated Explicit VR Little Endian\n            # All encapsulated transfer syntaxes\n            return True\n\n        raise ValueError('UID is not a transfer syntax.')\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_little_endian", "self", "return", "true", "if", "a", "little", "endian", "transfer", "syntax", "uid", "if", "self", "is_transfer_syntax", "explicit", "vr", "big", "endian", "if", "self", "1", "2", "840", "10008", "1", "2", "2", "return", "false", "explicit", "vr", "little", "endian", "implicit", "vr", "little", "endian", "deflated", "explicit", "vr", "little", "endian", "all", "encapsulated", "transfer", "syntaxes", "return", "true", "raise", "valueerror", "uid", "is", "not", "a", "transfer", "syntax"], "doc_len": 61}
{"doc_id": "pydicom/uid.py::UID.is_transfer_syntax", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_transfer_syntax", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_transfer_syntax(self):\n        \"\"\"Return True if a transfer syntax UID.\"\"\"\n        if not self.is_private:\n            return self.type == \"Transfer Syntax\"\n\n        raise ValueError(\"Can't determine UID type for private UIDs.\")\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_transfer_syntax", "self", "return", "true", "if", "a", "transfer", "syntax", "uid", "if", "not", "self", "is_private", "return", "self", "type", "transfer", "syntax", "raise", "valueerror", "can", "t", "determine", "uid", "type", "for", "private", "uids"], "doc_len": 33}
{"doc_id": "pydicom/uid.py::UID.is_deflated", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_deflated", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_deflated(self):\n        \"\"\"Return True if a deflated transfer syntax UID.\"\"\"\n        if self.is_transfer_syntax:\n            # Deflated Explicit VR Little Endian\n            if self == '1.2.840.10008.1.2.1.99':\n                return True\n\n            # Explicit VR Little Endian\n            # Implicit VR Little Endian\n            # Explicit VR Big Endian\n            # All encapsulated transfer syntaxes\n            return False\n\n        raise ValueError('UID is not a transfer syntax.')\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_deflated", "self", "return", "true", "if", "a", "deflated", "transfer", "syntax", "uid", "if", "self", "is_transfer_syntax", "deflated", "explicit", "vr", "little", "endian", "if", "self", "1", "2", "840", "10008", "1", "2", "1", "99", "return", "true", "explicit", "vr", "little", "endian", "implicit", "vr", "little", "endian", "explicit", "vr", "big", "endian", "all", "encapsulated", "transfer", "syntaxes", "return", "false", "raise", "valueerror", "uid", "is", "not", "a", "transfer", "syntax"], "doc_len": 61}
{"doc_id": "pydicom/uid.py::UID.is_encapsulated", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_encapsulated", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_encapsulated(self):\n        \"\"\"Return True if an encasulated transfer syntax UID.\"\"\"\n        return self.is_compressed\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_encapsulated", "self", "return", "true", "if", "an", "encasulated", "transfer", "syntax", "uid", "return", "self", "is_compressed"], "doc_len": 18}
{"doc_id": "pydicom/uid.py::UID.is_compressed", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_compressed", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_compressed(self):\n        \"\"\"Return True if a compressed transfer syntax UID.\"\"\"\n        if self.is_transfer_syntax:\n            # Explicit VR Little Endian\n            # Implicit VR Little Endian\n            # Explicit VR Big Endian\n            # Deflated Explicit VR Little Endian\n            if self in ['1.2.840.10008.1.2', '1.2.840.10008.1.2.1',\n                        '1.2.840.10008.1.2.2', '1.2.840.10008.1.2.1.99']:\n                return False\n\n            # All encapsulated transfer syntaxes\n            return True\n\n        raise ValueError('UID is not a transfer syntax.')\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_compressed", "self", "return", "true", "if", "a", "compressed", "transfer", "syntax", "uid", "if", "self", "is_transfer_syntax", "explicit", "vr", "little", "endian", "implicit", "vr", "little", "endian", "explicit", "vr", "big", "endian", "deflated", "explicit", "vr", "little", "endian", "if", "self", "in", "1", "2", "840", "10008", "1", "2", "1", "2", "840", "10008", "1", "2", "1", "1", "2", "840", "10008", "1", "2", "2", "1", "2", "840", "10008", "1", "2", "1", "99", "return", "false", "all", "encapsulated", "transfer", "syntaxes", "return", "true", "raise", "valueerror", "uid", "is", "not", "a", "transfer", "syntax"], "doc_len": 82}
{"doc_id": "pydicom/uid.py::UID.name", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "name", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def name(self):\n        \"\"\"Return the UID name from the UID dictionary.\"\"\"\n        uid_string = str.__str__(self)\n        if uid_string in UID_dictionary:\n            return UID_dictionary[self][0]\n\n        return uid_string\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "name", "self", "return", "the", "uid", "name", "from", "the", "uid", "dictionary", "uid_string", "str", "__str__", "self", "if", "uid_string", "in", "uid_dictionary", "return", "uid_dictionary", "self", "0", "return", "uid_string"], "doc_len": 29}
{"doc_id": "pydicom/uid.py::UID.type", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "type", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def type(self):\n        \"\"\"Return the UID type from the UID dictionary.\"\"\"\n        if str.__str__(self) in UID_dictionary:\n            return UID_dictionary[self][1]\n\n        return ''\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "type", "self", "return", "the", "uid", "type", "from", "the", "uid", "dictionary", "if", "str", "__str__", "self", "in", "uid_dictionary", "return", "uid_dictionary", "self", "1", "return"], "doc_len": 26}
{"doc_id": "pydicom/uid.py::UID.info", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "info", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def info(self):\n        \"\"\"Return the UID info from the UID dictionary.\"\"\"\n        if str.__str__(self) in UID_dictionary:\n            return UID_dictionary[self][2]\n\n        return ''\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "info", "self", "return", "the", "uid", "info", "from", "the", "uid", "dictionary", "if", "str", "__str__", "self", "in", "uid_dictionary", "return", "uid_dictionary", "self", "2", "return"], "doc_len": 26}
{"doc_id": "pydicom/uid.py::UID.is_retired", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_retired", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_retired(self):\n        \"\"\"Return True if the UID is retired, False otherwise or if private.\"\"\"\n        if str.__str__(self) in UID_dictionary:\n            return bool(UID_dictionary[self][3])\n\n        return False\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_retired", "self", "return", "true", "if", "the", "uid", "is", "retired", "false", "otherwise", "or", "if", "private", "if", "str", "__str__", "self", "in", "uid_dictionary", "return", "bool", "uid_dictionary", "self", "3", "return", "false"], "doc_len": 32}
{"doc_id": "pydicom/uid.py::UID.is_private", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_private", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_private(self):\n        \"\"\"Return True if the UID isn't an officially registered DICOM UID.\"\"\"\n        if self[:13] == '1.2.840.10008':\n            return False\n\n        return True\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_private", "self", "return", "true", "if", "the", "uid", "isn", "t", "an", "officially", "registered", "dicom", "uid", "if", "self", "13", "1", "2", "840", "10008", "return", "false", "return", "true"], "doc_len": 30}
{"doc_id": "pydicom/uid.py::UID.is_valid", "file_path": "pydicom/uid.py", "class_name": "UID", "func_name": "is_valid", "text": "文件路径: pydicom/uid.py, 类名: UID\n    def is_valid(self):\n        \"\"\"Return True if `self` is a valid UID, False otherwise.\"\"\"\n        if len(self) <= 64 and re.match(RE_VALID_UID, self):\n            return True\n\n        return False\n", "tokens": ["pydicom", "uid", "py", "uid", "def", "is_valid", "self", "return", "true", "if", "self", "is", "a", "valid", "uid", "false", "otherwise", "if", "len", "self", "64", "and", "re", "match", "re_valid_uid", "self", "return", "true", "return", "false"], "doc_len": 30}
{"doc_id": "pydicom/uid.py::generate_uid", "file_path": "pydicom/uid.py", "class_name": null, "func_name": "generate_uid", "text": "文件路径: pydicom/uid.py\ndef generate_uid(prefix=PYDICOM_ROOT_UID, entropy_srcs=None):\n    \"\"\"Return a 64 character UID which starts with `prefix`.\n\n    Parameters\n    ----------\n    prefix : str or None\n        The UID prefix to use when creating the UID. Default is the pydicom\n        root UID '1.2.826.0.1.3680043.8.498.'. If None then a prefix of '2.25.'\n        will be used with the integer form of a UUID generated using the\n        UUID4 algorithm.\n    entropy_srcs : list of str or None\n        If `prefix` is not None, then the prefix will be appended with a\n        SHA512 hash of the list which means the result is deterministic and\n        should make the original data unrecoverable. If None random data will\n        be used (default).\n\n    Returns\n    -------\n    pydicom.uid.UID\n        A DICOM UID of up to 64 characters.\n\n    Raises\n    ------\n    ValueError\n        If `prefix` is invalid or greater than 63 characters.\n\n    Example\n    -------\n    >>> from pydicom.uid import generate_uid\n    >>> generate_uid()\n    1.2.826.0.1.3680043.8.498.22463838056059845879389038257786771680\n    >>> generate_uid(prefix=None)\n    2.25.167161297070865690102504091919570542144\n    >>> generate_uid(entropy_srcs=['lorem', 'ipsum'])\n    1.2.826.0.1.3680043.8.498.87507166259346337659265156363895084463\n    >>> generate_uid(entropy_srcs=['lorem', 'ipsum'])\n    1.2.826.0.1.3680043.8.498.87507166259346337659265156363895084463\n    \"\"\"\n    if prefix is None:\n        # UUID -> as 128-bit int -> max 39 characters long\n        return UID('2.25.{}'.format(uuid.uuid4().int))\n\n    max_uid_len = 64\n    if len(prefix) > max_uid_len - 1:\n        raise ValueError(\"The prefix must be less than 63 chars\")\n    if not re.match(RE_VALID_UID_PREFIX, prefix):\n        raise ValueError(\"The prefix is not in a valid format\")\n\n    avail_digits = max_uid_len - len(prefix)\n\n    if entropy_srcs is None:\n        entropy_srcs = [\n            str(uuid.uuid1()),  # 128-bit from MAC/time/randomness\n            str(os.getpid()),  # Current process ID\n            hex(random.getrandbits(64))  # 64 bits randomness\n        ]\n    hash_val = hashlib.sha512(''.join(entropy_srcs).encode('utf-8'))\n\n    # Convert this to an int with the maximum available digits\n    dicom_uid = prefix + str(int(hash_val.hexdigest(), 16))[:avail_digits]\n\n    return UID(dicom_uid)\n", "tokens": ["pydicom", "uid", "py", "def", "generate_uid", "prefix", "pydicom_root_uid", "entropy_srcs", "none", "return", "a", "64", "character", "uid", "which", "starts", "with", "prefix", "parameters", "prefix", "str", "or", "none", "the", "uid", "prefix", "to", "use", "when", "creating", "the", "uid", "default", "is", "the", "pydicom", "root", "uid", "1", "2", "826", "0", "1", "3680043", "8", "498", "if", "none", "then", "a", "prefix", "of", "2", "25", "will", "be", "used", "with", "the", "integer", "form", "of", "a", "uuid", "generated", "using", "the", "uuid4", "algorithm", "entropy_srcs", "list", "of", "str", "or", "none", "if", "prefix", "is", "not", "none", "then", "the", "prefix", "will", "be", "appended", "with", "a", "sha512", "hash", "of", "the", "list", "which", "means", "the", "result", "is", "deterministic", "and", "should", "make", "the", "original", "data", "unrecoverable", "if", "none", "random", "data", "will", "be", "used", "default", "returns", "pydicom", "uid", "uid", "a", "dicom", "uid", "of", "up", "to", "64", "characters", "raises", "valueerror", "if", "prefix", "is", "invalid", "or", "greater", "than", "63", "characters", "example", "from", "pydicom", "uid", "import", "generate_uid", "generate_uid", "1", "2", "826", "0", "1", "3680043", "8", "498", "22463838056059845879389038257786771680", "generate_uid", "prefix", "none", "2", "25", "167161297070865690102504091919570542144", "generate_uid", "entropy_srcs", "lorem", "ipsum", "1", "2", "826", "0", "1", "3680043", "8", "498", "87507166259346337659265156363895084463", "generate_uid", "entropy_srcs", "lorem", "ipsum", "1", "2", "826", "0", "1", "3680043", "8", "498", "87507166259346337659265156363895084463", "if", "prefix", "is", "none", "uuid", "as", "128", "bit", "int", "max", "39", "characters", "long", "return", "uid", "2", "25", "format", "uuid", "uuid4", "int", "max_uid_len", "64", "if", "len", "prefix", "max_uid_len", "1", "raise", "valueerror", "the", "prefix", "must", "be", "less", "than", "63", "chars", "if", "not", "re", "match", "re_valid_uid_prefix", "prefix", "raise", "valueerror", "the", "prefix", "is", "not", "in", "a", "valid", "format", "avail_digits", "max_uid_len", "len", "prefix", "if", "entropy_srcs", "is", "none", "entropy_srcs", "str", "uuid", "uuid1", "128", "bit", "from", "mac", "time", "randomness", "str", "os", "getpid", "current", "process", "id", "hex", "random", "getrandbits", "64", "64", "bits", "randomness", "hash_val", "hashlib", "sha512", "join", "entropy_srcs", "encode", "utf", "8", "convert", "this", "to", "an", "int", "with", "the", "maximum", "available", "digits", "dicom_uid", "prefix", "str", "int", "hash_val", "hexdigest", "16", "avail_digits", "return", "uid", "dicom_uid"], "doc_len": 299}
{"doc_id": "pydicom/valuerep.py::DA.__getstate__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__getstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __getstate__(self):\n        return dict((slot, getattr(self, slot)) for slot in self.__slots__\n                    if hasattr(self, slot))\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__getstate__", "self", "return", "dict", "slot", "getattr", "self", "slot", "for", "slot", "in", "self", "__slots__", "if", "hasattr", "self", "slot"], "doc_len": 22}
{"doc_id": "pydicom/valuerep.py::DA.__setstate__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__setstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __setstate__(self, state):\n        for slot, value in state.items():\n            setattr(self, slot, value)\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__setstate__", "self", "state", "for", "slot", "value", "in", "state", "items", "setattr", "self", "slot", "value"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::DA.__reduce__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__reduce__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __reduce__(self):\n        return super(DA, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__reduce__", "self", "return", "super", "da", "self", "__reduce__", "self", "__getstate__"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::DA.__reduce_ex__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__reduce_ex__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __reduce_ex__(self, protocol):\n        return super(DA, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__reduce_ex__", "self", "protocol", "return", "super", "da", "self", "__reduce__", "self", "__getstate__"], "doc_len": 15}
{"doc_id": "pydicom/valuerep.py::DA.__new__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __new__(cls, val):\n        \"\"\"Create an instance of DA object.\n\n        Raise an exception if the string cannot be parsed or the argument\n        is otherwise incompatible.\n\n        :param val: val must be a string conformant to the DA definition\n        in the DICOM Standard PS 3.5-2011\n        \"\"\"\n        if isinstance(val, (str, compat.string_types)):\n            if len(val) == 8:\n                year = int(val[0:4])\n                month = int(val[4:6])\n                day = int(val[6:8])\n                val = super(DA, cls).__new__(cls, year, month, day)\n            elif len(val) == 10 and val[4] == '.' and val[7] == '.':\n                # ACR-NEMA Standard 300, predecessor to DICOM\n                # for compatibility with a few old pydicom example files\n                year = int(val[0:4])\n                month = int(val[5:7])\n                day = int(val[8:10])\n                val = super(DA, cls).__new__(cls, year, month, day)\n            elif val == '':\n                val = None  # empty date\n            else:\n                try:\n                    val = super(DA, cls).__new__(cls, val)\n                except TypeError:\n                    raise ValueError(\"Cannot convert to datetime: '%s'\" %\n                                     (val))\n        elif isinstance(val, date):\n            val = super(DA, cls).__new__(cls, val.year, val.month, val.day)\n        else:\n            val = super(DA, cls).__new__(cls, val)\n        return val\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__new__", "cls", "val", "create", "an", "instance", "of", "da", "object", "raise", "an", "exception", "if", "the", "string", "cannot", "be", "parsed", "or", "the", "argument", "is", "otherwise", "incompatible", "param", "val", "val", "must", "be", "a", "string", "conformant", "to", "the", "da", "definition", "in", "the", "dicom", "standard", "ps", "3", "5", "2011", "if", "isinstance", "val", "str", "compat", "string_types", "if", "len", "val", "8", "year", "int", "val", "0", "4", "month", "int", "val", "4", "6", "day", "int", "val", "6", "8", "val", "super", "da", "cls", "__new__", "cls", "year", "month", "day", "elif", "len", "val", "10", "and", "val", "4", "and", "val", "7", "acr", "nema", "standard", "300", "predecessor", "to", "dicom", "for", "compatibility", "with", "a", "few", "old", "pydicom", "example", "files", "year", "int", "val", "0", "4", "month", "int", "val", "5", "7", "day", "int", "val", "8", "10", "val", "super", "da", "cls", "__new__", "cls", "year", "month", "day", "elif", "val", "val", "none", "empty", "date", "else", "try", "val", "super", "da", "cls", "__new__", "cls", "val", "except", "typeerror", "raise", "valueerror", "cannot", "convert", "to", "datetime", "s", "val", "elif", "isinstance", "val", "date", "val", "super", "da", "cls", "__new__", "cls", "val", "year", "val", "month", "val", "day", "else", "val", "super", "da", "cls", "__new__", "cls", "val", "return", "val"], "doc_len": 184}
{"doc_id": "pydicom/valuerep.py::DA.__init__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __init__(self, val):\n        if isinstance(val, (str, compat.string_types)):\n            self.original_string = val\n        elif isinstance(val, DA) and hasattr(val, 'original_string'):\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__init__", "self", "val", "if", "isinstance", "val", "str", "compat", "string_types", "self", "original_string", "val", "elif", "isinstance", "val", "da", "and", "hasattr", "val", "original_string", "self", "original_string", "val", "original_string"], "doc_len": 29}
{"doc_id": "pydicom/valuerep.py::DA.__str__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __str__(self):\n        if hasattr(self, 'original_string'):\n            return self.original_string\n        else:\n            return super(DA, self).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__str__", "self", "if", "hasattr", "self", "original_string", "return", "self", "original_string", "else", "return", "super", "da", "self", "__str__"], "doc_len": 20}
{"doc_id": "pydicom/valuerep.py::DA.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "DA", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: DA\n    def __repr__(self):\n        return \"\\\"\" + str(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "da", "def", "__repr__", "self", "return", "str", "self"], "doc_len": 10}
{"doc_id": "pydicom/valuerep.py::DT.__getstate__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__getstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __getstate__(self):\n        return dict((slot, getattr(self, slot)) for slot in self.__slots__\n                    if hasattr(self, slot))\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__getstate__", "self", "return", "dict", "slot", "getattr", "self", "slot", "for", "slot", "in", "self", "__slots__", "if", "hasattr", "self", "slot"], "doc_len": 22}
{"doc_id": "pydicom/valuerep.py::DT.__setstate__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__setstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __setstate__(self, state):\n        for slot, value in state.items():\n            setattr(self, slot, value)\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__setstate__", "self", "state", "for", "slot", "value", "in", "state", "items", "setattr", "self", "slot", "value"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::DT.__reduce__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__reduce__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __reduce__(self):\n        return super(DT, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__reduce__", "self", "return", "super", "dt", "self", "__reduce__", "self", "__getstate__"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::DT.__reduce_ex__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__reduce_ex__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __reduce_ex__(self, protocol):\n        return super(DT, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__reduce_ex__", "self", "protocol", "return", "super", "dt", "self", "__reduce__", "self", "__getstate__"], "doc_len": 15}
{"doc_id": "pydicom/valuerep.py::DT._utc_offset", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "_utc_offset", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def _utc_offset(offset, name):\n        return timezone(timedelta(seconds=offset), name)\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "_utc_offset", "offset", "name", "return", "timezone", "timedelta", "seconds", "offset", "name"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::DT.__new__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __new__(cls, val):\n        \"\"\"Create an instance of DT object.\n\n        Raise an exception if the string cannot be parsed or the argument\n        is otherwise incompatible.\n\n        :param val: val must be a string conformant to the DT definition\n        in the DICOM Standard PS 3.5-2011\n        \"\"\"\n        if isinstance(val, (str, compat.string_types)):\n            match = DT._regex_dt.match(val)\n            if match and len(val) <= 26:\n                dt_match = match.group(2)\n                year = int(dt_match[0:4])\n                if len(dt_match) < 6:\n                    month = 1\n                else:\n                    month = int(dt_match[4:6])\n                if len(dt_match) < 8:\n                    day = 1\n                else:\n                    day = int(dt_match[6:8])\n                if len(dt_match) < 10:\n                    hour = 0\n                else:\n                    hour = int(dt_match[8:10])\n                if len(dt_match) < 12:\n                    minute = 0\n                else:\n                    minute = int(dt_match[10:12])\n                if len(dt_match) < 14:\n                    second = 0\n                    microsecond = 0\n                else:\n                    second = int(dt_match[12:14])\n                    ms_match = match.group(4)\n                    if ms_match:\n                        microsecond = int(ms_match.rstrip().ljust(6, '0'))\n                    else:\n                        microsecond = 0\n                tz_match = match.group(5)\n                if tz_match:\n                    offset1 = int(tz_match[1:3]) * 60\n                    offset2 = int(tz_match[3:5])\n                    offset = (offset1 + offset2) * 60\n                    if tz_match[0] == '-':\n                        offset = -offset\n                    tzinfo = cls._utc_offset(offset, tz_match)\n                else:\n                    tzinfo = None\n                val = super(DT,\n                            cls).__new__(cls, year, month, day, hour, minute,\n                                         second, microsecond, tzinfo)\n            else:\n                try:\n                    val = super(DT, cls).__new__(cls, val)\n                except TypeError:\n                    raise ValueError(\"Cannot convert to datetime: '%s'\" %\n                                     (val))\n        elif isinstance(val, datetime):\n            val = super(DT, cls).__new__(cls, val.year, val.month, val.day,\n                                         val.hour, val.minute, val.second,\n                                         val.microsecond, val.tzinfo)\n        else:\n            val = super(DT, cls).__new__(cls, val)\n        return val\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__new__", "cls", "val", "create", "an", "instance", "of", "dt", "object", "raise", "an", "exception", "if", "the", "string", "cannot", "be", "parsed", "or", "the", "argument", "is", "otherwise", "incompatible", "param", "val", "val", "must", "be", "a", "string", "conformant", "to", "the", "dt", "definition", "in", "the", "dicom", "standard", "ps", "3", "5", "2011", "if", "isinstance", "val", "str", "compat", "string_types", "match", "dt", "_regex_dt", "match", "val", "if", "match", "and", "len", "val", "26", "dt_match", "match", "group", "2", "year", "int", "dt_match", "0", "4", "if", "len", "dt_match", "6", "month", "1", "else", "month", "int", "dt_match", "4", "6", "if", "len", "dt_match", "8", "day", "1", "else", "day", "int", "dt_match", "6", "8", "if", "len", "dt_match", "10", "hour", "0", "else", "hour", "int", "dt_match", "8", "10", "if", "len", "dt_match", "12", "minute", "0", "else", "minute", "int", "dt_match", "10", "12", "if", "len", "dt_match", "14", "second", "0", "microsecond", "0", "else", "second", "int", "dt_match", "12", "14", "ms_match", "match", "group", "4", "if", "ms_match", "microsecond", "int", "ms_match", "rstrip", "ljust", "6", "0", "else", "microsecond", "0", "tz_match", "match", "group", "5", "if", "tz_match", "offset1", "int", "tz_match", "1", "3", "60", "offset2", "int", "tz_match", "3", "5", "offset", "offset1", "offset2", "60", "if", "tz_match", "0", "offset", "offset", "tzinfo", "cls", "_utc_offset", "offset", "tz_match", "else", "tzinfo", "none", "val", "super", "dt", "cls", "__new__", "cls", "year", "month", "day", "hour", "minute", "second", "microsecond", "tzinfo", "else", "try", "val", "super", "dt", "cls", "__new__", "cls", "val", "except", "typeerror", "raise", "valueerror", "cannot", "convert", "to", "datetime", "s", "val", "elif", "isinstance", "val", "datetime", "val", "super", "dt", "cls", "__new__", "cls", "val", "year", "val", "month", "val", "day", "val", "hour", "val", "minute", "val", "second", "val", "microsecond", "val", "tzinfo", "else", "val", "super", "dt", "cls", "__new__", "cls", "val", "return", "val"], "doc_len": 256}
{"doc_id": "pydicom/valuerep.py::DT.__init__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __init__(self, val):\n        if isinstance(val, (str, compat.string_types)):\n            self.original_string = val\n        elif isinstance(val, DT) and hasattr(val, 'original_string'):\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__init__", "self", "val", "if", "isinstance", "val", "str", "compat", "string_types", "self", "original_string", "val", "elif", "isinstance", "val", "dt", "and", "hasattr", "val", "original_string", "self", "original_string", "val", "original_string"], "doc_len": 29}
{"doc_id": "pydicom/valuerep.py::DT.__str__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __str__(self):\n        if hasattr(self, 'original_string'):\n            return self.original_string\n        else:\n            return super(DT, self).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__str__", "self", "if", "hasattr", "self", "original_string", "return", "self", "original_string", "else", "return", "super", "dt", "self", "__str__"], "doc_len": 20}
{"doc_id": "pydicom/valuerep.py::DT.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "DT", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: DT\n    def __repr__(self):\n        return \"\\\"\" + str(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "dt", "def", "__repr__", "self", "return", "str", "self"], "doc_len": 10}
{"doc_id": "pydicom/valuerep.py::TM.__getstate__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__getstate__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __getstate__(self):\n        return dict((slot, getattr(self, slot)) for slot in self.__slots__\n                    if hasattr(self, slot))\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__getstate__", "self", "return", "dict", "slot", "getattr", "self", "slot", "for", "slot", "in", "self", "__slots__", "if", "hasattr", "self", "slot"], "doc_len": 22}
{"doc_id": "pydicom/valuerep.py::TM.__setstate__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__setstate__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __setstate__(self, state):\n        for slot, value in state.items():\n            setattr(self, slot, value)\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__setstate__", "self", "state", "for", "slot", "value", "in", "state", "items", "setattr", "self", "slot", "value"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::TM.__reduce__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__reduce__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __reduce__(self):\n        return super(TM, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__reduce__", "self", "return", "super", "tm", "self", "__reduce__", "self", "__getstate__"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::TM.__reduce_ex__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__reduce_ex__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __reduce_ex__(self, protocol):\n        return super(TM, self).__reduce__() + (self.__getstate__(),)\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__reduce_ex__", "self", "protocol", "return", "super", "tm", "self", "__reduce__", "self", "__getstate__"], "doc_len": 15}
{"doc_id": "pydicom/valuerep.py::TM.__new__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __new__(cls, val):\n        \"\"\"Create an instance of TM object from a string.\n\n        Raise an exception if the string cannot be parsed or the argument\n        is otherwise incompatible.\n\n        :param val: val must be a string conformant to the TM definition\n        in the DICOM Standard PS 3.5-2011\n        \"\"\"\n        if isinstance(val, (str, compat.string_types)):\n            match = TM._regex_tm.match(val)\n            if match and len(val) <= 16:\n                tm_match = match.group(1)\n                hour = int(tm_match[0:2])\n                if len(tm_match) < 4:\n                    minute = 0\n                else:\n                    minute = int(tm_match[2:4])\n                if len(tm_match) < 6:\n                    second = 0\n                    microsecond = 0\n                else:\n                    second = int(tm_match[4:6])\n                    ms_match = match.group(3)\n                    if ms_match:\n                        microsecond = int(ms_match.rstrip().ljust(6, '0'))\n                    else:\n                        microsecond = 0\n                val = super(TM, cls).__new__(cls, hour, minute, second,\n                                             microsecond)\n            elif val == '':\n                val = None  # empty time\n            else:\n                try:\n                    val = super(TM, cls).__new__(cls, val)\n                except TypeError:\n                    raise ValueError(\"Cannot convert to datetime: '%s\" % (val))\n        elif isinstance(val, time):\n            val = super(TM, cls).__new__(cls, val.hour, val.minute, val.second,\n                                         val.microsecond)\n        else:\n            val = super(TM, cls).__new__(cls, val)\n        return val\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__new__", "cls", "val", "create", "an", "instance", "of", "tm", "object", "from", "a", "string", "raise", "an", "exception", "if", "the", "string", "cannot", "be", "parsed", "or", "the", "argument", "is", "otherwise", "incompatible", "param", "val", "val", "must", "be", "a", "string", "conformant", "to", "the", "tm", "definition", "in", "the", "dicom", "standard", "ps", "3", "5", "2011", "if", "isinstance", "val", "str", "compat", "string_types", "match", "tm", "_regex_tm", "match", "val", "if", "match", "and", "len", "val", "16", "tm_match", "match", "group", "1", "hour", "int", "tm_match", "0", "2", "if", "len", "tm_match", "4", "minute", "0", "else", "minute", "int", "tm_match", "2", "4", "if", "len", "tm_match", "6", "second", "0", "microsecond", "0", "else", "second", "int", "tm_match", "4", "6", "ms_match", "match", "group", "3", "if", "ms_match", "microsecond", "int", "ms_match", "rstrip", "ljust", "6", "0", "else", "microsecond", "0", "val", "super", "tm", "cls", "__new__", "cls", "hour", "minute", "second", "microsecond", "elif", "val", "val", "none", "empty", "time", "else", "try", "val", "super", "tm", "cls", "__new__", "cls", "val", "except", "typeerror", "raise", "valueerror", "cannot", "convert", "to", "datetime", "s", "val", "elif", "isinstance", "val", "time", "val", "super", "tm", "cls", "__new__", "cls", "val", "hour", "val", "minute", "val", "second", "val", "microsecond", "else", "val", "super", "tm", "cls", "__new__", "cls", "val", "return", "val"], "doc_len": 183}
{"doc_id": "pydicom/valuerep.py::TM.__init__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __init__(self, val):\n        if isinstance(val, (str, compat.string_types)):\n            self.original_string = val\n        elif isinstance(val, TM) and hasattr(val, 'original_string'):\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__init__", "self", "val", "if", "isinstance", "val", "str", "compat", "string_types", "self", "original_string", "val", "elif", "isinstance", "val", "tm", "and", "hasattr", "val", "original_string", "self", "original_string", "val", "original_string"], "doc_len": 29}
{"doc_id": "pydicom/valuerep.py::TM.__str__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __str__(self):\n        if hasattr(self, 'original_string'):\n            return self.original_string\n        else:\n            return super(TM, self).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__str__", "self", "if", "hasattr", "self", "original_string", "return", "self", "original_string", "else", "return", "super", "tm", "self", "__str__"], "doc_len": 20}
{"doc_id": "pydicom/valuerep.py::TM.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "TM", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: TM\n    def __repr__(self):\n        return \"\\\"\" + str(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "tm", "def", "__repr__", "self", "return", "str", "self"], "doc_len": 10}
{"doc_id": "pydicom/valuerep.py::DSfloat.__getstate__", "file_path": "pydicom/valuerep.py", "class_name": "DSfloat", "func_name": "__getstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DSfloat\n    def __getstate__(self):\n        return dict((slot, getattr(self, slot)) for slot in self.__slots__\n                    if hasattr(self, slot))\n", "tokens": ["pydicom", "valuerep", "py", "dsfloat", "def", "__getstate__", "self", "return", "dict", "slot", "getattr", "self", "slot", "for", "slot", "in", "self", "__slots__", "if", "hasattr", "self", "slot"], "doc_len": 22}
{"doc_id": "pydicom/valuerep.py::DSfloat.__setstate__", "file_path": "pydicom/valuerep.py", "class_name": "DSfloat", "func_name": "__setstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DSfloat\n    def __setstate__(self, state):\n        for slot, value in state.items():\n            setattr(self, slot, value)\n", "tokens": ["pydicom", "valuerep", "py", "dsfloat", "def", "__setstate__", "self", "state", "for", "slot", "value", "in", "state", "items", "setattr", "self", "slot", "value"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::DSfloat.__init__", "file_path": "pydicom/valuerep.py", "class_name": "DSfloat", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: DSfloat\n    def __init__(self, val):\n        \"\"\"Store the original string if one given, for exact write-out of same\n        value later.\n        \"\"\"\n        # ... also if user changes a data element value, then will get\n        # a different object, because float is immutable.\n\n        has_attribute = hasattr(val, 'original_string')\n        if isinstance(val, (str, compat.text_type)):\n            self.original_string = val\n        elif isinstance(val, (DSfloat, DSdecimal)) and has_attribute:\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "dsfloat", "def", "__init__", "self", "val", "store", "the", "original", "string", "if", "one", "given", "for", "exact", "write", "out", "of", "same", "value", "later", "also", "if", "user", "changes", "a", "data", "element", "value", "then", "will", "get", "a", "different", "object", "because", "float", "is", "immutable", "has_attribute", "hasattr", "val", "original_string", "if", "isinstance", "val", "str", "compat", "text_type", "self", "original_string", "val", "elif", "isinstance", "val", "dsfloat", "dsdecimal", "and", "has_attribute", "self", "original_string", "val", "original_string"], "doc_len": 65}
{"doc_id": "pydicom/valuerep.py::DSfloat.__str__", "file_path": "pydicom/valuerep.py", "class_name": "DSfloat", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: DSfloat\n    def __str__(self):\n        if hasattr(self, 'original_string'):\n            return self.original_string\n        else:\n            return super(DSfloat, self).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "dsfloat", "def", "__str__", "self", "if", "hasattr", "self", "original_string", "return", "self", "original_string", "else", "return", "super", "dsfloat", "self", "__str__"], "doc_len": 20}
{"doc_id": "pydicom/valuerep.py::DSfloat.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "DSfloat", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: DSfloat\n    def __repr__(self):\n        return \"\\\"\" + str(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "dsfloat", "def", "__repr__", "self", "return", "str", "self"], "doc_len": 10}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__getstate__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__getstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __getstate__(self):\n        return dict((slot, getattr(self, slot)) for slot in self.__slots__\n                    if hasattr(self, slot))\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__getstate__", "self", "return", "dict", "slot", "getattr", "self", "slot", "for", "slot", "in", "self", "__slots__", "if", "hasattr", "self", "slot"], "doc_len": 22}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__setstate__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__setstate__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __setstate__(self, state):\n        for slot, value in state.items():\n            setattr(self, slot, value)\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__setstate__", "self", "state", "for", "slot", "value", "in", "state", "items", "setattr", "self", "slot", "value"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__new__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __new__(cls, val):\n        \"\"\"Create an instance of DS object, or return a blank string if one is\n        passed in, e.g. from a type 2 DICOM blank value.\n\n        :param val: val must be a string or a number type which can be\n                   converted to a decimal\n        \"\"\"\n        # Store this value here so that if the input string is actually a valid\n        # string but decimal.Decimal transforms it to an invalid string it will\n        # still be initialized properly\n        enforce_length = config.enforce_valid_values\n        # DICOM allows spaces around the string,\n        # but python doesn't, so clean it\n        if isinstance(val, (str, compat.text_type)):\n            val = val.strip()\n            # If the input string is actually invalid that we relax the valid\n            # value constraint for this particular instance\n            if len(val) <= 16:\n                enforce_length = False\n        if val == '':\n            return val\n        if isinstance(val, float) and not config.allow_DS_float:\n            msg = (\"DS cannot be instantiated with a float value, \"\n                   \"unless config.allow_DS_float is set to True. \"\n                   \"It is recommended to convert to a string instead, \"\n                   \"with the desired number of digits, or use \"\n                   \"Decimal.quantize and pass a Decimal instance.\")\n            raise TypeError(msg)\n        if not isinstance(val, Decimal):\n            val = super(DSdecimal, cls).__new__(cls, val)\n        if len(str(val)) > 16 and enforce_length:\n            msg = (\"DS value representation must be <= 16 \"\n                   \"characters by DICOM standard. Initialize with \"\n                   \"a smaller string, or set config.enforce_valid_values \"\n                   \"to False to override, or use Decimal.quantize() and \"\n                   \"initialize with a Decimal instance.\")\n            raise OverflowError(msg)\n        return val\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__new__", "cls", "val", "create", "an", "instance", "of", "ds", "object", "or", "return", "a", "blank", "string", "if", "one", "is", "passed", "in", "e", "g", "from", "a", "type", "2", "dicom", "blank", "value", "param", "val", "val", "must", "be", "a", "string", "or", "a", "number", "type", "which", "can", "be", "converted", "to", "a", "decimal", "store", "this", "value", "here", "so", "that", "if", "the", "input", "string", "is", "actually", "a", "valid", "string", "but", "decimal", "decimal", "transforms", "it", "to", "an", "invalid", "string", "it", "will", "still", "be", "initialized", "properly", "enforce_length", "config", "enforce_valid_values", "dicom", "allows", "spaces", "around", "the", "string", "but", "python", "doesn", "t", "so", "clean", "it", "if", "isinstance", "val", "str", "compat", "text_type", "val", "val", "strip", "if", "the", "input", "string", "is", "actually", "invalid", "that", "we", "relax", "the", "valid", "value", "constraint", "for", "this", "particular", "instance", "if", "len", "val", "16", "enforce_length", "false", "if", "val", "return", "val", "if", "isinstance", "val", "float", "and", "not", "config", "allow_ds_float", "msg", "ds", "cannot", "be", "instantiated", "with", "a", "float", "value", "unless", "config", "allow_ds_float", "is", "set", "to", "true", "it", "is", "recommended", "to", "convert", "to", "a", "string", "instead", "with", "the", "desired", "number", "of", "digits", "or", "use", "decimal", "quantize", "and", "pass", "a", "decimal", "instance", "raise", "typeerror", "msg", "if", "not", "isinstance", "val", "decimal", "val", "super", "dsdecimal", "cls", "__new__", "cls", "val", "if", "len", "str", "val", "16", "and", "enforce_length", "msg", "ds", "value", "representation", "must", "be", "16", "characters", "by", "dicom", "standard", "initialize", "with", "a", "smaller", "string", "or", "set", "config", "enforce_valid_values", "to", "false", "to", "override", "or", "use", "decimal", "quantize", "and", "initialize", "with", "a", "decimal", "instance", "raise", "overflowerror", "msg", "return", "val"], "doc_len": 243}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__init__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __init__(self, val):\n        \"\"\"Store the original string if one given, for exact write-out of same\n        value later. E.g. if set '1.23e2', Decimal would write '123', but DS\n        will use the original\n        \"\"\"\n        # ... also if user changes a data element value, then will get\n        # a different Decimal, as Decimal is immutable.\n        if isinstance(val, (str, compat.text_type)):\n            self.original_string = val\n        elif isinstance(val, (DSfloat, DSdecimal)) and hasattr(val, 'original_string'):  # noqa\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__init__", "self", "val", "store", "the", "original", "string", "if", "one", "given", "for", "exact", "write", "out", "of", "same", "value", "later", "e", "g", "if", "set", "1", "23e2", "decimal", "would", "write", "123", "but", "ds", "will", "use", "the", "original", "also", "if", "user", "changes", "a", "data", "element", "value", "then", "will", "get", "a", "different", "decimal", "as", "decimal", "is", "immutable", "if", "isinstance", "val", "str", "compat", "text_type", "self", "original_string", "val", "elif", "isinstance", "val", "dsfloat", "dsdecimal", "and", "hasattr", "val", "original_string", "noqa", "self", "original_string", "val", "original_string"], "doc_len": 80}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__str__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __str__(self):\n        if hasattr(self, 'original_string') and len(self.original_string) <= 16:  # noqa\n            return self.original_string\n        else:\n            return super(DSdecimal, self).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__str__", "self", "if", "hasattr", "self", "original_string", "and", "len", "self", "original_string", "16", "noqa", "return", "self", "original_string", "else", "return", "super", "dsdecimal", "self", "__str__"], "doc_len": 26}
{"doc_id": "pydicom/valuerep.py::DSdecimal.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "DSdecimal", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: DSdecimal\n    def __repr__(self):\n        return \"\\\"\" + str(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "dsdecimal", "def", "__repr__", "self", "return", "str", "self"], "doc_len": 10}
{"doc_id": "pydicom/valuerep.py::DS", "file_path": "pydicom/valuerep.py", "class_name": null, "func_name": "DS", "text": "文件路径: pydicom/valuerep.py\ndef DS(val):\n    \"\"\"Factory function for creating DS class instances.\n    Checks for blank string; if so, return that.\n    Else calls DSfloat or DSdecimal to create the class\n    instance. This avoids overriding __new__ in DSfloat\n    (which carries a time penalty for large arrays of DS).\n    Similarly the string clean and check can be avoided\n    and DSfloat called directly if a string has already\n    been processed.\n    \"\"\"\n    if isinstance(val, (str, compat.text_type)):\n        val = val.strip()\n    if val == '' or val is None:\n        return ''\n    return DSclass(val)\n", "tokens": ["pydicom", "valuerep", "py", "def", "ds", "val", "factory", "function", "for", "creating", "ds", "class", "instances", "checks", "for", "blank", "string", "if", "so", "return", "that", "else", "calls", "dsfloat", "or", "dsdecimal", "to", "create", "the", "class", "instance", "this", "avoids", "overriding", "__new__", "in", "dsfloat", "which", "carries", "a", "time", "penalty", "for", "large", "arrays", "of", "ds", "similarly", "the", "string", "clean", "and", "check", "can", "be", "avoided", "and", "dsfloat", "called", "directly", "if", "a", "string", "has", "already", "been", "processed", "if", "isinstance", "val", "str", "compat", "text_type", "val", "val", "strip", "if", "val", "or", "val", "is", "none", "return", "return", "dsclass", "val"], "doc_len": 86}
{"doc_id": "pydicom/valuerep.py::IS.__new__", "file_path": "pydicom/valuerep.py", "class_name": "IS", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: IS\n    def __new__(cls, val):\n        \"\"\"Create instance if new integer string\"\"\"\n        if val is None:\n            return ''\n        if isinstance(val, (str, compat.text_type)) and val.strip() == '':\n            return ''\n        # Overflow error in Python 2 for integers too large\n        # while calling super(IS). Fall back on the regular int\n        # casting that will automatically convert the val to long\n        # if needed.\n        try:\n            newval = super(IS, cls).__new__(cls, val)\n        except OverflowError:\n            newval = int(val)\n        # check if a float or Decimal passed in, then could have lost info,\n        # and will raise error. E.g. IS(Decimal('1')) is ok, but not IS(1.23)\n        if isinstance(val, (float, Decimal)) and newval != val:\n            raise TypeError(\"Could not convert value to integer without loss\")\n        # Checks in case underlying int is >32 bits, DICOM does not allow this\n        check_newval = (newval < -2 ** 31 or newval >= 2 ** 31)\n        if check_newval and config.enforce_valid_values:\n            dcm_limit = \"-2**31 to (2**31 - 1) for IS\"\n            message = \"Value exceeds DICOM limits of %s\" % (dcm_limit)\n            raise OverflowError(message)\n        return newval\n", "tokens": ["pydicom", "valuerep", "py", "is", "def", "__new__", "cls", "val", "create", "instance", "if", "new", "integer", "string", "if", "val", "is", "none", "return", "if", "isinstance", "val", "str", "compat", "text_type", "and", "val", "strip", "return", "overflow", "error", "in", "python", "2", "for", "integers", "too", "large", "while", "calling", "super", "is", "fall", "back", "on", "the", "regular", "int", "casting", "that", "will", "automatically", "convert", "the", "val", "to", "long", "if", "needed", "try", "newval", "super", "is", "cls", "__new__", "cls", "val", "except", "overflowerror", "newval", "int", "val", "check", "if", "a", "float", "or", "decimal", "passed", "in", "then", "could", "have", "lost", "info", "and", "will", "raise", "error", "e", "g", "is", "decimal", "1", "is", "ok", "but", "not", "is", "1", "23", "if", "isinstance", "val", "float", "decimal", "and", "newval", "val", "raise", "typeerror", "could", "not", "convert", "value", "to", "integer", "without", "loss", "checks", "in", "case", "underlying", "int", "is", "32", "bits", "dicom", "does", "not", "allow", "this", "check_newval", "newval", "2", "31", "or", "newval", "2", "31", "if", "check_newval", "and", "config", "enforce_valid_values", "dcm_limit", "2", "31", "to", "2", "31", "1", "for", "is", "message", "value", "exceeds", "dicom", "limits", "of", "s", "dcm_limit", "raise", "overflowerror", "message", "return", "newval"], "doc_len": 167}
{"doc_id": "pydicom/valuerep.py::IS.__init__", "file_path": "pydicom/valuerep.py", "class_name": "IS", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: IS\n    def __init__(self, val):\n        # If a string passed, then store it\n        if isinstance(val, (str, compat.text_type)):\n            self.original_string = val\n        elif isinstance(val, IS) and hasattr(val, 'original_string'):\n            self.original_string = val.original_string\n", "tokens": ["pydicom", "valuerep", "py", "is", "def", "__init__", "self", "val", "if", "a", "string", "passed", "then", "store", "it", "if", "isinstance", "val", "str", "compat", "text_type", "self", "original_string", "val", "elif", "isinstance", "val", "is", "and", "hasattr", "val", "original_string", "self", "original_string", "val", "original_string"], "doc_len": 36}
{"doc_id": "pydicom/valuerep.py::IS.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "IS", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: IS\n    def __repr__(self):\n        if hasattr(self, 'original_string'):\n            return \"\\\"\" + self.original_string + \"\\\"\"\n        else:\n            return \"\\\"\" + int.__str__(self) + \"\\\"\"\n", "tokens": ["pydicom", "valuerep", "py", "is", "def", "__repr__", "self", "if", "hasattr", "self", "original_string", "return", "self", "original_string", "else", "return", "int", "__str__", "self"], "doc_len": 19}
{"doc_id": "pydicom/valuerep.py::MultiString", "file_path": "pydicom/valuerep.py", "class_name": null, "func_name": "MultiString", "text": "文件路径: pydicom/valuerep.py\ndef MultiString(val, valtype=str):\n    \"\"\"Split a bytestring by delimiters if there are any\n\n    val -- DICOM bytestring to split up\n    valtype -- default str, but can be e.g.\n    UID to overwrite to a specific type\n    \"\"\"\n    # Remove trailing blank used to pad to even length\n    # 2005.05.25: also check for trailing 0, error made\n    # in PET files we are converting\n\n    if val and (val.endswith(' ') or val.endswith('\\x00')):\n        val = val[:-1]\n    splitup = val.split(\"\\\\\")\n\n    if len(splitup) == 1:\n        val = splitup[0]\n        return valtype(val) if val else val\n    else:\n        return MultiValue(valtype, splitup)\n", "tokens": ["pydicom", "valuerep", "py", "def", "multistring", "val", "valtype", "str", "split", "a", "bytestring", "by", "delimiters", "if", "there", "are", "any", "val", "dicom", "bytestring", "to", "split", "up", "valtype", "default", "str", "but", "can", "be", "e", "g", "uid", "to", "overwrite", "to", "a", "specific", "type", "remove", "trailing", "blank", "used", "to", "pad", "to", "even", "length", "2005", "05", "25", "also", "check", "for", "trailing", "0", "error", "made", "in", "pet", "files", "we", "are", "converting", "if", "val", "and", "val", "endswith", "or", "val", "endswith", "x00", "val", "val", "1", "splitup", "val", "split", "if", "len", "splitup", "1", "val", "splitup", "0", "return", "valtype", "val", "if", "val", "else", "val", "else", "return", "multivalue", "valtype", "splitup"], "doc_len": 97}
{"doc_id": "pydicom/valuerep.py::_verify_encodings", "file_path": "pydicom/valuerep.py", "class_name": null, "func_name": "_verify_encodings", "text": "文件路径: pydicom/valuerep.py\ndef _verify_encodings(encodings):\n    \"\"\"Checks the encoding to ensure proper format\"\"\"\n    if encodings is not None:\n        if not isinstance(encodings, (list, tuple)):\n            return encodings,\n        return tuple(encodings)\n    return encodings\n", "tokens": ["pydicom", "valuerep", "py", "def", "_verify_encodings", "encodings", "checks", "the", "encoding", "to", "ensure", "proper", "format", "if", "encodings", "is", "not", "none", "if", "not", "isinstance", "encodings", "list", "tuple", "return", "encodings", "return", "tuple", "encodings", "return", "encodings"], "doc_len": 31}
{"doc_id": "pydicom/valuerep.py::_decode_personname", "file_path": "pydicom/valuerep.py", "class_name": null, "func_name": "_decode_personname", "text": "文件路径: pydicom/valuerep.py\ndef _decode_personname(components, encodings):\n    \"\"\"Return a list of decoded person name components.\n\n    Parameters\n    ----------\n    components : list of byte string\n        The list of the up to three encoded person name components\n    encodings : list of str\n        The Python encodings uses to decode `components`.\n\n    Returns\n    -------\n    text type\n        The unicode string representing the person name.\n        If the decoding of some component parts is not possible using the\n        given encodings, they are decoded with the first encoding using\n        replacement characters for bytes that cannot be decoded.\n    \"\"\"\n    from pydicom.charset import decode_string\n\n    if isinstance(components[0], compat.text_type):\n        comps = components\n    else:\n        comps = [decode_string(comp, encodings, PN_DELIMS)\n                 for comp in components]\n    # Remove empty elements from the end to avoid trailing '='\n    while len(comps) and not comps[-1]:\n        comps.pop()\n    return tuple(comps)\n", "tokens": ["pydicom", "valuerep", "py", "def", "_decode_personname", "components", "encodings", "return", "a", "list", "of", "decoded", "person", "name", "components", "parameters", "components", "list", "of", "byte", "string", "the", "list", "of", "the", "up", "to", "three", "encoded", "person", "name", "components", "encodings", "list", "of", "str", "the", "python", "encodings", "uses", "to", "decode", "components", "returns", "text", "type", "the", "unicode", "string", "representing", "the", "person", "name", "if", "the", "decoding", "of", "some", "component", "parts", "is", "not", "possible", "using", "the", "given", "encodings", "they", "are", "decoded", "with", "the", "first", "encoding", "using", "replacement", "characters", "for", "bytes", "that", "cannot", "be", "decoded", "from", "pydicom", "charset", "import", "decode_string", "if", "isinstance", "components", "0", "compat", "text_type", "comps", "components", "else", "comps", "decode_string", "comp", "encodings", "pn_delims", "for", "comp", "in", "components", "remove", "empty", "elements", "from", "the", "end", "to", "avoid", "trailing", "while", "len", "comps", "and", "not", "comps", "1", "comps", "pop", "return", "tuple", "comps"], "doc_len": 127}
{"doc_id": "pydicom/valuerep.py::_encode_personname", "file_path": "pydicom/valuerep.py", "class_name": null, "func_name": "_encode_personname", "text": "文件路径: pydicom/valuerep.py\ndef _encode_personname(components, encodings):\n    \"\"\"Encode a list of text string person name components.\n\n    Parameters\n    ----------\n    components : list of text type\n        The list of the up to three unicode person name components\n    encodings : list of str\n        The Python encodings uses to encode `components`.\n\n    Returns\n    -------\n    byte string\n        The byte string that can be written as a PN DICOM tag value.\n        If the encoding of some component parts is not possible using the\n        given encodings, they are encoded with the first encoding using\n        replacement bytes for characters that cannot be encoded.\n    \"\"\"\n    from pydicom.charset import encode_string\n\n    encoded_comps = []\n    for comp in components:\n        groups = [encode_string(group, encodings)\n                  for group in comp.split('^')]\n        encoded_comps.append(b'^'.join(groups))\n\n    # Remove empty elements from the end\n    while len(encoded_comps) and not encoded_comps[-1]:\n        encoded_comps.pop()\n    return b'='.join(encoded_comps)\n", "tokens": ["pydicom", "valuerep", "py", "def", "_encode_personname", "components", "encodings", "encode", "a", "list", "of", "text", "string", "person", "name", "components", "parameters", "components", "list", "of", "text", "type", "the", "list", "of", "the", "up", "to", "three", "unicode", "person", "name", "components", "encodings", "list", "of", "str", "the", "python", "encodings", "uses", "to", "encode", "components", "returns", "byte", "string", "the", "byte", "string", "that", "can", "be", "written", "as", "a", "pn", "dicom", "tag", "value", "if", "the", "encoding", "of", "some", "component", "parts", "is", "not", "possible", "using", "the", "given", "encodings", "they", "are", "encoded", "with", "the", "first", "encoding", "using", "replacement", "bytes", "for", "characters", "that", "cannot", "be", "encoded", "from", "pydicom", "charset", "import", "encode_string", "encoded_comps", "for", "comp", "in", "components", "groups", "encode_string", "group", "encodings", "for", "group", "in", "comp", "split", "encoded_comps", "append", "b", "join", "groups", "remove", "empty", "elements", "from", "the", "end", "while", "len", "encoded_comps", "and", "not", "encoded_comps", "1", "encoded_comps", "pop", "return", "b", "join", "encoded_comps"], "doc_len": 133}
{"doc_id": "pydicom/valuerep.py::PersonName3.__init__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __init__(self, val, encodings=None, original_string=None):\n        if isinstance(val, PersonName3):\n            encodings = val.encodings\n            self.original_string = val.original_string\n            self._components = tuple(str(val).split('='))\n        elif isinstance(val, bytes):\n            # this is the raw byte string - decode it on demand\n            self.original_string = val\n            self._components = None\n        else:\n            # handle None `val` as empty string\n            val = val or ''\n\n            # this is the decoded string - save the original string if\n            # available for easier writing back\n            self.original_string = original_string\n            self._components = tuple(val.split('='))\n\n        # if the encoding is not given, leave it as undefined (None)\n        self.encodings = _verify_encodings(encodings)\n        self._dict = {}\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__init__", "self", "val", "encodings", "none", "original_string", "none", "if", "isinstance", "val", "personname3", "encodings", "val", "encodings", "self", "original_string", "val", "original_string", "self", "_components", "tuple", "str", "val", "split", "elif", "isinstance", "val", "bytes", "this", "is", "the", "raw", "byte", "string", "decode", "it", "on", "demand", "self", "original_string", "val", "self", "_components", "none", "else", "handle", "none", "val", "as", "empty", "string", "val", "val", "or", "this", "is", "the", "decoded", "string", "save", "the", "original", "string", "if", "available", "for", "easier", "writing", "back", "self", "original_string", "original_string", "self", "_components", "tuple", "val", "split", "if", "the", "encoding", "is", "not", "given", "leave", "it", "as", "undefined", "none", "self", "encodings", "_verify_encodings", "encodings", "self", "_dict"], "doc_len": 99}
{"doc_id": "pydicom/valuerep.py::PersonName3._create_dict", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "_create_dict", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def _create_dict(self):\n        \"\"\"Creates a dictionary of person name group and component names.\n        Used exclusively for `formatted` for backwards compatibility.\"\"\"\n        if not self._dict:\n            for name in ('family_name', 'given_name', 'middle_name',\n                         'name_prefix', 'name_suffix',\n                         'ideographic', 'phonetic'):\n                self._dict[name] = getattr(self, name, '')\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "_create_dict", "self", "creates", "a", "dictionary", "of", "person", "name", "group", "and", "component", "names", "used", "exclusively", "for", "formatted", "for", "backwards", "compatibility", "if", "not", "self", "_dict", "for", "name", "in", "family_name", "given_name", "middle_name", "name_prefix", "name_suffix", "ideographic", "phonetic", "self", "_dict", "name", "getattr", "self", "name"], "doc_len": 44}
{"doc_id": "pydicom/valuerep.py::PersonName3.components", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "components", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def components(self):\n        \"\"\"Return the up to three decoded person name components, representing\n        the alphabetic, ideographic and phonetic representations as a list\n        of unicode strings.\n        \"\"\"\n        if self._components is None:\n            groups = self.original_string.split(b'=')\n            encodings = self.encodings or [default_encoding]\n            self._components = _decode_personname(groups, encodings)\n\n        return self._components\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "components", "self", "return", "the", "up", "to", "three", "decoded", "person", "name", "components", "representing", "the", "alphabetic", "ideographic", "and", "phonetic", "representations", "as", "a", "list", "of", "unicode", "strings", "if", "self", "_components", "is", "none", "groups", "self", "original_string", "split", "b", "encodings", "self", "encodings", "or", "default_encoding", "self", "_components", "_decode_personname", "groups", "encodings", "return", "self", "_components"], "doc_len": 52}
{"doc_id": "pydicom/valuerep.py::PersonName3._name_part", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "_name_part", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def _name_part(self, i):\n        try:\n            return self.components[0].split('^')[i]\n        except IndexError:\n            return ''\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "_name_part", "self", "i", "try", "return", "self", "components", "0", "split", "i", "except", "indexerror", "return"], "doc_len": 18}
{"doc_id": "pydicom/valuerep.py::PersonName3.family_name", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "family_name", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def family_name(self):\n        \"\"\"Return the first (family name) group of the alphabetic person name\n        representation as a unicode string\"\"\"\n        return self._name_part(0)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "family_name", "self", "return", "the", "first", "family", "name", "group", "of", "the", "alphabetic", "person", "name", "representation", "as", "a", "unicode", "string", "return", "self", "_name_part", "0"], "doc_len": 27}
{"doc_id": "pydicom/valuerep.py::PersonName3.given_name", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "given_name", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def given_name(self):\n        \"\"\"Return the second (given name) group of the alphabetic person name\n        representation as a unicode string\"\"\"\n        return self._name_part(1)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "given_name", "self", "return", "the", "second", "given", "name", "group", "of", "the", "alphabetic", "person", "name", "representation", "as", "a", "unicode", "string", "return", "self", "_name_part", "1"], "doc_len": 27}
{"doc_id": "pydicom/valuerep.py::PersonName3.middle_name", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "middle_name", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def middle_name(self):\n        \"\"\"Return the third (middle name) group of the alphabetic person name\n        representation as a unicode string\"\"\"\n        return self._name_part(2)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "middle_name", "self", "return", "the", "third", "middle", "name", "group", "of", "the", "alphabetic", "person", "name", "representation", "as", "a", "unicode", "string", "return", "self", "_name_part", "2"], "doc_len": 27}
{"doc_id": "pydicom/valuerep.py::PersonName3.name_prefix", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "name_prefix", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def name_prefix(self):\n        \"\"\"Return the fourth (name prefix) group of the alphabetic person name\n        representation as a unicode string\"\"\"\n        return self._name_part(3)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "name_prefix", "self", "return", "the", "fourth", "name", "prefix", "group", "of", "the", "alphabetic", "person", "name", "representation", "as", "a", "unicode", "string", "return", "self", "_name_part", "3"], "doc_len": 27}
{"doc_id": "pydicom/valuerep.py::PersonName3.name_suffix", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "name_suffix", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def name_suffix(self):\n        \"\"\"Return the fifth (name suffix) group of the alphabetic person name\n        representation as a unicode string\"\"\"\n        return self._name_part(4)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "name_suffix", "self", "return", "the", "fifth", "name", "suffix", "group", "of", "the", "alphabetic", "person", "name", "representation", "as", "a", "unicode", "string", "return", "self", "_name_part", "4"], "doc_len": 27}
{"doc_id": "pydicom/valuerep.py::PersonName3.ideographic", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "ideographic", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def ideographic(self):\n        \"\"\"Return the second (ideographic) person name component as a\n        unicode string\"\"\"\n        try:\n            return self.components[1]\n        except IndexError:\n            return ''\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "ideographic", "self", "return", "the", "second", "ideographic", "person", "name", "component", "as", "a", "unicode", "string", "try", "return", "self", "components", "1", "except", "indexerror", "return"], "doc_len": 26}
{"doc_id": "pydicom/valuerep.py::PersonName3.phonetic", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "phonetic", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def phonetic(self):\n        \"\"\"Return the third (phonetic) person name component as a\n        unicode string\"\"\"\n        try:\n            return self.components[2]\n        except IndexError:\n            return ''\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "phonetic", "self", "return", "the", "third", "phonetic", "person", "name", "component", "as", "a", "unicode", "string", "try", "return", "self", "components", "2", "except", "indexerror", "return"], "doc_len": 26}
{"doc_id": "pydicom/valuerep.py::PersonName3.__eq__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__eq__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __eq__(self, other):\n        return str(self) == other\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__eq__", "self", "other", "return", "str", "self", "other"], "doc_len": 12}
{"doc_id": "pydicom/valuerep.py::PersonName3.__ne__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__ne__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __ne__(self, other):\n        return not self == other\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__ne__", "self", "other", "return", "not", "self", "other"], "doc_len": 12}
{"doc_id": "pydicom/valuerep.py::PersonName3.__str__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__str__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __str__(self):\n        return '='.join(self.components).__str__()\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__str__", "self", "return", "join", "self", "components", "__str__"], "doc_len": 12}
{"doc_id": "pydicom/valuerep.py::PersonName3.__repr__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__repr__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __repr__(self):\n        return '='.join(self.components).__repr__()\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__repr__", "self", "return", "join", "self", "components", "__repr__"], "doc_len": 12}
{"doc_id": "pydicom/valuerep.py::PersonName3.__hash__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__hash__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __hash__(self):\n        return hash(self.components)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__hash__", "self", "return", "hash", "self", "components"], "doc_len": 11}
{"doc_id": "pydicom/valuerep.py::PersonName3.decode", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "decode", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def decode(self, encodings=None):\n        \"\"\"Return the patient name decoded by the given encodings.\n\n        Parameters\n        ----------\n        encodings : list of str\n            The list of encodings used for decoding the byte string. If not\n            given, the initial encodings set in the object are used.\n\n        Returns\n        -------\n        PersonName3\n            A person name object that will return the decoded string with\n            the given encodings on demand. If the encodings are not given,\n            the current object is returned.\n        \"\"\"\n        # in the common case (encoding did not change) we decode on demand\n        if encodings is None or encodings == self.encodings:\n            return self\n        # the encoding was unknown or incorrect - create a new\n        # PersonName object with the changed encoding\n        encodings = _verify_encodings(encodings)\n        return PersonName3(self.original_string, encodings)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "decode", "self", "encodings", "none", "return", "the", "patient", "name", "decoded", "by", "the", "given", "encodings", "parameters", "encodings", "list", "of", "str", "the", "list", "of", "encodings", "used", "for", "decoding", "the", "byte", "string", "if", "not", "given", "the", "initial", "encodings", "set", "in", "the", "object", "are", "used", "returns", "personname3", "a", "person", "name", "object", "that", "will", "return", "the", "decoded", "string", "with", "the", "given", "encodings", "on", "demand", "if", "the", "encodings", "are", "not", "given", "the", "current", "object", "is", "returned", "in", "the", "common", "case", "encoding", "did", "not", "change", "we", "decode", "on", "demand", "if", "encodings", "is", "none", "or", "encodings", "self", "encodings", "return", "self", "the", "encoding", "was", "unknown", "or", "incorrect", "create", "a", "new", "personname", "object", "with", "the", "changed", "encoding", "encodings", "_verify_encodings", "encodings", "return", "personname3", "self", "original_string", "encodings"], "doc_len": 119}
{"doc_id": "pydicom/valuerep.py::PersonName3.encode", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "encode", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def encode(self, encodings=None):\n        \"\"\"Return the patient name decoded by the given encodings.\n\n        Parameters\n        ----------\n        encodings : list of str\n            The list of encodings used for encoding the unicode string. If\n            not given, the initial encodings set in the object are used.\n\n        Returns\n        -------\n        bytes\n            The person name encoded with the given encodings as a byte string.\n            If no encoding is given, the original byte string is returned, if\n            available, otherwise each group of the patient name is encoded\n            with the first matching of the given encodings.\n        \"\"\"\n        encodings = _verify_encodings(encodings) or self.encodings\n\n        # if the encoding is not the original encoding, we have to return\n        # a re-encoded string (without updating the original string)\n        if encodings != self.encodings and self.encodings is not None:\n            return _encode_personname(self.components, encodings)\n        if self.original_string is None:\n            # if the original encoding was not set, we set it now\n            self.original_string = _encode_personname(\n                self.components, encodings or [default_encoding])\n        return self.original_string\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "encode", "self", "encodings", "none", "return", "the", "patient", "name", "decoded", "by", "the", "given", "encodings", "parameters", "encodings", "list", "of", "str", "the", "list", "of", "encodings", "used", "for", "encoding", "the", "unicode", "string", "if", "not", "given", "the", "initial", "encodings", "set", "in", "the", "object", "are", "used", "returns", "bytes", "the", "person", "name", "encoded", "with", "the", "given", "encodings", "as", "a", "byte", "string", "if", "no", "encoding", "is", "given", "the", "original", "byte", "string", "is", "returned", "if", "available", "otherwise", "each", "group", "of", "the", "patient", "name", "is", "encoded", "with", "the", "first", "matching", "of", "the", "given", "encodings", "encodings", "_verify_encodings", "encodings", "or", "self", "encodings", "if", "the", "encoding", "is", "not", "the", "original", "encoding", "we", "have", "to", "return", "a", "re", "encoded", "string", "without", "updating", "the", "original", "string", "if", "encodings", "self", "encodings", "and", "self", "encodings", "is", "not", "none", "return", "_encode_personname", "self", "components", "encodings", "if", "self", "original_string", "is", "none", "if", "the", "original", "encoding", "was", "not", "set", "we", "set", "it", "now", "self", "original_string", "_encode_personname", "self", "components", "encodings", "or", "default_encoding", "return", "self", "original_string"], "doc_len": 158}
{"doc_id": "pydicom/valuerep.py::PersonName3.family_comma_given", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "family_comma_given", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def family_comma_given(self):\n        return self.formatted('%(family_name)s, %(given_name)s')\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "family_comma_given", "self", "return", "self", "formatted", "family_name", "s", "given_name", "s"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::PersonName3.formatted", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "formatted", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def formatted(self, format_str):\n        self._create_dict()\n        return format_str % self._dict\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "formatted", "self", "format_str", "self", "_create_dict", "return", "format_str", "self", "_dict"], "doc_len": 14}
{"doc_id": "pydicom/valuerep.py::PersonName3.__bool__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName3", "func_name": "__bool__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName3\n    def __bool__(self):\n        if self.original_string is None:\n            return (self._components is not None and\n                    (len(self._components) > 1 or bool(self._components[0])))\n        return bool(self.original_string)\n", "tokens": ["pydicom", "valuerep", "py", "personname3", "def", "__bool__", "self", "if", "self", "original_string", "is", "none", "return", "self", "_components", "is", "not", "none", "and", "len", "self", "_components", "1", "or", "bool", "self", "_components", "0", "return", "bool", "self", "original_string"], "doc_len": 32}
{"doc_id": "pydicom/valuerep.py::PersonNameBase.__init__", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameBase", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameBase\n    def __init__(self, val):\n        \"\"\"Initialize the PN properties\"\"\"\n        # Note normally use __new__ on subclassing an immutable,\n        # but here we just want to do some pre-processing\n        # for properties PS 3.5-2008 section 6.2 (p.28)\n        # and 6.2.1 describes PN. Briefly:\n        # single-byte-characters=ideographic\n        # characters=phonetic-characters\n        # (each with?):\n        #   family-name-complex\n        #  ^Given-name-complex\n        #  ^Middle-name^name-prefix^name-suffix\n        self.parse()\n", "tokens": ["pydicom", "valuerep", "py", "personnamebase", "def", "__init__", "self", "val", "initialize", "the", "pn", "properties", "note", "normally", "use", "__new__", "on", "subclassing", "an", "immutable", "but", "here", "we", "just", "want", "to", "do", "some", "pre", "processing", "for", "properties", "ps", "3", "5", "2008", "section", "6", "2", "p", "28", "and", "6", "2", "1", "describes", "pn", "briefly", "single", "byte", "characters", "ideographic", "characters", "phonetic", "characters", "each", "with", "family", "name", "complex", "given", "name", "complex", "middle", "name", "name", "prefix", "name", "suffix", "self", "parse"], "doc_len": 71}
{"doc_id": "pydicom/valuerep.py::PersonNameBase.formatted", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameBase", "func_name": "formatted", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameBase\n    def formatted(self, format_str):\n        \"\"\"Return a formatted string according to the format pattern\n\n        Use \"...%(property)...%(property)...\" where property\n        is one of family_name, given_name,\n                  middle_name, name_prefix,\n                  name_suffix\n        \"\"\"\n        return format_str % self.__dict__\n", "tokens": ["pydicom", "valuerep", "py", "personnamebase", "def", "formatted", "self", "format_str", "return", "a", "formatted", "string", "according", "to", "the", "format", "pattern", "use", "property", "property", "where", "property", "is", "one", "of", "family_name", "given_name", "middle_name", "name_prefix", "name_suffix", "return", "format_str", "self", "__dict__"], "doc_len": 34}
{"doc_id": "pydicom/valuerep.py::PersonNameBase.parse", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameBase", "func_name": "parse", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameBase\n    def parse(self):\n        \"\"\"Break down the components and name parts\"\"\"\n        self.components = tuple(self.split(\"=\"))\n        nComponents = len(self.components)\n        self.single_byte = self.components[0]\n        self.ideographic = ''\n        self.phonetic = ''\n        if nComponents > 1:\n            self.ideographic = self.components[1]\n        if nComponents > 2:\n            self.phonetic = self.components[2]\n\n        if self.single_byte:\n            # in case missing trailing items are left out\n            name_string = self.single_byte + \"^^^^\"\n            parts = name_string.split(\"^\")[:5]\n            self.family_name, self.given_name, self.middle_name = parts[:3]\n            self.name_prefix, self.name_suffix = parts[3:]\n        else:\n            (self.family_name, self.given_name, self.middle_name,\n             self.name_prefix, self.name_suffix) = ('', '', '', '', '')\n", "tokens": ["pydicom", "valuerep", "py", "personnamebase", "def", "parse", "self", "break", "down", "the", "components", "and", "name", "parts", "self", "components", "tuple", "self", "split", "ncomponents", "len", "self", "components", "self", "single_byte", "self", "components", "0", "self", "ideographic", "self", "phonetic", "if", "ncomponents", "1", "self", "ideographic", "self", "components", "1", "if", "ncomponents", "2", "self", "phonetic", "self", "components", "2", "if", "self", "single_byte", "in", "case", "missing", "trailing", "items", "are", "left", "out", "name_string", "self", "single_byte", "parts", "name_string", "split", "5", "self", "family_name", "self", "given_name", "self", "middle_name", "parts", "3", "self", "name_prefix", "self", "name_suffix", "parts", "3", "else", "self", "family_name", "self", "given_name", "self", "middle_name", "self", "name_prefix", "self", "name_suffix"], "doc_len": 91}
{"doc_id": "pydicom/valuerep.py::PersonName.__new__", "file_path": "pydicom/valuerep.py", "class_name": "PersonName", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName\n    def __new__(cls, val):\n        \"\"\"Return instance of the new class\"\"\"\n        # Check if trying to convert a string that has already been converted\n        if isinstance(val, PersonName):\n            return val\n        return super(PersonName, cls).__new__(cls, val)\n", "tokens": ["pydicom", "valuerep", "py", "personname", "def", "__new__", "cls", "val", "return", "instance", "of", "the", "new", "class", "check", "if", "trying", "to", "convert", "a", "string", "that", "has", "already", "been", "converted", "if", "isinstance", "val", "personname", "return", "val", "return", "super", "personname", "cls", "__new__", "cls", "val"], "doc_len": 39}
{"doc_id": "pydicom/valuerep.py::PersonName.encode", "file_path": "pydicom/valuerep.py", "class_name": "PersonName", "func_name": "encode", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName\n    def encode(self, *args):\n        \"\"\"Dummy method to mimic py2 str behavior in py3 bytes subclass\"\"\"\n        # This greatly simplifies the write process so all objects have the\n        # \"encode\" method\n        return self\n", "tokens": ["pydicom", "valuerep", "py", "personname", "def", "encode", "self", "args", "dummy", "method", "to", "mimic", "py2", "str", "behavior", "in", "py3", "bytes", "subclass", "this", "greatly", "simplifies", "the", "write", "process", "so", "all", "objects", "have", "the", "encode", "method", "return", "self"], "doc_len": 34}
{"doc_id": "pydicom/valuerep.py::PersonName.family_comma_given", "file_path": "pydicom/valuerep.py", "class_name": "PersonName", "func_name": "family_comma_given", "text": "文件路径: pydicom/valuerep.py, 类名: PersonName\n    def family_comma_given(self):\n        \"\"\"Return name as 'Family-name, Given-name'\"\"\"\n        return self.formatted(\"%(family_name)s, %(given_name)s\")\n", "tokens": ["pydicom", "valuerep", "py", "personname", "def", "family_comma_given", "self", "return", "name", "as", "family", "name", "given", "name", "return", "self", "formatted", "family_name", "s", "given_name", "s"], "doc_len": 21}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.__new__", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "__new__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def __new__(cls, val, encodings):\n        \"\"\"Return unicode string after conversion of each part\n        val -- the PN value to store\n        encodings -- a list of python encodings, generally found\n                 from pydicom.charset.python_encodings mapping\n                 of values in DICOM data element (0008,0005).\n        \"\"\"\n        encodings = _verify_encodings(encodings)\n        comps = _decode_personname(val.split(b\"=\"), encodings)\n        new_val = u\"=\".join(comps)\n        return compat.text_type.__new__(cls, new_val)\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "__new__", "cls", "val", "encodings", "return", "unicode", "string", "after", "conversion", "of", "each", "part", "val", "the", "pn", "value", "to", "store", "encodings", "a", "list", "of", "python", "encodings", "generally", "found", "from", "pydicom", "charset", "python_encodings", "mapping", "of", "values", "in", "dicom", "data", "element", "0008", "0005", "encodings", "_verify_encodings", "encodings", "comps", "_decode_personname", "val", "split", "b", "encodings", "new_val", "u", "join", "comps", "return", "compat", "text_type", "__new__", "cls", "new_val"], "doc_len": 63}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.__init__", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "__init__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def __init__(self, val, encodings):\n        self.encodings = _verify_encodings(encodings)\n        PersonNameBase.__init__(self, val)\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "__init__", "self", "val", "encodings", "self", "encodings", "_verify_encodings", "encodings", "personnamebase", "__init__", "self", "val"], "doc_len": 17}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.__copy__", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "__copy__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def __copy__(self):\n        \"\"\"Correctly copy object.\n        Needed because of the overwritten __new__.\n        \"\"\"\n        # no need to use the original encoding here - we just encode and\n        # decode in utf-8 and set the original encoding later\n        name = compat.text_type(self).encode('utf8')\n        new_person = PersonNameUnicode(name, 'utf8')\n        new_person.__dict__.update(self.__dict__)\n        return new_person\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "__copy__", "self", "correctly", "copy", "object", "needed", "because", "of", "the", "overwritten", "__new__", "no", "need", "to", "use", "the", "original", "encoding", "here", "we", "just", "encode", "and", "decode", "in", "utf", "8", "and", "set", "the", "original", "encoding", "later", "name", "compat", "text_type", "self", "encode", "utf8", "new_person", "personnameunicode", "name", "utf8", "new_person", "__dict__", "update", "self", "__dict__", "return", "new_person"], "doc_len": 55}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.__deepcopy__", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "__deepcopy__", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def __deepcopy__(self, memo):\n        \"\"\"Make correctly a deep copy of the object.\n        Needed because of the overwritten __new__.\n        \"\"\"\n        name = compat.text_type(self).encode('utf8')\n        new_person = PersonNameUnicode(name, 'utf8')\n        memo[id(self)] = new_person\n        # no need for deepcopy call - all attributes are immutable\n        new_person.__dict__.update(self.__dict__)\n        return new_person\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "__deepcopy__", "self", "memo", "make", "correctly", "a", "deep", "copy", "of", "the", "object", "needed", "because", "of", "the", "overwritten", "__new__", "name", "compat", "text_type", "self", "encode", "utf8", "new_person", "personnameunicode", "name", "utf8", "memo", "id", "self", "new_person", "no", "need", "for", "deepcopy", "call", "all", "attributes", "are", "immutable", "new_person", "__dict__", "update", "self", "__dict__", "return", "new_person"], "doc_len": 52}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.encode", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "encode", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def encode(self, encodings):\n        \"\"\"Encode the unicode using the specified encoding\"\"\"\n        encodings = _verify_encodings(encodings) or self.encodings\n        return _encode_personname(self.split('='), encodings)\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "encode", "self", "encodings", "encode", "the", "unicode", "using", "the", "specified", "encoding", "encodings", "_verify_encodings", "encodings", "or", "self", "encodings", "return", "_encode_personname", "self", "split", "encodings"], "doc_len": 26}
{"doc_id": "pydicom/valuerep.py::PersonNameUnicode.family_comma_given", "file_path": "pydicom/valuerep.py", "class_name": "PersonNameUnicode", "func_name": "family_comma_given", "text": "文件路径: pydicom/valuerep.py, 类名: PersonNameUnicode\n    def family_comma_given(self):\n        \"\"\"Return name as 'Family-name, Given-name'\"\"\"\n        return self.formatted(\"%(family_name)u, %(given_name)u\")\n", "tokens": ["pydicom", "valuerep", "py", "personnameunicode", "def", "family_comma_given", "self", "return", "name", "as", "family", "name", "given", "name", "return", "self", "formatted", "family_name", "u", "given_name", "u"], "doc_len": 21}
{"doc_id": "pydicom/values.py::convert_tag", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_tag", "text": "文件路径: pydicom/values.py\ndef convert_tag(byte_string, is_little_endian, offset=0):\n    if is_little_endian:\n        struct_format = \"<HH\"\n    else:\n        struct_format = \">HH\"\n    return TupleTag(unpack(struct_format, byte_string[offset:offset + 4]))\n", "tokens": ["pydicom", "values", "py", "def", "convert_tag", "byte_string", "is_little_endian", "offset", "0", "if", "is_little_endian", "struct_format", "hh", "else", "struct_format", "hh", "return", "tupletag", "unpack", "struct_format", "byte_string", "offset", "offset", "4"], "doc_len": 24}
{"doc_id": "pydicom/values.py::convert_AE_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_AE_string", "text": "文件路径: pydicom/values.py\ndef convert_AE_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read a byte string for a VR of 'AE'.\n\n    Elements with VR of 'AE' have non-significant leading and trailing spaces.\n    \"\"\"\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    byte_string = byte_string.strip()\n    return byte_string\n", "tokens": ["pydicom", "values", "py", "def", "convert_ae_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "a", "byte", "string", "for", "a", "vr", "of", "ae", "elements", "with", "vr", "of", "ae", "have", "non", "significant", "leading", "and", "trailing", "spaces", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "byte_string", "byte_string", "strip", "return", "byte_string"], "doc_len": 42}
{"doc_id": "pydicom/values.py::convert_ATvalue", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_ATvalue", "text": "文件路径: pydicom/values.py\ndef convert_ATvalue(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return AT (tag) data_element value(s)\"\"\"\n    length = len(byte_string)\n    if length == 4:\n        return convert_tag(byte_string, is_little_endian)\n\n    # length > 4\n    if length % 4 != 0:\n        logger.warn(\"Expected length to be multiple of 4 for VR 'AT', \"\n                    \"got length %d\", length)\n    return MultiValue(Tag, [\n        convert_tag(byte_string, is_little_endian, offset=x)\n        for x in range(0, length, 4)\n    ])\n", "tokens": ["pydicom", "values", "py", "def", "convert_atvalue", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "at", "tag", "data_element", "value", "s", "length", "len", "byte_string", "if", "length", "4", "return", "convert_tag", "byte_string", "is_little_endian", "length", "4", "if", "length", "4", "0", "logger", "warn", "expected", "length", "to", "be", "multiple", "of", "4", "for", "vr", "at", "got", "length", "d", "length", "return", "multivalue", "tag", "convert_tag", "byte_string", "is_little_endian", "offset", "x", "for", "x", "in", "range", "0", "length", "4"], "doc_len": 64}
{"doc_id": "pydicom/values.py::_DA_from_byte_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "_DA_from_byte_string", "text": "文件路径: pydicom/values.py\ndef _DA_from_byte_string(byte_string):\n    return DA(byte_string.rstrip())\n", "tokens": ["pydicom", "values", "py", "def", "_da_from_byte_string", "byte_string", "return", "da", "byte_string", "rstrip"], "doc_len": 10}
{"doc_id": "pydicom/values.py::convert_DA_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_DA_string", "text": "文件路径: pydicom/values.py\ndef convert_DA_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return a DA value\"\"\"\n\n    if config.datetime_conversion:\n        if not in_py2:\n            byte_string = byte_string.decode(default_encoding)\n        splitup = byte_string.split(\"\\\\\")\n        if len(splitup) == 1:\n            return _DA_from_byte_string(splitup[0])\n        else:\n            return MultiValue(_DA_from_byte_string, splitup)\n    else:\n        return convert_string(byte_string, is_little_endian, struct_format)\n", "tokens": ["pydicom", "values", "py", "def", "convert_da_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "da", "value", "if", "config", "datetime_conversion", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "splitup", "byte_string", "split", "if", "len", "splitup", "1", "return", "_da_from_byte_string", "splitup", "0", "else", "return", "multivalue", "_da_from_byte_string", "splitup", "else", "return", "convert_string", "byte_string", "is_little_endian", "struct_format"], "doc_len": 47}
{"doc_id": "pydicom/values.py::convert_DS_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_DS_string", "text": "文件路径: pydicom/values.py\ndef convert_DS_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return a DS value or list of values\"\"\"\n\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    # Below, go directly to DS class instance\n    # rather than factory DS, but need to\n    # ensure last string doesn't have\n    # blank padding (use strip())\n    return MultiString(byte_string.strip(), valtype=pydicom.valuerep.DSclass)\n", "tokens": ["pydicom", "values", "py", "def", "convert_ds_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "ds", "value", "or", "list", "of", "values", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "below", "go", "directly", "to", "ds", "class", "instance", "rather", "than", "factory", "ds", "but", "need", "to", "ensure", "last", "string", "doesn", "t", "have", "blank", "padding", "use", "strip", "return", "multistring", "byte_string", "strip", "valtype", "pydicom", "valuerep", "dsclass"], "doc_len": 58}
{"doc_id": "pydicom/values.py::_DT_from_byte_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "_DT_from_byte_string", "text": "文件路径: pydicom/values.py\ndef _DT_from_byte_string(byte_string):\n    byte_string = byte_string.rstrip()\n    length = len(byte_string)\n    if length < 4 or length > 26:\n        logger.warn(\"Expected length between 4 and 26, got length %d\", length)\n    return DT(byte_string)\n", "tokens": ["pydicom", "values", "py", "def", "_dt_from_byte_string", "byte_string", "byte_string", "byte_string", "rstrip", "length", "len", "byte_string", "if", "length", "4", "or", "length", "26", "logger", "warn", "expected", "length", "between", "4", "and", "26", "got", "length", "d", "length", "return", "dt", "byte_string"], "doc_len": 33}
{"doc_id": "pydicom/values.py::convert_DT_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_DT_string", "text": "文件路径: pydicom/values.py\ndef convert_DT_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return a DT value\"\"\"\n\n    if config.datetime_conversion:\n        if not in_py2:\n            byte_string = byte_string.decode(default_encoding)\n        splitup = byte_string.split(\"\\\\\")\n        if len(splitup) == 1:\n            return _DT_from_byte_string(splitup[0])\n        else:\n            return MultiValue(_DT_from_byte_string, splitup)\n    else:\n        return convert_string(byte_string, is_little_endian, struct_format)\n", "tokens": ["pydicom", "values", "py", "def", "convert_dt_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "dt", "value", "if", "config", "datetime_conversion", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "splitup", "byte_string", "split", "if", "len", "splitup", "1", "return", "_dt_from_byte_string", "splitup", "0", "else", "return", "multivalue", "_dt_from_byte_string", "splitup", "else", "return", "convert_string", "byte_string", "is_little_endian", "struct_format"], "doc_len": 47}
{"doc_id": "pydicom/values.py::convert_IS_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_IS_string", "text": "文件路径: pydicom/values.py\ndef convert_IS_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return an IS value or list of values\"\"\"\n\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    return MultiString(byte_string, valtype=pydicom.valuerep.IS)\n", "tokens": ["pydicom", "values", "py", "def", "convert_is_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "an", "is", "value", "or", "list", "of", "values", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "return", "multistring", "byte_string", "valtype", "pydicom", "valuerep", "is"], "doc_len": 33}
{"doc_id": "pydicom/values.py::convert_numbers", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_numbers", "text": "文件路径: pydicom/values.py\ndef convert_numbers(byte_string, is_little_endian, struct_format):\n    \"\"\"Convert `byte_string` to a value,\n       depending on `struct_format`.\n\n    Given an encoded DICOM Element value,\n    use `struct_format` and the endianness\n    of the data to decode it.\n\n    Parameters\n    ----------\n    byte_string : bytes\n        The raw byte data to decode.\n    is_little_endian : bool\n        The encoding of `byte_string`.\n    struct_format : str\n        The type of data encoded in `byte_string`.\n\n    Returns\n    -------\n    str\n        If there is no encoded data in `byte_string`\n        then an empty string will\n        be returned.\n    value\n        If `byte_string` encodes a single value\n         then it will be returned.\n    list\n        If `byte_string` encodes multiple values\n        then a list of the decoded\n        values will be returned.\n    \"\"\"\n    endianChar = '><' [is_little_endian]\n\n    # \"=\" means use 'standard' size, needed on 64-bit systems.\n    bytes_per_value = calcsize(\"=\" + struct_format)\n    length = len(byte_string)\n\n    if length % bytes_per_value != 0:\n        logger.warning(\"Expected length to be even multiple of number size\")\n\n    format_string = \"%c%u%c\" % (endianChar, length // bytes_per_value,\n                                struct_format)\n\n    value = unpack(format_string, byte_string)\n\n    # if the number is empty, then return the empty\n    # string rather than empty list\n    if len(value) == 0:\n        return ''\n    elif len(value) == 1:\n        return value[0]\n    else:\n        # convert from tuple to a list so can modify if need to\n        return list(value)\n", "tokens": ["pydicom", "values", "py", "def", "convert_numbers", "byte_string", "is_little_endian", "struct_format", "convert", "byte_string", "to", "a", "value", "depending", "on", "struct_format", "given", "an", "encoded", "dicom", "element", "value", "use", "struct_format", "and", "the", "endianness", "of", "the", "data", "to", "decode", "it", "parameters", "byte_string", "bytes", "the", "raw", "byte", "data", "to", "decode", "is_little_endian", "bool", "the", "encoding", "of", "byte_string", "struct_format", "str", "the", "type", "of", "data", "encoded", "in", "byte_string", "returns", "str", "if", "there", "is", "no", "encoded", "data", "in", "byte_string", "then", "an", "empty", "string", "will", "be", "returned", "value", "if", "byte_string", "encodes", "a", "single", "value", "then", "it", "will", "be", "returned", "list", "if", "byte_string", "encodes", "multiple", "values", "then", "a", "list", "of", "the", "decoded", "values", "will", "be", "returned", "endianchar", "is_little_endian", "means", "use", "standard", "size", "needed", "on", "64", "bit", "systems", "bytes_per_value", "calcsize", "struct_format", "length", "len", "byte_string", "if", "length", "bytes_per_value", "0", "logger", "warning", "expected", "length", "to", "be", "even", "multiple", "of", "number", "size", "format_string", "c", "u", "c", "endianchar", "length", "bytes_per_value", "struct_format", "value", "unpack", "format_string", "byte_string", "if", "the", "number", "is", "empty", "then", "return", "the", "empty", "string", "rather", "than", "empty", "list", "if", "len", "value", "0", "return", "elif", "len", "value", "1", "return", "value", "0", "else", "convert", "from", "tuple", "to", "a", "list", "so", "can", "modify", "if", "need", "to", "return", "list", "value"], "doc_len": 188}
{"doc_id": "pydicom/values.py::convert_OBvalue", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_OBvalue", "text": "文件路径: pydicom/values.py\ndef convert_OBvalue(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Return the raw bytes from reading an OB value\"\"\"\n    return byte_string\n", "tokens": ["pydicom", "values", "py", "def", "convert_obvalue", "byte_string", "is_little_endian", "struct_format", "none", "return", "the", "raw", "bytes", "from", "reading", "an", "ob", "value", "return", "byte_string"], "doc_len": 20}
{"doc_id": "pydicom/values.py::convert_OWvalue", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_OWvalue", "text": "文件路径: pydicom/values.py\ndef convert_OWvalue(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Return the raw bytes from reading an OW value rep\n\n    Note: pydicom does NOT do byte swapping, except in\n    dataset.pixel_array function\n    \"\"\"\n    # for now, Maybe later will have own routine\n    return convert_OBvalue(byte_string, is_little_endian)\n", "tokens": ["pydicom", "values", "py", "def", "convert_owvalue", "byte_string", "is_little_endian", "struct_format", "none", "return", "the", "raw", "bytes", "from", "reading", "an", "ow", "value", "rep", "note", "pydicom", "does", "not", "do", "byte", "swapping", "except", "in", "dataset", "pixel_array", "function", "for", "now", "maybe", "later", "will", "have", "own", "routine", "return", "convert_obvalue", "byte_string", "is_little_endian"], "doc_len": 43}
{"doc_id": "pydicom/values.py::convert_PN", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_PN", "text": "文件路径: pydicom/values.py\ndef convert_PN(byte_string,\n               encodings=None):\n    \"\"\"Read and return string(s) as PersonName instance(s)\"\"\"\n\n    def get_valtype(x):\n        if not in_py2:\n            return PersonName(x, encodings).decode()\n        return PersonName(x, encodings)\n\n    # XXX - We have to replicate MultiString functionality\n    # here because we can't decode easily here since that\n    # is performed in PersonNameUnicode\n    if byte_string.endswith((b' ', b'\\x00')):\n        byte_string = byte_string[:-1]\n\n    splitup = byte_string.split(b\"\\\\\")\n\n    if len(splitup) == 1:\n        return get_valtype(splitup[0])\n    else:\n        return MultiValue(get_valtype, splitup)\n", "tokens": ["pydicom", "values", "py", "def", "convert_pn", "byte_string", "encodings", "none", "read", "and", "return", "string", "s", "as", "personname", "instance", "s", "def", "get_valtype", "x", "if", "not", "in_py2", "return", "personname", "x", "encodings", "decode", "return", "personname", "x", "encodings", "xxx", "we", "have", "to", "replicate", "multistring", "functionality", "here", "because", "we", "can", "t", "decode", "easily", "here", "since", "that", "is", "performed", "in", "personnameunicode", "if", "byte_string", "endswith", "b", "b", "x00", "byte_string", "byte_string", "1", "splitup", "byte_string", "split", "b", "if", "len", "splitup", "1", "return", "get_valtype", "splitup", "0", "else", "return", "multivalue", "get_valtype", "splitup"], "doc_len": 79}
{"doc_id": "pydicom/values.py::convert_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_string", "text": "文件路径: pydicom/values.py\ndef convert_string(byte_string,\n                   is_little_endian,\n                   struct_format=None):\n    \"\"\"Read and return a string or strings\"\"\"\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    return MultiString(byte_string)\n", "tokens": ["pydicom", "values", "py", "def", "convert_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "string", "or", "strings", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "return", "multistring", "byte_string"], "doc_len": 26}
{"doc_id": "pydicom/values.py::convert_text", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_text", "text": "文件路径: pydicom/values.py\ndef convert_text(byte_string, encodings=None):\n    \"\"\"Read and return a string or strings\"\"\"\n    values = byte_string.split(b'\\\\')\n    values = [convert_single_string(value, encodings) for value in values]\n    if len(values) == 1:\n        return values[0]\n    else:\n        return MultiValue(compat.text_type, values)\n", "tokens": ["pydicom", "values", "py", "def", "convert_text", "byte_string", "encodings", "none", "read", "and", "return", "a", "string", "or", "strings", "values", "byte_string", "split", "b", "values", "convert_single_string", "value", "encodings", "for", "value", "in", "values", "if", "len", "values", "1", "return", "values", "0", "else", "return", "multivalue", "compat", "text_type", "values"], "doc_len": 40}
{"doc_id": "pydicom/values.py::convert_single_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_single_string", "text": "文件路径: pydicom/values.py\ndef convert_single_string(byte_string, encodings=None):\n    \"\"\"Read and return a single string\n       (backslash character does not split)\"\"\"\n    encodings = encodings or [default_encoding]\n    value = decode_string(byte_string, encodings, TEXT_VR_DELIMS)\n    if value and value.endswith(' '):\n        value = value[:-1]\n    return value\n", "tokens": ["pydicom", "values", "py", "def", "convert_single_string", "byte_string", "encodings", "none", "read", "and", "return", "a", "single", "string", "backslash", "character", "does", "not", "split", "encodings", "encodings", "or", "default_encoding", "value", "decode_string", "byte_string", "encodings", "text_vr_delims", "if", "value", "and", "value", "endswith", "value", "value", "1", "return", "value"], "doc_len": 38}
{"doc_id": "pydicom/values.py::convert_SQ", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_SQ", "text": "文件路径: pydicom/values.py\ndef convert_SQ(byte_string,\n               is_implicit_VR,\n               is_little_endian,\n               encoding=default_encoding,\n               offset=0):\n    \"\"\"Convert a sequence that has been read\n       as bytes but not yet parsed.\"\"\"\n    fp = BytesIO(byte_string)\n    seq = read_sequence(fp, is_implicit_VR, is_little_endian,\n                        len(byte_string), encoding, offset)\n    return seq\n", "tokens": ["pydicom", "values", "py", "def", "convert_sq", "byte_string", "is_implicit_vr", "is_little_endian", "encoding", "default_encoding", "offset", "0", "convert", "a", "sequence", "that", "has", "been", "read", "as", "bytes", "but", "not", "yet", "parsed", "fp", "bytesio", "byte_string", "seq", "read_sequence", "fp", "is_implicit_vr", "is_little_endian", "len", "byte_string", "encoding", "offset", "return", "seq"], "doc_len": 39}
{"doc_id": "pydicom/values.py::_TM_from_byte_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "_TM_from_byte_string", "text": "文件路径: pydicom/values.py\ndef _TM_from_byte_string(byte_string):\n    byte_string = byte_string.rstrip()\n    length = len(byte_string)\n    if (length < 2 or length > 16) and length != 0:\n        logger.warn(\"Expected length between 2 and 16, got length %d\", length)\n    return TM(byte_string)\n", "tokens": ["pydicom", "values", "py", "def", "_tm_from_byte_string", "byte_string", "byte_string", "byte_string", "rstrip", "length", "len", "byte_string", "if", "length", "2", "or", "length", "16", "and", "length", "0", "logger", "warn", "expected", "length", "between", "2", "and", "16", "got", "length", "d", "length", "return", "tm", "byte_string"], "doc_len": 36}
{"doc_id": "pydicom/values.py::convert_TM_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_TM_string", "text": "文件路径: pydicom/values.py\ndef convert_TM_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return a TM value\"\"\"\n    if config.datetime_conversion:\n        if not in_py2:\n            byte_string = byte_string.decode(default_encoding)\n        splitup = byte_string.split(\"\\\\\")\n        if len(splitup) == 1:\n            return _TM_from_byte_string(splitup[0])\n        else:\n            return MultiValue(_TM_from_byte_string, splitup)\n    else:\n        return convert_string(byte_string, is_little_endian, struct_format)\n", "tokens": ["pydicom", "values", "py", "def", "convert_tm_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "tm", "value", "if", "config", "datetime_conversion", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "splitup", "byte_string", "split", "if", "len", "splitup", "1", "return", "_tm_from_byte_string", "splitup", "0", "else", "return", "multivalue", "_tm_from_byte_string", "splitup", "else", "return", "convert_string", "byte_string", "is_little_endian", "struct_format"], "doc_len": 47}
{"doc_id": "pydicom/values.py::convert_UI", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_UI", "text": "文件路径: pydicom/values.py\ndef convert_UI(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read and return a UI values or values\"\"\"\n    # Strip off 0-byte padding for even length (if there)\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    if byte_string and byte_string.endswith('\\0'):\n        byte_string = byte_string[:-1]\n    return MultiString(byte_string, pydicom.uid.UID)\n", "tokens": ["pydicom", "values", "py", "def", "convert_ui", "byte_string", "is_little_endian", "struct_format", "none", "read", "and", "return", "a", "ui", "values", "or", "values", "strip", "off", "0", "byte", "padding", "for", "even", "length", "if", "there", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "if", "byte_string", "and", "byte_string", "endswith", "0", "byte_string", "byte_string", "1", "return", "multistring", "byte_string", "pydicom", "uid", "uid"], "doc_len": 49}
{"doc_id": "pydicom/values.py::convert_UN", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_UN", "text": "文件路径: pydicom/values.py\ndef convert_UN(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Return a byte string for a VR of 'UN' (unknown)\"\"\"\n    return byte_string\n", "tokens": ["pydicom", "values", "py", "def", "convert_un", "byte_string", "is_little_endian", "struct_format", "none", "return", "a", "byte", "string", "for", "a", "vr", "of", "un", "unknown", "return", "byte_string"], "doc_len": 21}
{"doc_id": "pydicom/values.py::convert_UR_string", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_UR_string", "text": "文件路径: pydicom/values.py\ndef convert_UR_string(byte_string, is_little_endian, struct_format=None):\n    \"\"\"Read a byte string for a VR of 'UR'\n\n    Elements with VR of 'UR' shall not be multi-valued\n    and trailing spaces shall be ignored.\n    \"\"\"\n    if not in_py2:\n        byte_string = byte_string.decode(default_encoding)\n    byte_string = byte_string.rstrip()\n    return byte_string\n", "tokens": ["pydicom", "values", "py", "def", "convert_ur_string", "byte_string", "is_little_endian", "struct_format", "none", "read", "a", "byte", "string", "for", "a", "vr", "of", "ur", "elements", "with", "vr", "of", "ur", "shall", "not", "be", "multi", "valued", "and", "trailing", "spaces", "shall", "be", "ignored", "if", "not", "in_py2", "byte_string", "byte_string", "decode", "default_encoding", "byte_string", "byte_string", "rstrip", "return", "byte_string"], "doc_len": 46}
{"doc_id": "pydicom/values.py::convert_value", "file_path": "pydicom/values.py", "class_name": null, "func_name": "convert_value", "text": "文件路径: pydicom/values.py\ndef convert_value(VR, raw_data_element, encodings=None):\n    \"\"\"Return the converted value (from raw bytes) for the given VR\"\"\"\n    if VR not in converters:\n        # `VR` characters are in the ascii alphabet ranges 65 - 90, 97 - 122\n        char_range = list(range(65, 91)) + list(range(97, 123))\n        # If the VR characters are outside that range then print hex values\n        if ord(VR[0]) not in char_range or ord(VR[1]) not in char_range:\n            VR = ' '.join(['0x{:02x}'.format(ord(ch)) for ch in VR])\n        message = \"Unknown Value Representation '{}'\".format(VR)\n        raise NotImplementedError(message)\n\n    # Look up the function to convert that VR\n    # Dispatch two cases: a plain converter,\n    # or a number one which needs a format string\n    if isinstance(converters[VR], tuple):\n        converter, num_format = converters[VR]\n    else:\n        converter = converters[VR]\n        num_format = None\n\n    # Ensure that encodings is a list\n    encodings = encodings or [default_encoding]\n    if isinstance(encodings, compat.string_types):\n        encodings = [encodings]\n\n    byte_string = raw_data_element.value\n    is_little_endian = raw_data_element.is_little_endian\n    is_implicit_VR = raw_data_element.is_implicit_VR\n\n    # Not only two cases. Also need extra info if is a raw sequence\n    # Pass all encodings to the converter if needed\n    try:\n        if VR in text_VRs or VR == 'PN':\n            value = converter(byte_string,\n                              encodings=encodings)\n        elif VR != \"SQ\":\n            value = converter(byte_string,\n                              is_little_endian,\n                              num_format)\n        else:\n            value = convert_SQ(byte_string,\n                               is_implicit_VR,\n                               is_little_endian,\n                               encodings,\n                               raw_data_element.value_tell)\n    except ValueError:\n        if config.enforce_valid_values:\n            # The user really wants an exception here\n            raise\n        logger.debug('unable to translate tag %s with VR %s'\n                     % (raw_data_element.tag, VR))\n\n        for vr in convert_retry_VR_order:\n            if vr == VR:\n                continue\n            try:\n                value = convert_value(vr, raw_data_element, encodings)\n                logger.debug('converted value for tag %s with VR %s'\n                             % (raw_data_element.tag, vr))\n                break\n            except Exception:\n                pass\n        else:\n            logger.debug('Could not convert value for tag %s with any VR '\n                         'in the convert_retry_VR_order list'\n                         % raw_data_element.tag)\n            value = raw_data_element.value\n    return value\n", "tokens": ["pydicom", "values", "py", "def", "convert_value", "vr", "raw_data_element", "encodings", "none", "return", "the", "converted", "value", "from", "raw", "bytes", "for", "the", "given", "vr", "if", "vr", "not", "in", "converters", "vr", "characters", "are", "in", "the", "ascii", "alphabet", "ranges", "65", "90", "97", "122", "char_range", "list", "range", "65", "91", "list", "range", "97", "123", "if", "the", "vr", "characters", "are", "outside", "that", "range", "then", "print", "hex", "values", "if", "ord", "vr", "0", "not", "in", "char_range", "or", "ord", "vr", "1", "not", "in", "char_range", "vr", "join", "0x", "02x", "format", "ord", "ch", "for", "ch", "in", "vr", "message", "unknown", "value", "representation", "format", "vr", "raise", "notimplementederror", "message", "look", "up", "the", "function", "to", "convert", "that", "vr", "dispatch", "two", "cases", "a", "plain", "converter", "or", "a", "number", "one", "which", "needs", "a", "format", "string", "if", "isinstance", "converters", "vr", "tuple", "converter", "num_format", "converters", "vr", "else", "converter", "converters", "vr", "num_format", "none", "ensure", "that", "encodings", "is", "a", "list", "encodings", "encodings", "or", "default_encoding", "if", "isinstance", "encodings", "compat", "string_types", "encodings", "encodings", "byte_string", "raw_data_element", "value", "is_little_endian", "raw_data_element", "is_little_endian", "is_implicit_vr", "raw_data_element", "is_implicit_vr", "not", "only", "two", "cases", "also", "need", "extra", "info", "if", "is", "a", "raw", "sequence", "pass", "all", "encodings", "to", "the", "converter", "if", "needed", "try", "if", "vr", "in", "text_vrs", "or", "vr", "pn", "value", "converter", "byte_string", "encodings", "encodings", "elif", "vr", "sq", "value", "converter", "byte_string", "is_little_endian", "num_format", "else", "value", "convert_sq", "byte_string", "is_implicit_vr", "is_little_endian", "encodings", "raw_data_element", "value_tell", "except", "valueerror", "if", "config", "enforce_valid_values", "the", "user", "really", "wants", "an", "exception", "here", "raise", "logger", "debug", "unable", "to", "translate", "tag", "s", "with", "vr", "s", "raw_data_element", "tag", "vr", "for", "vr", "in", "convert_retry_vr_order", "if", "vr", "vr", "continue", "try", "value", "convert_value", "vr", "raw_data_element", "encodings", "logger", "debug", "converted", "value", "for", "tag", "s", "with", "vr", "s", "raw_data_element", "tag", "vr", "break", "except", "exception", "pass", "else", "logger", "debug", "could", "not", "convert", "value", "for", "tag", "s", "with", "any", "vr", "in", "the", "convert_retry_vr_order", "list", "raw_data_element", "tag", "value", "raw_data_element", "value", "return", "value"], "doc_len": 288}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeFragmentFrame.setup", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeFragmentFrame", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeFragmentFrame\n    def setup(self):\n        \"\"\"Setup the test\"\"\"\n        ds = dcmread(JP2K_10FRAME)\n        self.test_data = decode_data_sequence(ds.PixelData)\n        assert len(self.test_data) == 10\n        self.no_runs = 1000\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timefragmentframe", "def", "setup", "self", "setup", "the", "test", "ds", "dcmread", "jp2k_10frame", "self", "test_data", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "self", "test_data", "10", "self", "no_runs", "1000"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeFragmentFrame.time_fragment_single", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeFragmentFrame", "func_name": "time_fragment_single", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeFragmentFrame\n    def time_fragment_single(self):\n        \"\"\"Time fragmenting each frame into 1 fragment.\"\"\"\n        for ii in range(self.no_runs):\n            for fragment in fragment_frame(self.test_data[0], 1):\n                pass\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timefragmentframe", "def", "time_fragment_single", "self", "time", "fragmenting", "each", "frame", "into", "1", "fragment", "for", "ii", "in", "range", "self", "no_runs", "for", "fragment", "in", "fragment_frame", "self", "test_data", "0", "1", "pass"], "doc_len": 30}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeFragmentFrame.time_fragment_ten", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeFragmentFrame", "func_name": "time_fragment_ten", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeFragmentFrame\n    def time_fragment_ten(self):\n        \"\"\"Time fragmenting each frame into 10 fragments.\"\"\"\n        for ii in range(self.no_runs):\n            for fragment in fragment_frame(self.test_data[0], 10):\n                pass\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timefragmentframe", "def", "time_fragment_ten", "self", "time", "fragmenting", "each", "frame", "into", "10", "fragments", "for", "ii", "in", "range", "self", "no_runs", "for", "fragment", "in", "fragment_frame", "self", "test_data", "0", "10", "pass"], "doc_len": 30}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeItemiseFrame.setup", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeItemiseFrame", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeItemiseFrame\n    def setup(self):\n        \"\"\"Setup the test\"\"\"\n        ds = dcmread(JP2K_10FRAME)\n        self.test_data = decode_data_sequence(ds.PixelData)\n        assert len(self.test_data) == 10\n        self.no_runs = 1000\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeitemiseframe", "def", "setup", "self", "setup", "the", "test", "ds", "dcmread", "jp2k_10frame", "self", "test_data", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "self", "test_data", "10", "self", "no_runs", "1000"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeItemiseFrame.time_itemise_single", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeItemiseFrame", "func_name": "time_itemise_single", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeItemiseFrame\n    def time_itemise_single(self):\n        \"\"\"Time itemising a frame into 1 fragment.\"\"\"\n        for ii in range(self.no_runs):\n            for item in itemise_frame(self.test_data[0], 1):\n                pass\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeitemiseframe", "def", "time_itemise_single", "self", "time", "itemising", "a", "frame", "into", "1", "fragment", "for", "ii", "in", "range", "self", "no_runs", "for", "item", "in", "itemise_frame", "self", "test_data", "0", "1", "pass"], "doc_len": 30}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeItemiseFrame.time_itemise_ten", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeItemiseFrame", "func_name": "time_itemise_ten", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeItemiseFrame\n    def time_itemise_ten(self):\n        \"\"\"Time itemising a frame into 10 fragments.\"\"\"\n        for ii in range(self.no_runs):\n            for item in itemise_frame(self.test_data[0], 10):\n                pass\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeitemiseframe", "def", "time_itemise_ten", "self", "time", "itemising", "a", "frame", "into", "10", "fragments", "for", "ii", "in", "range", "self", "no_runs", "for", "item", "in", "itemise_frame", "self", "test_data", "0", "10", "pass"], "doc_len": 30}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeEncapsulate.setup", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeEncapsulate", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeEncapsulate\n    def setup(self):\n        \"\"\"Setup the test\"\"\"\n        ds = dcmread(JP2K_10FRAME)\n        self.test_data = decode_data_sequence(ds.PixelData)\n        assert len(self.test_data) == 10\n        self.no_runs = 1000\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeencapsulate", "def", "setup", "self", "setup", "the", "test", "ds", "dcmread", "jp2k_10frame", "self", "test_data", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "self", "test_data", "10", "self", "no_runs", "1000"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeEncapsulate.time_encapsulate_single_bot", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeEncapsulate", "func_name": "time_encapsulate_single_bot", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeEncapsulate\n    def time_encapsulate_single_bot(self):\n        \"\"\"Time encapsulating frames with 1 fragment per frame.\"\"\"\n        for ii in range(self.no_runs):\n            encapsulate(self.test_data, 1, has_bot=True)\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeencapsulate", "def", "time_encapsulate_single_bot", "self", "time", "encapsulating", "frames", "with", "1", "fragment", "per", "frame", "for", "ii", "in", "range", "self", "no_runs", "encapsulate", "self", "test_data", "1", "has_bot", "true"], "doc_len": 28}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeEncapsulate.time_encapsulate_ten_bot", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeEncapsulate", "func_name": "time_encapsulate_ten_bot", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeEncapsulate\n    def time_encapsulate_ten_bot(self):\n        \"\"\"Time encapsulating frames with 10 fragments per frame.\"\"\"\n        for ii in range(self.no_runs):\n            encapsulate(self.test_data, 10, has_bot=True)\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeencapsulate", "def", "time_encapsulate_ten_bot", "self", "time", "encapsulating", "frames", "with", "10", "fragments", "per", "frame", "for", "ii", "in", "range", "self", "no_runs", "encapsulate", "self", "test_data", "10", "has_bot", "true"], "doc_len": 28}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeEncapsulate.time_encapsulate_single_nobot", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeEncapsulate", "func_name": "time_encapsulate_single_nobot", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeEncapsulate\n    def time_encapsulate_single_nobot(self):\n        \"\"\"Time encapsulating frames with 1 fragment per frame.\"\"\"\n        for ii in range(self.no_runs):\n            encapsulate(self.test_data, 1, has_bot=False)\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeencapsulate", "def", "time_encapsulate_single_nobot", "self", "time", "encapsulating", "frames", "with", "1", "fragment", "per", "frame", "for", "ii", "in", "range", "self", "no_runs", "encapsulate", "self", "test_data", "1", "has_bot", "false"], "doc_len": 28}
{"doc_id": "pydicom/benchmarks/bench_encaps.py::TimeEncapsulate.time_encapsulate_ten_nobot", "file_path": "pydicom/benchmarks/bench_encaps.py", "class_name": "TimeEncapsulate", "func_name": "time_encapsulate_ten_nobot", "text": "文件路径: pydicom/benchmarks/bench_encaps.py, 类名: TimeEncapsulate\n    def time_encapsulate_ten_nobot(self):\n        \"\"\"Time encapsulating frames with 10 fragments per frame.\"\"\"\n        for ii in range(self.no_runs):\n            encapsulate(self.test_data, 10, has_bot=False)\n", "tokens": ["pydicom", "benchmarks", "bench_encaps", "py", "timeencapsulate", "def", "time_encapsulate_ten_nobot", "self", "time", "encapsulating", "frames", "with", "10", "fragments", "per", "frame", "for", "ii", "in", "range", "self", "no_runs", "encapsulate", "self", "test_data", "10", "has_bot", "false"], "doc_len": 28}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::_create_temporary_dataset", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": null, "func_name": "_create_temporary_dataset", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py\ndef _create_temporary_dataset(shape=(100, 1024, 1024, 3), bit_depth=16):\n    \"\"\"Function to create a temporary dataset for use in testing.\n\n    Parameters\n    ----------\n    shape : 4-tuple\n        The (frames, rows, columns, channels) of the test dataset.\n    bit_depth : int\n        The BitsAllocated value to use for the dataset, one of 8, 16, 32, 64.\n\n    Returns\n    -------\n    tempfile.TemporaryFile\n        A created DICOM File Format conformant dataset.\n    \"\"\"\n    ds = Dataset()\n    ds.is_little_endian = True\n    ds.is_implicit_VR = False\n    ds.file_meta = Dataset()\n    ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n    ds.SOPClassUID = '1.2.3.4'\n    ds.SOPInstanceUID = generate_uid()\n    ds.BitsAllocated = bit_depth\n    ds.PixelRepresentation = 0\n    ds.PlanarConfiguration = 0\n    ds.Rows = shape[1]\n    ds.Columns = shape[2]\n    ds.NumberOfFrames = shape[0]\n    ds.SamplesPerPixel = shape[3]\n    if shape[3] == 1:\n        ds.PhotometricInterpretation = 'MONOCHROME2'\n    elif shape[3] == 3:\n        ds.PhotometricInterpretation = 'RGB'\n\n    arr = np.zeros(shape, dtype='uint{}'.format(bit_depth))\n    ds.PixelData = arr.tobytes()\n\n    if len(ds.PixelData) % 2:\n        ds.PixelData += b'\\x00'\n\n    tfile = TemporaryFile(mode='w+b')\n    ds.save_as(tfile, write_like_original=False)\n    tfile.seek(0)\n\n    return tfile\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "def", "_create_temporary_dataset", "shape", "100", "1024", "1024", "3", "bit_depth", "16", "function", "to", "create", "a", "temporary", "dataset", "for", "use", "in", "testing", "parameters", "shape", "4", "tuple", "the", "frames", "rows", "columns", "channels", "of", "the", "test", "dataset", "bit_depth", "int", "the", "bitsallocated", "value", "to", "use", "for", "the", "dataset", "one", "of", "8", "16", "32", "64", "returns", "tempfile", "temporaryfile", "a", "created", "dicom", "file", "format", "conformant", "dataset", "ds", "dataset", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "false", "ds", "file_meta", "dataset", "ds", "file_meta", "transfersyntaxuid", "explicitvrlittleendian", "ds", "sopclassuid", "1", "2", "3", "4", "ds", "sopinstanceuid", "generate_uid", "ds", "bitsallocated", "bit_depth", "ds", "pixelrepresentation", "0", "ds", "planarconfiguration", "0", "ds", "rows", "shape", "1", "ds", "columns", "shape", "2", "ds", "numberofframes", "shape", "0", "ds", "samplesperpixel", "shape", "3", "if", "shape", "3", "1", "ds", "photometricinterpretation", "monochrome2", "elif", "shape", "3", "3", "ds", "photometricinterpretation", "rgb", "arr", "np", "zeros", "shape", "dtype", "uint", "format", "bit_depth", "ds", "pixeldata", "arr", "tobytes", "if", "len", "ds", "pixeldata", "2", "ds", "pixeldata", "b", "x00", "tfile", "temporaryfile", "mode", "w", "b", "ds", "save_as", "tfile", "write_like_original", "false", "tfile", "seek", "0", "return", "tfile"], "doc_len": 161}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData_LargeDataset.setup", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData_LargeDataset", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData_LargeDataset\n    def setup(self):\n        \"\"\"Setup the tests.\"\"\"\n        self.no_runs = 100\n\n        self.ds_16_3_100 = dcmread(_create_temporary_dataset())\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata_largedataset", "def", "setup", "self", "setup", "the", "tests", "self", "no_runs", "100", "self", "ds_16_3_100", "dcmread", "_create_temporary_dataset"], "doc_len": 18}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData_LargeDataset.time_large_dataset", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData_LargeDataset", "func_name": "time_large_dataset", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData_LargeDataset\n    def time_large_dataset(self):\n        \"\"\"Time reading pixel data from a large dataset.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_3_100)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata_largedataset", "def", "time_large_dataset", "self", "time", "reading", "pixel", "data", "from", "a", "large", "dataset", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_3_100"], "doc_len": 25}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.setup", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def setup(self):\n        \"\"\"Setup the tests.\"\"\"\n        self.no_runs = 100\n\n        self.ds_1_1_1 = dcmread(EXPL_1_1_1F)\n        self.ds_1_1_3 = dcmread(EXPL_1_1_3F)\n        self.ds_8_1_1 = dcmread(EXPL_8_1_1F)\n        self.ds_8_1_2 = dcmread(EXPL_8_1_2F)\n        self.ds_8_3_1 = dcmread(EXPL_8_3_1F)\n        self.ds_8_3_2 = dcmread(EXPL_8_3_2F)\n        self.ds_16_1_1 = dcmread(EXPL_16_1_1F)\n        self.ds_16_1_10 = dcmread(EXPL_16_1_10F)\n        self.ds_16_3_1 = dcmread(EXPL_16_3_1F)\n        self.ds_16_3_2 = dcmread(EXPL_16_3_2F)\n        self.ds_32_1_1 = dcmread(IMPL_32_1_1F)\n        self.ds_32_1_15 = dcmread(IMPL_32_1_15F)\n        self.ds_32_3_1 = dcmread(EXPL_32_3_1F)\n        self.ds_32_3_2 = dcmread(EXPL_32_3_2F)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "setup", "self", "setup", "the", "tests", "self", "no_runs", "100", "self", "ds_1_1_1", "dcmread", "expl_1_1_1f", "self", "ds_1_1_3", "dcmread", "expl_1_1_3f", "self", "ds_8_1_1", "dcmread", "expl_8_1_1f", "self", "ds_8_1_2", "dcmread", "expl_8_1_2f", "self", "ds_8_3_1", "dcmread", "expl_8_3_1f", "self", "ds_8_3_2", "dcmread", "expl_8_3_2f", "self", "ds_16_1_1", "dcmread", "expl_16_1_1f", "self", "ds_16_1_10", "dcmread", "expl_16_1_10f", "self", "ds_16_3_1", "dcmread", "expl_16_3_1f", "self", "ds_16_3_2", "dcmread", "expl_16_3_2f", "self", "ds_32_1_1", "dcmread", "impl_32_1_1f", "self", "ds_32_1_15", "dcmread", "impl_32_1_15f", "self", "ds_32_3_1", "dcmread", "expl_32_3_1f", "self", "ds_32_3_2", "dcmread", "expl_32_3_2f"], "doc_len": 70}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_1bit_1sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_1bit_1sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_1bit_1sample_1frame(self):\n        \"\"\"Time retrieval of 1-bit, 1 sample/pixel, 1 frame.\"\"\"\n        no_runs = self.no_runs\n        if 'PyPy' in python_implementation():\n            no_runs = 1\n\n        for ii in range(no_runs):\n            get_pixeldata(self.ds_1_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_1bit_1sample_1frame", "self", "time", "retrieval", "of", "1", "bit", "1", "sample", "pixel", "1", "frame", "no_runs", "self", "no_runs", "if", "pypy", "in", "python_implementation", "no_runs", "1", "for", "ii", "in", "range", "no_runs", "get_pixeldata", "self", "ds_1_1_1"], "doc_len": 35}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_1bit_1sample_3frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_1bit_1sample_3frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_1bit_1sample_3frame(self):\n        \"\"\"Time retrieval of 1-bit, 1 sample/pixel, 3 frame.\"\"\"\n        no_runs = self.no_runs\n        if 'PyPy' in python_implementation():\n            no_runs = 1\n\n        for ii in range(no_runs):\n            get_pixeldata(self.ds_1_1_3)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_1bit_1sample_3frame", "self", "time", "retrieval", "of", "1", "bit", "1", "sample", "pixel", "3", "frame", "no_runs", "self", "no_runs", "if", "pypy", "in", "python_implementation", "no_runs", "1", "for", "ii", "in", "range", "no_runs", "get_pixeldata", "self", "ds_1_1_3"], "doc_len": 35}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_8bit_1sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_8bit_1sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_8bit_1sample_1frame(self):\n        \"\"\"Time retrieval of 8-bit, 1 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_8bit_1sample_1frame", "self", "time", "retrieval", "of", "8", "bit", "1", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_8bit_1sample_2frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_8bit_1sample_2frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_8bit_1sample_2frame(self):\n        \"\"\"Time retrieval of 8-bit, 1 sample/pixel, 2 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_1_2)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_8bit_1sample_2frame", "self", "time", "retrieval", "of", "8", "bit", "1", "sample", "pixel", "2", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_1_2"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_8bit_3sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_8bit_3sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_8bit_3sample_1frame(self):\n        \"\"\"Time retrieval of 8-bit, 3 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_8bit_3sample_1frame", "self", "time", "retrieval", "of", "8", "bit", "3", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_8bit_3sample_2frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_8bit_3sample_2frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_8bit_3sample_2frame(self):\n        \"\"\"Time retrieval of 8-bit, 3 sample/pixel, 2 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_3_2)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_8bit_3sample_2frame", "self", "time", "retrieval", "of", "8", "bit", "3", "sample", "pixel", "2", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_3_2"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_16bit_1sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_1sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_16bit_1sample_1frame(self):\n        \"\"\"Time retrieval of 16-bit, 1 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_16bit_1sample_1frame", "self", "time", "retrieval", "of", "16", "bit", "1", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_16bit_1sample_10frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_1sample_10frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_16bit_1sample_10frame(self):\n        \"\"\"Time retrieval of 16-bit, 1 sample/pixel, 10 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_1_10)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_16bit_1sample_10frame", "self", "time", "retrieval", "of", "16", "bit", "1", "sample", "pixel", "10", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_1_10"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_16bit_3sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_3sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_16bit_3sample_1frame(self):\n        \"\"\"Time retrieval of 16-bit, 3 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_16bit_3sample_1frame", "self", "time", "retrieval", "of", "16", "bit", "3", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_16bit_3sample_2frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_3sample_2frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_16bit_3sample_2frame(self):\n        \"\"\"Time retrieval of 16-bit, 3 sample/pixel, 2 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_3_2)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_16bit_3sample_2frame", "self", "time", "retrieval", "of", "16", "bit", "3", "sample", "pixel", "2", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_3_2"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_32bit_1sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_1sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_32bit_1sample_1frame(self):\n        \"\"\"Time retrieval of 32-bit, 1 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_32bit_1sample_1frame", "self", "time", "retrieval", "of", "32", "bit", "1", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_32bit_1sample_15frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_1sample_15frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_32bit_1sample_15frame(self):\n        \"\"\"Time retrieval of 32-bit, 1 sample/pixel, 15 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_1_15)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_32bit_1sample_15frame", "self", "time", "retrieval", "of", "32", "bit", "1", "sample", "pixel", "15", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_1_15"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_32bit_3sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_3sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_32bit_3sample_1frame(self):\n        \"\"\"Time retrieval of 32-bit, 3 sample/pixel, 1 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_32bit_3sample_1frame", "self", "time", "retrieval", "of", "32", "bit", "3", "sample", "pixel", "1", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_numpy.py::TimeGetPixelData.time_32bit_3sample_2frame", "file_path": "pydicom/benchmarks/bench_handler_numpy.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_3sample_2frame", "text": "文件路径: pydicom/benchmarks/bench_handler_numpy.py, 类名: TimeGetPixelData\n    def time_32bit_3sample_2frame(self):\n        \"\"\"Time retrieval of 32-bit, 3 sample/pixel, 2 frame.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_3_2)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_numpy", "py", "timegetpixeldata", "def", "time_32bit_3sample_2frame", "self", "time", "retrieval", "of", "32", "bit", "3", "sample", "pixel", "2", "frame", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_3_2"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeRLEDecodeFrame.setup", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeRLEDecodeFrame", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeRLEDecodeFrame\n    def setup(self):\n        # MONOCHROME2, 64x64, 1 sample/pixel, 16 bits allocated, 12 bits stored\n        self.ds = dcmread(EMRI_RLE_10F)\n        self.frames = decode_data_sequence(self.ds.PixelData)\n        assert len(self.frames) == 10\n\n        self.no_runs = 100\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timerledecodeframe", "def", "setup", "self", "monochrome2", "64x64", "1", "sample", "pixel", "16", "bits", "allocated", "12", "bits", "stored", "self", "ds", "dcmread", "emri_rle_10f", "self", "frames", "decode_data_sequence", "self", "ds", "pixeldata", "assert", "len", "self", "frames", "10", "self", "no_runs", "100"], "doc_len": 37}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeRLEDecodeFrame.time_decode_16bit_1sample_1frame", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeRLEDecodeFrame", "func_name": "time_decode_16bit_1sample_1frame", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeRLEDecodeFrame\n    def time_decode_16bit_1sample_1frame(self):\n        \"\"\"Time decoding the pixel data from a single RLE frame.\"\"\"\n        for ii in range(self.no_runs):\n            _rle_decode_frame(self.frames[0],\n                              self.ds.Rows,\n                              self.ds.Columns,\n                              self.ds.SamplesPerPixel,\n                              self.ds.BitsAllocated)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timerledecodeframe", "def", "time_decode_16bit_1sample_1frame", "self", "time", "decoding", "the", "pixel", "data", "from", "a", "single", "rle", "frame", "for", "ii", "in", "range", "self", "no_runs", "_rle_decode_frame", "self", "frames", "0", "self", "ds", "rows", "self", "ds", "columns", "self", "ds", "samplesperpixel", "self", "ds", "bitsallocated"], "doc_len": 40}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeRLEDecodeFrame.time_decode_16bit_1sample_10frame", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeRLEDecodeFrame", "func_name": "time_decode_16bit_1sample_10frame", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeRLEDecodeFrame\n    def time_decode_16bit_1sample_10frame(self):\n        \"\"\"Time decoding the pixel data from 10 RLE frames.\"\"\"\n        for ii in range(self.no_runs):\n            for frame in self.frames:\n                _rle_decode_frame(frame,\n                                  self.ds.Rows,\n                                  self.ds.Columns,\n                                  self.ds.SamplesPerPixel,\n                                  self.ds.BitsAllocated)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timerledecodeframe", "def", "time_decode_16bit_1sample_10frame", "self", "time", "decoding", "the", "pixel", "data", "from", "10", "rle", "frames", "for", "ii", "in", "range", "self", "no_runs", "for", "frame", "in", "self", "frames", "_rle_decode_frame", "frame", "self", "ds", "rows", "self", "ds", "columns", "self", "ds", "samplesperpixel", "self", "ds", "bitsallocated"], "doc_len": 42}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.setup", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def setup(self):\n        \"\"\"Setup the test\"\"\"\n        self.ds_8_1_1 = dcmread(OB_RLE_1F)\n        self.ds_8_3_1 = dcmread(SC_RLE_1F)\n        self.ds_16_1_1 = dcmread(MR_RLE_1F)\n        self.ds_16_3_1 = dcmread(SC_RLE_16_1F)\n        self.ds_32_1_1 = dcmread(RTDOSE_RLE_1F)\n        self.ds_32_3_1 = dcmread(SC_RLE_32_1F)\n\n        self.no_runs = 100\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "setup", "self", "setup", "the", "test", "self", "ds_8_1_1", "dcmread", "ob_rle_1f", "self", "ds_8_3_1", "dcmread", "sc_rle_1f", "self", "ds_16_1_1", "dcmread", "mr_rle_1f", "self", "ds_16_3_1", "dcmread", "sc_rle_16_1f", "self", "ds_32_1_1", "dcmread", "rtdose_rle_1f", "self", "ds_32_3_1", "dcmread", "sc_rle_32_1f", "self", "no_runs", "100"], "doc_len": 38}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_08bit_1sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_08bit_1sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_08bit_1sample(self):\n        \"\"\"Time retrieval of 8-bit, 1 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_08bit_1sample", "self", "time", "retrieval", "of", "8", "bit", "1", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_08bit_3sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_08bit_3sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_08bit_3sample(self):\n        \"\"\"Time retrieval of 8-bit, 3 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_8_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_08bit_3sample", "self", "time", "retrieval", "of", "8", "bit", "3", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_8_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_16bit_1sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_1sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_16bit_1sample(self):\n        \"\"\"Time retrieval of 16-bit, 1 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_16bit_1sample", "self", "time", "retrieval", "of", "16", "bit", "1", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_16bit_3sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_16bit_3sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_16bit_3sample(self):\n        \"\"\"Time retrieval of 16-bit, 3 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_16_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_16bit_3sample", "self", "time", "retrieval", "of", "16", "bit", "3", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_16_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_32bit_1sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_1sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_32bit_1sample(self):\n        \"\"\"Time retrieval of 32-bit, 1 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_1_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_32bit_1sample", "self", "time", "retrieval", "of", "32", "bit", "1", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_1_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_decode.py::TimeGetPixelData.time_32bit_3sample", "file_path": "pydicom/benchmarks/bench_handler_rle_decode.py", "class_name": "TimeGetPixelData", "func_name": "time_32bit_3sample", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_decode.py, 类名: TimeGetPixelData\n    def time_32bit_3sample(self):\n        \"\"\"Time retrieval of 32-bit, 3 sample/pixel RLE data.\"\"\"\n        for ii in range(self.no_runs):\n            get_pixeldata(self.ds_32_3_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_decode", "py", "timegetpixeldata", "def", "time_32bit_3sample", "self", "time", "retrieval", "of", "32", "bit", "3", "sample", "pixel", "rle", "data", "for", "ii", "in", "range", "self", "no_runs", "get_pixeldata", "self", "ds_32_3_1"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeSegment.setup", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeSegment", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeSegment\n    def setup(self):\n        ds = dcmread(EXPL_8_1_1F)\n        self.arr = ds.pixel_array\n\n        self.no_runs = 100\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodesegment", "def", "setup", "self", "ds", "dcmread", "expl_8_1_1f", "self", "arr", "ds", "pixel_array", "self", "no_runs", "100"], "doc_len": 18}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeSegment.time_encode", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeSegment", "func_name": "time_encode", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeSegment\n    def time_encode(self):\n        \"\"\"Time encoding a full segment.\"\"\"\n        # Re-encode the decoded data\n        for ii in range(self.no_runs):\n            _rle_encode_segment(self.arr)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodesegment", "def", "time_encode", "self", "time", "encoding", "a", "full", "segment", "re", "encode", "the", "decoded", "data", "for", "ii", "in", "range", "self", "no_runs", "_rle_encode_segment", "self", "arr"], "doc_len": 27}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.setup", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "setup", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def setup(self):\n        ds = dcmread(EXPL_8_1_1F)\n        self.arr8_1 = ds.pixel_array\n        ds = dcmread(EXPL_8_3_1F)\n        self.arr8_3 = ds.pixel_array\n        ds = dcmread(EXPL_16_1_1F)\n        self.arr16_1 = ds.pixel_array\n        ds = dcmread(EXPL_16_3_1F)\n        self.arr16_3 = ds.pixel_array\n        ds = dcmread(EXPL_32_1_1F)\n        self.arr32_1 = ds.pixel_array\n        ds = dcmread(EXPL_32_3_1F)\n        self.arr32_3 = ds.pixel_array\n\n        self.no_runs = 100\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "setup", "self", "ds", "dcmread", "expl_8_1_1f", "self", "arr8_1", "ds", "pixel_array", "ds", "dcmread", "expl_8_3_1f", "self", "arr8_3", "ds", "pixel_array", "ds", "dcmread", "expl_16_1_1f", "self", "arr16_1", "ds", "pixel_array", "ds", "dcmread", "expl_16_3_1f", "self", "arr16_3", "ds", "pixel_array", "ds", "dcmread", "expl_32_1_1f", "self", "arr32_1", "ds", "pixel_array", "ds", "dcmread", "expl_32_3_1f", "self", "arr32_3", "ds", "pixel_array", "self", "no_runs", "100"], "doc_len": 53}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_08_1", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_08_1", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_08_1(self):\n        \"\"\"Time encoding 8 bit 1 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr8_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_08_1", "self", "time", "encoding", "8", "bit", "1", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr8_1"], "doc_len": 24}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_08_3", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_08_3", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_08_3(self):\n        \"\"\"Time encoding 8 bit 3 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr8_3)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_08_3", "self", "time", "encoding", "8", "bit", "3", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr8_3"], "doc_len": 24}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_16_1", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_16_1", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_16_1(self):\n        \"\"\"Time encoding 16 bit 1 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr16_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_16_1", "self", "time", "encoding", "16", "bit", "1", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr16_1"], "doc_len": 24}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_16_3", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_16_3", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_16_3(self):\n        \"\"\"Time encoding 16 bit 3 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr16_3)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_16_3", "self", "time", "encoding", "16", "bit", "3", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr16_3"], "doc_len": 24}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_32_1", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_32_1", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_32_1(self):\n        \"\"\"Time encoding 32 bit 1 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr32_1)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_32_1", "self", "time", "encoding", "32", "bit", "1", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr32_1"], "doc_len": 24}
{"doc_id": "pydicom/benchmarks/bench_handler_rle_encode.py::TimeRLEEncodeFrame.time_32_3", "file_path": "pydicom/benchmarks/bench_handler_rle_encode.py", "class_name": "TimeRLEEncodeFrame", "func_name": "time_32_3", "text": "文件路径: pydicom/benchmarks/bench_handler_rle_encode.py, 类名: TimeRLEEncodeFrame\n    def time_32_3(self):\n        \"\"\"Time encoding 32 bit 3 sample/pixel.\"\"\"\n        for ii in range(self.no_runs):\n            rle_encode_frame(self.arr32_3)\n", "tokens": ["pydicom", "benchmarks", "bench_handler_rle_encode", "py", "timerleencodeframe", "def", "time_32_3", "self", "time", "encoding", "32", "bit", "3", "sample", "pixel", "for", "ii", "in", "range", "self", "no_runs", "rle_encode_frame", "self", "arr32_3"], "doc_len": 24}
{"doc_id": "pydicom/data/data_manager.py::get_files", "file_path": "pydicom/data/data_manager.py", "class_name": null, "func_name": "get_files", "text": "文件路径: pydicom/data/data_manager.py\ndef get_files(base, pattern):\n    \"\"\"Return all files from a set of sources.\n\n    Parameters\n    ----------\n    base : str\n        Base directory to recursively search.\n\n    pattern : str\n        A string pattern to filter the files. Default is \"*\" and it will return\n        all files.\n\n    Returns\n    -------\n    files : list of str\n        The list of filenames matched.\n    \"\"\"\n\n    # if the user forgot to add them\n    pattern = \"*\" + pattern + \"*\"\n\n    files = []\n    for root, dirnames, filenames in walk(base):\n        for filename in filenames:\n            filename_filter = fnmatch.filter([join(root, filename)],\n                                             pattern)\n            if len(filename_filter):\n                files.append(filename_filter[0])\n\n    return files\n", "tokens": ["pydicom", "data", "data_manager", "py", "def", "get_files", "base", "pattern", "return", "all", "files", "from", "a", "set", "of", "sources", "parameters", "base", "str", "base", "directory", "to", "recursively", "search", "pattern", "str", "a", "string", "pattern", "to", "filter", "the", "files", "default", "is", "and", "it", "will", "return", "all", "files", "returns", "files", "list", "of", "str", "the", "list", "of", "filenames", "matched", "if", "the", "user", "forgot", "to", "add", "them", "pattern", "pattern", "files", "for", "root", "dirnames", "filenames", "in", "walk", "base", "for", "filename", "in", "filenames", "filename_filter", "fnmatch", "filter", "join", "root", "filename", "pattern", "if", "len", "filename_filter", "files", "append", "filename_filter", "0", "return", "files"], "doc_len": 88}
{"doc_id": "pydicom/data/data_manager.py::get_testdata_files", "file_path": "pydicom/data/data_manager.py", "class_name": null, "func_name": "get_testdata_files", "text": "文件路径: pydicom/data/data_manager.py\ndef get_testdata_files(pattern=\"*\"):\n    \"\"\"Return test data files from pydicom data root.\n\n    Parameters\n    ----------\n    pattern : str, optional (default=\"*\")\n        A string pattern to filter the files\n\n    Returns\n    -------\n    files : list of str\n        The list of filenames matched.\n\n    \"\"\"\n\n    data_path = join(DATA_ROOT, 'test_files')\n\n    files = get_files(base=data_path, pattern=pattern)\n    files = [filename for filename in files if not filename.endswith('.py')]\n\n    return files\n", "tokens": ["pydicom", "data", "data_manager", "py", "def", "get_testdata_files", "pattern", "return", "test", "data", "files", "from", "pydicom", "data", "root", "parameters", "pattern", "str", "optional", "default", "a", "string", "pattern", "to", "filter", "the", "files", "returns", "files", "list", "of", "str", "the", "list", "of", "filenames", "matched", "data_path", "join", "data_root", "test_files", "files", "get_files", "base", "data_path", "pattern", "pattern", "files", "filename", "for", "filename", "in", "files", "if", "not", "filename", "endswith", "py", "return", "files"], "doc_len": 60}
{"doc_id": "pydicom/data/data_manager.py::get_charset_files", "file_path": "pydicom/data/data_manager.py", "class_name": null, "func_name": "get_charset_files", "text": "文件路径: pydicom/data/data_manager.py\ndef get_charset_files(pattern=\"*\"):\n    \"\"\"Return charset files from pydicom data root.\n\n    Parameters\n    ----------\n    pattern : str, optional (default=\"*\")\n        A string pattern to filter the files\n\n    Returns\n    ----------\n    files : list of str\n        The list of filenames matched.\n\n    \"\"\"\n\n    data_path = join(DATA_ROOT, 'charset_files')\n\n    files = get_files(base=data_path, pattern=pattern)\n    files = [filename for filename in files if not filename.endswith('.py')]\n\n    return files\n", "tokens": ["pydicom", "data", "data_manager", "py", "def", "get_charset_files", "pattern", "return", "charset", "files", "from", "pydicom", "data", "root", "parameters", "pattern", "str", "optional", "default", "a", "string", "pattern", "to", "filter", "the", "files", "returns", "files", "list", "of", "str", "the", "list", "of", "filenames", "matched", "data_path", "join", "data_root", "charset_files", "files", "get_files", "base", "data_path", "pattern", "pattern", "files", "filename", "for", "filename", "in", "files", "if", "not", "filename", "endswith", "py", "return", "files"], "doc_len": 59}
{"doc_id": "pydicom/data/tests/test_data_manager.py::TestGetData.test_get_dataset", "file_path": "pydicom/data/tests/test_data_manager.py", "class_name": "TestGetData", "func_name": "test_get_dataset", "text": "文件路径: pydicom/data/tests/test_data_manager.py, 类名: TestGetData\n    def test_get_dataset(self):\n        \"\"\"Test the different functions to get lists of data files.\"\"\"\n\n        # Test base locations\n        charbase = os.path.join(DATA_ROOT, 'charset_files')\n        self.assertTrue(os.path.exists(charbase))\n\n        testbase = os.path.join(DATA_ROOT, 'test_files')\n        self.assertTrue(os.path.exists(testbase))\n\n        # Test file get\n        chardata = get_charset_files()\n        self.assertTrue(len(chardata) > 15)\n\n        # Test that top level file is included\n        bases = [basename(x) for x in chardata]\n\n        # Test that subdirectory files included\n        testdata = get_testdata_files()\n        bases = [basename(x) for x in testdata]\n        self.assertTrue('2693' in bases)\n        self.assertTrue(len(testdata) > 70)\n\n        # The files should be from their respective bases\n        [self.assertTrue(testbase in x) for x in testdata]\n        [self.assertTrue(charbase in x) for x in chardata]\n", "tokens": ["pydicom", "data", "tests", "test_data_manager", "py", "testgetdata", "def", "test_get_dataset", "self", "test", "the", "different", "functions", "to", "get", "lists", "of", "data", "files", "test", "base", "locations", "charbase", "os", "path", "join", "data_root", "charset_files", "self", "asserttrue", "os", "path", "exists", "charbase", "testbase", "os", "path", "join", "data_root", "test_files", "self", "asserttrue", "os", "path", "exists", "testbase", "test", "file", "get", "chardata", "get_charset_files", "self", "asserttrue", "len", "chardata", "15", "test", "that", "top", "level", "file", "is", "included", "bases", "basename", "x", "for", "x", "in", "chardata", "test", "that", "subdirectory", "files", "included", "testdata", "get_testdata_files", "bases", "basename", "x", "for", "x", "in", "testdata", "self", "asserttrue", "2693", "in", "bases", "self", "asserttrue", "len", "testdata", "70", "the", "files", "should", "be", "from", "their", "respective", "bases", "self", "asserttrue", "testbase", "in", "x", "for", "x", "in", "testdata", "self", "asserttrue", "charbase", "in", "x", "for", "x", "in", "chardata"], "doc_len": 120}
{"doc_id": "pydicom/data/tests/test_data_manager.py::TestGetData.test_get_dataset_pattern", "file_path": "pydicom/data/tests/test_data_manager.py", "class_name": "TestGetData", "func_name": "test_get_dataset_pattern", "text": "文件路径: pydicom/data/tests/test_data_manager.py, 类名: TestGetData\n    def test_get_dataset_pattern(self):\n        \"\"\"Test that pattern is working properly.\"\"\"\n\n        pattern = 'CT_small'\n        filename = get_testdata_files(pattern)\n        self.assertTrue(filename[0].endswith('CT_small.dcm'))\n\n        pattern = 'chrX1'\n        filename = get_charset_files(pattern)\n        self.assertTrue(filename[0].endswith('chrX1.dcm'))\n", "tokens": ["pydicom", "data", "tests", "test_data_manager", "py", "testgetdata", "def", "test_get_dataset_pattern", "self", "test", "that", "pattern", "is", "working", "properly", "pattern", "ct_small", "filename", "get_testdata_files", "pattern", "self", "asserttrue", "filename", "0", "endswith", "ct_small", "dcm", "pattern", "chrx1", "filename", "get_charset_files", "pattern", "self", "asserttrue", "filename", "0", "endswith", "chrx1", "dcm"], "doc_len": 39}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::is_available", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "is_available", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef is_available():\n    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n    return HAVE_NP and HAVE_GDCM\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "is_available", "return", "true", "if", "the", "handler", "has", "its", "dependencies", "met", "return", "have_np", "and", "have_gdcm"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::needs_to_convert_to_RGB", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "needs_to_convert_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef needs_to_convert_to_RGB(dicom_dataset):\n    should_convert = (dicom_dataset.file_meta.TransferSyntaxUID in\n                      should_convert_these_syntaxes_to_RGB)\n    should_convert &= dicom_dataset.SamplesPerPixel == 3\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "needs_to_convert_to_rgb", "dicom_dataset", "should_convert", "dicom_dataset", "file_meta", "transfersyntaxuid", "in", "should_convert_these_syntaxes_to_rgb", "should_convert", "dicom_dataset", "samplesperpixel", "3", "return", "false"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::should_change_PhotometricInterpretation_to_RGB", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "should_change_PhotometricInterpretation_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n    should_change = (dicom_dataset.file_meta.TransferSyntaxUID in\n                     should_convert_these_syntaxes_to_RGB)\n    should_change &= dicom_dataset.SamplesPerPixel == 3\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "should_change", "dicom_dataset", "file_meta", "transfersyntaxuid", "in", "should_convert_these_syntaxes_to_rgb", "should_change", "dicom_dataset", "samplesperpixel", "3", "return", "false"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::supports_transfer_syntax", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "supports_transfer_syntax", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef supports_transfer_syntax(transfer_syntax):\n    \"\"\"\n    Returns\n    -------\n    bool\n        True if this pixel data handler might support this transfer syntax.\n\n        False to prevent any attempt to try to use this handler\n        to decode the given transfer syntax\n    \"\"\"\n    return transfer_syntax in SUPPORTED_TRANSFER_SYNTAXES\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "supports_transfer_syntax", "transfer_syntax", "returns", "bool", "true", "if", "this", "pixel", "data", "handler", "might", "support", "this", "transfer", "syntax", "false", "to", "prevent", "any", "attempt", "to", "try", "to", "use", "this", "handler", "to", "decode", "the", "given", "transfer", "syntax", "return", "transfer_syntax", "in", "supported_transfer_syntaxes"], "doc_len": 41}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::create_data_element", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "create_data_element", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef create_data_element(dicom_dataset):\n    \"\"\"Create a gdcm.DataElement containing PixelData from a FileDataset\n\n    Parameters\n    ----------\n    dicom_dataset : FileDataset\n\n\n    Returns\n    -------\n    gdcm.DataElement\n        Converted PixelData element\n    \"\"\"\n    data_element = gdcm.DataElement(gdcm.Tag(0x7fe0, 0x0010))\n    if dicom_dataset.file_meta.TransferSyntaxUID.is_compressed:\n        if getattr(dicom_dataset, 'NumberOfFrames', 1) > 1:\n            pixel_data_sequence = pydicom.encaps.decode_data_sequence(\n                dicom_dataset.PixelData)\n        else:\n            pixel_data_sequence = [\n                pydicom.encaps.defragment_data(dicom_dataset.PixelData)\n            ]\n\n        fragments = gdcm.SequenceOfFragments.New()\n        for pixel_data in pixel_data_sequence:\n            fragment = gdcm.Fragment()\n            fragment.SetByteStringValue(pixel_data)\n            fragments.AddFragment(fragment)\n        data_element.SetValue(fragments.__ref__())\n    else:\n        data_element.SetByteStringValue(dicom_dataset.PixelData)\n\n    return data_element\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "create_data_element", "dicom_dataset", "create", "a", "gdcm", "dataelement", "containing", "pixeldata", "from", "a", "filedataset", "parameters", "dicom_dataset", "filedataset", "returns", "gdcm", "dataelement", "converted", "pixeldata", "element", "data_element", "gdcm", "dataelement", "gdcm", "tag", "0x7fe0", "0x0010", "if", "dicom_dataset", "file_meta", "transfersyntaxuid", "is_compressed", "if", "getattr", "dicom_dataset", "numberofframes", "1", "1", "pixel_data_sequence", "pydicom", "encaps", "decode_data_sequence", "dicom_dataset", "pixeldata", "else", "pixel_data_sequence", "pydicom", "encaps", "defragment_data", "dicom_dataset", "pixeldata", "fragments", "gdcm", "sequenceoffragments", "new", "for", "pixel_data", "in", "pixel_data_sequence", "fragment", "gdcm", "fragment", "fragment", "setbytestringvalue", "pixel_data", "fragments", "addfragment", "fragment", "data_element", "setvalue", "fragments", "__ref__", "else", "data_element", "setbytestringvalue", "dicom_dataset", "pixeldata", "return", "data_element"], "doc_len": 84}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::create_image", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "create_image", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef create_image(dicom_dataset, data_element):\n    \"\"\"Create a gdcm.Image from a FileDataset and a gdcm.DataElement containing\n    PixelData (0x7fe0, 0x0010)\n\n    Parameters\n    ----------\n    dicom_dataset : FileDataset\n    data_element : gdcm.DataElement\n        DataElement containing PixelData\n\n    Returns\n    -------\n    gdcm.Image\n    \"\"\"\n    image = gdcm.Image()\n    number_of_frames = getattr(dicom_dataset, 'NumberOfFrames', 1)\n    image.SetNumberOfDimensions(2 if number_of_frames == 1 else 3)\n    image.SetDimensions(\n        (dicom_dataset.Columns, dicom_dataset.Rows, number_of_frames))\n    image.SetDataElement(data_element)\n    pi_type = gdcm.PhotometricInterpretation.GetPIType(\n        dicom_dataset.PhotometricInterpretation)\n    image.SetPhotometricInterpretation(\n        gdcm.PhotometricInterpretation(pi_type))\n    ts_type = gdcm.TransferSyntax.GetTSType(\n        str.__str__(dicom_dataset.file_meta.TransferSyntaxUID))\n    image.SetTransferSyntax(gdcm.TransferSyntax(ts_type))\n    pixel_format = gdcm.PixelFormat(\n        dicom_dataset.SamplesPerPixel, dicom_dataset.BitsAllocated,\n        dicom_dataset.BitsStored, dicom_dataset.HighBit,\n        dicom_dataset.PixelRepresentation)\n    image.SetPixelFormat(pixel_format)\n    if 'PlanarConfiguration' in dicom_dataset:\n        image.SetPlanarConfiguration(dicom_dataset.PlanarConfiguration)\n    return image\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "create_image", "dicom_dataset", "data_element", "create", "a", "gdcm", "image", "from", "a", "filedataset", "and", "a", "gdcm", "dataelement", "containing", "pixeldata", "0x7fe0", "0x0010", "parameters", "dicom_dataset", "filedataset", "data_element", "gdcm", "dataelement", "dataelement", "containing", "pixeldata", "returns", "gdcm", "image", "image", "gdcm", "image", "number_of_frames", "getattr", "dicom_dataset", "numberofframes", "1", "image", "setnumberofdimensions", "2", "if", "number_of_frames", "1", "else", "3", "image", "setdimensions", "dicom_dataset", "columns", "dicom_dataset", "rows", "number_of_frames", "image", "setdataelement", "data_element", "pi_type", "gdcm", "photometricinterpretation", "getpitype", "dicom_dataset", "photometricinterpretation", "image", "setphotometricinterpretation", "gdcm", "photometricinterpretation", "pi_type", "ts_type", "gdcm", "transfersyntax", "gettstype", "str", "__str__", "dicom_dataset", "file_meta", "transfersyntaxuid", "image", "settransfersyntax", "gdcm", "transfersyntax", "ts_type", "pixel_format", "gdcm", "pixelformat", "dicom_dataset", "samplesperpixel", "dicom_dataset", "bitsallocated", "dicom_dataset", "bitsstored", "dicom_dataset", "highbit", "dicom_dataset", "pixelrepresentation", "image", "setpixelformat", "pixel_format", "if", "planarconfiguration", "in", "dicom_dataset", "image", "setplanarconfiguration", "dicom_dataset", "planarconfiguration", "return", "image"], "doc_len": 112}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::create_image_reader", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "create_image_reader", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef create_image_reader(filename):\n    \"\"\"Create a gdcm.ImageReader\n\n    Parameters\n    ----------\n    filename: str or unicode (Python 2)\n\n    Returns\n    -------\n    gdcm.ImageReader\n    \"\"\"\n    image_reader = gdcm.ImageReader()\n    if compat.in_py2:\n        if isinstance(filename, unicode):\n            image_reader.SetFileName(\n                filename.encode(sys.getfilesystemencoding()))\n        else:\n            image_reader.SetFileName(filename)\n    else:\n        image_reader.SetFileName(filename)\n    return image_reader\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "create_image_reader", "filename", "create", "a", "gdcm", "imagereader", "parameters", "filename", "str", "or", "unicode", "python", "2", "returns", "gdcm", "imagereader", "image_reader", "gdcm", "imagereader", "if", "compat", "in_py2", "if", "isinstance", "filename", "unicode", "image_reader", "setfilename", "filename", "encode", "sys", "getfilesystemencoding", "else", "image_reader", "setfilename", "filename", "else", "image_reader", "setfilename", "filename", "return", "image_reader"], "doc_len": 47}
{"doc_id": "pydicom/pixel_data_handlers/gdcm_handler.py::get_pixeldata", "file_path": "pydicom/pixel_data_handlers/gdcm_handler.py", "class_name": null, "func_name": "get_pixeldata", "text": "文件路径: pydicom/pixel_data_handlers/gdcm_handler.py\ndef get_pixeldata(dicom_dataset):\n    \"\"\"\n    Use the GDCM package to decode the PixelData attribute\n\n    Returns\n    -------\n    numpy.ndarray\n\n        A correctly sized (but not shaped) numpy array\n        of the entire data volume\n\n    Raises\n    ------\n    ImportError\n        if the required packages are not available\n\n    TypeError\n        if the image could not be read by GDCM\n        if the pixel data type is unsupported\n\n    AttributeError\n        if the decoded amount of data does not match the expected amount\n    \"\"\"\n\n    if not HAVE_GDCM:\n        msg = (\"GDCM requires both the gdcm package and numpy \"\n               \"and one or more could not be imported\")\n        raise ImportError(msg)\n\n    if HAVE_GDCM_IN_MEMORY_SUPPORT:\n        gdcm_data_element = create_data_element(dicom_dataset)\n        gdcm_image = create_image(dicom_dataset, gdcm_data_element)\n    else:\n        gdcm_image_reader = create_image_reader(dicom_dataset.filename)\n        if not gdcm_image_reader.Read():\n            raise TypeError(\"GDCM could not read DICOM image\")\n        gdcm_image = gdcm_image_reader.GetImage()\n\n    # GDCM returns char* as type str. Under Python 2 `str` are\n    # byte arrays by default. Python 3 decodes this to\n    # unicode strings by default.\n    # The SWIG docs mention that they always decode byte streams\n    # as utf-8 strings for Python 3, with the `surrogateescape`\n    # error handler configured.\n    # Therefore, we can encode them back to their original bytearray\n    # representation on Python 3 by using the same parameters.\n    if compat.in_py2:\n        pixel_bytearray = gdcm_image.GetBuffer()\n    else:\n        pixel_bytearray = gdcm_image.GetBuffer().encode(\n            \"utf-8\", \"surrogateescape\")\n\n    # Here we need to be careful because in some cases, GDCM reads a\n    # buffer that is too large, so we need to make sure we only include\n    # the first n_rows * n_columns * dtype_size bytes.\n    expected_length_bytes = get_expected_length(dicom_dataset)\n    if len(pixel_bytearray) > expected_length_bytes:\n        # We make sure that all the bytes after are in fact zeros\n        padding = pixel_bytearray[expected_length_bytes:]\n        if numpy.any(numpy.frombuffer(padding, numpy.byte)):\n            pixel_bytearray = pixel_bytearray[:expected_length_bytes]\n        else:\n            # We revert to the old behavior which should then result\n            #   in a Numpy error later on.\n            pass\n\n    numpy_dtype = pixel_dtype(dicom_dataset)\n    pixel_array = numpy.frombuffer(pixel_bytearray, dtype=numpy_dtype)\n\n    expected_length_pixels = get_expected_length(dicom_dataset, 'pixels')\n    if pixel_array.size != expected_length_pixels:\n        raise AttributeError(\"Amount of pixel data %d does \"\n                             \"not match the expected data %d\" %\n                             (pixel_array.size, expected_length_pixels))\n\n    if should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n        dicom_dataset.PhotometricInterpretation = \"RGB\"\n\n    return pixel_array.copy()\n", "tokens": ["pydicom", "pixel_data_handlers", "gdcm_handler", "py", "def", "get_pixeldata", "dicom_dataset", "use", "the", "gdcm", "package", "to", "decode", "the", "pixeldata", "attribute", "returns", "numpy", "ndarray", "a", "correctly", "sized", "but", "not", "shaped", "numpy", "array", "of", "the", "entire", "data", "volume", "raises", "importerror", "if", "the", "required", "packages", "are", "not", "available", "typeerror", "if", "the", "image", "could", "not", "be", "read", "by", "gdcm", "if", "the", "pixel", "data", "type", "is", "unsupported", "attributeerror", "if", "the", "decoded", "amount", "of", "data", "does", "not", "match", "the", "expected", "amount", "if", "not", "have_gdcm", "msg", "gdcm", "requires", "both", "the", "gdcm", "package", "and", "numpy", "and", "one", "or", "more", "could", "not", "be", "imported", "raise", "importerror", "msg", "if", "have_gdcm_in_memory_support", "gdcm_data_element", "create_data_element", "dicom_dataset", "gdcm_image", "create_image", "dicom_dataset", "gdcm_data_element", "else", "gdcm_image_reader", "create_image_reader", "dicom_dataset", "filename", "if", "not", "gdcm_image_reader", "read", "raise", "typeerror", "gdcm", "could", "not", "read", "dicom", "image", "gdcm_image", "gdcm_image_reader", "getimage", "gdcm", "returns", "char", "as", "type", "str", "under", "python", "2", "str", "are", "byte", "arrays", "by", "default", "python", "3", "decodes", "this", "to", "unicode", "strings", "by", "default", "the", "swig", "docs", "mention", "that", "they", "always", "decode", "byte", "streams", "as", "utf", "8", "strings", "for", "python", "3", "with", "the", "surrogateescape", "error", "handler", "configured", "therefore", "we", "can", "encode", "them", "back", "to", "their", "original", "bytearray", "representation", "on", "python", "3", "by", "using", "the", "same", "parameters", "if", "compat", "in_py2", "pixel_bytearray", "gdcm_image", "getbuffer", "else", "pixel_bytearray", "gdcm_image", "getbuffer", "encode", "utf", "8", "surrogateescape", "here", "we", "need", "to", "be", "careful", "because", "in", "some", "cases", "gdcm", "reads", "a", "buffer", "that", "is", "too", "large", "so", "we", "need", "to", "make", "sure", "we", "only", "include", "the", "first", "n_rows", "n_columns", "dtype_size", "bytes", "expected_length_bytes", "get_expected_length", "dicom_dataset", "if", "len", "pixel_bytearray", "expected_length_bytes", "we", "make", "sure", "that", "all", "the", "bytes", "after", "are", "in", "fact", "zeros", "padding", "pixel_bytearray", "expected_length_bytes", "if", "numpy", "any", "numpy", "frombuffer", "padding", "numpy", "byte", "pixel_bytearray", "pixel_bytearray", "expected_length_bytes", "else", "we", "revert", "to", "the", "old", "behavior", "which", "should", "then", "result", "in", "a", "numpy", "error", "later", "on", "pass", "numpy_dtype", "pixel_dtype", "dicom_dataset", "pixel_array", "numpy", "frombuffer", "pixel_bytearray", "dtype", "numpy_dtype", "expected_length_pixels", "get_expected_length", "dicom_dataset", "pixels", "if", "pixel_array", "size", "expected_length_pixels", "raise", "attributeerror", "amount", "of", "pixel", "data", "d", "does", "not", "match", "the", "expected", "data", "d", "pixel_array", "size", "expected_length_pixels", "if", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "dicom_dataset", "photometricinterpretation", "rgb", "return", "pixel_array", "copy"], "doc_len": 330}
{"doc_id": "pydicom/pixel_data_handlers/jpeg_ls_handler.py::is_available", "file_path": "pydicom/pixel_data_handlers/jpeg_ls_handler.py", "class_name": null, "func_name": "is_available", "text": "文件路径: pydicom/pixel_data_handlers/jpeg_ls_handler.py\ndef is_available():\n    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n    return HAVE_NP and HAVE_JPEGLS\n", "tokens": ["pydicom", "pixel_data_handlers", "jpeg_ls_handler", "py", "def", "is_available", "return", "true", "if", "the", "handler", "has", "its", "dependencies", "met", "return", "have_np", "and", "have_jpegls"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/jpeg_ls_handler.py::needs_to_convert_to_RGB", "file_path": "pydicom/pixel_data_handlers/jpeg_ls_handler.py", "class_name": null, "func_name": "needs_to_convert_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/jpeg_ls_handler.py\ndef needs_to_convert_to_RGB(dicom_dataset):\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "jpeg_ls_handler", "py", "def", "needs_to_convert_to_rgb", "dicom_dataset", "return", "false"], "doc_len": 9}
{"doc_id": "pydicom/pixel_data_handlers/jpeg_ls_handler.py::should_change_PhotometricInterpretation_to_RGB", "file_path": "pydicom/pixel_data_handlers/jpeg_ls_handler.py", "class_name": null, "func_name": "should_change_PhotometricInterpretation_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/jpeg_ls_handler.py\ndef should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n    should_change = dicom_dataset.SamplesPerPixel == 3\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "jpeg_ls_handler", "py", "def", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "should_change", "dicom_dataset", "samplesperpixel", "3", "return", "false"], "doc_len": 13}
{"doc_id": "pydicom/pixel_data_handlers/jpeg_ls_handler.py::supports_transfer_syntax", "file_path": "pydicom/pixel_data_handlers/jpeg_ls_handler.py", "class_name": null, "func_name": "supports_transfer_syntax", "text": "文件路径: pydicom/pixel_data_handlers/jpeg_ls_handler.py\ndef supports_transfer_syntax(transfer_syntax):\n    \"\"\"\n    Returns\n    -------\n    bool\n        True if this pixel data handler might support this transfer syntax.\n\n        False to prevent any attempt to try to use this handler\n        to decode the given transfer syntax\n    \"\"\"\n    return transfer_syntax in SUPPORTED_TRANSFER_SYNTAXES\n", "tokens": ["pydicom", "pixel_data_handlers", "jpeg_ls_handler", "py", "def", "supports_transfer_syntax", "transfer_syntax", "returns", "bool", "true", "if", "this", "pixel", "data", "handler", "might", "support", "this", "transfer", "syntax", "false", "to", "prevent", "any", "attempt", "to", "try", "to", "use", "this", "handler", "to", "decode", "the", "given", "transfer", "syntax", "return", "transfer_syntax", "in", "supported_transfer_syntaxes"], "doc_len": 41}
{"doc_id": "pydicom/pixel_data_handlers/jpeg_ls_handler.py::get_pixeldata", "file_path": "pydicom/pixel_data_handlers/jpeg_ls_handler.py", "class_name": null, "func_name": "get_pixeldata", "text": "文件路径: pydicom/pixel_data_handlers/jpeg_ls_handler.py\ndef get_pixeldata(dicom_dataset):\n    \"\"\"\n    Use the jpeg_ls package to decode the PixelData attribute\n\n    Returns\n    -------\n    numpy.ndarray\n\n        A correctly sized (but not shaped) numpy array\n        of the entire data volume\n\n    Raises\n    ------\n    ImportError\n        if the required packages are not available\n\n    NotImplementedError\n        if the transfer syntax is not supported\n\n    TypeError\n        if the pixel data type is unsupported\n    \"\"\"\n    if (dicom_dataset.file_meta.TransferSyntaxUID\n            not in SUPPORTED_TRANSFER_SYNTAXES):\n        msg = (\"The jpeg_ls does not support \"\n               \"this transfer syntax {0}.\".format(\n                   dicom_dataset.file_meta.TransferSyntaxUID.name))\n        raise NotImplementedError(msg)\n\n    if not HAVE_JPEGLS:\n        msg = (\"The jpeg_ls package is required to use pixel_array \"\n               \"for this transfer syntax {0}, and jpeg_ls could not \"\n               \"be imported.\".format(\n                   dicom_dataset.file_meta.TransferSyntaxUID.name))\n        raise ImportError(msg)\n    # Make NumPy format code, e.g. \"uint16\", \"int32\" etc\n    # from two pieces of info:\n    # dicom_dataset.PixelRepresentation -- 0 for unsigned, 1 for signed;\n    # dicom_dataset.BitsAllocated -- 8, 16, or 32\n    if dicom_dataset.PixelRepresentation == 0:\n        format_str = 'uint{}'.format(dicom_dataset.BitsAllocated)\n    elif dicom_dataset.PixelRepresentation == 1:\n        format_str = 'int{}'.format(dicom_dataset.BitsAllocated)\n    else:\n        format_str = 'bad_pixel_representation'\n    try:\n        numpy_format = numpy.dtype(format_str)\n    except TypeError:\n        msg = (\"Data type not understood by NumPy: \"\n               \"format='{}', PixelRepresentation={}, \"\n               \"BitsAllocated={}\".format(\n                   format_str,\n                   dicom_dataset.PixelRepresentation,\n                   dicom_dataset.BitsAllocated))\n        raise TypeError(msg)\n\n    numpy_format = dtype_corrected_for_endianness(\n        dicom_dataset.is_little_endian, numpy_format)\n\n    # decompress here\n    UncompressedPixelData = bytearray()\n    if ('NumberOfFrames' in dicom_dataset and\n            dicom_dataset.NumberOfFrames > 1):\n        # multiple compressed frames\n        CompressedPixelDataSeq = pydicom.encaps.decode_data_sequence(\n            dicom_dataset.PixelData)\n        # print len(CompressedPixelDataSeq)\n        for frame in CompressedPixelDataSeq:\n            decompressed_image = jpeg_ls.decode(\n                numpy.frombuffer(frame, dtype=numpy.uint8))\n            UncompressedPixelData.extend(decompressed_image.tobytes())\n    else:\n        # single compressed frame\n        CompressedPixelData = pydicom.encaps.defragment_data(\n            dicom_dataset.PixelData)\n        decompressed_image = jpeg_ls.decode(\n            numpy.frombuffer(CompressedPixelData, dtype=numpy.uint8))\n        UncompressedPixelData.extend(decompressed_image.tobytes())\n\n    pixel_array = numpy.frombuffer(UncompressedPixelData, numpy_format)\n    if should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n        dicom_dataset.PhotometricInterpretation = \"RGB\"\n\n    return pixel_array\n", "tokens": ["pydicom", "pixel_data_handlers", "jpeg_ls_handler", "py", "def", "get_pixeldata", "dicom_dataset", "use", "the", "jpeg_ls", "package", "to", "decode", "the", "pixeldata", "attribute", "returns", "numpy", "ndarray", "a", "correctly", "sized", "but", "not", "shaped", "numpy", "array", "of", "the", "entire", "data", "volume", "raises", "importerror", "if", "the", "required", "packages", "are", "not", "available", "notimplementederror", "if", "the", "transfer", "syntax", "is", "not", "supported", "typeerror", "if", "the", "pixel", "data", "type", "is", "unsupported", "if", "dicom_dataset", "file_meta", "transfersyntaxuid", "not", "in", "supported_transfer_syntaxes", "msg", "the", "jpeg_ls", "does", "not", "support", "this", "transfer", "syntax", "0", "format", "dicom_dataset", "file_meta", "transfersyntaxuid", "name", "raise", "notimplementederror", "msg", "if", "not", "have_jpegls", "msg", "the", "jpeg_ls", "package", "is", "required", "to", "use", "pixel_array", "for", "this", "transfer", "syntax", "0", "and", "jpeg_ls", "could", "not", "be", "imported", "format", "dicom_dataset", "file_meta", "transfersyntaxuid", "name", "raise", "importerror", "msg", "make", "numpy", "format", "code", "e", "g", "uint16", "int32", "etc", "from", "two", "pieces", "of", "info", "dicom_dataset", "pixelrepresentation", "0", "for", "unsigned", "1", "for", "signed", "dicom_dataset", "bitsallocated", "8", "16", "or", "32", "if", "dicom_dataset", "pixelrepresentation", "0", "format_str", "uint", "format", "dicom_dataset", "bitsallocated", "elif", "dicom_dataset", "pixelrepresentation", "1", "format_str", "int", "format", "dicom_dataset", "bitsallocated", "else", "format_str", "bad_pixel_representation", "try", "numpy_format", "numpy", "dtype", "format_str", "except", "typeerror", "msg", "data", "type", "not", "understood", "by", "numpy", "format", "pixelrepresentation", "bitsallocated", "format", "format_str", "dicom_dataset", "pixelrepresentation", "dicom_dataset", "bitsallocated", "raise", "typeerror", "msg", "numpy_format", "dtype_corrected_for_endianness", "dicom_dataset", "is_little_endian", "numpy_format", "decompress", "here", "uncompressedpixeldata", "bytearray", "if", "numberofframes", "in", "dicom_dataset", "and", "dicom_dataset", "numberofframes", "1", "multiple", "compressed", "frames", "compressedpixeldataseq", "pydicom", "encaps", "decode_data_sequence", "dicom_dataset", "pixeldata", "print", "len", "compressedpixeldataseq", "for", "frame", "in", "compressedpixeldataseq", "decompressed_image", "jpeg_ls", "decode", "numpy", "frombuffer", "frame", "dtype", "numpy", "uint8", "uncompressedpixeldata", "extend", "decompressed_image", "tobytes", "else", "single", "compressed", "frame", "compressedpixeldata", "pydicom", "encaps", "defragment_data", "dicom_dataset", "pixeldata", "decompressed_image", "jpeg_ls", "decode", "numpy", "frombuffer", "compressedpixeldata", "dtype", "numpy", "uint8", "uncompressedpixeldata", "extend", "decompressed_image", "tobytes", "pixel_array", "numpy", "frombuffer", "uncompressedpixeldata", "numpy_format", "if", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "dicom_dataset", "photometricinterpretation", "rgb", "return", "pixel_array"], "doc_len": 270}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::is_available", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "is_available", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef is_available():\n    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n    return HAVE_NP\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "is_available", "return", "true", "if", "the", "handler", "has", "its", "dependencies", "met", "return", "have_np"], "doc_len": 17}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::supports_transfer_syntax", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "supports_transfer_syntax", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef supports_transfer_syntax(transfer_syntax):\n    \"\"\"Return True if the handler supports the `transfer_syntax`.\n\n    Parameters\n    ----------\n    transfer_syntax : UID\n        The Transfer Syntax UID of the Pixel Data that is to be used with\n        the handler.\n    \"\"\"\n    return transfer_syntax in SUPPORTED_TRANSFER_SYNTAXES\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "supports_transfer_syntax", "transfer_syntax", "return", "true", "if", "the", "handler", "supports", "the", "transfer_syntax", "parameters", "transfer_syntax", "uid", "the", "transfer", "syntax", "uid", "of", "the", "pixel", "data", "that", "is", "to", "be", "used", "with", "the", "handler", "return", "transfer_syntax", "in", "supported_transfer_syntaxes"], "doc_len": 38}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::needs_to_convert_to_RGB", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "needs_to_convert_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef needs_to_convert_to_RGB(ds):\n    \"\"\"Return True if the pixel data should to be converted from YCbCr to RGB.\n\n    This affects JPEG transfer syntaxes.\n    \"\"\"\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "needs_to_convert_to_rgb", "ds", "return", "true", "if", "the", "pixel", "data", "should", "to", "be", "converted", "from", "ycbcr", "to", "rgb", "this", "affects", "jpeg", "transfer", "syntaxes", "return", "false"], "doc_len": 28}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::should_change_PhotometricInterpretation_to_RGB", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "should_change_PhotometricInterpretation_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef should_change_PhotometricInterpretation_to_RGB(ds):\n    \"\"\"Return True if the PhotometricInterpretation should be changed to RGB.\n\n    This affects JPEG transfer syntaxes.\n    \"\"\"\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "should_change_photometricinterpretation_to_rgb", "ds", "return", "true", "if", "the", "photometricinterpretation", "should", "be", "changed", "to", "rgb", "this", "affects", "jpeg", "transfer", "syntaxes", "return", "false"], "doc_len": 24}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::pack_bits", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "pack_bits", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef pack_bits(arr):\n    \"\"\"Pack a binary numpy ndarray into bytes for use with Pixel Data.\n\n    Should be used in conjunction with (0028,0100) *BitsAllocated* = 1.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        The ndarray containing 1-bit data as ints. The array must only contain\n        integer values of 0 and 1 and must have an 'uint' or 'int' dtype. For\n        the sake of efficiency its recommended that the array length be a\n        multiple of 8 (i.e. that any empty bit-padding to round out the byte\n        has already been added).\n\n    Returns\n    -------\n    bytes\n        The bit packed data.\n\n    Raises\n    ------\n    ValueError\n        If `arr` contains anything other than 0 or 1.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Section 8.1.1 and Annex D\n    \"\"\"\n    if arr.shape == (0,):\n        return bytes()\n\n    # Test array\n    if not np.array_equal(arr, arr.astype(bool)):\n        raise ValueError(\n            \"Only binary arrays (containing ones or zeroes) can be packed.\"\n        )\n\n    if len(arr.shape) > 1:\n        raise ValueError(\"Only 1D arrays are supported.\")\n\n    # The array length must be a multiple of 8, pad the end\n    if arr.shape[0] % 8:\n        arr = np.append(arr, np.zeros(8 - arr.shape[0] % 8))\n\n    # Reshape so each row is 8 bits\n    arr = np.reshape(arr, (-1, 8))\n    arr = np.fliplr(arr)\n    arr = np.packbits(arr.astype('uint8'))\n\n    return arr.tobytes()\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "pack_bits", "arr", "pack", "a", "binary", "numpy", "ndarray", "into", "bytes", "for", "use", "with", "pixel", "data", "should", "be", "used", "in", "conjunction", "with", "0028", "0100", "bitsallocated", "1", "parameters", "arr", "numpy", "ndarray", "the", "ndarray", "containing", "1", "bit", "data", "as", "ints", "the", "array", "must", "only", "contain", "integer", "values", "of", "0", "and", "1", "and", "must", "have", "an", "uint", "or", "int", "dtype", "for", "the", "sake", "of", "efficiency", "its", "recommended", "that", "the", "array", "length", "be", "a", "multiple", "of", "8", "i", "e", "that", "any", "empty", "bit", "padding", "to", "round", "out", "the", "byte", "has", "already", "been", "added", "returns", "bytes", "the", "bit", "packed", "data", "raises", "valueerror", "if", "arr", "contains", "anything", "other", "than", "0", "or", "1", "references", "dicom", "standard", "part", "5", "section", "8", "1", "1", "and", "annex", "d", "if", "arr", "shape", "0", "return", "bytes", "test", "array", "if", "not", "np", "array_equal", "arr", "arr", "astype", "bool", "raise", "valueerror", "only", "binary", "arrays", "containing", "ones", "or", "zeroes", "can", "be", "packed", "if", "len", "arr", "shape", "1", "raise", "valueerror", "only", "1d", "arrays", "are", "supported", "the", "array", "length", "must", "be", "a", "multiple", "of", "8", "pad", "the", "end", "if", "arr", "shape", "0", "8", "arr", "np", "append", "arr", "np", "zeros", "8", "arr", "shape", "0", "8", "reshape", "so", "each", "row", "is", "8", "bits", "arr", "np", "reshape", "arr", "1", "8", "arr", "np", "fliplr", "arr", "arr", "np", "packbits", "arr", "astype", "uint8", "return", "arr", "tobytes"], "doc_len": 215}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::unpack_bits", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "unpack_bits", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef unpack_bits(bytestream):\n    \"\"\"Unpack bit packed pixel data into a numpy ndarray.\n\n    Suitable for use when (0028,0011) *Bits Allocated* is 1.\n\n    Parameters\n    ----------\n    bytestream : bytes\n        The bit packed pixel data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The unpacked pixel data as a 1D array.\n\n    Notes\n    -----\n    The implementation for PyPy is roughly 100 times slower than the\n    standard ``numpy.unpackbits`` method.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Section 8.1.1 and Annex D\n    \"\"\"\n    # Thanks to @sbrodehl (#643)\n    # e.g. b'\\xC0\\x09' -> [192, 9]\n    arr = np.frombuffer(bytestream, dtype='uint8')\n    # -> [1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1]\n    arr = np.unpackbits(arr)\n    # -> [[1 1 0 0 0 0 0 0],\n    #     [0 0 0 0 1 0 0 1]]\n    arr = np.reshape(arr, (-1, 8))\n    # -> [[0 0 0 0 0 0 1 1],\n    #     [1 0 0 1 0 0 0 0]]\n    arr = np.fliplr(arr)\n    # -> [0 0 0 0 0 0 1 1 1 0 0 1 0 0 0 0]\n    arr = np.ravel(arr)\n\n    return arr\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "unpack_bits", "bytestream", "unpack", "bit", "packed", "pixel", "data", "into", "a", "numpy", "ndarray", "suitable", "for", "use", "when", "0028", "0011", "bits", "allocated", "is", "1", "parameters", "bytestream", "bytes", "the", "bit", "packed", "pixel", "data", "returns", "numpy", "ndarray", "the", "unpacked", "pixel", "data", "as", "a", "1d", "array", "notes", "the", "implementation", "for", "pypy", "is", "roughly", "100", "times", "slower", "than", "the", "standard", "numpy", "unpackbits", "method", "references", "dicom", "standard", "part", "5", "section", "8", "1", "1", "and", "annex", "d", "thanks", "to", "sbrodehl", "643", "e", "g", "b", "xc0", "x09", "192", "9", "arr", "np", "frombuffer", "bytestream", "dtype", "uint8", "1", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "arr", "np", "unpackbits", "arr", "1", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "arr", "np", "reshape", "arr", "1", "8", "0", "0", "0", "0", "0", "0", "1", "1", "1", "0", "0", "1", "0", "0", "0", "0", "arr", "np", "fliplr", "arr", "0", "0", "0", "0", "0", "0", "1", "1", "1", "0", "0", "1", "0", "0", "0", "0", "arr", "np", "ravel", "arr", "return", "arr"], "doc_len": 174}
{"doc_id": "pydicom/pixel_data_handlers/numpy_handler.py::get_pixeldata", "file_path": "pydicom/pixel_data_handlers/numpy_handler.py", "class_name": null, "func_name": "get_pixeldata", "text": "文件路径: pydicom/pixel_data_handlers/numpy_handler.py\ndef get_pixeldata(ds, read_only=False):\n    \"\"\"Return an ndarray of the Pixel Data.\n\n    Parameters\n    ----------\n    ds : dataset.Dataset\n        The DICOM dataset containing an Image Pixel module and the Pixel Data\n        to be converted.\n    read_only : bool, optional\n        If False (default) then returns a writeable array that no longer uses\n        the original memory. If True and the value of (0028,0100) *Bits\n        Allocated* > 1 then returns a read-only array that uses the original\n        memory buffer of the pixel data. If *Bits Allocated* = 1 then always\n        returns a writeable array.\n\n    Returns\n    -------\n    np.ndarray\n        The contents of the Pixel Data element (7FE0,0010) as a 1D array.\n\n    Raises\n    ------\n    AttributeError\n        If the dataset is missing a required element.\n    NotImplementedError\n        If the dataset contains pixel data in an unsupported format.\n    ValueError\n        If the actual length of the pixel data doesn't match the expected\n        length.\n    \"\"\"\n    transfer_syntax = ds.file_meta.TransferSyntaxUID\n    # The check of transfer syntax must be first\n    if transfer_syntax not in SUPPORTED_TRANSFER_SYNTAXES:\n        raise NotImplementedError(\n            \"Unable to convert the pixel data as the transfer syntax \"\n            \"is not supported by the numpy pixel data handler.\"\n        )\n\n    # Check required elements\n    required_elements = ['PixelData', 'BitsAllocated', 'Rows', 'Columns',\n                         'PixelRepresentation', 'SamplesPerPixel']\n    missing = [elem for elem in required_elements if elem not in ds]\n    if missing:\n        raise AttributeError(\n            \"Unable to convert the pixel data as the following required \"\n            \"elements are missing from the dataset: \" + \", \".join(missing)\n        )\n\n    # Calculate the expected length of the pixel data (in bytes)\n    #   Note: this does NOT include the trailing null byte for odd length data\n    expected_len = get_expected_length(ds)\n\n    # Check that the actual length of the pixel data is as expected\n    actual_length = len(ds.PixelData)\n    # Correct for the trailing NULL byte padding for odd length data\n\n    padded_expected_len = expected_len + expected_len % 2\n    if actual_length < padded_expected_len:\n        if actual_length == expected_len:\n            warnings.warn(\n                \"The pixel data length is odd and misses a padding byte.\")\n        else:\n            raise ValueError(\n                \"The length of the pixel data in the dataset ({} bytes) \"\n                \"doesn't match the expected length ({} bytes). \"\n                \"The dataset may be corrupted or there may be an issue \"\n                \"with the pixel data handler.\"\n                .format(actual_length, padded_expected_len)\n            )\n    elif actual_length > padded_expected_len:\n        # PS 3.5, Section 8.1.1\n        msg = (\n            \"The length of the pixel data in the dataset ({} bytes) indicates \"\n            \"it contains excess padding. {} bytes will be removed from the \"\n            \"end of the data\"\n            .format(actual_length, actual_length - expected_len)\n        )\n        warnings.warn(msg)\n\n    # Unpack the pixel data into a 1D ndarray\n    if ds.BitsAllocated == 1:\n        # Skip any trailing padding bits\n        nr_pixels = get_expected_length(ds, unit='pixels')\n        arr = unpack_bits(ds.PixelData)[:nr_pixels]\n    else:\n        # Skip the trailing padding byte if present\n        arr = np.frombuffer(ds.PixelData[:expected_len],\n                            dtype=pixel_dtype(ds))\n\n    if should_change_PhotometricInterpretation_to_RGB(ds):\n        ds.PhotometricInterpretation = \"RGB\"\n\n    if not read_only and ds.BitsAllocated > 1:\n        return arr.copy()\n\n    return arr\n", "tokens": ["pydicom", "pixel_data_handlers", "numpy_handler", "py", "def", "get_pixeldata", "ds", "read_only", "false", "return", "an", "ndarray", "of", "the", "pixel", "data", "parameters", "ds", "dataset", "dataset", "the", "dicom", "dataset", "containing", "an", "image", "pixel", "module", "and", "the", "pixel", "data", "to", "be", "converted", "read_only", "bool", "optional", "if", "false", "default", "then", "returns", "a", "writeable", "array", "that", "no", "longer", "uses", "the", "original", "memory", "if", "true", "and", "the", "value", "of", "0028", "0100", "bits", "allocated", "1", "then", "returns", "a", "read", "only", "array", "that", "uses", "the", "original", "memory", "buffer", "of", "the", "pixel", "data", "if", "bits", "allocated", "1", "then", "always", "returns", "a", "writeable", "array", "returns", "np", "ndarray", "the", "contents", "of", "the", "pixel", "data", "element", "7fe0", "0010", "as", "a", "1d", "array", "raises", "attributeerror", "if", "the", "dataset", "is", "missing", "a", "required", "element", "notimplementederror", "if", "the", "dataset", "contains", "pixel", "data", "in", "an", "unsupported", "format", "valueerror", "if", "the", "actual", "length", "of", "the", "pixel", "data", "doesn", "t", "match", "the", "expected", "length", "transfer_syntax", "ds", "file_meta", "transfersyntaxuid", "the", "check", "of", "transfer", "syntax", "must", "be", "first", "if", "transfer_syntax", "not", "in", "supported_transfer_syntaxes", "raise", "notimplementederror", "unable", "to", "convert", "the", "pixel", "data", "as", "the", "transfer", "syntax", "is", "not", "supported", "by", "the", "numpy", "pixel", "data", "handler", "check", "required", "elements", "required_elements", "pixeldata", "bitsallocated", "rows", "columns", "pixelrepresentation", "samplesperpixel", "missing", "elem", "for", "elem", "in", "required_elements", "if", "elem", "not", "in", "ds", "if", "missing", "raise", "attributeerror", "unable", "to", "convert", "the", "pixel", "data", "as", "the", "following", "required", "elements", "are", "missing", "from", "the", "dataset", "join", "missing", "calculate", "the", "expected", "length", "of", "the", "pixel", "data", "in", "bytes", "note", "this", "does", "not", "include", "the", "trailing", "null", "byte", "for", "odd", "length", "data", "expected_len", "get_expected_length", "ds", "check", "that", "the", "actual", "length", "of", "the", "pixel", "data", "is", "as", "expected", "actual_length", "len", "ds", "pixeldata", "correct", "for", "the", "trailing", "null", "byte", "padding", "for", "odd", "length", "data", "padded_expected_len", "expected_len", "expected_len", "2", "if", "actual_length", "padded_expected_len", "if", "actual_length", "expected_len", "warnings", "warn", "the", "pixel", "data", "length", "is", "odd", "and", "misses", "a", "padding", "byte", "else", "raise", "valueerror", "the", "length", "of", "the", "pixel", "data", "in", "the", "dataset", "bytes", "doesn", "t", "match", "the", "expected", "length", "bytes", "the", "dataset", "may", "be", "corrupted", "or", "there", "may", "be", "an", "issue", "with", "the", "pixel", "data", "handler", "format", "actual_length", "padded_expected_len", "elif", "actual_length", "padded_expected_len", "ps", "3", "5", "section", "8", "1", "1", "msg", "the", "length", "of", "the", "pixel", "data", "in", "the", "dataset", "bytes", "indicates", "it", "contains", "excess", "padding", "bytes", "will", "be", "removed", "from", "the", "end", "of", "the", "data", "format", "actual_length", "actual_length", "expected_len", "warnings", "warn", "msg", "unpack", "the", "pixel", "data", "into", "a", "1d", "ndarray", "if", "ds", "bitsallocated", "1", "skip", "any", "trailing", "padding", "bits", "nr_pixels", "get_expected_length", "ds", "unit", "pixels", "arr", "unpack_bits", "ds", "pixeldata", "nr_pixels", "else", "skip", "the", "trailing", "padding", "byte", "if", "present", "arr", "np", "frombuffer", "ds", "pixeldata", "expected_len", "dtype", "pixel_dtype", "ds", "if", "should_change_photometricinterpretation_to_rgb", "ds", "ds", "photometricinterpretation", "rgb", "if", "not", "read_only", "and", "ds", "bitsallocated", "1", "return", "arr", "copy", "return", "arr"], "doc_len": 443}
{"doc_id": "pydicom/pixel_data_handlers/pillow_handler.py::is_available", "file_path": "pydicom/pixel_data_handlers/pillow_handler.py", "class_name": null, "func_name": "is_available", "text": "文件路径: pydicom/pixel_data_handlers/pillow_handler.py\ndef is_available():\n    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n    return HAVE_NP and HAVE_PIL\n", "tokens": ["pydicom", "pixel_data_handlers", "pillow_handler", "py", "def", "is_available", "return", "true", "if", "the", "handler", "has", "its", "dependencies", "met", "return", "have_np", "and", "have_pil"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/pillow_handler.py::supports_transfer_syntax", "file_path": "pydicom/pixel_data_handlers/pillow_handler.py", "class_name": null, "func_name": "supports_transfer_syntax", "text": "文件路径: pydicom/pixel_data_handlers/pillow_handler.py\ndef supports_transfer_syntax(transfer_syntax):\n    \"\"\"\n    Returns\n    -------\n    bool\n        True if this pixel data handler might support this transfer syntax.\n\n        False to prevent any attempt to try to use this handler\n        to decode the given transfer syntax\n    \"\"\"\n    return transfer_syntax in PillowSupportedTransferSyntaxes\n", "tokens": ["pydicom", "pixel_data_handlers", "pillow_handler", "py", "def", "supports_transfer_syntax", "transfer_syntax", "returns", "bool", "true", "if", "this", "pixel", "data", "handler", "might", "support", "this", "transfer", "syntax", "false", "to", "prevent", "any", "attempt", "to", "try", "to", "use", "this", "handler", "to", "decode", "the", "given", "transfer", "syntax", "return", "transfer_syntax", "in", "pillowsupportedtransfersyntaxes"], "doc_len": 41}
{"doc_id": "pydicom/pixel_data_handlers/pillow_handler.py::needs_to_convert_to_RGB", "file_path": "pydicom/pixel_data_handlers/pillow_handler.py", "class_name": null, "func_name": "needs_to_convert_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/pillow_handler.py\ndef needs_to_convert_to_RGB(dicom_dataset):\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "pillow_handler", "py", "def", "needs_to_convert_to_rgb", "dicom_dataset", "return", "false"], "doc_len": 9}
{"doc_id": "pydicom/pixel_data_handlers/pillow_handler.py::should_change_PhotometricInterpretation_to_RGB", "file_path": "pydicom/pixel_data_handlers/pillow_handler.py", "class_name": null, "func_name": "should_change_PhotometricInterpretation_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/pillow_handler.py\ndef should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n    should_change = dicom_dataset.SamplesPerPixel == 3\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "pillow_handler", "py", "def", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "should_change", "dicom_dataset", "samplesperpixel", "3", "return", "false"], "doc_len": 13}
{"doc_id": "pydicom/pixel_data_handlers/pillow_handler.py::get_pixeldata", "file_path": "pydicom/pixel_data_handlers/pillow_handler.py", "class_name": null, "func_name": "get_pixeldata", "text": "文件路径: pydicom/pixel_data_handlers/pillow_handler.py\ndef get_pixeldata(dicom_dataset):\n    \"\"\"Use Pillow to decompress compressed Pixel Data.\n\n    Returns\n    -------\n    numpy.ndarray\n       The contents of the Pixel Data element (7FE0,0010) as an ndarray.\n\n    Raises\n    ------\n    ImportError\n        If PIL is not available.\n\n    NotImplementedError\n        if the transfer syntax is not supported\n\n    TypeError\n        if the pixel data type is unsupported\n    \"\"\"\n    logger.debug(\"Trying to use Pillow to read pixel array \"\n                 \"(has pillow = %s)\", HAVE_PIL)\n    transfer_syntax = dicom_dataset.file_meta.TransferSyntaxUID\n    if not HAVE_PIL:\n        msg = (\"The pillow package is required to use pixel_array for \"\n               \"this transfer syntax {0}, and pillow could not be \"\n               \"imported.\".format(transfer_syntax.name))\n        raise ImportError(msg)\n\n    if not HAVE_JPEG and transfer_syntax in PillowJPEGTransferSyntaxes:\n        msg = (\"this transfer syntax {0}, can not be read because \"\n               \"Pillow lacks the jpeg decoder plugin\"\n               .format(transfer_syntax.name))\n        raise NotImplementedError(msg)\n\n    if not HAVE_JPEG2K and transfer_syntax in PillowJPEG2000TransferSyntaxes:\n        msg = (\"this transfer syntax {0}, can not be read because \"\n               \"Pillow lacks the jpeg 2000 decoder plugin\"\n               .format(transfer_syntax.name))\n        raise NotImplementedError(msg)\n\n    if transfer_syntax not in PillowSupportedTransferSyntaxes:\n        msg = (\"this transfer syntax {0}, can not be read because \"\n               \"Pillow does not support this syntax\"\n               .format(transfer_syntax.name))\n        raise NotImplementedError(msg)\n\n    # Make NumPy format code, e.g. \"uint16\", \"int32\" etc\n    # from two pieces of info:\n    # dicom_dataset.PixelRepresentation -- 0 for unsigned, 1 for signed;\n    # dicom_dataset.BitsAllocated -- 8, 16, or 32\n    if dicom_dataset.PixelRepresentation == 0:\n        format_str = 'uint{}'.format(dicom_dataset.BitsAllocated)\n    elif dicom_dataset.PixelRepresentation == 1:\n        format_str = 'int{}'.format(dicom_dataset.BitsAllocated)\n    else:\n        format_str = 'bad_pixel_representation'\n    try:\n        numpy_format = numpy.dtype(format_str)\n    except TypeError:\n        msg = (\"Data type not understood by NumPy: \"\n               \"format='{}', PixelRepresentation={}, \"\n               \"BitsAllocated={}\".format(\n                   format_str,\n                   dicom_dataset.PixelRepresentation,\n                   dicom_dataset.BitsAllocated))\n        raise TypeError(msg)\n\n    numpy_format = dtype_corrected_for_endianness(\n        dicom_dataset.is_little_endian, numpy_format)\n\n    # decompress here\n    if transfer_syntax in PillowJPEGTransferSyntaxes:\n        logger.debug(\"This is a JPEG lossy format\")\n        if dicom_dataset.BitsAllocated > 8:\n            raise NotImplementedError(\"JPEG Lossy only supported if \"\n                                      \"Bits Allocated = 8\")\n        generic_jpeg_file_header = b''\n        frame_start_from = 0\n    elif transfer_syntax in PillowJPEG2000TransferSyntaxes:\n        logger.debug(\"This is a JPEG 2000 format\")\n        generic_jpeg_file_header = b''\n        # generic_jpeg_file_header = b'\\x00\\x00\\x00\\x0C\\x6A'\n        #     b'\\x50\\x20\\x20\\x0D\\x0A\\x87\\x0A'\n        frame_start_from = 0\n    else:\n        logger.debug(\"This is a another pillow supported format\")\n        generic_jpeg_file_header = b''\n        frame_start_from = 0\n\n    try:\n        UncompressedPixelData = bytearray()\n        if ('NumberOfFrames' in dicom_dataset and\n                dicom_dataset.NumberOfFrames > 1):\n            # multiple compressed frames\n            CompressedPixelDataSeq = \\\n                pydicom.encaps.decode_data_sequence(\n                    dicom_dataset.PixelData)\n            for frame in CompressedPixelDataSeq:\n                data = generic_jpeg_file_header + \\\n                    frame[frame_start_from:]\n                fio = io.BytesIO(data)\n                try:\n                    decompressed_image = Image.open(fio)\n                except IOError as e:\n                    raise NotImplementedError(e.strerror)\n                UncompressedPixelData.extend(decompressed_image.tobytes())\n        else:\n            # single compressed frame\n            pixel_data = pydicom.encaps.defragment_data(\n                dicom_dataset.PixelData)\n            pixel_data = generic_jpeg_file_header + \\\n                pixel_data[frame_start_from:]\n            try:\n                fio = io.BytesIO(pixel_data)\n                decompressed_image = Image.open(fio)\n            except IOError as e:\n                raise NotImplementedError(e.strerror)\n            UncompressedPixelData.extend(decompressed_image.tobytes())\n    except Exception:\n        raise\n\n    logger.debug(\n        \"Successfully read %s pixel bytes\", len(UncompressedPixelData)\n    )\n\n    pixel_array = numpy.frombuffer(UncompressedPixelData, numpy_format)\n\n    if (transfer_syntax in\n            PillowJPEG2000TransferSyntaxes and\n            dicom_dataset.BitsStored == 16):\n        # WHY IS THIS EVEN NECESSARY??\n        pixel_array &= 0x7FFF\n\n    if should_change_PhotometricInterpretation_to_RGB(dicom_dataset):\n        dicom_dataset.PhotometricInterpretation = \"RGB\"\n\n    return pixel_array\n", "tokens": ["pydicom", "pixel_data_handlers", "pillow_handler", "py", "def", "get_pixeldata", "dicom_dataset", "use", "pillow", "to", "decompress", "compressed", "pixel", "data", "returns", "numpy", "ndarray", "the", "contents", "of", "the", "pixel", "data", "element", "7fe0", "0010", "as", "an", "ndarray", "raises", "importerror", "if", "pil", "is", "not", "available", "notimplementederror", "if", "the", "transfer", "syntax", "is", "not", "supported", "typeerror", "if", "the", "pixel", "data", "type", "is", "unsupported", "logger", "debug", "trying", "to", "use", "pillow", "to", "read", "pixel", "array", "has", "pillow", "s", "have_pil", "transfer_syntax", "dicom_dataset", "file_meta", "transfersyntaxuid", "if", "not", "have_pil", "msg", "the", "pillow", "package", "is", "required", "to", "use", "pixel_array", "for", "this", "transfer", "syntax", "0", "and", "pillow", "could", "not", "be", "imported", "format", "transfer_syntax", "name", "raise", "importerror", "msg", "if", "not", "have_jpeg", "and", "transfer_syntax", "in", "pillowjpegtransfersyntaxes", "msg", "this", "transfer", "syntax", "0", "can", "not", "be", "read", "because", "pillow", "lacks", "the", "jpeg", "decoder", "plugin", "format", "transfer_syntax", "name", "raise", "notimplementederror", "msg", "if", "not", "have_jpeg2k", "and", "transfer_syntax", "in", "pillowjpeg2000transfersyntaxes", "msg", "this", "transfer", "syntax", "0", "can", "not", "be", "read", "because", "pillow", "lacks", "the", "jpeg", "2000", "decoder", "plugin", "format", "transfer_syntax", "name", "raise", "notimplementederror", "msg", "if", "transfer_syntax", "not", "in", "pillowsupportedtransfersyntaxes", "msg", "this", "transfer", "syntax", "0", "can", "not", "be", "read", "because", "pillow", "does", "not", "support", "this", "syntax", "format", "transfer_syntax", "name", "raise", "notimplementederror", "msg", "make", "numpy", "format", "code", "e", "g", "uint16", "int32", "etc", "from", "two", "pieces", "of", "info", "dicom_dataset", "pixelrepresentation", "0", "for", "unsigned", "1", "for", "signed", "dicom_dataset", "bitsallocated", "8", "16", "or", "32", "if", "dicom_dataset", "pixelrepresentation", "0", "format_str", "uint", "format", "dicom_dataset", "bitsallocated", "elif", "dicom_dataset", "pixelrepresentation", "1", "format_str", "int", "format", "dicom_dataset", "bitsallocated", "else", "format_str", "bad_pixel_representation", "try", "numpy_format", "numpy", "dtype", "format_str", "except", "typeerror", "msg", "data", "type", "not", "understood", "by", "numpy", "format", "pixelrepresentation", "bitsallocated", "format", "format_str", "dicom_dataset", "pixelrepresentation", "dicom_dataset", "bitsallocated", "raise", "typeerror", "msg", "numpy_format", "dtype_corrected_for_endianness", "dicom_dataset", "is_little_endian", "numpy_format", "decompress", "here", "if", "transfer_syntax", "in", "pillowjpegtransfersyntaxes", "logger", "debug", "this", "is", "a", "jpeg", "lossy", "format", "if", "dicom_dataset", "bitsallocated", "8", "raise", "notimplementederror", "jpeg", "lossy", "only", "supported", "if", "bits", "allocated", "8", "generic_jpeg_file_header", "b", "frame_start_from", "0", "elif", "transfer_syntax", "in", "pillowjpeg2000transfersyntaxes", "logger", "debug", "this", "is", "a", "jpeg", "2000", "format", "generic_jpeg_file_header", "b", "generic_jpeg_file_header", "b", "x00", "x00", "x00", "x0c", "x6a", "b", "x50", "x20", "x20", "x0d", "x0a", "x87", "x0a", "frame_start_from", "0", "else", "logger", "debug", "this", "is", "a", "another", "pillow", "supported", "format", "generic_jpeg_file_header", "b", "frame_start_from", "0", "try", "uncompressedpixeldata", "bytearray", "if", "numberofframes", "in", "dicom_dataset", "and", "dicom_dataset", "numberofframes", "1", "multiple", "compressed", "frames", "compressedpixeldataseq", "pydicom", "encaps", "decode_data_sequence", "dicom_dataset", "pixeldata", "for", "frame", "in", "compressedpixeldataseq", "data", "generic_jpeg_file_header", "frame", "frame_start_from", "fio", "io", "bytesio", "data", "try", "decompressed_image", "image", "open", "fio", "except", "ioerror", "as", "e", "raise", "notimplementederror", "e", "strerror", "uncompressedpixeldata", "extend", "decompressed_image", "tobytes", "else", "single", "compressed", "frame", "pixel_data", "pydicom", "encaps", "defragment_data", "dicom_dataset", "pixeldata", "pixel_data", "generic_jpeg_file_header", "pixel_data", "frame_start_from", "try", "fio", "io", "bytesio", "pixel_data", "decompressed_image", "image", "open", "fio", "except", "ioerror", "as", "e", "raise", "notimplementederror", "e", "strerror", "uncompressedpixeldata", "extend", "decompressed_image", "tobytes", "except", "exception", "raise", "logger", "debug", "successfully", "read", "s", "pixel", "bytes", "len", "uncompressedpixeldata", "pixel_array", "numpy", "frombuffer", "uncompressedpixeldata", "numpy_format", "if", "transfer_syntax", "in", "pillowjpeg2000transfersyntaxes", "and", "dicom_dataset", "bitsstored", "16", "why", "is", "this", "even", "necessary", "pixel_array", "0x7fff", "if", "should_change_photometricinterpretation_to_rgb", "dicom_dataset", "dicom_dataset", "photometricinterpretation", "rgb", "return", "pixel_array"], "doc_len": 466}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::is_available", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "is_available", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef is_available():\n    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n    return HAVE_RLE\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "is_available", "return", "true", "if", "the", "handler", "has", "its", "dependencies", "met", "return", "have_rle"], "doc_len": 17}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::supports_transfer_syntax", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "supports_transfer_syntax", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef supports_transfer_syntax(transfer_syntax):\n    \"\"\"Return True if the handler supports the `transfer_syntax`.\"\"\"\n    return transfer_syntax in SUPPORTED_TRANSFER_SYNTAXES\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "supports_transfer_syntax", "transfer_syntax", "return", "true", "if", "the", "handler", "supports", "the", "transfer_syntax", "return", "transfer_syntax", "in", "supported_transfer_syntaxes"], "doc_len": 19}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::needs_to_convert_to_RGB", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "needs_to_convert_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef needs_to_convert_to_RGB(ds):\n    \"\"\"Return True if the pixel data should to be converted from YCbCr to RGB.\n\n    This affects JPEG transfer syntaxes.\n    \"\"\"\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "needs_to_convert_to_rgb", "ds", "return", "true", "if", "the", "pixel", "data", "should", "to", "be", "converted", "from", "ycbcr", "to", "rgb", "this", "affects", "jpeg", "transfer", "syntaxes", "return", "false"], "doc_len": 28}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::should_change_PhotometricInterpretation_to_RGB", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "should_change_PhotometricInterpretation_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef should_change_PhotometricInterpretation_to_RGB(ds):\n    \"\"\"Return True if the PhotometricInterpretation should be changed to RGB.\n\n    This affects JPEG transfer syntaxes.\n    \"\"\"\n    return False\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "should_change_photometricinterpretation_to_rgb", "ds", "return", "true", "if", "the", "photometricinterpretation", "should", "be", "changed", "to", "rgb", "this", "affects", "jpeg", "transfer", "syntaxes", "return", "false"], "doc_len": 24}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::get_pixeldata", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "get_pixeldata", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef get_pixeldata(ds, rle_segment_order='>'):\n    \"\"\"Return an ndarray of the Pixel Data.\n\n    Parameters\n    ----------\n    ds : dataset.Dataset\n        The DICOM dataset containing an Image Pixel module and the RLE encoded\n        Pixel Data to be converted.\n    rle_segment_order : str\n        The order of segments used by the RLE decoder when dealing with Bits\n        Allocated > 8. Each RLE segment contains 8-bits of the pixel data,\n        and segments are supposed to be ordered from MSB to LSB. A value of\n        '>' means interpret the segments as being in big endian order\n        (default) while a value of '<' means interpret the segments as being\n        in little endian order which may be possible if the encoded data is\n        non-conformant.\n\n    Returns\n    -------\n    np.ndarray\n        The decoded contents of the Pixel Data element (7FE0,0010) as a 1D\n        array.\n\n    Raises\n    ------\n    AttributeError\n        If the dataset is missing a required element.\n    NotImplementedError\n        If the dataset contains pixel data in an unsupported format.\n    ValueError\n        If the actual length of the pixel data doesn't match the expected\n        length.\n    \"\"\"\n    transfer_syntax = ds.file_meta.TransferSyntaxUID\n    # The check of transfer syntax must be first\n    if transfer_syntax not in SUPPORTED_TRANSFER_SYNTAXES:\n        raise NotImplementedError(\n            \"Unable to convert the pixel data as the transfer syntax \"\n            \"is not supported by the RLE pixel data handler.\"\n        )\n\n    # Check required elements\n    required_elements = ['PixelData', 'BitsAllocated', 'Rows', 'Columns',\n                         'PixelRepresentation', 'SamplesPerPixel']\n    missing = [elem for elem in required_elements if elem not in ds]\n    if missing:\n        raise AttributeError(\n            \"Unable to convert the pixel data as the following required \"\n            \"elements are missing from the dataset: \" + \", \".join(missing)\n        )\n\n    nr_bits = ds.BitsAllocated\n    nr_samples = ds.SamplesPerPixel\n    nr_frames = getattr(ds, 'NumberOfFrames', 1)\n    rows = ds.Rows\n    cols = ds.Columns\n\n    # Decompress each frame of the pixel data\n    pixel_data = bytearray()\n    if nr_frames > 1:\n        for rle_frame in decode_data_sequence(ds.PixelData):\n            frame = _rle_decode_frame(rle_frame, rows, cols, nr_samples,\n                                      nr_bits)\n            pixel_data.extend(frame)\n    else:\n        frame = _rle_decode_frame(defragment_data(ds.PixelData),\n                                  rows, cols, nr_samples, nr_bits)\n\n        pixel_data.extend(frame)\n\n    # The segment order should be big endian by default but make it possible\n    #   to switch if the RLE is non-conformant\n    dtype = pixel_dtype(ds).newbyteorder(rle_segment_order)\n    arr = np.frombuffer(pixel_data, dtype)\n\n    if should_change_PhotometricInterpretation_to_RGB(ds):\n        ds.PhotometricInterpretation = \"RGB\"\n\n    return arr\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "get_pixeldata", "ds", "rle_segment_order", "return", "an", "ndarray", "of", "the", "pixel", "data", "parameters", "ds", "dataset", "dataset", "the", "dicom", "dataset", "containing", "an", "image", "pixel", "module", "and", "the", "rle", "encoded", "pixel", "data", "to", "be", "converted", "rle_segment_order", "str", "the", "order", "of", "segments", "used", "by", "the", "rle", "decoder", "when", "dealing", "with", "bits", "allocated", "8", "each", "rle", "segment", "contains", "8", "bits", "of", "the", "pixel", "data", "and", "segments", "are", "supposed", "to", "be", "ordered", "from", "msb", "to", "lsb", "a", "value", "of", "means", "interpret", "the", "segments", "as", "being", "in", "big", "endian", "order", "default", "while", "a", "value", "of", "means", "interpret", "the", "segments", "as", "being", "in", "little", "endian", "order", "which", "may", "be", "possible", "if", "the", "encoded", "data", "is", "non", "conformant", "returns", "np", "ndarray", "the", "decoded", "contents", "of", "the", "pixel", "data", "element", "7fe0", "0010", "as", "a", "1d", "array", "raises", "attributeerror", "if", "the", "dataset", "is", "missing", "a", "required", "element", "notimplementederror", "if", "the", "dataset", "contains", "pixel", "data", "in", "an", "unsupported", "format", "valueerror", "if", "the", "actual", "length", "of", "the", "pixel", "data", "doesn", "t", "match", "the", "expected", "length", "transfer_syntax", "ds", "file_meta", "transfersyntaxuid", "the", "check", "of", "transfer", "syntax", "must", "be", "first", "if", "transfer_syntax", "not", "in", "supported_transfer_syntaxes", "raise", "notimplementederror", "unable", "to", "convert", "the", "pixel", "data", "as", "the", "transfer", "syntax", "is", "not", "supported", "by", "the", "rle", "pixel", "data", "handler", "check", "required", "elements", "required_elements", "pixeldata", "bitsallocated", "rows", "columns", "pixelrepresentation", "samplesperpixel", "missing", "elem", "for", "elem", "in", "required_elements", "if", "elem", "not", "in", "ds", "if", "missing", "raise", "attributeerror", "unable", "to", "convert", "the", "pixel", "data", "as", "the", "following", "required", "elements", "are", "missing", "from", "the", "dataset", "join", "missing", "nr_bits", "ds", "bitsallocated", "nr_samples", "ds", "samplesperpixel", "nr_frames", "getattr", "ds", "numberofframes", "1", "rows", "ds", "rows", "cols", "ds", "columns", "decompress", "each", "frame", "of", "the", "pixel", "data", "pixel_data", "bytearray", "if", "nr_frames", "1", "for", "rle_frame", "in", "decode_data_sequence", "ds", "pixeldata", "frame", "_rle_decode_frame", "rle_frame", "rows", "cols", "nr_samples", "nr_bits", "pixel_data", "extend", "frame", "else", "frame", "_rle_decode_frame", "defragment_data", "ds", "pixeldata", "rows", "cols", "nr_samples", "nr_bits", "pixel_data", "extend", "frame", "the", "segment", "order", "should", "be", "big", "endian", "by", "default", "but", "make", "it", "possible", "to", "switch", "if", "the", "rle", "is", "non", "conformant", "dtype", "pixel_dtype", "ds", "newbyteorder", "rle_segment_order", "arr", "np", "frombuffer", "pixel_data", "dtype", "if", "should_change_photometricinterpretation_to_rgb", "ds", "ds", "photometricinterpretation", "rgb", "return", "arr"], "doc_len": 344}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_parse_rle_header", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_parse_rle_header", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _parse_rle_header(header):\n    \"\"\"Return a list of byte offsets for the segments in RLE data.\n\n    **RLE Header Format**\n\n    The RLE Header contains the number of segments for the image and the\n    starting offset of each segment. Each of these numbers is represented as\n    an unsigned long stored in little-endian. The RLE Header is 16 long words\n    in length (i.e. 64 bytes) which allows it to describe a compressed image\n    with up to 15 segments. All unused segment offsets shall be set to zero.\n\n    As an example, the table below describes an RLE Header with 3 segments as\n    would typically be used with 8-bit RGB or YCbCr data (with 1 segment per\n    channel).\n\n    +--------------+---------------------------------+------------+\n    | Byte  offset | Description                     | Value      |\n    +==============+=================================+============+\n    | 0            | Number of segments              | 3          |\n    +--------------+---------------------------------+------------+\n    | 4            | Offset of segment 1, N bytes    | 64         |\n    +--------------+---------------------------------+------------+\n    | 8            | Offset of segment 2, M bytes    | 64 + N     |\n    +--------------+---------------------------------+------------+\n    | 12           | Offset of segment 3             | 64 + N + M |\n    +--------------+---------------------------------+------------+\n    | 16           | Offset of segment 4 (not used)  | 0          |\n    +--------------+---------------------------------+------------+\n    | ...          | ...                             | 0          |\n    +--------------+---------------------------------+------------+\n    | 60           | Offset of segment 15 (not used) | 0          |\n    +--------------+---------------------------------+------------+\n\n    Parameters\n    ----------\n    header : bytes\n        The RLE header data (i.e. the first 64 bytes of an RLE frame).\n\n    Returns\n    -------\n    list of int\n        The byte offsets for each segment in the RLE data.\n\n    Raises\n    ------\n    ValueError\n        If there are more than 15 segments or if the header is not 64 bytes\n        long.\n\n    References\n    ----------\n    DICOM Standard, Part 5, Annex G\n    \"\"\"\n    if len(header) != 64:\n        raise ValueError('The RLE header can only be 64 bytes long')\n\n    nr_segments = unpack('<L', header[:4])[0]\n    if nr_segments > 15:\n        raise ValueError(\n            \"The RLE header specifies an invalid number of segments ({})\"\n            .format(nr_segments)\n        )\n\n    offsets = unpack('<{}L'.format(nr_segments),\n                     header[4:4 * (nr_segments + 1)])\n\n    return list(offsets)\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_parse_rle_header", "header", "return", "a", "list", "of", "byte", "offsets", "for", "the", "segments", "in", "rle", "data", "rle", "header", "format", "the", "rle", "header", "contains", "the", "number", "of", "segments", "for", "the", "image", "and", "the", "starting", "offset", "of", "each", "segment", "each", "of", "these", "numbers", "is", "represented", "as", "an", "unsigned", "long", "stored", "in", "little", "endian", "the", "rle", "header", "is", "16", "long", "words", "in", "length", "i", "e", "64", "bytes", "which", "allows", "it", "to", "describe", "a", "compressed", "image", "with", "up", "to", "15", "segments", "all", "unused", "segment", "offsets", "shall", "be", "set", "to", "zero", "as", "an", "example", "the", "table", "below", "describes", "an", "rle", "header", "with", "3", "segments", "as", "would", "typically", "be", "used", "with", "8", "bit", "rgb", "or", "ycbcr", "data", "with", "1", "segment", "per", "channel", "byte", "offset", "description", "value", "0", "number", "of", "segments", "3", "4", "offset", "of", "segment", "1", "n", "bytes", "64", "8", "offset", "of", "segment", "2", "m", "bytes", "64", "n", "12", "offset", "of", "segment", "3", "64", "n", "m", "16", "offset", "of", "segment", "4", "not", "used", "0", "0", "60", "offset", "of", "segment", "15", "not", "used", "0", "parameters", "header", "bytes", "the", "rle", "header", "data", "i", "e", "the", "first", "64", "bytes", "of", "an", "rle", "frame", "returns", "list", "of", "int", "the", "byte", "offsets", "for", "each", "segment", "in", "the", "rle", "data", "raises", "valueerror", "if", "there", "are", "more", "than", "15", "segments", "or", "if", "the", "header", "is", "not", "64", "bytes", "long", "references", "dicom", "standard", "part", "5", "annex", "g", "if", "len", "header", "64", "raise", "valueerror", "the", "rle", "header", "can", "only", "be", "64", "bytes", "long", "nr_segments", "unpack", "l", "header", "4", "0", "if", "nr_segments", "15", "raise", "valueerror", "the", "rle", "header", "specifies", "an", "invalid", "number", "of", "segments", "format", "nr_segments", "offsets", "unpack", "l", "format", "nr_segments", "header", "4", "4", "nr_segments", "1", "return", "list", "offsets"], "doc_len": 276}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_rle_decode_frame", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_rle_decode_frame", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _rle_decode_frame(data, rows, columns, nr_samples, nr_bits):\n    \"\"\"Decodes a single frame of RLE encoded data.\n\n    Each frame may contain up to 15 segments of encoded data.\n\n    Parameters\n    ----------\n    data : bytes\n        The RLE frame data\n    rows : int\n        The number of output rows\n    columns : int\n        The number of output columns\n    nr_samples : int\n        Number of samples per pixel (e.g. 3 for RGB data).\n    nr_bits : int\n        Number of bits per sample - must be a multiple of 8\n\n    Returns\n    -------\n    bytearray\n        The frame's decoded data in big endian and planar configuration 1\n        byte ordering (i.e. for RGB data this is all red pixels then all\n        green then all blue, with the bytes for each pixel ordered from\n        MSB to LSB when reading left to right).\n    \"\"\"\n    if nr_bits % 8:\n        raise NotImplementedError(\n            \"Unable to decode RLE encoded pixel data with a (0028,0100) \"\n            \"'Bits Allocated' value of {}\".format(nr_bits)\n        )\n\n    # Parse the RLE Header\n    offsets = _parse_rle_header(data[:64])\n    nr_segments = len(offsets)\n\n    # Check that the actual number of segments is as expected\n    bytes_per_sample = nr_bits // 8\n    if nr_segments != nr_samples * bytes_per_sample:\n        raise ValueError(\n            \"The number of RLE segments in the pixel data doesn't match the \"\n            \"expected amount ({} vs. {} segments)\"\n            .format(nr_segments, nr_samples * bytes_per_sample)\n        )\n\n    # Ensure the last segment gets decoded\n    offsets.append(len(data))\n\n    # Preallocate with null bytes\n    decoded = bytearray(rows * columns * nr_samples * bytes_per_sample)\n\n    # Example:\n    # RLE encoded data is ordered like this (for 16-bit, 3 sample):\n    #  Segment: 1     | 2     | 3     | 4     | 5     | 6\n    #           R MSB | R LSB | G MSB | G LSB | B MSB | B LSB\n    #  A segment contains only the MSB or LSB parts of all the sample pixels\n\n    # To minimise the amount of array manipulation later, and to make things\n    # faster we interleave each segment in a manner consistent with a planar\n    # configuration of 1 (and maintain big endian byte ordering):\n    #    All red samples             | All green samples           | All blue\n    #    Pxl 1   Pxl 2   ... Pxl N   | Pxl 1   Pxl 2   ... Pxl N   | ...\n    #    MSB LSB MSB LSB ... MSB LSB | MSB LSB MSB LSB ... MSB LSB | ...\n\n    # `stride` is the total number of bytes of each sample plane\n    stride = bytes_per_sample * rows * columns\n    for sample_number in range(nr_samples):\n        for byte_offset in range(bytes_per_sample):\n            # Decode the segment\n            # ii is 0, 1, 2, 3, ..., (nr_segments - 1)\n            ii = sample_number * bytes_per_sample + byte_offset\n            segment = _rle_decode_segment(data[offsets[ii]:offsets[ii + 1]])\n            # Check that the number of decoded pixels is correct\n            if len(segment) != rows * columns:\n                raise ValueError(\n                    \"The amount of decoded RLE segment data doesn't match the \"\n                    \"expected amount ({} vs. {} bytes)\"\n                    .format(len(segment), rows * columns)\n                )\n\n            # For 100 pixel/plane, 32-bit, 3 sample data `start` will be\n            #   0, 1, 2, 3, 400, 401, 402, 403, 800, 801, 802, 803\n            start = byte_offset + sample_number * stride\n            decoded[start:start + stride:bytes_per_sample] = segment\n\n    return decoded\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_rle_decode_frame", "data", "rows", "columns", "nr_samples", "nr_bits", "decodes", "a", "single", "frame", "of", "rle", "encoded", "data", "each", "frame", "may", "contain", "up", "to", "15", "segments", "of", "encoded", "data", "parameters", "data", "bytes", "the", "rle", "frame", "data", "rows", "int", "the", "number", "of", "output", "rows", "columns", "int", "the", "number", "of", "output", "columns", "nr_samples", "int", "number", "of", "samples", "per", "pixel", "e", "g", "3", "for", "rgb", "data", "nr_bits", "int", "number", "of", "bits", "per", "sample", "must", "be", "a", "multiple", "of", "8", "returns", "bytearray", "the", "frame", "s", "decoded", "data", "in", "big", "endian", "and", "planar", "configuration", "1", "byte", "ordering", "i", "e", "for", "rgb", "data", "this", "is", "all", "red", "pixels", "then", "all", "green", "then", "all", "blue", "with", "the", "bytes", "for", "each", "pixel", "ordered", "from", "msb", "to", "lsb", "when", "reading", "left", "to", "right", "if", "nr_bits", "8", "raise", "notimplementederror", "unable", "to", "decode", "rle", "encoded", "pixel", "data", "with", "a", "0028", "0100", "bits", "allocated", "value", "of", "format", "nr_bits", "parse", "the", "rle", "header", "offsets", "_parse_rle_header", "data", "64", "nr_segments", "len", "offsets", "check", "that", "the", "actual", "number", "of", "segments", "is", "as", "expected", "bytes_per_sample", "nr_bits", "8", "if", "nr_segments", "nr_samples", "bytes_per_sample", "raise", "valueerror", "the", "number", "of", "rle", "segments", "in", "the", "pixel", "data", "doesn", "t", "match", "the", "expected", "amount", "vs", "segments", "format", "nr_segments", "nr_samples", "bytes_per_sample", "ensure", "the", "last", "segment", "gets", "decoded", "offsets", "append", "len", "data", "preallocate", "with", "null", "bytes", "decoded", "bytearray", "rows", "columns", "nr_samples", "bytes_per_sample", "example", "rle", "encoded", "data", "is", "ordered", "like", "this", "for", "16", "bit", "3", "sample", "segment", "1", "2", "3", "4", "5", "6", "r", "msb", "r", "lsb", "g", "msb", "g", "lsb", "b", "msb", "b", "lsb", "a", "segment", "contains", "only", "the", "msb", "or", "lsb", "parts", "of", "all", "the", "sample", "pixels", "to", "minimise", "the", "amount", "of", "array", "manipulation", "later", "and", "to", "make", "things", "faster", "we", "interleave", "each", "segment", "in", "a", "manner", "consistent", "with", "a", "planar", "configuration", "of", "1", "and", "maintain", "big", "endian", "byte", "ordering", "all", "red", "samples", "all", "green", "samples", "all", "blue", "pxl", "1", "pxl", "2", "pxl", "n", "pxl", "1", "pxl", "2", "pxl", "n", "msb", "lsb", "msb", "lsb", "msb", "lsb", "msb", "lsb", "msb", "lsb", "msb", "lsb", "stride", "is", "the", "total", "number", "of", "bytes", "of", "each", "sample", "plane", "stride", "bytes_per_sample", "rows", "columns", "for", "sample_number", "in", "range", "nr_samples", "for", "byte_offset", "in", "range", "bytes_per_sample", "decode", "the", "segment", "ii", "is", "0", "1", "2", "3", "nr_segments", "1", "ii", "sample_number", "bytes_per_sample", "byte_offset", "segment", "_rle_decode_segment", "data", "offsets", "ii", "offsets", "ii", "1", "check", "that", "the", "number", "of", "decoded", "pixels", "is", "correct", "if", "len", "segment", "rows", "columns", "raise", "valueerror", "the", "amount", "of", "decoded", "rle", "segment", "data", "doesn", "t", "match", "the", "expected", "amount", "vs", "bytes", "format", "len", "segment", "rows", "columns", "for", "100", "pixel", "plane", "32", "bit", "3", "sample", "data", "start", "will", "be", "0", "1", "2", "3", "400", "401", "402", "403", "800", "801", "802", "803", "start", "byte_offset", "sample_number", "stride", "decoded", "start", "start", "stride", "bytes_per_sample", "segment", "return", "decoded"], "doc_len": 449}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_rle_decode_segment", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_rle_decode_segment", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _rle_decode_segment(data):\n    \"\"\"Return a single segment of decoded RLE data as bytearray.\n\n    Parameters\n    ----------\n    data : bytes\n        The segment data to be decoded.\n\n    Returns\n    -------\n    bytearray\n        The decoded segment.\n    \"\"\"\n\n    data = bytearray(data)\n    result = bytearray()\n    pos = 0\n    result_extend = result.extend\n\n    try:\n        while True:\n            # header_byte is N + 1\n            header_byte = data[pos] + 1\n            pos += 1\n            if header_byte > 129:\n                # Extend by copying the next byte (-N + 1) times\n                # however since using uint8 instead of int8 this will be\n                # (256 - N + 1) times\n                result_extend(data[pos:pos + 1] * (258 - header_byte))\n                pos += 1\n            elif header_byte < 129:\n                # Extend by literally copying the next (N + 1) bytes\n                result_extend(data[pos:pos + header_byte])\n                pos += header_byte\n\n    except IndexError:\n        pass\n\n    return result\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_rle_decode_segment", "data", "return", "a", "single", "segment", "of", "decoded", "rle", "data", "as", "bytearray", "parameters", "data", "bytes", "the", "segment", "data", "to", "be", "decoded", "returns", "bytearray", "the", "decoded", "segment", "data", "bytearray", "data", "result", "bytearray", "pos", "0", "result_extend", "result", "extend", "try", "while", "true", "header_byte", "is", "n", "1", "header_byte", "data", "pos", "1", "pos", "1", "if", "header_byte", "129", "extend", "by", "copying", "the", "next", "byte", "n", "1", "times", "however", "since", "using", "uint8", "instead", "of", "int8", "this", "will", "be", "256", "n", "1", "times", "result_extend", "data", "pos", "pos", "1", "258", "header_byte", "pos", "1", "elif", "header_byte", "129", "extend", "by", "literally", "copying", "the", "next", "n", "1", "bytes", "result_extend", "data", "pos", "pos", "header_byte", "pos", "header_byte", "except", "indexerror", "pass", "return", "result"], "doc_len": 113}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::rle_encode_frame", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "rle_encode_frame", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef rle_encode_frame(arr):\n    \"\"\"Return an numpy ndarray image frame as RLE encoded bytearray.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        A 2D (if Samples Per Pixel = 1) or 3D (if Samples Per Pixel = 3)\n        ndarray containing a single frame of the image to be RLE encoded.\n\n    Returns\n    -------\n    bytearray\n        An RLE encoded frame, including the RLE header, following the format\n        specified by the DICOM Standard, Part 5, Annex G.\n    \"\"\"\n    shape = arr.shape\n    if len(shape) > 3:\n        # Note: only raises if multi-sample pixel data with multiple frames\n        raise ValueError(\n            \"Unable to encode multiple frames at once, please encode one \"\n            \"frame at a time\"\n        )\n\n    # Check the expected number of segments\n    nr_segments = arr.dtype.itemsize\n    if len(shape) == 3:\n        # Number of samples * bytes per sample\n        nr_segments *= shape[-1]\n\n    if nr_segments > 15:\n        raise ValueError(\n            \"Unable to encode as the DICOM standard only allows \"\n            \"a maximum of 15 segments in RLE encoded data\"\n        )\n\n    rle_data = bytearray()\n    seg_lengths = []\n    if len(shape) == 3:\n        # Samples Per Pixel > 1\n        for ii in range(arr.shape[-1]):\n            # Need a contiguous array in order to be able to split it up\n            # into byte segments\n            for segment in _rle_encode_plane(arr[..., ii].copy()):\n                rle_data.extend(segment)\n                seg_lengths.append(len(segment))\n    else:\n        # Samples Per Pixel = 1\n        for segment in _rle_encode_plane(arr):\n            rle_data.extend(segment)\n            seg_lengths.append(len(segment))\n\n    # Add the number of segments to the header\n    rle_header = bytearray(pack('<L', len(seg_lengths)))\n\n    # Add the segment offsets, starting at 64 for the first segment\n    # We don't need an offset to any data at the end of the last segment\n    offsets = [64]\n    for ii, length in enumerate(seg_lengths[:-1]):\n        offsets.append(offsets[ii] + length)\n    rle_header.extend(pack('<{}L'.format(len(offsets)), *offsets))\n\n    # Add trailing padding to make up the rest of the header (if required)\n    rle_header.extend(b'\\x00' * (64 - len(rle_header)))\n\n    return rle_header + rle_data\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "rle_encode_frame", "arr", "return", "an", "numpy", "ndarray", "image", "frame", "as", "rle", "encoded", "bytearray", "parameters", "arr", "numpy", "ndarray", "a", "2d", "if", "samples", "per", "pixel", "1", "or", "3d", "if", "samples", "per", "pixel", "3", "ndarray", "containing", "a", "single", "frame", "of", "the", "image", "to", "be", "rle", "encoded", "returns", "bytearray", "an", "rle", "encoded", "frame", "including", "the", "rle", "header", "following", "the", "format", "specified", "by", "the", "dicom", "standard", "part", "5", "annex", "g", "shape", "arr", "shape", "if", "len", "shape", "3", "note", "only", "raises", "if", "multi", "sample", "pixel", "data", "with", "multiple", "frames", "raise", "valueerror", "unable", "to", "encode", "multiple", "frames", "at", "once", "please", "encode", "one", "frame", "at", "a", "time", "check", "the", "expected", "number", "of", "segments", "nr_segments", "arr", "dtype", "itemsize", "if", "len", "shape", "3", "number", "of", "samples", "bytes", "per", "sample", "nr_segments", "shape", "1", "if", "nr_segments", "15", "raise", "valueerror", "unable", "to", "encode", "as", "the", "dicom", "standard", "only", "allows", "a", "maximum", "of", "15", "segments", "in", "rle", "encoded", "data", "rle_data", "bytearray", "seg_lengths", "if", "len", "shape", "3", "samples", "per", "pixel", "1", "for", "ii", "in", "range", "arr", "shape", "1", "need", "a", "contiguous", "array", "in", "order", "to", "be", "able", "to", "split", "it", "up", "into", "byte", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "ii", "copy", "rle_data", "extend", "segment", "seg_lengths", "append", "len", "segment", "else", "samples", "per", "pixel", "1", "for", "segment", "in", "_rle_encode_plane", "arr", "rle_data", "extend", "segment", "seg_lengths", "append", "len", "segment", "add", "the", "number", "of", "segments", "to", "the", "header", "rle_header", "bytearray", "pack", "l", "len", "seg_lengths", "add", "the", "segment", "offsets", "starting", "at", "64", "for", "the", "first", "segment", "we", "don", "t", "need", "an", "offset", "to", "any", "data", "at", "the", "end", "of", "the", "last", "segment", "offsets", "64", "for", "ii", "length", "in", "enumerate", "seg_lengths", "1", "offsets", "append", "offsets", "ii", "length", "rle_header", "extend", "pack", "l", "format", "len", "offsets", "offsets", "add", "trailing", "padding", "to", "make", "up", "the", "rest", "of", "the", "header", "if", "required", "rle_header", "extend", "b", "x00", "64", "len", "rle_header", "return", "rle_header", "rle_data"], "doc_len": 300}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_rle_encode_plane", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_rle_encode_plane", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _rle_encode_plane(arr):\n    \"\"\"Yield RLE encoded segments from an image plane as bytearray.\n\n    A plane of N-byte samples must be split into N segments, with each segment\n    containing the same byte of the N-byte samples. For example, in a plane\n    containing 16 bits per sample, the first segment will contain the most\n    significant 8 bits of the samples and the second segment the 8 least\n    significant bits. Each segment is RLE encoded prior to being yielded.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        A 2D ndarray containing a single plane of the image data to be RLE\n        encoded. The dtype of the array should be a multiple of 8 (i.e. uint8,\n        uint32, int16, etc.).\n\n    Yields\n    ------\n    bytearray\n        An RLE encoded segment of the plane, following the format specified\n        by the DICOM Standard, Part 5, Annex G. The segments are yielded in\n        order from most significant to least.\n    \"\"\"\n    # Determine the byte order of the array\n    byte_order = arr.dtype.byteorder\n    if byte_order == '=':\n        byte_order = '<' if sys.byteorder == 'little' else '>'\n\n    # Re-view the N-bit array data as N / 8 x uint8s\n    arr8 = arr.view(np.uint8)\n\n    # Reshape the uint8 array data into 1 or more segments and encode\n    bytes_per_sample = arr.dtype.itemsize\n    for ii in range(bytes_per_sample):\n        # If the original byte order is little endian we need to segment\n        #   in reverse order\n        if byte_order == '<':\n            ii = bytes_per_sample - ii - 1\n        segment = arr8.ravel()[ii::bytes_per_sample].reshape(arr.shape)\n\n        yield _rle_encode_segment(segment)\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_rle_encode_plane", "arr", "yield", "rle", "encoded", "segments", "from", "an", "image", "plane", "as", "bytearray", "a", "plane", "of", "n", "byte", "samples", "must", "be", "split", "into", "n", "segments", "with", "each", "segment", "containing", "the", "same", "byte", "of", "the", "n", "byte", "samples", "for", "example", "in", "a", "plane", "containing", "16", "bits", "per", "sample", "the", "first", "segment", "will", "contain", "the", "most", "significant", "8", "bits", "of", "the", "samples", "and", "the", "second", "segment", "the", "8", "least", "significant", "bits", "each", "segment", "is", "rle", "encoded", "prior", "to", "being", "yielded", "parameters", "arr", "numpy", "ndarray", "a", "2d", "ndarray", "containing", "a", "single", "plane", "of", "the", "image", "data", "to", "be", "rle", "encoded", "the", "dtype", "of", "the", "array", "should", "be", "a", "multiple", "of", "8", "i", "e", "uint8", "uint32", "int16", "etc", "yields", "bytearray", "an", "rle", "encoded", "segment", "of", "the", "plane", "following", "the", "format", "specified", "by", "the", "dicom", "standard", "part", "5", "annex", "g", "the", "segments", "are", "yielded", "in", "order", "from", "most", "significant", "to", "least", "determine", "the", "byte", "order", "of", "the", "array", "byte_order", "arr", "dtype", "byteorder", "if", "byte_order", "byte_order", "if", "sys", "byteorder", "little", "else", "re", "view", "the", "n", "bit", "array", "data", "as", "n", "8", "x", "uint8s", "arr8", "arr", "view", "np", "uint8", "reshape", "the", "uint8", "array", "data", "into", "1", "or", "more", "segments", "and", "encode", "bytes_per_sample", "arr", "dtype", "itemsize", "for", "ii", "in", "range", "bytes_per_sample", "if", "the", "original", "byte", "order", "is", "little", "endian", "we", "need", "to", "segment", "in", "reverse", "order", "if", "byte_order", "ii", "bytes_per_sample", "ii", "1", "segment", "arr8", "ravel", "ii", "bytes_per_sample", "reshape", "arr", "shape", "yield", "_rle_encode_segment", "segment"], "doc_len": 239}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_rle_encode_segment", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_rle_encode_segment", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _rle_encode_segment(arr):\n    \"\"\"Return a 2D numpy ndarray as an RLE encoded bytearray.\n\n    Each row of the image is encoded separately as required by the DICOM\n    Standard.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        A 2D ndarray of 8-bit uint data, representing a Byte Segment as in\n        the DICOM Standard, Part 5, Annex G.2.\n\n    Returns\n    -------\n    bytearray\n        The RLE encoded segment, following the format specified by the DICOM\n        Standard. Odd length encoded segments are padded by a trailing 0x00\n        to be even length.\n    \"\"\"\n    out = bytearray()\n    if len(arr.shape) > 1:\n        for row in arr:\n            out.extend(_rle_encode_row(row))\n    else:\n        out.extend(_rle_encode_row(arr))\n\n    # Pad odd length data with a trailing 0x00 byte\n    out.extend(b'\\x00' * (len(out) % 2))\n\n    return out\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_rle_encode_segment", "arr", "return", "a", "2d", "numpy", "ndarray", "as", "an", "rle", "encoded", "bytearray", "each", "row", "of", "the", "image", "is", "encoded", "separately", "as", "required", "by", "the", "dicom", "standard", "parameters", "arr", "numpy", "ndarray", "a", "2d", "ndarray", "of", "8", "bit", "uint", "data", "representing", "a", "byte", "segment", "as", "in", "the", "dicom", "standard", "part", "5", "annex", "g", "2", "returns", "bytearray", "the", "rle", "encoded", "segment", "following", "the", "format", "specified", "by", "the", "dicom", "standard", "odd", "length", "encoded", "segments", "are", "padded", "by", "a", "trailing", "0x00", "to", "be", "even", "length", "out", "bytearray", "if", "len", "arr", "shape", "1", "for", "row", "in", "arr", "out", "extend", "_rle_encode_row", "row", "else", "out", "extend", "_rle_encode_row", "arr", "pad", "odd", "length", "data", "with", "a", "trailing", "0x00", "byte", "out", "extend", "b", "x00", "len", "out", "2", "return", "out"], "doc_len": 123}
{"doc_id": "pydicom/pixel_data_handlers/rle_handler.py::_rle_encode_row", "file_path": "pydicom/pixel_data_handlers/rle_handler.py", "class_name": null, "func_name": "_rle_encode_row", "text": "文件路径: pydicom/pixel_data_handlers/rle_handler.py\ndef _rle_encode_row(arr):\n    \"\"\"Return a numpy array as an RLE encoded bytearray.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        A 1D ndarray of 8-bit uint data.\n\n    Returns\n    -------\n    bytes\n        The RLE encoded row, following the format specified by the DICOM\n        Standard, Part 5, Annex G.\n\n    Notes\n    -----\n    * 2-byte repeat runs are always encoded as Replicate Runs rather than\n      only when not preceeded by a Literal Run as suggested by the Standard.\n    \"\"\"\n    out = []\n    out_append = out.append\n    out_extend = out.extend\n\n    literal = []\n    for key, group in groupby(arr.astype('uint8').tolist()):\n        group = list(group)\n        if len(group) == 1:\n            literal.append(group[0])\n        else:\n            if literal:\n                # Literal runs\n                for ii in range(0, len(literal), 128):\n                    _run = literal[ii:ii + 128]\n                    out_append(len(_run) - 1)\n                    out_extend(_run)\n\n                literal = []\n\n            # Replicate run\n            for ii in range(0, len(group), 128):\n                if len(group[ii:ii + 128]) > 1:\n                    # Replicate run\n                    out_append(257 - len(group[ii:ii + 128]))\n                    out_append(group[0])\n                else:\n                    # Literal run only if last replicate part is length 1\n                    out_append(0)\n                    out_append(group[0])\n\n    # Final literal run if literal isn't followed by a replicate run\n    for ii in range(0, len(literal), 128):\n        _run = literal[ii:ii + 128]\n        out_append(len(_run) - 1)\n        out_extend(_run)\n\n    return pack('{}B'.format(len(out)), *out)\n", "tokens": ["pydicom", "pixel_data_handlers", "rle_handler", "py", "def", "_rle_encode_row", "arr", "return", "a", "numpy", "array", "as", "an", "rle", "encoded", "bytearray", "parameters", "arr", "numpy", "ndarray", "a", "1d", "ndarray", "of", "8", "bit", "uint", "data", "returns", "bytes", "the", "rle", "encoded", "row", "following", "the", "format", "specified", "by", "the", "dicom", "standard", "part", "5", "annex", "g", "notes", "2", "byte", "repeat", "runs", "are", "always", "encoded", "as", "replicate", "runs", "rather", "than", "only", "when", "not", "preceeded", "by", "a", "literal", "run", "as", "suggested", "by", "the", "standard", "out", "out_append", "out", "append", "out_extend", "out", "extend", "literal", "for", "key", "group", "in", "groupby", "arr", "astype", "uint8", "tolist", "group", "list", "group", "if", "len", "group", "1", "literal", "append", "group", "0", "else", "if", "literal", "literal", "runs", "for", "ii", "in", "range", "0", "len", "literal", "128", "_run", "literal", "ii", "ii", "128", "out_append", "len", "_run", "1", "out_extend", "_run", "literal", "replicate", "run", "for", "ii", "in", "range", "0", "len", "group", "128", "if", "len", "group", "ii", "ii", "128", "1", "replicate", "run", "out_append", "257", "len", "group", "ii", "ii", "128", "out_append", "group", "0", "else", "literal", "run", "only", "if", "last", "replicate", "part", "is", "length", "1", "out_append", "0", "out_append", "group", "0", "final", "literal", "run", "if", "literal", "isn", "t", "followed", "by", "a", "replicate", "run", "for", "ii", "in", "range", "0", "len", "literal", "128", "_run", "literal", "ii", "ii", "128", "out_append", "len", "_run", "1", "out_extend", "_run", "return", "pack", "b", "format", "len", "out", "out"], "doc_len": 208}
{"doc_id": "pydicom/pixel_data_handlers/util.py::convert_color_space", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "convert_color_space", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef convert_color_space(arr, current, desired):\n    \"\"\"Convert the image(s) in `arr` from one color space to another.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        The image(s) as an ndarray with shape (frames, rows, columns, planes)\n        or (rows, columns, planes).\n    current : str\n        The current color space, should be a valid value for (0028,0004)\n        *Photometric Interpretation*. One of 'RGB', 'YBR_FULL'.\n    desired : str\n        The desired color space, should be a valid value for (0028,0004)\n        *Photometric Interpretation*. One of 'RGB', 'YBR_FULL'.\n\n    Returns\n    -------\n    numpy.ndarray\n        The image(s) converted to the desired color space.\n    \"\"\"\n    if not HAVE_NP:\n        raise ImportError(\n            \"Numpy is required to convert the color space.\"\n        )\n\n    # No change needed\n    if current == desired:\n        return arr\n\n    _converters = {\n        'YBR_FULL': {\n            'RGB': _convert_YBR_FULL_to_RGB\n        },\n        'RGB': {\n            'YBR_FULL': _convert_RGB_to_YBR_FULL,\n        }\n    }\n    try:\n        converter = _converters[current][desired]\n    except KeyError:\n        raise NotImplementedError(\n            \"Conversion from {0} to {1} is not supported.\"\n            .format(current, desired)\n        )\n\n    return converter(arr)\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "convert_color_space", "arr", "current", "desired", "convert", "the", "image", "s", "in", "arr", "from", "one", "color", "space", "to", "another", "parameters", "arr", "numpy", "ndarray", "the", "image", "s", "as", "an", "ndarray", "with", "shape", "frames", "rows", "columns", "planes", "or", "rows", "columns", "planes", "current", "str", "the", "current", "color", "space", "should", "be", "a", "valid", "value", "for", "0028", "0004", "photometric", "interpretation", "one", "of", "rgb", "ybr_full", "desired", "str", "the", "desired", "color", "space", "should", "be", "a", "valid", "value", "for", "0028", "0004", "photometric", "interpretation", "one", "of", "rgb", "ybr_full", "returns", "numpy", "ndarray", "the", "image", "s", "converted", "to", "the", "desired", "color", "space", "if", "not", "have_np", "raise", "importerror", "numpy", "is", "required", "to", "convert", "the", "color", "space", "no", "change", "needed", "if", "current", "desired", "return", "arr", "_converters", "ybr_full", "rgb", "_convert_ybr_full_to_rgb", "rgb", "ybr_full", "_convert_rgb_to_ybr_full", "try", "converter", "_converters", "current", "desired", "except", "keyerror", "raise", "notimplementederror", "conversion", "from", "0", "to", "1", "is", "not", "supported", "format", "current", "desired", "return", "converter", "arr"], "doc_len": 144}
{"doc_id": "pydicom/pixel_data_handlers/util.py::dtype_corrected_for_endianness", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "dtype_corrected_for_endianness", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef dtype_corrected_for_endianness(is_little_endian, numpy_dtype):\n    \"\"\"Return a numpy dtype corrected for system and dataset endianness.\n\n    Parameters\n    ----------\n    is_little_endian : bool\n        The endianess of the affected dataset.\n    numpy_dtype : numpy.dtype\n        The numpy data type used for the pixel data without considering\n        endianess.\n\n    Raises\n    ------\n    ValueError\n        If `is_little_endian` is None, e.g. not initialized.\n\n    Returns\n    -------\n    numpy.dtype\n        The numpy data type to be used for the pixel data, considering\n        the endianess.\n    \"\"\"\n    if is_little_endian is None:\n        raise ValueError(\"Dataset attribute 'is_little_endian' \"\n                         \"has to be set before writing the dataset\")\n\n    if is_little_endian != (byteorder == 'little'):\n        return numpy_dtype.newbyteorder('S')\n\n    return numpy_dtype\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "dtype_corrected_for_endianness", "is_little_endian", "numpy_dtype", "return", "a", "numpy", "dtype", "corrected", "for", "system", "and", "dataset", "endianness", "parameters", "is_little_endian", "bool", "the", "endianess", "of", "the", "affected", "dataset", "numpy_dtype", "numpy", "dtype", "the", "numpy", "data", "type", "used", "for", "the", "pixel", "data", "without", "considering", "endianess", "raises", "valueerror", "if", "is_little_endian", "is", "none", "e", "g", "not", "initialized", "returns", "numpy", "dtype", "the", "numpy", "data", "type", "to", "be", "used", "for", "the", "pixel", "data", "considering", "the", "endianess", "if", "is_little_endian", "is", "none", "raise", "valueerror", "dataset", "attribute", "is_little_endian", "has", "to", "be", "set", "before", "writing", "the", "dataset", "if", "is_little_endian", "byteorder", "little", "return", "numpy_dtype", "newbyteorder", "s", "return", "numpy_dtype"], "doc_len": 96}
{"doc_id": "pydicom/pixel_data_handlers/util.py::pixel_dtype", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "pixel_dtype", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef pixel_dtype(ds):\n    \"\"\"Return a numpy dtype for the pixel data in dataset in `ds`.\n\n    Suitable for use with IODs containing the Image Pixel module.\n\n    +------------------------------------------+--------------+\n    | Element                                  | Supported    |\n    +-------------+---------------------+------+ values       |\n    | Tag         | Keyword             | Type |              |\n    +=============+=====================+======+==============+\n    | (0028,0101) | BitsAllocated       | 1    | 1, 8, 16, 32 |\n    +-------------+---------------------+------+--------------+\n    | (0028,0103) | PixelRepresentation | 1    | 0, 1         |\n    +-------------+---------------------+------+--------------+\n\n    Parameters\n    ----------\n    ds : dataset.Dataset\n        The DICOM dataset containing the pixel data you wish to get the\n        numpy dtype for.\n\n    Returns\n    -------\n    numpy.dtype\n        A numpy dtype suitable for containing the dataset's pixel data.\n\n    Raises\n    ------\n    NotImplementedError\n        If the pixel data is of a type that isn't supported by either numpy\n        or pydicom.\n    \"\"\"\n    if not HAVE_NP:\n        raise ImportError(\"Numpy is required to determine the dtype.\")\n\n    if ds.is_little_endian is None:\n        ds.is_little_endian = ds.file_meta.TransferSyntaxUID.is_little_endian\n\n    # (0028,0103) Pixel Representation, US, 1\n    #   Data representation of the pixel samples\n    #   0x0000 - unsigned int\n    #   0x0001 - 2's complement (signed int)\n    pixel_repr = ds.PixelRepresentation\n    if pixel_repr == 0:\n        dtype_str = 'uint'\n    elif pixel_repr == 1:\n        dtype_str = 'int'\n    else:\n        raise ValueError(\n            \"Unable to determine the data type to use to contain the \"\n            \"Pixel Data as a value of '{}' for '(0028,0103) Pixel \"\n            \"Representation' is invalid\".format(pixel_repr)\n        )\n\n    # (0028,0100) Bits Allocated, US, 1\n    #   The number of bits allocated for each pixel sample\n    #   PS3.5 8.1.1: Bits Allocated shall either be 1 or a multiple of 8\n    #   For bit packed data we use uint8\n    bits_allocated = ds.BitsAllocated\n    if bits_allocated == 1:\n        dtype_str = 'uint8'\n    elif bits_allocated > 0 and bits_allocated % 8 == 0:\n        dtype_str += str(bits_allocated)\n    else:\n        raise ValueError(\n            \"Unable to determine the data type to use to contain the \"\n            \"Pixel Data as a value of '{}' for '(0028,0100) Bits \"\n            \"Allocated' is invalid\".format(bits_allocated)\n        )\n\n    # Check to see if the dtype is valid for numpy\n    try:\n        dtype = np.dtype(dtype_str)\n    except TypeError:\n        raise NotImplementedError(\n            \"The data type '{}' needed to contain the Pixel Data is not \"\n            \"supported by numpy\".format(dtype_str)\n        )\n\n    # Correct for endianness of the system vs endianness of the dataset\n    if ds.is_little_endian != (byteorder == 'little'):\n        # 'S' swap from current to opposite\n        dtype = dtype.newbyteorder('S')\n\n    return dtype\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "pixel_dtype", "ds", "return", "a", "numpy", "dtype", "for", "the", "pixel", "data", "in", "dataset", "in", "ds", "suitable", "for", "use", "with", "iods", "containing", "the", "image", "pixel", "module", "element", "supported", "values", "tag", "keyword", "type", "0028", "0101", "bitsallocated", "1", "1", "8", "16", "32", "0028", "0103", "pixelrepresentation", "1", "0", "1", "parameters", "ds", "dataset", "dataset", "the", "dicom", "dataset", "containing", "the", "pixel", "data", "you", "wish", "to", "get", "the", "numpy", "dtype", "for", "returns", "numpy", "dtype", "a", "numpy", "dtype", "suitable", "for", "containing", "the", "dataset", "s", "pixel", "data", "raises", "notimplementederror", "if", "the", "pixel", "data", "is", "of", "a", "type", "that", "isn", "t", "supported", "by", "either", "numpy", "or", "pydicom", "if", "not", "have_np", "raise", "importerror", "numpy", "is", "required", "to", "determine", "the", "dtype", "if", "ds", "is_little_endian", "is", "none", "ds", "is_little_endian", "ds", "file_meta", "transfersyntaxuid", "is_little_endian", "0028", "0103", "pixel", "representation", "us", "1", "data", "representation", "of", "the", "pixel", "samples", "0x0000", "unsigned", "int", "0x0001", "2", "s", "complement", "signed", "int", "pixel_repr", "ds", "pixelrepresentation", "if", "pixel_repr", "0", "dtype_str", "uint", "elif", "pixel_repr", "1", "dtype_str", "int", "else", "raise", "valueerror", "unable", "to", "determine", "the", "data", "type", "to", "use", "to", "contain", "the", "pixel", "data", "as", "a", "value", "of", "for", "0028", "0103", "pixel", "representation", "is", "invalid", "format", "pixel_repr", "0028", "0100", "bits", "allocated", "us", "1", "the", "number", "of", "bits", "allocated", "for", "each", "pixel", "sample", "ps3", "5", "8", "1", "1", "bits", "allocated", "shall", "either", "be", "1", "or", "a", "multiple", "of", "8", "for", "bit", "packed", "data", "we", "use", "uint8", "bits_allocated", "ds", "bitsallocated", "if", "bits_allocated", "1", "dtype_str", "uint8", "elif", "bits_allocated", "0", "and", "bits_allocated", "8", "0", "dtype_str", "str", "bits_allocated", "else", "raise", "valueerror", "unable", "to", "determine", "the", "data", "type", "to", "use", "to", "contain", "the", "pixel", "data", "as", "a", "value", "of", "for", "0028", "0100", "bits", "allocated", "is", "invalid", "format", "bits_allocated", "check", "to", "see", "if", "the", "dtype", "is", "valid", "for", "numpy", "try", "dtype", "np", "dtype", "dtype_str", "except", "typeerror", "raise", "notimplementederror", "the", "data", "type", "needed", "to", "contain", "the", "pixel", "data", "is", "not", "supported", "by", "numpy", "format", "dtype_str", "correct", "for", "endianness", "of", "the", "system", "vs", "endianness", "of", "the", "dataset", "if", "ds", "is_little_endian", "byteorder", "little", "s", "swap", "from", "current", "to", "opposite", "dtype", "dtype", "newbyteorder", "s", "return", "dtype"], "doc_len": 335}
{"doc_id": "pydicom/pixel_data_handlers/util.py::reshape_pixel_array", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "reshape_pixel_array", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef reshape_pixel_array(ds, arr):\n    \"\"\"Return a reshaped ndarray `arr`.\n\n    +------------------------------------------+-----------+----------+\n    | Element                                  | Supported |          |\n    +-------------+---------------------+------+ values    |          |\n    | Tag         | Keyword             | Type |           |          |\n    +=============+=====================+======+===========+==========+\n    | (0028,0002) | SamplesPerPixel     | 1    | N > 0     | Required |\n    +-------------+---------------------+------+-----------+----------+\n    | (0028,0006) | PlanarConfiguration | 1C   | 0, 1      | Optional |\n    +-------------+---------------------+------+-----------+----------+\n    | (0028,0008) | NumberOfFrames      | 1C   | N > 0     | Optional |\n    +-------------+---------------------+------+-----------+----------+\n    | (0028,0010) | Rows                | 1    | N > 0     | Required |\n    +-------------+---------------------+------+-----------+----------+\n    | (0028,0011) | Columns             | 1    | N > 0     | Required |\n    +-------------+---------------------+------+-----------+----------+\n\n    (0028,0008) *Number of Frames* is required when the pixel data contains\n    more than 1 frame. (0028,0006) *Planar Configuration* is required when\n    (0028,0002) *Samples per Pixel* is greater than 1. For certain\n    compressed transfer syntaxes it is always taken to be either 0 or 1 as\n    shown in the table below.\n\n    +---------------------------------------------+-----------------------+\n    | Transfer Syntax                             | Planar Configuration  |\n    +------------------------+--------------------+                       |\n    | UID                    | Name               |                       |\n    +========================+====================+=======================+\n    | 1.2.840.10008.1.2.4.50 | JPEG Baseline      | 0                     |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.57 | JPEG Lossless,     | 0                     |\n    |                        | Non-hierarchical   |                       |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.70 | JPEG Lossless,     | 0                     |\n    |                        | Non-hierarchical,  |                       |\n    |                        | SV1                |                       |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.80 | JPEG-LS Lossless   | 1                     |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.81 | JPEG-LS Lossy      | 1                     |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.90 | JPEG 2000 Lossless | 0                     |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.4.91 | JPEG 2000 Lossy    | 0                     |\n    +------------------------+--------------------+-----------------------+\n    | 1.2.840.10008.1.2.5    | RLE Lossless       | 1                     |\n    +------------------------+--------------------+-----------------------+\n\n    Parameters\n    ----------\n    ds : dataset.Dataset\n        The dataset containing the Image Pixel module corresponding to the\n        pixel data in `arr`.\n    arr : numpy.ndarray\n        The 1D array containing the pixel data.\n\n    Returns\n    -------\n    numpy.ndarray\n        A reshaped array containing the pixel data. The shape of the array\n        depends on the contents of the dataset:\n\n        * For single frame, single sample data (rows, columns)\n        * For single frame, multi-sample data (rows, columns, planes)\n        * For multi-frame, single sample data (frames, rows, columns)\n        * For multi-frame, multi-sample data (frames, rows, columns, planes)\n\n    References\n    ----------\n\n    * DICOM Standard, Part 3, Annex C.7.6.3.1\n    * DICOM Standard, Part 4, Sections 8.2.1-4\n    \"\"\"\n    if not HAVE_NP:\n        raise ImportError(\"Numpy is required to reshape the pixel array.\")\n\n    nr_frames = getattr(ds, 'NumberOfFrames', 1)\n    nr_samples = ds.SamplesPerPixel\n\n    if nr_frames < 1:\n        raise ValueError(\n            \"Unable to reshape the pixel array as a value of {} for \"\n            \"(0028,0008) 'Number of Frames' is invalid.\"\n            .format(nr_frames)\n        )\n\n    if nr_samples < 1:\n        raise ValueError(\n            \"Unable to reshape the pixel array as a value of {} for \"\n            \"(0028,0002) 'Samples per Pixel' is invalid.\"\n            .format(nr_samples)\n        )\n\n    # Valid values for Planar Configuration are dependent on transfer syntax\n    if nr_samples > 1:\n        transfer_syntax = ds.file_meta.TransferSyntaxUID\n        if transfer_syntax in ['1.2.840.10008.1.2.4.50',\n                               '1.2.840.10008.1.2.4.57',\n                               '1.2.840.10008.1.2.4.70',\n                               '1.2.840.10008.1.2.4.90',\n                               '1.2.840.10008.1.2.4.91']:\n            planar_configuration = 0\n        elif transfer_syntax in ['1.2.840.10008.1.2.4.80',\n                                 '1.2.840.10008.1.2.4.81',\n                                 '1.2.840.10008.1.2.5']:\n            planar_configuration = 1\n        else:\n            planar_configuration = ds.PlanarConfiguration\n\n        if planar_configuration not in [0, 1]:\n            raise ValueError(\n                \"Unable to reshape the pixel array as a value of {} for \"\n                \"(0028,0006) 'Planar Configuration' is invalid.\"\n                .format(planar_configuration)\n            )\n\n    if nr_frames > 1:\n        # Multi-frame\n        if nr_samples == 1:\n            # Single plane\n            arr = arr.reshape(nr_frames, ds.Rows, ds.Columns)\n        else:\n            # Multiple planes, usually 3\n            if planar_configuration == 0:\n                arr = arr.reshape(nr_frames, ds.Rows, ds.Columns, nr_samples)\n            else:\n                arr = arr.reshape(nr_frames, nr_samples, ds.Rows, ds.Columns)\n                arr = arr.transpose(0, 2, 3, 1)\n    else:\n        # Single frame\n        if nr_samples == 1:\n            # Single plane\n            arr = arr.reshape(ds.Rows, ds.Columns)\n        else:\n            # Multiple planes, usually 3\n            if planar_configuration == 0:\n                arr = arr.reshape(ds.Rows, ds.Columns, nr_samples)\n            else:\n                arr = arr.reshape(nr_samples, ds.Rows, ds.Columns)\n                arr = arr.transpose(1, 2, 0)\n\n    return arr\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "reshape_pixel_array", "ds", "arr", "return", "a", "reshaped", "ndarray", "arr", "element", "supported", "values", "tag", "keyword", "type", "0028", "0002", "samplesperpixel", "1", "n", "0", "required", "0028", "0006", "planarconfiguration", "1c", "0", "1", "optional", "0028", "0008", "numberofframes", "1c", "n", "0", "optional", "0028", "0010", "rows", "1", "n", "0", "required", "0028", "0011", "columns", "1", "n", "0", "required", "0028", "0008", "number", "of", "frames", "is", "required", "when", "the", "pixel", "data", "contains", "more", "than", "1", "frame", "0028", "0006", "planar", "configuration", "is", "required", "when", "0028", "0002", "samples", "per", "pixel", "is", "greater", "than", "1", "for", "certain", "compressed", "transfer", "syntaxes", "it", "is", "always", "taken", "to", "be", "either", "0", "or", "1", "as", "shown", "in", "the", "table", "below", "transfer", "syntax", "planar", "configuration", "uid", "name", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "0", "1", "2", "840", "10008", "1", "2", "4", "57", "jpeg", "lossless", "0", "non", "hierarchical", "1", "2", "840", "10008", "1", "2", "4", "70", "jpeg", "lossless", "0", "non", "hierarchical", "sv1", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "1", "1", "2", "840", "10008", "1", "2", "4", "81", "jpeg", "ls", "lossy", "1", "1", "2", "840", "10008", "1", "2", "4", "90", "jpeg", "2000", "lossless", "0", "1", "2", "840", "10008", "1", "2", "4", "91", "jpeg", "2000", "lossy", "0", "1", "2", "840", "10008", "1", "2", "5", "rle", "lossless", "1", "parameters", "ds", "dataset", "dataset", "the", "dataset", "containing", "the", "image", "pixel", "module", "corresponding", "to", "the", "pixel", "data", "in", "arr", "arr", "numpy", "ndarray", "the", "1d", "array", "containing", "the", "pixel", "data", "returns", "numpy", "ndarray", "a", "reshaped", "array", "containing", "the", "pixel", "data", "the", "shape", "of", "the", "array", "depends", "on", "the", "contents", "of", "the", "dataset", "for", "single", "frame", "single", "sample", "data", "rows", "columns", "for", "single", "frame", "multi", "sample", "data", "rows", "columns", "planes", "for", "multi", "frame", "single", "sample", "data", "frames", "rows", "columns", "for", "multi", "frame", "multi", "sample", "data", "frames", "rows", "columns", "planes", "references", "dicom", "standard", "part", "3", "annex", "c", "7", "6", "3", "1", "dicom", "standard", "part", "4", "sections", "8", "2", "1", "4", "if", "not", "have_np", "raise", "importerror", "numpy", "is", "required", "to", "reshape", "the", "pixel", "array", "nr_frames", "getattr", "ds", "numberofframes", "1", "nr_samples", "ds", "samplesperpixel", "if", "nr_frames", "1", "raise", "valueerror", "unable", "to", "reshape", "the", "pixel", "array", "as", "a", "value", "of", "for", "0028", "0008", "number", "of", "frames", "is", "invalid", "format", "nr_frames", "if", "nr_samples", "1", "raise", "valueerror", "unable", "to", "reshape", "the", "pixel", "array", "as", "a", "value", "of", "for", "0028", "0002", "samples", "per", "pixel", "is", "invalid", "format", "nr_samples", "valid", "values", "for", "planar", "configuration", "are", "dependent", "on", "transfer", "syntax", "if", "nr_samples", "1", "transfer_syntax", "ds", "file_meta", "transfersyntaxuid", "if", "transfer_syntax", "in", "1", "2", "840", "10008", "1", "2", "4", "50", "1", "2", "840", "10008", "1", "2", "4", "57", "1", "2", "840", "10008", "1", "2", "4", "70", "1", "2", "840", "10008", "1", "2", "4", "90", "1", "2", "840", "10008", "1", "2", "4", "91", "planar_configuration", "0", "elif", "transfer_syntax", "in", "1", "2", "840", "10008", "1", "2", "4", "80", "1", "2", "840", "10008", "1", "2", "4", "81", "1", "2", "840", "10008", "1", "2", "5", "planar_configuration", "1", "else", "planar_configuration", "ds", "planarconfiguration", "if", "planar_configuration", "not", "in", "0", "1", "raise", "valueerror", "unable", "to", "reshape", "the", "pixel", "array", "as", "a", "value", "of", "for", "0028", "0006", "planar", "configuration", "is", "invalid", "format", "planar_configuration", "if", "nr_frames", "1", "multi", "frame", "if", "nr_samples", "1", "single", "plane", "arr", "arr", "reshape", "nr_frames", "ds", "rows", "ds", "columns", "else", "multiple", "planes", "usually", "3", "if", "planar_configuration", "0", "arr", "arr", "reshape", "nr_frames", "ds", "rows", "ds", "columns", "nr_samples", "else", "arr", "arr", "reshape", "nr_frames", "nr_samples", "ds", "rows", "ds", "columns", "arr", "arr", "transpose", "0", "2", "3", "1", "else", "single", "frame", "if", "nr_samples", "1", "single", "plane", "arr", "arr", "reshape", "ds", "rows", "ds", "columns", "else", "multiple", "planes", "usually", "3", "if", "planar_configuration", "0", "arr", "arr", "reshape", "ds", "rows", "ds", "columns", "nr_samples", "else", "arr", "arr", "reshape", "nr_samples", "ds", "rows", "ds", "columns", "arr", "arr", "transpose", "1", "2", "0", "return", "arr"], "doc_len": 607}
{"doc_id": "pydicom/pixel_data_handlers/util.py::get_expected_length", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "get_expected_length", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef get_expected_length(ds, unit='bytes'):\n    \"\"\"Return the expected length (in bytes or pixels) of the pixel data.\n\n    +-----------------------------------+------+-------------+\n    | Element                           | Type | Required or |\n    +-------------+---------------------+      | optional    |\n    | Tag         | Keyword             |      |             |\n    +=============+=====================+======+=============+\n    | (0028,0002) | SamplesPerPixel     | 1    | Required    |\n    +-------------+---------------------+------+-------------+\n    | (0028,0008) | NumberOfFrames      | 1C   | Optional    |\n    +-------------+---------------------+------+-------------+\n    | (0028,0010) | Rows                | 1    | Required    |\n    +-------------+---------------------+------+-------------+\n    | (0028,0011) | Columns             | 1    | Required    |\n    +-------------+---------------------+------+-------------+\n    | (0028,0100) | BitsAllocated       | 1    | Required    |\n    +-------------+---------------------+------+-------------+\n\n    Parameters\n    ----------\n    ds : dataset.Dataset\n        The DICOM dataset containing the Image Pixel module and pixel data.\n    unit : str, optional\n        If 'bytes' then returns the expected length of the Pixel Data in\n        whole bytes and NOT including an odd length trailing NULL padding\n        byte. If 'pixels' then returns the expected length of the Pixel Data\n        in terms of the total number of pixels (default 'bytes').\n\n    Returns\n    -------\n    int\n        The expected length of the pixel data in either whole bytes or pixels,\n        excluding the NULL trailing padding byte for odd length data.\n    \"\"\"\n    length = ds.Rows * ds.Columns * ds.SamplesPerPixel\n    length *= getattr(ds, 'NumberOfFrames', 1)\n\n    if unit == 'pixels':\n        return length\n\n    # Correct for the number of bytes per pixel\n    bits_allocated = ds.BitsAllocated\n    if bits_allocated == 1:\n        # Determine the nearest whole number of bytes needed to contain\n        #   1-bit pixel data. e.g. 10 x 10 1-bit pixels is 100 bits, which\n        #   are packed into 12.5 -> 13 bytes\n        length = length // 8 + (length % 8 > 0)\n    else:\n        length *= bits_allocated // 8\n\n    return length\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "get_expected_length", "ds", "unit", "bytes", "return", "the", "expected", "length", "in", "bytes", "or", "pixels", "of", "the", "pixel", "data", "element", "type", "required", "or", "optional", "tag", "keyword", "0028", "0002", "samplesperpixel", "1", "required", "0028", "0008", "numberofframes", "1c", "optional", "0028", "0010", "rows", "1", "required", "0028", "0011", "columns", "1", "required", "0028", "0100", "bitsallocated", "1", "required", "parameters", "ds", "dataset", "dataset", "the", "dicom", "dataset", "containing", "the", "image", "pixel", "module", "and", "pixel", "data", "unit", "str", "optional", "if", "bytes", "then", "returns", "the", "expected", "length", "of", "the", "pixel", "data", "in", "whole", "bytes", "and", "not", "including", "an", "odd", "length", "trailing", "null", "padding", "byte", "if", "pixels", "then", "returns", "the", "expected", "length", "of", "the", "pixel", "data", "in", "terms", "of", "the", "total", "number", "of", "pixels", "default", "bytes", "returns", "int", "the", "expected", "length", "of", "the", "pixel", "data", "in", "either", "whole", "bytes", "or", "pixels", "excluding", "the", "null", "trailing", "padding", "byte", "for", "odd", "length", "data", "length", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "length", "getattr", "ds", "numberofframes", "1", "if", "unit", "pixels", "return", "length", "correct", "for", "the", "number", "of", "bytes", "per", "pixel", "bits_allocated", "ds", "bitsallocated", "if", "bits_allocated", "1", "determine", "the", "nearest", "whole", "number", "of", "bytes", "needed", "to", "contain", "1", "bit", "pixel", "data", "e", "g", "10", "x", "10", "1", "bit", "pixels", "is", "100", "bits", "which", "are", "packed", "into", "12", "5", "13", "bytes", "length", "length", "8", "length", "8", "0", "else", "length", "bits_allocated", "8", "return", "length"], "doc_len": 217}
{"doc_id": "pydicom/pixel_data_handlers/util.py::_convert_RGB_to_YBR_FULL", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "_convert_RGB_to_YBR_FULL", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef _convert_RGB_to_YBR_FULL(arr):\n    \"\"\"Return an ndarray converted from RGB to YBR_FULL color space.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        An ndarray of an 8-bit per channel images in RGB color space.\n\n    Returns\n    -------\n    numpy.ndarray\n        The array in YBR_FULL color space.\n\n    References\n    ----------\n\n    * DICOM Standard, Part 3, Annex C.7.6.3.1.2\n    * ISO/IEC 10918-5:2012, Section 7\n    \"\"\"\n    orig_dtype = arr.dtype\n    arr = arr.astype(np.float)\n\n    rgb_to_ybr = np.asarray(\n        [[+0.299, +0.587, +0.114],\n         [-0.299, -0.587, +0.886],\n         [+0.701, -0.587, -0.114]], dtype=np.float)\n\n    arr = np.dot(arr, rgb_to_ybr.T)\n    if len(arr.shape) == 4:\n        # Multi-frame\n        arr[:, :, :, 1] /= 1.772\n        arr[:, :, :, 2] /= 1.402\n    else:\n        # Single frame\n        arr[:, :, 1] /= 1.772\n        arr[:, :, 2] /= 1.402\n\n    arr += [0, 128, 128]\n\n    # Round(x) -> floor of (arr + 0.5)\n    arr = np.floor(arr + 0.5)\n    # Max(0, arr) -> 0 if 0 >= arr, arr otherwise\n    arr[np.where(arr < 0)] = 0\n    # Min(arr, 255) -> arr if arr <= 255, 255 otherwise\n    arr[np.where(arr > 255)] = 255\n\n    return arr.astype(orig_dtype)\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "_convert_rgb_to_ybr_full", "arr", "return", "an", "ndarray", "converted", "from", "rgb", "to", "ybr_full", "color", "space", "parameters", "arr", "numpy", "ndarray", "an", "ndarray", "of", "an", "8", "bit", "per", "channel", "images", "in", "rgb", "color", "space", "returns", "numpy", "ndarray", "the", "array", "in", "ybr_full", "color", "space", "references", "dicom", "standard", "part", "3", "annex", "c", "7", "6", "3", "1", "2", "iso", "iec", "10918", "5", "2012", "section", "7", "orig_dtype", "arr", "dtype", "arr", "arr", "astype", "np", "float", "rgb_to_ybr", "np", "asarray", "0", "299", "0", "587", "0", "114", "0", "299", "0", "587", "0", "886", "0", "701", "0", "587", "0", "114", "dtype", "np", "float", "arr", "np", "dot", "arr", "rgb_to_ybr", "t", "if", "len", "arr", "shape", "4", "multi", "frame", "arr", "1", "1", "772", "arr", "2", "1", "402", "else", "single", "frame", "arr", "1", "1", "772", "arr", "2", "1", "402", "arr", "0", "128", "128", "round", "x", "floor", "of", "arr", "0", "5", "arr", "np", "floor", "arr", "0", "5", "max", "0", "arr", "0", "if", "0", "arr", "arr", "otherwise", "arr", "np", "where", "arr", "0", "0", "min", "arr", "255", "arr", "if", "arr", "255", "255", "otherwise", "arr", "np", "where", "arr", "255", "255", "return", "arr", "astype", "orig_dtype"], "doc_len": 177}
{"doc_id": "pydicom/pixel_data_handlers/util.py::_convert_YBR_FULL_to_RGB", "file_path": "pydicom/pixel_data_handlers/util.py", "class_name": null, "func_name": "_convert_YBR_FULL_to_RGB", "text": "文件路径: pydicom/pixel_data_handlers/util.py\ndef _convert_YBR_FULL_to_RGB(arr):\n    \"\"\"Return an ndarray converted from YBR_FULL to RGB color space.\n\n    Parameters\n    ----------\n    arr : numpy.ndarray\n        An ndarray of an 8-bit per channel images in YBR_FULL color space.\n\n    Returns\n    -------\n    numpy.ndarray\n        The array in RGB color space.\n\n    References\n    ----------\n\n    * DICOM Standard, Part 3, Annex C.7.6.3.1.2\n    * ISO/IEC 10918-5:2012, Section 7\n    \"\"\"\n    orig_dtype = arr.dtype\n\n    ybr_to_rgb = np.asarray(\n        [[1.0, +0.0, +1.402],\n         [1.0, -0.114 * 1.772 / 0.587, -0.299 * 1.402 / 0.587],\n         [1.0, +1.772, +0.0]], dtype=np.float)\n\n    arr = arr.astype(np.float)\n    arr -= [0, 128, 128]\n    arr = np.dot(arr, ybr_to_rgb.T)\n\n    # Round(x) -> floor of (arr + 0.5)\n    arr = np.floor(arr + 0.5)\n    # Max(0, arr) -> 0 if 0 >= arr, arr otherwise\n    arr[np.where(arr < 0)] = 0\n    # Min(arr, 255) -> arr if arr <= 255, 255 otherwise\n    arr[np.where(arr > 255)] = 255\n\n    return arr.astype(orig_dtype)\n", "tokens": ["pydicom", "pixel_data_handlers", "util", "py", "def", "_convert_ybr_full_to_rgb", "arr", "return", "an", "ndarray", "converted", "from", "ybr_full", "to", "rgb", "color", "space", "parameters", "arr", "numpy", "ndarray", "an", "ndarray", "of", "an", "8", "bit", "per", "channel", "images", "in", "ybr_full", "color", "space", "returns", "numpy", "ndarray", "the", "array", "in", "rgb", "color", "space", "references", "dicom", "standard", "part", "3", "annex", "c", "7", "6", "3", "1", "2", "iso", "iec", "10918", "5", "2012", "section", "7", "orig_dtype", "arr", "dtype", "ybr_to_rgb", "np", "asarray", "1", "0", "0", "0", "1", "402", "1", "0", "0", "114", "1", "772", "0", "587", "0", "299", "1", "402", "0", "587", "1", "0", "1", "772", "0", "0", "dtype", "np", "float", "arr", "arr", "astype", "np", "float", "arr", "0", "128", "128", "arr", "np", "dot", "arr", "ybr_to_rgb", "t", "round", "x", "floor", "of", "arr", "0", "5", "arr", "np", "floor", "arr", "0", "5", "max", "0", "arr", "0", "if", "0", "arr", "arr", "otherwise", "arr", "np", "where", "arr", "0", "0", "min", "arr", "255", "arr", "if", "arr", "255", "255", "otherwise", "arr", "np", "where", "arr", "255", "255", "return", "arr", "astype", "orig_dtype"], "doc_len": 159}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.teardown", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def teardown(self):\n        config.enforce_valid_values = False\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "teardown", "self", "config", "enforce_valid_values", "false"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_encodings", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_encodings", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_encodings(self):\n        test_string = u'Hello World'\n        for x in pydicom.charset.python_encoding.items():\n            test_string.encode(x[1])\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_encodings", "self", "test_string", "u", "hello", "world", "for", "x", "in", "pydicom", "charset", "python_encoding", "items", "test_string", "encode", "x", "1"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_nested_character_sets", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_nested_character_sets", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_nested_character_sets(self):\n        \"\"\"charset: can read and decode SQ with different encodings.........\"\"\"\n        ds = dcmread(get_charset_files(\"chrSQEncoding.dcm\")[0])\n        ds.decode()\n\n        # These datasets inside of the SQ cannot be decoded with\n        # default_encoding OR UTF-8 (the parent dataset's encoding).\n        # Instead, we make sure that it is decoded using the\n        # (0008,0005) tag of the dataset\n\n        sequence = ds[0x32, 0x1064][0]\n        assert ['shift_jis', 'iso2022_jp'] == sequence._character_set\n        assert u'ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう' == sequence.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_nested_character_sets", "self", "charset", "can", "read", "and", "decode", "sq", "with", "different", "encodings", "ds", "dcmread", "get_charset_files", "chrsqencoding", "dcm", "0", "ds", "decode", "these", "datasets", "inside", "of", "the", "sq", "cannot", "be", "decoded", "with", "default_encoding", "or", "utf", "8", "the", "parent", "dataset", "s", "encoding", "instead", "we", "make", "sure", "that", "it", "is", "decoded", "using", "the", "0008", "0005", "tag", "of", "the", "dataset", "sequence", "ds", "0x32", "0x1064", "0", "assert", "shift_jis", "iso2022_jp", "sequence", "_character_set", "assert", "u", "sequence", "patientname"], "doc_len": 74}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_inherited_character_set_in_sequence", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_inherited_character_set_in_sequence", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_inherited_character_set_in_sequence(self):\n        \"\"\"charset: can read and decode SQ with parent encoding.............\"\"\"\n        ds = dcmread(get_charset_files('chrSQEncoding1.dcm')[0])\n        ds.decode()\n\n        # These datasets inside of the SQ shall be decoded with the parent\n        # dataset's encoding\n        sequence = ds[0x32, 0x1064][0]\n        assert ['shift_jis', 'iso2022_jp'] == sequence._character_set\n        assert u'ﾔﾏﾀﾞ^ﾀﾛｳ=山田^太郎=やまだ^たろう' == sequence.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_inherited_character_set_in_sequence", "self", "charset", "can", "read", "and", "decode", "sq", "with", "parent", "encoding", "ds", "dcmread", "get_charset_files", "chrsqencoding1", "dcm", "0", "ds", "decode", "these", "datasets", "inside", "of", "the", "sq", "shall", "be", "decoded", "with", "the", "parent", "dataset", "s", "encoding", "sequence", "ds", "0x32", "0x1064", "0", "assert", "shift_jis", "iso2022_jp", "sequence", "_character_set", "assert", "u", "sequence", "patientname"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_standard_file", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_standard_file", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_standard_file(self):\n        \"\"\"charset: can read and decode standard file without special char..\"\"\"\n        ds = dcmread(get_testdata_files(\"CT_small.dcm\")[0])\n        ds.decode()\n        assert u'CompressedSamples^CT1' == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_standard_file", "self", "charset", "can", "read", "and", "decode", "standard", "file", "without", "special", "char", "ds", "dcmread", "get_testdata_files", "ct_small", "dcm", "0", "ds", "decode", "assert", "u", "compressedsamples", "ct1", "ds", "patientname"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_invalid_character_set", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_invalid_character_set", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_invalid_character_set(self):\n        \"\"\"charset: replace invalid encoding with default encoding\"\"\"\n        ds = dcmread(get_testdata_files(\"CT_small.dcm\")[0])\n        ds.read_encoding = None\n        ds.SpecificCharacterSet = 'Unsupported'\n        with pytest.warns(UserWarning,\n                          match=u\"Unknown encoding 'Unsupported' \"\n                                u\"- using default encoding instead\"):\n            ds.decode()\n            assert u'CompressedSamples^CT1' == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_invalid_character_set", "self", "charset", "replace", "invalid", "encoding", "with", "default", "encoding", "ds", "dcmread", "get_testdata_files", "ct_small", "dcm", "0", "ds", "read_encoding", "none", "ds", "specificcharacterset", "unsupported", "with", "pytest", "warns", "userwarning", "match", "u", "unknown", "encoding", "unsupported", "u", "using", "default", "encoding", "instead", "ds", "decode", "assert", "u", "compressedsamples", "ct1", "ds", "patientname"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_invalid_character_set_enforce_valid", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_invalid_character_set_enforce_valid", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_invalid_character_set_enforce_valid(self):\n        \"\"\"charset: raise on invalid encoding\"\"\"\n        config.enforce_valid_values = True\n        ds = dcmread(get_testdata_files(\"CT_small.dcm\")[0])\n        ds.read_encoding = None\n        ds.SpecificCharacterSet = 'Unsupported'\n        with pytest.raises(LookupError,\n                           match=u\"Unknown encoding 'Unsupported'\"):\n            ds.decode()\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_invalid_character_set_enforce_valid", "self", "charset", "raise", "on", "invalid", "encoding", "config", "enforce_valid_values", "true", "ds", "dcmread", "get_testdata_files", "ct_small", "dcm", "0", "ds", "read_encoding", "none", "ds", "specificcharacterset", "unsupported", "with", "pytest", "raises", "lookuperror", "match", "u", "unknown", "encoding", "unsupported", "ds", "decode"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_decoding_with_specific_tags", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_decoding_with_specific_tags", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_decoding_with_specific_tags(self):\n        \"\"\"Decoding is correctly applied even if  Specific Character Set\n        is not in specific tags...\"\"\"\n        rus_file = get_charset_files(\"chrRuss.dcm\")[0]\n        ds = dcmread(rus_file, specific_tags=['PatientName'])\n        ds.decode()\n        assert 2 == len(ds)  # specific character set is always decoded\n        assert u'Люкceмбypг' == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_decoding_with_specific_tags", "self", "decoding", "is", "correctly", "applied", "even", "if", "specific", "character", "set", "is", "not", "in", "specific", "tags", "rus_file", "get_charset_files", "chrruss", "dcm", "0", "ds", "dcmread", "rus_file", "specific_tags", "patientname", "ds", "decode", "assert", "2", "len", "ds", "specific", "character", "set", "is", "always", "decoded", "assert", "u", "ce", "yp", "ds", "patientname"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_charset", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_charset", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_charset(self):\n        \"\"\"Test bad charset defaults to ISO IR 6\"\"\"\n        # Python 3: elem.value is PersonName3, Python 2: elem.value is str\n        elem = DataElement(0x00100010, 'PN', 'CITIZEN')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 126'])\n        # After decode Python 2: elem.value is PersonNameUnicode\n        assert 'iso_ir_126' in elem.value.encodings\n        assert 'iso8859' not in elem.value.encodings\n        # default encoding is iso8859\n        pydicom.charset.decode(elem, [])\n        assert 'iso8859' in elem.value.encodings\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_charset", "self", "test", "bad", "charset", "defaults", "to", "iso", "ir", "6", "python", "3", "elem", "value", "is", "personname3", "python", "2", "elem", "value", "is", "str", "elem", "dataelement", "0x00100010", "pn", "citizen", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "126", "after", "decode", "python", "2", "elem", "value", "is", "personnameunicode", "assert", "iso_ir_126", "in", "elem", "value", "encodings", "assert", "iso8859", "not", "in", "elem", "value", "encodings", "default", "encoding", "is", "iso8859", "pydicom", "charset", "decode", "elem", "assert", "iso8859", "in", "elem", "value", "encodings"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_encoded_single_encoding", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_encoded_single_encoding", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_encoded_single_encoding(self):\n        \"\"\"Test handling bad encoding for single encoding\"\"\"\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n\n        with pytest.warns(UserWarning, match=\"Failed to decode byte string \"\n                                             \"with encoding 'UTF8'\"):\n            pydicom.charset.decode(elem, ['ISO_IR 192'])\n            assert u'���������' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_encoded_single_encoding", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "elem", "dataelement", "0x00100010", "pn", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "with", "pytest", "warns", "userwarning", "match", "failed", "to", "decode", "byte", "string", "with", "encoding", "utf8", "pydicom", "charset", "decode", "elem", "iso_ir", "192", "assert", "u", "elem", "value"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_encoded_single_encoding_enforce_standard", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_encoded_single_encoding_enforce_standard", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_encoded_single_encoding_enforce_standard(self):\n        \"\"\"Test handling bad encoding for single encoding if\n        config.enforce_valid_values is set\"\"\"\n        config.enforce_valid_values = True\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        msg = (\"'utf.?8' codec can't decode byte 0xc4 in position 0: \"\n               \"invalid continuation byte\")\n        with pytest.raises(UnicodeDecodeError, match=msg):\n            pydicom.charset.decode(elem, ['ISO_IR 192'])\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_encoded_single_encoding_enforce_standard", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "if", "config", "enforce_valid_values", "is", "set", "config", "enforce_valid_values", "true", "elem", "dataelement", "0x00100010", "pn", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "msg", "utf", "8", "codec", "can", "t", "decode", "byte", "0xc4", "in", "position", "0", "invalid", "continuation", "byte", "with", "pytest", "raises", "unicodedecodeerror", "match", "msg", "pydicom", "charset", "decode", "elem", "iso_ir", "192"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_code_extensions_not_allowed", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_code_extensions_not_allowed", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_code_extensions_not_allowed(self):\n        \"\"\"Test that UTF8 does not allow code extensions\"\"\"\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xc3\\xa9r\\xc3\\xb4me')\n\n        msg = (\"Value 'ISO_IR 192' for Specific Character Set does not \"\n               \"allow code extensions, ignoring: ISO 2022 IR 100, \"\n               \"ISO 2022 IR 144\")\n        with pytest.warns(UserWarning, match=msg):\n            pydicom.charset.decode(elem, ['ISO_IR 192', 'ISO 2022 IR 100',\n                                          'ISO 2022 IR 144'])\n            assert u'Buc^Jérôme' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_code_extensions_not_allowed", "self", "test", "that", "utf8", "does", "not", "allow", "code", "extensions", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "msg", "value", "iso_ir", "192", "for", "specific", "character", "set", "does", "not", "allow", "code", "extensions", "ignoring", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "with", "pytest", "warns", "userwarning", "match", "msg", "pydicom", "charset", "decode", "elem", "iso_ir", "192", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "assert", "u", "buc", "j", "r", "me", "elem", "value"], "doc_len": 77}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_convert_encodings_warnings", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_convert_encodings_warnings", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_convert_encodings_warnings(self):\n        \"\"\"Test warning if stand-alone encodings are used as code extension\"\"\"\n        with pytest.warns(UserWarning, match=\"Value 'GBK' cannot be used as \"\n                                             \"code extension, ignoring it\"):\n            encodings = pydicom.charset.convert_encodings(\n                ['ISO_IR 126', 'GBK', 'ISO 2022 IR 144', 'ISO_IR 192'])\n            assert ['iso_ir_126', 'iso_ir_144'] == encodings\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_convert_encodings_warnings", "self", "test", "warning", "if", "stand", "alone", "encodings", "are", "used", "as", "code", "extension", "with", "pytest", "warns", "userwarning", "match", "value", "gbk", "cannot", "be", "used", "as", "code", "extension", "ignoring", "it", "encodings", "pydicom", "charset", "convert_encodings", "iso_ir", "126", "gbk", "iso", "2022", "ir", "144", "iso_ir", "192", "assert", "iso_ir_126", "iso_ir_144", "encodings"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_convert_python_encodings", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_convert_python_encodings", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_convert_python_encodings(self):\n        \"\"\"Test that unknown encodings are returned unchanged by\n        `convert_encodings`\"\"\"\n        encodings = ['iso_ir_126', 'iso_ir_144']\n        assert encodings == pydicom.charset.convert_encodings(encodings)\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_convert_python_encodings", "self", "test", "that", "unknown", "encodings", "are", "returned", "unchanged", "by", "convert_encodings", "encodings", "iso_ir_126", "iso_ir_144", "assert", "encodings", "pydicom", "charset", "convert_encodings", "encodings"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_decoded_multi_byte_encoding", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_decoded_multi_byte_encoding", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_decoded_multi_byte_encoding(self):\n        \"\"\"Test handling bad encoding for single encoding\"\"\"\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\x1b$(D\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n\n        with pytest.warns(UserWarning, match='Failed to decode byte string '\n                                             'with encodings: iso-2022-jp'):\n            pydicom.charset.decode(elem, ['ISO 2022 IR 159'])\n            assert u'����������' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_decoded_multi_byte_encoding", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "elem", "dataelement", "0x00100010", "pn", "b", "x1b", "d", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "with", "pytest", "warns", "userwarning", "match", "failed", "to", "decode", "byte", "string", "with", "encodings", "iso", "2022", "jp", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "159", "assert", "u", "elem", "value"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_decoded_multi_byte_encoding_enforce_standard", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_decoded_multi_byte_encoding_enforce_standard", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_decoded_multi_byte_encoding_enforce_standard(self):\n        \"\"\"Test handling bad encoding for single encoding if\n        `config.enforce_valid_values` is set\"\"\"\n        config.enforce_valid_values = True\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\x1b$(D\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        msg = (\"'iso2022_jp' codec can't decode bytes in position 0-3: \"\n               \"illegal multibyte sequence\")\n        with pytest.raises(UnicodeDecodeError, match=msg):\n            pydicom.charset.decode(elem, ['ISO 2022 IR 159'])\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_decoded_multi_byte_encoding_enforce_standard", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "if", "config", "enforce_valid_values", "is", "set", "config", "enforce_valid_values", "true", "elem", "dataelement", "0x00100010", "pn", "b", "x1b", "d", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "msg", "iso2022_jp", "codec", "can", "t", "decode", "bytes", "in", "position", "0", "3", "illegal", "multibyte", "sequence", "with", "pytest", "raises", "unicodedecodeerror", "match", "msg", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "159"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_unknown_escape_sequence", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_unknown_escape_sequence", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_unknown_escape_sequence(self):\n        \"\"\"Test handling bad encoding for single encoding\"\"\"\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\x1b\\x2d\\x46\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n\n        with pytest.warns(UserWarning, match='Found unknown escape sequence '\n                                             'in encoded string value'):\n            pydicom.charset.decode(elem, ['ISO_IR 100'])\n            assert u'\\x1b-FÄéïíõóéïò' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_unknown_escape_sequence", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "elem", "dataelement", "0x00100010", "pn", "b", "x1b", "x2d", "x46", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "with", "pytest", "warns", "userwarning", "match", "found", "unknown", "escape", "sequence", "in", "encoded", "string", "value", "pydicom", "charset", "decode", "elem", "iso_ir", "100", "assert", "u", "x1b", "f", "elem", "value"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_unknown_escape_sequence_enforce_standard", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_unknown_escape_sequence_enforce_standard", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_unknown_escape_sequence_enforce_standard(self):\n        \"\"\"Test handling bad encoding for single encoding if\n        `config.enforce_valid_values` is set\"\"\"\n        config.enforce_valid_values = True\n        elem = DataElement(0x00100010, 'PN',\n                           b'\\x1b\\x2d\\x46\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        with pytest.raises(ValueError, match='Found unknown escape sequence '\n                                             'in encoded string value'):\n            pydicom.charset.decode(elem, ['ISO_IR 100'])\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_unknown_escape_sequence_enforce_standard", "self", "test", "handling", "bad", "encoding", "for", "single", "encoding", "if", "config", "enforce_valid_values", "is", "set", "config", "enforce_valid_values", "true", "elem", "dataelement", "0x00100010", "pn", "b", "x1b", "x2d", "x46", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "with", "pytest", "raises", "valueerror", "match", "found", "unknown", "escape", "sequence", "in", "encoded", "string", "value", "pydicom", "charset", "decode", "elem", "iso_ir", "100"], "doc_len": 59}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_patched_charset", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_patched_charset", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_patched_charset(self):\n        \"\"\"Test some commonly misspelled charset values\"\"\"\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xc3\\xa9r\\xc3\\xb4me')\n        pydicom.charset.decode(elem, ['ISO_IR 192'])\n        # correct encoding\n        assert u'Buc^Jérôme' == elem.value\n\n        # patched encoding shall behave correctly, but a warning is issued\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xc3\\xa9r\\xc3\\xb4me')\n        with pytest.warns(UserWarning,\n                          match='Incorrect value for Specific Character Set '\n                                \"'ISO IR 192' - assuming 'ISO_IR 192'\"):\n            pydicom.charset.decode(elem, ['ISO IR 192'])\n            assert u'Buc^Jérôme' == elem.value\n\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xe9r\\xf4me')\n        with pytest.warns(UserWarning,\n                          match='Incorrect value for Specific Character Set '\n                                \"'ISO-IR 144' - assuming 'ISO_IR 144'\") as w:\n            pydicom.charset.decode(elem, ['ISO_IR 100', 'ISO-IR 144'])\n            # make sure no warning is issued for the correct value\n            assert 1 == len(w)\n\n        # not patched incorrect encoding is replaced by default encoding\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xc3\\xa9r\\xc3\\xb4me')\n        with pytest.warns(UserWarning,\n                          match=u\"Unknown encoding 'ISOIR 192' - \"\n                                u\"using default encoding instead\"):\n            pydicom.charset.decode(elem, ['ISOIR 192'])\n\n        # Python encoding also can be used directly\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xc3\\xa9r\\xc3\\xb4me')\n        pydicom.charset.decode(elem, ['utf8'])\n        assert u'Buc^Jérôme' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_patched_charset", "self", "test", "some", "commonly", "misspelled", "charset", "values", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "pydicom", "charset", "decode", "elem", "iso_ir", "192", "correct", "encoding", "assert", "u", "buc", "j", "r", "me", "elem", "value", "patched", "encoding", "shall", "behave", "correctly", "but", "a", "warning", "is", "issued", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "with", "pytest", "warns", "userwarning", "match", "incorrect", "value", "for", "specific", "character", "set", "iso", "ir", "192", "assuming", "iso_ir", "192", "pydicom", "charset", "decode", "elem", "iso", "ir", "192", "assert", "u", "buc", "j", "r", "me", "elem", "value", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xe9r", "xf4me", "with", "pytest", "warns", "userwarning", "match", "incorrect", "value", "for", "specific", "character", "set", "iso", "ir", "144", "assuming", "iso_ir", "144", "as", "w", "pydicom", "charset", "decode", "elem", "iso_ir", "100", "iso", "ir", "144", "make", "sure", "no", "warning", "is", "issued", "for", "the", "correct", "value", "assert", "1", "len", "w", "not", "patched", "incorrect", "encoding", "is", "replaced", "by", "default", "encoding", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "with", "pytest", "warns", "userwarning", "match", "u", "unknown", "encoding", "isoir", "192", "u", "using", "default", "encoding", "instead", "pydicom", "charset", "decode", "elem", "isoir", "192", "python", "encoding", "also", "can", "be", "used", "directly", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "pydicom", "charset", "decode", "elem", "utf8", "assert", "u", "buc", "j", "r", "me", "elem", "value"], "doc_len": 217}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_patched_code_extension_charset", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_patched_code_extension_charset", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_patched_code_extension_charset(self):\n        \"\"\"Test some commonly misspelled charset values for code extensions.\"\"\"\n        elem = DataElement(0x00100010, 'PN',\n                           b'Dionysios=\\x1b\\x2d\\x46'\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        # correct encoding\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100', 'ISO 2022 IR 126'])\n        assert u'Dionysios=Διονυσιος' == elem.value\n\n        # patched encoding shall behave correctly, but a warning is issued\n        with pytest.warns(UserWarning,\n                          match='Incorrect value for Specific Character Set '\n                                \"'ISO_2022-IR 100' - assuming \"\n                                \"'ISO 2022 IR 100'\"):\n            elem = DataElement(0x00100010, 'PN',\n                               b'Dionysios=\\x1b\\x2d\\x46'\n                               b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n            pydicom.charset.decode(elem,\n                                   ['ISO_2022-IR 100', 'ISO 2022 IR 126'])\n            assert u'Dionysios=Διονυσιος' == elem.value\n\n        with pytest.warns(UserWarning,\n                          match=r'Incorrect value for Specific Character Set '\n                                r\"'ISO_2022_IR\\+126' - assuming \"\n                                r\"'ISO 2022 IR 126'\"):\n            elem = DataElement(0x00100010, 'PN',\n                               b'Dionysios=\\x1b\\x2d\\x46'\n                               b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n            pydicom.charset.decode(elem,\n                                   ['ISO 2022 IR 100', 'ISO_2022_IR+126'])\n            assert u'Dionysios=Διονυσιος' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_patched_code_extension_charset", "self", "test", "some", "commonly", "misspelled", "charset", "values", "for", "code", "extensions", "elem", "dataelement", "0x00100010", "pn", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "correct", "encoding", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "126", "assert", "u", "dionysios", "elem", "value", "patched", "encoding", "shall", "behave", "correctly", "but", "a", "warning", "is", "issued", "with", "pytest", "warns", "userwarning", "match", "incorrect", "value", "for", "specific", "character", "set", "iso_2022", "ir", "100", "assuming", "iso", "2022", "ir", "100", "elem", "dataelement", "0x00100010", "pn", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "pydicom", "charset", "decode", "elem", "iso_2022", "ir", "100", "iso", "2022", "ir", "126", "assert", "u", "dionysios", "elem", "value", "with", "pytest", "warns", "userwarning", "match", "r", "incorrect", "value", "for", "specific", "character", "set", "r", "iso_2022_ir", "126", "assuming", "r", "iso", "2022", "ir", "126", "elem", "dataelement", "0x00100010", "pn", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso_2022_ir", "126", "assert", "u", "dionysios", "elem", "value"], "doc_len": 174}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_multi_charset_default_value", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_multi_charset_default_value", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_multi_charset_default_value(self):\n        \"\"\"Test that the first value is used if no escape code is given\"\"\"\n        # regression test for #707\n        elem = DataElement(0x00100010, 'PN', b'Buc^J\\xe9r\\xf4me')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100', 'ISO 2022 IR 144'])\n        assert u'Buc^Jérôme' == elem.value\n\n        elem = DataElement(0x00081039, 'LO', b'R\\xf6ntgenaufnahme')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100', 'ISO 2022 IR 144'])\n        assert u'Röntgenaufnahme' == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_multi_charset_default_value", "self", "test", "that", "the", "first", "value", "is", "used", "if", "no", "escape", "code", "is", "given", "regression", "test", "for", "707", "elem", "dataelement", "0x00100010", "pn", "b", "buc", "j", "xe9r", "xf4me", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "assert", "u", "buc", "j", "r", "me", "elem", "value", "elem", "dataelement", "0x00081039", "lo", "b", "r", "xf6ntgenaufnahme", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "assert", "u", "r", "ntgenaufnahme", "elem", "value"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_single_byte_multi_charset_personname", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_single_byte_multi_charset_personname", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_single_byte_multi_charset_personname(self):\n        # component groups with different encodings\n        elem = DataElement(0x00100010, 'PN',\n                           b'Dionysios=\\x1b\\x2d\\x46'\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100', 'ISO 2022 IR 126'])\n        assert u'Dionysios=Διονυσιος' == elem.value\n\n        # multiple values with different encodings\n        encoded = (b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                   b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                   b'\\x1b\\x2d\\x4C'\n                   b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3')\n        elem = DataElement(0x00100060, 'PN', encoded)\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100',\n                                      'ISO 2022 IR 144',\n                                      'ISO 2022 IR 126'])\n        assert [u'Buc^Jérôme', u'Διονυσιος', u'Люкceмбypг'] == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_single_byte_multi_charset_personname", "self", "component", "groups", "with", "different", "encodings", "elem", "dataelement", "0x00100010", "pn", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "126", "assert", "u", "dionysios", "elem", "value", "multiple", "values", "with", "different", "encodings", "encoded", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "elem", "dataelement", "0x00100060", "pn", "encoded", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "iso", "2022", "ir", "126", "assert", "u", "buc", "j", "r", "me", "u", "u", "ce", "yp", "elem", "value"], "doc_len": 121}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_single_byte_multi_charset_text", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_single_byte_multi_charset_text", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_single_byte_multi_charset_text(self):\n        # changed encoding inside the string\n        elem = DataElement(0x00081039, 'LO',\n                           b'Dionysios is \\x1b\\x2d\\x46'\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100', 'ISO 2022 IR 126'])\n        assert u'Dionysios is Διονυσιος' == elem.value\n\n        # multiple values with different encodings\n        elem = DataElement(0x00081039, 'LO',\n                           b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                           b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                           b'\\x1b\\x2d\\x4C'\n                           b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3')\n        pydicom.charset.decode(elem, ['ISO 2022 IR 100',\n                                      'ISO 2022 IR 144',\n                                      'ISO 2022 IR 126'])\n        assert [u'Buc^Jérôme', u'Διονυσιος', u'Люкceмбypг'] == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_single_byte_multi_charset_text", "self", "changed", "encoding", "inside", "the", "string", "elem", "dataelement", "0x00081039", "lo", "b", "dionysios", "is", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "126", "assert", "u", "dionysios", "is", "elem", "value", "multiple", "values", "with", "different", "encodings", "elem", "dataelement", "0x00081039", "lo", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "144", "iso", "2022", "ir", "126", "assert", "u", "buc", "j", "r", "me", "u", "u", "ce", "yp", "elem", "value"], "doc_len": 121}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_single_byte_code_extensions", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_single_byte_code_extensions", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_single_byte_code_extensions(self, encoding, decoded, raw_data):\n        # single-byte encoding as code extension\n        elem = DataElement(0x00081039, 'LO', b'ASCII+' + raw_data)\n        pydicom.charset.decode(elem, ['', encoding])\n        assert u'ASCII+' + decoded == elem.value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_single_byte_code_extensions", "self", "encoding", "decoded", "raw_data", "single", "byte", "encoding", "as", "code", "extension", "elem", "dataelement", "0x00081039", "lo", "b", "ascii", "raw_data", "pydicom", "charset", "decode", "elem", "encoding", "assert", "u", "ascii", "decoded", "elem", "value"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_charset_patient_names", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_charset_patient_names", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_charset_patient_names(self, filename, patient_name):\n        \"\"\"Test patient names are correctly decoded and encoded.\"\"\"\n        # check that patient names are correctly read\n        file_path = get_charset_files(filename + '.dcm')[0]\n        ds = dcmread(file_path)\n        ds.decode()\n        assert patient_name == ds.PatientName\n\n        # check that patient names are correctly written back\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = False\n        fp.is_little_endian = True\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds = dcmread(fp)\n        assert patient_name == ds.PatientName\n\n        # check that patient names are correctly written back\n        # without original byte string (PersonName3 only)\n        if hasattr(ds.PatientName, 'original_string'):\n            ds.PatientName.original_string = None\n            fp = DicomBytesIO()\n            fp.is_implicit_VR = False\n            fp.is_little_endian = True\n            ds.save_as(fp, write_like_original=False)\n            fp.seek(0)\n            ds = dcmread(fp)\n            assert patient_name == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_charset_patient_names", "self", "filename", "patient_name", "test", "patient", "names", "are", "correctly", "decoded", "and", "encoded", "check", "that", "patient", "names", "are", "correctly", "read", "file_path", "get_charset_files", "filename", "dcm", "0", "ds", "dcmread", "file_path", "ds", "decode", "assert", "patient_name", "ds", "patientname", "check", "that", "patient", "names", "are", "correctly", "written", "back", "fp", "dicombytesio", "fp", "is_implicit_vr", "false", "fp", "is_little_endian", "true", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds", "dcmread", "fp", "assert", "patient_name", "ds", "patientname", "check", "that", "patient", "names", "are", "correctly", "written", "back", "without", "original", "byte", "string", "personname3", "only", "if", "hasattr", "ds", "patientname", "original_string", "ds", "patientname", "original_string", "none", "fp", "dicombytesio", "fp", "is_implicit_vr", "false", "fp", "is_little_endian", "true", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds", "dcmread", "fp", "assert", "patient_name", "ds", "patientname"], "doc_len": 116}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_changed_character_set", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_changed_character_set", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_changed_character_set(self):\n        # Regression test for #629\n        multiPN_name = get_charset_files(\"chrFrenMulti.dcm\")[0]\n        ds = dcmread(multiPN_name)  # is Latin-1\n        ds.SpecificCharacterSet = 'ISO_IR 192'\n        from pydicom.filebase import DicomBytesIO\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        # we expect UTF-8 encoding here\n        assert b'Buc^J\\xc3\\xa9r\\xc3\\xb4me' == ds_out.get_item(0x00100010).value\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_changed_character_set", "self", "regression", "test", "for", "629", "multipn_name", "get_charset_files", "chrfrenmulti", "dcm", "0", "ds", "dcmread", "multipn_name", "is", "latin", "1", "ds", "specificcharacterset", "iso_ir", "192", "from", "pydicom", "filebase", "import", "dicombytesio", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "we", "expect", "utf", "8", "encoding", "here", "assert", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "ds_out", "get_item", "0x00100010", "value"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_invalid_second_encoding", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_invalid_second_encoding", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_invalid_second_encoding(self):\n        # regression test for #850\n        elem = DataElement(0x00100010, 'PN', 'CITIZEN')\n        with pytest.warns(UserWarning,\n                          match=u\"Unknown encoding 'ISO 2022 IR 146' \"\n                                u\"- using default encoding instead\"):\n            pydicom.charset.decode(\n                elem, ['ISO 2022 IR 100', 'ISO 2022 IR 146'])\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_invalid_second_encoding", "self", "regression", "test", "for", "850", "elem", "dataelement", "0x00100010", "pn", "citizen", "with", "pytest", "warns", "userwarning", "match", "u", "unknown", "encoding", "iso", "2022", "ir", "146", "u", "using", "default", "encoding", "instead", "pydicom", "charset", "decode", "elem", "iso", "2022", "ir", "100", "iso", "2022", "ir", "146"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_japanese_multi_byte_personname", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_japanese_multi_byte_personname", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_japanese_multi_byte_personname(self):\n        \"\"\"Test japanese person name which has multi byte strings are\n        correctly encoded.\"\"\"\n        file_path = get_charset_files('chrH32.dcm')[0]\n        ds = dcmread(file_path)\n        ds.decode()\n\n        if hasattr(ds.PatientName, 'original_string'):\n            original_string = ds.PatientName.original_string\n            ds.PatientName.original_string = None\n            fp = DicomBytesIO()\n            fp.is_implicit_VR = False\n            fp.is_little_endian = True\n            ds.save_as(fp, write_like_original=False)\n            fp.seek(0)\n            ds_out = dcmread(fp)\n            assert original_string == ds_out.PatientName.original_string\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_japanese_multi_byte_personname", "self", "test", "japanese", "person", "name", "which", "has", "multi", "byte", "strings", "are", "correctly", "encoded", "file_path", "get_charset_files", "chrh32", "dcm", "0", "ds", "dcmread", "file_path", "ds", "decode", "if", "hasattr", "ds", "patientname", "original_string", "original_string", "ds", "patientname", "original_string", "ds", "patientname", "original_string", "none", "fp", "dicombytesio", "fp", "is_implicit_vr", "false", "fp", "is_little_endian", "true", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "assert", "original_string", "ds_out", "patientname", "original_string"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_japanese_multi_byte_encoding", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_japanese_multi_byte_encoding", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_japanese_multi_byte_encoding(self):\n        \"\"\"Test japanese multi byte strings are correctly encoded.\"\"\"\n        encoded = pydicom.charset.encode_string(u'あaｱア',\n                                                ['shift_jis', 'iso2022_jp'])\n        assert b'\\x1b$B$\"\\x1b(Ja\\x1b)I\\xb1\\x1b$B%\"\\x1b(J' == encoded\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_japanese_multi_byte_encoding", "self", "test", "japanese", "multi", "byte", "strings", "are", "correctly", "encoded", "encoded", "pydicom", "charset", "encode_string", "u", "a", "shift_jis", "iso2022_jp", "assert", "b", "x1b", "b", "x1b", "ja", "x1b", "i", "xb1", "x1b", "b", "x1b", "j", "encoded"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_charset.py::TestCharset.test_bad_japanese_encoding", "file_path": "pydicom/tests/test_charset.py", "class_name": "TestCharset", "func_name": "test_bad_japanese_encoding", "text": "文件路径: pydicom/tests/test_charset.py, 类名: TestCharset\n    def test_bad_japanese_encoding(self):\n        \"\"\"Test japanese multi byte strings are not correctly encoded.\"\"\"\n        with pytest.warns(UserWarning,\n                          match=u\"Failed to encode value with encodings\"\n                                u\": shift_jis - using replacement character\"\n                                u\"s in encoded string\"):\n            encoded = pydicom.charset.encode_string(u'あaｱア', ['shift_jis'])\n            assert b'?a??' == encoded\n", "tokens": ["pydicom", "tests", "test_charset", "py", "testcharset", "def", "test_bad_japanese_encoding", "self", "test", "japanese", "multi", "byte", "strings", "are", "not", "correctly", "encoded", "with", "pytest", "warns", "userwarning", "match", "u", "failed", "to", "encode", "value", "with", "encodings", "u", "shift_jis", "using", "replacement", "character", "u", "s", "in", "encoded", "string", "encoded", "pydicom", "charset", "encode_string", "u", "a", "shift_jis", "assert", "b", "a", "encoded"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_compat.py::test_python_version", "file_path": "pydicom/tests/test_compat.py", "class_name": null, "func_name": "test_python_version", "text": "文件路径: pydicom/tests/test_compat.py\ndef test_python_version():\n    \"\"\"Test that the correct python version is returned\"\"\"\n    if sys.version_info[0] == 2:\n        assert in_py2\n        assert text_type == unicode\n        assert string_types == (str, unicode)\n    else:\n        assert not in_py2\n        assert text_type == str\n        assert string_types == (str,)\n\n    # Kinda redundant\n    assert in_PyPy == ('PyPy' in sys.version)\n", "tokens": ["pydicom", "tests", "test_compat", "py", "def", "test_python_version", "test", "that", "the", "correct", "python", "version", "is", "returned", "if", "sys", "version_info", "0", "2", "assert", "in_py2", "assert", "text_type", "unicode", "assert", "string_types", "str", "unicode", "else", "assert", "not", "in_py2", "assert", "text_type", "str", "assert", "string_types", "str", "kinda", "redundant", "assert", "in_pypy", "pypy", "in", "sys", "version"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_compat.py::test_reraise", "file_path": "pydicom/tests/test_compat.py", "class_name": null, "func_name": "test_reraise", "text": "文件路径: pydicom/tests/test_compat.py\ndef test_reraise():\n    \"\"\"Test reraising an exception works in both py2 and 3\"\"\"\n    def raiser():\n        raise ValueError('Some msg')\n\n    with pytest.raises(ValueError) as exc:\n        reraise(raiser())\n\n    assert str(exc.value) == 'Some msg'\n", "tokens": ["pydicom", "tests", "test_compat", "py", "def", "test_reraise", "test", "reraising", "an", "exception", "works", "in", "both", "py2", "and", "3", "def", "raiser", "raise", "valueerror", "some", "msg", "with", "pytest", "raises", "valueerror", "as", "exc", "reraise", "raiser", "assert", "str", "exc", "value", "some", "msg"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.setup", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "setup", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def setup(self):\n        self.data_elementSH = DataElement((1, 2), \"SH\", \"hello\")\n        self.data_elementIS = DataElement((1, 2), \"IS\", \"42\")\n        self.data_elementDS = DataElement((1, 2), \"DS\", \"42.00001\")\n        self.data_elementMulti = DataElement((1, 2), \"DS\",\n                                             ['42.1', '42.2', '42.3'])\n        self.data_elementCommand = DataElement(0x00000000, 'UL', 100)\n        self.data_elementPrivate = DataElement(0x00090000, 'UL', 101)\n        self.data_elementRetired = DataElement(0x00080010, 'SH', 102)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "setup", "self", "self", "data_elementsh", "dataelement", "1", "2", "sh", "hello", "self", "data_elementis", "dataelement", "1", "2", "is", "42", "self", "data_elementds", "dataelement", "1", "2", "ds", "42", "00001", "self", "data_elementmulti", "dataelement", "1", "2", "ds", "42", "1", "42", "2", "42", "3", "self", "data_elementcommand", "dataelement", "0x00000000", "ul", "100", "self", "data_elementprivate", "dataelement", "0x00090000", "ul", "101", "self", "data_elementretired", "dataelement", "0x00080010", "sh", "102"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_VM_1", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_VM_1", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_VM_1(self):\n        \"\"\"DataElement: return correct value multiplicity for VM > 1\"\"\"\n        assert 3 == self.data_elementMulti.VM\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_vm_1", "self", "dataelement", "return", "correct", "value", "multiplicity", "for", "vm", "1", "assert", "3", "self", "data_elementmulti", "vm"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_VM_2", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_VM_2", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_VM_2(self):\n        \"\"\"DataElement: return correct value multiplicity for VM = 1\"\"\"\n        assert 1 == self.data_elementIS.VM\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_vm_2", "self", "dataelement", "return", "correct", "value", "multiplicity", "for", "vm", "1", "assert", "1", "self", "data_elementis", "vm"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_DSFloat_conversion", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_DSFloat_conversion", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_DSFloat_conversion(self):\n        \"\"\"Test that strings are correctly converted if changing the value.\"\"\"\n        assert isinstance(self.data_elementDS.value, DSfloat)\n        assert isinstance(self.data_elementMulti.value[0], DSfloat)\n        assert DSfloat('42.1') == self.data_elementMulti.value[0]\n\n        # multi-value append/insert\n        self.data_elementMulti.value.append('42.4')\n        assert isinstance(self.data_elementMulti.value[3], DSfloat)\n        assert DSfloat('42.4') == self.data_elementMulti.value[3]\n\n        self.data_elementMulti.value.insert(0, '42.0')\n        assert isinstance(self.data_elementMulti.value[0], DSfloat)\n        assert DSfloat('42.0') == self.data_elementMulti.value[0]\n\n        # change single value of multi-value\n        self.data_elementMulti.value[3] = '123.4'\n        assert isinstance(self.data_elementMulti.value[3], DSfloat)\n        assert DSfloat('123.4') == self.data_elementMulti.value[3]\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_dsfloat_conversion", "self", "test", "that", "strings", "are", "correctly", "converted", "if", "changing", "the", "value", "assert", "isinstance", "self", "data_elementds", "value", "dsfloat", "assert", "isinstance", "self", "data_elementmulti", "value", "0", "dsfloat", "assert", "dsfloat", "42", "1", "self", "data_elementmulti", "value", "0", "multi", "value", "append", "insert", "self", "data_elementmulti", "value", "append", "42", "4", "assert", "isinstance", "self", "data_elementmulti", "value", "3", "dsfloat", "assert", "dsfloat", "42", "4", "self", "data_elementmulti", "value", "3", "self", "data_elementmulti", "value", "insert", "0", "42", "0", "assert", "isinstance", "self", "data_elementmulti", "value", "0", "dsfloat", "assert", "dsfloat", "42", "0", "self", "data_elementmulti", "value", "0", "change", "single", "value", "of", "multi", "value", "self", "data_elementmulti", "value", "3", "123", "4", "assert", "isinstance", "self", "data_elementmulti", "value", "3", "dsfloat", "assert", "dsfloat", "123", "4", "self", "data_elementmulti", "value", "3"], "doc_len": 113}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_backslash", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_backslash", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_backslash(self):\n        \"\"\"DataElement: String with '\\\\' sets multi-valued data_element.\"\"\"\n        data_element = DataElement((1, 2), \"DS\", r\"42.1\\42.2\\42.3\")\n        assert 3 == data_element.VM\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_backslash", "self", "dataelement", "string", "with", "sets", "multi", "valued", "data_element", "data_element", "dataelement", "1", "2", "ds", "r", "42", "1", "42", "2", "42", "3", "assert", "3", "data_element", "vm"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_UID", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_UID", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_UID(self):\n        \"\"\"DataElement: setting or changing UID results in UID type.\"\"\"\n        ds = Dataset()\n        ds.TransferSyntaxUID = \"1.2.3\"\n        assert isinstance(ds.TransferSyntaxUID, UID)\n        ds.TransferSyntaxUID += \".4.5.6\"\n        assert isinstance(ds.TransferSyntaxUID, UID)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_uid", "self", "dataelement", "setting", "or", "changing", "uid", "results", "in", "uid", "type", "ds", "dataset", "ds", "transfersyntaxuid", "1", "2", "3", "assert", "isinstance", "ds", "transfersyntaxuid", "uid", "ds", "transfersyntaxuid", "4", "5", "6", "assert", "isinstance", "ds", "transfersyntaxuid", "uid"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_keyword", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_keyword", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_keyword(self):\n        \"\"\"DataElement: return correct keyword\"\"\"\n        assert 'CommandGroupLength' == self.data_elementCommand.keyword\n        assert '' == self.data_elementPrivate.keyword\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_keyword", "self", "dataelement", "return", "correct", "keyword", "assert", "commandgrouplength", "self", "data_elementcommand", "keyword", "assert", "self", "data_elementprivate", "keyword"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_retired", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_retired", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_retired(self):\n        \"\"\"DataElement: return correct is_retired\"\"\"\n        assert self.data_elementCommand.is_retired is False\n        assert self.data_elementRetired.is_retired is True\n        assert self.data_elementPrivate.is_retired is False\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_retired", "self", "dataelement", "return", "correct", "is_retired", "assert", "self", "data_elementcommand", "is_retired", "is", "false", "assert", "self", "data_elementretired", "is_retired", "is", "true", "assert", "self", "data_elementprivate", "is_retired", "is", "false"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_description_group_length", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_description_group_length", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_description_group_length(self):\n        \"\"\"Test DataElement.description for Group Length element\"\"\"\n        elem = DataElement(0x00100000, 'LO', 12345)\n        assert 'Group Length' == elem.description()\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_description_group_length", "self", "test", "dataelement", "description", "for", "group", "length", "element", "elem", "dataelement", "0x00100000", "lo", "12345", "assert", "group", "length", "elem", "description"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_description_unknown_private", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_description_unknown_private", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_description_unknown_private(self):\n        \"\"\"Test DataElement.description with an unknown private element\"\"\"\n        elem = DataElement(0x00110010, 'LO', 12345)\n        elem.private_creator = 'TEST'\n        assert 'Private tag data' == elem.description()\n        elem = DataElement(0x00110F00, 'LO', 12345)\n        assert elem.tag.is_private\n        assert not hasattr(elem, 'private_creator')\n        assert 'Private tag data' == elem.description()\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_description_unknown_private", "self", "test", "dataelement", "description", "with", "an", "unknown", "private", "element", "elem", "dataelement", "0x00110010", "lo", "12345", "elem", "private_creator", "test", "assert", "private", "tag", "data", "elem", "description", "elem", "dataelement", "0x00110f00", "lo", "12345", "assert", "elem", "tag", "is_private", "assert", "not", "hasattr", "elem", "private_creator", "assert", "private", "tag", "data", "elem", "description"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_description_unknown", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_description_unknown", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_description_unknown(self):\n        \"\"\"Test DataElement.description with an unknown element\"\"\"\n        elem = DataElement(0x00000004, 'LO', 12345)\n        assert '' == elem.description()\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_description_unknown", "self", "test", "dataelement", "description", "with", "an", "unknown", "element", "elem", "dataelement", "0x00000004", "lo", "12345", "assert", "elem", "description"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_standard_element", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_standard_element", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_standard_element(self):\n        \"\"\"DataElement: equality returns correct value for simple elements\"\"\"\n        dd = DataElement(0x00100010, 'PN', 'ANON')\n        assert dd == dd\n        ee = DataElement(0x00100010, 'PN', 'ANON')\n        assert dd == ee\n\n        # Check value\n        ee.value = 'ANAN'\n        assert not dd == ee\n\n        # Check tag\n        ee = DataElement(0x00100011, 'PN', 'ANON')\n        assert not dd == ee\n\n        # Check VR\n        ee = DataElement(0x00100010, 'SH', 'ANON')\n        assert not dd == ee\n\n        dd = DataElement(0x00080018, 'UI', '1.2.3.4')\n        ee = DataElement(0x00080018, 'UI', '1.2.3.4')\n        assert dd == ee\n\n        ee = DataElement(0x00080018, 'PN', '1.2.3.4')\n        assert not dd == ee\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_standard_element", "self", "dataelement", "equality", "returns", "correct", "value", "for", "simple", "elements", "dd", "dataelement", "0x00100010", "pn", "anon", "assert", "dd", "dd", "ee", "dataelement", "0x00100010", "pn", "anon", "assert", "dd", "ee", "check", "value", "ee", "value", "anan", "assert", "not", "dd", "ee", "check", "tag", "ee", "dataelement", "0x00100011", "pn", "anon", "assert", "not", "dd", "ee", "check", "vr", "ee", "dataelement", "0x00100010", "sh", "anon", "assert", "not", "dd", "ee", "dd", "dataelement", "0x00080018", "ui", "1", "2", "3", "4", "ee", "dataelement", "0x00080018", "ui", "1", "2", "3", "4", "assert", "dd", "ee", "ee", "dataelement", "0x00080018", "pn", "1", "2", "3", "4", "assert", "not", "dd", "ee"], "doc_len": 94}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_private_element", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_private_element", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_private_element(self):\n        \"\"\"DataElement: equality returns correct value for private elements\"\"\"\n        dd = DataElement(0x01110001, 'PN', 'ANON')\n        assert dd == dd\n        ee = DataElement(0x01110001, 'PN', 'ANON')\n        assert dd == ee\n\n        # Check value\n        ee.value = 'ANAN'\n        assert not dd == ee\n\n        # Check tag\n        ee = DataElement(0x01110002, 'PN', 'ANON')\n        assert not dd == ee\n\n        # Check VR\n        ee = DataElement(0x01110001, 'SH', 'ANON')\n        assert not dd == ee\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_private_element", "self", "dataelement", "equality", "returns", "correct", "value", "for", "private", "elements", "dd", "dataelement", "0x01110001", "pn", "anon", "assert", "dd", "dd", "ee", "dataelement", "0x01110001", "pn", "anon", "assert", "dd", "ee", "check", "value", "ee", "value", "anan", "assert", "not", "dd", "ee", "check", "tag", "ee", "dataelement", "0x01110002", "pn", "anon", "assert", "not", "dd", "ee", "check", "vr", "ee", "dataelement", "0x01110001", "sh", "anon", "assert", "not", "dd", "ee"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_sequence_element", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_sequence_element", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_sequence_element(self):\n        \"\"\"DataElement: equality returns correct value for sequence elements\"\"\"\n        dd = DataElement(0x300A00B0, 'SQ', [])\n        assert dd == dd\n        ee = DataElement(0x300A00B0, 'SQ', [])\n        assert dd == ee\n\n        # Check value\n        e = Dataset()\n        e.PatientName = 'ANON'\n        ee.value = [e]\n        assert not dd == ee\n\n        # Check tag\n        ee = DataElement(0x01110002, 'SQ', [])\n        assert not dd == ee\n\n        # Check VR\n        ee = DataElement(0x300A00B0, 'SH', [])\n        assert not dd == ee\n\n        # Check with dataset\n        dd = DataElement(0x300A00B0, 'SQ', [Dataset()])\n        dd.value[0].PatientName = 'ANON'\n        ee = DataElement(0x300A00B0, 'SQ', [Dataset()])\n        ee.value[0].PatientName = 'ANON'\n        assert dd == ee\n\n        # Check uneven sequences\n        dd.value.append(Dataset())\n        dd.value[1].PatientName = 'ANON'\n        assert not dd == ee\n\n        ee.value.append(Dataset())\n        ee.value[1].PatientName = 'ANON'\n        assert dd == ee\n        ee.value.append(Dataset())\n        ee.value[2].PatientName = 'ANON'\n        assert not dd == ee\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_sequence_element", "self", "dataelement", "equality", "returns", "correct", "value", "for", "sequence", "elements", "dd", "dataelement", "0x300a00b0", "sq", "assert", "dd", "dd", "ee", "dataelement", "0x300a00b0", "sq", "assert", "dd", "ee", "check", "value", "e", "dataset", "e", "patientname", "anon", "ee", "value", "e", "assert", "not", "dd", "ee", "check", "tag", "ee", "dataelement", "0x01110002", "sq", "assert", "not", "dd", "ee", "check", "vr", "ee", "dataelement", "0x300a00b0", "sh", "assert", "not", "dd", "ee", "check", "with", "dataset", "dd", "dataelement", "0x300a00b0", "sq", "dataset", "dd", "value", "0", "patientname", "anon", "ee", "dataelement", "0x300a00b0", "sq", "dataset", "ee", "value", "0", "patientname", "anon", "assert", "dd", "ee", "check", "uneven", "sequences", "dd", "value", "append", "dataset", "dd", "value", "1", "patientname", "anon", "assert", "not", "dd", "ee", "ee", "value", "append", "dataset", "ee", "value", "1", "patientname", "anon", "assert", "dd", "ee", "ee", "value", "append", "dataset", "ee", "value", "2", "patientname", "anon", "assert", "not", "dd", "ee"], "doc_len": 131}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_not_rlement", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_not_rlement", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_not_rlement(self):\n        \"\"\"DataElement: equality returns correct value when not same class\"\"\"\n        dd = DataElement(0x00100010, 'PN', 'ANON')\n        ee = {'0x00100010': 'ANON'}\n        assert not dd == ee\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_not_rlement", "self", "dataelement", "equality", "returns", "correct", "value", "when", "not", "same", "class", "dd", "dataelement", "0x00100010", "pn", "anon", "ee", "0x00100010", "anon", "assert", "not", "dd", "ee"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_inheritance", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_inheritance", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_inheritance(self):\n        \"\"\"DataElement: equality returns correct value for subclasses\"\"\"\n\n        class DataElementPlus(DataElement):\n            pass\n\n        dd = DataElement(0x00100010, 'PN', 'ANON')\n        ee = DataElementPlus(0x00100010, 'PN', 'ANON')\n        assert ee == ee\n        assert dd == ee\n        assert ee == dd\n\n        ee = DataElementPlus(0x00100010, 'PN', 'ANONY')\n        assert not dd == ee\n        assert not ee == dd\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_inheritance", "self", "dataelement", "equality", "returns", "correct", "value", "for", "subclasses", "class", "dataelementplus", "dataelement", "pass", "dd", "dataelement", "0x00100010", "pn", "anon", "ee", "dataelementplus", "0x00100010", "pn", "anon", "assert", "ee", "ee", "assert", "dd", "ee", "assert", "ee", "dd", "ee", "dataelementplus", "0x00100010", "pn", "anony", "assert", "not", "dd", "ee", "assert", "not", "ee", "dd"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_equality_class_members", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_equality_class_members", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_equality_class_members(self):\n        \"\"\"Test equality is correct when ignored class members differ.\"\"\"\n        dd = DataElement(0x00100010, 'PN', 'ANON')\n        dd.showVR = False\n        dd.file_tell = 10\n        dd.maxBytesToDisplay = 0\n        dd.descripWidth = 0\n        assert DataElement(0x00100010, 'PN', 'ANON') == dd\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_equality_class_members", "self", "test", "equality", "is", "correct", "when", "ignored", "class", "members", "differ", "dd", "dataelement", "0x00100010", "pn", "anon", "dd", "showvr", "false", "dd", "file_tell", "10", "dd", "maxbytestodisplay", "0", "dd", "descripwidth", "0", "assert", "dataelement", "0x00100010", "pn", "anon", "dd"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_inequality_standard", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_inequality_standard", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_inequality_standard(self):\n        \"\"\"Test DataElement.__ne__ for standard element\"\"\"\n        dd = DataElement(0x00100010, 'PN', 'ANON')\n        assert not dd != dd\n        assert DataElement(0x00100010, 'PN', 'ANONA') != dd\n\n        # Check tag\n        assert DataElement(0x00100011, 'PN', 'ANON') != dd\n\n        # Check VR\n        assert DataElement(0x00100010, 'SH', 'ANON') != dd\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_inequality_standard", "self", "test", "dataelement", "__ne__", "for", "standard", "element", "dd", "dataelement", "0x00100010", "pn", "anon", "assert", "not", "dd", "dd", "assert", "dataelement", "0x00100010", "pn", "anona", "dd", "check", "tag", "assert", "dataelement", "0x00100011", "pn", "anon", "dd", "check", "vr", "assert", "dataelement", "0x00100010", "sh", "anon", "dd"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_inequality_sequence", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_inequality_sequence", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_inequality_sequence(self):\n        \"\"\"Test DataElement.__ne__ for sequence element\"\"\"\n        dd = DataElement(0x300A00B0, 'SQ', [])\n        assert not dd != dd\n        assert not DataElement(0x300A00B0, 'SQ', []) != dd\n        ee = DataElement(0x300A00B0, 'SQ', [Dataset()])\n        assert ee != dd\n\n        # Check value\n        dd.value = [Dataset()]\n        dd[0].PatientName = 'ANON'\n        ee[0].PatientName = 'ANON'\n        assert not ee != dd\n        ee[0].PatientName = 'ANONA'\n        assert ee != dd\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_inequality_sequence", "self", "test", "dataelement", "__ne__", "for", "sequence", "element", "dd", "dataelement", "0x300a00b0", "sq", "assert", "not", "dd", "dd", "assert", "not", "dataelement", "0x300a00b0", "sq", "dd", "ee", "dataelement", "0x300a00b0", "sq", "dataset", "assert", "ee", "dd", "check", "value", "dd", "value", "dataset", "dd", "0", "patientname", "anon", "ee", "0", "patientname", "anon", "assert", "not", "ee", "dd", "ee", "0", "patientname", "anona", "assert", "ee", "dd"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_hash", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_hash(self):\n        \"\"\"Test hash(DataElement) raises TypeError\"\"\"\n        with pytest.raises(TypeError, match=r\"unhashable\"):\n            hash(DataElement(0x00100010, 'PN', 'ANON'))\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_hash", "self", "test", "hash", "dataelement", "raises", "typeerror", "with", "pytest", "raises", "typeerror", "match", "r", "unhashable", "hash", "dataelement", "0x00100010", "pn", "anon"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_repeater_str", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_repeater_str", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_repeater_str(self):\n        \"\"\"Test a repeater group element displays the element name.\"\"\"\n        elem = DataElement(0x60023000, 'OB', b'\\x00')\n        assert 'Overlay Data' in elem.__str__()\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_repeater_str", "self", "test", "a", "repeater", "group", "element", "displays", "the", "element", "name", "elem", "dataelement", "0x60023000", "ob", "b", "x00", "assert", "overlay", "data", "in", "elem", "__str__"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_str_no_vr", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_str_no_vr", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_str_no_vr(self):\n        \"\"\"Test DataElement.__str__ output with no VR\"\"\"\n        elem = DataElement(0x00100010, 'PN', 'ANON')\n        assert \"(0010, 0010) Patient's Name\" in str(elem)\n        assert \"PN: 'ANON'\" in str(elem)\n        elem.showVR = False\n        assert \"(0010, 0010) Patient's Name\" in str(elem)\n        assert 'PN' not in str(elem)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_str_no_vr", "self", "test", "dataelement", "__str__", "output", "with", "no", "vr", "elem", "dataelement", "0x00100010", "pn", "anon", "assert", "0010", "0010", "patient", "s", "name", "in", "str", "elem", "assert", "pn", "anon", "in", "str", "elem", "elem", "showvr", "false", "assert", "0010", "0010", "patient", "s", "name", "in", "str", "elem", "assert", "pn", "not", "in", "str", "elem"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_repr_seq", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_repr_seq", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_repr_seq(self):\n        \"\"\"Test DataElement.__repr__ with a sequence\"\"\"\n        elem = DataElement(0x300A00B0, 'SQ', [Dataset()])\n        elem[0].PatientID = '1234'\n        assert repr(elem) == repr(elem.value)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_repr_seq", "self", "test", "dataelement", "__repr__", "with", "a", "sequence", "elem", "dataelement", "0x300a00b0", "sq", "dataset", "elem", "0", "patientid", "1234", "assert", "repr", "elem", "repr", "elem", "value"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_unicode", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_unicode", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_unicode(self):\n        \"\"\"Test unicode representation of the DataElement\"\"\"\n        elem = DataElement(0x00100010, 'PN', u'ANON')\n        # Make sure elem.value is actually unicode\n        assert isinstance(elem.value, unicode)\n        assert (\n            u\"(0010, 0010) Patient's Name                      PN: ANON\"\n        ) == unicode(elem)\n        assert isinstance(unicode(elem), unicode)\n        assert not isinstance(unicode(elem), str)\n        # Make sure elem.value is still unicode\n        assert isinstance(elem.value, unicode)\n\n        # When value is not in compat.text_type\n        elem = DataElement(0x00100010, 'LO', 12345)\n        assert isinstance(unicode(elem), unicode)\n        assert (\n            u\"(0010, 0010) Patient's Name                      LO: 12345\"\n        ) == unicode(elem)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_unicode", "self", "test", "unicode", "representation", "of", "the", "dataelement", "elem", "dataelement", "0x00100010", "pn", "u", "anon", "make", "sure", "elem", "value", "is", "actually", "unicode", "assert", "isinstance", "elem", "value", "unicode", "assert", "u", "0010", "0010", "patient", "s", "name", "pn", "anon", "unicode", "elem", "assert", "isinstance", "unicode", "elem", "unicode", "assert", "not", "isinstance", "unicode", "elem", "str", "make", "sure", "elem", "value", "is", "still", "unicode", "assert", "isinstance", "elem", "value", "unicode", "when", "value", "is", "not", "in", "compat", "text_type", "elem", "dataelement", "0x00100010", "lo", "12345", "assert", "isinstance", "unicode", "elem", "unicode", "assert", "u", "0010", "0010", "patient", "s", "name", "lo", "12345", "unicode", "elem"], "doc_len": 94}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_getitem_raises", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_getitem_raises", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_getitem_raises(self):\n        \"\"\"Test DataElement.__getitem__ raise if value not indexable\"\"\"\n        elem = DataElement(0x00100010, 'LO', 12345)\n        with pytest.raises(TypeError):\n            elem[0]\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_getitem_raises", "self", "test", "dataelement", "__getitem__", "raise", "if", "value", "not", "indexable", "elem", "dataelement", "0x00100010", "lo", "12345", "with", "pytest", "raises", "typeerror", "elem", "0"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_repval_large_elem", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_repval_large_elem", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_repval_large_elem(self):\n        \"\"\"Test DataElement.repval doesn't return a huge string for a large\n        value\"\"\"\n        elem = DataElement(0x00820003, 'UT', 'a'*1000)\n        assert len(elem.repval) < 100\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_repval_large_elem", "self", "test", "dataelement", "repval", "doesn", "t", "return", "a", "huge", "string", "for", "a", "large", "value", "elem", "dataelement", "0x00820003", "ut", "a", "1000", "assert", "len", "elem", "repval", "100"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_repval_large_vm", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_repval_large_vm", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_repval_large_vm(self):\n        \"\"\"Test DataElement.repval doesn't return a huge string for a large\n        vm\"\"\"\n        elem = DataElement(0x00080054, 'AE', 'a\\\\'*1000+'a')\n        assert len(elem.repval) < 100\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_repval_large_vm", "self", "test", "dataelement", "repval", "doesn", "t", "return", "a", "huge", "string", "for", "a", "large", "vm", "elem", "dataelement", "0x00080054", "ae", "a", "1000", "a", "assert", "len", "elem", "repval", "100"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_repval_strange_type", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_repval_strange_type", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_repval_strange_type(self):\n        \"\"\"Test DataElement.repval doesn't break with bad types\"\"\"\n        elem = DataElement(0x00020001, 'OB', 0)\n        assert len(elem.repval) < 100\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_repval_strange_type", "self", "test", "dataelement", "repval", "doesn", "t", "break", "with", "bad", "types", "elem", "dataelement", "0x00020001", "ob", "0", "assert", "len", "elem", "repval", "100"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_private_tag_in_repeater_range", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_private_tag_in_repeater_range", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_private_tag_in_repeater_range(self):\n        \"\"\"Test that an unknown private tag (e.g. a tag not in the private\n        dictionary) in the repeater range is not handled as a repeater tag\n        if using Implicit Little Endian transfer syntax.\"\"\"\n        # regression test for #689\n        ds = Dataset()\n        ds[0x50f10010] = RawDataElement(\n            Tag(0x50f10010), None, 8, b'FDMS 1.0', 0, True, True)\n        ds[0x50f1100a] = RawDataElement(\n            Tag(0x50f1100a), None, 6, b'ACC0.6', 0, True, True)\n        private_creator_data_elem = ds[0x50f10010]\n        assert 'Private Creator' == private_creator_data_elem.name\n        assert 'LO' == private_creator_data_elem.VR\n\n        private_data_elem = ds[0x50f1100a]\n        assert '[FNC Parameters]' == private_data_elem.name\n        assert 'UN' == private_data_elem.VR\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_private_tag_in_repeater_range", "self", "test", "that", "an", "unknown", "private", "tag", "e", "g", "a", "tag", "not", "in", "the", "private", "dictionary", "in", "the", "repeater", "range", "is", "not", "handled", "as", "a", "repeater", "tag", "if", "using", "implicit", "little", "endian", "transfer", "syntax", "regression", "test", "for", "689", "ds", "dataset", "ds", "0x50f10010", "rawdataelement", "tag", "0x50f10010", "none", "8", "b", "fdms", "1", "0", "0", "true", "true", "ds", "0x50f1100a", "rawdataelement", "tag", "0x50f1100a", "none", "6", "b", "acc0", "6", "0", "true", "true", "private_creator_data_elem", "ds", "0x50f10010", "assert", "private", "creator", "private_creator_data_elem", "name", "assert", "lo", "private_creator_data_elem", "vr", "private_data_elem", "ds", "0x50f1100a", "assert", "fnc", "parameters", "private_data_elem", "name", "assert", "un", "private_data_elem", "vr"], "doc_len": 98}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_private_repeater_tag", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_private_repeater_tag", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_private_repeater_tag(self):\n        \"\"\"Test that a known private tag in the repeater range is correctly\n        handled using Implicit Little Endian transfer syntax.\"\"\"\n        ds = Dataset()\n        ds[0x60210012] = RawDataElement(\n            Tag(0x60210012), None, 12, b'PAPYRUS 3.0 ', 0, True, True)\n        ds[0x60211200] = RawDataElement(\n            Tag(0x60211200), None, 6, b'123456', 0, True, True)\n        private_creator_data_elem = ds[0x60210012]\n        assert 'Private Creator' == private_creator_data_elem.name\n        assert 'LO' == private_creator_data_elem.VR\n\n        private_data_elem = ds[0x60211200]\n        assert '[Overlay ID]' == private_data_elem.name\n        assert 'UN' == private_data_elem.VR\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_private_repeater_tag", "self", "test", "that", "a", "known", "private", "tag", "in", "the", "repeater", "range", "is", "correctly", "handled", "using", "implicit", "little", "endian", "transfer", "syntax", "ds", "dataset", "ds", "0x60210012", "rawdataelement", "tag", "0x60210012", "none", "12", "b", "papyrus", "3", "0", "0", "true", "true", "ds", "0x60211200", "rawdataelement", "tag", "0x60211200", "none", "6", "b", "123456", "0", "true", "true", "private_creator_data_elem", "ds", "0x60210012", "assert", "private", "creator", "private_creator_data_elem", "name", "assert", "lo", "private_creator_data_elem", "vr", "private_data_elem", "ds", "0x60211200", "assert", "overlay", "id", "private_data_elem", "name", "assert", "un", "private_data_elem", "vr"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_empty_text_values", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_empty_text_values", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_empty_text_values(self):\n        \"\"\"Test that assigning an empty value behaves as expected.\"\"\"\n        def check_empty_text_element(value):\n            setattr(ds, tag_name, value)\n            elem = ds[tag_name]\n            assert bool(elem.value) is False\n\n        text_vrs = {\n            'AE': 'Receiver',\n            'AS': 'PatientAge',\n            'AT': 'OffendingElement',\n            'CS': 'QualityControlSubject',\n            'DA': 'PatientBirthDate',\n            'DS': 'PatientWeight',\n            'DT': 'AcquisitionDateTime',\n            'IS': 'BeamNumber',\n            'LO': 'DataSetSubtype',\n            'LT': 'ExtendedCodeMeaning',\n            'PN': 'PatientName',\n            'SH': 'CodeValue',\n            'ST': 'InstitutionAddress',\n            'TM': 'StudyTime',\n            'UC': 'LongCodeValue',\n            'UI': 'SOPClassUID',\n            'UR': 'CodingSchemeURL',\n            'UT': 'StrainAdditionalInformation',\n        }\n        ds = Dataset()\n        # set value to new element\n        for tag_name in text_vrs.values():\n            check_empty_text_element(None)\n            del ds[tag_name]\n            check_empty_text_element(b'')\n            del ds[tag_name]\n            check_empty_text_element(u'')\n            del ds[tag_name]\n            check_empty_text_element([])\n            del ds[tag_name]\n\n        # set value to existing element\n        for tag_name in text_vrs.values():\n            check_empty_text_element(None)\n            check_empty_text_element(b'')\n            check_empty_text_element(u'')\n            check_empty_text_element([])\n            check_empty_text_element(None)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_empty_text_values", "self", "test", "that", "assigning", "an", "empty", "value", "behaves", "as", "expected", "def", "check_empty_text_element", "value", "setattr", "ds", "tag_name", "value", "elem", "ds", "tag_name", "assert", "bool", "elem", "value", "is", "false", "text_vrs", "ae", "receiver", "as", "patientage", "at", "offendingelement", "cs", "qualitycontrolsubject", "da", "patientbirthdate", "ds", "patientweight", "dt", "acquisitiondatetime", "is", "beamnumber", "lo", "datasetsubtype", "lt", "extendedcodemeaning", "pn", "patientname", "sh", "codevalue", "st", "institutionaddress", "tm", "studytime", "uc", "longcodevalue", "ui", "sopclassuid", "ur", "codingschemeurl", "ut", "strainadditionalinformation", "ds", "dataset", "set", "value", "to", "new", "element", "for", "tag_name", "in", "text_vrs", "values", "check_empty_text_element", "none", "del", "ds", "tag_name", "check_empty_text_element", "b", "del", "ds", "tag_name", "check_empty_text_element", "u", "del", "ds", "tag_name", "check_empty_text_element", "del", "ds", "tag_name", "set", "value", "to", "existing", "element", "for", "tag_name", "in", "text_vrs", "values", "check_empty_text_element", "none", "check_empty_text_element", "b", "check_empty_text_element", "u", "check_empty_text_element", "check_empty_text_element", "none"], "doc_len": 120}
{"doc_id": "pydicom/tests/test_dataelem.py::TestDataElement.test_empty_binary_values", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestDataElement", "func_name": "test_empty_binary_values", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestDataElement\n    def test_empty_binary_values(self):\n        \"\"\"Test that assigning an empty value behaves as expected for\n        non-text VRs.\"\"\"\n        def check_empty_binary_element(value):\n            setattr(ds, tag_name, value)\n            elem = ds[tag_name]\n            assert bool(elem.value) is False\n\n        non_text_vrs = {\n            'SL': 'RationalNumeratorValue',\n            'SS': 'SelectorSSValue',\n            'UL': 'SimpleFrameList',\n            'US': 'SourceAcquisitionBeamNumber',\n            'FD': 'RealWorldValueLUTData',\n            'FL': 'VectorAccuracy',\n            'OB': 'FillPattern',\n            'OD': 'DoubleFloatPixelData',\n            'OF': 'UValueData',\n            'OL': 'TrackPointIndexList',\n            'OW': 'TrianglePointIndexList',\n            'UN': 'SelectorUNValue',\n        }\n        ds = Dataset()\n        # set value to new element\n        for tag_name in non_text_vrs.values():\n            check_empty_binary_element(None)\n            del ds[tag_name]\n            check_empty_binary_element([])\n            del ds[tag_name]\n            check_empty_binary_element(MultiValue(int, []))\n            del ds[tag_name]\n\n        # set value to existing element\n        for tag_name in non_text_vrs.values():\n            check_empty_binary_element(None)\n            check_empty_binary_element([])\n            check_empty_binary_element(MultiValue(int, []))\n            check_empty_binary_element(None)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testdataelement", "def", "test_empty_binary_values", "self", "test", "that", "assigning", "an", "empty", "value", "behaves", "as", "expected", "for", "non", "text", "vrs", "def", "check_empty_binary_element", "value", "setattr", "ds", "tag_name", "value", "elem", "ds", "tag_name", "assert", "bool", "elem", "value", "is", "false", "non_text_vrs", "sl", "rationalnumeratorvalue", "ss", "selectorssvalue", "ul", "simpleframelist", "us", "sourceacquisitionbeamnumber", "fd", "realworldvaluelutdata", "fl", "vectoraccuracy", "ob", "fillpattern", "od", "doublefloatpixeldata", "of", "uvaluedata", "ol", "trackpointindexlist", "ow", "trianglepointindexlist", "un", "selectorunvalue", "ds", "dataset", "set", "value", "to", "new", "element", "for", "tag_name", "in", "non_text_vrs", "values", "check_empty_binary_element", "none", "del", "ds", "tag_name", "check_empty_binary_element", "del", "ds", "tag_name", "check_empty_binary_element", "multivalue", "int", "del", "ds", "tag_name", "set", "value", "to", "existing", "element", "for", "tag_name", "in", "non_text_vrs", "values", "check_empty_binary_element", "none", "check_empty_binary_element", "check_empty_binary_element", "multivalue", "int", "check_empty_binary_element", "none"], "doc_len": 107}
{"doc_id": "pydicom/tests/test_dataelem.py::TestRawDataElement.test_key_error", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestRawDataElement", "func_name": "test_key_error", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestRawDataElement\n    def test_key_error(self):\n        \"\"\"RawDataElement: conversion of unknown tag throws KeyError...\"\"\"\n        # raw data element -> tag VR length value\n        #                       value_tell is_implicit_VR is_little_endian'\n        # Unknown (not in DICOM dict), non-private, non-group 0 for this test\n        raw = RawDataElement(Tag(0x88880002), None, 4, 0x1111,\n                             0, True, True)\n\n        with pytest.raises(KeyError, match=r\"\\(8888, 0002\\)\"):\n            DataElement_from_raw(raw)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testrawdataelement", "def", "test_key_error", "self", "rawdataelement", "conversion", "of", "unknown", "tag", "throws", "keyerror", "raw", "data", "element", "tag", "vr", "length", "value", "value_tell", "is_implicit_vr", "is_little_endian", "unknown", "not", "in", "dicom", "dict", "non", "private", "non", "group", "0", "for", "this", "test", "raw", "rawdataelement", "tag", "0x88880002", "none", "4", "0x1111", "0", "true", "true", "with", "pytest", "raises", "keyerror", "match", "r", "8888", "0002", "dataelement_from_raw", "raw"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_dataelem.py::TestRawDataElement.test_valid_tag", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestRawDataElement", "func_name": "test_valid_tag", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestRawDataElement\n    def test_valid_tag(self):\n        \"\"\"RawDataElement: conversion of known tag succeeds...\"\"\"\n        raw = RawDataElement(Tag(0x00080020), 'DA', 8, b'20170101',\n                             0, False, True)\n        element = DataElement_from_raw(raw, default_encoding)\n        assert 'Study Date' == element.name\n        assert 'DA' == element.VR\n        assert '20170101' == element.value\n\n        raw = RawDataElement(Tag(0x00080000), None, 4, b'\\x02\\x00\\x00\\x00',\n                             0, True, True)\n        elem = DataElement_from_raw(raw, default_encoding)\n        assert 'UL' == elem.VR\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testrawdataelement", "def", "test_valid_tag", "self", "rawdataelement", "conversion", "of", "known", "tag", "succeeds", "raw", "rawdataelement", "tag", "0x00080020", "da", "8", "b", "20170101", "0", "false", "true", "element", "dataelement_from_raw", "raw", "default_encoding", "assert", "study", "date", "element", "name", "assert", "da", "element", "vr", "assert", "20170101", "element", "value", "raw", "rawdataelement", "tag", "0x00080000", "none", "4", "b", "x02", "x00", "x00", "x00", "0", "true", "true", "elem", "dataelement_from_raw", "raw", "default_encoding", "assert", "ul", "elem", "vr"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_dataelem.py::TestRawDataElement.test_data_element_without_encoding", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestRawDataElement", "func_name": "test_data_element_without_encoding", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestRawDataElement\n    def test_data_element_without_encoding(self):\n        \"\"\"RawDataElement: no encoding needed.\"\"\"\n        raw = RawDataElement(Tag(0x00104000), 'LT', 23,\n                             b'comment\\\\comment2\\\\comment3',\n                             0, False, True)\n        element = DataElement_from_raw(raw)\n        assert 'Patient Comments' == element.name\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testrawdataelement", "def", "test_data_element_without_encoding", "self", "rawdataelement", "no", "encoding", "needed", "raw", "rawdataelement", "tag", "0x00104000", "lt", "23", "b", "comment", "comment2", "comment3", "0", "false", "true", "element", "dataelement_from_raw", "raw", "assert", "patient", "comments", "element", "name"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_dataelem.py::TestRawDataElement.test_unknown_vr", "file_path": "pydicom/tests/test_dataelem.py", "class_name": "TestRawDataElement", "func_name": "test_unknown_vr", "text": "文件路径: pydicom/tests/test_dataelem.py, 类名: TestRawDataElement\n    def test_unknown_vr(self):\n        \"\"\"Test converting a raw element with unknown VR\"\"\"\n        raw = RawDataElement(Tag(0x00080000), 'AA', 8, b'20170101',\n                             0, False, True)\n        with pytest.raises(NotImplementedError):\n            DataElement_from_raw(raw, default_encoding)\n", "tokens": ["pydicom", "tests", "test_dataelem", "py", "testrawdataelement", "def", "test_unknown_vr", "self", "test", "converting", "a", "raw", "element", "with", "unknown", "vr", "raw", "rawdataelement", "tag", "0x00080000", "aa", "8", "b", "20170101", "0", "false", "true", "with", "pytest", "raises", "notimplementederror", "dataelement_from_raw", "raw", "default_encoding"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_dataset.py::BadRepr.__repr__", "file_path": "pydicom/tests/test_dataset.py", "class_name": "BadRepr", "func_name": "__repr__", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: BadRepr\n    def __repr__(self):\n        raise ValueError(\"bad repr\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "badrepr", "def", "__repr__", "self", "raise", "valueerror", "bad", "repr"], "doc_len": 12}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.setup", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "setup", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def setup(self):\n        self.ds = Dataset()\n        self.ds.TreatmentMachineName = \"unit001\"\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "setup", "self", "self", "ds", "dataset", "self", "ds", "treatmentmachinename", "unit001"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_attribute_error_in_property", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_attribute_error_in_property", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_attribute_error_in_property(self):\n        \"\"\"Dataset: AttributeError in property raises actual error message.\"\"\"\n        # This comes from bug fix for issue 42\n        # First, fake enough to try the pixel_array property\n        ds = Dataset()\n        ds.file_meta = Dataset()\n        ds.PixelData = 'xyzlmnop'\n        msg_from_gdcm = r\"'Dataset' object has no attribute 'filename'\"\n        msg_from_numpy = (r\"'Dataset' object has no attribute \"\n                          \"'TransferSyntaxUID'\")\n        msg_from_pillow = (r\"'Dataset' object has no attribute \"\n                           \"'PixelRepresentation'\")\n        msg = \"(\" + \"|\".join(\n            [msg_from_gdcm, msg_from_numpy, msg_from_pillow]) + \")\"\n        with pytest.raises(AttributeError, match=msg):\n            ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_attribute_error_in_property", "self", "dataset", "attributeerror", "in", "property", "raises", "actual", "error", "message", "this", "comes", "from", "bug", "fix", "for", "issue", "42", "first", "fake", "enough", "to", "try", "the", "pixel_array", "property", "ds", "dataset", "ds", "file_meta", "dataset", "ds", "pixeldata", "xyzlmnop", "msg_from_gdcm", "r", "dataset", "object", "has", "no", "attribute", "filename", "msg_from_numpy", "r", "dataset", "object", "has", "no", "attribute", "transfersyntaxuid", "msg_from_pillow", "r", "dataset", "object", "has", "no", "attribute", "pixelrepresentation", "msg", "join", "msg_from_gdcm", "msg_from_numpy", "msg_from_pillow", "with", "pytest", "raises", "attributeerror", "match", "msg", "ds", "pixel_array"], "doc_len": 77}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_for_stray_raw_data_element", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_for_stray_raw_data_element", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_for_stray_raw_data_element(self):\n        dataset = Dataset()\n        dataset.PatientName = 'MacDonald^George'\n        sub_ds = Dataset()\n        sub_ds.BeamNumber = '1'\n        dataset.BeamSequence = Sequence([sub_ds])\n        fp = DicomBytesIO()\n        pydicom.write_file(fp, dataset)\n\n        def _reset():\n            fp.seek(0)\n            ds1 = pydicom.dcmread(fp, force=True)\n            fp.seek(0)\n            ds2 = pydicom.dcmread(fp, force=True)\n            return ds1, ds2\n\n        ds1, ds2 = _reset()\n        assert ds1 == ds2\n\n        ds1, ds2 = _reset()\n        ds1.PatientName  # convert from raw\n        assert ds1 == ds2\n\n        ds1, ds2 = _reset()\n        ds2.PatientName\n        assert ds1 == ds2\n\n        ds1, ds2 = _reset()\n        ds2.PatientName\n        assert ds2 == ds1  # compare in other order\n\n        ds1, ds2 = _reset()\n        ds2.BeamSequence[0].BeamNumber\n        assert ds1 == ds2\n\n        # add a new element to one ds sequence item\n        ds1, ds2 = _reset()\n        ds2.BeamSequence[0].BeamName = '1'\n        assert ds1 != ds2\n\n        # change a value in a sequence item\n        ds1, ds2 = _reset()\n        ds2.BeamSequence[0].BeamNumber = '2'\n        assert ds2 != ds1\n\n        fp.close()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_for_stray_raw_data_element", "self", "dataset", "dataset", "dataset", "patientname", "macdonald", "george", "sub_ds", "dataset", "sub_ds", "beamnumber", "1", "dataset", "beamsequence", "sequence", "sub_ds", "fp", "dicombytesio", "pydicom", "write_file", "fp", "dataset", "def", "_reset", "fp", "seek", "0", "ds1", "pydicom", "dcmread", "fp", "force", "true", "fp", "seek", "0", "ds2", "pydicom", "dcmread", "fp", "force", "true", "return", "ds1", "ds2", "ds1", "ds2", "_reset", "assert", "ds1", "ds2", "ds1", "ds2", "_reset", "ds1", "patientname", "convert", "from", "raw", "assert", "ds1", "ds2", "ds1", "ds2", "_reset", "ds2", "patientname", "assert", "ds1", "ds2", "ds1", "ds2", "_reset", "ds2", "patientname", "assert", "ds2", "ds1", "compare", "in", "other", "order", "ds1", "ds2", "_reset", "ds2", "beamsequence", "0", "beamnumber", "assert", "ds1", "ds2", "add", "a", "new", "element", "to", "one", "ds", "sequence", "item", "ds1", "ds2", "_reset", "ds2", "beamsequence", "0", "beamname", "1", "assert", "ds1", "ds2", "change", "a", "value", "in", "a", "sequence", "item", "ds1", "ds2", "_reset", "ds2", "beamsequence", "0", "beamnumber", "2", "assert", "ds2", "ds1", "fp", "close"], "doc_len": 139}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_attribute_error_in_property_correct_debug", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_attribute_error_in_property_correct_debug", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_attribute_error_in_property_correct_debug(self):\n        \"\"\"Test AttributeError in property raises correctly.\"\"\"\n        class Foo(Dataset):\n            @property\n            def bar(self):\n                return self._barr()\n\n            def _bar(self):\n                return 'OK'\n\n        def test():\n            ds = Foo()\n            ds.bar\n\n        msg = r\"'Foo' object has no attribute '_barr'\"\n        with pytest.raises(AttributeError, match=msg):\n            test()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_attribute_error_in_property_correct_debug", "self", "test", "attributeerror", "in", "property", "raises", "correctly", "class", "foo", "dataset", "property", "def", "bar", "self", "return", "self", "_barr", "def", "_bar", "self", "return", "ok", "def", "test", "ds", "foo", "ds", "bar", "msg", "r", "foo", "object", "has", "no", "attribute", "_barr", "with", "pytest", "raises", "attributeerror", "match", "msg", "test"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_tag_exception_print", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_tag_exception_print", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_tag_exception_print(self):\n        \"\"\"Test that tag appears in exception messages.\"\"\"\n        ds = Dataset()\n        ds.PatientID = \"123456\"  # Valid value\n        ds.SmallestImagePixelValue = BadRepr()  # Invalid value\n\n        msg = r\"With tag \\(0028, 0106\\) got exception: bad repr\"\n        with pytest.raises(ValueError, match=msg):\n            str(ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_tag_exception_print", "self", "test", "that", "tag", "appears", "in", "exception", "messages", "ds", "dataset", "ds", "patientid", "123456", "valid", "value", "ds", "smallestimagepixelvalue", "badrepr", "invalid", "value", "msg", "r", "with", "tag", "0028", "0106", "got", "exception", "bad", "repr", "with", "pytest", "raises", "valueerror", "match", "msg", "str", "ds"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_tag_exception_walk", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_tag_exception_walk", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_tag_exception_walk(self):\n        \"\"\"Test that tag appears in exceptions raised during recursion.\"\"\"\n        ds = Dataset()\n        ds.PatientID = \"123456\"  # Valid value\n        ds.SmallestImagePixelValue = BadRepr()  # Invalid value\n\n        def callback(dataset, data_element):\n            return str(data_element)\n\n        def func(dataset=ds):\n            return dataset.walk(callback)\n\n        msg = r\"With tag \\(0028, 0106\\) got exception: bad repr\"\n        with pytest.raises(ValueError, match=msg):\n            func()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_tag_exception_walk", "self", "test", "that", "tag", "appears", "in", "exceptions", "raised", "during", "recursion", "ds", "dataset", "ds", "patientid", "123456", "valid", "value", "ds", "smallestimagepixelvalue", "badrepr", "invalid", "value", "def", "callback", "dataset", "data_element", "return", "str", "data_element", "def", "func", "dataset", "ds", "return", "dataset", "walk", "callback", "msg", "r", "with", "tag", "0028", "0106", "got", "exception", "bad", "repr", "with", "pytest", "raises", "valueerror", "match", "msg", "func"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_set_new_data_element_by_name", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_set_new_data_element_by_name", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_set_new_data_element_by_name(self):\n        \"\"\"Dataset: set new data_element by name.\"\"\"\n        ds = Dataset()\n        ds.TreatmentMachineName = \"unit #1\"\n        data_element = ds[0x300a, 0x00b2]\n        assert \"unit #1\" == data_element.value\n        assert \"SH\" == data_element.VR\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_set_new_data_element_by_name", "self", "dataset", "set", "new", "data_element", "by", "name", "ds", "dataset", "ds", "treatmentmachinename", "unit", "1", "data_element", "ds", "0x300a", "0x00b2", "assert", "unit", "1", "data_element", "value", "assert", "sh", "data_element", "vr"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_set_existing_data_element_by_name", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_set_existing_data_element_by_name", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_set_existing_data_element_by_name(self):\n        \"\"\"Dataset: set existing data_element by name.\"\"\"\n        self.ds.TreatmentMachineName = \"unit999\"  # change existing value\n        assert \"unit999\" == self.ds[0x300a, 0x00b2].value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_set_existing_data_element_by_name", "self", "dataset", "set", "existing", "data_element", "by", "name", "self", "ds", "treatmentmachinename", "unit999", "change", "existing", "value", "assert", "unit999", "self", "ds", "0x300a", "0x00b2", "value"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_set_non_dicom", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_set_non_dicom", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_set_non_dicom(self):\n        \"\"\"Dataset: can set class instance property (non-dicom).\"\"\"\n        ds = Dataset()\n        ds.SomeVariableName = 42\n        assert hasattr(ds, 'SomeVariableName')\n        assert 42 == ds.SomeVariableName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_set_non_dicom", "self", "dataset", "can", "set", "class", "instance", "property", "non", "dicom", "ds", "dataset", "ds", "somevariablename", "42", "assert", "hasattr", "ds", "somevariablename", "assert", "42", "ds", "somevariablename"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_membership", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_membership", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_membership(self):\n        \"\"\"Dataset: can test if item present by 'if <name> in dataset'.\"\"\"\n        assert 'TreatmentMachineName' in self.ds\n        assert 'Dummyname' not in self.ds\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_membership", "self", "dataset", "can", "test", "if", "item", "present", "by", "if", "name", "in", "dataset", "assert", "treatmentmachinename", "in", "self", "ds", "assert", "dummyname", "not", "in", "self", "ds"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_contains", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_contains", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_contains(self):\n        \"\"\"Dataset: can test if item present by 'if <tag> in dataset'.\"\"\"\n        self.ds.CommandGroupLength = 100  # (0000,0000)\n        assert (0x300a, 0xb2) in self.ds\n        assert [0x300a, 0xb2] in self.ds\n        assert 0x300a00b2 in self.ds\n        assert (0x10, 0x5f) not in self.ds\n        assert 'CommandGroupLength' in self.ds\n        # Use a negative tag to cause an exception\n        assert (-0x0010, 0x0010) not in self.ds\n        # Random non-existent property\n        assert 'random name' not in self.ds\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_contains", "self", "dataset", "can", "test", "if", "item", "present", "by", "if", "tag", "in", "dataset", "self", "ds", "commandgrouplength", "100", "0000", "0000", "assert", "0x300a", "0xb2", "in", "self", "ds", "assert", "0x300a", "0xb2", "in", "self", "ds", "assert", "0x300a00b2", "in", "self", "ds", "assert", "0x10", "0x5f", "not", "in", "self", "ds", "assert", "commandgrouplength", "in", "self", "ds", "use", "a", "negative", "tag", "to", "cause", "an", "exception", "assert", "0x0010", "0x0010", "not", "in", "self", "ds", "random", "non", "existent", "property", "assert", "random", "name", "not", "in", "self", "ds"], "doc_len": 80}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_clear", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_clear", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_clear(self):\n        assert 1 == len(self.ds)\n        self.ds.clear()\n        assert 0 == len(self.ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_clear", "self", "assert", "1", "len", "self", "ds", "self", "ds", "clear", "assert", "0", "len", "self", "ds"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pop", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pop", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pop(self):\n        with pytest.raises(KeyError):\n            self.ds.pop(0x300a00b244)\n        assert 'default' == self.ds.pop('dummy', 'default')\n        elem = self.ds.pop(0x300a00b2)\n        assert 'unit001' == elem.value\n        with pytest.raises(KeyError):\n            self.ds.pop(0x300a00b2)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pop", "self", "with", "pytest", "raises", "keyerror", "self", "ds", "pop", "0x300a00b244", "assert", "default", "self", "ds", "pop", "dummy", "default", "elem", "self", "ds", "pop", "0x300a00b2", "assert", "unit001", "elem", "value", "with", "pytest", "raises", "keyerror", "self", "ds", "pop", "0x300a00b2"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pop_using_tuple", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pop_using_tuple", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pop_using_tuple(self):\n        elem = self.ds.pop((0x300a, 0x00b2))\n        assert 'unit001' == elem.value\n        with pytest.raises(KeyError):\n            self.ds.pop((0x300a, 0x00b2))\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pop_using_tuple", "self", "elem", "self", "ds", "pop", "0x300a", "0x00b2", "assert", "unit001", "elem", "value", "with", "pytest", "raises", "keyerror", "self", "ds", "pop", "0x300a", "0x00b2"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pop_using_keyword", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pop_using_keyword", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pop_using_keyword(self):\n        with pytest.raises(KeyError):\n            self.ds.pop('InvalidName')\n        elem = self.ds.pop('TreatmentMachineName')\n        assert 'unit001' == elem.value\n        with pytest.raises(KeyError):\n            self.ds.pop('TreatmentMachineName')\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pop_using_keyword", "self", "with", "pytest", "raises", "keyerror", "self", "ds", "pop", "invalidname", "elem", "self", "ds", "pop", "treatmentmachinename", "assert", "unit001", "elem", "value", "with", "pytest", "raises", "keyerror", "self", "ds", "pop", "treatmentmachinename"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_popitem", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_popitem", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_popitem(self):\n        elem = self.ds.popitem()\n        assert 0x300a00b2 == elem[0]\n        assert 'unit001' == elem[1].value\n        with pytest.raises(KeyError):\n            self.ds.popitem()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_popitem", "self", "elem", "self", "ds", "popitem", "assert", "0x300a00b2", "elem", "0", "assert", "unit001", "elem", "1", "value", "with", "pytest", "raises", "keyerror", "self", "ds", "popitem"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_setdefault", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_setdefault", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_setdefault(self):\n        elem = self.ds.setdefault(0x300a00b2, 'foo')\n        assert 'unit001' == elem.value\n        elem = self.ds.setdefault(\n            0x00100010, DataElement(0x00100010, 'PN', \"Test\")\n        )\n        assert 'Test' == elem.value\n        assert 2 == len(self.ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_setdefault", "self", "elem", "self", "ds", "setdefault", "0x300a00b2", "foo", "assert", "unit001", "elem", "value", "elem", "self", "ds", "setdefault", "0x00100010", "dataelement", "0x00100010", "pn", "test", "assert", "test", "elem", "value", "assert", "2", "len", "self", "ds"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_setdefault_tuple", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_setdefault_tuple", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_setdefault_tuple(self):\n        elem = self.ds.setdefault((0x300a, 0x00b2), 'foo')\n        assert 'unit001' == elem.value\n        elem = self.ds.setdefault(\n            (0x0010, 0x0010), DataElement(0x00100010, 'PN', \"Test\")\n        )\n        assert 'Test' == elem.value\n        assert 2 == len(self.ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_setdefault_tuple", "self", "elem", "self", "ds", "setdefault", "0x300a", "0x00b2", "foo", "assert", "unit001", "elem", "value", "elem", "self", "ds", "setdefault", "0x0010", "0x0010", "dataelement", "0x00100010", "pn", "test", "assert", "test", "elem", "value", "assert", "2", "len", "self", "ds"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_setdefault_use_value", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_setdefault_use_value", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_setdefault_use_value(self):\n        elem = self.ds.setdefault((0x0010, 0x0010), \"Test\")\n        assert 'Test' == elem.value\n        assert 2 == len(self.ds)\n        with pytest.raises(KeyError, match=r'Tag \\(0011, 0010\\) not found '\n                                           r'in DICOM dictionary'):\n            self.ds.setdefault((0x0011, 0x0010), \"Test\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_setdefault_use_value", "self", "elem", "self", "ds", "setdefault", "0x0010", "0x0010", "test", "assert", "test", "elem", "value", "assert", "2", "len", "self", "ds", "with", "pytest", "raises", "keyerror", "match", "r", "tag", "0011", "0010", "not", "found", "r", "in", "dicom", "dictionary", "self", "ds", "setdefault", "0x0011", "0x0010", "test"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_setdefault_keyword", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_setdefault_keyword", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_setdefault_keyword(self):\n        elem = self.ds.setdefault('TreatmentMachineName', 'foo')\n        assert 'unit001' == elem.value\n        elem = self.ds.setdefault(\n            'PatientName', DataElement(0x00100010, 'PN', \"Test\")\n        )\n        assert 'Test' == elem.value\n        assert 2 == len(self.ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_setdefault_keyword", "self", "elem", "self", "ds", "setdefault", "treatmentmachinename", "foo", "assert", "unit001", "elem", "value", "elem", "self", "ds", "setdefault", "patientname", "dataelement", "0x00100010", "pn", "test", "assert", "test", "elem", "value", "assert", "2", "len", "self", "ds"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_exists1", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_exists1", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_exists1(self):\n        \"\"\"Dataset: dataset.get() returns an existing item by name.\"\"\"\n        assert 'unit001' == self.ds.get('TreatmentMachineName', None)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_exists1", "self", "dataset", "dataset", "get", "returns", "an", "existing", "item", "by", "name", "assert", "unit001", "self", "ds", "get", "treatmentmachinename", "none"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_exists2", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_exists2", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_exists2(self):\n        \"\"\"Dataset: dataset.get() returns an existing item by long tag.\"\"\"\n        assert 'unit001' == self.ds.get(0x300A00B2, None).value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_exists2", "self", "dataset", "dataset", "get", "returns", "an", "existing", "item", "by", "long", "tag", "assert", "unit001", "self", "ds", "get", "0x300a00b2", "none", "value"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_exists3", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_exists3", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_exists3(self):\n        \"\"\"Dataset: dataset.get() returns an existing item by tuple tag.\"\"\"\n        assert 'unit001' == self.ds.get((0x300A, 0x00B2), None).value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_exists3", "self", "dataset", "dataset", "get", "returns", "an", "existing", "item", "by", "tuple", "tag", "assert", "unit001", "self", "ds", "get", "0x300a", "0x00b2", "none", "value"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_exists4", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_exists4", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_exists4(self):\n        \"\"\"Dataset: dataset.get() returns an existing item by Tag.\"\"\"\n        assert 'unit001' == self.ds.get(Tag(0x300A00B2), None).value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_exists4", "self", "dataset", "dataset", "get", "returns", "an", "existing", "item", "by", "tag", "assert", "unit001", "self", "ds", "get", "tag", "0x300a00b2", "none", "value"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_default1", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_default1", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_default1(self):\n        \"\"\"Dataset: dataset.get() returns default for non-existing name.\"\"\"\n        assert \"not-there\" == self.ds.get('NotAMember', \"not-there\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_default1", "self", "dataset", "dataset", "get", "returns", "default", "for", "non", "existing", "name", "assert", "not", "there", "self", "ds", "get", "notamember", "not", "there"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_default2", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_default2", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_default2(self):\n        \"\"\"Dataset: dataset.get() returns default for non-existing tuple tag\"\"\"\n        assert \"not-there\" == self.ds.get((0x9999, 0x9999), \"not-there\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_default2", "self", "dataset", "dataset", "get", "returns", "default", "for", "non", "existing", "tuple", "tag", "assert", "not", "there", "self", "ds", "get", "0x9999", "0x9999", "not", "there"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_default3", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_default3", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_default3(self):\n        \"\"\"Dataset: dataset.get() returns default for non-existing long tag.\"\"\"\n        assert \"not-there\" == self.ds.get(0x99999999, \"not-there\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_default3", "self", "dataset", "dataset", "get", "returns", "default", "for", "non", "existing", "long", "tag", "assert", "not", "there", "self", "ds", "get", "0x99999999", "not", "there"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_default4", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_default4", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_default4(self):\n        \"\"\"Dataset: dataset.get() returns default for non-existing Tag.\"\"\"\n        assert \"not-there\" == self.ds.get(Tag(0x99999999), \"not-there\")\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_default4", "self", "dataset", "dataset", "get", "returns", "default", "for", "non", "existing", "tag", "assert", "not", "there", "self", "ds", "get", "tag", "0x99999999", "not", "there"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_raises", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_raises", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_raises(self):\n        \"\"\"Test Dataset.get() raises exception when invalid Tag\"\"\"\n        with pytest.raises(TypeError,\n                           match=r'Dataset.get key must be a string or tag'):\n            self.ds.get(-0x0010, 0x0010)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_raises", "self", "test", "dataset", "get", "raises", "exception", "when", "invalid", "tag", "with", "pytest", "raises", "typeerror", "match", "r", "dataset", "get", "key", "must", "be", "a", "string", "or", "tag", "self", "ds", "get", "0x0010", "0x0010"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_from_raw", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_from_raw", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_from_raw(self):\n        \"\"\"Dataset: get(tag) returns same object as ds[tag] for raw element.\"\"\"\n        # This came from issue 88, where get(tag#) returned a RawDataElement,\n        #     while get(name) converted to a true DataElement\n        test_tag = 0x100010\n        test_elem = RawDataElement(Tag(test_tag), 'PN', 4, b'test',\n                                   0, True, True)\n        ds = Dataset({Tag(test_tag): test_elem})\n        assert ds[test_tag] == ds.get(test_tag)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_from_raw", "self", "dataset", "get", "tag", "returns", "same", "object", "as", "ds", "tag", "for", "raw", "element", "this", "came", "from", "issue", "88", "where", "get", "tag", "returned", "a", "rawdataelement", "while", "get", "name", "converted", "to", "a", "true", "dataelement", "test_tag", "0x100010", "test_elem", "rawdataelement", "tag", "test_tag", "pn", "4", "b", "test", "0", "true", "true", "ds", "dataset", "tag", "test_tag", "test_elem", "assert", "ds", "test_tag", "ds", "get", "test_tag"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test__setitem__", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test__setitem__", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test__setitem__(self):\n        \"\"\"Dataset: if set an item, it must be a DataElement instance.\"\"\"\n        ds = Dataset()\n        with pytest.raises(TypeError):\n            ds[0x300a, 0xb2] = \"unit1\"\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test__setitem__", "self", "dataset", "if", "set", "an", "item", "it", "must", "be", "a", "dataelement", "instance", "ds", "dataset", "with", "pytest", "raises", "typeerror", "ds", "0x300a", "0xb2", "unit1"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_matching_tags", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_matching_tags", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_matching_tags(self):\n        \"\"\"Dataset: key and data_element.tag mismatch raises ValueError.\"\"\"\n        ds = Dataset()\n        data_element = DataElement((0x300a, 0x00b2), \"SH\", \"unit001\")\n        with pytest.raises(ValueError):\n            ds[0x10, 0x10] = data_element\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_matching_tags", "self", "dataset", "key", "and", "data_element", "tag", "mismatch", "raises", "valueerror", "ds", "dataset", "data_element", "dataelement", "0x300a", "0x00b2", "sh", "unit001", "with", "pytest", "raises", "valueerror", "ds", "0x10", "0x10", "data_element"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_named_member_updated", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_named_member_updated", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_named_member_updated(self):\n        \"\"\"Dataset: if set data_element by tag, name also reflects change.\"\"\"\n        self.ds[0x300a, 0xb2].value = \"moon_unit\"\n        assert 'moon_unit' == self.ds.TreatmentMachineName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_named_member_updated", "self", "dataset", "if", "set", "data_element", "by", "tag", "name", "also", "reflects", "change", "self", "ds", "0x300a", "0xb2", "value", "moon_unit", "assert", "moon_unit", "self", "ds", "treatmentmachinename"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_update", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_update", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_update(self):\n        \"\"\"Dataset: update() method works with tag or name.\"\"\"\n        pat_data_element = DataElement((0x10, 0x12), 'PN', 'Johnny')\n        self.ds.update({'PatientName': 'John', (0x10, 0x12): pat_data_element})\n        assert 'John' == self.ds[0x10, 0x10].value\n        assert 'Johnny' == self.ds[0x10, 0x12].value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_update", "self", "dataset", "update", "method", "works", "with", "tag", "or", "name", "pat_data_element", "dataelement", "0x10", "0x12", "pn", "johnny", "self", "ds", "update", "patientname", "john", "0x10", "0x12", "pat_data_element", "assert", "john", "self", "ds", "0x10", "0x10", "value", "assert", "johnny", "self", "ds", "0x10", "0x12", "value"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_dir_subclass", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_dir_subclass", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_dir_subclass(self):\n        \"\"\"Dataset.__dir__ returns class specific dir\"\"\"\n        class DSP(Dataset):\n            def test_func(self):\n                pass\n\n        ds = DSP()\n        assert hasattr(ds, 'test_func')\n        assert callable(ds.test_func)\n        assert 'test_func' in dir(ds)\n\n        ds = Dataset()\n        assert hasattr(ds, 'group_dataset')\n        assert callable(ds.group_dataset)\n        assert 'group_dataset' in dir(ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_dir_subclass", "self", "dataset", "__dir__", "returns", "class", "specific", "dir", "class", "dsp", "dataset", "def", "test_func", "self", "pass", "ds", "dsp", "assert", "hasattr", "ds", "test_func", "assert", "callable", "ds", "test_func", "assert", "test_func", "in", "dir", "ds", "ds", "dataset", "assert", "hasattr", "ds", "group_dataset", "assert", "callable", "ds", "group_dataset", "assert", "group_dataset", "in", "dir", "ds"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_dir", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_dir", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_dir(self):\n        \"\"\"Dataset.dir() returns sorted list of named data_elements.\"\"\"\n        ds = self.ds\n        ds.PatientName = \"name\"\n        ds.PatientID = \"id\"\n        ds.NonDicomVariable = \"junk\"\n        ds.add_new((0x18, 0x1151), \"IS\", 150)  # X-ray Tube Current\n        ds.add_new((0x1111, 0x123), \"DS\", \"42.0\")  # private - no name in dir()\n        expected = ['PatientID',\n                    'PatientName',\n                    'TreatmentMachineName',\n                    'XRayTubeCurrent']\n        assert expected == ds.dir()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_dir", "self", "dataset", "dir", "returns", "sorted", "list", "of", "named", "data_elements", "ds", "self", "ds", "ds", "patientname", "name", "ds", "patientid", "id", "ds", "nondicomvariable", "junk", "ds", "add_new", "0x18", "0x1151", "is", "150", "x", "ray", "tube", "current", "ds", "add_new", "0x1111", "0x123", "ds", "42", "0", "private", "no", "name", "in", "dir", "expected", "patientid", "patientname", "treatmentmachinename", "xraytubecurrent", "assert", "expected", "ds", "dir"], "doc_len": 59}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_dir_filter", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_dir_filter", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_dir_filter(self):\n        \"\"\"Test Dataset.dir(*filters) works OK.\"\"\"\n        ds = self.ds\n        ds.PatientName = \"name\"\n        ds.PatientID = \"id\"\n        ds.NonDicomVariable = \"junk\"\n        ds.add_new((0x18, 0x1151), \"IS\", 150)  # X-ray Tube Current\n        ds.add_new((0x1111, 0x123), \"DS\", \"42.0\")  # private - no name in dir()\n        assert 'PatientID' in ds\n        assert 'XRayTubeCurrent' in ds\n        assert 'TreatmentMachineName' in ds\n        assert 'PatientName' in ds\n        assert 'PatientBirthDate' not in ds\n        assert ['PatientID', 'PatientName'] == ds.dir('Patient')\n        assert ['PatientName', 'TreatmentMachineName'] == ds.dir('Name')\n        expected = ['PatientID', 'PatientName', 'TreatmentMachineName']\n        assert expected == ds.dir('Name', 'Patient')\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_dir_filter", "self", "test", "dataset", "dir", "filters", "works", "ok", "ds", "self", "ds", "ds", "patientname", "name", "ds", "patientid", "id", "ds", "nondicomvariable", "junk", "ds", "add_new", "0x18", "0x1151", "is", "150", "x", "ray", "tube", "current", "ds", "add_new", "0x1111", "0x123", "ds", "42", "0", "private", "no", "name", "in", "dir", "assert", "patientid", "in", "ds", "assert", "xraytubecurrent", "in", "ds", "assert", "treatmentmachinename", "in", "ds", "assert", "patientname", "in", "ds", "assert", "patientbirthdate", "not", "in", "ds", "assert", "patientid", "patientname", "ds", "dir", "patient", "assert", "patientname", "treatmentmachinename", "ds", "dir", "name", "expected", "patientid", "patientname", "treatmentmachinename", "assert", "expected", "ds", "dir", "name", "patient"], "doc_len": 91}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_dicom_attr", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_dicom_attr", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_dicom_attr(self):\n        \"\"\"Dataset: delete DICOM attribute by name.\"\"\"\n        del self.ds.TreatmentMachineName\n        with pytest.raises(AttributeError):\n            self.ds.TreatmentMachineName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_dicom_attr", "self", "dataset", "delete", "dicom", "attribute", "by", "name", "del", "self", "ds", "treatmentmachinename", "with", "pytest", "raises", "attributeerror", "self", "ds", "treatmentmachinename"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_dicom_command_group_length", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_dicom_command_group_length", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_dicom_command_group_length(self):\n        \"\"\"Dataset: delete CommandGroupLength doesn't raise AttributeError.\"\"\"\n        self.ds.CommandGroupLength = 100  # (0x0000, 0x0000)\n        del self.ds.CommandGroupLength\n        with pytest.raises(AttributeError):\n            self.ds.CommandGroupLength\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_dicom_command_group_length", "self", "dataset", "delete", "commandgrouplength", "doesn", "t", "raise", "attributeerror", "self", "ds", "commandgrouplength", "100", "0x0000", "0x0000", "del", "self", "ds", "commandgrouplength", "with", "pytest", "raises", "attributeerror", "self", "ds", "commandgrouplength"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_other_attr", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_other_attr", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_other_attr(self):\n        \"\"\"Dataset: delete non-DICOM attribute by name.\"\"\"\n        self.ds.meaningoflife = 42\n        assert hasattr(self.ds, 'meaningoflife')\n        del self.ds.meaningoflife\n        assert not hasattr(self.ds, 'meaningoflife')\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_other_attr", "self", "dataset", "delete", "non", "dicom", "attribute", "by", "name", "self", "ds", "meaningoflife", "42", "assert", "hasattr", "self", "ds", "meaningoflife", "del", "self", "ds", "meaningoflife", "assert", "not", "hasattr", "self", "ds", "meaningoflife"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_dicom_attr_we_dont_have", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_dicom_attr_we_dont_have", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_dicom_attr_we_dont_have(self):\n        \"\"\"Dataset: try delete of missing DICOM attribute.\"\"\"\n        with pytest.raises(AttributeError):\n            del self.ds.PatientName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_dicom_attr_we_dont_have", "self", "dataset", "try", "delete", "of", "missing", "dicom", "attribute", "with", "pytest", "raises", "attributeerror", "del", "self", "ds", "patientname"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_item_long", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_item_long", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_item_long(self):\n        \"\"\"Dataset: delete item by tag number (long).\"\"\"\n        del self.ds[0x300a00b2]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_item_long", "self", "dataset", "delete", "item", "by", "tag", "number", "long", "del", "self", "ds", "0x300a00b2"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_item_tuple", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_item_tuple", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_item_tuple(self):\n        \"\"\"Dataset: delete item by tag number (tuple).\"\"\"\n        del self.ds[0x300a, 0x00b2]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_item_tuple", "self", "dataset", "delete", "item", "by", "tag", "number", "tuple", "del", "self", "ds", "0x300a", "0x00b2"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_non_existing_item", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_non_existing_item", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_non_existing_item(self):\n        \"\"\"Dataset: raise KeyError for non-existing item delete.\"\"\"\n        with pytest.raises(KeyError):\n            del self.ds[0x10, 0x10]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_non_existing_item", "self", "dataset", "raise", "keyerror", "for", "non", "existing", "item", "delete", "with", "pytest", "raises", "keyerror", "del", "self", "ds", "0x10", "0x10"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_no_sequence", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_no_sequence", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_no_sequence(self):\n        \"\"\"Dataset: equality returns correct value with simple dataset\"\"\"\n        # Test empty dataset\n        assert Dataset() == Dataset()\n\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        d.PatientName = 'Test'\n        assert d == d\n\n        e = Dataset()\n        e.PatientName = 'Test'\n        e.SOPInstanceUID = '1.2.3.4'\n        assert d == e\n\n        e.SOPInstanceUID = '1.2.3.5'\n        assert not d == e\n\n        # Check VR\n        del e.SOPInstanceUID\n        e.add(DataElement(0x00080018, 'PN', '1.2.3.4'))\n        assert not d == e\n\n        # Check Tag\n        del e.SOPInstanceUID\n        e.StudyInstanceUID = '1.2.3.4'\n        assert not d == e\n\n        # Check missing Element in self\n        e.SOPInstanceUID = '1.2.3.4'\n        assert not d == e\n\n        # Check missing Element in other\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        d.StudyInstanceUID = '1.2.3.4.5'\n\n        e = Dataset()\n        e.SOPInstanceUID = '1.2.3.4'\n        assert not d == e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_no_sequence", "self", "dataset", "equality", "returns", "correct", "value", "with", "simple", "dataset", "test", "empty", "dataset", "assert", "dataset", "dataset", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "d", "patientname", "test", "assert", "d", "d", "e", "dataset", "e", "patientname", "test", "e", "sopinstanceuid", "1", "2", "3", "4", "assert", "d", "e", "e", "sopinstanceuid", "1", "2", "3", "5", "assert", "not", "d", "e", "check", "vr", "del", "e", "sopinstanceuid", "e", "add", "dataelement", "0x00080018", "pn", "1", "2", "3", "4", "assert", "not", "d", "e", "check", "tag", "del", "e", "sopinstanceuid", "e", "studyinstanceuid", "1", "2", "3", "4", "assert", "not", "d", "e", "check", "missing", "element", "in", "self", "e", "sopinstanceuid", "1", "2", "3", "4", "assert", "not", "d", "e", "check", "missing", "element", "in", "other", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "d", "studyinstanceuid", "1", "2", "3", "4", "5", "e", "dataset", "e", "sopinstanceuid", "1", "2", "3", "4", "assert", "not", "d", "e"], "doc_len": 140}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_private", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_private", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_private(self):\n        \"\"\"Dataset: equality returns correct value\"\"\"\n        \"\"\"when dataset has private elements\"\"\"\n        d = Dataset()\n        d_elem = DataElement(0x01110001, 'PN', 'Private')\n        assert d == d\n        d.add(d_elem)\n\n        e = Dataset()\n        e_elem = DataElement(0x01110001, 'PN', 'Private')\n        e.add(e_elem)\n        assert e == d\n\n        e[0x01110001].value = 'Public'\n        assert not e == d\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_private", "self", "dataset", "equality", "returns", "correct", "value", "when", "dataset", "has", "private", "elements", "d", "dataset", "d_elem", "dataelement", "0x01110001", "pn", "private", "assert", "d", "d", "d", "add", "d_elem", "e", "dataset", "e_elem", "dataelement", "0x01110001", "pn", "private", "e", "add", "e_elem", "assert", "e", "d", "e", "0x01110001", "value", "public", "assert", "not", "e", "d"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_sequence", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_sequence", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_sequence(self):\n        \"\"\"Equality returns correct value with sequences\"\"\"\n        # Test even sequences\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        d.BeamSequence = []\n        beam_seq = Dataset()\n        beam_seq.PatientID = '1234'\n        beam_seq.PatientName = 'ANON'\n        d.BeamSequence.append(beam_seq)\n        assert d == d\n\n        e = Dataset()\n        e.SOPInstanceUID = '1.2.3.4'\n        e.BeamSequence = []\n        beam_seq = Dataset()\n        beam_seq.PatientName = 'ANON'\n        beam_seq.PatientID = '1234'\n        e.BeamSequence.append(beam_seq)\n        assert d == e\n\n        e.BeamSequence[0].PatientName = 'ANONY'\n        assert not d == e\n\n        # Test uneven sequences\n        e.BeamSequence[0].PatientName = 'ANON'\n        assert d == e\n\n        e.BeamSequence.append(beam_seq)\n        assert not d == e\n\n        d.BeamSequence.append(beam_seq)\n        assert d == e\n        d.BeamSequence.append(beam_seq)\n        assert not d == e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_sequence", "self", "equality", "returns", "correct", "value", "with", "sequences", "test", "even", "sequences", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "d", "beamsequence", "beam_seq", "dataset", "beam_seq", "patientid", "1234", "beam_seq", "patientname", "anon", "d", "beamsequence", "append", "beam_seq", "assert", "d", "d", "e", "dataset", "e", "sopinstanceuid", "1", "2", "3", "4", "e", "beamsequence", "beam_seq", "dataset", "beam_seq", "patientname", "anon", "beam_seq", "patientid", "1234", "e", "beamsequence", "append", "beam_seq", "assert", "d", "e", "e", "beamsequence", "0", "patientname", "anony", "assert", "not", "d", "e", "test", "uneven", "sequences", "e", "beamsequence", "0", "patientname", "anon", "assert", "d", "e", "e", "beamsequence", "append", "beam_seq", "assert", "not", "d", "e", "d", "beamsequence", "append", "beam_seq", "assert", "d", "e", "d", "beamsequence", "append", "beam_seq", "assert", "not", "d", "e"], "doc_len": 110}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_not_dataset", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_not_dataset", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_not_dataset(self):\n        \"\"\"Dataset: equality returns correct value when not the same class\"\"\"\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        # Make sure Dataset.__eq__() is being used, not dict__eq__()\n        assert not d == {'SOPInstanceUID': '1.2.3.4'}\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_not_dataset", "self", "dataset", "equality", "returns", "correct", "value", "when", "not", "the", "same", "class", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "make", "sure", "dataset", "__eq__", "is", "being", "used", "not", "dict__eq__", "assert", "not", "d", "sopinstanceuid", "1", "2", "3", "4"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_unknown", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_unknown", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_unknown(self):\n        \"\"\"Dataset: equality returns correct value with extra members \"\"\"\n        # Non-element class members are ignored in equality testing\n        d = Dataset()\n        d.SOPEustaceUID = '1.2.3.4'\n        assert d == d\n\n        e = Dataset()\n        e.SOPEustaceUID = '1.2.3.5'\n        assert d == e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_unknown", "self", "dataset", "equality", "returns", "correct", "value", "with", "extra", "members", "non", "element", "class", "members", "are", "ignored", "in", "equality", "testing", "d", "dataset", "d", "sopeustaceuid", "1", "2", "3", "4", "assert", "d", "d", "e", "dataset", "e", "sopeustaceuid", "1", "2", "3", "5", "assert", "d", "e"], "doc_len": 47}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_inheritance", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_inheritance", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_inheritance(self):\n        \"\"\"Dataset: equality returns correct value for subclass \"\"\"\n\n        class DatasetPlus(Dataset):\n            pass\n\n        d = Dataset()\n        d.PatientName = 'ANON'\n        e = DatasetPlus()\n        e.PatientName = 'ANON'\n        assert d == e\n        assert e == d\n        assert e == e\n\n        e.PatientName = 'ANONY'\n        assert not d == e\n        assert not e == d\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_inheritance", "self", "dataset", "equality", "returns", "correct", "value", "for", "subclass", "class", "datasetplus", "dataset", "pass", "d", "dataset", "d", "patientname", "anon", "e", "datasetplus", "e", "patientname", "anon", "assert", "d", "e", "assert", "e", "d", "assert", "e", "e", "e", "patientname", "anony", "assert", "not", "d", "e", "assert", "not", "e", "d"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_equality_elements", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_equality_elements", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_equality_elements(self):\n        \"\"\"Test that Dataset equality only checks DataElements.\"\"\"\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        d.PatientName = 'Test'\n        d.foo = 'foo'\n        assert d == d\n\n        e = Dataset()\n        e.PatientName = 'Test'\n        e.SOPInstanceUID = '1.2.3.4'\n        assert d == e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_equality_elements", "self", "test", "that", "dataset", "equality", "only", "checks", "dataelements", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "d", "patientname", "test", "d", "foo", "foo", "assert", "d", "d", "e", "dataset", "e", "patientname", "test", "e", "sopinstanceuid", "1", "2", "3", "4", "assert", "d", "e"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_inequality", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_inequality", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_inequality(self):\n        \"\"\"Test inequality operator\"\"\"\n        d = Dataset()\n        d.SOPInstanceUID = '1.2.3.4'\n        assert not d != d\n\n        e = Dataset()\n        e.SOPInstanceUID = '1.2.3.5'\n        assert d != e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_inequality", "self", "test", "inequality", "operator", "d", "dataset", "d", "sopinstanceuid", "1", "2", "3", "4", "assert", "not", "d", "d", "e", "dataset", "e", "sopinstanceuid", "1", "2", "3", "5", "assert", "d", "e"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_hash", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_hash(self):\n        \"\"\"DataElement: hash returns TypeError\"\"\"\n        ds = Dataset()\n        ds.PatientName = 'ANON'\n        with pytest.raises(TypeError):\n            hash(ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_hash", "self", "dataelement", "hash", "returns", "typeerror", "ds", "dataset", "ds", "patientname", "anon", "with", "pytest", "raises", "typeerror", "hash", "ds"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_property", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_property", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_property(self):\n        \"\"\"Test properties work OK.\"\"\"\n        class DSPlus(Dataset):\n            @property\n            def test(self):\n                return self._test\n\n            @test.setter\n            def test(self, value):\n                self._test = value\n\n        dsp = DSPlus()\n        dsp.test = 'ABCD'\n        assert 'ABCD' == dsp.test\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_property", "self", "test", "properties", "work", "ok", "class", "dsplus", "dataset", "property", "def", "test", "self", "return", "self", "_test", "test", "setter", "def", "test", "self", "value", "self", "_test", "value", "dsp", "dsplus", "dsp", "test", "abcd", "assert", "abcd", "dsp", "test"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_add_repeater_elem_by_keyword", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_add_repeater_elem_by_keyword", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_add_repeater_elem_by_keyword(self):\n        \"\"\"Repeater using keyword to add repeater group elements raises.\"\"\"\n        ds = Dataset()\n        with pytest.raises(ValueError):\n            ds.OverlayData = b'\\x00'\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_add_repeater_elem_by_keyword", "self", "repeater", "using", "keyword", "to", "add", "repeater", "group", "elements", "raises", "ds", "dataset", "with", "pytest", "raises", "valueerror", "ds", "overlaydata", "b", "x00"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_setitem_slice_raises", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_setitem_slice_raises", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_setitem_slice_raises(self):\n        \"\"\"Test Dataset.__setitem__ raises if slicing used.\"\"\"\n        ds = Dataset()\n        with pytest.raises(NotImplementedError):\n            ds.__setitem__(slice(None), Dataset())\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_setitem_slice_raises", "self", "test", "dataset", "__setitem__", "raises", "if", "slicing", "used", "ds", "dataset", "with", "pytest", "raises", "notimplementederror", "ds", "__setitem__", "slice", "none", "dataset"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_getitem_slice_raises", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_getitem_slice_raises", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_getitem_slice_raises(self):\n        \"\"\"Test Dataset.__getitem__ raises if slice Tags invalid.\"\"\"\n        ds = Dataset()\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(None, -1))\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(-1, -1))\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(-1))\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_getitem_slice_raises", "self", "test", "dataset", "__getitem__", "raises", "if", "slice", "tags", "invalid", "ds", "dataset", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "none", "1", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "1", "1", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "1"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_empty_slice", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_empty_slice", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_empty_slice(self):\n        \"\"\"Test Dataset slicing with empty Dataset.\"\"\"\n        ds = Dataset()\n        assert ds[:] == Dataset()\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(None, -1))\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(-1, -1))\n        with pytest.raises(ValueError):\n            ds.__getitem__(slice(-1))\n        with pytest.raises(NotImplementedError):\n            ds.__setitem__(slice(None), Dataset())\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_empty_slice", "self", "test", "dataset", "slicing", "with", "empty", "dataset", "ds", "dataset", "assert", "ds", "dataset", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "none", "1", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "1", "1", "with", "pytest", "raises", "valueerror", "ds", "__getitem__", "slice", "1", "with", "pytest", "raises", "notimplementederror", "ds", "__setitem__", "slice", "none", "dataset"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_getitem_slice", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_getitem_slice", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_getitem_slice(self):\n        \"\"\"Test Dataset.__getitem__ using slices.\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.CommandLengthToEnd = 111  # 0000,0001\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.add_new(0x00090002, 'PN', 'CITIZEN^2')\n        ds.add_new(0x00090003, 'PN', 'CITIZEN^3')\n        ds.add_new(0x00090004, 'PN', 'CITIZEN^4')\n        ds.add_new(0x00090005, 'PN', 'CITIZEN^5')\n        ds.add_new(0x00090006, 'PN', 'CITIZEN^6')\n        ds.add_new(0x00090007, 'PN', 'CITIZEN^7')\n        ds.add_new(0x00090008, 'PN', 'CITIZEN^8')\n        ds.add_new(0x00090009, 'PN', 'CITIZEN^9')\n        ds.add_new(0x00090010, 'PN', 'CITIZEN^10')\n        ds.PatientName = 'CITIZEN^Jan'  # 0010,0010\n        ds.PatientID = '12345'  # 0010,0010\n        ds.ExaminedBodyThickness = 1.223  # 0010,9431\n        ds.BeamSequence = [Dataset()]  # 300A,00B0\n        ds.BeamSequence[0].PatientName = 'ANON'\n\n        # Slice all items - should return original dataset\n        assert ds[:] == ds\n\n        # Slice starting from and including (0008,0001)\n        test_ds = ds[0x00080001:]\n        assert 'CommandGroupLength' not in test_ds\n        assert 'CommandLengthToEnd' not in test_ds\n        assert 'Overlays' not in test_ds\n        assert 'LengthToEnd' in test_ds\n        assert 'BeamSequence' in test_ds\n\n        # Slice ending at and not including (0009,0002)\n        test_ds = ds[:0x00090002]\n        assert 'CommandGroupLength' in test_ds\n        assert 'CommandLengthToEnd' in test_ds\n        assert 'Overlays' in test_ds\n        assert 'LengthToEnd' in test_ds\n        assert 0x00090001 in test_ds\n        assert 0x00090002 not in test_ds\n        assert 'BeamSequence' not in test_ds\n\n        # Slice with a step - every second tag\n        # Should return zeroth tag, then second, fourth, etc...\n        test_ds = ds[::2]\n        assert 'CommandGroupLength' in test_ds\n        assert 'CommandLengthToEnd' not in test_ds\n        assert 0x00090001 in test_ds\n        assert 0x00090002 not in test_ds\n\n        # Slice starting at and including (0008,0018) and ending at and not\n        #   including (0009,0008)\n        test_ds = ds[0x00080018:0x00090008]\n        assert 'SOPInstanceUID' in test_ds\n        assert 0x00090007 in test_ds\n        assert 0x00090008 not in test_ds\n\n        # Slice starting at and including (0008,0018) and ending at and not\n        #   including (0009,0008), every third element\n        test_ds = ds[0x00080018:0x00090008:3]\n        assert 'SOPInstanceUID' in test_ds\n        assert 0x00090001 not in test_ds\n        assert 0x00090002 in test_ds\n        assert 0x00090003 not in test_ds\n        assert 0x00090004 not in test_ds\n        assert 0x00090005 in test_ds\n        assert 0x00090006 not in test_ds\n        assert 0x00090008 not in test_ds\n\n        # Slice starting and ending (and not including) (0008,0018)\n        assert ds[(0x0008, 0x0018):(0x0008, 0x0018)] == Dataset()\n\n        # Test slicing using other acceptable Tag initialisations\n        assert 'SOPInstanceUID' in ds[(0x00080018):(0x00080019)]\n        assert 'SOPInstanceUID' in ds[(0x0008, 0x0018):(0x0008, 0x0019)]\n        assert 'SOPInstanceUID' in ds['0x00080018':'0x00080019']\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_getitem_slice", "self", "test", "dataset", "__getitem__", "using", "slices", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "commandlengthtoend", "111", "0000", "0001", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "add_new", "0x00090002", "pn", "citizen", "2", "ds", "add_new", "0x00090003", "pn", "citizen", "3", "ds", "add_new", "0x00090004", "pn", "citizen", "4", "ds", "add_new", "0x00090005", "pn", "citizen", "5", "ds", "add_new", "0x00090006", "pn", "citizen", "6", "ds", "add_new", "0x00090007", "pn", "citizen", "7", "ds", "add_new", "0x00090008", "pn", "citizen", "8", "ds", "add_new", "0x00090009", "pn", "citizen", "9", "ds", "add_new", "0x00090010", "pn", "citizen", "10", "ds", "patientname", "citizen", "jan", "0010", "0010", "ds", "patientid", "12345", "0010", "0010", "ds", "examinedbodythickness", "1", "223", "0010", "9431", "ds", "beamsequence", "dataset", "300a", "00b0", "ds", "beamsequence", "0", "patientname", "anon", "slice", "all", "items", "should", "return", "original", "dataset", "assert", "ds", "ds", "slice", "starting", "from", "and", "including", "0008", "0001", "test_ds", "ds", "0x00080001", "assert", "commandgrouplength", "not", "in", "test_ds", "assert", "commandlengthtoend", "not", "in", "test_ds", "assert", "overlays", "not", "in", "test_ds", "assert", "lengthtoend", "in", "test_ds", "assert", "beamsequence", "in", "test_ds", "slice", "ending", "at", "and", "not", "including", "0009", "0002", "test_ds", "ds", "0x00090002", "assert", "commandgrouplength", "in", "test_ds", "assert", "commandlengthtoend", "in", "test_ds", "assert", "overlays", "in", "test_ds", "assert", "lengthtoend", "in", "test_ds", "assert", "0x00090001", "in", "test_ds", "assert", "0x00090002", "not", "in", "test_ds", "assert", "beamsequence", "not", "in", "test_ds", "slice", "with", "a", "step", "every", "second", "tag", "should", "return", "zeroth", "tag", "then", "second", "fourth", "etc", "test_ds", "ds", "2", "assert", "commandgrouplength", "in", "test_ds", "assert", "commandlengthtoend", "not", "in", "test_ds", "assert", "0x00090001", "in", "test_ds", "assert", "0x00090002", "not", "in", "test_ds", "slice", "starting", "at", "and", "including", "0008", "0018", "and", "ending", "at", "and", "not", "including", "0009", "0008", "test_ds", "ds", "0x00080018", "0x00090008", "assert", "sopinstanceuid", "in", "test_ds", "assert", "0x00090007", "in", "test_ds", "assert", "0x00090008", "not", "in", "test_ds", "slice", "starting", "at", "and", "including", "0008", "0018", "and", "ending", "at", "and", "not", "including", "0009", "0008", "every", "third", "element", "test_ds", "ds", "0x00080018", "0x00090008", "3", "assert", "sopinstanceuid", "in", "test_ds", "assert", "0x00090001", "not", "in", "test_ds", "assert", "0x00090002", "in", "test_ds", "assert", "0x00090003", "not", "in", "test_ds", "assert", "0x00090004", "not", "in", "test_ds", "assert", "0x00090005", "in", "test_ds", "assert", "0x00090006", "not", "in", "test_ds", "assert", "0x00090008", "not", "in", "test_ds", "slice", "starting", "and", "ending", "and", "not", "including", "0008", "0018", "assert", "ds", "0x0008", "0x0018", "0x0008", "0x0018", "dataset", "test", "slicing", "using", "other", "acceptable", "tag", "initialisations", "assert", "sopinstanceuid", "in", "ds", "0x00080018", "0x00080019", "assert", "sopinstanceuid", "in", "ds", "0x0008", "0x0018", "0x0008", "0x0019", "assert", "sopinstanceuid", "in", "ds", "0x00080018", "0x00080019"], "doc_len": 390}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_getitem_slice_ffff", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_getitem_slice_ffff", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_getitem_slice_ffff(self):\n        \"\"\"Test slicing with (FFFF,FFFF)\"\"\"\n        # Issue #92\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.CommandLengthToEnd = 111  # 0000,0001\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n        ds.add_new(0xFFFF0001, 'PN', 'CITIZEN^1')\n        ds.add_new(0xFFFF0002, 'PN', 'CITIZEN^2')\n        ds.add_new(0xFFFF0003, 'PN', 'CITIZEN^3')\n        ds.add_new(0xFFFFFFFE, 'PN', 'CITIZEN^4')\n        ds.add_new(0xFFFFFFFF, 'PN', 'CITIZEN^5')\n\n        assert 'CITIZEN^5' == ds[:][0xFFFFFFFF].value\n        assert 0xFFFFFFFF not in ds[0x1000:0xFFFFFFFF]\n        assert 0xFFFFFFFF not in ds[(0x1000):(0xFFFF, 0xFFFF)]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_getitem_slice_ffff", "self", "test", "slicing", "with", "ffff", "ffff", "issue", "92", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "commandlengthtoend", "111", "0000", "0001", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "ds", "add_new", "0xffff0001", "pn", "citizen", "1", "ds", "add_new", "0xffff0002", "pn", "citizen", "2", "ds", "add_new", "0xffff0003", "pn", "citizen", "3", "ds", "add_new", "0xfffffffe", "pn", "citizen", "4", "ds", "add_new", "0xffffffff", "pn", "citizen", "5", "assert", "citizen", "5", "ds", "0xffffffff", "value", "assert", "0xffffffff", "not", "in", "ds", "0x1000", "0xffffffff", "assert", "0xffffffff", "not", "in", "ds", "0x1000", "0xffff", "0xffff"], "doc_len": 101}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delitem_slice", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delitem_slice", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delitem_slice(self):\n        \"\"\"Test Dataset.__delitem__ using slices.\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.CommandLengthToEnd = 111  # 0000,0001\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.add_new(0x00090002, 'PN', 'CITIZEN^2')\n        ds.add_new(0x00090003, 'PN', 'CITIZEN^3')\n        ds.add_new(0x00090004, 'PN', 'CITIZEN^4')\n        ds.add_new(0x00090005, 'PN', 'CITIZEN^5')\n        ds.add_new(0x00090006, 'PN', 'CITIZEN^6')\n        ds.add_new(0x00090007, 'PN', 'CITIZEN^7')\n        ds.add_new(0x00090008, 'PN', 'CITIZEN^8')\n        ds.add_new(0x00090009, 'PN', 'CITIZEN^9')\n        ds.add_new(0x00090010, 'PN', 'CITIZEN^10')\n        ds.PatientName = 'CITIZEN^Jan'  # 0010,0010\n        ds.PatientID = '12345'  # 0010,0010\n        ds.ExaminedBodyThickness = 1.223  # 0010,9431\n        ds.BeamSequence = [Dataset()]  # 300A,00B0\n        ds.BeamSequence[0].PatientName = 'ANON'\n\n        # Delete the 0x0009 group\n        del ds[0x00090000:0x00100000]\n        assert 'SkipFrameRangeFlag' in ds\n        assert 0x00090001 not in ds\n        assert 0x00090010 not in ds\n        assert 'PatientName' in ds\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delitem_slice", "self", "test", "dataset", "__delitem__", "using", "slices", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "commandlengthtoend", "111", "0000", "0001", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "add_new", "0x00090002", "pn", "citizen", "2", "ds", "add_new", "0x00090003", "pn", "citizen", "3", "ds", "add_new", "0x00090004", "pn", "citizen", "4", "ds", "add_new", "0x00090005", "pn", "citizen", "5", "ds", "add_new", "0x00090006", "pn", "citizen", "6", "ds", "add_new", "0x00090007", "pn", "citizen", "7", "ds", "add_new", "0x00090008", "pn", "citizen", "8", "ds", "add_new", "0x00090009", "pn", "citizen", "9", "ds", "add_new", "0x00090010", "pn", "citizen", "10", "ds", "patientname", "citizen", "jan", "0010", "0010", "ds", "patientid", "12345", "0010", "0010", "ds", "examinedbodythickness", "1", "223", "0010", "9431", "ds", "beamsequence", "dataset", "300a", "00b0", "ds", "beamsequence", "0", "patientname", "anon", "delete", "the", "0x0009", "group", "del", "ds", "0x00090000", "0x00100000", "assert", "skipframerangeflag", "in", "ds", "assert", "0x00090001", "not", "in", "ds", "assert", "0x00090010", "not", "in", "ds", "assert", "patientname", "in", "ds"], "doc_len": 161}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_iteritems", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_iteritems", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_iteritems(self):\n        ds = Dataset()\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n\n        keys = []\n        for key in ds.iterkeys():\n            keys.append(key)\n        assert 4 == len(keys)\n        assert 0x000051B0 in keys\n        assert 0x00089460 in keys\n\n        values = []\n        for value in ds.itervalues():\n            values.append(value)\n\n        assert 4 == len(values)\n        assert DataElement(0x00080018, 'UI', '1.2.3.4') in values\n        assert DataElement(0x00089460, 'CS', 'TEST') in values\n\n        items = {}\n        for key, value in ds.iteritems():\n            items[key] = value\n\n        assert 4 == len(items)\n        assert 0x000051B0 in items\n        assert 0x00080018 in items\n        assert '1.2.3.4' == items[0x00080018].value\n        assert 12 == items[0x00080001].value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_iteritems", "self", "ds", "dataset", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "keys", "for", "key", "in", "ds", "iterkeys", "keys", "append", "key", "assert", "4", "len", "keys", "assert", "0x000051b0", "in", "keys", "assert", "0x00089460", "in", "keys", "values", "for", "value", "in", "ds", "itervalues", "values", "append", "value", "assert", "4", "len", "values", "assert", "dataelement", "0x00080018", "ui", "1", "2", "3", "4", "in", "values", "assert", "dataelement", "0x00089460", "cs", "test", "in", "values", "items", "for", "key", "value", "in", "ds", "iteritems", "items", "key", "value", "assert", "4", "len", "items", "assert", "0x000051b0", "in", "items", "assert", "0x00080018", "in", "items", "assert", "1", "2", "3", "4", "items", "0x00080018", "value", "assert", "12", "items", "0x00080001", "value"], "doc_len": 119}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_group_dataset", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_group_dataset", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_group_dataset(self):\n        \"\"\"Test Dataset.group_dataset\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.CommandLengthToEnd = 111  # 0000,0001\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n\n        # Test getting group 0x0000\n        group0000 = ds.group_dataset(0x0000)\n        assert 'CommandGroupLength' in group0000\n        assert 'CommandLengthToEnd' in group0000\n        assert 'Overlays' in group0000\n        assert 'LengthToEnd' not in group0000\n        assert 'SOPInstanceUID' not in group0000\n        assert 'SkipFrameRangeFlag' not in group0000\n\n        # Test getting group 0x0008\n        group0000 = ds.group_dataset(0x0008)\n        assert 'CommandGroupLength' not in group0000\n        assert 'CommandLengthToEnd' not in group0000\n        assert 'Overlays' not in group0000\n        assert 'LengthToEnd' in group0000\n        assert 'SOPInstanceUID' in group0000\n        assert 'SkipFrameRangeFlag' in group0000\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_group_dataset", "self", "test", "dataset", "group_dataset", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "commandlengthtoend", "111", "0000", "0001", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "test", "getting", "group", "0x0000", "group0000", "ds", "group_dataset", "0x0000", "assert", "commandgrouplength", "in", "group0000", "assert", "commandlengthtoend", "in", "group0000", "assert", "overlays", "in", "group0000", "assert", "lengthtoend", "not", "in", "group0000", "assert", "sopinstanceuid", "not", "in", "group0000", "assert", "skipframerangeflag", "not", "in", "group0000", "test", "getting", "group", "0x0008", "group0000", "ds", "group_dataset", "0x0008", "assert", "commandgrouplength", "not", "in", "group0000", "assert", "commandlengthtoend", "not", "in", "group0000", "assert", "overlays", "not", "in", "group0000", "assert", "lengthtoend", "in", "group0000", "assert", "sopinstanceuid", "in", "group0000", "assert", "skipframerangeflag", "in", "group0000"], "doc_len": 116}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_item", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_item", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_item(self):\n        \"\"\"Test Dataset.get_item\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n\n        # Test non-deferred read\n        assert ds[0x00000000] == ds.get_item(0x00000000)\n        assert 120 == ds.get_item(0x00000000).value\n        assert ds[0x00080018] == ds.get_item(0x00080018)\n        assert '1.2.3.4' == ds.get_item(0x00080018).value\n\n        # Test deferred read\n        test_file = get_testdata_files('MR_small.dcm')[0]\n        ds = dcmread(test_file, force=True, defer_size='0.8 kB')\n        ds_ref = dcmread(test_file, force=True)\n        # get_item will follow the deferred read branch\n        assert ds_ref.PixelData == ds.get_item((0x7fe00010)).value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_item", "self", "test", "dataset", "get_item", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "test", "non", "deferred", "read", "assert", "ds", "0x00000000", "ds", "get_item", "0x00000000", "assert", "120", "ds", "get_item", "0x00000000", "value", "assert", "ds", "0x00080018", "ds", "get_item", "0x00080018", "assert", "1", "2", "3", "4", "ds", "get_item", "0x00080018", "value", "test", "deferred", "read", "test_file", "get_testdata_files", "mr_small", "dcm", "0", "ds", "dcmread", "test_file", "force", "true", "defer_size", "0", "8", "kb", "ds_ref", "dcmread", "test_file", "force", "true", "get_item", "will", "follow", "the", "deferred", "read", "branch", "assert", "ds_ref", "pixeldata", "ds", "get_item", "0x7fe00010", "value"], "doc_len": 93}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_item_slice", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_item_slice", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_item_slice(self):\n        \"\"\"Test Dataset.get_item with slice argument\"\"\"\n        # adapted from test_getitem_slice\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.CommandLengthToEnd = 111  # 0000,0001\n        ds.Overlays = 12  # 0000,51B0\n        ds.LengthToEnd = 12  # 0008,0001\n        ds.SOPInstanceUID = '1.2.3.4'  # 0008,0018\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.add_new(0x00090002, 'PN', 'CITIZEN^2')\n        ds.add_new(0x00090003, 'PN', 'CITIZEN^3')\n        elem = RawDataElement(0x00090004, 'PN', 9, b'CITIZEN^4', 0, True, True)\n        ds.__setitem__(0x00090004, elem)\n        elem = RawDataElement(0x00090005, 'PN', 9, b'CITIZEN^5', 0, True, True)\n        ds.__setitem__(0x00090005, elem)\n        elem = RawDataElement(0x00090006, 'PN', 9, b'CITIZEN^6', 0, True, True)\n        ds.__setitem__(0x00090006, elem)\n        ds.PatientName = 'CITIZEN^Jan'  # 0010,0010\n        elem = RawDataElement(0x00100020, 'LO', 5, b'12345', 0, True, True)\n        ds.__setitem__(0x00100020, elem)  # Patient ID\n        ds.ExaminedBodyThickness = 1.223  # 0010,9431\n        ds.BeamSequence = [Dataset()]  # 300A,00B0\n        ds.BeamSequence[0].PatientName = 'ANON'\n\n        # Slice starting from and including (0008,0001)\n        test_ds = ds.get_item(slice(0x00080001, None))\n        assert 'CommandGroupLength' not in test_ds\n        assert 'CommandLengthToEnd' not in test_ds\n        assert 'Overlays' not in test_ds\n        assert 'LengthToEnd' in test_ds\n        assert 'BeamSequence' in test_ds\n\n        # Slice ending at and not including (0009,0002)\n        test_ds = ds.get_item(slice(None, 0x00090002))\n        assert 'CommandGroupLength' in test_ds\n        assert 'CommandLengthToEnd' in test_ds\n        assert 'Overlays' in test_ds\n        assert 'LengthToEnd' in test_ds\n        assert 0x00090001 in test_ds\n        assert 0x00090002 not in test_ds\n        assert 'BeamSequence' not in test_ds\n\n        # Slice with a step - every second tag\n        # Should return zeroth tag, then second, fourth, etc...\n        test_ds = ds.get_item(slice(None, None, 2))\n        assert 'CommandGroupLength' in test_ds\n        assert 'CommandLengthToEnd' not in test_ds\n        assert 0x00090001 in test_ds\n        assert 0x00090002 not in test_ds\n\n        # Slice starting at and including (0008,0018) and ending at and not\n        #   including (0009,0008)\n        test_ds = ds.get_item(slice(0x00080018, 0x00090006))\n        assert 'SOPInstanceUID' in test_ds\n        assert 0x00090005 in test_ds\n        assert 0x00090006 not in test_ds\n\n        # Slice starting at and including (0008,0018) and ending at and not\n        #   including (0009,0006), every third element\n        test_ds = ds.get_item(slice(0x00080018, 0x00090008, 3))\n        assert 'SOPInstanceUID' in test_ds\n        assert 0x00090001 not in test_ds\n        assert 0x00090002 in test_ds\n        assert not test_ds.get_item(0x00090002).is_raw\n        assert 0x00090003 not in test_ds\n        assert 0x00090004 not in test_ds\n        assert 0x00090005 in test_ds\n        assert test_ds.get_item(0x00090005).is_raw\n        assert 0x00090006 not in test_ds\n\n        # Slice starting and ending (and not including) (0008,0018)\n        assert Dataset() == ds.get_item(slice((0x0008, 0x0018),\n                                              (0x0008, 0x0018)))\n\n        # Test slicing using other acceptable Tag initialisations\n        assert 'SOPInstanceUID' in ds.get_item(slice(0x00080018, 0x00080019))\n        assert 'SOPInstanceUID' in ds.get_item(slice((0x0008, 0x0018),\n                                                     (0x0008, 0x0019)))\n        assert 'SOPInstanceUID' in ds.get_item(slice('0x00080018',\n                                                     '0x00080019'))\n\n        # Slice all items - should return original dataset\n        assert ds == ds.get_item(slice(None, None))\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_item_slice", "self", "test", "dataset", "get_item", "with", "slice", "argument", "adapted", "from", "test_getitem_slice", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "commandlengthtoend", "111", "0000", "0001", "ds", "overlays", "12", "0000", "51b0", "ds", "lengthtoend", "12", "0008", "0001", "ds", "sopinstanceuid", "1", "2", "3", "4", "0008", "0018", "ds", "skipframerangeflag", "test", "0008", "9460", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "add_new", "0x00090002", "pn", "citizen", "2", "ds", "add_new", "0x00090003", "pn", "citizen", "3", "elem", "rawdataelement", "0x00090004", "pn", "9", "b", "citizen", "4", "0", "true", "true", "ds", "__setitem__", "0x00090004", "elem", "elem", "rawdataelement", "0x00090005", "pn", "9", "b", "citizen", "5", "0", "true", "true", "ds", "__setitem__", "0x00090005", "elem", "elem", "rawdataelement", "0x00090006", "pn", "9", "b", "citizen", "6", "0", "true", "true", "ds", "__setitem__", "0x00090006", "elem", "ds", "patientname", "citizen", "jan", "0010", "0010", "elem", "rawdataelement", "0x00100020", "lo", "5", "b", "12345", "0", "true", "true", "ds", "__setitem__", "0x00100020", "elem", "patient", "id", "ds", "examinedbodythickness", "1", "223", "0010", "9431", "ds", "beamsequence", "dataset", "300a", "00b0", "ds", "beamsequence", "0", "patientname", "anon", "slice", "starting", "from", "and", "including", "0008", "0001", "test_ds", "ds", "get_item", "slice", "0x00080001", "none", "assert", "commandgrouplength", "not", "in", "test_ds", "assert", "commandlengthtoend", "not", "in", "test_ds", "assert", "overlays", "not", "in", "test_ds", "assert", "lengthtoend", "in", "test_ds", "assert", "beamsequence", "in", "test_ds", "slice", "ending", "at", "and", "not", "including", "0009", "0002", "test_ds", "ds", "get_item", "slice", "none", "0x00090002", "assert", "commandgrouplength", "in", "test_ds", "assert", "commandlengthtoend", "in", "test_ds", "assert", "overlays", "in", "test_ds", "assert", "lengthtoend", "in", "test_ds", "assert", "0x00090001", "in", "test_ds", "assert", "0x00090002", "not", "in", "test_ds", "assert", "beamsequence", "not", "in", "test_ds", "slice", "with", "a", "step", "every", "second", "tag", "should", "return", "zeroth", "tag", "then", "second", "fourth", "etc", "test_ds", "ds", "get_item", "slice", "none", "none", "2", "assert", "commandgrouplength", "in", "test_ds", "assert", "commandlengthtoend", "not", "in", "test_ds", "assert", "0x00090001", "in", "test_ds", "assert", "0x00090002", "not", "in", "test_ds", "slice", "starting", "at", "and", "including", "0008", "0018", "and", "ending", "at", "and", "not", "including", "0009", "0008", "test_ds", "ds", "get_item", "slice", "0x00080018", "0x00090006", "assert", "sopinstanceuid", "in", "test_ds", "assert", "0x00090005", "in", "test_ds", "assert", "0x00090006", "not", "in", "test_ds", "slice", "starting", "at", "and", "including", "0008", "0018", "and", "ending", "at", "and", "not", "including", "0009", "0006", "every", "third", "element", "test_ds", "ds", "get_item", "slice", "0x00080018", "0x00090008", "3", "assert", "sopinstanceuid", "in", "test_ds", "assert", "0x00090001", "not", "in", "test_ds", "assert", "0x00090002", "in", "test_ds", "assert", "not", "test_ds", "get_item", "0x00090002", "is_raw", "assert", "0x00090003", "not", "in", "test_ds", "assert", "0x00090004", "not", "in", "test_ds", "assert", "0x00090005", "in", "test_ds", "assert", "test_ds", "get_item", "0x00090005", "is_raw", "assert", "0x00090006", "not", "in", "test_ds", "slice", "starting", "and", "ending", "and", "not", "including", "0008", "0018", "assert", "dataset", "ds", "get_item", "slice", "0x0008", "0x0018", "0x0008", "0x0018", "test", "slicing", "using", "other", "acceptable", "tag", "initialisations", "assert", "sopinstanceuid", "in", "ds", "get_item", "slice", "0x00080018", "0x00080019", "assert", "sopinstanceuid", "in", "ds", "get_item", "slice", "0x0008", "0x0018", "0x0008", "0x0019", "assert", "sopinstanceuid", "in", "ds", "get_item", "slice", "0x00080018", "0x00080019", "slice", "all", "items", "should", "return", "original", "dataset", "assert", "ds", "ds", "get_item", "slice", "none", "none"], "doc_len": 440}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_get_private_item", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_get_private_item", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_get_private_item(self):\n        ds = Dataset()\n        ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n        ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n        ds.add_new(0x00091001, 'SH', 'Version1')\n        ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n        ds.add_new(0x00091101, 'SH', 'Version2')\n        ds.add_new(0x00091102, 'US', 2)\n\n        with pytest.raises(ValueError, match='Tag must be private'):\n            ds.get_private_item(0x0008, 0x05, 'Creator 1.0')\n        with pytest.raises(ValueError,\n                           match='Private creator must have a value'):\n            ds.get_private_item(0x0009, 0x10, '')\n        with pytest.raises(KeyError,\n                           match=\"Private creator 'Creator 3.0' not found\"):\n            ds.get_private_item(0x0009, 0x10, 'Creator 3.0')\n        item = ds.get_private_item(0x0009, 0x01, 'Creator 1.0')\n        assert 'Version1' == item.value\n        item = ds.get_private_item(0x0009, 0x01, 'Creator 2.0')\n        assert 'Version2' == item.value\n\n        with pytest.raises(KeyError):\n            ds.get_private_item(0x0009, 0x02, 'Creator 1.0')\n        item = ds.get_private_item(0x0009, 0x02, 'Creator 2.0')\n        assert 2 == item.value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_get_private_item", "self", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00091001", "sh", "version1", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "ds", "add_new", "0x00091101", "sh", "version2", "ds", "add_new", "0x00091102", "us", "2", "with", "pytest", "raises", "valueerror", "match", "tag", "must", "be", "private", "ds", "get_private_item", "0x0008", "0x05", "creator", "1", "0", "with", "pytest", "raises", "valueerror", "match", "private", "creator", "must", "have", "a", "value", "ds", "get_private_item", "0x0009", "0x10", "with", "pytest", "raises", "keyerror", "match", "private", "creator", "creator", "3", "0", "not", "found", "ds", "get_private_item", "0x0009", "0x10", "creator", "3", "0", "item", "ds", "get_private_item", "0x0009", "0x01", "creator", "1", "0", "assert", "version1", "item", "value", "item", "ds", "get_private_item", "0x0009", "0x01", "creator", "2", "0", "assert", "version2", "item", "value", "with", "pytest", "raises", "keyerror", "ds", "get_private_item", "0x0009", "0x02", "creator", "1", "0", "item", "ds", "get_private_item", "0x0009", "0x02", "creator", "2", "0", "assert", "2", "item", "value"], "doc_len": 142}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_private_block", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_private_block", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_private_block(self):\n        ds = Dataset()\n        ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n        ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n        ds.add_new(0x00091001, 'SH', 'Version1')\n        ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n        ds.add_new(0x00091101, 'SH', 'Version2')\n        ds.add_new(0x00091102, 'US', 2)\n\n        # Dataset.private_block\n        with pytest.raises(ValueError, match='Tag must be private'):\n            ds.private_block(0x0008, 'Creator 1.0')\n        with pytest.raises(ValueError,\n                           match='Private creator must have a value'):\n            ds.private_block(0x0009, '')\n        with pytest.raises(KeyError,\n                           match=\"Private creator 'Creator 3.0' not found\"):\n            ds.private_block(0x0009, 'Creator 3.0')\n\n        block = ds.private_block(0x0009, 'Creator 1.0')\n\n        # test for containment\n        assert 1 in block\n        assert 2 not in block\n\n        # get item from private block\n        item = block[0x01]\n        assert 'Version1' == item.value\n        block = ds.private_block(0x0009, 'Creator 2.0')\n        with pytest.raises(ValueError,\n                           match='Element offset must be less than 256'):\n            block[0x0101]\n\n        item = block[0x01]\n        assert 'Version2' == item.value\n\n        # Dataset.get_private_item\n        with pytest.raises(KeyError):\n            ds.get_private_item(0x0009, 0x02, 'Creator 1.0')\n\n        item = ds.get_private_item(0x0009, 0x02, 'Creator 2.0')\n        assert 2 == item.value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_private_block", "self", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00091001", "sh", "version1", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "ds", "add_new", "0x00091101", "sh", "version2", "ds", "add_new", "0x00091102", "us", "2", "dataset", "private_block", "with", "pytest", "raises", "valueerror", "match", "tag", "must", "be", "private", "ds", "private_block", "0x0008", "creator", "1", "0", "with", "pytest", "raises", "valueerror", "match", "private", "creator", "must", "have", "a", "value", "ds", "private_block", "0x0009", "with", "pytest", "raises", "keyerror", "match", "private", "creator", "creator", "3", "0", "not", "found", "ds", "private_block", "0x0009", "creator", "3", "0", "block", "ds", "private_block", "0x0009", "creator", "1", "0", "test", "for", "containment", "assert", "1", "in", "block", "assert", "2", "not", "in", "block", "get", "item", "from", "private", "block", "item", "block", "0x01", "assert", "version1", "item", "value", "block", "ds", "private_block", "0x0009", "creator", "2", "0", "with", "pytest", "raises", "valueerror", "match", "element", "offset", "must", "be", "less", "than", "256", "block", "0x0101", "item", "block", "0x01", "assert", "version2", "item", "value", "dataset", "get_private_item", "with", "pytest", "raises", "keyerror", "ds", "get_private_item", "0x0009", "0x02", "creator", "1", "0", "item", "ds", "get_private_item", "0x0009", "0x02", "creator", "2", "0", "assert", "2", "item", "value"], "doc_len": 178}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_add_new_private_tag", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_add_new_private_tag", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_add_new_private_tag(self):\n        ds = Dataset()\n        ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n        ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n        ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n\n        with pytest.raises(ValueError, match='Tag must be private'):\n            ds.private_block(0x0008, 'Creator 1.0')\n        block = ds.private_block(0x0009, 'Creator 2.0', create=True)\n        block.add_new(0x01, 'SH', 'Version2')\n        assert 'Version2' == ds[0x00091101].value\n        block = ds.private_block(0x0009, 'Creator 3.0', create=True)\n        block.add_new(0x01, 'SH', 'Version3')\n        assert 'Creator 3.0' == ds[0x00090012].value\n        assert 'Version3' == ds[0x00091201].value\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_add_new_private_tag", "self", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "with", "pytest", "raises", "valueerror", "match", "tag", "must", "be", "private", "ds", "private_block", "0x0008", "creator", "1", "0", "block", "ds", "private_block", "0x0009", "creator", "2", "0", "create", "true", "block", "add_new", "0x01", "sh", "version2", "assert", "version2", "ds", "0x00091101", "value", "block", "ds", "private_block", "0x0009", "creator", "3", "0", "create", "true", "block", "add_new", "0x01", "sh", "version3", "assert", "creator", "3", "0", "ds", "0x00090012", "value", "assert", "version3", "ds", "0x00091201", "value"], "doc_len": 90}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_delete_private_tag", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_delete_private_tag", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_delete_private_tag(self):\n        ds = Dataset()\n        ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n        ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n        ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n        ds.add_new(0x00091101, 'SH', 'Version2')\n\n        block = ds.private_block(0x0009, 'Creator 2.0')\n        with pytest.raises(ValueError,\n                           match='Element offset must be less than 256'):\n            del block[0x1001]\n        assert 1 in block\n        del block[0x01]\n        assert 1 not in block\n        with pytest.raises(KeyError):\n            del block[0x01]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_delete_private_tag", "self", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "ds", "add_new", "0x00091101", "sh", "version2", "block", "ds", "private_block", "0x0009", "creator", "2", "0", "with", "pytest", "raises", "valueerror", "match", "element", "offset", "must", "be", "less", "than", "256", "del", "block", "0x1001", "assert", "1", "in", "block", "del", "block", "0x01", "assert", "1", "not", "in", "block", "with", "pytest", "raises", "keyerror", "del", "block", "0x01"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_private_creators", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_private_creators", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_private_creators(self):\n        ds = Dataset()\n        ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n        ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n        ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n\n        with pytest.raises(ValueError, match='Group must be an odd number'):\n            ds.private_creators(0x0008)\n        assert ['Creator 1.0', 'Creator 2.0'] == ds.private_creators(0x0009)\n        assert not ds.private_creators(0x0011)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_private_creators", "self", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "with", "pytest", "raises", "valueerror", "match", "group", "must", "be", "an", "odd", "number", "ds", "private_creators", "0x0008", "assert", "creator", "1", "0", "creator", "2", "0", "ds", "private_creators", "0x0009", "assert", "not", "ds", "private_creators", "0x0011"], "doc_len": 59}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_is_original_encoding", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_is_original_encoding", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_is_original_encoding(self):\n        \"\"\"Test Dataset.write_like_original\"\"\"\n        ds = Dataset()\n        assert not ds.is_original_encoding\n\n        # simulate reading\n        ds.SpecificCharacterSet = 'ISO_IR 100'\n        ds.set_original_encoding(True, True, ['latin_1'])\n        assert not ds.is_original_encoding\n\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        assert ds.is_original_encoding\n        # changed character set\n        ds.SpecificCharacterSet = 'ISO_IR 192'\n        assert not ds.is_original_encoding\n        # back to original character set\n        ds.SpecificCharacterSet = 'ISO_IR 100'\n        assert ds.is_original_encoding\n        ds.is_little_endian = False\n        assert not ds.is_original_encoding\n        ds.is_little_endian = True\n        ds.is_implicit_VR = False\n        assert not ds.is_original_encoding\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_is_original_encoding", "self", "test", "dataset", "write_like_original", "ds", "dataset", "assert", "not", "ds", "is_original_encoding", "simulate", "reading", "ds", "specificcharacterset", "iso_ir", "100", "ds", "set_original_encoding", "true", "true", "latin_1", "assert", "not", "ds", "is_original_encoding", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "assert", "ds", "is_original_encoding", "changed", "character", "set", "ds", "specificcharacterset", "iso_ir", "192", "assert", "not", "ds", "is_original_encoding", "back", "to", "original", "character", "set", "ds", "specificcharacterset", "iso_ir", "100", "assert", "ds", "is_original_encoding", "ds", "is_little_endian", "false", "assert", "not", "ds", "is_original_encoding", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "false", "assert", "not", "ds", "is_original_encoding"], "doc_len": 81}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_remove_private_tags", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_remove_private_tags", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_remove_private_tags(self):\n        \"\"\"Test Dataset.remove_private_tags\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120  # 0000,0000\n        ds.SkipFrameRangeFlag = 'TEST'  # 0008,9460\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.add_new(0x00090010, 'PN', 'CITIZEN^10')\n        ds.PatientName = 'CITIZEN^Jan'  # 0010,0010\n\n        ds.remove_private_tags()\n        assert Dataset() == ds[0x00090000:0x00100000]\n        assert 'CommandGroupLength' in ds\n        assert 'SkipFrameRangeFlag' in ds\n        assert 'PatientName' in ds\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_remove_private_tags", "self", "test", "dataset", "remove_private_tags", "ds", "dataset", "ds", "commandgrouplength", "120", "0000", "0000", "ds", "skipframerangeflag", "test", "0008", "9460", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "add_new", "0x00090010", "pn", "citizen", "10", "ds", "patientname", "citizen", "jan", "0010", "0010", "ds", "remove_private_tags", "assert", "dataset", "ds", "0x00090000", "0x00100000", "assert", "commandgrouplength", "in", "ds", "assert", "skipframerangeflag", "in", "ds", "assert", "patientname", "in", "ds"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_data_element", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_data_element", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_data_element(self):\n        \"\"\"Test Dataset.data_element.\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120\n        ds.SkipFrameRangeFlag = 'TEST'\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.BeamSequence = [Dataset()]\n        ds.BeamSequence[0].PatientName = 'ANON'\n        assert ds[0x00000000] == ds.data_element('CommandGroupLength')\n        assert ds[0x300A00B0] == ds.data_element('BeamSequence')\n        assert ds.data_element('not an element keyword') is None\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_data_element", "self", "test", "dataset", "data_element", "ds", "dataset", "ds", "commandgrouplength", "120", "ds", "skipframerangeflag", "test", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "beamsequence", "dataset", "ds", "beamsequence", "0", "patientname", "anon", "assert", "ds", "0x00000000", "ds", "data_element", "commandgrouplength", "assert", "ds", "0x300a00b0", "ds", "data_element", "beamsequence", "assert", "ds", "data_element", "not", "an", "element", "keyword", "is", "none"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_iterall", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_iterall", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_iterall(self):\n        \"\"\"Test Dataset.iterall\"\"\"\n        ds = Dataset()\n        ds.CommandGroupLength = 120\n        ds.SkipFrameRangeFlag = 'TEST'\n        ds.add_new(0x00090001, 'PN', 'CITIZEN^1')\n        ds.BeamSequence = [Dataset()]\n        ds.BeamSequence[0].PatientName = 'ANON'\n        elem_gen = ds.iterall()\n        assert ds.data_element('CommandGroupLength') == next(elem_gen)\n        assert ds.data_element('SkipFrameRangeFlag') == next(elem_gen)\n        assert ds[0x00090001] == next(elem_gen)\n        assert ds.data_element('BeamSequence') == next(elem_gen)\n        assert ds.BeamSequence[0].data_element('PatientName') == next(elem_gen)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_iterall", "self", "test", "dataset", "iterall", "ds", "dataset", "ds", "commandgrouplength", "120", "ds", "skipframerangeflag", "test", "ds", "add_new", "0x00090001", "pn", "citizen", "1", "ds", "beamsequence", "dataset", "ds", "beamsequence", "0", "patientname", "anon", "elem_gen", "ds", "iterall", "assert", "ds", "data_element", "commandgrouplength", "next", "elem_gen", "assert", "ds", "data_element", "skipframerangeflag", "next", "elem_gen", "assert", "ds", "0x00090001", "next", "elem_gen", "assert", "ds", "data_element", "beamsequence", "next", "elem_gen", "assert", "ds", "beamsequence", "0", "data_element", "patientname", "next", "elem_gen"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_save_as", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_save_as", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_save_as(self):\n        \"\"\"Test Dataset.save_as\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.PatientName = 'CITIZEN'\n        # Raise AttributeError if is_implicit_VR or is_little_endian missing\n        with pytest.raises(AttributeError):\n            ds.save_as(fp, write_like_original=False)\n\n        ds.is_implicit_VR = True\n        with pytest.raises(AttributeError):\n            ds.save_as(fp, write_like_original=False)\n\n        ds.is_little_endian = True\n        del ds.is_implicit_VR\n        with pytest.raises(AttributeError):\n            ds.save_as(fp, write_like_original=False)\n\n        ds.is_implicit_VR = True\n        ds.file_meta = Dataset()\n        ds.file_meta.MediaStorageSOPClassUID = '1.1'\n        ds.file_meta.MediaStorageSOPInstanceUID = '1.2'\n        ds.file_meta.TransferSyntaxUID = '1.3'\n        ds.file_meta.ImplementationClassUID = '1.4'\n        ds.save_as(fp, write_like_original=False)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_save_as", "self", "test", "dataset", "save_as", "fp", "dicombytesio", "ds", "dataset", "ds", "patientname", "citizen", "raise", "attributeerror", "if", "is_implicit_vr", "or", "is_little_endian", "missing", "with", "pytest", "raises", "attributeerror", "ds", "save_as", "fp", "write_like_original", "false", "ds", "is_implicit_vr", "true", "with", "pytest", "raises", "attributeerror", "ds", "save_as", "fp", "write_like_original", "false", "ds", "is_little_endian", "true", "del", "ds", "is_implicit_vr", "with", "pytest", "raises", "attributeerror", "ds", "save_as", "fp", "write_like_original", "false", "ds", "is_implicit_vr", "true", "ds", "file_meta", "dataset", "ds", "file_meta", "mediastoragesopclassuid", "1", "1", "ds", "file_meta", "mediastoragesopinstanceuid", "1", "2", "ds", "file_meta", "transfersyntaxuid", "1", "3", "ds", "file_meta", "implementationclassuid", "1", "4", "ds", "save_as", "fp", "write_like_original", "false"], "doc_len": 92}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_with", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_with", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_with(self):\n        \"\"\"Test Dataset.__enter__ and __exit__.\"\"\"\n        test_file = get_testdata_files('CT_small.dcm')[0]\n        with dcmread(test_file) as ds:\n            assert 'CompressedSamples^CT1' == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_with", "self", "test", "dataset", "__enter__", "and", "__exit__", "test_file", "get_testdata_files", "ct_small", "dcm", "0", "with", "dcmread", "test_file", "as", "ds", "assert", "compressedsamples", "ct1", "ds", "patientname"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_exit_exception", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_exit_exception", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_exit_exception(self):\n        \"\"\"Test Dataset.__exit__ when an exception is raised.\"\"\"\n        class DSException(Dataset):\n            @property\n            def test(self):\n                raise ValueError(\"Random ex message!\")\n\n        with pytest.raises(ValueError, match=\"Random ex message!\"):\n            getattr(DSException(), 'test')\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_exit_exception", "self", "test", "dataset", "__exit__", "when", "an", "exception", "is", "raised", "class", "dsexception", "dataset", "property", "def", "test", "self", "raise", "valueerror", "random", "ex", "message", "with", "pytest", "raises", "valueerror", "match", "random", "ex", "message", "getattr", "dsexception", "test"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pixel_array_already_have", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pixel_array_already_have", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pixel_array_already_have(self):\n        \"\"\"Test Dataset._get_pixel_array when we already have the array\"\"\"\n        # Test that _pixel_array is returned unchanged unless required\n        fpath = get_testdata_files(\"CT_small.dcm\")[0]\n        ds = dcmread(fpath)\n        ds._pixel_id = id(ds.PixelData)\n        ds._pixel_array = 'Test Value'\n        ds.convert_pixel_data()\n        assert id(ds.PixelData) == ds._pixel_id\n        assert 'Test Value' == ds._pixel_array\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pixel_array_already_have", "self", "test", "dataset", "_get_pixel_array", "when", "we", "already", "have", "the", "array", "test", "that", "_pixel_array", "is", "returned", "unchanged", "unless", "required", "fpath", "get_testdata_files", "ct_small", "dcm", "0", "ds", "dcmread", "fpath", "ds", "_pixel_id", "id", "ds", "pixeldata", "ds", "_pixel_array", "test", "value", "ds", "convert_pixel_data", "assert", "id", "ds", "pixeldata", "ds", "_pixel_id", "assert", "test", "value", "ds", "_pixel_array"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pixel_array_id_changed", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pixel_array_id_changed", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pixel_array_id_changed(self):\n        \"\"\"Test that we try to get new pixel data if the id has changed.\"\"\"\n        fpath = get_testdata_files(\"CT_small.dcm\")[0]\n        ds = dcmread(fpath)\n        ds.file_meta.TransferSyntaxUID = '1.2.3.4'\n        ds._pixel_id = 1234\n        assert id(ds.PixelData) != ds._pixel_id\n        ds._pixel_array = 'Test Value'\n        # If _pixel_id doesn't match then attempt to get new pixel data\n        orig_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n        with pytest.raises(NotImplementedError):\n            ds.convert_pixel_data()\n\n        pydicom.config.pixel_data_handlers = orig_handlers\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pixel_array_id_changed", "self", "test", "that", "we", "try", "to", "get", "new", "pixel", "data", "if", "the", "id", "has", "changed", "fpath", "get_testdata_files", "ct_small", "dcm", "0", "ds", "dcmread", "fpath", "ds", "file_meta", "transfersyntaxuid", "1", "2", "3", "4", "ds", "_pixel_id", "1234", "assert", "id", "ds", "pixeldata", "ds", "_pixel_id", "ds", "_pixel_array", "test", "value", "if", "_pixel_id", "doesn", "t", "match", "then", "attempt", "to", "get", "new", "pixel", "data", "orig_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "with", "pytest", "raises", "notimplementederror", "ds", "convert_pixel_data", "pydicom", "config", "pixel_data_handlers", "orig_handlers"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_pixel_array_unknown_syntax", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_pixel_array_unknown_syntax", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_pixel_array_unknown_syntax(self):\n        \"\"\"Test that pixel_array for an unknown syntax raises exception.\"\"\"\n        ds = dcmread(get_testdata_files(\"CT_small.dcm\")[0])\n        ds.file_meta.TransferSyntaxUID = '1.2.3.4'\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.3.4' \\(1.2.3.4\\) as there are no pixel data handlers \"\n            r\"available that support it\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_pixel_array_unknown_syntax", "self", "test", "that", "pixel_array", "for", "an", "unknown", "syntax", "raises", "exception", "ds", "dcmread", "get_testdata_files", "ct_small", "dcm", "0", "ds", "file_meta", "transfersyntaxuid", "1", "2", "3", "4", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "3", "4", "1", "2", "3", "4", "as", "there", "are", "no", "pixel", "data", "handlers", "r", "available", "that", "support", "it", "with", "pytest", "raises", "notimplementederror", "match", "msg", "ds", "pixel_array"], "doc_len": 72}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_formatted_lines", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_formatted_lines", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_formatted_lines(self):\n        \"\"\"Test Dataset.formatted_lines\"\"\"\n        ds = Dataset()\n        with pytest.raises(StopIteration):\n            next(ds.formatted_lines())\n        ds.PatientName = 'CITIZEN^Jan'\n        ds.BeamSequence = [Dataset()]\n        ds.BeamSequence[0].PatientID = 'JAN^Citizen'\n        elem_format = \"%(tag)s\"\n        seq_format = \"%(name)s %(tag)s\"\n        indent_format = \">>>\"  # placeholder for future functionality\n\n        line_generator = ds.formatted_lines(element_format=elem_format,\n                                            sequence_element_format=seq_format,\n                                            indent_format=indent_format)\n        assert \"(0010, 0010)\" == next(line_generator)\n        assert \"Beam Sequence (300a, 00b0)\" == next(line_generator)\n        assert \"(0010, 0020)\" == next(line_generator)\n        with pytest.raises(StopIteration):\n            next(line_generator)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_formatted_lines", "self", "test", "dataset", "formatted_lines", "ds", "dataset", "with", "pytest", "raises", "stopiteration", "next", "ds", "formatted_lines", "ds", "patientname", "citizen", "jan", "ds", "beamsequence", "dataset", "ds", "beamsequence", "0", "patientid", "jan", "citizen", "elem_format", "tag", "s", "seq_format", "name", "s", "tag", "s", "indent_format", "placeholder", "for", "future", "functionality", "line_generator", "ds", "formatted_lines", "element_format", "elem_format", "sequence_element_format", "seq_format", "indent_format", "indent_format", "assert", "0010", "0010", "next", "line_generator", "assert", "beam", "sequence", "300a", "00b0", "next", "line_generator", "assert", "0010", "0020", "next", "line_generator", "with", "pytest", "raises", "stopiteration", "next", "line_generator"], "doc_len": 78}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_formatted_lines_known_uid", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_formatted_lines_known_uid", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_formatted_lines_known_uid(self):\n        \"\"\"Test that the UID name is output when known.\"\"\"\n        ds = Dataset()\n        ds.TransferSyntaxUID = '1.2.840.10008.1.2'\n        assert 'Implicit VR Little Endian' in str(ds)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_formatted_lines_known_uid", "self", "test", "that", "the", "uid", "name", "is", "output", "when", "known", "ds", "dataset", "ds", "transfersyntaxuid", "1", "2", "840", "10008", "1", "2", "assert", "implicit", "vr", "little", "endian", "in", "str", "ds"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_set_convert_private_elem_from_raw", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_set_convert_private_elem_from_raw", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_set_convert_private_elem_from_raw(self):\n        \"\"\"Test Dataset.__setitem__ with a raw private element\"\"\"\n        test_file = get_testdata_files('CT_small.dcm')[0]\n        ds = dcmread(test_file, force=True)\n        # 'tag VR length value value_tell is_implicit_VR is_little_endian'\n        elem = RawDataElement((0x0043, 0x1029), 'OB', 2, b'\\x00\\x01', 0,\n                              True, True)\n        ds.__setitem__((0x0043, 0x1029), elem)\n\n        assert b'\\x00\\x01' == ds[(0x0043, 0x1029)].value\n        assert isinstance(ds[(0x0043, 0x1029)], DataElement)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_set_convert_private_elem_from_raw", "self", "test", "dataset", "__setitem__", "with", "a", "raw", "private", "element", "test_file", "get_testdata_files", "ct_small", "dcm", "0", "ds", "dcmread", "test_file", "force", "true", "tag", "vr", "length", "value", "value_tell", "is_implicit_vr", "is_little_endian", "elem", "rawdataelement", "0x0043", "0x1029", "ob", "2", "b", "x00", "x01", "0", "true", "true", "ds", "__setitem__", "0x0043", "0x1029", "elem", "assert", "b", "x00", "x01", "ds", "0x0043", "0x1029", "value", "assert", "isinstance", "ds", "0x0043", "0x1029", "dataelement"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_top", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_top", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_top(self):\n        \"\"\"Test Dataset.top returns only top level str\"\"\"\n        ds = Dataset()\n        ds.PatientName = 'CITIZEN^Jan'\n        ds.BeamSequence = [Dataset()]\n        ds.BeamSequence[0].PatientID = 'JAN^Citizen'\n        assert \"Patient's Name\" in ds.top()\n        assert \"Patient ID\" not in ds.top()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_top", "self", "test", "dataset", "top", "returns", "only", "top", "level", "str", "ds", "dataset", "ds", "patientname", "citizen", "jan", "ds", "beamsequence", "dataset", "ds", "beamsequence", "0", "patientid", "jan", "citizen", "assert", "patient", "s", "name", "in", "ds", "top", "assert", "patient", "id", "not", "in", "ds", "top"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_trait_names", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_trait_names", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_trait_names(self):\n        \"\"\"Test Dataset.trait_names contains element keywords\"\"\"\n        test_file = get_testdata_files('CT_small.dcm')[0]\n        ds = dcmread(test_file, force=True)\n        names = ds.trait_names()\n        assert 'PatientName' in names\n        assert 'save_as' in names\n        assert 'PixelData' in names\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_trait_names", "self", "test", "dataset", "trait_names", "contains", "element", "keywords", "test_file", "get_testdata_files", "ct_small", "dcm", "0", "ds", "dcmread", "test_file", "force", "true", "names", "ds", "trait_names", "assert", "patientname", "in", "names", "assert", "save_as", "in", "names", "assert", "pixeldata", "in", "names"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_walk", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_walk", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_walk(self):\n        \"\"\"Test Dataset.walk iterates through sequences\"\"\"\n        def test_callback(dataset, elem):\n            if elem.keyword is 'PatientID':\n                dataset.PatientID = 'FIXED'\n\n        ds = Dataset()\n        ds.PatientName = 'CITIZEN^Jan'\n        ds.BeamSequence = [Dataset(), Dataset()]\n        ds.BeamSequence[0].PatientID = 'JAN^Citizen^Snr'\n        ds.BeamSequence[0].PatientName = 'Some^Name'\n        ds.BeamSequence[1].PatientID = 'JAN^Citizen^Jr'\n        ds.BeamSequence[1].PatientName = 'Other^Name'\n        ds.walk(test_callback, recursive=True)\n\n        assert 'CITIZEN^Jan' == ds.PatientName\n        assert 'FIXED' == ds.BeamSequence[0].PatientID\n        assert 'Some^Name' == ds.BeamSequence[0].PatientName\n        assert 'FIXED' == ds.BeamSequence[1].PatientID\n        assert 'Other^Name' == ds.BeamSequence[1].PatientName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_walk", "self", "test", "dataset", "walk", "iterates", "through", "sequences", "def", "test_callback", "dataset", "elem", "if", "elem", "keyword", "is", "patientid", "dataset", "patientid", "fixed", "ds", "dataset", "ds", "patientname", "citizen", "jan", "ds", "beamsequence", "dataset", "dataset", "ds", "beamsequence", "0", "patientid", "jan", "citizen", "snr", "ds", "beamsequence", "0", "patientname", "some", "name", "ds", "beamsequence", "1", "patientid", "jan", "citizen", "jr", "ds", "beamsequence", "1", "patientname", "other", "name", "ds", "walk", "test_callback", "recursive", "true", "assert", "citizen", "jan", "ds", "patientname", "assert", "fixed", "ds", "beamsequence", "0", "patientid", "assert", "some", "name", "ds", "beamsequence", "0", "patientname", "assert", "fixed", "ds", "beamsequence", "1", "patientid", "assert", "other", "name", "ds", "beamsequence", "1", "patientname"], "doc_len": 98}
{"doc_id": "pydicom/tests/test_dataset.py::TestDataset.test_update_with_dataset", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDataset", "func_name": "test_update_with_dataset", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDataset\n    def test_update_with_dataset(self):\n        \"\"\"Regression test for #779\"\"\"\n        ds = Dataset()\n        ds.PatientName = \"Test\"\n        ds2 = Dataset()\n        ds2.update(ds)\n        assert 'Test' == ds2.PatientName\n\n        # Test sequences\n        ds2 = Dataset()\n        ds.BeamSequence = [Dataset(), Dataset()]\n        ds.BeamSequence[0].PatientName = 'TestA'\n        ds.BeamSequence[1].PatientName = 'TestB'\n\n        ds2.update(ds)\n        assert 'TestA' == ds2.BeamSequence[0].PatientName\n        assert 'TestB' == ds2.BeamSequence[1].PatientName\n\n        # Test overwrite\n        ds.PatientName = 'TestC'\n        ds2.update(ds)\n        assert 'TestC' == ds2.PatientName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdataset", "def", "test_update_with_dataset", "self", "regression", "test", "for", "779", "ds", "dataset", "ds", "patientname", "test", "ds2", "dataset", "ds2", "update", "ds", "assert", "test", "ds2", "patientname", "test", "sequences", "ds2", "dataset", "ds", "beamsequence", "dataset", "dataset", "ds", "beamsequence", "0", "patientname", "testa", "ds", "beamsequence", "1", "patientname", "testb", "ds2", "update", "ds", "assert", "testa", "ds2", "beamsequence", "0", "patientname", "assert", "testb", "ds2", "beamsequence", "1", "patientname", "test", "overwrite", "ds", "patientname", "testc", "ds2", "update", "ds", "assert", "testc", "ds2", "patientname"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_dataset.py::TestDatasetElements.setup", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDatasetElements", "func_name": "setup", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDatasetElements\n    def setup(self):\n        self.ds = Dataset()\n        self.sub_ds1 = Dataset()\n        self.sub_ds2 = Dataset()\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdatasetelements", "def", "setup", "self", "self", "ds", "dataset", "self", "sub_ds1", "dataset", "self", "sub_ds2", "dataset"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_dataset.py::TestDatasetElements.test_sequence_assignment", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDatasetElements", "func_name": "test_sequence_assignment", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDatasetElements\n    def test_sequence_assignment(self):\n        \"\"\"Assignment to SQ works only if valid Sequence assigned.\"\"\"\n        msg = r\"Sequence contents must be Dataset instances\"\n        with pytest.raises(TypeError, match=msg):\n            self.ds.ConceptCodeSequence = [1, 2, 3]\n\n        # check also that assigning proper sequence *does* work\n        self.ds.ConceptCodeSequence = [self.sub_ds1, self.sub_ds2]\n        assert isinstance(self.ds.ConceptCodeSequence, Sequence)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdatasetelements", "def", "test_sequence_assignment", "self", "assignment", "to", "sq", "works", "only", "if", "valid", "sequence", "assigned", "msg", "r", "sequence", "contents", "must", "be", "dataset", "instances", "with", "pytest", "raises", "typeerror", "match", "msg", "self", "ds", "conceptcodesequence", "1", "2", "3", "check", "also", "that", "assigning", "proper", "sequence", "does", "work", "self", "ds", "conceptcodesequence", "self", "sub_ds1", "self", "sub_ds2", "assert", "isinstance", "self", "ds", "conceptcodesequence", "sequence"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_dataset.py::TestDatasetElements.test_ensure_file_meta", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDatasetElements", "func_name": "test_ensure_file_meta", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDatasetElements\n    def test_ensure_file_meta(self):\n        assert not hasattr(self.ds, 'file_meta')\n        self.ds.ensure_file_meta()\n        assert hasattr(self.ds, 'file_meta')\n        assert not self.ds.file_meta\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdatasetelements", "def", "test_ensure_file_meta", "self", "assert", "not", "hasattr", "self", "ds", "file_meta", "self", "ds", "ensure_file_meta", "assert", "hasattr", "self", "ds", "file_meta", "assert", "not", "self", "ds", "file_meta"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dataset.py::TestDatasetElements.test_fix_meta_info", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDatasetElements", "func_name": "test_fix_meta_info", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDatasetElements\n    def test_fix_meta_info(self):\n        self.ds.is_little_endian = True\n        self.ds.is_implicit_VR = True\n        self.ds.fix_meta_info(enforce_standard=False)\n        assert ImplicitVRLittleEndian == self.ds.file_meta.TransferSyntaxUID\n\n        self.ds.is_implicit_VR = False\n        self.ds.fix_meta_info(enforce_standard=False)\n        # transfer syntax does not change because of ambiguity\n        assert ImplicitVRLittleEndian == self.ds.file_meta.TransferSyntaxUID\n\n        self.ds.is_little_endian = False\n        self.ds.is_implicit_VR = True\n        with pytest.raises(NotImplementedError):\n            self.ds.fix_meta_info()\n\n        self.ds.is_implicit_VR = False\n        self.ds.fix_meta_info(enforce_standard=False)\n        assert ExplicitVRBigEndian == self.ds.file_meta.TransferSyntaxUID\n\n        assert 'MediaStorageSOPClassUID' not in self.ds.file_meta\n        assert 'MediaStorageSOPInstanceUID ' not in self.ds.file_meta\n        with pytest.raises(ValueError,\n                           match='Missing required File Meta .*'):\n            self.ds.fix_meta_info(enforce_standard=True)\n\n        self.ds.SOPClassUID = '1.2.3'\n        self.ds.SOPInstanceUID = '4.5.6'\n        self.ds.fix_meta_info(enforce_standard=False)\n        assert '1.2.3' == self.ds.file_meta.MediaStorageSOPClassUID\n        assert '4.5.6' == self.ds.file_meta.MediaStorageSOPInstanceUID\n        self.ds.fix_meta_info(enforce_standard=True)\n\n        self.ds.file_meta.PatientID = 'PatientID'\n        with pytest.raises(ValueError,\n                           match=r'Only File Meta Information Group '\n                                 r'\\(0002,eeee\\) elements must be present .*'):\n            self.ds.fix_meta_info(enforce_standard=True)\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdatasetelements", "def", "test_fix_meta_info", "self", "self", "ds", "is_little_endian", "true", "self", "ds", "is_implicit_vr", "true", "self", "ds", "fix_meta_info", "enforce_standard", "false", "assert", "implicitvrlittleendian", "self", "ds", "file_meta", "transfersyntaxuid", "self", "ds", "is_implicit_vr", "false", "self", "ds", "fix_meta_info", "enforce_standard", "false", "transfer", "syntax", "does", "not", "change", "because", "of", "ambiguity", "assert", "implicitvrlittleendian", "self", "ds", "file_meta", "transfersyntaxuid", "self", "ds", "is_little_endian", "false", "self", "ds", "is_implicit_vr", "true", "with", "pytest", "raises", "notimplementederror", "self", "ds", "fix_meta_info", "self", "ds", "is_implicit_vr", "false", "self", "ds", "fix_meta_info", "enforce_standard", "false", "assert", "explicitvrbigendian", "self", "ds", "file_meta", "transfersyntaxuid", "assert", "mediastoragesopclassuid", "not", "in", "self", "ds", "file_meta", "assert", "mediastoragesopinstanceuid", "not", "in", "self", "ds", "file_meta", "with", "pytest", "raises", "valueerror", "match", "missing", "required", "file", "meta", "self", "ds", "fix_meta_info", "enforce_standard", "true", "self", "ds", "sopclassuid", "1", "2", "3", "self", "ds", "sopinstanceuid", "4", "5", "6", "self", "ds", "fix_meta_info", "enforce_standard", "false", "assert", "1", "2", "3", "self", "ds", "file_meta", "mediastoragesopclassuid", "assert", "4", "5", "6", "self", "ds", "file_meta", "mediastoragesopinstanceuid", "self", "ds", "fix_meta_info", "enforce_standard", "true", "self", "ds", "file_meta", "patientid", "patientid", "with", "pytest", "raises", "valueerror", "match", "r", "only", "file", "meta", "information", "group", "r", "0002", "eeee", "elements", "must", "be", "present", "self", "ds", "fix_meta_info", "enforce_standard", "true"], "doc_len": 174}
{"doc_id": "pydicom/tests/test_dataset.py::TestDatasetElements.test_validate_and_correct_file_meta", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestDatasetElements", "func_name": "test_validate_and_correct_file_meta", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestDatasetElements\n    def test_validate_and_correct_file_meta(self):\n        file_meta = Dataset()\n        validate_file_meta(file_meta, enforce_standard=False)\n        with pytest.raises(ValueError):\n            validate_file_meta(file_meta, enforce_standard=True)\n\n        file_meta.PatientID = 'PatientID'\n        for enforce_standard in (True, False):\n            with pytest.raises(\n                    ValueError,\n                    match=r'Only File Meta Information Group '\n                          r'\\(0002,eeee\\) elements must be present .*'):\n                validate_file_meta(\n                    file_meta, enforce_standard=enforce_standard)\n\n        file_meta = Dataset()\n        file_meta.MediaStorageSOPClassUID = '1.2.3'\n        file_meta.MediaStorageSOPInstanceUID = '1.2.4'\n        # still missing TransferSyntaxUID\n        with pytest.raises(ValueError):\n            validate_file_meta(file_meta, enforce_standard=True)\n\n        file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        validate_file_meta(file_meta, enforce_standard=True)\n\n        # check the default created values\n        assert b'\\x00\\x01' == file_meta.FileMetaInformationVersion\n        assert PYDICOM_IMPLEMENTATION_UID == file_meta.ImplementationClassUID\n        assert file_meta.ImplementationVersionName.startswith('PYDICOM ')\n\n        file_meta.ImplementationClassUID = '1.2.3.4'\n        file_meta.ImplementationVersionName = 'ACME LTD'\n        validate_file_meta(file_meta, enforce_standard=True)\n        # check that existing values are left alone\n        assert '1.2.3.4' == file_meta.ImplementationClassUID\n        assert 'ACME LTD' == file_meta.ImplementationVersionName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testdatasetelements", "def", "test_validate_and_correct_file_meta", "self", "file_meta", "dataset", "validate_file_meta", "file_meta", "enforce_standard", "false", "with", "pytest", "raises", "valueerror", "validate_file_meta", "file_meta", "enforce_standard", "true", "file_meta", "patientid", "patientid", "for", "enforce_standard", "in", "true", "false", "with", "pytest", "raises", "valueerror", "match", "r", "only", "file", "meta", "information", "group", "r", "0002", "eeee", "elements", "must", "be", "present", "validate_file_meta", "file_meta", "enforce_standard", "enforce_standard", "file_meta", "dataset", "file_meta", "mediastoragesopclassuid", "1", "2", "3", "file_meta", "mediastoragesopinstanceuid", "1", "2", "4", "still", "missing", "transfersyntaxuid", "with", "pytest", "raises", "valueerror", "validate_file_meta", "file_meta", "enforce_standard", "true", "file_meta", "transfersyntaxuid", "implicitvrlittleendian", "validate_file_meta", "file_meta", "enforce_standard", "true", "check", "the", "default", "created", "values", "assert", "b", "x00", "x01", "file_meta", "filemetainformationversion", "assert", "pydicom_implementation_uid", "file_meta", "implementationclassuid", "assert", "file_meta", "implementationversionname", "startswith", "pydicom", "file_meta", "implementationclassuid", "1", "2", "3", "4", "file_meta", "implementationversionname", "acme", "ltd", "validate_file_meta", "file_meta", "enforce_standard", "true", "check", "that", "existing", "values", "are", "left", "alone", "assert", "1", "2", "3", "4", "file_meta", "implementationclassuid", "assert", "acme", "ltd", "file_meta", "implementationversionname"], "doc_len": 135}
{"doc_id": "pydicom/tests/test_dataset.py::TestFileDataset.setup", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestFileDataset", "func_name": "setup", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestFileDataset\n    def setup(self):\n        self.test_file = get_testdata_files('CT_small.dcm')[0]\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testfiledataset", "def", "setup", "self", "self", "test_file", "get_testdata_files", "ct_small", "dcm", "0"], "doc_len": 14}
{"doc_id": "pydicom/tests/test_dataset.py::TestFileDataset.test_equality_file_meta", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestFileDataset", "func_name": "test_equality_file_meta", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestFileDataset\n    def test_equality_file_meta(self):\n        \"\"\"Dataset: equality returns correct value if with metadata\"\"\"\n        d = dcmread(self.test_file)\n        e = dcmread(self.test_file)\n        assert d == e\n\n        e.is_implicit_VR = not e.is_implicit_VR\n        assert not d == e\n\n        e.is_implicit_VR = not e.is_implicit_VR\n        assert d == e\n        e.is_little_endian = not e.is_little_endian\n        assert not d == e\n\n        e.is_little_endian = not e.is_little_endian\n        assert d == e\n        e.filename = 'test_filename.dcm'\n        assert not d == e\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testfiledataset", "def", "test_equality_file_meta", "self", "dataset", "equality", "returns", "correct", "value", "if", "with", "metadata", "d", "dcmread", "self", "test_file", "e", "dcmread", "self", "test_file", "assert", "d", "e", "e", "is_implicit_vr", "not", "e", "is_implicit_vr", "assert", "not", "d", "e", "e", "is_implicit_vr", "not", "e", "is_implicit_vr", "assert", "d", "e", "e", "is_little_endian", "not", "e", "is_little_endian", "assert", "not", "d", "e", "e", "is_little_endian", "not", "e", "is_little_endian", "assert", "d", "e", "e", "filename", "test_filename", "dcm", "assert", "not", "d", "e"], "doc_len": 69}
{"doc_id": "pydicom/tests/test_dataset.py::TestFileDataset.test_creation_with_container", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestFileDataset", "func_name": "test_creation_with_container", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestFileDataset\n    def test_creation_with_container(self):\n        \"\"\"FileDataset.__init__ works OK with a container such as gzip\"\"\"\n        class Dummy(object):\n            filename = '/some/path/to/test'\n\n        ds = Dataset()\n        ds.PatientName = \"CITIZEN^Jan\"\n        fds = FileDataset(Dummy(), ds)\n        assert '/some/path/to/test' == fds.filename\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testfiledataset", "def", "test_creation_with_container", "self", "filedataset", "__init__", "works", "ok", "with", "a", "container", "such", "as", "gzip", "class", "dummy", "object", "filename", "some", "path", "to", "test", "ds", "dataset", "ds", "patientname", "citizen", "jan", "fds", "filedataset", "dummy", "ds", "assert", "some", "path", "to", "test", "fds", "filename"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_dataset.py::TestFileDataset.test_works_as_expected_within_numpy_array", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestFileDataset", "func_name": "test_works_as_expected_within_numpy_array", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestFileDataset\n    def test_works_as_expected_within_numpy_array(self):\n        \"\"\"Test Dataset within a numpy array\"\"\"\n        try:\n            import numpy as np\n        except ImportError:\n            np = None\n\n        if np is None:\n            pytest.skip('No numpy installed')\n\n        # see PR #836\n        dataset = Dataset()\n        patient_name = 'MacDonald^George'\n        dataset.PatientName = patient_name\n        array_of_datasets = np.array([dataset])\n        assert patient_name == array_of_datasets[0].PatientName\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testfiledataset", "def", "test_works_as_expected_within_numpy_array", "self", "test", "dataset", "within", "a", "numpy", "array", "try", "import", "numpy", "as", "np", "except", "importerror", "np", "none", "if", "np", "is", "none", "pytest", "skip", "no", "numpy", "installed", "see", "pr", "836", "dataset", "dataset", "patient_name", "macdonald", "george", "dataset", "patientname", "patient_name", "array_of_datasets", "np", "array", "dataset", "assert", "patient_name", "array_of_datasets", "0", "patientname"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_dataset.py::TestFileDataset.test_dataset_overrides_all_dict_attributes", "file_path": "pydicom/tests/test_dataset.py", "class_name": "TestFileDataset", "func_name": "test_dataset_overrides_all_dict_attributes", "text": "文件路径: pydicom/tests/test_dataset.py, 类名: TestFileDataset\n    def test_dataset_overrides_all_dict_attributes(self):\n        \"\"\"Ensure that we don't use inherited dict functionality\"\"\"\n        ds = Dataset()\n        di = dict()\n        expected_diff = {'__class__', '__doc__', '__hash__'}\n        assert expected_diff == set(dir(di)) - set(dir(ds))\n", "tokens": ["pydicom", "tests", "test_dataset", "py", "testfiledataset", "def", "test_dataset_overrides_all_dict_attributes", "self", "ensure", "that", "we", "don", "t", "use", "inherited", "dict", "functionality", "ds", "dataset", "di", "dict", "expected_diff", "__class__", "__doc__", "__hash__", "assert", "expected_diff", "set", "dir", "di", "set", "dir", "ds"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_dicomdir.py::TestDicomDir.test_read_file", "file_path": "pydicom/tests/test_dicomdir.py", "class_name": "TestDicomDir", "func_name": "test_read_file", "text": "文件路径: pydicom/tests/test_dicomdir.py, 类名: TestDicomDir\n    def test_read_file(self):\n        \"\"\"Test creation of DicomDir instance using filereader.read_file\"\"\"\n        ds = read_file(TEST_FILE)\n        assert isinstance(ds, DicomDir)\n", "tokens": ["pydicom", "tests", "test_dicomdir", "py", "testdicomdir", "def", "test_read_file", "self", "test", "creation", "of", "dicomdir", "instance", "using", "filereader", "read_file", "ds", "read_file", "test_file", "assert", "isinstance", "ds", "dicomdir"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_dicomdir.py::TestDicomDir.test_invalid_sop_file_meta", "file_path": "pydicom/tests/test_dicomdir.py", "class_name": "TestDicomDir", "func_name": "test_invalid_sop_file_meta", "text": "文件路径: pydicom/tests/test_dicomdir.py, 类名: TestDicomDir\n    def test_invalid_sop_file_meta(self):\n        \"\"\"Test exception raised if SOP Class is not Media Storage Directory\"\"\"\n        ds = read_file(get_testdata_files('CT_small.dcm')[0])\n        with pytest.raises(InvalidDicomError,\n                           match=r\"SOP Class is not Media Storage \"\n                                 r\"Directory \\(DICOMDIR\\)\"):\n            DicomDir(\"some_name\", ds, b'\\x00' * 128, ds.file_meta, True, True)\n", "tokens": ["pydicom", "tests", "test_dicomdir", "py", "testdicomdir", "def", "test_invalid_sop_file_meta", "self", "test", "exception", "raised", "if", "sop", "class", "is", "not", "media", "storage", "directory", "ds", "read_file", "get_testdata_files", "ct_small", "dcm", "0", "with", "pytest", "raises", "invaliddicomerror", "match", "r", "sop", "class", "is", "not", "media", "storage", "r", "directory", "dicomdir", "dicomdir", "some_name", "ds", "b", "x00", "128", "ds", "file_meta", "true", "true"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_dicomdir.py::TestDicomDir.test_invalid_sop_no_file_meta", "file_path": "pydicom/tests/test_dicomdir.py", "class_name": "TestDicomDir", "func_name": "test_invalid_sop_no_file_meta", "text": "文件路径: pydicom/tests/test_dicomdir.py, 类名: TestDicomDir\n    def test_invalid_sop_no_file_meta(self):\n        \"\"\"Test exception raised if invalid sop class but no file_meta\"\"\"\n        ds = read_file(get_testdata_files('CT_small.dcm')[0])\n        with pytest.raises(AttributeError,\n                           match=\"'DicomDir' object has no attribute \"\n                                 \"'DirectoryRecordSequence'\"):\n            DicomDir(\"some_name\", ds, b'\\x00' * 128, None, True, True)\n", "tokens": ["pydicom", "tests", "test_dicomdir", "py", "testdicomdir", "def", "test_invalid_sop_no_file_meta", "self", "test", "exception", "raised", "if", "invalid", "sop", "class", "but", "no", "file_meta", "ds", "read_file", "get_testdata_files", "ct_small", "dcm", "0", "with", "pytest", "raises", "attributeerror", "match", "dicomdir", "object", "has", "no", "attribute", "directoryrecordsequence", "dicomdir", "some_name", "ds", "b", "x00", "128", "none", "true", "true"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_dicomdir.py::TestDicomDir.test_parse_records", "file_path": "pydicom/tests/test_dicomdir.py", "class_name": "TestDicomDir", "func_name": "test_parse_records", "text": "文件路径: pydicom/tests/test_dicomdir.py, 类名: TestDicomDir\n    def test_parse_records(self):\n        \"\"\"Test DicomDir.parse_records\"\"\"\n        ds = read_file(TEST_FILE)\n        assert hasattr(ds, 'patient_records')\n        # There are two top level PATIENT records\n        assert len(ds.patient_records) == 2\n        assert ds.patient_records[0].PatientName == 'Doe^Archibald'\n        assert ds.patient_records[1].PatientName == 'Doe^Peter'\n", "tokens": ["pydicom", "tests", "test_dicomdir", "py", "testdicomdir", "def", "test_parse_records", "self", "test", "dicomdir", "parse_records", "ds", "read_file", "test_file", "assert", "hasattr", "ds", "patient_records", "there", "are", "two", "top", "level", "patient", "records", "assert", "len", "ds", "patient_records", "2", "assert", "ds", "patient_records", "0", "patientname", "doe", "archibald", "assert", "ds", "patient_records", "1", "patientname", "doe", "peter"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_tag_not_found", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_tag_not_found", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_tag_not_found(self):\n        \"\"\"dicom_dictionary: CleanName returns blank string for unknown tag\"\"\"\n        assert '' == keyword_for_tag(0x99991111)\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_tag_not_found", "self", "dicom_dictionary", "cleanname", "returns", "blank", "string", "for", "unknown", "tag", "assert", "keyword_for_tag", "0x99991111"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_repeaters", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_repeaters", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_repeaters(self):\n        \"\"\"dicom_dictionary: Tags with \"x\" return correct dict info........\"\"\"\n        assert 'Transform Label' == dictionary_description(0x280400)\n        assert ('Rows For Nth Order Coefficients' ==\n                dictionary_description(0x280410))\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_repeaters", "self", "dicom_dictionary", "tags", "with", "x", "return", "correct", "dict", "info", "assert", "transform", "label", "dictionary_description", "0x280400", "assert", "rows", "for", "nth", "order", "coefficients", "dictionary_description", "0x280410"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_dict_has_tag", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_dict_has_tag", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_dict_has_tag(self):\n        \"\"\"Test dictionary_has_tag\"\"\"\n        assert dictionary_has_tag(0x00100010)\n        assert not dictionary_has_tag(0x11110010)\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_dict_has_tag", "self", "test", "dictionary_has_tag", "assert", "dictionary_has_tag", "0x00100010", "assert", "not", "dictionary_has_tag", "0x11110010"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_repeater_has_tag", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_repeater_has_tag", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_repeater_has_tag(self):\n        \"\"\"Test repeater_has_tag\"\"\"\n        assert repeater_has_tag(0x60000010)\n        assert repeater_has_tag(0x60020010)\n        assert not repeater_has_tag(0x00100010)\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_repeater_has_tag", "self", "test", "repeater_has_tag", "assert", "repeater_has_tag", "0x60000010", "assert", "repeater_has_tag", "0x60020010", "assert", "not", "repeater_has_tag", "0x00100010"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_repeater_has_keyword", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_repeater_has_keyword", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_repeater_has_keyword(self):\n        \"\"\"Test repeater_has_keyword\"\"\"\n        assert repeater_has_keyword('OverlayData')\n        assert not repeater_has_keyword('PixelData')\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_repeater_has_keyword", "self", "test", "repeater_has_keyword", "assert", "repeater_has_keyword", "overlaydata", "assert", "not", "repeater_has_keyword", "pixeldata"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_get_private_entry", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_get_private_entry", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_get_private_entry(self):\n        \"\"\"Test get_private_entry\"\"\"\n        # existing entry\n        entry = get_private_entry((0x0903, 0x0011), 'GEIIS PACS')\n        assert 'US' == entry[0]  # VR\n        assert '1' == entry[1]  # VM\n        assert 'Significant Flag' == entry[2]  # name\n        assert not entry[3]  # is retired\n\n        # existing entry in another slot\n        entry = get_private_entry((0x0903, 0x1011), 'GEIIS PACS')\n        assert 'Significant Flag' == entry[2]  # name\n\n        # non-existing entry\n        with pytest.raises(KeyError):\n            get_private_entry((0x0903, 0x0011), 'Nonexisting')\n        with pytest.raises(KeyError):\n            get_private_entry((0x0903, 0x0091), 'GEIIS PACS')\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_get_private_entry", "self", "test", "get_private_entry", "existing", "entry", "entry", "get_private_entry", "0x0903", "0x0011", "geiis", "pacs", "assert", "us", "entry", "0", "vr", "assert", "1", "entry", "1", "vm", "assert", "significant", "flag", "entry", "2", "name", "assert", "not", "entry", "3", "is", "retired", "existing", "entry", "in", "another", "slot", "entry", "get_private_entry", "0x0903", "0x1011", "geiis", "pacs", "assert", "significant", "flag", "entry", "2", "name", "non", "existing", "entry", "with", "pytest", "raises", "keyerror", "get_private_entry", "0x0903", "0x0011", "nonexisting", "with", "pytest", "raises", "keyerror", "get_private_entry", "0x0903", "0x0091", "geiis", "pacs"], "doc_len": 77}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_entry", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_entry", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_entry(self):\n        \"\"\"dicom_dictionary: Can add and use a single dictionary entry\"\"\"\n        add_dict_entry(0x10021001, \"UL\", \"TestOne\", \"Test One\")\n        add_dict_entry(0x10021002, \"DS\", \"TestTwo\", \"Test Two\", VM='3')\n        ds = Dataset()\n        ds.TestOne = 'test'\n        ds.TestTwo = ['1', '2', '3']\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_entry", "self", "dicom_dictionary", "can", "add", "and", "use", "a", "single", "dictionary", "entry", "add_dict_entry", "0x10021001", "ul", "testone", "test", "one", "add_dict_entry", "0x10021002", "ds", "testtwo", "test", "two", "vm", "3", "ds", "dataset", "ds", "testone", "test", "ds", "testtwo", "1", "2", "3"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_entry_raises_for_private_tag", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_entry_raises_for_private_tag", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_entry_raises_for_private_tag(self):\n        with pytest.raises(ValueError,\n                           match='Private tags cannot be '\n                                 'added using \"add_dict_entries\"'):\n            add_dict_entry(0x10011101, 'DS', 'Test One', 'Test One')\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_entry_raises_for_private_tag", "self", "with", "pytest", "raises", "valueerror", "match", "private", "tags", "cannot", "be", "added", "using", "add_dict_entries", "add_dict_entry", "0x10011101", "ds", "test", "one", "test", "one"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_entries", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_entries", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_entries(self):\n        \"\"\"dicom_dictionary: add and use a dict of new dictionary entries\"\"\"\n        new_dict_items = {\n            0x10021001: ('UL', '1', \"Test One\", '', 'TestOne'),\n            0x10021002: ('DS', '3', \"Test Two\", '', 'TestTwo'),\n        }\n        add_dict_entries(new_dict_items)\n        ds = Dataset()\n        ds.TestOne = 'test'\n        ds.TestTwo = ['1', '2', '3']\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_entries", "self", "dicom_dictionary", "add", "and", "use", "a", "dict", "of", "new", "dictionary", "entries", "new_dict_items", "0x10021001", "ul", "1", "test", "one", "testone", "0x10021002", "ds", "3", "test", "two", "testtwo", "add_dict_entries", "new_dict_items", "ds", "dataset", "ds", "testone", "test", "ds", "testtwo", "1", "2", "3"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_entries_raises_for_private_tags", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_entries_raises_for_private_tags", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_entries_raises_for_private_tags(self):\n        new_dict_items = {\n            0x10021001: ('UL', '1', 'Test One', '', 'TestOne'),\n            0x10011002: ('DS', '3', 'Test Two', '', 'TestTwo'),\n        }\n        with pytest.raises(ValueError, match='Private tags cannot be added '\n                                             'using \"add_dict_entries\"'):\n            add_dict_entries(new_dict_items)\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_entries_raises_for_private_tags", "self", "new_dict_items", "0x10021001", "ul", "1", "test", "one", "testone", "0x10011002", "ds", "3", "test", "two", "testtwo", "with", "pytest", "raises", "valueerror", "match", "private", "tags", "cannot", "be", "added", "using", "add_dict_entries", "add_dict_entries", "new_dict_items"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_private_entry", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_private_entry", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_private_entry(self):\n        add_private_dict_entry('ACME 3.1', 0x10011101, 'DS', 'Test One', '3')\n        entry = get_private_entry((0x1001, 0x0001), 'ACME 3.1')\n        assert 'DS' == entry[0]  # VR\n        assert '3' == entry[1]  # VM\n        assert 'Test One' == entry[2]  # description\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_private_entry", "self", "add_private_dict_entry", "acme", "3", "1", "0x10011101", "ds", "test", "one", "3", "entry", "get_private_entry", "0x1001", "0x0001", "acme", "3", "1", "assert", "ds", "entry", "0", "vr", "assert", "3", "entry", "1", "vm", "assert", "test", "one", "entry", "2", "description"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_private_entry_raises_for_non_private_tag", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_private_entry_raises_for_non_private_tag", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_private_entry_raises_for_non_private_tag(self):\n        with pytest.raises(ValueError,\n                           match='Non-private tags cannot be '\n                                 'added using \"add_private_dict_entries\"'):\n            add_private_dict_entry('ACME 3.1', 0x10021101, 'DS', 'Test One')\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_private_entry_raises_for_non_private_tag", "self", "with", "pytest", "raises", "valueerror", "match", "non", "private", "tags", "cannot", "be", "added", "using", "add_private_dict_entries", "add_private_dict_entry", "acme", "3", "1", "0x10021101", "ds", "test", "one"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_private_entries", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_private_entries", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_private_entries(self):\n        \"\"\"dicom_dictionary: add and use a dict of new dictionary entries\"\"\"\n        new_dict_items = {\n            0x10011001: ('SH', '1', \"Test One\",),\n            0x10011002: ('DS', '3', \"Test Two\", '', 'TestTwo'),\n        }\n        add_private_dict_entries('ACME 3.1', new_dict_items)\n        ds = Dataset()\n        ds[0x10010010] = DataElement(0x10010010, 'LO', 'ACME 3.1')\n        ds[0x10011001] = DataElement(0x10011001, 'SH', 'Test')\n        ds[0x10011002] = DataElement(0x10011002, 'DS', '1\\\\2\\\\3')\n\n        assert 'Test' == ds[0x10011001].value\n        assert [1, 2, 3] == ds[0x10011002].value\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_private_entries", "self", "dicom_dictionary", "add", "and", "use", "a", "dict", "of", "new", "dictionary", "entries", "new_dict_items", "0x10011001", "sh", "1", "test", "one", "0x10011002", "ds", "3", "test", "two", "testtwo", "add_private_dict_entries", "acme", "3", "1", "new_dict_items", "ds", "dataset", "ds", "0x10010010", "dataelement", "0x10010010", "lo", "acme", "3", "1", "ds", "0x10011001", "dataelement", "0x10011001", "sh", "test", "ds", "0x10011002", "dataelement", "0x10011002", "ds", "1", "2", "3", "assert", "test", "ds", "0x10011001", "value", "assert", "1", "2", "3", "ds", "0x10011002", "value"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_add_private_entries_raises_for_non_private_tags", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_add_private_entries_raises_for_non_private_tags", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_add_private_entries_raises_for_non_private_tags(self):\n        new_dict_items = {\n            0x10021001: ('UL', '1', 'Test One', '', 'TestOne'),\n            0x10011002: ('DS', '3', 'Test Two', '', 'TestTwo'),\n        }\n        with pytest.raises(ValueError,\n                           match='Non-private tags cannot be '\n                                 'added using \"add_private_dict_entries\"'):\n            add_private_dict_entries('ACME 3.1', new_dict_items)\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_add_private_entries_raises_for_non_private_tags", "self", "new_dict_items", "0x10021001", "ul", "1", "test", "one", "testone", "0x10011002", "ds", "3", "test", "two", "testtwo", "with", "pytest", "raises", "valueerror", "match", "non", "private", "tags", "cannot", "be", "added", "using", "add_private_dict_entries", "add_private_dict_entries", "acme", "3", "1", "new_dict_items"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_dictionary_VM", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_dictionary_VM", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_dictionary_VM(self):\n        \"\"\"Test dictionary_VM\"\"\"\n        assert dictionary_VM(0x00000000) == '1'\n        assert dictionary_VM(0x00081163) == '2'\n        assert dictionary_VM(0x0000901) == '1-n'\n        assert dictionary_VM(0x00041141) == '1-8'\n        assert dictionary_VM(0x00080008) == '2-n'\n        assert dictionary_VM(0x00080309) == '1-3'\n        assert dictionary_VM(0x00081162) == '3-3n'\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_dictionary_vm", "self", "test", "dictionary_vm", "assert", "dictionary_vm", "0x00000000", "1", "assert", "dictionary_vm", "0x00081163", "2", "assert", "dictionary_vm", "0x0000901", "1", "n", "assert", "dictionary_vm", "0x00041141", "1", "8", "assert", "dictionary_vm", "0x00080008", "2", "n", "assert", "dictionary_vm", "0x00080309", "1", "3", "assert", "dictionary_vm", "0x00081162", "3", "3n"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_private_dict_VR", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_private_dict_VR", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_private_dict_VR(self):\n        \"\"\"Test private_dictionary_VR\"\"\"\n        assert private_dictionary_VR(0x00090000, 'ACUSON') == 'IS'\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_private_dict_vr", "self", "test", "private_dictionary_vr", "assert", "private_dictionary_vr", "0x00090000", "acuson", "is"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_dictionary.py::TestDict.test_private_dict_VM", "file_path": "pydicom/tests/test_dictionary.py", "class_name": "TestDict", "func_name": "test_private_dict_VM", "text": "文件路径: pydicom/tests/test_dictionary.py, 类名: TestDict\n    def test_private_dict_VM(self):\n        \"\"\"Test private_dictionary_VM\"\"\"\n        assert private_dictionary_VM(0x00090000, 'ACUSON') == '1'\n", "tokens": ["pydicom", "tests", "test_dictionary", "py", "testdict", "def", "test_private_dict_vm", "self", "test", "private_dictionary_vm", "assert", "private_dictionary_vm", "0x00090000", "acuson", "1"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_bad_tag", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_bad_tag", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_bad_tag(self):\n        \"\"\"Test raises exception if no item tag.\"\"\"\n        # (fffe,e100)\n        bytestream = b'\\xFE\\xFF\\x00\\xE1' \\\n                     b'\\x08\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        with pytest.raises(ValueError,\n                           match=r\"Unexpected tag '\\(fffe, e100\\)' when \"\n                                 r\"parsing the Basic Table Offset item.\"):\n            get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_bad_tag", "self", "test", "raises", "exception", "if", "no", "item", "tag", "fffe", "e100", "bytestream", "b", "xfe", "xff", "x00", "xe1", "b", "x08", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "with", "pytest", "raises", "valueerror", "match", "r", "unexpected", "tag", "fffe", "e100", "when", "r", "parsing", "the", "basic", "table", "offset", "item", "get_frame_offsets", "fp"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_bad_length_multiple", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_bad_length_multiple", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_bad_length_multiple(self):\n        \"\"\"Test raises exception if the item length is not a multiple of 4.\"\"\"\n        # Length 10\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0A\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        with pytest.raises(ValueError,\n                           match=\"The length of the Basic Offset Table item\"\n                                 \" is not a multiple of 4.\"):\n            get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_bad_length_multiple", "self", "test", "raises", "exception", "if", "the", "item", "length", "is", "not", "a", "multiple", "of", "4", "length", "10", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0a", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "x09", "x0a", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "with", "pytest", "raises", "valueerror", "match", "the", "length", "of", "the", "basic", "offset", "table", "item", "is", "not", "a", "multiple", "of", "4", "get_frame_offsets", "fp"], "doc_len": 72}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_zero_length", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_zero_length", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_zero_length(self):\n        \"\"\"Test reading BOT with zero length\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert [0] == get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_zero_length", "self", "test", "reading", "bot", "with", "zero", "length", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "0", "get_frame_offsets", "fp"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_multi_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_multi_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_multi_frame(self):\n        \"\"\"Test reading multi-frame BOT item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x10\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x66\\x13\\x00\\x00' \\\n                     b'\\xF4\\x25\\x00\\x00' \\\n                     b'\\xFE\\x37\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert [0, 4966, 9716, 14334] == get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_multi_frame", "self", "test", "reading", "multi", "frame", "bot", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x10", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x66", "x13", "x00", "x00", "b", "xf4", "x25", "x00", "x00", "b", "xfe", "x37", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "0", "4966", "9716", "14334", "get_frame_offsets", "fp"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_single_frame(self):\n        \"\"\"Test reading single-frame BOT item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert [0] == get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_single_frame", "self", "test", "reading", "single", "frame", "bot", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "0", "get_frame_offsets", "fp"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_encaps.py::TestGetFrameOffsets.test_not_little_endian", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGetFrameOffsets", "func_name": "test_not_little_endian", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGetFrameOffsets\n    def test_not_little_endian(self):\n        \"\"\"Test reading big endian raises exception\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = False\n        with pytest.raises(ValueError,\n                           match=\"'fp.is_little_endian' must be True\"):\n            get_frame_offsets(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgetframeoffsets", "def", "test_not_little_endian", "self", "test", "reading", "big", "endian", "raises", "exception", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "false", "with", "pytest", "raises", "valueerror", "match", "fp", "is_little_endian", "must", "be", "true", "get_frame_offsets", "fp"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_item_undefined_length", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_item_undefined_length", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_item_undefined_length(self):\n        \"\"\"Test exception raised if item length undefined.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\xFF\\xFF\\xFF\\xFF' \\\n                     b'\\x00\\x00\\x00\\x01'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        with pytest.raises(ValueError,\n                           match=\"Undefined item length at offset 4 when \"\n                                 \"parsing the encapsulated pixel data \"\n                                 \"fragments.\"):\n            next(fragments)\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_item_undefined_length", "self", "test", "exception", "raised", "if", "item", "length", "undefined", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "xff", "xff", "xff", "xff", "b", "x00", "x00", "x00", "x01", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "with", "pytest", "raises", "valueerror", "match", "undefined", "item", "length", "at", "offset", "4", "when", "parsing", "the", "encapsulated", "pixel", "data", "fragments", "next", "fragments", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_item_sequence_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_item_sequence_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_item_sequence_delimiter(self):\n        \"\"\"Test that the fragments are returned if seq delimiter hit.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\xDD\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_item_sequence_delimiter", "self", "test", "that", "the", "fragments", "are", "returned", "if", "seq", "delimiter", "hit", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "xdd", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 81}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_item_bad_tag", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_item_bad_tag", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_item_bad_tag(self):\n        \"\"\"Test exception raised if item has unexpected tag\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\x10\\x00\\x10\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        with pytest.raises(ValueError,\n                           match=r\"Unexpected tag '\\(0010, 0010\\)' at offset \"\n                                 r\"12 when parsing the encapsulated pixel \"\n                                 r\"data \"\n                                 r\"fragment items.\"):\n            next(fragments)\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_item_bad_tag", "self", "test", "exception", "raised", "if", "item", "has", "unexpected", "tag", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "x10", "x00", "x10", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "with", "pytest", "raises", "valueerror", "match", "r", "unexpected", "tag", "0010", "0010", "at", "offset", "r", "12", "when", "parsing", "the", "encapsulated", "pixel", "r", "data", "r", "fragment", "items", "next", "fragments", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 105}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_single_fragment_no_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_single_fragment_no_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_single_fragment_no_delimiter(self):\n        \"\"\"Test single fragment is returned OK\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_single_fragment_no_delimiter", "self", "test", "single", "fragment", "is", "returned", "ok", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_multi_fragments_no_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_multi_fragments_no_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_multi_fragments_no_delimiter(self):\n        \"\"\"Test multi fragments are returned OK\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        assert next(fragments) == b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_multi_fragments_no_delimiter", "self", "test", "multi", "fragments", "are", "returned", "ok", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "assert", "next", "fragments", "b", "x01", "x02", "x03", "x04", "x05", "x06", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_single_fragment_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_single_fragment_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_single_fragment_delimiter(self):\n        \"\"\"Test single fragment is returned OK with sequence delimiter item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\xDD\\xE0'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_single_fragment_delimiter", "self", "test", "single", "fragment", "is", "returned", "ok", "with", "sequence", "delimiter", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "xdd", "xe0", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_multi_fragments_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_multi_fragments_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_multi_fragments_delimiter(self):\n        \"\"\"Test multi fragments are returned OK with sequence delimiter item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06' \\\n                     b'\\xFE\\xFF\\xDD\\xE0'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        fragments = generate_pixel_data_fragment(fp)\n        assert next(fragments) == b'\\x01\\x00\\x00\\x00'\n        assert next(fragments) == b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_multi_fragments_delimiter", "self", "test", "multi", "fragments", "are", "returned", "ok", "with", "sequence", "delimiter", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "b", "xfe", "xff", "xdd", "xe0", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "fragments", "generate_pixel_data_fragment", "fp", "assert", "next", "fragments", "b", "x01", "x00", "x00", "x00", "assert", "next", "fragments", "b", "x01", "x02", "x03", "x04", "x05", "x06", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFragment.test_not_little_endian", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFragment", "func_name": "test_not_little_endian", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFragment\n    def test_not_little_endian(self):\n        \"\"\"Test reading big endian raises exception\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = False\n        fragments = generate_pixel_data_fragment(fp)\n        with pytest.raises(ValueError,\n                           match=\"'fp.is_little_endian' must be True\"):\n            next(fragments)\n        pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldatafragment", "def", "test_not_little_endian", "self", "test", "reading", "big", "endian", "raises", "exception", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "false", "fragments", "generate_pixel_data_fragment", "fp", "with", "pytest", "raises", "valueerror", "match", "fp", "is_little_endian", "must", "be", "true", "next", "fragments", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_empty_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_empty_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_empty_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragments\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == b'\\x01\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_empty_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragments", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_empty_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_empty_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_empty_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == (\n            b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_empty_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 104}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragment\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == b'\\x01\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragment", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == (\n            b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 109}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_multi_frame_one_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_multi_frame_one_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_multi_frame_one_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is one fragment\"\"\"\n        # 3 frames, each 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x18\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == b'\\x01\\x00\\x00\\x00'\n        assert next(frames) == b'\\x02\\x00\\x00\\x00'\n        assert next(frames) == b'\\x03\\x00\\x00\\x00'\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_multi_frame_one_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "one", "fragment", "3", "frames", "each", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0c", "x00", "x00", "x00", "b", "x18", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "assert", "next", "frames", "b", "x02", "x00", "x00", "x00", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 128}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_multi_frame_three_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_multi_frame_three_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_multi_frame_three_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is three fragments\"\"\"\n        # 2 frames, each 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x20\\x00\\x00\\x00' \\\n                     b'\\x40\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == (\n            b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        )\n        assert next(frames) == (\n            b'\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        )\n        assert next(frames) == (\n            b'\\x03\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_multi_frame_three_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "three", "fragments", "2", "frames", "each", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x20", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "assert", "next", "frames", "b", "x02", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 224}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelDataFrames.test_multi_frame_varied_ratio", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelDataFrames", "func_name": "test_multi_frame_varied_ratio", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelDataFrames\n    def test_multi_frame_varied_ratio(self):\n        \"\"\"Test a multi-frame image where each frames is random fragments\"\"\"\n        # 3 frames, 1st is 1 fragment, 2nd is 3 fragments, 3rd is 2 fragments\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0E\\x00\\x00\\x00' \\\n                     b'\\x32\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x01' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x02' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x04'\n        frames = generate_pixel_data_frame(bytestream)\n        assert next(frames) == b'\\x01\\x00\\x00\\x00\\x00\\x01'\n        assert next(frames) == (\n            b'\\x02\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x02'\n        )\n        assert next(frames) == b'\\x03\\x00\\x00\\x00\\x02\\x04'\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldataframes", "def", "test_multi_frame_varied_ratio", "self", "test", "a", "multi", "frame", "image", "where", "each", "frames", "is", "random", "fragments", "3", "frames", "1st", "is", "1", "fragment", "2nd", "is", "3", "fragments", "3rd", "is", "2", "fragments", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0e", "x00", "x00", "x00", "b", "x32", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "x00", "x01", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "x00", "x02", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x04", "frames", "generate_pixel_data_frame", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "x00", "x01", "assert", "next", "frames", "b", "x02", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "x00", "x02", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "x02", "x04", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 187}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_empty_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_empty_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_empty_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragments\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00', )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_empty_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragments", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_empty_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_empty_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_empty_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00',\n                                b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00')\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_empty_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 106}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragment\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00', )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragment", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00',\n                                b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00')\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 111}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_multi_frame_one_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_multi_frame_one_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_multi_frame_one_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is one fragment\"\"\"\n        # 3 frames, each 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x18\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00', )\n        assert next(frames) == (b'\\x02\\x00\\x00\\x00', )\n        assert next(frames) == (b'\\x03\\x00\\x00\\x00', )\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_multi_frame_one_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "one", "fragment", "3", "frames", "each", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0c", "x00", "x00", "x00", "b", "x18", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "assert", "next", "frames", "b", "x02", "x00", "x00", "x00", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 128}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_multi_frame_three_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_multi_frame_three_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_multi_frame_three_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is three fragments\"\"\"\n        # 2 frames, each 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x20\\x00\\x00\\x00' \\\n                     b'\\x40\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00',\n                                b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00')\n        assert next(frames) == (b'\\x02\\x00\\x00\\x00',\n                                b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00')\n        assert next(frames) == (b'\\x03\\x00\\x00\\x00',\n                                b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00')\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_multi_frame_three_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "three", "fragments", "2", "frames", "each", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x20", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "assert", "next", "frames", "b", "x02", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 230}
{"doc_id": "pydicom/tests/test_encaps.py::TestGeneratePixelData.test_multi_frame_varied_ratio", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestGeneratePixelData", "func_name": "test_multi_frame_varied_ratio", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestGeneratePixelData\n    def test_multi_frame_varied_ratio(self):\n        \"\"\"Test a multi-frame image where each frames is random fragments\"\"\"\n        # 3 frames, 1st is 1 fragment, 2nd is 3 fragments, 3rd is 2 fragments\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0E\\x00\\x00\\x00' \\\n                     b'\\x32\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x01' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x02' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x04'\n        frames = generate_pixel_data(bytestream)\n        assert next(frames) == (b'\\x01\\x00\\x00\\x00\\x00\\x01', )\n        assert next(frames) == (b'\\x02\\x00', b'\\x02\\x00\\x00\\x00',\n                                b'\\x03\\x00\\x00\\x00\\x00\\x02')\n        assert next(frames) == (b'\\x03\\x00\\x00\\x00', b'\\x02\\x04')\n        pytest.raises(StopIteration, next, frames)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testgeneratepixeldata", "def", "test_multi_frame_varied_ratio", "self", "test", "a", "multi", "frame", "image", "where", "each", "frames", "is", "random", "fragments", "3", "frames", "1st", "is", "1", "fragment", "2nd", "is", "3", "fragments", "3rd", "is", "2", "fragments", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0e", "x00", "x00", "x00", "b", "x32", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "x00", "x01", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "x00", "x02", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x04", "frames", "generate_pixel_data", "bytestream", "assert", "next", "frames", "b", "x01", "x00", "x00", "x00", "x00", "x01", "assert", "next", "frames", "b", "x02", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "x00", "x02", "assert", "next", "frames", "b", "x03", "x00", "x00", "x00", "b", "x02", "x04", "pytest", "raises", "stopiteration", "next", "frames"], "doc_len": 190}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_empty_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_empty_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_empty_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragments\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [b'\\x01\\x00\\x00\\x00']\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_empty_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragments", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_empty_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_empty_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_empty_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [b'\\x01\\x00\\x00\\x00',\n                          b'\\x02\\x00\\x00\\x00',\n                          b'\\x03\\x00\\x00\\x00']\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_empty_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00"], "doc_len": 100}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_bot_single_fragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_bot_single_fragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_bot_single_fragment(self):\n        \"\"\"Test a single-frame image where the frame is one fragment\"\"\"\n        # 1 frame, 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [b'\\x01\\x00\\x00\\x00']\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_bot_single_fragment", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "one", "fragment", "1", "frame", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_bot_triple_fragment_single_frame", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_bot_triple_fragment_single_frame", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_bot_triple_fragment_single_frame(self):\n        \"\"\"Test a single-frame image where the frame is three fragments\"\"\"\n        # 1 frame, 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [b'\\x01\\x00\\x00\\x00',\n                          b'\\x02\\x00\\x00\\x00',\n                          b'\\x03\\x00\\x00\\x00']\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_bot_triple_fragment_single_frame", "self", "test", "a", "single", "frame", "image", "where", "the", "frame", "is", "three", "fragments", "1", "frame", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00"], "doc_len": 105}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_multi_frame_one_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_multi_frame_one_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_multi_frame_one_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is one fragment\"\"\"\n        # 3 frames, each 1 fragment long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x18\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [b'\\x01\\x00\\x00\\x00',\n                          b'\\x02\\x00\\x00\\x00',\n                          b'\\x03\\x00\\x00\\x00']\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_multi_frame_one_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "one", "fragment", "3", "frames", "each", "1", "fragment", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0c", "x00", "x00", "x00", "b", "x18", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00"], "doc_len": 116}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_multi_frame_three_to_one", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_multi_frame_three_to_one", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_multi_frame_three_to_one(self):\n        \"\"\"Test a multi-frame image where each frame is three fragments\"\"\"\n        # 2 frames, each 3 fragments long\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x20\\x00\\x00\\x00' \\\n                     b'\\x40\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [\n            b'\\x01\\x00\\x00\\x00', b'\\x02\\x00\\x00\\x00', b'\\x03\\x00\\x00\\x00',\n            b'\\x02\\x00\\x00\\x00', b'\\x02\\x00\\x00\\x00', b'\\x03\\x00\\x00\\x00',\n            b'\\x03\\x00\\x00\\x00', b'\\x02\\x00\\x00\\x00', b'\\x03\\x00\\x00\\x00'\n        ]\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_multi_frame_three_to_one", "self", "test", "a", "multi", "frame", "image", "where", "each", "frame", "is", "three", "fragments", "2", "frames", "each", "3", "fragments", "long", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x20", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00"], "doc_len": 218}
{"doc_id": "pydicom/tests/test_encaps.py::TestDecodeDataSequence.test_multi_frame_varied_ratio", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDecodeDataSequence", "func_name": "test_multi_frame_varied_ratio", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDecodeDataSequence\n    def test_multi_frame_varied_ratio(self):\n        \"\"\"Test a multi-frame image where each frames is random fragments\"\"\"\n        # 3 frames, 1st is 1 fragment, 2nd is 3 fragments, 3rd is 2 fragments\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x0C\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\x0E\\x00\\x00\\x00' \\\n                     b'\\x32\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x01' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x02' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00\\x03\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x02\\x00\\x00\\x00\\x02\\x04'\n        frames = decode_data_sequence(bytestream)\n        assert frames == [\n            b'\\x01\\x00\\x00\\x00\\x00\\x01', b'\\x02\\x00', b'\\x02\\x00\\x00\\x00',\n            b'\\x03\\x00\\x00\\x00\\x00\\x02', b'\\x03\\x00\\x00\\x00', b'\\x02\\x04'\n        ]\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdecodedatasequence", "def", "test_multi_frame_varied_ratio", "self", "test", "a", "multi", "frame", "image", "where", "each", "frames", "is", "random", "fragments", "3", "frames", "1st", "is", "1", "fragment", "2nd", "is", "3", "fragments", "3rd", "is", "2", "fragments", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x0c", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "x0e", "x00", "x00", "x00", "b", "x32", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x01", "x00", "x00", "x00", "x00", "x01", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "x00", "x02", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "x02", "x04", "frames", "decode_data_sequence", "bytestream", "assert", "frames", "b", "x01", "x00", "x00", "x00", "x00", "x01", "b", "x02", "x00", "b", "x02", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "x00", "x02", "b", "x03", "x00", "x00", "x00", "b", "x02", "x04"], "doc_len": 178}
{"doc_id": "pydicom/tests/test_encaps.py::TestDefragmentData.test_defragment", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestDefragmentData", "func_name": "test_defragment", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestDefragmentData\n    def test_defragment(self):\n        \"\"\"Test joining fragmented data works\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x03\\x00\\x00\\x00'\n        reference = b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n        assert defragment_data(bytestream) == reference\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testdefragmentdata", "def", "test_defragment", "self", "test", "joining", "fragmented", "data", "works", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x03", "x00", "x00", "x00", "reference", "b", "x01", "x00", "x00", "x00", "x02", "x00", "x00", "x00", "x03", "x00", "x00", "x00", "assert", "defragment_data", "bytestream", "reference"], "doc_len": 92}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_item_undefined_length", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_item_undefined_length", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_item_undefined_length(self):\n        \"\"\"Test exception raised if item length undefined.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\xFF\\xFF\\xFF\\xFF' \\\n                     b'\\x00\\x00\\x00\\x01'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        with pytest.raises(ValueError,\n                           match=\"Encapsulated data fragment had Undefined \"\n                                 \"Length at data position 0x4\"):\n            read_item(fp)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_item_undefined_length", "self", "test", "exception", "raised", "if", "item", "length", "undefined", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "xff", "xff", "xff", "xff", "b", "x00", "x00", "x00", "x01", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "with", "pytest", "raises", "valueerror", "match", "encapsulated", "data", "fragment", "had", "undefined", "length", "at", "data", "position", "0x4", "read_item", "fp"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_item_sequence_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_item_sequence_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_item_sequence_delimiter(self):\n        \"\"\"Test non-zero length seq delimiter reads correctly.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\xDD\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n        assert read_item(fp) is None\n        assert read_item(fp) == b'\\x02\\x00\\x00\\x00'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_item_sequence_delimiter", "self", "test", "non", "zero", "length", "seq", "delimiter", "reads", "correctly", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "xdd", "xe0", "b", "x04", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00", "assert", "read_item", "fp", "is", "none", "assert", "read_item", "fp", "b", "x02", "x00", "x00", "x00"], "doc_len": 84}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_item_sequence_delimiter_zero_length", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_item_sequence_delimiter_zero_length", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_item_sequence_delimiter_zero_length(self):\n        \"\"\"Test that the fragments are returned if seq delimiter hit.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\xDD\\xE0' \\\n                     b'\\x00\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n        assert read_item(fp) is None\n        assert read_item(fp) == b'\\x02\\x00\\x00\\x00'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_item_sequence_delimiter_zero_length", "self", "test", "that", "the", "fragments", "are", "returned", "if", "seq", "delimiter", "hit", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "xdd", "xe0", "b", "x00", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00", "assert", "read_item", "fp", "is", "none", "assert", "read_item", "fp", "b", "x02", "x00", "x00", "x00"], "doc_len": 86}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_item_bad_tag", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_item_bad_tag", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_item_bad_tag(self):\n        \"\"\"Test item is read if it has an unexpected tag\"\"\"\n        # This should raise an exception instead\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\x10\\x00\\x10\\x00' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\xFF\\x00\\xFF\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x02\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n        assert read_item(fp) == b'\\xFF\\x00\\xFF\\x00'\n        assert read_item(fp) == b'\\x02\\x00\\x00\\x00'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_item_bad_tag", "self", "test", "item", "is", "read", "if", "it", "has", "an", "unexpected", "tag", "this", "should", "raise", "an", "exception", "instead", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "x10", "x00", "x10", "x00", "b", "x04", "x00", "x00", "x00", "b", "xff", "x00", "xff", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x02", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00", "assert", "read_item", "fp", "b", "xff", "x00", "xff", "x00", "assert", "read_item", "fp", "b", "x02", "x00", "x00", "x00"], "doc_len": 100}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_single_fragment_no_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_single_fragment_no_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_single_fragment_no_delimiter(self):\n        \"\"\"Test single fragment is returned OK\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_single_fragment_no_delimiter", "self", "test", "single", "fragment", "is", "returned", "ok", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_multi_fragments_no_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_multi_fragments_no_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_multi_fragments_no_delimiter(self):\n        \"\"\"Test multi fragments are returned OK\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n        assert read_item(fp) == b'\\x01\\x02\\x03\\x04\\x05\\x06'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_multi_fragments_no_delimiter", "self", "test", "multi", "fragments", "are", "returned", "ok", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00", "assert", "read_item", "fp", "b", "x01", "x02", "x03", "x04", "x05", "x06"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_single_fragment_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_single_fragment_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_single_fragment_delimiter(self):\n        \"\"\"Test single fragment is returned OK with sequence delimiter item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\xDD\\xE0'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_single_fragment_delimiter", "self", "test", "single", "fragment", "is", "returned", "ok", "with", "sequence", "delimiter", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "xdd", "xe0", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_encaps.py::TestReadItem.test_multi_fragments_delimiter", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestReadItem", "func_name": "test_multi_fragments_delimiter", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestReadItem\n    def test_multi_fragments_delimiter(self):\n        \"\"\"Test multi fragments are returned OK with sequence delimiter item\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x04\\x00\\x00\\x00' \\\n                     b'\\x01\\x00\\x00\\x00' \\\n                     b'\\xFE\\xFF\\x00\\xE0' \\\n                     b'\\x06\\x00\\x00\\x00' \\\n                     b'\\x01\\x02\\x03\\x04\\x05\\x06' \\\n                     b'\\xFE\\xFF\\xDD\\xE0'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert read_item(fp) == b'\\x01\\x00\\x00\\x00'\n        assert read_item(fp) == b'\\x01\\x02\\x03\\x04\\x05\\x06'\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testreaditem", "def", "test_multi_fragments_delimiter", "self", "test", "multi", "fragments", "are", "returned", "ok", "with", "sequence", "delimiter", "item", "bytestream", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "x01", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe0", "b", "x06", "x00", "x00", "x00", "b", "x01", "x02", "x03", "x04", "x05", "x06", "b", "xfe", "xff", "xdd", "xe0", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "read_item", "fp", "b", "x01", "x00", "x00", "x00", "assert", "read_item", "fp", "b", "x01", "x02", "x03", "x04", "x05", "x06"], "doc_len": 80}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_single_fragment_even_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_single_fragment_even_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_single_fragment_even_data(self):\n        \"\"\"Test 1 fragment from even data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE1'\n        fragments = fragment_frame(bytestream, nr_fragments=1)\n        fragment = next(fragments)\n        assert pytest.raises(StopIteration, next, fragments)\n        assert fragment == bytestream\n        assert len(fragment) == 4\n\n        assert isinstance(fragment, bytes)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_single_fragment_even_data", "self", "test", "1", "fragment", "from", "even", "data", "bytestream", "b", "xfe", "xff", "x00", "xe1", "fragments", "fragment_frame", "bytestream", "nr_fragments", "1", "fragment", "next", "fragments", "assert", "pytest", "raises", "stopiteration", "next", "fragments", "assert", "fragment", "bytestream", "assert", "len", "fragment", "4", "assert", "isinstance", "fragment", "bytes"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_single_fragment_odd_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_single_fragment_odd_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_single_fragment_odd_data(self):\n        \"\"\"Test 1 fragment from odd data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00'\n        fragments = fragment_frame(bytestream, nr_fragments=1)\n        fragment = next(fragments)\n        assert pytest.raises(StopIteration, next, fragments)\n        assert fragment == bytestream + b'\\x00'\n        assert len(fragment) == 4\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_single_fragment_odd_data", "self", "test", "1", "fragment", "from", "odd", "data", "bytestream", "b", "xfe", "xff", "x00", "fragments", "fragment_frame", "bytestream", "nr_fragments", "1", "fragment", "next", "fragments", "assert", "pytest", "raises", "stopiteration", "next", "fragments", "assert", "fragment", "bytestream", "b", "x00", "assert", "len", "fragment", "4"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_even_fragment_even_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_even_fragment_even_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_even_fragment_even_data(self):\n        \"\"\"Test even fragments from even data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE1'\n        # Each fragment should be 2 bytes\n        fragments = fragment_frame(bytestream, nr_fragments=2)\n        fragment = next(fragments)\n        assert fragment == bytestream[:2]\n        fragment = next(fragments)\n        assert fragment == bytestream[2:]\n        assert pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_even_fragment_even_data", "self", "test", "even", "fragments", "from", "even", "data", "bytestream", "b", "xfe", "xff", "x00", "xe1", "each", "fragment", "should", "be", "2", "bytes", "fragments", "fragment_frame", "bytestream", "nr_fragments", "2", "fragment", "next", "fragments", "assert", "fragment", "bytestream", "2", "fragment", "next", "fragments", "assert", "fragment", "bytestream", "2", "assert", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_even_fragment_odd_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_even_fragment_odd_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_even_fragment_odd_data(self):\n        \"\"\"Test even fragments from odd data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00'\n        # First fragment should be 1.5 -> 2 bytes, with the final\n        #   fragment 1 byte + 1 byte padding\n        fragments = fragment_frame(bytestream, nr_fragments=2)\n        fragment = next(fragments)\n        assert fragment == b'\\xFE\\xFF'\n        fragment = next(fragments)\n        assert fragment == b'\\x00\\x00'\n        assert pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_even_fragment_odd_data", "self", "test", "even", "fragments", "from", "odd", "data", "bytestream", "b", "xfe", "xff", "x00", "first", "fragment", "should", "be", "1", "5", "2", "bytes", "with", "the", "final", "fragment", "1", "byte", "1", "byte", "padding", "fragments", "fragment_frame", "bytestream", "nr_fragments", "2", "fragment", "next", "fragments", "assert", "fragment", "b", "xfe", "xff", "fragment", "next", "fragments", "assert", "fragment", "b", "x00", "x00", "assert", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_odd_fragments_even_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_odd_fragments_even_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_odd_fragments_even_data(self):\n        \"\"\"Test odd fragments from even data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE1' * 31  # 124 bytes\n        assert len(bytestream) % 2 == 0\n        # Each fragment should be 17.7 -> 18 bytes, with the final\n        #   fragment 16 bytes\n        fragments = fragment_frame(bytestream, nr_fragments=7)\n        for ii in range(6):\n            fragment = next(fragments)\n            assert len(fragment) == 18\n\n        fragment = next(fragments)\n        assert len(fragment) == 16\n        assert pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_odd_fragments_even_data", "self", "test", "odd", "fragments", "from", "even", "data", "bytestream", "b", "xfe", "xff", "x00", "xe1", "31", "124", "bytes", "assert", "len", "bytestream", "2", "0", "each", "fragment", "should", "be", "17", "7", "18", "bytes", "with", "the", "final", "fragment", "16", "bytes", "fragments", "fragment_frame", "bytestream", "nr_fragments", "7", "for", "ii", "in", "range", "6", "fragment", "next", "fragments", "assert", "len", "fragment", "18", "fragment", "next", "fragments", "assert", "len", "fragment", "16", "assert", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 72}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_odd_fragments_odd_data", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_odd_fragments_odd_data", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_odd_fragments_odd_data(self):\n        \"\"\"Test odd fragments from odd data\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00' * 31  # 93 bytes\n        assert len(bytestream) % 2 == 1\n        # Each fragment should be 13.3 -> 14 bytes, with the final\n        #   fragment 9 bytes + 1 byte padding\n        fragments = fragment_frame(bytestream, nr_fragments=7)\n        for ii in range(6):\n            fragment = next(fragments)\n            assert len(fragment) == 14\n        fragment = next(fragments)\n        assert len(fragment) == 10\n        assert pytest.raises(StopIteration, next, fragments)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_odd_fragments_odd_data", "self", "test", "odd", "fragments", "from", "odd", "data", "bytestream", "b", "xfe", "xff", "x00", "31", "93", "bytes", "assert", "len", "bytestream", "2", "1", "each", "fragment", "should", "be", "13", "3", "14", "bytes", "with", "the", "final", "fragment", "9", "bytes", "1", "byte", "padding", "fragments", "fragment_frame", "bytestream", "nr_fragments", "7", "for", "ii", "in", "range", "6", "fragment", "next", "fragments", "assert", "len", "fragment", "14", "fragment", "next", "fragments", "assert", "len", "fragment", "10", "assert", "pytest", "raises", "stopiteration", "next", "fragments"], "doc_len": 74}
{"doc_id": "pydicom/tests/test_encaps.py::TestFragmentFrame.test_too_many_fragments_raises", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestFragmentFrame", "func_name": "test_too_many_fragments_raises", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestFragmentFrame\n    def test_too_many_fragments_raises(self):\n        \"\"\"Test exception raised if too many fragments.\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00' * 31  # 93 bytes\n        # At most we can have 47 fragments\n        for fragment in fragment_frame(bytestream, nr_fragments=47):\n            pass\n\n        with pytest.raises(ValueError):\n            for fragment in fragment_frame(bytestream, nr_fragments=48):\n                pass\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testfragmentframe", "def", "test_too_many_fragments_raises", "self", "test", "exception", "raised", "if", "too", "many", "fragments", "bytestream", "b", "xfe", "xff", "x00", "31", "93", "bytes", "at", "most", "we", "can", "have", "47", "fragments", "for", "fragment", "in", "fragment_frame", "bytestream", "nr_fragments", "47", "pass", "with", "pytest", "raises", "valueerror", "for", "fragment", "in", "fragment_frame", "bytestream", "nr_fragments", "48", "pass"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_encaps.py::TestEncapsulateFrame.test_single_item", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestEncapsulateFrame", "func_name": "test_single_item", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestEncapsulateFrame\n    def test_single_item(self):\n        \"\"\"Test encapsulating into one fragment\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE1'\n        item_generator = itemise_frame(bytestream, nr_fragments=1)\n        item = next(item_generator)\n\n        assert item == (\n            b'\\xfe\\xff\\x00\\xe0'\n            b'\\x04\\x00\\x00\\x00'\n            b'\\xFE\\xFF\\x00\\xE1'\n        )\n\n        pytest.raises(StopIteration, next, item_generator)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testencapsulateframe", "def", "test_single_item", "self", "test", "encapsulating", "into", "one", "fragment", "bytestream", "b", "xfe", "xff", "x00", "xe1", "item_generator", "itemise_frame", "bytestream", "nr_fragments", "1", "item", "next", "item_generator", "assert", "item", "b", "xfe", "xff", "x00", "xe0", "b", "x04", "x00", "x00", "x00", "b", "xfe", "xff", "x00", "xe1", "pytest", "raises", "stopiteration", "next", "item_generator"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_encaps.py::TestEncapsulateFrame.test_two_items", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestEncapsulateFrame", "func_name": "test_two_items", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestEncapsulateFrame\n    def test_two_items(self):\n        \"\"\"Test encapsulating into two fragments\"\"\"\n        bytestream = b'\\xFE\\xFF\\x00\\xE1'\n        item_generator = itemise_frame(bytestream, nr_fragments=2)\n\n        item = next(item_generator)\n        assert item == (\n            b'\\xfe\\xff\\x00\\xe0'\n            b'\\x02\\x00\\x00\\x00'\n            b'\\xFE\\xFF'\n        )\n\n        item = next(item_generator)\n        assert item == (\n            b'\\xfe\\xff\\x00\\xe0'\n            b'\\x02\\x00\\x00\\x00'\n            b'\\x00\\xe1'\n        )\n\n        pytest.raises(StopIteration, next, item_generator)\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testencapsulateframe", "def", "test_two_items", "self", "test", "encapsulating", "into", "two", "fragments", "bytestream", "b", "xfe", "xff", "x00", "xe1", "item_generator", "itemise_frame", "bytestream", "nr_fragments", "2", "item", "next", "item_generator", "assert", "item", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "b", "xfe", "xff", "item", "next", "item_generator", "assert", "item", "b", "xfe", "xff", "x00", "xe0", "b", "x02", "x00", "x00", "x00", "b", "x00", "xe1", "pytest", "raises", "stopiteration", "next", "item_generator"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_encaps.py::TestEncapsulate.test_encapsulate_single_fragment_per_frame_no_bot", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestEncapsulate", "func_name": "test_encapsulate_single_fragment_per_frame_no_bot", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestEncapsulate\n    def test_encapsulate_single_fragment_per_frame_no_bot(self):\n        \"\"\"Test encapsulating single fragment per frame with no BOT values.\"\"\"\n        ds = dcmread(JP2K_10FRAME_NOBOT)\n        frames = decode_data_sequence(ds.PixelData)\n        assert len(frames) == 10\n\n        data = encapsulate(frames, fragments_per_frame=1, has_bot=False)\n        test_frames = decode_data_sequence(data)\n        for a, b in zip(test_frames, frames):\n            assert a == b\n\n        # Original data has no BOT values\n        assert data == ds.PixelData\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testencapsulate", "def", "test_encapsulate_single_fragment_per_frame_no_bot", "self", "test", "encapsulating", "single", "fragment", "per", "frame", "with", "no", "bot", "values", "ds", "dcmread", "jp2k_10frame_nobot", "frames", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "frames", "10", "data", "encapsulate", "frames", "fragments_per_frame", "1", "has_bot", "false", "test_frames", "decode_data_sequence", "data", "for", "a", "b", "in", "zip", "test_frames", "frames", "assert", "a", "b", "original", "data", "has", "no", "bot", "values", "assert", "data", "ds", "pixeldata"], "doc_len": 59}
{"doc_id": "pydicom/tests/test_encaps.py::TestEncapsulate.test_encapsulate_single_fragment_per_frame_bot", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestEncapsulate", "func_name": "test_encapsulate_single_fragment_per_frame_bot", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestEncapsulate\n    def test_encapsulate_single_fragment_per_frame_bot(self):\n        \"\"\"Test encapsulating single fragment per frame with BOT values.\"\"\"\n        ds = dcmread(JP2K_10FRAME_NOBOT)\n        frames = decode_data_sequence(ds.PixelData)\n        assert len(frames) == 10\n\n        data = encapsulate(frames, fragments_per_frame=1, has_bot=True)\n        test_frames = decode_data_sequence(data)\n        for a, b in zip(test_frames, frames):\n            assert a == b\n\n        fp = DicomBytesIO(data)\n        fp.is_little_endian = True\n        offsets = get_frame_offsets(fp)\n        assert offsets == [\n            0x0000,  # 0\n            0x0eee,  # 3822\n            0x1df6,  # 7670\n            0x2cf8,  # 11512\n            0x3bfc,  # 15356\n            0x4ade,  # 19166\n            0x59a2,  # 22946\n            0x6834,  # 26676\n            0x76e2,  # 30434\n            0x8594  # 34196\n        ]\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testencapsulate", "def", "test_encapsulate_single_fragment_per_frame_bot", "self", "test", "encapsulating", "single", "fragment", "per", "frame", "with", "bot", "values", "ds", "dcmread", "jp2k_10frame_nobot", "frames", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "frames", "10", "data", "encapsulate", "frames", "fragments_per_frame", "1", "has_bot", "true", "test_frames", "decode_data_sequence", "data", "for", "a", "b", "in", "zip", "test_frames", "frames", "assert", "a", "b", "fp", "dicombytesio", "data", "fp", "is_little_endian", "true", "offsets", "get_frame_offsets", "fp", "assert", "offsets", "0x0000", "0", "0x0eee", "3822", "0x1df6", "7670", "0x2cf8", "11512", "0x3bfc", "15356", "0x4ade", "19166", "0x59a2", "22946", "0x6834", "26676", "0x76e2", "30434", "0x8594", "34196"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_encaps.py::TestEncapsulate.test_encapsulate_bot", "file_path": "pydicom/tests/test_encaps.py", "class_name": "TestEncapsulate", "func_name": "test_encapsulate_bot", "text": "文件路径: pydicom/tests/test_encaps.py, 类名: TestEncapsulate\n    def test_encapsulate_bot(self):\n        \"\"\"Test the Basic Offset Table is correct.\"\"\"\n        ds = dcmread(JP2K_10FRAME_NOBOT)\n        frames = decode_data_sequence(ds.PixelData)\n        assert len(frames) == 10\n\n        data = encapsulate(frames, fragments_per_frame=1, has_bot=True)\n        assert data[:56] == (\n            b'\\xfe\\xff\\x00\\xe0'  # Basic offset table item tag\n            b'\\x28\\x00\\x00\\x00'  # Basic offset table length\n            b'\\x00\\x00\\x00\\x00'  # First offset\n            b'\\xee\\x0e\\x00\\x00'\n            b'\\xf6\\x1d\\x00\\x00'\n            b'\\xf8\\x2c\\x00\\x00'\n            b'\\xfc\\x3b\\x00\\x00'\n            b'\\xde\\x4a\\x00\\x00'\n            b'\\xa2\\x59\\x00\\x00'\n            b'\\x34\\x68\\x00\\x00'\n            b'\\xe2\\x76\\x00\\x00'\n            b'\\x94\\x85\\x00\\x00'  # Last offset\n            b'\\xfe\\xff\\x00\\xe0'  # Next item tag\n            b'\\xe6\\x0e\\x00\\x00'  # Next item length\n        )\n", "tokens": ["pydicom", "tests", "test_encaps", "py", "testencapsulate", "def", "test_encapsulate_bot", "self", "test", "the", "basic", "offset", "table", "is", "correct", "ds", "dcmread", "jp2k_10frame_nobot", "frames", "decode_data_sequence", "ds", "pixeldata", "assert", "len", "frames", "10", "data", "encapsulate", "frames", "fragments_per_frame", "1", "has_bot", "true", "assert", "data", "56", "b", "xfe", "xff", "x00", "xe0", "basic", "offset", "table", "item", "tag", "b", "x28", "x00", "x00", "x00", "basic", "offset", "table", "length", "b", "x00", "x00", "x00", "x00", "first", "offset", "b", "xee", "x0e", "x00", "x00", "b", "xf6", "x1d", "x00", "x00", "b", "xf8", "x2c", "x00", "x00", "b", "xfc", "x3b", "x00", "x00", "b", "xde", "x4a", "x00", "x00", "b", "xa2", "x59", "x00", "x00", "b", "x34", "x68", "x00", "x00", "b", "xe2", "x76", "x00", "x00", "b", "x94", "x85", "x00", "x00", "last", "offset", "b", "xfe", "xff", "x00", "xe0", "next", "item", "tag", "b", "xe6", "x0e", "x00", "x00", "next", "item", "length"], "doc_len": 125}
{"doc_id": "pydicom/tests/test_environment.py::get_envar", "file_path": "pydicom/tests/test_environment.py", "class_name": null, "func_name": "get_envar", "text": "文件路径: pydicom/tests/test_environment.py\ndef get_envar(envar):\n    \"\"\"Return the value of the environmental variable `envar`.\n\n    Parameters\n    ----------\n    envar : str\n        The environmental variable to check for.\n\n    Returns\n    -------\n    str or None\n        If the envar is present then return its value otherwise returns None.\n    \"\"\"\n    if envar in os.environ:\n        return os.environ.get(envar)\n\n    return None\n", "tokens": ["pydicom", "tests", "test_environment", "py", "def", "get_envar", "envar", "return", "the", "value", "of", "the", "environmental", "variable", "envar", "parameters", "envar", "str", "the", "environmental", "variable", "to", "check", "for", "returns", "str", "or", "none", "if", "the", "envar", "is", "present", "then", "return", "its", "value", "otherwise", "returns", "none", "if", "envar", "in", "os", "environ", "return", "os", "environ", "get", "envar", "return", "none"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_distribution", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_distribution", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_distribution(self):\n        \"\"\"Test that the distribution is correct.\"\"\"\n        distrib = get_envar('DISTRIB')\n        if not distrib:\n            raise RuntimeError(\"No 'DISTRIB' envar has been set\")\n\n        if distrib == 'conda':\n            # May not be robust\n            assert os.path.exists(os.path.join(sys.prefix, 'conda-meta'))\n            assert \"CPython\" in platform.python_implementation()\n        elif distrib == 'pypy':\n            assert 'PyPy' in platform.python_implementation()\n        elif distrib == 'ubuntu':\n            assert \"CPython\" in platform.python_implementation()\n        else:\n            raise NotImplementedError(\"Unknown 'DISTRIB' value\")\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_distribution", "self", "test", "that", "the", "distribution", "is", "correct", "distrib", "get_envar", "distrib", "if", "not", "distrib", "raise", "runtimeerror", "no", "distrib", "envar", "has", "been", "set", "if", "distrib", "conda", "may", "not", "be", "robust", "assert", "os", "path", "exists", "os", "path", "join", "sys", "prefix", "conda", "meta", "assert", "cpython", "in", "platform", "python_implementation", "elif", "distrib", "pypy", "assert", "pypy", "in", "platform", "python_implementation", "elif", "distrib", "ubuntu", "assert", "cpython", "in", "platform", "python_implementation", "else", "raise", "notimplementederror", "unknown", "distrib", "value"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_python_version", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_python_version", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_python_version(self):\n        \"\"\"Test that the python version is correct.\"\"\"\n        version = get_envar('PYTHON_VERSION')\n        if not version:\n            raise RuntimeError(\"No 'PYTHON_VERSION' envar has been set\")\n\n        version = tuple([int(vv) for vv in version.split('.')])\n        assert version == sys.version_info[:2]\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_python_version", "self", "test", "that", "the", "python", "version", "is", "correct", "version", "get_envar", "python_version", "if", "not", "version", "raise", "runtimeerror", "no", "python_version", "envar", "has", "been", "set", "version", "tuple", "int", "vv", "for", "vv", "in", "version", "split", "assert", "version", "sys", "version_info", "2"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_numpy", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_numpy", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_numpy(self):\n        \"\"\"Test that numpy is absent/present.\"\"\"\n        have_np = get_envar('NUMPY')\n        if not have_np:\n            raise RuntimeError(\"No 'NUMPY' envar has been set\")\n\n        if have_np == 'true':\n            try:\n                import numpy\n            except ImportError:\n                pytest.fail(\"NUMPY is true but numpy is not importable\")\n        elif have_np == 'false':\n            with pytest.raises(ImportError):\n                import numpy\n        else:\n            raise NotImplementedError(\n                \"Unknown 'NUMPY' value of '{}'\".format(have_np)\n            )\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_numpy", "self", "test", "that", "numpy", "is", "absent", "present", "have_np", "get_envar", "numpy", "if", "not", "have_np", "raise", "runtimeerror", "no", "numpy", "envar", "has", "been", "set", "if", "have_np", "true", "try", "import", "numpy", "except", "importerror", "pytest", "fail", "numpy", "is", "true", "but", "numpy", "is", "not", "importable", "elif", "have_np", "false", "with", "pytest", "raises", "importerror", "import", "numpy", "else", "raise", "notimplementederror", "unknown", "numpy", "value", "of", "format", "have_np"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_pillow", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_pillow", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_pillow(self):\n        \"\"\"Test that pillow is absent/present with the correct plugins.\"\"\"\n        have_pillow = get_envar('PILLOW')\n        if not have_pillow:\n            raise RuntimeError(\"No 'PILLOW' envar has been set\")\n\n        if have_pillow == 'both':\n            try:\n                from PIL import _imaging\n            except ImportError:\n                pytest.fail(\"PILLOW is both but PIL is not importable\")\n\n            assert getattr(_imaging, \"jpeg_decoder\", False)\n            assert getattr(_imaging, \"jpeg2k_decoder\", False)\n        elif have_pillow == 'jpeg':\n            try:\n                from PIL import _imaging\n            except ImportError:\n                pytest.fail(\"PILLOW is both but PIL is not importable\")\n\n            assert getattr(_imaging, \"jpeg_decoder\", False)\n            assert not getattr(_imaging, \"jpeg2k_decoder\", False)\n        elif have_pillow == 'false':\n            with pytest.raises(ImportError):\n                import PIL\n        else:\n            raise NotImplementedError(\n                \"Unknown 'PILLOW' value of '{}'\".format(have_pillow)\n            )\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_pillow", "self", "test", "that", "pillow", "is", "absent", "present", "with", "the", "correct", "plugins", "have_pillow", "get_envar", "pillow", "if", "not", "have_pillow", "raise", "runtimeerror", "no", "pillow", "envar", "has", "been", "set", "if", "have_pillow", "both", "try", "from", "pil", "import", "_imaging", "except", "importerror", "pytest", "fail", "pillow", "is", "both", "but", "pil", "is", "not", "importable", "assert", "getattr", "_imaging", "jpeg_decoder", "false", "assert", "getattr", "_imaging", "jpeg2k_decoder", "false", "elif", "have_pillow", "jpeg", "try", "from", "pil", "import", "_imaging", "except", "importerror", "pytest", "fail", "pillow", "is", "both", "but", "pil", "is", "not", "importable", "assert", "getattr", "_imaging", "jpeg_decoder", "false", "assert", "not", "getattr", "_imaging", "jpeg2k_decoder", "false", "elif", "have_pillow", "false", "with", "pytest", "raises", "importerror", "import", "pil", "else", "raise", "notimplementederror", "unknown", "pillow", "value", "of", "format", "have_pillow"], "doc_len": 111}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_jpegls", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_jpegls", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_jpegls(self):\n        \"\"\"Test that jpeg-ls is absent/present.\"\"\"\n        have_jpegls = get_envar('JPEG_LS')\n        if not have_jpegls:\n            raise RuntimeError(\"No 'JPEG_LS' envar has been set\")\n\n        if have_jpegls == 'true':\n            try:\n                import jpeg_ls\n            except ImportError:\n                pytest.fail(\"JPEG_LS is true but jpeg_ls is not importable\")\n        elif have_jpegls == 'false':\n            with pytest.raises(ImportError):\n                import jpeg_ls\n        else:\n            raise NotImplementedError(\n                \"Unknown 'JPEG_LS' value of '{}'\".format(have_jpegls)\n            )\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_jpegls", "self", "test", "that", "jpeg", "ls", "is", "absent", "present", "have_jpegls", "get_envar", "jpeg_ls", "if", "not", "have_jpegls", "raise", "runtimeerror", "no", "jpeg_ls", "envar", "has", "been", "set", "if", "have_jpegls", "true", "try", "import", "jpeg_ls", "except", "importerror", "pytest", "fail", "jpeg_ls", "is", "true", "but", "jpeg_ls", "is", "not", "importable", "elif", "have_jpegls", "false", "with", "pytest", "raises", "importerror", "import", "jpeg_ls", "else", "raise", "notimplementederror", "unknown", "jpeg_ls", "value", "of", "format", "have_jpegls"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_environment.py::TestBuilds.test_gdcm", "file_path": "pydicom/tests/test_environment.py", "class_name": "TestBuilds", "func_name": "test_gdcm", "text": "文件路径: pydicom/tests/test_environment.py, 类名: TestBuilds\n    def test_gdcm(self):\n        \"\"\"Test that gdcm is absent/present.\"\"\"\n        have_gdcm = get_envar('GDCM')\n        if not have_gdcm:\n            raise RuntimeError(\"No 'GDCM' envar has been set\")\n\n        if have_gdcm == 'true':\n            try:\n                import gdcm\n            except ImportError:\n                pytest.fail(\"GDCM is true but gdcm is not importable\")\n        elif have_gdcm == 'false':\n            with pytest.raises(ImportError):\n                import gdcm\n        elif have_gdcm == 'old':\n            try:\n                import gdcm\n            except ImportError:\n                pytest.fail(\"GDCM is 'old' but gdcm is not importable\")\n            assert gdcm.Version_GetVersion() == '2.8.4'\n        else:\n            raise NotImplementedError(\n                \"Unknown 'GDCM' value of '{}'\".format(have_gdcm)\n            )\n", "tokens": ["pydicom", "tests", "test_environment", "py", "testbuilds", "def", "test_gdcm", "self", "test", "that", "gdcm", "is", "absent", "present", "have_gdcm", "get_envar", "gdcm", "if", "not", "have_gdcm", "raise", "runtimeerror", "no", "gdcm", "envar", "has", "been", "set", "if", "have_gdcm", "true", "try", "import", "gdcm", "except", "importerror", "pytest", "fail", "gdcm", "is", "true", "but", "gdcm", "is", "not", "importable", "elif", "have_gdcm", "false", "with", "pytest", "raises", "importerror", "import", "gdcm", "elif", "have_gdcm", "old", "try", "import", "gdcm", "except", "importerror", "pytest", "fail", "gdcm", "is", "old", "but", "gdcm", "is", "not", "importable", "assert", "gdcm", "version_getversion", "2", "8", "4", "else", "raise", "notimplementederror", "unknown", "gdcm", "value", "of", "format", "have_gdcm"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_errors.py::test_message", "file_path": "pydicom/tests/test_errors.py", "class_name": null, "func_name": "test_message", "text": "文件路径: pydicom/tests/test_errors.py\ndef test_message():\n    \"\"\"Test InvalidDicomError with a message\"\"\"\n\n    def _test():\n        raise InvalidDicomError('test msg')\n    with pytest.raises(InvalidDicomError, match='test msg'):\n        _test()\n", "tokens": ["pydicom", "tests", "test_errors", "py", "def", "test_message", "test", "invaliddicomerror", "with", "a", "message", "def", "_test", "raise", "invaliddicomerror", "test", "msg", "with", "pytest", "raises", "invaliddicomerror", "match", "test", "msg", "_test"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_errors.py::test_no_message", "file_path": "pydicom/tests/test_errors.py", "class_name": null, "func_name": "test_no_message", "text": "文件路径: pydicom/tests/test_errors.py\ndef test_no_message():\n    \"\"\"Test InvalidDicomError with no message\"\"\"\n\n    def _test():\n        raise InvalidDicomError\n    with pytest.raises(InvalidDicomError,\n                       match='The specified file is not a valid DICOM '\n                             'file.'):\n        _test()\n", "tokens": ["pydicom", "tests", "test_errors", "py", "def", "test_no_message", "test", "invaliddicomerror", "with", "no", "message", "def", "_test", "raise", "invaliddicomerror", "with", "pytest", "raises", "invaliddicomerror", "match", "the", "specified", "file", "is", "not", "a", "valid", "dicom", "file", "_test"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_init", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_init", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_init(self):\n        \"\"\"Test __init__\"\"\"\n        # All the subclasses override this anyway\n        fp = DicomIO()\n        assert fp.is_implicit_VR\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_init", "self", "test", "__init__", "all", "the", "subclasses", "override", "this", "anyway", "fp", "dicomio", "assert", "fp", "is_implicit_vr"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_le_tag", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_le_tag", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_le_tag(self):\n        \"\"\"Test DicomIO.read_le_tag indirectly\"\"\"\n        # Tags are 2 + 2 = 4 bytes\n        bytestream = b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert Tag(fp.read_le_tag()) == 0x02010403\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_le_tag", "self", "test", "dicomio", "read_le_tag", "indirectly", "tags", "are", "2", "2", "4", "bytes", "bytestream", "b", "x01", "x02", "x03", "x04", "x05", "x06", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "tag", "fp", "read_le_tag", "0x02010403"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_be_tag", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_be_tag", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_be_tag(self):\n        \"\"\"Test DicomIO.read_be_tag indirectly\"\"\"\n        # Tags are 2 + 2 = 4 bytes\n        bytestream = b'\\x01\\x02\\x03\\x04\\x05\\x06'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = False\n        assert Tag(fp.read_be_tag()) == 0x01020304\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_be_tag", "self", "test", "dicomio", "read_be_tag", "indirectly", "tags", "are", "2", "2", "4", "bytes", "bytestream", "b", "x01", "x02", "x03", "x04", "x05", "x06", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "false", "assert", "tag", "fp", "read_be_tag", "0x01020304"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_write_tag", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_write_tag", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_write_tag(self):\n        \"\"\"Test DicomIO.write_tag indirectly\"\"\"\n        tag = Tag(0x01020304)\n\n        # Little endian\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        fp.write_tag(tag)\n        assert fp.getvalue() == b'\\x02\\x01\\x04\\x03'\n\n        # Big endian\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        fp.write_tag(tag)\n        assert fp.getvalue() == b'\\x01\\x02\\x03\\x04'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_write_tag", "self", "test", "dicomio", "write_tag", "indirectly", "tag", "tag", "0x01020304", "little", "endian", "fp", "dicombytesio", "fp", "is_little_endian", "true", "fp", "write_tag", "tag", "assert", "fp", "getvalue", "b", "x02", "x01", "x04", "x03", "big", "endian", "fp", "dicombytesio", "fp", "is_little_endian", "false", "fp", "write_tag", "tag", "assert", "fp", "getvalue", "b", "x01", "x02", "x03", "x04"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_le_us", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_le_us", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_le_us(self):\n        \"\"\"Test DicomIO.read_leUS indirectly\"\"\"\n        # US are 2 bytes fixed\n        bytestream = b'\\x00\\x00\\xFF\\x00\\xFE\\xFF'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert fp.read_leUS() == 0\n        assert fp.read_leUS() == 255\n        assert fp.read_leUS() == 65534\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_le_us", "self", "test", "dicomio", "read_leus", "indirectly", "us", "are", "2", "bytes", "fixed", "bytestream", "b", "x00", "x00", "xff", "x00", "xfe", "xff", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "fp", "read_leus", "0", "assert", "fp", "read_leus", "255", "assert", "fp", "read_leus", "65534"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_be_us", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_be_us", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_be_us(self):\n        \"\"\"Test DicomIO.read_beUS indirectly\"\"\"\n        # US are 2 bytes fixed\n        bytestream = b'\\x00\\x00\\x00\\xFF\\xFF\\xFE'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert fp.read_beUS() == 0\n        assert fp.read_beUS() == 255\n        assert fp.read_beUS() == 0xFFFE\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_be_us", "self", "test", "dicomio", "read_beus", "indirectly", "us", "are", "2", "bytes", "fixed", "bytestream", "b", "x00", "x00", "x00", "xff", "xff", "xfe", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "fp", "read_beus", "0", "assert", "fp", "read_beus", "255", "assert", "fp", "read_beus", "0xfffe"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_write_le_us", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_write_le_us", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_write_le_us(self):\n        \"\"\"Test DicomIO.write_leUS indirectly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        assert fp.getvalue() == b''\n        fp.write_leUS(0)\n        assert fp.getvalue() == b'\\x00\\x00'\n        fp.write_leUS(255)\n        assert fp.getvalue() == b'\\x00\\x00\\xFF\\x00'\n        fp.write_leUS(65534)\n        assert fp.getvalue() == b'\\x00\\x00\\xFF\\x00\\xFE\\xFF'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_write_le_us", "self", "test", "dicomio", "write_leus", "indirectly", "fp", "dicombytesio", "fp", "is_little_endian", "true", "assert", "fp", "getvalue", "b", "fp", "write_leus", "0", "assert", "fp", "getvalue", "b", "x00", "x00", "fp", "write_leus", "255", "assert", "fp", "getvalue", "b", "x00", "x00", "xff", "x00", "fp", "write_leus", "65534", "assert", "fp", "getvalue", "b", "x00", "x00", "xff", "x00", "xfe", "xff"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_write_be_us", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_write_be_us", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_write_be_us(self):\n        \"\"\"Test DicomIO.write_beUS indirectly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        assert fp.getvalue() == b''\n        fp.write_beUS(0)\n        assert fp.getvalue() == b'\\x00\\x00'\n        fp.write_beUS(255)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\xFF'\n        fp.write_beUS(65534)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\xFF\\xFF\\xFE'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_write_be_us", "self", "test", "dicomio", "write_beus", "indirectly", "fp", "dicombytesio", "fp", "is_little_endian", "false", "assert", "fp", "getvalue", "b", "fp", "write_beus", "0", "assert", "fp", "getvalue", "b", "x00", "x00", "fp", "write_beus", "255", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "xff", "fp", "write_beus", "65534", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "xff", "xff", "xfe"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_le_ul", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_le_ul", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_le_ul(self):\n        \"\"\"Test DicomIO.read_leUL indirectly\"\"\"\n        # UL are 4 bytes fixed\n        bytestream = b'\\x00\\x00\\x00\\x00\\xFF\\xFF\\x00\\x00\\xFE\\xFF\\xFF\\xFF'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = True\n        assert fp.read_leUL() == 0\n        assert fp.read_leUL() == 0xFFFF\n        assert fp.read_leUL() == 0xFFFFFFFE\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_le_ul", "self", "test", "dicomio", "read_leul", "indirectly", "ul", "are", "4", "bytes", "fixed", "bytestream", "b", "x00", "x00", "x00", "x00", "xff", "xff", "x00", "x00", "xfe", "xff", "xff", "xff", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "true", "assert", "fp", "read_leul", "0", "assert", "fp", "read_leul", "0xffff", "assert", "fp", "read_leul", "0xfffffffe"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_be_ul", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_be_ul", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_be_ul(self):\n        \"\"\"Test DicomIO.read_beUL indirectly\"\"\"\n        # UL are 4 bytes fixed\n        bytestream = b'\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE'\n        fp = DicomBytesIO(bytestream)\n        fp.is_little_endian = False\n        assert fp.read_beUL() == 0\n        assert fp.read_beUL() == 0xFFFF\n        assert fp.read_beUL() == 0xFFFFFFFE\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_be_ul", "self", "test", "dicomio", "read_beul", "indirectly", "ul", "are", "4", "bytes", "fixed", "bytestream", "b", "x00", "x00", "x00", "x00", "x00", "x00", "xff", "xff", "xff", "xff", "xff", "xfe", "fp", "dicombytesio", "bytestream", "fp", "is_little_endian", "false", "assert", "fp", "read_beul", "0", "assert", "fp", "read_beul", "0xffff", "assert", "fp", "read_beul", "0xfffffffe"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_write_le_ul", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_write_le_ul", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_write_le_ul(self):\n        \"\"\"Test DicomIO.write_leUL indirectly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        assert fp.getvalue() == b''\n        fp.write_leUL(0)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\x00'\n        fp.write_leUL(65535)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\x00\\xFF\\xFF\\x00\\x00'\n        fp.write_leUL(4294967294)\n        assert fp.getvalue() == (\n            b'\\x00\\x00\\x00\\x00\\xFF\\xFF\\x00\\x00\\xFE\\xFF\\xFF\\xFF')\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_write_le_ul", "self", "test", "dicomio", "write_leul", "indirectly", "fp", "dicombytesio", "fp", "is_little_endian", "true", "assert", "fp", "getvalue", "b", "fp", "write_leul", "0", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "fp", "write_leul", "65535", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "xff", "xff", "x00", "x00", "fp", "write_leul", "4294967294", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "xff", "xff", "x00", "x00", "xfe", "xff", "xff", "xff"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_write_be_ul", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_write_be_ul", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_write_be_ul(self):\n        \"\"\"Test DicomIO.write_beUL indirectly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        assert fp.getvalue() == b''\n        fp.write_beUL(0)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\x00'\n        fp.write_beUL(65535)\n        assert fp.getvalue() == b'\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF'\n        fp.write_beUL(4294967294)\n        assert fp.getvalue() == (\n            b'\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE')\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_write_be_ul", "self", "test", "dicomio", "write_beul", "indirectly", "fp", "dicombytesio", "fp", "is_little_endian", "false", "assert", "fp", "getvalue", "b", "fp", "write_beul", "0", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "fp", "write_beul", "65535", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "x00", "x00", "xff", "xff", "fp", "write_beul", "4294967294", "assert", "fp", "getvalue", "b", "x00", "x00", "x00", "x00", "x00", "x00", "xff", "xff", "xff", "xff", "xff", "xfe"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read(self):\n        \"\"\"Test DicomIO.read entire length\"\"\"\n        fp = DicomBytesIO(b'\\x00\\x01\\x03')\n        fp.is_little_endian = True\n        bytestream = fp.read(length=None, need_exact_length=False)\n        assert bytestream == b'\\x00\\x01\\x03'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read", "self", "test", "dicomio", "read", "entire", "length", "fp", "dicombytesio", "b", "x00", "x01", "x03", "fp", "is_little_endian", "true", "bytestream", "fp", "read", "length", "none", "need_exact_length", "false", "assert", "bytestream", "b", "x00", "x01", "x03"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_length", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_length", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_length(self):\n        \"\"\"Test DicomIO.read specific length\"\"\"\n        fp = DicomBytesIO(b'\\x00\\x01\\x03')\n        fp.is_little_endian = True\n        bytestream = fp.read(length=2, need_exact_length=False)\n        assert bytestream == b'\\x00\\x01'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_length", "self", "test", "dicomio", "read", "specific", "length", "fp", "dicombytesio", "b", "x00", "x01", "x03", "fp", "is_little_endian", "true", "bytestream", "fp", "read", "length", "2", "need_exact_length", "false", "assert", "bytestream", "b", "x00", "x01"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_exact_length", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_exact_length", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_exact_length(self):\n        \"\"\"Test DicomIO.read exact length\"\"\"\n        fp = DicomBytesIO(b'\\x00\\x01\\x03\\x04')\n        fp.is_little_endian = True\n        bytestream = fp.read(length=4, need_exact_length=True)\n        assert bytestream == b'\\x00\\x01\\x03\\x04'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_exact_length", "self", "test", "dicomio", "read", "exact", "length", "fp", "dicombytesio", "b", "x00", "x01", "x03", "x04", "fp", "is_little_endian", "true", "bytestream", "fp", "read", "length", "4", "need_exact_length", "true", "assert", "bytestream", "b", "x00", "x01", "x03", "x04"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_read_exact_length_raises", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_read_exact_length_raises", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_read_exact_length_raises(self):\n        \"\"\"Test DicomIO.read exact length raises if short\"\"\"\n        fp = DicomBytesIO(b'\\x00\\x01\\x03')\n        fp.is_little_endian = True\n        with pytest.raises(EOFError,\n                           match=\"Unexpected end of file. Read 3 bytes of 4 \"\n                                 \"expected starting at position 0x0\"):\n            fp.read(length=4, need_exact_length=True)\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_read_exact_length_raises", "self", "test", "dicomio", "read", "exact", "length", "raises", "if", "short", "fp", "dicombytesio", "b", "x00", "x01", "x03", "fp", "is_little_endian", "true", "with", "pytest", "raises", "eoferror", "match", "unexpected", "end", "of", "file", "read", "3", "bytes", "of", "4", "expected", "starting", "at", "position", "0x0", "fp", "read", "length", "4", "need_exact_length", "true"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_getter_is_little_endian", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_getter_is_little_endian", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_getter_is_little_endian(self):\n        \"\"\"Test DicomIO.is_little_endian getter\"\"\"\n        fp = DicomIO()\n        fp.is_little_endian = True\n        assert fp.is_little_endian\n        fp.is_little_endian = False\n        assert not fp.is_little_endian\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_getter_is_little_endian", "self", "test", "dicomio", "is_little_endian", "getter", "fp", "dicomio", "fp", "is_little_endian", "true", "assert", "fp", "is_little_endian", "fp", "is_little_endian", "false", "assert", "not", "fp", "is_little_endian"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_setter_is_little_endian", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_setter_is_little_endian", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_setter_is_little_endian(self):\n        \"\"\"Test DicomIO.is_little_endian setter\"\"\"\n        fp = DicomIO()\n        fp.is_little_endian = True\n        assert fp.read_US == fp.read_leUS\n        assert fp.read_UL == fp.read_leUL\n        assert fp.write_US == fp.write_leUS\n        assert fp.write_UL == fp.write_leUL\n        assert fp.read_tag == fp.read_le_tag\n\n        fp.is_little_endian = False\n        assert fp.read_US == fp.read_beUS\n        assert fp.read_UL == fp.read_beUL\n        assert fp.write_US == fp.write_beUS\n        assert fp.write_UL == fp.write_beUL\n        assert fp.read_tag == fp.read_be_tag\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_setter_is_little_endian", "self", "test", "dicomio", "is_little_endian", "setter", "fp", "dicomio", "fp", "is_little_endian", "true", "assert", "fp", "read_us", "fp", "read_leus", "assert", "fp", "read_ul", "fp", "read_leul", "assert", "fp", "write_us", "fp", "write_leus", "assert", "fp", "write_ul", "fp", "write_leul", "assert", "fp", "read_tag", "fp", "read_le_tag", "fp", "is_little_endian", "false", "assert", "fp", "read_us", "fp", "read_beus", "assert", "fp", "read_ul", "fp", "read_beul", "assert", "fp", "write_us", "fp", "write_beus", "assert", "fp", "write_ul", "fp", "write_beul", "assert", "fp", "read_tag", "fp", "read_be_tag"], "doc_len": 70}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomIO.test_is_implicit_vr", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomIO", "func_name": "test_is_implicit_vr", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomIO\n    def test_is_implicit_vr(self):\n        \"\"\"Test DicomIO.is_implicit_VR\"\"\"\n        fp = DicomIO()\n        fp.is_implicit_VR = True\n        assert fp.is_implicit_VR\n        fp.is_implicit_VR = False\n        assert not fp.is_implicit_VR\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomio", "def", "test_is_implicit_vr", "self", "test", "dicomio", "is_implicit_vr", "fp", "dicomio", "fp", "is_implicit_vr", "true", "assert", "fp", "is_implicit_vr", "fp", "is_implicit_vr", "false", "assert", "not", "fp", "is_implicit_vr"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomFileLike.test_init_good_parent", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomFileLike", "func_name": "test_init_good_parent", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomFileLike\n    def test_init_good_parent(self):\n        \"\"\"Test methods are set OK if parent is good\"\"\"\n        fp = DicomFileLike(BytesIO())\n        assert fp.parent_read == fp.parent.read\n        assert fp.write == fp.parent.write\n        assert fp.seek == fp.parent.seek\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomfilelike", "def", "test_init_good_parent", "self", "test", "methods", "are", "set", "ok", "if", "parent", "is", "good", "fp", "dicomfilelike", "bytesio", "assert", "fp", "parent_read", "fp", "parent", "read", "assert", "fp", "write", "fp", "parent", "write", "assert", "fp", "seek", "fp", "parent", "seek"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomFileLike.test_init_bad_parent", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomFileLike", "func_name": "test_init_bad_parent", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomFileLike\n    def test_init_bad_parent(self):\n        \"\"\"Test exceptions raised if parent has no IO methods\"\"\"\n        class IntPlus(int):\n            def tell(self):\n                pass\n\n            def close(self):\n                pass\n\n        fp = DicomFileLike(IntPlus)\n        with pytest.raises(IOError,\n                           match=r\"This DicomFileLike object has no write\\(\\) \"\n                                 r\"method\"):\n            fp.write(b'')\n        with pytest.raises(IOError,\n                           match=r\"This DicomFileLike object has no read\\(\\) \"\n                                 r\"method\"):\n            fp.parent_read(b'')\n        with pytest.raises(IOError,\n                           match=r\"This DicomFileLike object has no seek\\(\\) \"\n                                 r\"method\"):\n            fp.seek(0, 1)\n        assert fp.name == '<no filename>'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomfilelike", "def", "test_init_bad_parent", "self", "test", "exceptions", "raised", "if", "parent", "has", "no", "io", "methods", "class", "intplus", "int", "def", "tell", "self", "pass", "def", "close", "self", "pass", "fp", "dicomfilelike", "intplus", "with", "pytest", "raises", "ioerror", "match", "r", "this", "dicomfilelike", "object", "has", "no", "write", "r", "method", "fp", "write", "b", "with", "pytest", "raises", "ioerror", "match", "r", "this", "dicomfilelike", "object", "has", "no", "read", "r", "method", "fp", "parent_read", "b", "with", "pytest", "raises", "ioerror", "match", "r", "this", "dicomfilelike", "object", "has", "no", "seek", "r", "method", "fp", "seek", "0", "1", "assert", "fp", "name", "no", "filename"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomFileLike.test_context", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomFileLike", "func_name": "test_context", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomFileLike\n    def test_context(self):\n        \"\"\"Test using DicomFileLike as a context\"\"\"\n        with DicomFileLike(BytesIO(b'\\x00\\x01')) as fp:\n            assert fp.parent_read(2) == b'\\x00\\x01'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomfilelike", "def", "test_context", "self", "test", "using", "dicomfilelike", "as", "a", "context", "with", "dicomfilelike", "bytesio", "b", "x00", "x01", "as", "fp", "assert", "fp", "parent_read", "2", "b", "x00", "x01"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomBytesIO.test_getvalue", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomBytesIO", "func_name": "test_getvalue", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomBytesIO\n    def test_getvalue(self):\n        \"\"\"Test DicomBytesIO.getvalue\"\"\"\n        fp = DicomBytesIO(b'\\x00\\x01\\x00\\x02')\n        assert fp.getvalue() == b'\\x00\\x01\\x00\\x02'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicombytesio", "def", "test_getvalue", "self", "test", "dicombytesio", "getvalue", "fp", "dicombytesio", "b", "x00", "x01", "x00", "x02", "assert", "fp", "getvalue", "b", "x00", "x01", "x00", "x02"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_filebase.py::TestDicomFile.test_read", "file_path": "pydicom/tests/test_filebase.py", "class_name": "TestDicomFile", "func_name": "test_read", "text": "文件路径: pydicom/tests/test_filebase.py, 类名: TestDicomFile\n    def test_read(self):\n        \"\"\"Test the function\"\"\"\n        with DicomFile(TEST_FILE, 'rb') as fp:\n            assert not fp.parent.closed\n            assert 'CT_small.dcm' in fp.name\n            assert fp.read(2) == b'\\x49\\x49'\n", "tokens": ["pydicom", "tests", "test_filebase", "py", "testdicomfile", "def", "test_read", "self", "test", "the", "function", "with", "dicomfile", "test_file", "rb", "as", "fp", "assert", "not", "fp", "parent", "closed", "assert", "ct_small", "dcm", "in", "fp", "name", "assert", "fp", "read", "2", "b", "x49", "x49"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_empty_numbers_tag", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_empty_numbers_tag", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_empty_numbers_tag(self):\n        \"\"\"Tests that an empty tag with a number VR (FL, UL, SL, US,\n        SS, FL, FD, OF) reads as an empty string\"\"\"\n        empty_number_tags_ds = dcmread(empty_number_tags_name)\n        assert '' == empty_number_tags_ds.ExaminedBodyThickness\n        assert '' == empty_number_tags_ds.SimpleFrameList\n        assert '' == empty_number_tags_ds.ReferencePixelX0\n        assert '' == empty_number_tags_ds.PhysicalUnitsXDirection\n        assert '' == empty_number_tags_ds.TagAngleSecondAxis\n        assert '' == empty_number_tags_ds.TagSpacingSecondDimension\n        assert '' == empty_number_tags_ds.VectorGridData\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_empty_numbers_tag", "self", "tests", "that", "an", "empty", "tag", "with", "a", "number", "vr", "fl", "ul", "sl", "us", "ss", "fl", "fd", "of", "reads", "as", "an", "empty", "string", "empty_number_tags_ds", "dcmread", "empty_number_tags_name", "assert", "empty_number_tags_ds", "examinedbodythickness", "assert", "empty_number_tags_ds", "simpleframelist", "assert", "empty_number_tags_ds", "referencepixelx0", "assert", "empty_number_tags_ds", "physicalunitsxdirection", "assert", "empty_number_tags_ds", "taganglesecondaxis", "assert", "empty_number_tags_ds", "tagspacingseconddimension", "assert", "empty_number_tags_ds", "vectorgriddata"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_UTF8_filename", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_UTF8_filename", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_UTF8_filename(self):\n        utf8_filename = os.path.join(tempfile.gettempdir(), \"ДИКОМ.dcm\")\n        shutil.copyfile(rtdose_name, utf8_filename)\n        ds = dcmread(utf8_filename)\n        os.remove(utf8_filename)\n        assert ds is not None\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_utf8_filename", "self", "utf8_filename", "os", "path", "join", "tempfile", "gettempdir", "dcm", "shutil", "copyfile", "rtdose_name", "utf8_filename", "ds", "dcmread", "utf8_filename", "os", "remove", "utf8_filename", "assert", "ds", "is", "not", "none"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_RTPlan", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_RTPlan", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_RTPlan(self):\n        \"\"\"Returns correct values for sample data elements in test\n        RT Plan file.\n        \"\"\"\n        plan = dcmread(rtplan_name)\n        beam = plan.BeamSequence[0]\n        # if not two controlpoints, then this would raise exception\n        cp0, cp1 = beam.ControlPointSequence\n\n        assert \"unit001\" == beam.TreatmentMachineName\n        assert beam[0x300a, 0x00b2].value == beam.TreatmentMachineName\n\n        got = cp1.ReferencedDoseReferenceSequence[\n            0].CumulativeDoseReferenceCoefficient\n        DS = pydicom.valuerep.DS\n        expected = DS('0.9990268')\n        assert expected == got\n        got = cp0.BeamLimitingDevicePositionSequence[0].LeafJawPositions\n        assert [DS('-100'), DS('100.0')] == got\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_rtplan", "self", "returns", "correct", "values", "for", "sample", "data", "elements", "in", "test", "rt", "plan", "file", "plan", "dcmread", "rtplan_name", "beam", "plan", "beamsequence", "0", "if", "not", "two", "controlpoints", "then", "this", "would", "raise", "exception", "cp0", "cp1", "beam", "controlpointsequence", "assert", "unit001", "beam", "treatmentmachinename", "assert", "beam", "0x300a", "0x00b2", "value", "beam", "treatmentmachinename", "got", "cp1", "referenceddosereferencesequence", "0", "cumulativedosereferencecoefficient", "ds", "pydicom", "valuerep", "ds", "expected", "ds", "0", "9990268", "assert", "expected", "got", "got", "cp0", "beamlimitingdevicepositionsequence", "0", "leafjawpositions", "assert", "ds", "100", "ds", "100", "0", "got"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_RTDose", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_RTDose", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_RTDose(self):\n        \"\"\"Returns correct values for sample data elements in test\n        RT Dose file\"\"\"\n        dose = dcmread(rtdose_name)\n        assert Tag((0x3004, 0x000c)) == dose.FrameIncrementPointer\n        assert dose[0x28, 9].value == dose.FrameIncrementPointer\n\n        # try a value that is nested the deepest\n        # (so deep I break it into two steps!)\n        fract = (\n            dose.ReferencedRTPlanSequence[0].ReferencedFractionGroupSequence[0]\n        )\n        assert 1 == fract.ReferencedBeamSequence[0].ReferencedBeamNumber\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_rtdose", "self", "returns", "correct", "values", "for", "sample", "data", "elements", "in", "test", "rt", "dose", "file", "dose", "dcmread", "rtdose_name", "assert", "tag", "0x3004", "0x000c", "dose", "frameincrementpointer", "assert", "dose", "0x28", "9", "value", "dose", "frameincrementpointer", "try", "a", "value", "that", "is", "nested", "the", "deepest", "so", "deep", "i", "break", "it", "into", "two", "steps", "fract", "dose", "referencedrtplansequence", "0", "referencedfractiongroupsequence", "0", "assert", "1", "fract", "referencedbeamsequence", "0", "referencedbeamnumber"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_CT", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_CT", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_CT(self):\n        \"\"\"Returns correct values for sample data elements in test CT file.\"\"\"\n        ct = dcmread(ct_name)\n        assert '1.3.6.1.4.1.5962.2' == ct.file_meta.ImplementationClassUID\n        value = ct.file_meta[0x2, 0x12].value\n        assert value == ct.file_meta.ImplementationClassUID\n\n        # (0020, 0032) Image Position (Patient)\n        # [-158.13580300000001, -179.035797, -75.699996999999996]\n        got = ct.ImagePositionPatient\n        DS = pydicom.valuerep.DS\n        expected = [DS('-158.135803'), DS('-179.035797'), DS('-75.699997')]\n        assert expected == got\n\n        assert 128 == ct.Rows\n        assert 128 == ct.Columns\n        assert 16 == ct.BitsStored\n        assert 128 * 128 * 2 == len(ct.PixelData)\n\n        # Also test private elements name can be resolved:\n        got = ct[(0x0043, 0x104e)].name\n        assert \"[Duration of X-ray on]\" == got\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_ct", "self", "returns", "correct", "values", "for", "sample", "data", "elements", "in", "test", "ct", "file", "ct", "dcmread", "ct_name", "assert", "1", "3", "6", "1", "4", "1", "5962", "2", "ct", "file_meta", "implementationclassuid", "value", "ct", "file_meta", "0x2", "0x12", "value", "assert", "value", "ct", "file_meta", "implementationclassuid", "0020", "0032", "image", "position", "patient", "158", "13580300000001", "179", "035797", "75", "699996999999996", "got", "ct", "imagepositionpatient", "ds", "pydicom", "valuerep", "ds", "expected", "ds", "158", "135803", "ds", "179", "035797", "ds", "75", "699997", "assert", "expected", "got", "assert", "128", "ct", "rows", "assert", "128", "ct", "columns", "assert", "16", "ct", "bitsstored", "assert", "128", "128", "2", "len", "ct", "pixeldata", "also", "test", "private", "elements", "name", "can", "be", "resolved", "got", "ct", "0x0043", "0x104e", "name", "assert", "duration", "of", "x", "ray", "on", "got"], "doc_len": 115}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_CT_PixelData", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_CT_PixelData", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_CT_PixelData(self):\n        \"\"\"Check that we can read pixel data.\n        Tests that we get last one in array.\n        \"\"\"\n        ct = dcmread(ct_name)\n        assert 909 == ct.pixel_array[-1][-1]\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_ct_pixeldata", "self", "check", "that", "we", "can", "read", "pixel", "data", "tests", "that", "we", "get", "last", "one", "in", "array", "ct", "dcmread", "ct_name", "assert", "909", "ct", "pixel_array", "1", "1"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_force", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_force", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_force(self):\n        \"\"\"Raises exception if missing DICOM header and force==False.\"\"\"\n        with pytest.raises(InvalidDicomError):\n            dcmread(rtstruct_name)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_force", "self", "raises", "exception", "if", "missing", "dicom", "header", "and", "force", "false", "with", "pytest", "raises", "invaliddicomerror", "dcmread", "rtstruct_name"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_RTStruct", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_RTStruct", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_RTStruct(self):\n        \"\"\"Returns correct values for sample elements in test RTSTRUCT file.\"\"\"\n        # RTSTRUCT test file has complex nested sequences\n        # -- see rtstruct.dump file\n        # Also has no DICOM header ... so tests 'force' argument of dcmread\n\n        rtss = dcmread(rtstruct_name, force=True)\n        frame_of_ref = rtss.ReferencedFrameOfReferenceSequence[0]\n        study = frame_of_ref.RTReferencedStudySequence[0]\n        uid = study.RTReferencedSeriesSequence[0].SeriesInstanceUID\n        assert \"1.2.826.0.1.3680043.8.498.2010020400001.2.1.1\" == uid\n\n        got = rtss.ROIContourSequence[0].ContourSequence[2].ContourNumber\n        assert 3 == got\n\n        obs_seq0 = rtss.RTROIObservationsSequence[0]\n        got = obs_seq0.ROIPhysicalPropertiesSequence[0].ROIPhysicalProperty\n        assert 'REL_ELEC_DENSITY' == got\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_rtstruct", "self", "returns", "correct", "values", "for", "sample", "elements", "in", "test", "rtstruct", "file", "rtstruct", "test", "file", "has", "complex", "nested", "sequences", "see", "rtstruct", "dump", "file", "also", "has", "no", "dicom", "header", "so", "tests", "force", "argument", "of", "dcmread", "rtss", "dcmread", "rtstruct_name", "force", "true", "frame_of_ref", "rtss", "referencedframeofreferencesequence", "0", "study", "frame_of_ref", "rtreferencedstudysequence", "0", "uid", "study", "rtreferencedseriessequence", "0", "seriesinstanceuid", "assert", "1", "2", "826", "0", "1", "3680043", "8", "498", "2010020400001", "2", "1", "1", "uid", "got", "rtss", "roicontoursequence", "0", "contoursequence", "2", "contournumber", "assert", "3", "got", "obs_seq0", "rtss", "rtroiobservationssequence", "0", "got", "obs_seq0", "roiphysicalpropertiessequence", "0", "roiphysicalproperty", "assert", "rel_elec_density", "got"], "doc_len": 94}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_dir", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_dir", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_dir(self):\n        \"\"\"Returns correct dir attributes for both Dataset and DICOM names\n        (python >= 2.6)..\"\"\"\n        # Only python >= 2.6 calls __dir__ for dir() call\n        rtss = dcmread(rtstruct_name, force=True)\n        # sample some expected 'dir' values\n        got_dir = dir(rtss)\n        expect_in_dir = ['pixel_array', 'add_new', 'ROIContourSequence',\n                         'StructureSetDate']\n        for name in expect_in_dir:\n            assert name in got_dir\n\n        # Now check for some items in dir() of a nested item\n        roi0 = rtss.ROIContourSequence[0]\n        got_dir = dir(roi0)\n        expect_in_dir = ['pixel_array', 'add_new', 'ReferencedROINumber',\n                         'ROIDisplayColor']\n        for name in expect_in_dir:\n            assert name in got_dir\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_dir", "self", "returns", "correct", "dir", "attributes", "for", "both", "dataset", "and", "dicom", "names", "python", "2", "6", "only", "python", "2", "6", "calls", "__dir__", "for", "dir", "call", "rtss", "dcmread", "rtstruct_name", "force", "true", "sample", "some", "expected", "dir", "values", "got_dir", "dir", "rtss", "expect_in_dir", "pixel_array", "add_new", "roicontoursequence", "structuresetdate", "for", "name", "in", "expect_in_dir", "assert", "name", "in", "got_dir", "now", "check", "for", "some", "items", "in", "dir", "of", "a", "nested", "item", "roi0", "rtss", "roicontoursequence", "0", "got_dir", "dir", "roi0", "expect_in_dir", "pixel_array", "add_new", "referencedroinumber", "roidisplaycolor", "for", "name", "in", "expect_in_dir", "assert", "name", "in", "got_dir"], "doc_len": 87}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_MR", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_MR", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_MR(self):\n        \"\"\"Returns correct values for sample data elements in test MR file.\"\"\"\n        mr = dcmread(mr_name)\n        # (0010, 0010) Patient's Name           'CompressedSamples^MR1'\n        mr.decode()\n        assert 'CompressedSamples^MR1' == mr.PatientName\n        assert mr[0x10, 0x10].value == mr.PatientName\n\n        DS = pydicom.valuerep.DS\n        assert [DS('0.3125'), DS('0.3125')] == mr.PixelSpacing\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_mr", "self", "returns", "correct", "values", "for", "sample", "data", "elements", "in", "test", "mr", "file", "mr", "dcmread", "mr_name", "0010", "0010", "patient", "s", "name", "compressedsamples", "mr1", "mr", "decode", "assert", "compressedsamples", "mr1", "mr", "patientname", "assert", "mr", "0x10", "0x10", "value", "mr", "patientname", "ds", "pydicom", "valuerep", "ds", "assert", "ds", "0", "3125", "ds", "0", "3125", "mr", "pixelspacing"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_deflate", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_deflate", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_deflate(self):\n        \"\"\"Returns correct values for sample data elements in test compressed\n         (zlib deflate) file\n         \"\"\"\n        # Everything after group 2 is compressed.\n        # If we can read anything else, the decompression must have been ok.\n        ds = dcmread(deflate_name)\n        assert \"WSD\" == ds.ConversionType\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_deflate", "self", "returns", "correct", "values", "for", "sample", "data", "elements", "in", "test", "compressed", "zlib", "deflate", "file", "everything", "after", "group", "2", "is", "compressed", "if", "we", "can", "read", "anything", "else", "the", "decompression", "must", "have", "been", "ok", "ds", "dcmread", "deflate_name", "assert", "wsd", "ds", "conversiontype"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_pixels_read", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_pixels_read", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_pixels_read(self):\n        \"\"\"Returns all data elements before pixels using\n        stop_before_pixels=False.\n        \"\"\"\n        # Just check the tags, and a couple of values\n        ctpartial = dcmread(ct_name, stop_before_pixels=True)\n        ctpartial_tags = sorted(ctpartial.keys())\n        ctfull = dcmread(ct_name)\n        ctfull_tags = sorted(ctfull.keys())\n        missing = [Tag(0x7fe0, 0x10), Tag(0xfffc, 0xfffc)]\n        assert ctfull_tags == ctpartial_tags + missing\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_pixels_read", "self", "returns", "all", "data", "elements", "before", "pixels", "using", "stop_before_pixels", "false", "just", "check", "the", "tags", "and", "a", "couple", "of", "values", "ctpartial", "dcmread", "ct_name", "stop_before_pixels", "true", "ctpartial_tags", "sorted", "ctpartial", "keys", "ctfull", "dcmread", "ct_name", "ctfull_tags", "sorted", "ctfull", "keys", "missing", "tag", "0x7fe0", "0x10", "tag", "0xfffc", "0xfffc", "assert", "ctfull_tags", "ctpartial_tags", "missing"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_specific_tags", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_specific_tags", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_specific_tags(self):\n        \"\"\"Returns only tags specified by user.\"\"\"\n        ctspecific = dcmread(ct_name, specific_tags=[\n            Tag(0x0010, 0x0010), 'PatientID', 'ImageType', 'ViewName'])\n        ctspecific_tags = sorted(ctspecific.keys())\n        expected = [\n            # SpecificCharacterSet is always added\n            # ViewName does not exist in the data set\n            Tag(0x0008, 0x0005), Tag(0x0008, 0x0008),\n            Tag(0x0010, 0x0010), Tag(0x0010, 0x0020)\n        ]\n        assert expected == ctspecific_tags\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_specific_tags", "self", "returns", "only", "tags", "specified", "by", "user", "ctspecific", "dcmread", "ct_name", "specific_tags", "tag", "0x0010", "0x0010", "patientid", "imagetype", "viewname", "ctspecific_tags", "sorted", "ctspecific", "keys", "expected", "specificcharacterset", "is", "always", "added", "viewname", "does", "not", "exist", "in", "the", "data", "set", "tag", "0x0008", "0x0005", "tag", "0x0008", "0x0008", "tag", "0x0010", "0x0010", "tag", "0x0010", "0x0020", "assert", "expected", "ctspecific_tags"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_specific_tags_with_unknown_length_SQ", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_specific_tags_with_unknown_length_SQ", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_specific_tags_with_unknown_length_SQ(self):\n        \"\"\"Returns only tags specified by user.\"\"\"\n        unknown_len_sq_tag = Tag(0x3f03, 0x1001)\n        tags = dcmread(priv_SQ_name, specific_tags=[unknown_len_sq_tag])\n        tags = sorted(tags.keys())\n        assert [unknown_len_sq_tag] == tags\n\n        tags = dcmread(priv_SQ_name, specific_tags=['PatientName'])\n        tags = sorted(tags.keys())\n        assert [] == tags\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_specific_tags_with_unknown_length_sq", "self", "returns", "only", "tags", "specified", "by", "user", "unknown_len_sq_tag", "tag", "0x3f03", "0x1001", "tags", "dcmread", "priv_sq_name", "specific_tags", "unknown_len_sq_tag", "tags", "sorted", "tags", "keys", "assert", "unknown_len_sq_tag", "tags", "tags", "dcmread", "priv_sq_name", "specific_tags", "patientname", "tags", "sorted", "tags", "keys", "assert", "tags"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_specific_tags_with_unknown_length_tag", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_specific_tags_with_unknown_length_tag", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_specific_tags_with_unknown_length_tag(self):\n        \"\"\"Returns only tags specified by user.\"\"\"\n        unknown_len_tag = Tag(0x7fe0, 0x0010)  # Pixel Data\n        tags = dcmread(emri_jpeg_2k_lossless, specific_tags=[unknown_len_tag])\n        tags = sorted(tags.keys())\n        # SpecificCharacterSet is always added\n        assert [Tag(0x08, 0x05), unknown_len_tag] == tags\n\n        tags = dcmread(\n            emri_jpeg_2k_lossless, specific_tags=['SpecificCharacterSet']\n        )\n        tags = sorted(tags.keys())\n        assert [Tag(0x08, 0x05)] == tags\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_specific_tags_with_unknown_length_tag", "self", "returns", "only", "tags", "specified", "by", "user", "unknown_len_tag", "tag", "0x7fe0", "0x0010", "pixel", "data", "tags", "dcmread", "emri_jpeg_2k_lossless", "specific_tags", "unknown_len_tag", "tags", "sorted", "tags", "keys", "specificcharacterset", "is", "always", "added", "assert", "tag", "0x08", "0x05", "unknown_len_tag", "tags", "tags", "dcmread", "emri_jpeg_2k_lossless", "specific_tags", "specificcharacterset", "tags", "sorted", "tags", "keys", "assert", "tag", "0x08", "0x05", "tags"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_private_SQ", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_private_SQ", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_private_SQ(self):\n        \"\"\"Can read private undefined length SQ without error.\"\"\"\n        # From issues 91, 97, 98. Bug introduced by fast reading, due to\n        #    VR=None in raw data elements, then an undefined length private\n        #    item VR is looked up, and there is no such tag,\n        #    generating an exception\n\n        # Simply read the file, in 0.9.5 this generated an exception\n        dcmread(priv_SQ_name)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_private_sq", "self", "can", "read", "private", "undefined", "length", "sq", "without", "error", "from", "issues", "91", "97", "98", "bug", "introduced", "by", "fast", "reading", "due", "to", "vr", "none", "in", "raw", "data", "elements", "then", "an", "undefined", "length", "private", "item", "vr", "is", "looked", "up", "and", "there", "is", "no", "such", "tag", "generating", "an", "exception", "simply", "read", "the", "file", "in", "0", "9", "5", "this", "generated", "an", "exception", "dcmread", "priv_sq_name"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_nested_private_SQ", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_nested_private_SQ", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_nested_private_SQ(self):\n        \"\"\"Can successfully read a private SQ which contains additional SQs.\"\"\"\n        # From issue 113. When a private SQ of undefined length is used, the\n        #   sequence is read in and the length of the SQ is determined upon\n        #   identification of the SQ termination sequence. When using nested\n        #   Sequences, the first termination sequence encountered actually\n        #   belongs to the nested Sequence not the parent, therefore the\n        #   remainder of the file is not read in properly\n        ds = dcmread(nested_priv_SQ_name)\n\n        # Make sure that the entire dataset was read in\n        pixel_data_tag = TupleTag((0x7fe0, 0x10))\n        assert pixel_data_tag in ds\n\n        # Check that the DataElement is indeed a Sequence\n        tag = TupleTag((0x01, 0x01))\n        seq0 = ds[tag]\n        assert 'SQ' == seq0.VR\n\n        # Now verify the presence of the nested private SQ\n        seq1 = seq0[0][tag]\n        assert 'SQ' == seq1.VR\n\n        # Now make sure the values that are parsed are correct\n        assert b'Double Nested SQ' == seq1[0][tag].value\n        assert b'Nested SQ' == seq0[0][0x01, 0x02].value\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_nested_private_sq", "self", "can", "successfully", "read", "a", "private", "sq", "which", "contains", "additional", "sqs", "from", "issue", "113", "when", "a", "private", "sq", "of", "undefined", "length", "is", "used", "the", "sequence", "is", "read", "in", "and", "the", "length", "of", "the", "sq", "is", "determined", "upon", "identification", "of", "the", "sq", "termination", "sequence", "when", "using", "nested", "sequences", "the", "first", "termination", "sequence", "encountered", "actually", "belongs", "to", "the", "nested", "sequence", "not", "the", "parent", "therefore", "the", "remainder", "of", "the", "file", "is", "not", "read", "in", "properly", "ds", "dcmread", "nested_priv_sq_name", "make", "sure", "that", "the", "entire", "dataset", "was", "read", "in", "pixel_data_tag", "tupletag", "0x7fe0", "0x10", "assert", "pixel_data_tag", "in", "ds", "check", "that", "the", "dataelement", "is", "indeed", "a", "sequence", "tag", "tupletag", "0x01", "0x01", "seq0", "ds", "tag", "assert", "sq", "seq0", "vr", "now", "verify", "the", "presence", "of", "the", "nested", "private", "sq", "seq1", "seq0", "0", "tag", "assert", "sq", "seq1", "vr", "now", "make", "sure", "the", "values", "that", "are", "parsed", "are", "correct", "assert", "b", "double", "nested", "sq", "seq1", "0", "tag", "value", "assert", "b", "nested", "sq", "seq0", "0", "0x01", "0x02", "value"], "doc_len": 163}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_meta_group_length", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_meta_group_length", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_meta_group_length(self):\n        \"\"\"Read file with no group length in file meta.\"\"\"\n        # Issue 108 -- iView example file with no group length (0002,0002)\n        # Originally crashed, now check no exception, but also check one item\n        #     in file_meta, and second one in followinsg dataset\n        ds = dcmread(no_meta_group_length)\n        assert \"20111130\" == ds.InstanceCreationDate\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_meta_group_length", "self", "read", "file", "with", "no", "group", "length", "in", "file", "meta", "issue", "108", "iview", "example", "file", "with", "no", "group", "length", "0002", "0002", "originally", "crashed", "now", "check", "no", "exception", "but", "also", "check", "one", "item", "in", "file_meta", "and", "second", "one", "in", "followinsg", "dataset", "ds", "dcmread", "no_meta_group_length", "assert", "20111130", "ds", "instancecreationdate"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_transfer_syntax_in_meta", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_transfer_syntax_in_meta", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_transfer_syntax_in_meta(self):\n        \"\"\"Read file with file_meta, but has no TransferSyntaxUID in it.\"\"\"\n        # From issue 258: if file has file_meta but no TransferSyntaxUID in it,\n        #   should assume default transfer syntax\n        ds = dcmread(meta_missing_tsyntax_name)  # is default transfer syntax\n\n        # Repeat one test from nested private sequence test to maker sure\n        #    file was read correctly\n        pixel_data_tag = TupleTag((0x7fe0, 0x10))\n        assert pixel_data_tag in ds\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_transfer_syntax_in_meta", "self", "read", "file", "with", "file_meta", "but", "has", "no", "transfersyntaxuid", "in", "it", "from", "issue", "258", "if", "file", "has", "file_meta", "but", "no", "transfersyntaxuid", "in", "it", "should", "assume", "default", "transfer", "syntax", "ds", "dcmread", "meta_missing_tsyntax_name", "is", "default", "transfer", "syntax", "repeat", "one", "test", "from", "nested", "private", "sequence", "test", "to", "maker", "sure", "file", "was", "read", "correctly", "pixel_data_tag", "tupletag", "0x7fe0", "0x10", "assert", "pixel_data_tag", "in", "ds"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_explicit_VR_little_endian_no_meta", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_explicit_VR_little_endian_no_meta", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_explicit_VR_little_endian_no_meta(self):\n        \"\"\"Read file without file meta with Little Endian Explicit VR dataset.\n        \"\"\"\n        # Example file from CMS XiO 5.0 and above\n        # Still need to force read data since there is no 'DICM' marker present\n        ds = dcmread(explicit_vr_le_no_meta, force=True)\n        assert \"20150529\" == ds.InstanceCreationDate\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_explicit_vr_little_endian_no_meta", "self", "read", "file", "without", "file", "meta", "with", "little", "endian", "explicit", "vr", "dataset", "example", "file", "from", "cms", "xio", "5", "0", "and", "above", "still", "need", "to", "force", "read", "data", "since", "there", "is", "no", "dicm", "marker", "present", "ds", "dcmread", "explicit_vr_le_no_meta", "force", "true", "assert", "20150529", "ds", "instancecreationdate"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_explicit_VR_big_endian_no_meta", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_explicit_VR_big_endian_no_meta", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_explicit_VR_big_endian_no_meta(self):\n        \"\"\"Read file without file meta with Big Endian Explicit VR dataset.\"\"\"\n        # Example file from CMS XiO 5.0 and above\n        # Still need to force read data since there is no 'DICM' marker present\n        ds = dcmread(explicit_vr_be_no_meta, force=True)\n        assert \"20150529\" == ds.InstanceCreationDate\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_explicit_vr_big_endian_no_meta", "self", "read", "file", "without", "file", "meta", "with", "big", "endian", "explicit", "vr", "dataset", "example", "file", "from", "cms", "xio", "5", "0", "and", "above", "still", "need", "to", "force", "read", "data", "since", "there", "is", "no", "dicm", "marker", "present", "ds", "dcmread", "explicit_vr_be_no_meta", "force", "true", "assert", "20150529", "ds", "instancecreationdate"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_planar_config", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_planar_config", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_planar_config(self):\n        px_data_ds = dcmread(color_px_name)\n        pl_data_ds = dcmread(color_pl_name)\n        assert px_data_ds.PlanarConfiguration != pl_data_ds.PlanarConfiguration\n        if have_numpy:\n            px_data = px_data_ds.pixel_array\n            pl_data = pl_data_ds.pixel_array\n            assert numpy.all(px_data == pl_data)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_planar_config", "self", "px_data_ds", "dcmread", "color_px_name", "pl_data_ds", "dcmread", "color_pl_name", "assert", "px_data_ds", "planarconfiguration", "pl_data_ds", "planarconfiguration", "if", "have_numpy", "px_data", "px_data_ds", "pixel_array", "pl_data", "pl_data_ds", "pixel_array", "assert", "numpy", "all", "px_data", "pl_data"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_correct_ambiguous_vr", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_correct_ambiguous_vr", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_correct_ambiguous_vr(self):\n        \"\"\"Test correcting ambiguous VR elements read from file\"\"\"\n        ds = Dataset()\n        ds.PixelRepresentation = 0\n        ds.add(DataElement(0x00280108, 'US', 10))\n        ds.add(DataElement(0x00280109, 'US', 500))\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ds)\n        file_ds.is_implicit_VR = True\n        file_ds.is_little_endian = True\n        file_ds.save_as(fp, write_like_original=True)\n\n        ds = dcmread(fp, force=True)\n        assert 'US' == ds[0x00280108].VR\n        assert 10 == ds.SmallestPixelValueInSeries\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_correct_ambiguous_vr", "self", "test", "correcting", "ambiguous", "vr", "elements", "read", "from", "file", "ds", "dataset", "ds", "pixelrepresentation", "0", "ds", "add", "dataelement", "0x00280108", "us", "10", "ds", "add", "dataelement", "0x00280109", "us", "500", "fp", "bytesio", "file_ds", "filedataset", "fp", "ds", "file_ds", "is_implicit_vr", "true", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "force", "true", "assert", "us", "ds", "0x00280108", "vr", "assert", "10", "ds", "smallestpixelvalueinseries"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_correct_ambiguous_explicit_vr", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_correct_ambiguous_explicit_vr", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_correct_ambiguous_explicit_vr(self):\n        \"\"\"Test correcting ambiguous VR elements read from file\"\"\"\n        ds = Dataset()\n        ds.PixelRepresentation = 0\n        ds.add(DataElement(0x00280108, 'US', 10))\n        ds.add(DataElement(0x00280109, 'US', 500))\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ds)\n        file_ds.is_implicit_VR = False\n        file_ds.is_little_endian = True\n        file_ds.save_as(fp, write_like_original=True)\n\n        ds = dcmread(fp, force=True)\n        assert 'US' == ds[0x00280108].VR\n        assert 10 == ds.SmallestPixelValueInSeries\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_correct_ambiguous_explicit_vr", "self", "test", "correcting", "ambiguous", "vr", "elements", "read", "from", "file", "ds", "dataset", "ds", "pixelrepresentation", "0", "ds", "add", "dataelement", "0x00280108", "us", "10", "ds", "add", "dataelement", "0x00280109", "us", "500", "fp", "bytesio", "file_ds", "filedataset", "fp", "ds", "file_ds", "is_implicit_vr", "false", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "force", "true", "assert", "us", "ds", "0x00280108", "vr", "assert", "10", "ds", "smallestpixelvalueinseries"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_correct_ambiguous_vr_compressed", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_correct_ambiguous_vr_compressed", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_correct_ambiguous_vr_compressed(self):\n        \"\"\"Test correcting compressed Pixel Data read from file\"\"\"\n        # Create an implicit VR compressed dataset\n        ds = dcmread(jpeg_lossless_name)\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ds)\n        file_ds.is_implicit_VR = True\n        file_ds.is_little_endian = True\n        file_ds.save_as(fp, write_like_original=True)\n\n        ds = dcmread(fp, force=True)\n        assert 'OB' == ds[0x7fe00010].VR\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_correct_ambiguous_vr_compressed", "self", "test", "correcting", "compressed", "pixel", "data", "read", "from", "file", "create", "an", "implicit", "vr", "compressed", "dataset", "ds", "dcmread", "jpeg_lossless_name", "fp", "bytesio", "file_ds", "filedataset", "fp", "ds", "file_ds", "is_implicit_vr", "true", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "force", "true", "assert", "ob", "ds", "0x7fe00010", "vr"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_long_specific_char_set", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_long_specific_char_set", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_long_specific_char_set(self):\n        \"\"\"Test that specific character set is read even if it is longer\n         than defer_size\"\"\"\n        ds = Dataset()\n\n        long_specific_char_set_value = ['ISO 2022IR 100'] * 9\n        ds.add(DataElement(0x00080005, 'CS', long_specific_char_set_value))\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ds)\n        file_ds.save_as(fp, write_like_original=True)\n\n        ds = dcmread(fp, defer_size=65, force=True)\n        assert long_specific_char_set_value == ds[0x00080005].value\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_long_specific_char_set", "self", "test", "that", "specific", "character", "set", "is", "read", "even", "if", "it", "is", "longer", "than", "defer_size", "ds", "dataset", "long_specific_char_set_value", "iso", "2022ir", "100", "9", "ds", "add", "dataelement", "0x00080005", "cs", "long_specific_char_set_value", "fp", "bytesio", "file_ds", "filedataset", "fp", "ds", "file_ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "defer_size", "65", "force", "true", "assert", "long_specific_char_set_value", "ds", "0x00080005", "value"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_preamble_file_meta_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_preamble_file_meta_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_preamble_file_meta_dataset(self):\n        \"\"\"Test correct read of group 2 elements with no preamble.\"\"\"\n        bytestream = (b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                      b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                      b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                      b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                      b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00\\x20\\x20\\x10\\x00'\n                      b'\\x02\\x00\\x00\\x00\\x01\\x00\\x20\\x20\\x20\\x00\\x06\\x00'\n                      b'\\x00\\x00\\x4e\\x4f\\x52\\x4d\\x41\\x4c')\n\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'MediaStorageSOPClassUID' in ds.file_meta\n        assert ImplicitVRLittleEndian == ds.file_meta.TransferSyntaxUID\n        assert 'NORMAL' == ds.Polarity\n        assert 1 == ds.ImageBoxPosition\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_preamble_file_meta_dataset", "self", "test", "correct", "read", "of", "group", "2", "elements", "with", "no", "preamble", "bytestream", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "x20", "x20", "x10", "x00", "b", "x02", "x00", "x00", "x00", "x01", "x00", "x20", "x20", "x20", "x00", "x06", "x00", "b", "x00", "x00", "x4e", "x4f", "x52", "x4d", "x41", "x4c", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "mediastoragesopclassuid", "in", "ds", "file_meta", "assert", "implicitvrlittleendian", "ds", "file_meta", "transfersyntaxuid", "assert", "normal", "ds", "polarity", "assert", "1", "ds", "imageboxposition"], "doc_len": 132}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_preamble_command_group_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_preamble_command_group_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_preamble_command_group_dataset(self):\n        \"\"\"Test correct read of group 0 and 2 elements with no preamble.\"\"\"\n        bytestream = (b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                      b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                      b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                      b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                      b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00'\n                      b'\\x20\\x20\\x10\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x20\\x20'\n                      b'\\x20\\x00\\x06\\x00\\x00\\x00\\x4e\\x4f\\x52\\x4d\\x41\\x4c'\n                      b'\\x00\\x00\\x10\\x01\\x02\\x00\\x00\\x00\\x03\\x00')\n\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'MediaStorageSOPClassUID' in ds.file_meta\n        assert ImplicitVRLittleEndian == ds.file_meta.TransferSyntaxUID\n        assert 'NORMAL' == ds.Polarity\n        assert 1 == ds.ImageBoxPosition\n        assert 3 == ds.MessageID\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_preamble_command_group_dataset", "self", "test", "correct", "read", "of", "group", "0", "and", "2", "elements", "with", "no", "preamble", "bytestream", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "b", "x20", "x20", "x10", "x00", "x02", "x00", "x00", "x00", "x01", "x00", "x20", "x20", "b", "x20", "x00", "x06", "x00", "x00", "x00", "x4e", "x4f", "x52", "x4d", "x41", "x4c", "b", "x00", "x00", "x10", "x01", "x02", "x00", "x00", "x00", "x03", "x00", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "mediastoragesopclassuid", "in", "ds", "file_meta", "assert", "implicitvrlittleendian", "ds", "file_meta", "transfersyntaxuid", "assert", "normal", "ds", "polarity", "assert", "1", "ds", "imageboxposition", "assert", "3", "ds", "messageid"], "doc_len": 149}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_group_length_wrong", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_group_length_wrong", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_group_length_wrong(self):\n        \"\"\"Test file is read correctly even if FileMetaInformationGroupLength\n        is incorrect.\n        \"\"\"\n        bytestream = (b'\\x02\\x00\\x00\\x00\\x55\\x4C\\x04\\x00\\x0A\\x00\\x00\\x00'\n                      b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                      b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                      b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                      b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                      b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00'\n                      b'\\x20\\x20\\x10\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x20\\x20'\n                      b'\\x20\\x00\\x06\\x00\\x00\\x00\\x4e\\x4f\\x52\\x4d\\x41\\x4c')\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        value = ds.file_meta.FileMetaInformationGroupLength\n        assert not len(bytestream) - 12 == value\n        assert 10 == ds.file_meta.FileMetaInformationGroupLength\n        assert 'MediaStorageSOPClassUID' in ds.file_meta\n        assert ImplicitVRLittleEndian == ds.file_meta.TransferSyntaxUID\n        assert 'NORMAL' == ds.Polarity\n        assert 1 == ds.ImageBoxPosition\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_group_length_wrong", "self", "test", "file", "is", "read", "correctly", "even", "if", "filemetainformationgrouplength", "is", "incorrect", "bytestream", "b", "x02", "x00", "x00", "x00", "x55", "x4c", "x04", "x00", "x0a", "x00", "x00", "x00", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "b", "x20", "x20", "x10", "x00", "x02", "x00", "x00", "x00", "x01", "x00", "x20", "x20", "b", "x20", "x00", "x06", "x00", "x00", "x00", "x4e", "x4f", "x52", "x4d", "x41", "x4c", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "value", "ds", "file_meta", "filemetainformationgrouplength", "assert", "not", "len", "bytestream", "12", "value", "assert", "10", "ds", "file_meta", "filemetainformationgrouplength", "assert", "mediastoragesopclassuid", "in", "ds", "file_meta", "assert", "implicitvrlittleendian", "ds", "file_meta", "transfersyntaxuid", "assert", "normal", "ds", "polarity", "assert", "1", "ds", "imageboxposition"], "doc_len": 160}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_preamble_command_meta_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_preamble_command_meta_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_preamble_command_meta_no_dataset(self):\n        \"\"\"Test reading only preamble, command and meta elements\"\"\"\n        preamble = b'\\x00' * 128\n        prefix = b'DICM'\n        command = (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x38'\n                   b'\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x12\\x00\\x00'\n                   b'\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31'\n                   b'\\x30\\x30\\x30\\x38\\x2e\\x31\\x2e\\x31\\x00\\x00'\n                   b'\\x00\\x00\\x01\\x02\\x00\\x00\\x00\\x30\\x00\\x00'\n                   b'\\x00\\x10\\x01\\x02\\x00\\x00\\x00\\x07\\x00\\x00'\n                   b'\\x00\\x00\\x08\\x02\\x00\\x00\\x00\\x01\\x01')\n        meta = (b'\\x02\\x00\\x00\\x00\\x55\\x4C\\x04\\x00\\x0A\\x00\\x00\\x00'\n                b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00')\n\n        bytestream = preamble + prefix + meta + command\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'TransferSyntaxUID' in ds.file_meta\n        assert 'MessageID' in ds\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_preamble_command_meta_no_dataset", "self", "test", "reading", "only", "preamble", "command", "and", "meta", "elements", "preamble", "b", "x00", "128", "prefix", "b", "dicm", "command", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x38", "b", "x00", "x00", "x00", "x00", "x00", "x02", "x00", "x12", "x00", "x00", "b", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "b", "x30", "x30", "x30", "x38", "x2e", "x31", "x2e", "x31", "x00", "x00", "b", "x00", "x00", "x01", "x02", "x00", "x00", "x00", "x30", "x00", "x00", "b", "x00", "x10", "x01", "x02", "x00", "x00", "x00", "x07", "x00", "x00", "b", "x00", "x00", "x08", "x02", "x00", "x00", "x00", "x01", "x01", "meta", "b", "x02", "x00", "x00", "x00", "x55", "x4c", "x04", "x00", "x0a", "x00", "x00", "x00", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "bytestream", "preamble", "prefix", "meta", "command", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds", "file_meta", "assert", "messageid", "in", "ds"], "doc_len": 196}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_preamble_meta_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_preamble_meta_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_preamble_meta_no_dataset(self):\n        \"\"\"Test reading only preamble and meta elements\"\"\"\n        preamble = b'\\x00' * 128\n        prefix = b'DICM'\n        meta = (b'\\x02\\x00\\x00\\x00\\x55\\x4C\\x04\\x00\\x0A\\x00\\x00\\x00'\n                b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00')\n\n        bytestream = preamble + prefix + meta\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert b'\\x00' * 128 == ds.preamble\n        assert 'TransferSyntaxUID' in ds.file_meta\n        assert Dataset() == ds[:]\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_preamble_meta_no_dataset", "self", "test", "reading", "only", "preamble", "and", "meta", "elements", "preamble", "b", "x00", "128", "prefix", "b", "dicm", "meta", "b", "x02", "x00", "x00", "x00", "x55", "x4c", "x04", "x00", "x0a", "x00", "x00", "x00", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "bytestream", "preamble", "prefix", "meta", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "b", "x00", "128", "ds", "preamble", "assert", "transfersyntaxuid", "in", "ds", "file_meta", "assert", "dataset", "ds"], "doc_len": 123}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_preamble_commandset_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_preamble_commandset_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_preamble_commandset_no_dataset(self):\n        \"\"\"Test reading only preamble and command set\"\"\"\n        preamble = b'\\x00' * 128\n        prefix = b'DICM'\n        command = (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x38'\n                   b'\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x12\\x00\\x00'\n                   b'\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31'\n                   b'\\x30\\x30\\x30\\x38\\x2e\\x31\\x2e\\x31\\x00\\x00'\n                   b'\\x00\\x00\\x01\\x02\\x00\\x00\\x00\\x30\\x00\\x00'\n                   b'\\x00\\x10\\x01\\x02\\x00\\x00\\x00\\x07\\x00\\x00'\n                   b'\\x00\\x00\\x08\\x02\\x00\\x00\\x00\\x01\\x01')\n        bytestream = preamble + prefix + command\n\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'MessageID' in ds\n        assert Dataset() == ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_preamble_commandset_no_dataset", "self", "test", "reading", "only", "preamble", "and", "command", "set", "preamble", "b", "x00", "128", "prefix", "b", "dicm", "command", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x38", "b", "x00", "x00", "x00", "x00", "x00", "x02", "x00", "x12", "x00", "x00", "b", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "b", "x30", "x30", "x30", "x38", "x2e", "x31", "x2e", "x31", "x00", "x00", "b", "x00", "x00", "x01", "x02", "x00", "x00", "x00", "x30", "x00", "x00", "b", "x00", "x10", "x01", "x02", "x00", "x00", "x00", "x07", "x00", "x00", "b", "x00", "x00", "x08", "x02", "x00", "x00", "x00", "x01", "x01", "bytestream", "preamble", "prefix", "command", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "messageid", "in", "ds", "assert", "dataset", "ds", "file_meta"], "doc_len": 118}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_meta_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_meta_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_meta_no_dataset(self):\n        \"\"\"Test reading only meta elements\"\"\"\n        bytestream = (b'\\x02\\x00\\x00\\x00\\x55\\x4C\\x04\\x00\\x0A\\x00\\x00\\x00'\n                      b'\\x02\\x00\\x02\\x00\\x55\\x49\\x16\\x00\\x31\\x2e\\x32\\x2e'\n                      b'\\x38\\x34\\x30\\x2e\\x31\\x30\\x30\\x30\\x38\\x2e\\x35\\x2e'\n                      b'\\x31\\x2e\\x31\\x2e\\x39\\x00\\x02\\x00\\x10\\x00\\x55\\x49'\n                      b'\\x12\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31\\x30'\n                      b'\\x30\\x30\\x38\\x2e\\x31\\x2e\\x32\\x00')\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'TransferSyntaxUID' in ds.file_meta\n        assert Dataset() == ds[:]\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_meta_no_dataset", "self", "test", "reading", "only", "meta", "elements", "bytestream", "b", "x02", "x00", "x00", "x00", "x55", "x4c", "x04", "x00", "x0a", "x00", "x00", "x00", "b", "x02", "x00", "x02", "x00", "x55", "x49", "x16", "x00", "x31", "x2e", "x32", "x2e", "b", "x38", "x34", "x30", "x2e", "x31", "x30", "x30", "x30", "x38", "x2e", "x35", "x2e", "b", "x31", "x2e", "x31", "x2e", "x39", "x00", "x02", "x00", "x10", "x00", "x55", "x49", "b", "x12", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "x30", "b", "x30", "x30", "x38", "x2e", "x31", "x2e", "x32", "x00", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds", "file_meta", "assert", "dataset", "ds"], "doc_len": 104}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_commandset_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_commandset_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_commandset_no_dataset(self):\n        \"\"\"Test reading only command set elements\"\"\"\n        bytestream = (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x38'\n                      b'\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x12\\x00\\x00'\n                      b'\\x00\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e\\x31'\n                      b'\\x30\\x30\\x30\\x38\\x2e\\x31\\x2e\\x31\\x00\\x00'\n                      b'\\x00\\x00\\x01\\x02\\x00\\x00\\x00\\x30\\x00\\x00'\n                      b'\\x00\\x10\\x01\\x02\\x00\\x00\\x00\\x07\\x00\\x00'\n                      b'\\x00\\x00\\x08\\x02\\x00\\x00\\x00\\x01\\x01')\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert 'MessageID' in ds\n        assert ds.preamble is None\n        assert Dataset() == ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_commandset_no_dataset", "self", "test", "reading", "only", "command", "set", "elements", "bytestream", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x38", "b", "x00", "x00", "x00", "x00", "x00", "x02", "x00", "x12", "x00", "x00", "b", "x00", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "x31", "b", "x30", "x30", "x30", "x38", "x2e", "x31", "x2e", "x31", "x00", "x00", "b", "x00", "x00", "x01", "x02", "x00", "x00", "x00", "x30", "x00", "x00", "b", "x00", "x10", "x01", "x02", "x00", "x00", "x00", "x07", "x00", "x00", "b", "x00", "x00", "x08", "x02", "x00", "x00", "x00", "x01", "x01", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "messageid", "in", "ds", "assert", "ds", "preamble", "is", "none", "assert", "dataset", "ds", "file_meta"], "doc_len": 111}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_file_meta_dataset_implicit_vr", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_file_meta_dataset_implicit_vr", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_file_meta_dataset_implicit_vr(self):\n        \"\"\"Test reading a file meta dataset that is implicit VR\"\"\"\n\n        bytestream = (b'\\x02\\x00\\x10\\x00\\x12\\x00\\x00\\x00'\n                      b'\\x31\\x2e\\x32\\x2e\\x38\\x34\\x30\\x2e'\n                      b'\\x31\\x30\\x30\\x30\\x38\\x2e\\x31\\x2e'\n                      b'\\x32\\x00')\n        fp = BytesIO(bytestream)\n        with pytest.warns(UserWarning):\n            ds = dcmread(fp, force=True)\n        assert 'TransferSyntaxUID' in ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_file_meta_dataset_implicit_vr", "self", "test", "reading", "a", "file", "meta", "dataset", "that", "is", "implicit", "vr", "bytestream", "b", "x02", "x00", "x10", "x00", "x12", "x00", "x00", "x00", "b", "x31", "x2e", "x32", "x2e", "x38", "x34", "x30", "x2e", "b", "x31", "x30", "x30", "x30", "x38", "x2e", "x31", "x2e", "b", "x32", "x00", "fp", "bytesio", "bytestream", "with", "pytest", "warns", "userwarning", "ds", "dcmread", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds", "file_meta"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_no_dataset", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_no_dataset", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_no_dataset(self):\n        \"\"\"Test reading no elements or preamble produces empty Dataset\"\"\"\n        bytestream = b''\n        fp = BytesIO(bytestream)\n        ds = dcmread(fp, force=True)\n        assert ds.preamble is None\n        assert Dataset() == ds.file_meta\n        assert Dataset() == ds[:]\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_no_dataset", "self", "test", "reading", "no", "elements", "or", "preamble", "produces", "empty", "dataset", "bytestream", "b", "fp", "bytesio", "bytestream", "ds", "dcmread", "fp", "force", "true", "assert", "ds", "preamble", "is", "none", "assert", "dataset", "ds", "file_meta", "assert", "dataset", "ds"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_empty_file", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_empty_file", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_empty_file(self):\n        \"\"\"Test reading no elements from file produces empty Dataset\"\"\"\n        with tempfile.NamedTemporaryFile() as f:\n            ds = dcmread(f, force=True)\n            assert ds.preamble is None\n            assert Dataset() == ds.file_meta\n            assert Dataset() == ds[:]\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_empty_file", "self", "test", "reading", "no", "elements", "from", "file", "produces", "empty", "dataset", "with", "tempfile", "namedtemporaryfile", "as", "f", "ds", "dcmread", "f", "force", "true", "assert", "ds", "preamble", "is", "none", "assert", "dataset", "ds", "file_meta", "assert", "dataset", "ds"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_filereader.py::TestReader.test_dcmread_does_not_raise", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReader", "func_name": "test_dcmread_does_not_raise", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReader\n    def test_dcmread_does_not_raise(self):\n        \"\"\"Test that reading from DicomBytesIO does not raise on EOF.\n        Regression test for #358.\"\"\"\n        ds = dcmread(mr_name)\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=True)\n        fp.seek(0)\n        de_gen = data_element_generator(fp, False, True)\n        try:\n            while True:\n                next(de_gen)\n        except StopIteration:\n            pass\n        except EOFError:\n            self.fail('Unexpected EOFError raised')\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreader", "def", "test_dcmread_does_not_raise", "self", "test", "that", "reading", "from", "dicombytesio", "does", "not", "raise", "on", "eof", "regression", "test", "for", "358", "ds", "dcmread", "mr_name", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "true", "fp", "seek", "0", "de_gen", "data_element_generator", "fp", "false", "true", "try", "while", "true", "next", "de_gen", "except", "stopiteration", "pass", "except", "eoferror", "self", "fail", "unexpected", "eoferror", "raised"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.setup", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def setup(self):\n        config.enforce_valid_values = False\n        self.ds_explicit = BytesIO(\n            b'\\x08\\x00\\x05\\x00CS\\x0a\\x00ISO_IR 100'  # SpecificCharacterSet\n            b'\\x08\\x00\\x20\\x00DA\\x08\\x0020000101'  # StudyDate\n        )\n        self.ds_implicit = BytesIO(\n            b'\\x08\\x00\\x05\\x00\\x0a\\x00\\x00\\x00ISO_IR 100'\n            b'\\x08\\x00\\x20\\x00\\x08\\x00\\x00\\x0020000101'\n        )\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "setup", "self", "config", "enforce_valid_values", "false", "self", "ds_explicit", "bytesio", "b", "x08", "x00", "x05", "x00cs", "x0a", "x00iso_ir", "100", "specificcharacterset", "b", "x08", "x00", "x20", "x00da", "x08", "x0020000101", "studydate", "self", "ds_implicit", "bytesio", "b", "x08", "x00", "x05", "x00", "x0a", "x00", "x00", "x00iso_ir", "100", "b", "x08", "x00", "x20", "x00", "x08", "x00", "x00", "x0020000101"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.teardown", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def teardown(self):\n        config.enforce_valid_values = False\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "teardown", "self", "config", "enforce_valid_values", "false"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.test_implicit_vr_expected_explicit_used", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "test_implicit_vr_expected_explicit_used", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def test_implicit_vr_expected_explicit_used(self):\n        msg = ('Expected implicit VR, but found explicit VR - '\n               'using explicit VR for reading')\n\n        with pytest.warns(UserWarning, match=msg):\n            ds = read_dataset(\n                self.ds_explicit, is_implicit_VR=True, is_little_endian=True\n            )\n        assert 'ISO_IR 100' == ds.SpecificCharacterSet\n        assert '20000101' == ds.StudyDate\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "test_implicit_vr_expected_explicit_used", "self", "msg", "expected", "implicit", "vr", "but", "found", "explicit", "vr", "using", "explicit", "vr", "for", "reading", "with", "pytest", "warns", "userwarning", "match", "msg", "ds", "read_dataset", "self", "ds_explicit", "is_implicit_vr", "true", "is_little_endian", "true", "assert", "iso_ir", "100", "ds", "specificcharacterset", "assert", "20000101", "ds", "studydate"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.test_implicit_vr_expected_explicit_used_strict", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "test_implicit_vr_expected_explicit_used_strict", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def test_implicit_vr_expected_explicit_used_strict(self):\n        config.enforce_valid_values = True\n        msg = ('Expected implicit VR, but found explicit VR - '\n               'using explicit VR for reading')\n\n        with pytest.raises(InvalidDicomError, match=msg):\n            read_dataset(\n                self.ds_explicit, is_implicit_VR=True, is_little_endian=True\n            )\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "test_implicit_vr_expected_explicit_used_strict", "self", "config", "enforce_valid_values", "true", "msg", "expected", "implicit", "vr", "but", "found", "explicit", "vr", "using", "explicit", "vr", "for", "reading", "with", "pytest", "raises", "invaliddicomerror", "match", "msg", "read_dataset", "self", "ds_explicit", "is_implicit_vr", "true", "is_little_endian", "true"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.test_explicit_vr_expected_implicit_used", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "test_explicit_vr_expected_implicit_used", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def test_explicit_vr_expected_implicit_used(self):\n        msg = ('Expected explicit VR, but found implicit VR - '\n               'using implicit VR for reading')\n\n        with pytest.warns(UserWarning, match=msg):\n            ds = read_dataset(\n                self.ds_implicit, is_implicit_VR=False, is_little_endian=True\n            )\n        assert 'ISO_IR 100' == ds.SpecificCharacterSet\n        assert '20000101' == ds.StudyDate\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "test_explicit_vr_expected_implicit_used", "self", "msg", "expected", "explicit", "vr", "but", "found", "implicit", "vr", "using", "implicit", "vr", "for", "reading", "with", "pytest", "warns", "userwarning", "match", "msg", "ds", "read_dataset", "self", "ds_implicit", "is_implicit_vr", "false", "is_little_endian", "true", "assert", "iso_ir", "100", "ds", "specificcharacterset", "assert", "20000101", "ds", "studydate"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_filereader.py::TestIncorrectVR.test_explicit_vr_expected_implicit_used_strict", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestIncorrectVR", "func_name": "test_explicit_vr_expected_implicit_used_strict", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestIncorrectVR\n    def test_explicit_vr_expected_implicit_used_strict(self):\n        config.enforce_valid_values = True\n        msg = ('Expected explicit VR, but found implicit VR - '\n               'using implicit VR for reading')\n        with pytest.raises(InvalidDicomError, match=msg):\n            read_dataset(\n                self.ds_implicit, is_implicit_VR=False, is_little_endian=True\n            )\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testincorrectvr", "def", "test_explicit_vr_expected_implicit_used_strict", "self", "config", "enforce_valid_values", "true", "msg", "expected", "explicit", "vr", "but", "found", "implicit", "vr", "using", "implicit", "vr", "for", "reading", "with", "pytest", "raises", "invaliddicomerror", "match", "msg", "read_dataset", "self", "ds_implicit", "is_implicit_vr", "false", "is_little_endian", "true"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filereader.py::TestUnknownVR.test_fail_decode_msg", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestUnknownVR", "func_name": "test_fail_decode_msg", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestUnknownVR\n    def test_fail_decode_msg(self, vr_bytes, str_output):\n        \"\"\"Regression test for #791.\"\"\"\n        # start the dataset with a valid tag (SpecificCharacterSet),\n        # as the first tag is used to check the VR\n        ds = read_dataset(\n            BytesIO(\n                b'\\x08\\x00\\x05\\x00CS\\x0a\\x00ISO_IR 100'\n                b'\\x08\\x00\\x06\\x00' +\n                vr_bytes +\n                b'\\x00\\x00\\x00\\x08\\x00\\x49'\n            ),\n            False, True\n        )\n        msg = (\n            r\"Unknown Value Representation '{}' in tag \\(0008, 0006\\)\"\n            .format(str_output)\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            print(ds)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testunknownvr", "def", "test_fail_decode_msg", "self", "vr_bytes", "str_output", "regression", "test", "for", "791", "start", "the", "dataset", "with", "a", "valid", "tag", "specificcharacterset", "as", "the", "first", "tag", "is", "used", "to", "check", "the", "vr", "ds", "read_dataset", "bytesio", "b", "x08", "x00", "x05", "x00cs", "x0a", "x00iso_ir", "100", "b", "x08", "x00", "x06", "x00", "vr_bytes", "b", "x00", "x00", "x00", "x08", "x00", "x49", "false", "true", "msg", "r", "unknown", "value", "representation", "in", "tag", "0008", "0006", "format", "str_output", "with", "pytest", "raises", "notimplementederror", "match", "msg", "print", "ds"], "doc_len": 77}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.setup", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def setup(self):\n        ds = Dataset()\n        ds.DoubleFloatPixelData = (b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                                   b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07')  # OD\n        ds.SelectorOLValue = (b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                              b'\\x01\\x01\\x02\\x03')  # VR of OL\n        ds.PotentialReasonsForProcedure = ['A', 'B',\n                                           'C']  # VR of UC, odd length\n        ds.StrainDescription = 'Test'  # Even length\n        ds.URNCodeValue = 'http://test.com'  # VR of UR\n        ds.RetrieveURL = 'ftp://test.com  '  # Test trailing spaces ignored\n        ds.DestinationAE = '    TEST  12    '  # 16 characters max for AE\n\n        self.fp = BytesIO()  # Implicit little\n        file_ds = FileDataset(self.fp, ds)\n        file_ds.is_implicit_VR = True\n        file_ds.is_little_endian = True\n        file_ds.save_as(self.fp, write_like_original=True)\n\n        self.fp_ex = BytesIO()  # Explicit little\n        file_ds = FileDataset(self.fp_ex, ds)\n        file_ds.is_implicit_VR = False\n        file_ds.is_little_endian = True\n        file_ds.save_as(self.fp_ex, write_like_original=True)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "setup", "self", "ds", "dataset", "ds", "doublefloatpixeldata", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "od", "ds", "selectorolvalue", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "vr", "of", "ol", "ds", "potentialreasonsforprocedure", "a", "b", "c", "vr", "of", "uc", "odd", "length", "ds", "straindescription", "test", "even", "length", "ds", "urncodevalue", "http", "test", "com", "vr", "of", "ur", "ds", "retrieveurl", "ftp", "test", "com", "test", "trailing", "spaces", "ignored", "ds", "destinationae", "test", "12", "16", "characters", "max", "for", "ae", "self", "fp", "bytesio", "implicit", "little", "file_ds", "filedataset", "self", "fp", "ds", "file_ds", "is_implicit_vr", "true", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp_ex", "bytesio", "explicit", "little", "file_ds", "filedataset", "self", "fp_ex", "ds", "file_ds", "is_implicit_vr", "false", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "self", "fp_ex", "write_like_original", "true"], "doc_len": 135}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_OD_implicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_OD_implicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_OD_implicit_little(self):\n        \"\"\"Check creation of OD DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp, force=True)\n        ref_elem = ds.get(0x7fe00009)\n        elem = DataElement(0x7fe00009, 'OD',\n                           b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                           b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_od_implicit_little", "self", "check", "creation", "of", "od", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp", "force", "true", "ref_elem", "ds", "get", "0x7fe00009", "elem", "dataelement", "0x7fe00009", "od", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "assert", "ref_elem", "elem"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_OD_explicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_OD_explicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_OD_explicit_little(self):\n        \"\"\"Check creation of OD DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp_ex, force=True)\n        ref_elem = ds.get(0x7fe00009)\n        elem = DataElement(0x7fe00009, 'OD',\n                           b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                           b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_od_explicit_little", "self", "check", "creation", "of", "od", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp_ex", "force", "true", "ref_elem", "ds", "get", "0x7fe00009", "elem", "dataelement", "0x7fe00009", "od", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "assert", "ref_elem", "elem"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_OL_implicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_OL_implicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_OL_implicit_little(self):\n        \"\"\"Check creation of OL DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp, force=True)\n        ref_elem = ds.get(0x00720075)\n        elem = DataElement(0x00720075, 'OL',\n                           b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                           b'\\x01\\x01\\x02\\x03')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_ol_implicit_little", "self", "check", "creation", "of", "ol", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp", "force", "true", "ref_elem", "ds", "get", "0x00720075", "elem", "dataelement", "0x00720075", "ol", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "assert", "ref_elem", "elem"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_OL_explicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_OL_explicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_OL_explicit_little(self):\n        \"\"\"Check creation of OL DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp_ex, force=True)\n        ref_elem = ds.get(0x00720075)\n        elem = DataElement(0x00720075, 'OL',\n                           b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                           b'\\x01\\x01\\x02\\x03')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_ol_explicit_little", "self", "check", "creation", "of", "ol", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp_ex", "force", "true", "ref_elem", "ds", "get", "0x00720075", "elem", "dataelement", "0x00720075", "ol", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "assert", "ref_elem", "elem"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_UC_implicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_UC_implicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_UC_implicit_little(self):\n        \"\"\"Check creation of DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp, force=True)\n        ref_elem = ds.get(0x00189908)\n        elem = DataElement(0x00189908, 'UC', ['A', 'B', 'C'])\n        assert ref_elem == elem\n\n        ds = dcmread(self.fp, force=True)\n        ref_elem = ds.get(0x00100212)\n        elem = DataElement(0x00100212, 'UC', 'Test')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_uc_implicit_little", "self", "check", "creation", "of", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp", "force", "true", "ref_elem", "ds", "get", "0x00189908", "elem", "dataelement", "0x00189908", "uc", "a", "b", "c", "assert", "ref_elem", "elem", "ds", "dcmread", "self", "fp", "force", "true", "ref_elem", "ds", "get", "0x00100212", "elem", "dataelement", "0x00100212", "uc", "test", "assert", "ref_elem", "elem"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_UC_explicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_UC_explicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_UC_explicit_little(self):\n        \"\"\"Check creation of DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp_ex, force=True)\n        ref_elem = ds.get(0x00189908)\n        elem = DataElement(0x00189908, 'UC', ['A', 'B', 'C'])\n        assert ref_elem == elem\n\n        ds = dcmread(self.fp_ex, force=True)\n        ref_elem = ds.get(0x00100212)\n        elem = DataElement(0x00100212, 'UC', 'Test')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_uc_explicit_little", "self", "check", "creation", "of", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp_ex", "force", "true", "ref_elem", "ds", "get", "0x00189908", "elem", "dataelement", "0x00189908", "uc", "a", "b", "c", "assert", "ref_elem", "elem", "ds", "dcmread", "self", "fp_ex", "force", "true", "ref_elem", "ds", "get", "0x00100212", "elem", "dataelement", "0x00100212", "uc", "test", "assert", "ref_elem", "elem"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_UR_implicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_UR_implicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_UR_implicit_little(self):\n        \"\"\"Check creation of DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp, force=True)\n        ref_elem = ds.get(0x00080120)  # URNCodeValue\n        elem = DataElement(0x00080120, 'UR', 'http://test.com')\n        assert ref_elem == elem\n\n        # Test trailing spaces ignored\n        ref_elem = ds.get(0x00081190)  # RetrieveURL\n        elem = DataElement(0x00081190, 'UR', 'ftp://test.com')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_ur_implicit_little", "self", "check", "creation", "of", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp", "force", "true", "ref_elem", "ds", "get", "0x00080120", "urncodevalue", "elem", "dataelement", "0x00080120", "ur", "http", "test", "com", "assert", "ref_elem", "elem", "test", "trailing", "spaces", "ignored", "ref_elem", "ds", "get", "0x00081190", "retrieveurl", "elem", "dataelement", "0x00081190", "ur", "ftp", "test", "com", "assert", "ref_elem", "elem"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_UR_explicit_little", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_UR_explicit_little", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_UR_explicit_little(self):\n        \"\"\"Check creation of DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp_ex, force=True)\n        ref_elem = ds.get(0x00080120)  # URNCodeValue\n        elem = DataElement(0x00080120, 'UR', 'http://test.com')\n        assert ref_elem == elem\n\n        # Test trailing spaces ignored\n        ref_elem = ds.get(0x00081190)  # RetrieveURL\n        elem = DataElement(0x00081190, 'UR', 'ftp://test.com')\n        assert ref_elem == elem\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_ur_explicit_little", "self", "check", "creation", "of", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp_ex", "force", "true", "ref_elem", "ds", "get", "0x00080120", "urncodevalue", "elem", "dataelement", "0x00080120", "ur", "http", "test", "com", "assert", "ref_elem", "elem", "test", "trailing", "spaces", "ignored", "ref_elem", "ds", "get", "0x00081190", "retrieveurl", "elem", "dataelement", "0x00081190", "ur", "ftp", "test", "com", "assert", "ref_elem", "elem"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadDataElement.test_read_AE", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadDataElement", "func_name": "test_read_AE", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadDataElement\n    def test_read_AE(self):\n        \"\"\"Check creation of AE DataElement from byte data works correctly.\"\"\"\n        ds = dcmread(self.fp, force=True)\n        assert 'TEST  12' == ds.DestinationAE\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreaddataelement", "def", "test_read_ae", "self", "check", "creation", "of", "ae", "dataelement", "from", "byte", "data", "works", "correctly", "ds", "dcmread", "self", "fp", "force", "true", "assert", "test", "12", "ds", "destinationae"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.setup", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def setup(self):\n        self.testfile_name = ct_name + \".tmp\"\n        shutil.copyfile(ct_name, self.testfile_name)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "setup", "self", "self", "testfile_name", "ct_name", "tmp", "shutil", "copyfile", "ct_name", "self", "testfile_name"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.teardown", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def teardown(self):\n        if os.path.exists(self.testfile_name):\n            os.remove(self.testfile_name)\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "teardown", "self", "if", "os", "path", "exists", "self", "testfile_name", "os", "remove", "self", "testfile_name"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.test_time_check", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "test_time_check", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def test_time_check(self):\n        \"\"\"Deferred read warns if file has been modified\"\"\"\n        ds = dcmread(self.testfile_name, defer_size='2 kB')\n        from time import sleep\n        sleep(0.1)\n        with open(self.testfile_name, \"r+\") as f:\n            f.write('\\0')  # \"touch\" the file\n\n        msg = r\"Deferred read warning -- file modification time has changed\"\n        with pytest.warns(UserWarning, match=msg):\n            ds.PixelData\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "test_time_check", "self", "deferred", "read", "warns", "if", "file", "has", "been", "modified", "ds", "dcmread", "self", "testfile_name", "defer_size", "2", "kb", "from", "time", "import", "sleep", "sleep", "0", "1", "with", "open", "self", "testfile_name", "r", "as", "f", "f", "write", "0", "touch", "the", "file", "msg", "r", "deferred", "read", "warning", "file", "modification", "time", "has", "changed", "with", "pytest", "warns", "userwarning", "match", "msg", "ds", "pixeldata"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.test_file_exists", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "test_file_exists", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def test_file_exists(self):\n        \"\"\"Deferred read raises error if file no longer exists.\"\"\"\n        ds = dcmread(self.testfile_name, defer_size=2000)\n        os.remove(self.testfile_name)\n        with pytest.raises(IOError):\n            ds.PixelData\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "test_file_exists", "self", "deferred", "read", "raises", "error", "if", "file", "no", "longer", "exists", "ds", "dcmread", "self", "testfile_name", "defer_size", "2000", "os", "remove", "self", "testfile_name", "with", "pytest", "raises", "ioerror", "ds", "pixeldata"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.test_values_identical", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "test_values_identical", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def test_values_identical(self):\n        \"\"\"Deferred values exactly matches normal read.\"\"\"\n        ds_norm = dcmread(self.testfile_name)\n        ds_defer = dcmread(self.testfile_name, defer_size=2000)\n        for data_elem in ds_norm:\n            tag = data_elem.tag\n            assert data_elem.value == ds_defer[tag].value\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "test_values_identical", "self", "deferred", "values", "exactly", "matches", "normal", "read", "ds_norm", "dcmread", "self", "testfile_name", "ds_defer", "dcmread", "self", "testfile_name", "defer_size", "2000", "for", "data_elem", "in", "ds_norm", "tag", "data_elem", "tag", "assert", "data_elem", "value", "ds_defer", "tag", "value"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filereader.py::TestDeferredRead.test_zipped_deferred", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDeferredRead", "func_name": "test_zipped_deferred", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDeferredRead\n    def test_zipped_deferred(self):\n        \"\"\"Deferred values from a gzipped file works.\"\"\"\n        # Arose from issue 103 \"Error for defer_size read of gzip file object\"\n        fobj = gzip.open(gzip_name)\n        ds = dcmread(fobj, defer_size=1)\n        fobj.close()\n        # before the fix, this threw an error as file reading was not in\n        # the right place, it was re-opened as a normal file, not a zip file\n        ds.InstanceNumber\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdeferredread", "def", "test_zipped_deferred", "self", "deferred", "values", "from", "a", "gzipped", "file", "works", "arose", "from", "issue", "103", "error", "for", "defer_size", "read", "of", "gzip", "file", "object", "fobj", "gzip", "open", "gzip_name", "ds", "dcmread", "fobj", "defer_size", "1", "fobj", "close", "before", "the", "fix", "this", "threw", "an", "error", "as", "file", "reading", "was", "not", "in", "the", "right", "place", "it", "was", "re", "opened", "as", "a", "normal", "file", "not", "a", "zip", "file", "ds", "instancenumber"], "doc_len": 68}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadTruncatedFile.testReadFileWithMissingPixelData", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadTruncatedFile", "func_name": "testReadFileWithMissingPixelData", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadTruncatedFile\n    def testReadFileWithMissingPixelData(self):\n        mr = dcmread(truncated_mr_name)\n        mr.decode()\n        assert 'CompressedSamples^MR1' == mr.PatientName\n        assert mr.PatientName == mr[0x10, 0x10].value\n        DS = pydicom.valuerep.DS\n        assert [DS('0.3125'), DS('0.3125')] == mr.PixelSpacing\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreadtruncatedfile", "def", "testreadfilewithmissingpixeldata", "self", "mr", "dcmread", "truncated_mr_name", "mr", "decode", "assert", "compressedsamples", "mr1", "mr", "patientname", "assert", "mr", "patientname", "mr", "0x10", "0x10", "value", "ds", "pydicom", "valuerep", "ds", "assert", "ds", "0", "3125", "ds", "0", "3125", "mr", "pixelspacing"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_filereader.py::TestReadTruncatedFile.testReadFileWithMissingPixelDataArray", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestReadTruncatedFile", "func_name": "testReadFileWithMissingPixelDataArray", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestReadTruncatedFile\n    def testReadFileWithMissingPixelDataArray(self):\n        mr = dcmread(truncated_mr_name)\n        mr.decode()\n        # Need to escape brackets\n        msg = (\n            r\"The length of the pixel data in the dataset \\(8130 bytes\\) \"\n            r\"doesn't match the expected length \\(8192 bytes\\). \"\n            r\"The dataset may be corrupted or there may be an issue with \"\n            r\"the pixel data handler.\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            mr.pixel_array\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testreadtruncatedfile", "def", "testreadfilewithmissingpixeldataarray", "self", "mr", "dcmread", "truncated_mr_name", "mr", "decode", "need", "to", "escape", "brackets", "msg", "r", "the", "length", "of", "the", "pixel", "data", "in", "the", "dataset", "8130", "bytes", "r", "doesn", "t", "match", "the", "expected", "length", "8192", "bytes", "r", "the", "dataset", "may", "be", "corrupted", "or", "there", "may", "be", "an", "issue", "with", "r", "the", "pixel", "data", "handler", "with", "pytest", "raises", "valueerror", "match", "msg", "mr", "pixel_array"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_filereader.py::TestFileLike.test_read_file_given_file_object", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestFileLike", "func_name": "test_read_file_given_file_object", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestFileLike\n    def test_read_file_given_file_object(self):\n        \"\"\"filereader: can read using already opened file............\"\"\"\n        f = open(ct_name, 'rb')\n        ct = dcmread(f)\n        # Tests here simply repeat testCT -- perhaps should collapse\n        # the code together?\n        got = ct.ImagePositionPatient\n        DS = pydicom.valuerep.DS\n        expected = [DS('-158.135803'), DS('-179.035797'), DS('-75.699997')]\n        assert expected == got\n        assert '1.3.6.1.4.1.5962.2' == ct.file_meta.ImplementationClassUID\n        value = ct.file_meta[0x2, 0x12].value\n        assert ct.file_meta.ImplementationClassUID == value\n\n        # (0020, 0032) Image Position (Patient)\n        # [-158.13580300000001, -179.035797, -75.699996999999996]\n        got = ct.ImagePositionPatient\n        expected = [DS('-158.135803'), DS('-179.035797'), DS('-75.699997')]\n        assert expected == got\n        assert 128 == ct.Rows\n        assert 128 == ct.Columns\n        assert 16 == ct.BitsStored\n        assert 128 * 128 * 2 == len(ct.PixelData)\n\n        # Should also be able to close the file ourselves without\n        # exception raised:\n        f.close()\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testfilelike", "def", "test_read_file_given_file_object", "self", "filereader", "can", "read", "using", "already", "opened", "file", "f", "open", "ct_name", "rb", "ct", "dcmread", "f", "tests", "here", "simply", "repeat", "testct", "perhaps", "should", "collapse", "the", "code", "together", "got", "ct", "imagepositionpatient", "ds", "pydicom", "valuerep", "ds", "expected", "ds", "158", "135803", "ds", "179", "035797", "ds", "75", "699997", "assert", "expected", "got", "assert", "1", "3", "6", "1", "4", "1", "5962", "2", "ct", "file_meta", "implementationclassuid", "value", "ct", "file_meta", "0x2", "0x12", "value", "assert", "ct", "file_meta", "implementationclassuid", "value", "0020", "0032", "image", "position", "patient", "158", "13580300000001", "179", "035797", "75", "699996999999996", "got", "ct", "imagepositionpatient", "expected", "ds", "158", "135803", "ds", "179", "035797", "ds", "75", "699997", "assert", "expected", "got", "assert", "128", "ct", "rows", "assert", "128", "ct", "columns", "assert", "16", "ct", "bitsstored", "assert", "128", "128", "2", "len", "ct", "pixeldata", "should", "also", "be", "able", "to", "close", "the", "file", "ourselves", "without", "exception", "raised", "f", "close"], "doc_len": 136}
{"doc_id": "pydicom/tests/test_filereader.py::TestFileLike.test_read_file_given_file_like_object", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestFileLike", "func_name": "test_read_file_given_file_like_object", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestFileLike\n    def test_read_file_given_file_like_object(self):\n        \"\"\"filereader: can read using a file-like (BytesIO) file....\"\"\"\n        with open(ct_name, 'rb') as f:\n            file_like = BytesIO(f.read())\n        ct = dcmread(file_like)\n        # Tests here simply repeat some of testCT test\n        got = ct.ImagePositionPatient\n        DS = pydicom.valuerep.DS\n        expected = [DS('-158.135803'), DS('-179.035797'), DS('-75.699997')]\n        assert expected == got\n        assert 128 * 128 * 2 == len(ct.PixelData)\n        # Should also be able to close the file ourselves without\n        # exception raised:\n        file_like.close()\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testfilelike", "def", "test_read_file_given_file_like_object", "self", "filereader", "can", "read", "using", "a", "file", "like", "bytesio", "file", "with", "open", "ct_name", "rb", "as", "f", "file_like", "bytesio", "f", "read", "ct", "dcmread", "file_like", "tests", "here", "simply", "repeat", "some", "of", "testct", "test", "got", "ct", "imagepositionpatient", "ds", "pydicom", "valuerep", "ds", "expected", "ds", "158", "135803", "ds", "179", "035797", "ds", "75", "699997", "assert", "expected", "got", "assert", "128", "128", "2", "len", "ct", "pixeldata", "should", "also", "be", "able", "to", "close", "the", "file", "ourselves", "without", "exception", "raised", "file_like", "close"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_filereader.py::TestDataElementGenerator.test_little_endian_explicit", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDataElementGenerator", "func_name": "test_little_endian_explicit", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDataElementGenerator\n    def test_little_endian_explicit(self):\n        \"\"\"Test reading little endian explicit VR data\"\"\"\n        # (0010, 0010) PatientName PN 6 ABCDEF\n        bytestream = (b'\\x10\\x00\\x10\\x00'\n                      b'PN'\n                      b'\\x06\\x00'\n                      b'ABCDEF')\n        fp = BytesIO(bytestream)\n        # fp, is_implicit_VR, is_little_endian,\n        gen = data_element_generator(fp, False, True)\n        elem = DataElement(0x00100010, 'PN', 'ABCDEF')\n        assert elem == DataElement_from_raw(next(gen), 'ISO_IR 100')\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdataelementgenerator", "def", "test_little_endian_explicit", "self", "test", "reading", "little", "endian", "explicit", "vr", "data", "0010", "0010", "patientname", "pn", "6", "abcdef", "bytestream", "b", "x10", "x00", "x10", "x00", "b", "pn", "b", "x06", "x00", "b", "abcdef", "fp", "bytesio", "bytestream", "fp", "is_implicit_vr", "is_little_endian", "gen", "data_element_generator", "fp", "false", "true", "elem", "dataelement", "0x00100010", "pn", "abcdef", "assert", "elem", "dataelement_from_raw", "next", "gen", "iso_ir", "100"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filereader.py::TestDataElementGenerator.test_little_endian_implicit", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDataElementGenerator", "func_name": "test_little_endian_implicit", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDataElementGenerator\n    def test_little_endian_implicit(self):\n        \"\"\"Test reading little endian implicit VR data\"\"\"\n        # (0010, 0010) PatientName PN 6 ABCDEF\n        bytestream = b'\\x10\\x00\\x10\\x00' \\\n                     b'\\x06\\x00\\x00\\x00' \\\n                     b'ABCDEF'\n        fp = BytesIO(bytestream)\n        gen = data_element_generator(fp, is_implicit_VR=True,\n                                     is_little_endian=True)\n        elem = DataElement(0x00100010, 'PN', 'ABCDEF')\n        assert elem == DataElement_from_raw(next(gen), 'ISO_IR 100')\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdataelementgenerator", "def", "test_little_endian_implicit", "self", "test", "reading", "little", "endian", "implicit", "vr", "data", "0010", "0010", "patientname", "pn", "6", "abcdef", "bytestream", "b", "x10", "x00", "x10", "x00", "b", "x06", "x00", "x00", "x00", "b", "abcdef", "fp", "bytesio", "bytestream", "gen", "data_element_generator", "fp", "is_implicit_vr", "true", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "pn", "abcdef", "assert", "elem", "dataelement_from_raw", "next", "gen", "iso_ir", "100"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_filereader.py::TestDataElementGenerator.test_big_endian_explicit", "file_path": "pydicom/tests/test_filereader.py", "class_name": "TestDataElementGenerator", "func_name": "test_big_endian_explicit", "text": "文件路径: pydicom/tests/test_filereader.py, 类名: TestDataElementGenerator\n    def test_big_endian_explicit(self):\n        \"\"\"Test reading big endian explicit VR data\"\"\"\n        # (0010, 0010) PatientName PN 6 ABCDEF\n        bytestream = b'\\x00\\x10\\x00\\x10' \\\n                     b'PN' \\\n                     b'\\x00\\x06' \\\n                     b'ABCDEF'\n        fp = BytesIO(bytestream)\n        # fp, is_implicit_VR, is_little_endian,\n        gen = data_element_generator(fp, False, False)\n        elem = DataElement(0x00100010, 'PN', 'ABCDEF')\n        assert elem == DataElement_from_raw(next(gen), 'ISO_IR 100')\n", "tokens": ["pydicom", "tests", "test_filereader", "py", "testdataelementgenerator", "def", "test_big_endian_explicit", "self", "test", "reading", "big", "endian", "explicit", "vr", "data", "0010", "0010", "patientname", "pn", "6", "abcdef", "bytestream", "b", "x00", "x10", "x00", "x10", "b", "pn", "b", "x00", "x06", "b", "abcdef", "fp", "bytesio", "bytestream", "fp", "is_implicit_vr", "is_little_endian", "gen", "data_element_generator", "fp", "false", "false", "elem", "dataelement", "0x00100010", "pn", "abcdef", "assert", "elem", "dataelement_from_raw", "next", "gen", "iso_ir", "100"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filewriter.py::files_identical", "file_path": "pydicom/tests/test_filewriter.py", "class_name": null, "func_name": "files_identical", "text": "文件路径: pydicom/tests/test_filewriter.py\ndef files_identical(a, b):\n    \"\"\"Return a tuple (file a == file b, index of first difference)\"\"\"\n    with open(a, \"rb\") as A:\n        with open(b, \"rb\") as B:\n            a_bytes = A.read()\n            b_bytes = B.read()\n\n    return bytes_identical(a_bytes, b_bytes)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "def", "files_identical", "a", "b", "return", "a", "tuple", "file", "a", "file", "b", "index", "of", "first", "difference", "with", "open", "a", "rb", "as", "a", "with", "open", "b", "rb", "as", "b", "a_bytes", "a", "read", "b_bytes", "b", "read", "return", "bytes_identical", "a_bytes", "b_bytes"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_filewriter.py::bytes_identical", "file_path": "pydicom/tests/test_filewriter.py", "class_name": null, "func_name": "bytes_identical", "text": "文件路径: pydicom/tests/test_filewriter.py\ndef bytes_identical(a_bytes, b_bytes):\n    \"\"\"Return a tuple\n       (bytes a == bytes b, index of first difference)\"\"\"\n    if len(a_bytes) != len(b_bytes):\n        return False, min([len(a_bytes), len(b_bytes)])\n    elif a_bytes == b_bytes:\n        return True, 0  # True, dummy argument\n    else:\n        pos = 0\n        while a_bytes[pos] == b_bytes[pos]:\n            pos += 1\n        return False, pos  # False if not identical, position of 1st diff\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "def", "bytes_identical", "a_bytes", "b_bytes", "return", "a", "tuple", "bytes", "a", "bytes", "b", "index", "of", "first", "difference", "if", "len", "a_bytes", "len", "b_bytes", "return", "false", "min", "len", "a_bytes", "len", "b_bytes", "elif", "a_bytes", "b_bytes", "return", "true", "0", "true", "dummy", "argument", "else", "pos", "0", "while", "a_bytes", "pos", "b_bytes", "pos", "pos", "1", "return", "false", "pos", "false", "if", "not", "identical", "position", "of", "1st", "diff"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def setup(self):\n        self.file_out = TemporaryFile('w+b')\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "setup", "self", "self", "file_out", "temporaryfile", "w", "b"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.teardown", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def teardown(self):\n        self.file_out.close()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "teardown", "self", "self", "file_out", "close"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.compare", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "compare", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def compare(self, in_filename):\n        \"\"\"Read Dataset from in_filename, write to file, compare\"\"\"\n        with open(in_filename, 'rb') as f:\n            bytes_in = BytesIO(f.read())\n            bytes_in.seek(0)\n\n        ds = dcmread(bytes_in)\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        bytes_out = BytesIO(self.file_out.read())\n        bytes_in.seek(0)\n        bytes_out.seek(0)\n        same, pos = bytes_identical(bytes_in.getvalue(), bytes_out.getvalue())\n        assert same\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "compare", "self", "in_filename", "read", "dataset", "from", "in_filename", "write", "to", "file", "compare", "with", "open", "in_filename", "rb", "as", "f", "bytes_in", "bytesio", "f", "read", "bytes_in", "seek", "0", "ds", "dcmread", "bytes_in", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "bytes_out", "bytesio", "self", "file_out", "read", "bytes_in", "seek", "0", "bytes_out", "seek", "0", "same", "pos", "bytes_identical", "bytes_in", "getvalue", "bytes_out", "getvalue", "assert", "same"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.compare_bytes", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "compare_bytes", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def compare_bytes(self, bytes_in, bytes_out):\n        \"\"\"Compare two bytestreams for equality\"\"\"\n        same, pos = bytes_identical(bytes_in, bytes_out)\n        assert same\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "compare_bytes", "self", "bytes_in", "bytes_out", "compare", "two", "bytestreams", "for", "equality", "same", "pos", "bytes_identical", "bytes_in", "bytes_out", "assert", "same"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testRTPlan", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testRTPlan", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testRTPlan(self):\n        \"\"\"Input file, write back and verify\n           them identical (RT Plan file)\"\"\"\n        self.compare(rtplan_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testrtplan", "self", "input", "file", "write", "back", "and", "verify", "them", "identical", "rt", "plan", "file", "self", "compare", "rtplan_name"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testRTDose", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testRTDose", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testRTDose(self):\n        \"\"\"Input file, write back and\n           verify them identical (RT Dose file)\"\"\"\n        self.compare(rtdose_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testrtdose", "self", "input", "file", "write", "back", "and", "verify", "them", "identical", "rt", "dose", "file", "self", "compare", "rtdose_name"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testCT", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testCT", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testCT(self):\n        \"\"\"Input file, write back and\n           verify them identical (CT file).....\"\"\"\n        self.compare(ct_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testct", "self", "input", "file", "write", "back", "and", "verify", "them", "identical", "ct", "file", "self", "compare", "ct_name"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testMR", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testMR", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testMR(self):\n        \"\"\"Input file, write back and verify\n           them identical (MR file).....\"\"\"\n        self.compare(mr_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testmr", "self", "input", "file", "write", "back", "and", "verify", "them", "identical", "mr", "file", "self", "compare", "mr_name"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testUnicode", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testUnicode", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testUnicode(self):\n        \"\"\"Ensure decoded string DataElements\n           are written to file properly\"\"\"\n        self.compare(unicode_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testunicode", "self", "ensure", "decoded", "string", "dataelements", "are", "written", "to", "file", "properly", "self", "compare", "unicode_name"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testMultiPN", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testMultiPN", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testMultiPN(self):\n        \"\"\"Ensure multiple Person Names are written\n           to the file correctly.\"\"\"\n        self.compare(multiPN_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testmultipn", "self", "ensure", "multiple", "person", "names", "are", "written", "to", "the", "file", "correctly", "self", "compare", "multipn_name"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testJPEG2000", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testJPEG2000", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testJPEG2000(self):\n        \"\"\"Input file, write back and verify\n           them identical (JPEG2K file).\"\"\"\n        self.compare(jpeg_name)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testjpeg2000", "self", "input", "file", "write", "back", "and", "verify", "them", "identical", "jpeg2k", "file", "self", "compare", "jpeg_name"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testListItemWriteBack", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testListItemWriteBack", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testListItemWriteBack(self):\n        \"\"\"Change item in a list and confirm\n          it is written to file\"\"\"\n        DS_expected = 0\n        CS_expected = \"new\"\n        SS_expected = 999\n        ds = dcmread(ct_name)\n        ds.ImagePositionPatient[2] = DS_expected\n        ds.ImageType[1] = CS_expected\n        ds[(0x0043, 0x1012)].value[0] = SS_expected\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        # Now read it back in and check that the values were changed\n        ds = dcmread(self.file_out)\n        assert CS_expected == ds.ImageType[1]\n        assert SS_expected == ds[0x00431012].value[0]\n        assert DS_expected == ds.ImagePositionPatient[2]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testlistitemwriteback", "self", "change", "item", "in", "a", "list", "and", "confirm", "it", "is", "written", "to", "file", "ds_expected", "0", "cs_expected", "new", "ss_expected", "999", "ds", "dcmread", "ct_name", "ds", "imagepositionpatient", "2", "ds_expected", "ds", "imagetype", "1", "cs_expected", "ds", "0x0043", "0x1012", "value", "0", "ss_expected", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "now", "read", "it", "back", "in", "and", "check", "that", "the", "values", "were", "changed", "ds", "dcmread", "self", "file_out", "assert", "cs_expected", "ds", "imagetype", "1", "assert", "ss_expected", "ds", "0x00431012", "value", "0", "assert", "ds_expected", "ds", "imagepositionpatient", "2"], "doc_len": 85}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.testwrite_short_uid", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "testwrite_short_uid", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def testwrite_short_uid(self):\n        ds = dcmread(rtplan_name)\n        ds.SOPInstanceUID = \"1.2\"\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        ds = dcmread(self.file_out)\n        assert \"1.2\" == ds.SOPInstanceUID\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "testwrite_short_uid", "self", "ds", "dcmread", "rtplan_name", "ds", "sopinstanceuid", "1", "2", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "ds", "dcmread", "self", "file_out", "assert", "1", "2", "ds", "sopinstanceuid"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.test_write_no_ts", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "test_write_no_ts", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def test_write_no_ts(self):\n        \"\"\"Test reading a file with no ts and writing it out identically.\"\"\"\n        ds = dcmread(no_ts)\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        with open(no_ts, 'rb') as ref_file:\n            written_bytes = self.file_out.read()\n            read_bytes = ref_file.read()\n            self.compare_bytes(read_bytes, written_bytes)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "test_write_no_ts", "self", "test", "reading", "a", "file", "with", "no", "ts", "and", "writing", "it", "out", "identically", "ds", "dcmread", "no_ts", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "with", "open", "no_ts", "rb", "as", "ref_file", "written_bytes", "self", "file_out", "read", "read_bytes", "ref_file", "read", "self", "compare_bytes", "read_bytes", "written_bytes"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.test_write_double_filemeta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "test_write_double_filemeta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def test_write_double_filemeta(self):\n        \"\"\"Test writing file meta from Dataset doesn't work\"\"\"\n        ds = dcmread(ct_name)\n        ds.TransferSyntaxUID = '1.1'\n        with pytest.raises(ValueError):\n            ds.save_as(self.file_out)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "test_write_double_filemeta", "self", "test", "writing", "file", "meta", "from", "dataset", "doesn", "t", "work", "ds", "dcmread", "ct_name", "ds", "transfersyntaxuid", "1", "1", "with", "pytest", "raises", "valueerror", "ds", "save_as", "self", "file_out"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.test_write_ffff_ffff", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "test_write_ffff_ffff", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def test_write_ffff_ffff(self):\n        \"\"\"Test writing element (FFFF, FFFF) to file #92\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.file_meta = Dataset()\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        ds.add_new(0xFFFFFFFF, 'LO', '123456')\n        ds.save_as(fp, write_like_original=True)\n\n        fp.seek(0)\n        ds = dcmread(fp, force=True)\n        assert ds[0xFFFFFFFF].value == b'123456'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "test_write_ffff_ffff", "self", "test", "writing", "element", "ffff", "ffff", "to", "file", "92", "fp", "dicombytesio", "ds", "dataset", "ds", "file_meta", "dataset", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "ds", "add_new", "0xffffffff", "lo", "123456", "ds", "save_as", "fp", "write_like_original", "true", "fp", "seek", "0", "ds", "dcmread", "fp", "force", "true", "assert", "ds", "0xffffffff", "value", "b", "123456"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFile.test_write_removes_grouplength", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFile", "func_name": "test_write_removes_grouplength", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFile\n    def test_write_removes_grouplength(self):\n        ds = dcmread(color_pl_name)\n        assert 0x00080000 in ds\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        ds = dcmread(self.file_out)\n        # group length has been removed\n        assert 0x00080000 not in ds\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefile", "def", "test_write_removes_grouplength", "self", "ds", "dcmread", "color_pl_name", "assert", "0x00080000", "in", "ds", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "ds", "dcmread", "self", "file_out", "group", "length", "has", "been", "removed", "assert", "0x00080000", "not", "in", "ds"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWriteDateTime.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWriteDateTime", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWriteDateTime\n    def setup(self):\n        config.datetime_conversion = True\n        self.file_out = TemporaryFile('w+b')\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwritedatetime", "def", "setup", "self", "config", "datetime_conversion", "true", "self", "file_out", "temporaryfile", "w", "b"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWriteDateTime.teardown", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWriteDateTime", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWriteDateTime\n    def teardown(self):\n        config.datetime_conversion = False\n        self.file_out.close()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwritedatetime", "def", "teardown", "self", "config", "datetime_conversion", "false", "self", "file_out", "close"], "doc_len": 14}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWriteDateTime.test_multivalue_DA", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWriteDateTime", "func_name": "test_multivalue_DA", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWriteDateTime\n    def test_multivalue_DA(self):\n        \"\"\"Write DA/DT/TM data elements..........\"\"\"\n        multi_DA_expected = (date(1961, 8, 4), date(1963, 11, 22))\n        DA_expected = date(1961, 8, 4)\n        tzinfo = timezone(timedelta(seconds=-21600), '-0600')\n        multi_DT_expected = (datetime(1961, 8, 4), datetime(\n            1963, 11, 22, 12, 30, 0, 0,\n            timezone(timedelta(seconds=-21600), '-0600')))\n        multi_TM_expected = (time(1, 23, 45), time(11, 11, 11))\n        TM_expected = time(11, 11, 11, 1)\n        ds = dcmread(datetime_name)\n        # Add date/time data elements\n        ds.CalibrationDate = MultiValue(DA, multi_DA_expected)\n        ds.DateOfLastCalibration = DA(DA_expected)\n        ds.ReferencedDateTime = MultiValue(DT, multi_DT_expected)\n        ds.CalibrationTime = MultiValue(TM, multi_TM_expected)\n        ds.TimeOfLastCalibration = TM(TM_expected)\n        ds.save_as(self.file_out, write_like_original=True)\n        self.file_out.seek(0)\n        # Now read it back in and check the values are as expected\n        ds = dcmread(self.file_out)\n        assert all([a == b\n                    for a, b in zip(ds.CalibrationDate, multi_DA_expected)])\n        assert DA_expected == ds.DateOfLastCalibration\n        assert all([a == b\n                    for a, b in zip(ds.ReferencedDateTime, multi_DT_expected)])\n        assert all([a == b\n                    for a, b in zip(ds.CalibrationTime, multi_TM_expected)])\n        assert TM_expected == ds.TimeOfLastCalibration\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwritedatetime", "def", "test_multivalue_da", "self", "write", "da", "dt", "tm", "data", "elements", "multi_da_expected", "date", "1961", "8", "4", "date", "1963", "11", "22", "da_expected", "date", "1961", "8", "4", "tzinfo", "timezone", "timedelta", "seconds", "21600", "0600", "multi_dt_expected", "datetime", "1961", "8", "4", "datetime", "1963", "11", "22", "12", "30", "0", "0", "timezone", "timedelta", "seconds", "21600", "0600", "multi_tm_expected", "time", "1", "23", "45", "time", "11", "11", "11", "tm_expected", "time", "11", "11", "11", "1", "ds", "dcmread", "datetime_name", "add", "date", "time", "data", "elements", "ds", "calibrationdate", "multivalue", "da", "multi_da_expected", "ds", "dateoflastcalibration", "da", "da_expected", "ds", "referenceddatetime", "multivalue", "dt", "multi_dt_expected", "ds", "calibrationtime", "multivalue", "tm", "multi_tm_expected", "ds", "timeoflastcalibration", "tm", "tm_expected", "ds", "save_as", "self", "file_out", "write_like_original", "true", "self", "file_out", "seek", "0", "now", "read", "it", "back", "in", "and", "check", "the", "values", "are", "as", "expected", "ds", "dcmread", "self", "file_out", "assert", "all", "a", "b", "for", "a", "b", "in", "zip", "ds", "calibrationdate", "multi_da_expected", "assert", "da_expected", "ds", "dateoflastcalibration", "assert", "all", "a", "b", "for", "a", "b", "in", "zip", "ds", "referenceddatetime", "multi_dt_expected", "assert", "all", "a", "b", "for", "a", "b", "in", "zip", "ds", "calibrationtime", "multi_tm_expected", "assert", "tm_expected", "ds", "timeoflastcalibration"], "doc_len": 168}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def setup(self):\n        # Create a dummy (in memory) file to write to\n        self.f1 = DicomBytesIO()\n        self.f1.is_little_endian = True\n        self.f1.is_implicit_VR = True\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "setup", "self", "create", "a", "dummy", "in", "memory", "file", "to", "write", "to", "self", "f1", "dicombytesio", "self", "f1", "is_little_endian", "true", "self", "f1", "is_implicit_vr", "true"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.encode_element", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "encode_element", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def encode_element(elem, is_implicit_VR=True, is_little_endian=True):\n        \"\"\"Return the encoded `elem`.\n\n        Parameters\n        ----------\n        elem : pydicom.dataelem.DataElement\n            The element to encode\n        is_implicit_VR : bool\n            Encode using implicit VR, default True\n        is_little_endian : bool\n            Encode using little endian, default True\n\n        Returns\n        -------\n        str or bytes\n            The encoded element as str (python2) or bytes (python3)\n        \"\"\"\n        with DicomBytesIO() as fp:\n            fp.is_implicit_VR = is_implicit_VR\n            fp.is_little_endian = is_little_endian\n            write_data_element(fp, elem)\n            return fp.parent.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "encode_element", "elem", "is_implicit_vr", "true", "is_little_endian", "true", "return", "the", "encoded", "elem", "parameters", "elem", "pydicom", "dataelem", "dataelement", "the", "element", "to", "encode", "is_implicit_vr", "bool", "encode", "using", "implicit", "vr", "default", "true", "is_little_endian", "bool", "encode", "using", "little", "endian", "default", "true", "returns", "str", "or", "bytes", "the", "encoded", "element", "as", "str", "python2", "or", "bytes", "python3", "with", "dicombytesio", "as", "fp", "fp", "is_implicit_vr", "is_implicit_vr", "fp", "is_little_endian", "is_little_endian", "write_data_element", "fp", "elem", "return", "fp", "parent", "getvalue"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_empty_AT", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_empty_AT", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_empty_AT(self):\n        \"\"\"Write empty AT correctly..........\"\"\"\n        # Was issue 74\n        data_elem = DataElement(0x00280009, \"AT\", [])\n        expected = hex2bytes((\n            \" 28 00 09 00\"  # (0028,0009) Frame Increment Pointer\n            \" 00 00 00 00\"  # length 0\n        ))\n        write_data_element(self.f1, data_elem)\n        assert expected == self.f1.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_empty_at", "self", "write", "empty", "at", "correctly", "was", "issue", "74", "data_elem", "dataelement", "0x00280009", "at", "expected", "hex2bytes", "28", "00", "09", "00", "0028", "0009", "frame", "increment", "pointer", "00", "00", "00", "00", "length", "0", "write_data_element", "self", "f1", "data_elem", "assert", "expected", "self", "f1", "getvalue"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.check_data_element", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "check_data_element", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def check_data_element(self, data_elem, expected):\n        encoded_elem = self.encode_element(data_elem)\n        assert expected == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "check_data_element", "self", "data_elem", "expected", "encoded_elem", "self", "encode_element", "data_elem", "assert", "expected", "encoded_elem"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_empty_LO", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_empty_LO", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_empty_LO(self):\n        data_elem = DataElement(0x00080070, 'LO', None)\n        expected = (b'\\x08\\x00\\x70\\x00'  # tag\n                    b'\\x00\\x00\\x00\\x00'  # length\n                    )  # value\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_empty_lo", "self", "data_elem", "dataelement", "0x00080070", "lo", "none", "expected", "b", "x08", "x00", "x70", "x00", "tag", "b", "x00", "x00", "x00", "x00", "length", "value", "self", "check_data_element", "data_elem", "expected"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_DA", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_DA", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_DA(self):\n        data_elem = DataElement(0x00080022, 'DA', '20000101')\n        expected = (b'\\x08\\x00\\x22\\x00'  # tag\n                    b'\\x08\\x00\\x00\\x00'  # length\n                    b'20000101')  # value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080022, 'DA', date(2000, 1, 1))\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_da", "self", "data_elem", "dataelement", "0x00080022", "da", "20000101", "expected", "b", "x08", "x00", "x22", "x00", "tag", "b", "x08", "x00", "x00", "x00", "length", "b", "20000101", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080022", "da", "date", "2000", "1", "1", "self", "check_data_element", "data_elem", "expected"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_multi_DA", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_multi_DA", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_multi_DA(self):\n        data_elem = DataElement(0x0014407E, 'DA', ['20100101', b'20101231'])\n        expected = (b'\\x14\\x00\\x7E\\x40'  # tag\n                    b'\\x12\\x00\\x00\\x00'  # length\n                    b'20100101\\\\20101231 ')  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0014407E, 'DA', [date(2010, 1, 1),\n                                                   date(2010, 12, 31)])\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_multi_da", "self", "data_elem", "dataelement", "0x0014407e", "da", "20100101", "b", "20101231", "expected", "b", "x14", "x00", "x7e", "x40", "tag", "b", "x12", "x00", "x00", "x00", "length", "b", "20100101", "20101231", "padded", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0014407e", "da", "date", "2010", "1", "1", "date", "2010", "12", "31", "self", "check_data_element", "data_elem", "expected"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_TM", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_TM", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_TM(self):\n        data_elem = DataElement(0x00080030, 'TM', '010203')\n        expected = (b'\\x08\\x00\\x30\\x00'  # tag\n                    b'\\x06\\x00\\x00\\x00'  # length\n                    b'010203')  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080030, 'TM', b'010203')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080030, 'TM', time(1, 2, 3))\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_tm", "self", "data_elem", "dataelement", "0x00080030", "tm", "010203", "expected", "b", "x08", "x00", "x30", "x00", "tag", "b", "x06", "x00", "x00", "x00", "length", "b", "010203", "padded", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080030", "tm", "b", "010203", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080030", "tm", "time", "1", "2", "3", "self", "check_data_element", "data_elem", "expected"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_multi_TM", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_multi_TM", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_multi_TM(self):\n        data_elem = DataElement(0x0014407C, 'TM', ['082500', b'092655'])\n        expected = (b'\\x14\\x00\\x7C\\x40'  # tag\n                    b'\\x0E\\x00\\x00\\x00'  # length\n                    b'082500\\\\092655 ')  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0014407C, 'TM', [time(8, 25),\n                                                   time(9, 26, 55)])\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_multi_tm", "self", "data_elem", "dataelement", "0x0014407c", "tm", "082500", "b", "092655", "expected", "b", "x14", "x00", "x7c", "x40", "tag", "b", "x0e", "x00", "x00", "x00", "length", "b", "082500", "092655", "padded", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0014407c", "tm", "time", "8", "25", "time", "9", "26", "55", "self", "check_data_element", "data_elem", "expected"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_DT", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_DT", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_DT(self):\n        data_elem = DataElement(0x0008002A, 'DT', '20170101120000')\n        expected = (b'\\x08\\x00\\x2A\\x00'  # tag\n                    b'\\x0E\\x00\\x00\\x00'  # length\n                    b'20170101120000')  # value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0008002A, 'DT', b'20170101120000')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0008002A, 'DT', datetime(2017, 1, 1, 12))\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_dt", "self", "data_elem", "dataelement", "0x0008002a", "dt", "20170101120000", "expected", "b", "x08", "x00", "x2a", "x00", "tag", "b", "x0e", "x00", "x00", "x00", "length", "b", "20170101120000", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0008002a", "dt", "b", "20170101120000", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0008002a", "dt", "datetime", "2017", "1", "1", "12", "self", "check_data_element", "data_elem", "expected"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_multi_DT", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_multi_DT", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_multi_DT(self):\n        data_elem = DataElement(0x0040A13A, 'DT',\n                                ['20120820120804', b'20130901111111'])\n        expected = (b'\\x40\\x00\\x3A\\xA1'  # tag\n                    b'\\x1E\\x00\\x00\\x00'  # length\n                    b'20120820120804\\\\20130901111111 ')  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(\n            0x0040A13A, 'DT', u'20120820120804\\\\20130901111111')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(\n            0x0040A13A, 'DT', b'20120820120804\\\\20130901111111')\n        self.check_data_element(data_elem, expected)\n\n        data_elem = DataElement(0x0040A13A, 'DT',\n                                [datetime(2012, 8, 20, 12, 8, 4),\n                                 datetime(2013, 9, 1, 11, 11, 11)])\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_multi_dt", "self", "data_elem", "dataelement", "0x0040a13a", "dt", "20120820120804", "b", "20130901111111", "expected", "b", "x40", "x00", "x3a", "xa1", "tag", "b", "x1e", "x00", "x00", "x00", "length", "b", "20120820120804", "20130901111111", "padded", "value", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0040a13a", "dt", "u", "20120820120804", "20130901111111", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0040a13a", "dt", "b", "20120820120804", "20130901111111", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x0040a13a", "dt", "datetime", "2012", "8", "20", "12", "8", "4", "datetime", "2013", "9", "1", "11", "11", "11", "self", "check_data_element", "data_elem", "expected"], "doc_len": 81}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_ascii_vr_with_padding", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_ascii_vr_with_padding", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_ascii_vr_with_padding(self):\n        expected = (b'\\x08\\x00\\x54\\x00'  # tag\n                    b'\\x0C\\x00\\x00\\x00'  # length\n                    b'CONQUESTSRV ')  # padded value\n        data_elem = DataElement(0x00080054, 'AE', 'CONQUESTSRV')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080054, 'AE', b'CONQUESTSRV')\n        self.check_data_element(data_elem, expected)\n\n        expected = (b'\\x08\\x00\\x62\\x00'  # tag\n                    b'\\x06\\x00\\x00\\x00'  # length\n                    b'1.2.3\\x00')  # padded value\n        data_elem = DataElement(0x00080062, 'UI', '1.2.3')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080062, 'UI', b'1.2.3')\n        self.check_data_element(data_elem, expected)\n\n        expected = (b'\\x08\\x00\\x60\\x00'  # tag\n                    b'\\x04\\x00\\x00\\x00'  # length\n                    b'REG ')\n        data_elem = DataElement(0x00080060, 'CS', 'REG')\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080060, 'CS', b'REG')\n        self.check_data_element(data_elem, expected)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_ascii_vr_with_padding", "self", "expected", "b", "x08", "x00", "x54", "x00", "tag", "b", "x0c", "x00", "x00", "x00", "length", "b", "conquestsrv", "padded", "value", "data_elem", "dataelement", "0x00080054", "ae", "conquestsrv", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080054", "ae", "b", "conquestsrv", "self", "check_data_element", "data_elem", "expected", "expected", "b", "x08", "x00", "x62", "x00", "tag", "b", "x06", "x00", "x00", "x00", "length", "b", "1", "2", "3", "x00", "padded", "value", "data_elem", "dataelement", "0x00080062", "ui", "1", "2", "3", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080062", "ui", "b", "1", "2", "3", "self", "check_data_element", "data_elem", "expected", "expected", "b", "x08", "x00", "x60", "x00", "tag", "b", "x04", "x00", "x00", "x00", "length", "b", "reg", "data_elem", "dataelement", "0x00080060", "cs", "reg", "self", "check_data_element", "data_elem", "expected", "data_elem", "dataelement", "0x00080060", "cs", "b", "reg", "self", "check_data_element", "data_elem", "expected"], "doc_len": 121}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_OD_implicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_OD_implicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_OD_implicit_little(self):\n        \"\"\"Test writing elements with VR of OD works correctly.\"\"\"\n        # VolumetricCurvePoints\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07' \\\n                     b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n        elem = DataElement(0x0070150d, 'OD', bytestring)\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0070, 150d): 70 00 0d 15\n        # Length (16): 10 00 00 00\n        #             | Tag          |   Length      |    Value ->\n        ref_bytes = b'\\x70\\x00\\x0d\\x15\\x10\\x00\\x00\\x00' + bytestring\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b''\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x70\\x00\\x0d\\x15\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_od_implicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "od", "works", "correctly", "volumetriccurvepoints", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "elem", "dataelement", "0x0070150d", "od", "bytestring", "encoded_elem", "self", "encode_element", "elem", "tag", "pair", "0070", "150d", "70", "00", "0d", "15", "length", "16", "10", "00", "00", "00", "tag", "length", "value", "ref_bytes", "b", "x70", "x00", "x0d", "x15", "x10", "x00", "x00", "x00", "bytestring", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "b", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x70", "x00", "x0d", "x15", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 99}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_OD_explicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_OD_explicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_OD_explicit_little(self):\n        \"\"\"Test writing elements with VR of OD works correctly.\n\n        Elements with a VR of 'OD' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # VolumetricCurvePoints\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07' \\\n                     b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n        elem = DataElement(0x0070150d, 'OD', bytestring)\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0070, 150d): 70 00 0d 15\n        # VR (OD): \\x4f\\x44\n        # Reserved: \\x00\\x00\n        # Length (16): \\x10\\x00\\x00\\x00\n        #             | Tag          | VR    |\n        ref_bytes = b'\\x70\\x00\\x0d\\x15\\x4f\\x44' \\\n                    b'\\x00\\x00\\x10\\x00\\x00\\x00' + bytestring\n        #             |Rsrvd |   Length      |    Value ->\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b''\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x70\\x00\\x0d\\x15\\x4f\\x44\\x00\\x00\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_od_explicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "od", "works", "correctly", "elements", "with", "a", "vr", "of", "od", "use", "the", "newer", "explicit", "vr", "encoding", "see", "ps3", "5", "section", "7", "1", "2", "volumetriccurvepoints", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "elem", "dataelement", "0x0070150d", "od", "bytestring", "encoded_elem", "self", "encode_element", "elem", "false", "true", "tag", "pair", "0070", "150d", "70", "00", "0d", "15", "vr", "od", "x4f", "x44", "reserved", "x00", "x00", "length", "16", "x10", "x00", "x00", "x00", "tag", "vr", "ref_bytes", "b", "x70", "x00", "x0d", "x15", "x4f", "x44", "b", "x00", "x00", "x10", "x00", "x00", "x00", "bytestring", "rsrvd", "length", "value", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "b", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x70", "x00", "x0d", "x15", "x4f", "x44", "x00", "x00", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 140}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_OL_implicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_OL_implicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_OL_implicit_little(self):\n        \"\"\"Test writing elements with VR of OL works correctly.\"\"\"\n        # TrackPointIndexList\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07' \\\n                     b'\\x01\\x01\\x02\\x03'\n        elem = DataElement(0x00660129, 'OL', bytestring)\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0066, 0129): 66 00 29 01\n        # Length (12): 0c 00 00 00\n        #             | Tag          |   Length      |    Value ->\n        ref_bytes = b'\\x66\\x00\\x29\\x01\\x0c\\x00\\x00\\x00' + bytestring\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b''\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x66\\x00\\x29\\x01\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_ol_implicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "ol", "works", "correctly", "trackpointindexlist", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "elem", "dataelement", "0x00660129", "ol", "bytestring", "encoded_elem", "self", "encode_element", "elem", "tag", "pair", "0066", "0129", "66", "00", "29", "01", "length", "12", "0c", "00", "00", "00", "tag", "length", "value", "ref_bytes", "b", "x66", "x00", "x29", "x01", "x0c", "x00", "x00", "x00", "bytestring", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "b", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x66", "x00", "x29", "x01", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 95}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_OL_explicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_OL_explicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_OL_explicit_little(self):\n        \"\"\"Test writing elements with VR of OL works correctly.\n\n        Elements with a VR of 'OL' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # TrackPointIndexList\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07' \\\n                     b'\\x01\\x01\\x02\\x03'\n        elem = DataElement(0x00660129, 'OL', bytestring)\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0066, 0129): 66 00 29 01\n        # VR (OL): \\x4f\\x4c\n        # Reserved: \\x00\\x00\n        # Length (12): 0c 00 00 00\n        #             | Tag          | VR    |\n        ref_bytes = b'\\x66\\x00\\x29\\x01\\x4f\\x4c' \\\n                    b'\\x00\\x00\\x0c\\x00\\x00\\x00' + bytestring\n        #             |Rsrvd |   Length      |    Value ->\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b''\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x66\\x00\\x29\\x01\\x4f\\x4c\\x00\\x00\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_ol_explicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "ol", "works", "correctly", "elements", "with", "a", "vr", "of", "ol", "use", "the", "newer", "explicit", "vr", "encoding", "see", "ps3", "5", "section", "7", "1", "2", "trackpointindexlist", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "elem", "dataelement", "0x00660129", "ol", "bytestring", "encoded_elem", "self", "encode_element", "elem", "false", "true", "tag", "pair", "0066", "0129", "66", "00", "29", "01", "vr", "ol", "x4f", "x4c", "reserved", "x00", "x00", "length", "12", "0c", "00", "00", "00", "tag", "vr", "ref_bytes", "b", "x66", "x00", "x29", "x01", "x4f", "x4c", "b", "x00", "x00", "x0c", "x00", "x00", "x00", "bytestring", "rsrvd", "length", "value", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "b", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x66", "x00", "x29", "x01", "x4f", "x4c", "x00", "x00", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 136}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_UC_implicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_UC_implicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_UC_implicit_little(self):\n        \"\"\"Test writing elements with VR of UC works correctly.\"\"\"\n        # VM 1, even data\n        elem = DataElement(0x00189908, 'UC', 'Test')\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0018, 9908): 08 00 20 01\n        # Length (4): 04 00 00 00\n        # Value: \\x54\\x65\\x73\\x74\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x04\\x00\\x00\\x00\\x54\\x65\\x73\\x74'\n        assert ref_bytes == encoded_elem\n\n        # VM 1, odd data - padded to even length\n        elem.value = 'Test.'\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x54\\x65\\x73\\x74\\x2e\\x20'\n        assert ref_bytes == encoded_elem\n\n        # VM 3, even data\n        elem.value = ['Aa', 'B', 'C']\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x41\\x61\\x5c\\x42\\x5c\\x43'\n        assert ref_bytes == encoded_elem\n\n        # VM 3, odd data - padded to even length\n        elem.value = ['A', 'B', 'C']\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x41\\x5c\\x42\\x5c\\x43\\x20'\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = ''\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_uc_implicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "uc", "works", "correctly", "vm", "1", "even", "data", "elem", "dataelement", "0x00189908", "uc", "test", "encoded_elem", "self", "encode_element", "elem", "tag", "pair", "0018", "9908", "08", "00", "20", "01", "length", "4", "04", "00", "00", "00", "value", "x54", "x65", "x73", "x74", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x04", "x00", "x00", "x00", "x54", "x65", "x73", "x74", "assert", "ref_bytes", "encoded_elem", "vm", "1", "odd", "data", "padded", "to", "even", "length", "elem", "value", "test", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x06", "x00", "x00", "x00", "x54", "x65", "x73", "x74", "x2e", "x20", "assert", "ref_bytes", "encoded_elem", "vm", "3", "even", "data", "elem", "value", "aa", "b", "c", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x06", "x00", "x00", "x00", "x41", "x61", "x5c", "x42", "x5c", "x43", "assert", "ref_bytes", "encoded_elem", "vm", "3", "odd", "data", "padded", "to", "even", "length", "elem", "value", "a", "b", "c", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x06", "x00", "x00", "x00", "x41", "x5c", "x42", "x5c", "x43", "x20", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "encoded_elem", "self", "encode_element", "elem", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 189}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_UC_explicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_UC_explicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_UC_explicit_little(self):\n        \"\"\"Test writing elements with VR of UC works correctly.\n\n        Elements with a VR of 'UC' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # VM 1, even data\n        elem = DataElement(0x00189908, 'UC', 'Test')\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0018, 9908): 08 00 20 01\n        # VR (UC): \\x55\\x43\n        # Reserved: \\x00\\x00\n        # Length (4): \\x04\\x00\\x00\\x00\n        # Value: \\x54\\x65\\x73\\x74\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x04\\x00\\x00\\x00' \\\n                    b'\\x54\\x65\\x73\\x74'\n        assert ref_bytes == encoded_elem\n\n        # VM 1, odd data - padded to even length\n        elem.value = 'Test.'\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00' \\\n                    b'\\x54\\x65\\x73\\x74\\x2e\\x20'\n        assert ref_bytes == encoded_elem\n\n        # VM 3, even data\n        elem.value = ['Aa', 'B', 'C']\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00' \\\n                    b'\\x41\\x61\\x5c\\x42\\x5c\\x43'\n        assert ref_bytes == encoded_elem\n\n        # VM 3, odd data - padded to even length\n        elem.value = ['A', 'B', 'C']\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00' \\\n                    b'\\x41\\x5c\\x42\\x5c\\x43\\x20'\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = ''\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_uc_explicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "uc", "works", "correctly", "elements", "with", "a", "vr", "of", "uc", "use", "the", "newer", "explicit", "vr", "encoding", "see", "ps3", "5", "section", "7", "1", "2", "vm", "1", "even", "data", "elem", "dataelement", "0x00189908", "uc", "test", "encoded_elem", "self", "encode_element", "elem", "false", "true", "tag", "pair", "0018", "9908", "08", "00", "20", "01", "vr", "uc", "x55", "x43", "reserved", "x00", "x00", "length", "4", "x04", "x00", "x00", "x00", "value", "x54", "x65", "x73", "x74", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x55", "x43", "x00", "x00", "x04", "x00", "x00", "x00", "b", "x54", "x65", "x73", "x74", "assert", "ref_bytes", "encoded_elem", "vm", "1", "odd", "data", "padded", "to", "even", "length", "elem", "value", "test", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x55", "x43", "x00", "x00", "x06", "x00", "x00", "x00", "b", "x54", "x65", "x73", "x74", "x2e", "x20", "assert", "ref_bytes", "encoded_elem", "vm", "3", "even", "data", "elem", "value", "aa", "b", "c", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x55", "x43", "x00", "x00", "x06", "x00", "x00", "x00", "b", "x41", "x61", "x5c", "x42", "x5c", "x43", "assert", "ref_bytes", "encoded_elem", "vm", "3", "odd", "data", "padded", "to", "even", "length", "elem", "value", "a", "b", "c", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x55", "x43", "x00", "x00", "x06", "x00", "x00", "x00", "b", "x41", "x5c", "x42", "x5c", "x43", "x20", "assert", "ref_bytes", "encoded_elem", "empty", "data", "elem", "value", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x18", "x00", "x08", "x99", "x55", "x43", "x00", "x00", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 249}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_UR_implicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_UR_implicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_UR_implicit_little(self):\n        \"\"\"Test writing elements with VR of UR works correctly.\"\"\"\n        # Even length URL\n        elem = DataElement(0x00080120, 'UR',\n                           'http://github.com/darcymason/pydicom')\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0008, 2001): 08 00 20 01\n        # Length (36): 24 00 00 00\n        # Value: 68 to 6d\n        ref_bytes = b'\\x08\\x00\\x20\\x01\\x24\\x00\\x00\\x00\\x68\\x74' \\\n                    b'\\x74\\x70\\x3a\\x2f\\x2f\\x67\\x69\\x74\\x68\\x75' \\\n                    b'\\x62\\x2e\\x63\\x6f\\x6d\\x2f\\x64\\x61\\x72\\x63' \\\n                    b'\\x79\\x6d\\x61\\x73\\x6f\\x6e\\x2f\\x70\\x79\\x64' \\\n                    b'\\x69\\x63\\x6f\\x6d'\n        assert ref_bytes == encoded_elem\n\n        # Odd length URL has trailing \\x20 (SPACE) padding\n        elem.value = '../test/test.py'\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0008, 2001): 08 00 20 01\n        # Length (16): 10 00 00 00\n        # Value: 2e to 20\n        ref_bytes = b'\\x08\\x00\\x20\\x01\\x10\\x00\\x00\\x00\\x2e\\x2e' \\\n                    b'\\x2f\\x74\\x65\\x73\\x74\\x2f\\x74\\x65\\x73\\x74' \\\n                    b'\\x2e\\x70\\x79\\x20'\n        assert ref_bytes == encoded_elem\n\n        # Empty value\n        elem.value = ''\n        encoded_elem = self.encode_element(elem)\n        assert b'\\x08\\x00\\x20\\x01\\x00\\x00\\x00\\x00' == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_ur_implicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "ur", "works", "correctly", "even", "length", "url", "elem", "dataelement", "0x00080120", "ur", "http", "github", "com", "darcymason", "pydicom", "encoded_elem", "self", "encode_element", "elem", "tag", "pair", "0008", "2001", "08", "00", "20", "01", "length", "36", "24", "00", "00", "00", "value", "68", "to", "6d", "ref_bytes", "b", "x08", "x00", "x20", "x01", "x24", "x00", "x00", "x00", "x68", "x74", "b", "x74", "x70", "x3a", "x2f", "x2f", "x67", "x69", "x74", "x68", "x75", "b", "x62", "x2e", "x63", "x6f", "x6d", "x2f", "x64", "x61", "x72", "x63", "b", "x79", "x6d", "x61", "x73", "x6f", "x6e", "x2f", "x70", "x79", "x64", "b", "x69", "x63", "x6f", "x6d", "assert", "ref_bytes", "encoded_elem", "odd", "length", "url", "has", "trailing", "x20", "space", "padding", "elem", "value", "test", "test", "py", "encoded_elem", "self", "encode_element", "elem", "tag", "pair", "0008", "2001", "08", "00", "20", "01", "length", "16", "10", "00", "00", "00", "value", "2e", "to", "20", "ref_bytes", "b", "x08", "x00", "x20", "x01", "x10", "x00", "x00", "x00", "x2e", "x2e", "b", "x2f", "x74", "x65", "x73", "x74", "x2f", "x74", "x65", "x73", "x74", "b", "x2e", "x70", "x79", "x20", "assert", "ref_bytes", "encoded_elem", "empty", "value", "elem", "value", "encoded_elem", "self", "encode_element", "elem", "assert", "b", "x08", "x00", "x20", "x01", "x00", "x00", "x00", "x00", "encoded_elem"], "doc_len": 189}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_UR_explicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_UR_explicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_UR_explicit_little(self):\n        \"\"\"Test writing elements with VR of UR works correctly.\n\n        Elements with a VR of 'UR' use the newer explicit VR\n        encoded (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # Even length URL\n        elem = DataElement(0x00080120, 'UR', 'ftp://bits')\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0008, 2001): 08 00 20 01\n        # VR (UR): \\x55\\x52\n        # Reserved: \\x00\\x00\n        # Length (4): \\x0a\\x00\\x00\\x00\n        # Value: \\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x73\n        ref_bytes = b'\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x0a\\x00\\x00\\x00' \\\n                    b'\\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x73'\n        assert ref_bytes == encoded_elem\n\n        # Odd length URL has trailing \\x20 (SPACE) padding\n        elem.value = 'ftp://bit'\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x0a\\x00\\x00\\x00' \\\n                    b'\\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x20'\n        assert ref_bytes == encoded_elem\n\n        # Empty value\n        elem.value = ''\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b'\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x00\\x00\\x00\\x00'\n        assert ref_bytes == encoded_elem\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_ur_explicit_little", "self", "test", "writing", "elements", "with", "vr", "of", "ur", "works", "correctly", "elements", "with", "a", "vr", "of", "ur", "use", "the", "newer", "explicit", "vr", "encoded", "see", "ps3", "5", "section", "7", "1", "2", "even", "length", "url", "elem", "dataelement", "0x00080120", "ur", "ftp", "bits", "encoded_elem", "self", "encode_element", "elem", "false", "true", "tag", "pair", "0008", "2001", "08", "00", "20", "01", "vr", "ur", "x55", "x52", "reserved", "x00", "x00", "length", "4", "x0a", "x00", "x00", "x00", "value", "x66", "x74", "x70", "x3a", "x2f", "x2f", "x62", "x69", "x74", "x73", "ref_bytes", "b", "x08", "x00", "x20", "x01", "x55", "x52", "x00", "x00", "x0a", "x00", "x00", "x00", "b", "x66", "x74", "x70", "x3a", "x2f", "x2f", "x62", "x69", "x74", "x73", "assert", "ref_bytes", "encoded_elem", "odd", "length", "url", "has", "trailing", "x20", "space", "padding", "elem", "value", "ftp", "bit", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x08", "x00", "x20", "x01", "x55", "x52", "x00", "x00", "x0a", "x00", "x00", "x00", "b", "x66", "x74", "x70", "x3a", "x2f", "x2f", "x62", "x69", "x74", "x20", "assert", "ref_bytes", "encoded_elem", "empty", "value", "elem", "value", "encoded_elem", "self", "encode_element", "elem", "false", "true", "ref_bytes", "b", "x08", "x00", "x20", "x01", "x55", "x52", "x00", "x00", "x00", "x00", "x00", "x00", "assert", "ref_bytes", "encoded_elem"], "doc_len": 184}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_UN_implicit_little", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_UN_implicit_little", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_UN_implicit_little(self):\n        \"\"\"Test writing UN VR in implicit little\"\"\"\n        elem = DataElement(0x00100010, 'UN', b'\\x01\\x02')\n        assert self.encode_element(elem) == (\n            b'\\x10\\x00\\x10\\x00\\x02\\x00\\x00\\x00\\x01\\x02')\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_un_implicit_little", "self", "test", "writing", "un", "vr", "in", "implicit", "little", "elem", "dataelement", "0x00100010", "un", "b", "x01", "x02", "assert", "self", "encode_element", "elem", "b", "x10", "x00", "x10", "x00", "x02", "x00", "x00", "x00", "x01", "x02"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDataElement.test_write_unknown_vr_raises", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDataElement", "func_name": "test_write_unknown_vr_raises", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDataElement\n    def test_write_unknown_vr_raises(self):\n        \"\"\"Test exception raised trying to write unknown VR element\"\"\"\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = True\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, 'ZZ', 'Test')\n        with pytest.raises(NotImplementedError,\n                           match=\"write_data_element: unknown Value \"\n                                 \"Representation 'ZZ'\"):\n            write_data_element(fp, elem)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedataelement", "def", "test_write_unknown_vr_raises", "self", "test", "exception", "raised", "trying", "to", "write", "unknown", "vr", "element", "fp", "dicombytesio", "fp", "is_implicit_vr", "true", "fp", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "zz", "test", "with", "pytest", "raises", "notimplementederror", "match", "write_data_element", "unknown", "value", "representation", "zz", "write_data_element", "fp", "elem"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_pixel_representation_vm_one", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_pixel_representation_vm_one", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_pixel_representation_vm_one(self):\n        \"\"\"Test correcting VM 1 elements which require PixelRepresentation.\"\"\"\n        ref_ds = Dataset()\n\n        # If PixelRepresentation is 0 then VR should be US\n        ref_ds.PixelRepresentation = 0\n        ref_ds.SmallestValidPixelValue = b'\\x00\\x01'  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 256 == ds.SmallestValidPixelValue\n        assert 'US' == ds[0x00280104].VR\n\n        # If PixelRepresentation is 1 then VR should be SS\n        ref_ds.PixelRepresentation = 1\n        ref_ds.SmallestValidPixelValue = b'\\x00\\x01'  # Big endian 1\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)\n        assert 1 == ds.SmallestValidPixelValue\n        assert 'SS' == ds[0x00280104].VR\n\n        # If no PixelRepresentation and no PixelData is present 'US' is set\n        ref_ds = Dataset()\n        ref_ds.SmallestValidPixelValue = b'\\x00\\x01'  # Big endian 1\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 'US' == ds[0x00280104].VR\n\n        # If no PixelRepresentation but PixelData is present\n        # AttributeError shall be raised\n        ref_ds.PixelData = b'123'\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(0028, 0104\\):.* 'PixelRepresentation'\"):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_pixel_representation_vm_one", "self", "test", "correcting", "vm", "1", "elements", "which", "require", "pixelrepresentation", "ref_ds", "dataset", "if", "pixelrepresentation", "is", "0", "then", "vr", "should", "be", "us", "ref_ds", "pixelrepresentation", "0", "ref_ds", "smallestvalidpixelvalue", "b", "x00", "x01", "little", "endian", "256", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "256", "ds", "smallestvalidpixelvalue", "assert", "us", "ds", "0x00280104", "vr", "if", "pixelrepresentation", "is", "1", "then", "vr", "should", "be", "ss", "ref_ds", "pixelrepresentation", "1", "ref_ds", "smallestvalidpixelvalue", "b", "x00", "x01", "big", "endian", "1", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "false", "assert", "1", "ds", "smallestvalidpixelvalue", "assert", "ss", "ds", "0x00280104", "vr", "if", "no", "pixelrepresentation", "and", "no", "pixeldata", "is", "present", "us", "is", "set", "ref_ds", "dataset", "ref_ds", "smallestvalidpixelvalue", "b", "x00", "x01", "big", "endian", "1", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "us", "ds", "0x00280104", "vr", "if", "no", "pixelrepresentation", "but", "pixeldata", "is", "present", "attributeerror", "shall", "be", "raised", "ref_ds", "pixeldata", "b", "123", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "0028", "0104", "pixelrepresentation", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true"], "doc_len": 153}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_pixel_representation_vm_three", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_pixel_representation_vm_three", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_pixel_representation_vm_three(self):\n        \"\"\"Test correcting VM 3 elements which require PixelRepresentation.\"\"\"\n        ref_ds = Dataset()\n\n        # If PixelRepresentation is 0 then VR should be US - Little endian\n        ref_ds.PixelRepresentation = 0\n        ref_ds.LUTDescriptor = b'\\x01\\x00\\x00\\x01\\x10\\x00'  # 1\\256\\16\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert [1, 256, 16] == ds.LUTDescriptor\n        assert 'US' == ds[0x00283002].VR\n\n        # If PixelRepresentation is 1 then VR should be SS\n        ref_ds.PixelRepresentation = 1\n        ref_ds.LUTDescriptor = b'\\x01\\x00\\x00\\x01\\x00\\x10'\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)\n        assert [256, 1, 16] == ds.LUTDescriptor\n        assert 'SS' == ds[0x00283002].VR\n\n        # If no PixelRepresentation and no PixelData is present 'US' is set\n        ref_ds = Dataset()\n        ref_ds.LUTDescriptor = b'\\x01\\x00\\x00\\x01\\x00\\x10'\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 'US' == ds[0x00283002].VR\n\n        # If no PixelRepresentation AttributeError shall be raised\n        ref_ds.PixelData = b'123'\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(0028, 3002\\):.* 'PixelRepresentation'\"):\n            correct_ambiguous_vr(deepcopy(ref_ds), False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_pixel_representation_vm_three", "self", "test", "correcting", "vm", "3", "elements", "which", "require", "pixelrepresentation", "ref_ds", "dataset", "if", "pixelrepresentation", "is", "0", "then", "vr", "should", "be", "us", "little", "endian", "ref_ds", "pixelrepresentation", "0", "ref_ds", "lutdescriptor", "b", "x01", "x00", "x00", "x01", "x10", "x00", "1", "256", "16", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "1", "256", "16", "ds", "lutdescriptor", "assert", "us", "ds", "0x00283002", "vr", "if", "pixelrepresentation", "is", "1", "then", "vr", "should", "be", "ss", "ref_ds", "pixelrepresentation", "1", "ref_ds", "lutdescriptor", "b", "x01", "x00", "x00", "x01", "x00", "x10", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "false", "assert", "256", "1", "16", "ds", "lutdescriptor", "assert", "ss", "ds", "0x00283002", "vr", "if", "no", "pixelrepresentation", "and", "no", "pixeldata", "is", "present", "us", "is", "set", "ref_ds", "dataset", "ref_ds", "lutdescriptor", "b", "x01", "x00", "x00", "x01", "x00", "x10", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "us", "ds", "0x00283002", "vr", "if", "no", "pixelrepresentation", "attributeerror", "shall", "be", "raised", "ref_ds", "pixeldata", "b", "123", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "0028", "3002", "pixelrepresentation", "correct_ambiguous_vr", "deepcopy", "ref_ds", "false"], "doc_len": 161}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_pixel_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_pixel_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_pixel_data(self):\n        \"\"\"Test correcting PixelData.\"\"\"\n        ref_ds = Dataset()\n\n        # If BitsAllocated  > 8 then VR must be OW\n        ref_ds.BitsAllocated = 16\n        ref_ds.PixelData = b'\\x00\\x01'  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert b'\\x00\\x01' == ds.PixelData\n        assert 'OW' == ds[0x7fe00010].VR\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)  # Big endian\n        assert b'\\x00\\x01' == ds.PixelData\n        assert 'OW' == ds[0x7fe00010].VR\n\n        # If BitsAllocated <= 8 then VR can be OB or OW: we set it to OB\n        ref_ds = Dataset()\n        ref_ds.BitsAllocated = 8\n        ref_ds.Rows = 2\n        ref_ds.Columns = 2\n        ref_ds.PixelData = b'\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00'\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b'\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00' == ds.PixelData\n        assert 'OB' == ds[0x7fe00010].VR\n\n        # If no BitsAllocated set then AttributesError is raised\n        ref_ds = Dataset()\n        ref_ds.PixelData = b'\\x00\\x01'  # Big endian 1\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(7fe0, 0010\\):.* 'BitsAllocated'\"):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_pixel_data", "self", "test", "correcting", "pixeldata", "ref_ds", "dataset", "if", "bitsallocated", "8", "then", "vr", "must", "be", "ow", "ref_ds", "bitsallocated", "16", "ref_ds", "pixeldata", "b", "x00", "x01", "little", "endian", "256", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "little", "endian", "assert", "b", "x00", "x01", "ds", "pixeldata", "assert", "ow", "ds", "0x7fe00010", "vr", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "false", "big", "endian", "assert", "b", "x00", "x01", "ds", "pixeldata", "assert", "ow", "ds", "0x7fe00010", "vr", "if", "bitsallocated", "8", "then", "vr", "can", "be", "ob", "or", "ow", "we", "set", "it", "to", "ob", "ref_ds", "dataset", "ref_ds", "bitsallocated", "8", "ref_ds", "rows", "2", "ref_ds", "columns", "2", "ref_ds", "pixeldata", "b", "x01", "x00", "x02", "x00", "x03", "x00", "x04", "x00", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "b", "x01", "x00", "x02", "x00", "x03", "x00", "x04", "x00", "ds", "pixeldata", "assert", "ob", "ds", "0x7fe00010", "vr", "if", "no", "bitsallocated", "set", "then", "attributeserror", "is", "raised", "ref_ds", "dataset", "ref_ds", "pixeldata", "b", "x00", "x01", "big", "endian", "1", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "7fe0", "0010", "bitsallocated", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true"], "doc_len": 166}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_waveform_bits_allocated", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_waveform_bits_allocated", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_waveform_bits_allocated(self):\n        \"\"\"Test correcting elements which require WaveformBitsAllocated.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.is_implicit_VR = False\n\n        # If WaveformBitsAllocated  > 8 then VR must be OW\n        ref_ds.WaveformBitsAllocated = 16\n        ref_ds.WaveformData = b'\\x00\\x01'  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert b'\\x00\\x01' == ds.WaveformData\n        assert 'OW' == ds[0x54001010].VR\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)  # Big endian\n        assert b'\\x00\\x01' == ds.WaveformData\n        assert 'OW' == ds[0x54001010].VR\n\n        # If WaveformBitsAllocated == 8 then VR is OB or OW - set it to OB\n        ref_ds.WaveformBitsAllocated = 8\n        ref_ds.WaveformData = b'\\x01\\x02'\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b'\\x01\\x02' == ds.WaveformData\n        assert 'OB' == ds[0x54001010].VR\n\n        # For implicit VR, VR is always OW\n        ref_ds.is_implicit_VR = True\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b'\\x01\\x02' == ds.WaveformData\n        assert 'OW' == ds[0x54001010].VR\n        ref_ds.is_implicit_VR = False\n\n        # If no WaveformBitsAllocated then AttributeError shall be raised\n        ref_ds = Dataset()\n        ref_ds.WaveformData = b'\\x00\\x01'  # Big endian 1\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(5400, 1010\\):.* 'WaveformBitsAllocated'\"):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_waveform_bits_allocated", "self", "test", "correcting", "elements", "which", "require", "waveformbitsallocated", "ref_ds", "dataset", "ref_ds", "is_implicit_vr", "false", "if", "waveformbitsallocated", "8", "then", "vr", "must", "be", "ow", "ref_ds", "waveformbitsallocated", "16", "ref_ds", "waveformdata", "b", "x00", "x01", "little", "endian", "256", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "little", "endian", "assert", "b", "x00", "x01", "ds", "waveformdata", "assert", "ow", "ds", "0x54001010", "vr", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "false", "big", "endian", "assert", "b", "x00", "x01", "ds", "waveformdata", "assert", "ow", "ds", "0x54001010", "vr", "if", "waveformbitsallocated", "8", "then", "vr", "is", "ob", "or", "ow", "set", "it", "to", "ob", "ref_ds", "waveformbitsallocated", "8", "ref_ds", "waveformdata", "b", "x01", "x02", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "b", "x01", "x02", "ds", "waveformdata", "assert", "ob", "ds", "0x54001010", "vr", "for", "implicit", "vr", "vr", "is", "always", "ow", "ref_ds", "is_implicit_vr", "true", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "b", "x01", "x02", "ds", "waveformdata", "assert", "ow", "ds", "0x54001010", "vr", "ref_ds", "is_implicit_vr", "false", "if", "no", "waveformbitsallocated", "then", "attributeerror", "shall", "be", "raised", "ref_ds", "dataset", "ref_ds", "waveformdata", "b", "x00", "x01", "big", "endian", "1", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "5400", "1010", "waveformbitsallocated", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true"], "doc_len": 179}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_lut_descriptor", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_lut_descriptor", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_lut_descriptor(self):\n        \"\"\"Test correcting elements which require LUTDescriptor.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.PixelRepresentation = 0\n\n        # If LUTDescriptor[0] is 1 then LUTData VR is 'US'\n        ref_ds.LUTDescriptor = b'\\x01\\x00\\x00\\x01\\x10\\x00'  # 1\\256\\16\n        ref_ds.LUTData = b'\\x00\\x01'  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert 1 == ds.LUTDescriptor[0]\n        assert 'US' == ds[0x00283002].VR\n        assert 256 == ds.LUTData\n        assert 'US' == ds[0x00283006].VR\n\n        # If LUTDescriptor[0] is not 1 then LUTData VR is 'OW'\n        ref_ds.LUTDescriptor = b'\\x02\\x00\\x00\\x01\\x10\\x00'  # 2\\256\\16\n        ref_ds.LUTData = b'\\x00\\x01\\x00\\x02'\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert 2 == ds.LUTDescriptor[0]\n        assert 'US' == ds[0x00283002].VR\n        assert b'\\x00\\x01\\x00\\x02' == ds.LUTData\n        assert 'OW' == ds[0x00283006].VR\n\n        # If no LUTDescriptor then raise AttributeError\n        ref_ds = Dataset()\n        ref_ds.LUTData = b'\\x00\\x01'\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(0028, 3006\\):.* 'LUTDescriptor'\"):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_lut_descriptor", "self", "test", "correcting", "elements", "which", "require", "lutdescriptor", "ref_ds", "dataset", "ref_ds", "pixelrepresentation", "0", "if", "lutdescriptor", "0", "is", "1", "then", "lutdata", "vr", "is", "us", "ref_ds", "lutdescriptor", "b", "x01", "x00", "x00", "x01", "x10", "x00", "1", "256", "16", "ref_ds", "lutdata", "b", "x00", "x01", "little", "endian", "256", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "little", "endian", "assert", "1", "ds", "lutdescriptor", "0", "assert", "us", "ds", "0x00283002", "vr", "assert", "256", "ds", "lutdata", "assert", "us", "ds", "0x00283006", "vr", "if", "lutdescriptor", "0", "is", "not", "1", "then", "lutdata", "vr", "is", "ow", "ref_ds", "lutdescriptor", "b", "x02", "x00", "x00", "x01", "x10", "x00", "2", "256", "16", "ref_ds", "lutdata", "b", "x00", "x01", "x00", "x02", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "little", "endian", "assert", "2", "ds", "lutdescriptor", "0", "assert", "us", "ds", "0x00283002", "vr", "assert", "b", "x00", "x01", "x00", "x02", "ds", "lutdata", "assert", "ow", "ds", "0x00283006", "vr", "if", "no", "lutdescriptor", "then", "raise", "attributeerror", "ref_ds", "dataset", "ref_ds", "lutdata", "b", "x00", "x01", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "0028", "3006", "lutdescriptor", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true"], "doc_len": 169}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_overlay", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_overlay", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_overlay(self):\n        \"\"\"Test correcting OverlayData\"\"\"\n        # VR must be 'OW'\n        ref_ds = Dataset()\n        ref_ds.is_implicit_VR = True\n        ref_ds.add(DataElement(0x60003000, 'OB or OW', b'\\x00'))\n        ref_ds.add(DataElement(0x601E3000, 'OB or OW', b'\\x00'))\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 'OW' == ds[0x60003000].VR\n        assert 'OW' == ds[0x601E3000].VR\n        assert 'OB or OW' == ref_ds[0x60003000].VR\n        assert 'OB or OW' == ref_ds[0x601E3000].VR\n\n        ref_ds.is_implicit_VR = False\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 'OW' == ds[0x60003000].VR\n        assert 'OB or OW' == ref_ds[0x60003000].VR\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_overlay", "self", "test", "correcting", "overlaydata", "vr", "must", "be", "ow", "ref_ds", "dataset", "ref_ds", "is_implicit_vr", "true", "ref_ds", "add", "dataelement", "0x60003000", "ob", "or", "ow", "b", "x00", "ref_ds", "add", "dataelement", "0x601e3000", "ob", "or", "ow", "b", "x00", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "ow", "ds", "0x60003000", "vr", "assert", "ow", "ds", "0x601e3000", "vr", "assert", "ob", "or", "ow", "ref_ds", "0x60003000", "vr", "assert", "ob", "or", "ow", "ref_ds", "0x601e3000", "vr", "ref_ds", "is_implicit_vr", "false", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "ow", "ds", "0x60003000", "vr", "assert", "ob", "or", "ow", "ref_ds", "0x60003000", "vr"], "doc_len": 87}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_sequence", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_sequence", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_sequence(self):\n        \"\"\"Test correcting elements in a sequence.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.BeamSequence = [Dataset()]\n        ref_ds.BeamSequence[0].PixelRepresentation = 0\n        ref_ds.BeamSequence[0].SmallestValidPixelValue = b'\\x00\\x01'\n        ref_ds.BeamSequence[0].BeamSequence = [Dataset()]\n\n        ref_ds.BeamSequence[0].BeamSequence[0].PixelRepresentation = 0\n        ref_ds.BeamSequence[0].BeamSequence[0].SmallestValidPixelValue = \\\n            b'\\x00\\x01'\n\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert ds.BeamSequence[0].SmallestValidPixelValue == 256\n        assert ds.BeamSequence[0][0x00280104].VR == 'US'\n        assert (\n                ds.BeamSequence[0].BeamSequence[\n                    0].SmallestValidPixelValue == 256)\n        assert ds.BeamSequence[0].BeamSequence[0][0x00280104].VR == 'US'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_sequence", "self", "test", "correcting", "elements", "in", "a", "sequence", "ref_ds", "dataset", "ref_ds", "beamsequence", "dataset", "ref_ds", "beamsequence", "0", "pixelrepresentation", "0", "ref_ds", "beamsequence", "0", "smallestvalidpixelvalue", "b", "x00", "x01", "ref_ds", "beamsequence", "0", "beamsequence", "dataset", "ref_ds", "beamsequence", "0", "beamsequence", "0", "pixelrepresentation", "0", "ref_ds", "beamsequence", "0", "beamsequence", "0", "smallestvalidpixelvalue", "b", "x00", "x01", "ds", "correct_ambiguous_vr", "deepcopy", "ref_ds", "true", "assert", "ds", "beamsequence", "0", "smallestvalidpixelvalue", "256", "assert", "ds", "beamsequence", "0", "0x00280104", "vr", "us", "assert", "ds", "beamsequence", "0", "beamsequence", "0", "smallestvalidpixelvalue", "256", "assert", "ds", "beamsequence", "0", "beamsequence", "0", "0x00280104", "vr", "us"], "doc_len": 87}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_write_new_ambiguous", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_write_new_ambiguous", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_write_new_ambiguous(self):\n        \"\"\"Regression test for #781\"\"\"\n        ds = Dataset()\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        ds.SmallestImagePixelValue = 0\n        assert ds[0x00280106].VR == 'US or SS'\n        ds.PixelRepresentation = 0\n        ds.LUTDescriptor = [1, 0]\n        assert ds[0x00283002].VR == 'US or SS'\n        ds.LUTData = 0\n        assert ds[0x00283006].VR == 'US or OW'\n        ds.save_as(DicomBytesIO())\n\n        assert ds[0x00280106].VR == 'US'\n        assert ds.SmallestImagePixelValue == 0\n        assert ds[0x00283006].VR == 'US'\n        assert ds.LUTData == 0\n        assert ds[0x00283002].VR == 'US'\n        assert ds.LUTDescriptor == [1, 0]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_write_new_ambiguous", "self", "regression", "test", "for", "781", "ds", "dataset", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "ds", "smallestimagepixelvalue", "0", "assert", "ds", "0x00280106", "vr", "us", "or", "ss", "ds", "pixelrepresentation", "0", "ds", "lutdescriptor", "1", "0", "assert", "ds", "0x00283002", "vr", "us", "or", "ss", "ds", "lutdata", "0", "assert", "ds", "0x00283006", "vr", "us", "or", "ow", "ds", "save_as", "dicombytesio", "assert", "ds", "0x00280106", "vr", "us", "assert", "ds", "smallestimagepixelvalue", "0", "assert", "ds", "0x00283006", "vr", "us", "assert", "ds", "lutdata", "0", "assert", "ds", "0x00283002", "vr", "us", "assert", "ds", "lutdescriptor", "1", "0"], "doc_len": 85}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_ambiguous_element_in_sequence_explicit", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_ambiguous_element_in_sequence_explicit", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_ambiguous_element_in_sequence_explicit(self):\n        \"\"\"Test that writing a sequence with an ambiguous element\n        as explicit transfer syntax works.\"\"\"\n        # regression test for #804\n        ds = Dataset()\n        ds.PixelRepresentation = 0\n        ds.ModalityLUTSequence = [Dataset()]\n        ds.ModalityLUTSequence[0].LUTDescriptor = [0, 0, 16]\n        ds.ModalityLUTSequence[0].LUTExplanation = None\n        ds.ModalityLUTSequence[0].ModalityLUTType = 'US'  # US = unspecified\n        ds.ModalityLUTSequence[0].LUTData = b'\\x0000\\x149a\\x1f1c\\xc2637'\n\n        ds.is_little_endian = True\n        ds.is_implicit_VR = False\n        fp = BytesIO()\n        ds.save_as(fp, write_like_original=True)\n\n        ds = dcmread(fp, force=True)\n        assert 'US' == ds.ModalityLUTSequence[0][0x00283002].VR\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_ambiguous_element_in_sequence_explicit", "self", "test", "that", "writing", "a", "sequence", "with", "an", "ambiguous", "element", "as", "explicit", "transfer", "syntax", "works", "regression", "test", "for", "804", "ds", "dataset", "ds", "pixelrepresentation", "0", "ds", "modalitylutsequence", "dataset", "ds", "modalitylutsequence", "0", "lutdescriptor", "0", "0", "16", "ds", "modalitylutsequence", "0", "lutexplanation", "none", "ds", "modalitylutsequence", "0", "modalityluttype", "us", "us", "unspecified", "ds", "modalitylutsequence", "0", "lutdata", "b", "x0000", "x149a", "x1f1c", "xc2637", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "false", "fp", "bytesio", "ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "force", "true", "assert", "us", "ds", "modalitylutsequence", "0", "0x00283002", "vr"], "doc_len": 87}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVR.test_ambiguous_element_in_sequence_implicit", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVR", "func_name": "test_ambiguous_element_in_sequence_implicit", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVR\n    def test_ambiguous_element_in_sequence_implicit(self):\n        \"\"\"Test that reading a sequence with an ambiguous element\n        from a file with implicit transfer syntax works.\"\"\"\n        # regression test for #804\n        ds = Dataset()\n        ds.PixelRepresentation = 0\n        ds.ModalityLUTSequence = [Dataset()]\n        ds.ModalityLUTSequence[0].LUTDescriptor = [0, 0, 16]\n        ds.ModalityLUTSequence[0].LUTExplanation = None\n        ds.ModalityLUTSequence[0].ModalityLUTType = 'US'  # US = unspecified\n        ds.ModalityLUTSequence[0].LUTData = b'\\x0000\\x149a\\x1f1c\\xc2637'\n\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        fp = BytesIO()\n        ds.save_as(fp, write_like_original=True)\n        ds = dcmread(fp, force=True)\n        # we first have to access the value to trigger correcting the VR\n        assert 16 == ds.ModalityLUTSequence[0].LUTDescriptor[2]\n        assert 'US' == ds.ModalityLUTSequence[0][0x00283002].VR\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvr", "def", "test_ambiguous_element_in_sequence_implicit", "self", "test", "that", "reading", "a", "sequence", "with", "an", "ambiguous", "element", "from", "a", "file", "with", "implicit", "transfer", "syntax", "works", "regression", "test", "for", "804", "ds", "dataset", "ds", "pixelrepresentation", "0", "ds", "modalitylutsequence", "dataset", "ds", "modalitylutsequence", "0", "lutdescriptor", "0", "0", "16", "ds", "modalitylutsequence", "0", "lutexplanation", "none", "ds", "modalitylutsequence", "0", "modalityluttype", "us", "us", "unspecified", "ds", "modalitylutsequence", "0", "lutdata", "b", "x0000", "x149a", "x1f1c", "xc2637", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "fp", "bytesio", "ds", "save_as", "fp", "write_like_original", "true", "ds", "dcmread", "fp", "force", "true", "we", "first", "have", "to", "access", "the", "value", "to", "trigger", "correcting", "the", "vr", "assert", "16", "ds", "modalitylutsequence", "0", "lutdescriptor", "2", "assert", "us", "ds", "modalitylutsequence", "0", "0x00283002", "vr"], "doc_len": 109}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVRElement.test_not_ambiguous", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVRElement", "func_name": "test_not_ambiguous", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVRElement\n    def test_not_ambiguous(self):\n        \"\"\"Test no change in element if not ambiguous\"\"\"\n        elem = DataElement(0x60003000, 'OB', b'\\x00')\n        out = correct_ambiguous_vr_element(elem, Dataset(), True)\n        assert out.VR == 'OB'\n        assert out.tag == 0x60003000\n        assert out.value == b'\\x00'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvrelement", "def", "test_not_ambiguous", "self", "test", "no", "change", "in", "element", "if", "not", "ambiguous", "elem", "dataelement", "0x60003000", "ob", "b", "x00", "out", "correct_ambiguous_vr_element", "elem", "dataset", "true", "assert", "out", "vr", "ob", "assert", "out", "tag", "0x60003000", "assert", "out", "value", "b", "x00"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVRElement.test_not_ambiguous_raw_data_element", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVRElement", "func_name": "test_not_ambiguous_raw_data_element", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVRElement\n    def test_not_ambiguous_raw_data_element(self):\n        \"\"\"Test no change in raw data element if not ambiguous\"\"\"\n        elem = RawDataElement(0x60003000, 'OB', 1, b'\\x00', 0, True, True)\n        out = correct_ambiguous_vr_element(elem, Dataset(), True)\n        assert out == elem\n        assert type(out) == RawDataElement\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvrelement", "def", "test_not_ambiguous_raw_data_element", "self", "test", "no", "change", "in", "raw", "data", "element", "if", "not", "ambiguous", "elem", "rawdataelement", "0x60003000", "ob", "1", "b", "x00", "0", "true", "true", "out", "correct_ambiguous_vr_element", "elem", "dataset", "true", "assert", "out", "elem", "assert", "type", "out", "rawdataelement"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVRElement.test_correct_ambiguous_data_element", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVRElement", "func_name": "test_correct_ambiguous_data_element", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVRElement\n    def test_correct_ambiguous_data_element(self):\n        \"\"\"Test correct ambiguous US/SS element\"\"\"\n        ds = Dataset()\n        ds.PixelPaddingValue = b'\\xfe\\xff'\n        out = correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n        # assume US if PixelData is not set\n        assert 'US' == out.VR\n\n        ds = Dataset()\n        ds.PixelPaddingValue = b'\\xfe\\xff'\n        ds.PixelData = b'3456'\n        with pytest.raises(AttributeError,\n                           match=r\"Failed to resolve ambiguous VR for tag \"\n                                 r\"\\(0028, 0120\\):.* 'PixelRepresentation'\"):\n            correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n\n        ds.PixelRepresentation = 0\n        out = correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n        assert out.VR == 'US'\n        assert out.value == 0xfffe\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvrelement", "def", "test_correct_ambiguous_data_element", "self", "test", "correct", "ambiguous", "us", "ss", "element", "ds", "dataset", "ds", "pixelpaddingvalue", "b", "xfe", "xff", "out", "correct_ambiguous_vr_element", "ds", "0x00280120", "ds", "true", "assume", "us", "if", "pixeldata", "is", "not", "set", "assert", "us", "out", "vr", "ds", "dataset", "ds", "pixelpaddingvalue", "b", "xfe", "xff", "ds", "pixeldata", "b", "3456", "with", "pytest", "raises", "attributeerror", "match", "r", "failed", "to", "resolve", "ambiguous", "vr", "for", "tag", "r", "0028", "0120", "pixelrepresentation", "correct_ambiguous_vr_element", "ds", "0x00280120", "ds", "true", "ds", "pixelrepresentation", "0", "out", "correct_ambiguous_vr_element", "ds", "0x00280120", "ds", "true", "assert", "out", "vr", "us", "assert", "out", "value", "0xfffe"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_filewriter.py::TestCorrectAmbiguousVRElement.test_correct_ambiguous_raw_data_element", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestCorrectAmbiguousVRElement", "func_name": "test_correct_ambiguous_raw_data_element", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestCorrectAmbiguousVRElement\n    def test_correct_ambiguous_raw_data_element(self):\n        \"\"\"Test that correcting ambiguous US/SS raw data element\n        works and converts it to a data element\"\"\"\n        ds = Dataset()\n        elem = RawDataElement(\n            0x00280120, 'US or SS', 2, b'\\xfe\\xff', 0, True, True)\n        ds[0x00280120] = elem\n        ds.PixelRepresentation = 0\n        out = correct_ambiguous_vr_element(elem, ds, True)\n        assert type(out) == DataElement\n        assert out.VR == 'US'\n        assert out.value == 0xfffe\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testcorrectambiguousvrelement", "def", "test_correct_ambiguous_raw_data_element", "self", "test", "that", "correcting", "ambiguous", "us", "ss", "raw", "data", "element", "works", "and", "converts", "it", "to", "a", "data", "element", "ds", "dataset", "elem", "rawdataelement", "0x00280120", "us", "or", "ss", "2", "b", "xfe", "xff", "0", "true", "true", "ds", "0x00280120", "elem", "ds", "pixelrepresentation", "0", "out", "correct_ambiguous_vr_element", "elem", "ds", "true", "assert", "type", "out", "dataelement", "assert", "out", "vr", "us", "assert", "out", "value", "0xfffe"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteAmbiguousVR.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteAmbiguousVR", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteAmbiguousVR\n    def setup(self):\n        # Create a dummy (in memory) file to write to\n        self.fp = DicomBytesIO()\n        self.fp.is_implicit_VR = False\n        self.fp.is_little_endian = True\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteambiguousvr", "def", "setup", "self", "create", "a", "dummy", "in", "memory", "file", "to", "write", "to", "self", "fp", "dicombytesio", "self", "fp", "is_implicit_vr", "false", "self", "fp", "is_little_endian", "true"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteAmbiguousVR.test_write_explicit_vr_raises", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteAmbiguousVR", "func_name": "test_write_explicit_vr_raises", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteAmbiguousVR\n    def test_write_explicit_vr_raises(self):\n        \"\"\"Test writing explicit vr raises exception if unsolved element.\"\"\"\n        ds = Dataset()\n        ds.PerimeterValue = b'\\x00\\x01'\n        with pytest.raises(ValueError):\n            write_dataset(self.fp, ds)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteambiguousvr", "def", "test_write_explicit_vr_raises", "self", "test", "writing", "explicit", "vr", "raises", "exception", "if", "unsolved", "element", "ds", "dataset", "ds", "perimetervalue", "b", "x00", "x01", "with", "pytest", "raises", "valueerror", "write_dataset", "self", "fp", "ds"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteAmbiguousVR.test_write_explicit_vr_little_endian", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteAmbiguousVR", "func_name": "test_write_explicit_vr_little_endian", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteAmbiguousVR\n    def test_write_explicit_vr_little_endian(self):\n        \"\"\"Test writing explicit little data for ambiguous elements.\"\"\"\n        # Create a dataset containing element with ambiguous VRs\n        ref_ds = Dataset()\n        ref_ds.PixelRepresentation = 0\n        ref_ds.SmallestValidPixelValue = b'\\x00\\x01'  # Little endian 256\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ref_ds)\n        file_ds.is_implicit_VR = False\n        file_ds.is_little_endian = True\n        file_ds.save_as(fp, write_like_original=True)\n        fp.seek(0)\n\n        ds = read_dataset(fp, False, True, parent_encoding='latin1')\n        assert 256 == ds.SmallestValidPixelValue\n        assert 'US' == ds[0x00280104].VR\n        assert not ds.read_implicit_vr\n        assert ds.read_little_endian\n        assert ds.read_encoding == 'latin1'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteambiguousvr", "def", "test_write_explicit_vr_little_endian", "self", "test", "writing", "explicit", "little", "data", "for", "ambiguous", "elements", "create", "a", "dataset", "containing", "element", "with", "ambiguous", "vrs", "ref_ds", "dataset", "ref_ds", "pixelrepresentation", "0", "ref_ds", "smallestvalidpixelvalue", "b", "x00", "x01", "little", "endian", "256", "fp", "bytesio", "file_ds", "filedataset", "fp", "ref_ds", "file_ds", "is_implicit_vr", "false", "file_ds", "is_little_endian", "true", "file_ds", "save_as", "fp", "write_like_original", "true", "fp", "seek", "0", "ds", "read_dataset", "fp", "false", "true", "parent_encoding", "latin1", "assert", "256", "ds", "smallestvalidpixelvalue", "assert", "us", "ds", "0x00280104", "vr", "assert", "not", "ds", "read_implicit_vr", "assert", "ds", "read_little_endian", "assert", "ds", "read_encoding", "latin1"], "doc_len": 84}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteAmbiguousVR.test_write_explicit_vr_big_endian", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteAmbiguousVR", "func_name": "test_write_explicit_vr_big_endian", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteAmbiguousVR\n    def test_write_explicit_vr_big_endian(self):\n        \"\"\"Test writing explicit big data for ambiguous elements.\"\"\"\n        # Create a dataset containing element with ambiguous VRs\n        ref_ds = Dataset()\n        ref_ds.PixelRepresentation = 1\n        ref_ds.SmallestValidPixelValue = b'\\x00\\x01'  # Big endian 1\n        ref_ds.SpecificCharacterSet = b'ISO_IR 192'\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ref_ds)\n        file_ds.is_implicit_VR = False\n        file_ds.is_little_endian = False\n        file_ds.save_as(fp, write_like_original=True)\n        fp.seek(0)\n\n        ds = read_dataset(fp, False, False)\n        assert 1 == ds.SmallestValidPixelValue\n        assert 'SS' == ds[0x00280104].VR\n        assert not ds.read_implicit_vr\n        assert not ds.read_little_endian\n        assert ['UTF8'] == ds.read_encoding\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteambiguousvr", "def", "test_write_explicit_vr_big_endian", "self", "test", "writing", "explicit", "big", "data", "for", "ambiguous", "elements", "create", "a", "dataset", "containing", "element", "with", "ambiguous", "vrs", "ref_ds", "dataset", "ref_ds", "pixelrepresentation", "1", "ref_ds", "smallestvalidpixelvalue", "b", "x00", "x01", "big", "endian", "1", "ref_ds", "specificcharacterset", "b", "iso_ir", "192", "fp", "bytesio", "file_ds", "filedataset", "fp", "ref_ds", "file_ds", "is_implicit_vr", "false", "file_ds", "is_little_endian", "false", "file_ds", "save_as", "fp", "write_like_original", "true", "fp", "seek", "0", "ds", "read_dataset", "fp", "false", "false", "assert", "1", "ds", "smallestvalidpixelvalue", "assert", "ss", "ds", "0x00280104", "vr", "assert", "not", "ds", "read_implicit_vr", "assert", "not", "ds", "read_little_endian", "assert", "utf8", "ds", "read_encoding"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWrite.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWrite", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWrite\n    def setup(self):\n        # Create simple dataset for all tests\n        ds = Dataset()\n        ds.PatientName = \"Name^Patient\"\n        ds.InstanceNumber = None\n\n        # Set up a simple nested sequence\n        # first, the innermost sequence\n        subitem1 = Dataset()\n        subitem1.ContourNumber = 1\n        subitem1.ContourData = ['2', '4', '8', '16']\n        subitem2 = Dataset()\n        subitem2.ContourNumber = 2\n        subitem2.ContourData = ['32', '64', '128', '196']\n\n        sub_ds = Dataset()\n        sub_ds.ContourSequence = Sequence((subitem1, subitem2))\n\n        # Now the top-level sequence\n        ds.ROIContourSequence = Sequence((sub_ds,))  # Comma to make one-tuple\n\n        # Store so each test can use it\n        self.ds = ds\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwrite", "def", "setup", "self", "create", "simple", "dataset", "for", "all", "tests", "ds", "dataset", "ds", "patientname", "name", "patient", "ds", "instancenumber", "none", "set", "up", "a", "simple", "nested", "sequence", "first", "the", "innermost", "sequence", "subitem1", "dataset", "subitem1", "contournumber", "1", "subitem1", "contourdata", "2", "4", "8", "16", "subitem2", "dataset", "subitem2", "contournumber", "2", "subitem2", "contourdata", "32", "64", "128", "196", "sub_ds", "dataset", "sub_ds", "contoursequence", "sequence", "subitem1", "subitem2", "now", "the", "top", "level", "sequence", "ds", "roicontoursequence", "sequence", "sub_ds", "comma", "to", "make", "one", "tuple", "store", "so", "each", "test", "can", "use", "it", "self", "ds", "ds"], "doc_len": 86}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWrite.compare_write", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWrite", "func_name": "compare_write", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWrite\n    def compare_write(self, hex_std, file_ds):\n        \"\"\"Write file and compare with expected byte string\n\n        :arg hex_std: the bytes which should be written, as space separated hex\n        :arg file_ds: a FileDataset instance containing the dataset to write\n        \"\"\"\n        out_filename = \"scratch.dcm\"\n        file_ds.save_as(out_filename, write_like_original=True)\n        std = hex2bytes(hex_std)\n        with open(out_filename, 'rb') as f:\n            bytes_written = f.read()\n        # print \"std    :\", bytes2hex(std)\n        # print \"written:\", bytes2hex(bytes_written)\n        same, pos = bytes_identical(std, bytes_written)\n        assert same\n\n        if os.path.exists(out_filename):\n            os.remove(out_filename)  # get rid of the file\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwrite", "def", "compare_write", "self", "hex_std", "file_ds", "write", "file", "and", "compare", "with", "expected", "byte", "string", "arg", "hex_std", "the", "bytes", "which", "should", "be", "written", "as", "space", "separated", "hex", "arg", "file_ds", "a", "filedataset", "instance", "containing", "the", "dataset", "to", "write", "out_filename", "scratch", "dcm", "file_ds", "save_as", "out_filename", "write_like_original", "true", "std", "hex2bytes", "hex_std", "with", "open", "out_filename", "rb", "as", "f", "bytes_written", "f", "read", "print", "std", "bytes2hex", "std", "print", "written", "bytes2hex", "bytes_written", "same", "pos", "bytes_identical", "std", "bytes_written", "assert", "same", "if", "os", "path", "exists", "out_filename", "os", "remove", "out_filename", "get", "rid", "of", "the", "file"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_filewriter.py::TestScratchWrite.testImpl_LE_deflen_write", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestScratchWrite", "func_name": "testImpl_LE_deflen_write", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestScratchWrite\n    def testImpl_LE_deflen_write(self):\n        \"\"\"Scratch Write for implicit VR little endian, defined length SQs\"\"\"\n        file_ds = FileDataset(\"test\", self.ds)\n        self.compare_write(impl_LE_deflen_std_hex, file_ds)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testscratchwrite", "def", "testimpl_le_deflen_write", "self", "scratch", "write", "for", "implicit", "vr", "little", "endian", "defined", "length", "sqs", "file_ds", "filedataset", "test", "self", "ds", "self", "compare_write", "impl_le_deflen_std_hex", "file_ds"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_preamble_default", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_preamble_default", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_preamble_default(self):\n        \"\"\"Test that the default preamble is written correctly when present.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x00' * 128\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == b'\\x00' * 128\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_preamble_default", "self", "test", "that", "the", "default", "preamble", "is", "written", "correctly", "when", "present", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x00", "128", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "b", "x00", "128"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_preamble_custom", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_preamble_custom", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_preamble_custom(self):\n        \"\"\"Test that a custom preamble is written correctly when present.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x01\\x02\\x03\\x04' + b'\\x00' * 124\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == b'\\x01\\x02\\x03\\x04' + b'\\x00' * 124\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_preamble_custom", "self", "test", "that", "a", "custom", "preamble", "is", "written", "correctly", "when", "present", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x01", "x02", "x03", "x04", "b", "x00", "124", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "b", "x01", "x02", "x03", "x04", "b", "x00", "124"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_no_preamble", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_no_preamble", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_no_preamble(self):\n        \"\"\"Test that a default preamble is written when absent.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        del ds.preamble\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == b'\\x00' * 128\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_no_preamble", "self", "test", "that", "a", "default", "preamble", "is", "written", "when", "absent", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "del", "ds", "preamble", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "b", "x00", "128"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_none_preamble", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_none_preamble", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_none_preamble(self):\n        \"\"\"Test that a default preamble is written when None.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = None\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == b'\\x00' * 128\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_none_preamble", "self", "test", "that", "a", "default", "preamble", "is", "written", "when", "none", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "ds", "preamble", "none", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "b", "x00", "128"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_bad_preamble", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_bad_preamble", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_bad_preamble(self):\n        \"\"\"Test that ValueError is raised when preamble is bad.\"\"\"\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x00' * 127\n        with pytest.raises(ValueError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n        ds.preamble = b'\\x00' * 129\n        with pytest.raises(ValueError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_bad_preamble", "self", "test", "that", "valueerror", "is", "raised", "when", "preamble", "is", "bad", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x00", "127", "with", "pytest", "raises", "valueerror", "ds", "save_as", "dicombytesio", "write_like_original", "false", "ds", "preamble", "b", "x00", "129", "with", "pytest", "raises", "valueerror", "ds", "save_as", "dicombytesio", "write_like_original", "false"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_prefix", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_prefix", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_prefix(self):\n        \"\"\"Test that the 'DICM' prefix\n           is written with preamble.\"\"\"\n        # Has preamble\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x00' * 128\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(128)\n        assert fp.read(4) == b'DICM'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_prefix", "self", "test", "that", "the", "dicm", "prefix", "is", "written", "with", "preamble", "has", "preamble", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x00", "128", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "128", "assert", "fp", "read", "4", "b", "dicm"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_prefix_none", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_prefix_none", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_prefix_none(self):\n        \"\"\"Test the 'DICM' prefix is written when preamble is None\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = None\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(128)\n        assert fp.read(4) == b'DICM'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_prefix_none", "self", "test", "the", "dicm", "prefix", "is", "written", "when", "preamble", "is", "none", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "ds", "preamble", "none", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "128", "assert", "fp", "read", "4", "b", "dicm"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_ds_changed", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_ds_changed", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_ds_changed(self):\n        \"\"\"Test writing the dataset changes its file_meta.\"\"\"\n        ds = dcmread(rtplan_name)\n        ref_ds = dcmread(rtplan_name)\n        for ref_elem, test_elem in zip(ref_ds.file_meta, ds.file_meta):\n            assert ref_elem == test_elem\n\n        ds.save_as(DicomBytesIO(), write_like_original=False)\n        assert ref_ds.file_meta != ds.file_meta\n        del ref_ds.file_meta\n        del ds.file_meta\n\n        # Ensure no RawDataElements in ref_ds and ds\n        for _ in ref_ds:\n            pass\n        for _ in ds:\n            pass\n        assert ref_ds == ds\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_ds_changed", "self", "test", "writing", "the", "dataset", "changes", "its", "file_meta", "ds", "dcmread", "rtplan_name", "ref_ds", "dcmread", "rtplan_name", "for", "ref_elem", "test_elem", "in", "zip", "ref_ds", "file_meta", "ds", "file_meta", "assert", "ref_elem", "test_elem", "ds", "save_as", "dicombytesio", "write_like_original", "false", "assert", "ref_ds", "file_meta", "ds", "file_meta", "del", "ref_ds", "file_meta", "del", "ds", "file_meta", "ensure", "no", "rawdataelements", "in", "ref_ds", "and", "ds", "for", "_", "in", "ref_ds", "pass", "for", "_", "in", "ds", "pass", "assert", "ref_ds", "ds"], "doc_len": 69}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_raw_elements_preserved_implicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_raw_elements_preserved_implicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_raw_elements_preserved_implicit_vr(self):\n        \"\"\"Test writing the dataset preserves raw elements.\"\"\"\n        ds = dcmread(rtplan_name)\n\n        # raw data elements after reading\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100020).is_raw  # Patient ID\n        assert ds.get_item(0x300A0006).is_raw  # RT Plan Date\n        assert ds.get_item(0x300A0010).is_raw  # Dose Reference Sequence\n\n        ds.save_as(DicomBytesIO(), write_like_original=False)\n\n        # data set still contains raw data elements after writing\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100020).is_raw  # Patient ID\n        assert ds.get_item(0x300A0006).is_raw  # RT Plan Date\n        assert ds.get_item(0x300A0010).is_raw  # Dose Reference Sequence\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_raw_elements_preserved_implicit_vr", "self", "test", "writing", "the", "dataset", "preserves", "raw", "elements", "ds", "dcmread", "rtplan_name", "raw", "data", "elements", "after", "reading", "assert", "ds", "get_item", "0x00080070", "is_raw", "manufacturer", "assert", "ds", "get_item", "0x00100020", "is_raw", "patient", "id", "assert", "ds", "get_item", "0x300a0006", "is_raw", "rt", "plan", "date", "assert", "ds", "get_item", "0x300a0010", "is_raw", "dose", "reference", "sequence", "ds", "save_as", "dicombytesio", "write_like_original", "false", "data", "set", "still", "contains", "raw", "data", "elements", "after", "writing", "assert", "ds", "get_item", "0x00080070", "is_raw", "manufacturer", "assert", "ds", "get_item", "0x00100020", "is_raw", "patient", "id", "assert", "ds", "get_item", "0x300a0006", "is_raw", "rt", "plan", "date", "assert", "ds", "get_item", "0x300a0010", "is_raw", "dose", "reference", "sequence"], "doc_len": 95}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_raw_elements_preserved_explicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_raw_elements_preserved_explicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_raw_elements_preserved_explicit_vr(self):\n        \"\"\"Test writing the dataset preserves raw elements.\"\"\"\n        ds = dcmread(color_pl_name)\n\n        # raw data elements after reading\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100010).is_raw  # Patient Name\n        assert ds.get_item(0x00080030).is_raw  # Study Time\n        assert ds.get_item(0x00089215).is_raw  # Derivation Code Sequence\n\n        ds.save_as(DicomBytesIO(), write_like_original=False)\n\n        # data set still contains raw data elements after writing\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100010).is_raw  # Patient Name\n        assert ds.get_item(0x00080030).is_raw  # Study Time\n        assert ds.get_item(0x00089215).is_raw  # Derivation Code Sequence\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_raw_elements_preserved_explicit_vr", "self", "test", "writing", "the", "dataset", "preserves", "raw", "elements", "ds", "dcmread", "color_pl_name", "raw", "data", "elements", "after", "reading", "assert", "ds", "get_item", "0x00080070", "is_raw", "manufacturer", "assert", "ds", "get_item", "0x00100010", "is_raw", "patient", "name", "assert", "ds", "get_item", "0x00080030", "is_raw", "study", "time", "assert", "ds", "get_item", "0x00089215", "is_raw", "derivation", "code", "sequence", "ds", "save_as", "dicombytesio", "write_like_original", "false", "data", "set", "still", "contains", "raw", "data", "elements", "after", "writing", "assert", "ds", "get_item", "0x00080070", "is_raw", "manufacturer", "assert", "ds", "get_item", "0x00100010", "is_raw", "patient", "name", "assert", "ds", "get_item", "0x00080030", "is_raw", "study", "time", "assert", "ds", "get_item", "0x00089215", "is_raw", "derivation", "code", "sequence"], "doc_len": 93}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_implicit_to_explicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_implicit_to_explicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_implicit_to_explicit_vr(self):\n        # make sure conversion from implicit to explicit VR works\n        # without private tags\n        ds = dcmread(mr_implicit_name)\n        ds.is_implicit_VR = False\n        ds.file_meta.TransferSyntaxUID = '1.2.840.10008.1.2.1'\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        ds_explicit = dcmread(mr_name)\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_implicit_to_explicit_vr", "self", "make", "sure", "conversion", "from", "implicit", "to", "explicit", "vr", "works", "without", "private", "tags", "ds", "dcmread", "mr_implicit_name", "ds", "is_implicit_vr", "false", "ds", "file_meta", "transfersyntaxuid", "1", "2", "840", "10008", "1", "2", "1", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "ds_explicit", "dcmread", "mr_name", "for", "elem_in", "elem_out", "in", "zip", "ds_explicit", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 62}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_write_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_write_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_write_dataset(self):\n        # make sure writing and reading back a dataset works correctly\n        ds = dcmread(mr_implicit_name)\n        fp = DicomBytesIO()\n        write_dataset(fp, ds)\n        fp.seek(0)\n        ds_read = read_dataset(fp, is_implicit_VR=True, is_little_endian=True)\n        for elem_orig, elem_read in zip(ds_read, ds):\n            assert elem_orig == elem_read\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_write_dataset", "self", "make", "sure", "writing", "and", "reading", "back", "a", "dataset", "works", "correctly", "ds", "dcmread", "mr_implicit_name", "fp", "dicombytesio", "write_dataset", "fp", "ds", "fp", "seek", "0", "ds_read", "read_dataset", "fp", "is_implicit_vr", "true", "is_little_endian", "true", "for", "elem_orig", "elem_read", "in", "zip", "ds_read", "ds", "assert", "elem_orig", "elem_read"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_write_dataset_with_explicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_write_dataset_with_explicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_write_dataset_with_explicit_vr(self):\n        # make sure conversion from implicit to explicit VR does not\n        # raise (regression test for #632)\n        ds = dcmread(mr_implicit_name)\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = False\n        fp.is_little_endian = True\n        write_dataset(fp, ds)\n        fp.seek(0)\n        ds_read = read_dataset(fp, is_implicit_VR=False, is_little_endian=True)\n        for elem_orig, elem_read in zip(ds_read, ds):\n            assert elem_orig == elem_read\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_write_dataset_with_explicit_vr", "self", "make", "sure", "conversion", "from", "implicit", "to", "explicit", "vr", "does", "not", "raise", "regression", "test", "for", "632", "ds", "dcmread", "mr_implicit_name", "fp", "dicombytesio", "fp", "is_implicit_vr", "false", "fp", "is_little_endian", "true", "write_dataset", "fp", "ds", "fp", "seek", "0", "ds_read", "read_dataset", "fp", "is_implicit_vr", "false", "is_little_endian", "true", "for", "elem_orig", "elem_read", "in", "zip", "ds_read", "ds", "assert", "elem_orig", "elem_read"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_implicit_to_explicit_vr_using_destination", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_implicit_to_explicit_vr_using_destination", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_implicit_to_explicit_vr_using_destination(self):\n        # make sure conversion from implicit to explicit VR works\n        # if setting the property in the destination\n        ds = dcmread(mr_implicit_name)\n        ds.is_implicit_VR = False\n        ds.file_meta.TransferSyntaxUID = '1.2.840.10008.1.2.1'\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = False\n        fp.is_little_endian = True\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        ds_explicit = dcmread(mr_name)\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_implicit_to_explicit_vr_using_destination", "self", "make", "sure", "conversion", "from", "implicit", "to", "explicit", "vr", "works", "if", "setting", "the", "property", "in", "the", "destination", "ds", "dcmread", "mr_implicit_name", "ds", "is_implicit_vr", "false", "ds", "file_meta", "transfersyntaxuid", "1", "2", "840", "10008", "1", "2", "1", "fp", "dicombytesio", "fp", "is_implicit_vr", "false", "fp", "is_little_endian", "true", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "ds_explicit", "dcmread", "mr_name", "for", "elem_in", "elem_out", "in", "zip", "ds_explicit", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 72}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_explicit_to_implicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_explicit_to_implicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_explicit_to_implicit_vr(self):\n        # make sure conversion from explicit to implicit VR works\n        # without private tags\n        ds = dcmread(mr_name)\n        ds.is_implicit_VR = True\n        ds.file_meta.TransferSyntaxUID = uid.ImplicitVRLittleEndian\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        ds_implicit = dcmread(mr_implicit_name)\n\n        for elem_in, elem_out in zip(ds_implicit, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_explicit_to_implicit_vr", "self", "make", "sure", "conversion", "from", "explicit", "to", "implicit", "vr", "works", "without", "private", "tags", "ds", "dcmread", "mr_name", "ds", "is_implicit_vr", "true", "ds", "file_meta", "transfersyntaxuid", "uid", "implicitvrlittleendian", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "ds_implicit", "dcmread", "mr_implicit_name", "for", "elem_in", "elem_out", "in", "zip", "ds_implicit", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_big_to_little_endian", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_big_to_little_endian", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_big_to_little_endian(self):\n        # make sure conversion from big to little endian works\n        # except for pixel data\n        ds = dcmread(mr_bigendian_name)\n        ds.is_little_endian = True\n        ds.file_meta.TransferSyntaxUID = uid.ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        ds_explicit = dcmread(mr_name)\n\n        # pixel data is not converted automatically\n        del ds_out.PixelData\n        del ds_explicit.PixelData\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_big_to_little_endian", "self", "make", "sure", "conversion", "from", "big", "to", "little", "endian", "works", "except", "for", "pixel", "data", "ds", "dcmread", "mr_bigendian_name", "ds", "is_little_endian", "true", "ds", "file_meta", "transfersyntaxuid", "uid", "explicitvrlittleendian", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "ds_explicit", "dcmread", "mr_name", "pixel", "data", "is", "not", "converted", "automatically", "del", "ds_out", "pixeldata", "del", "ds_explicit", "pixeldata", "for", "elem_in", "elem_out", "in", "zip", "ds_explicit", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 70}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_little_to_big_endian", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_little_to_big_endian", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_little_to_big_endian(self):\n        # make sure conversion from little to big endian works\n        # except for pixel data\n        ds = dcmread(mr_name)\n        ds.is_little_endian = False\n        ds.file_meta.TransferSyntaxUID = uid.ExplicitVRBigEndian\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        ds_explicit = dcmread(mr_bigendian_name)\n\n        # pixel data is not converted automatically\n        del ds_out.PixelData\n        del ds_explicit.PixelData\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_little_to_big_endian", "self", "make", "sure", "conversion", "from", "little", "to", "big", "endian", "works", "except", "for", "pixel", "data", "ds", "dcmread", "mr_name", "ds", "is_little_endian", "false", "ds", "file_meta", "transfersyntaxuid", "uid", "explicitvrbigendian", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "ds_explicit", "dcmread", "mr_bigendian_name", "pixel", "data", "is", "not", "converted", "automatically", "del", "ds_out", "pixeldata", "del", "ds_explicit", "pixeldata", "for", "elem_in", "elem_out", "in", "zip", "ds_explicit", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 70}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_changed_character_set", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_changed_character_set", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_changed_character_set(self):\n        \"\"\"Make sure that a changed character set is reflected\n        in the written data elements.\"\"\"\n        ds = dcmread(multiPN_name)\n        # Latin 1 original encoding\n        assert ds.get_item(0x00100010).value == b'Buc^J\\xe9r\\xf4me'\n\n        # change encoding to UTF-8\n        ds.SpecificCharacterSet = 'ISO_IR 192'\n        fp = DicomBytesIO()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        # patient name shall be UTF-8 encoded\n        assert ds_out.get_item(0x00100010).value == b'Buc^J\\xc3\\xa9r\\xc3\\xb4me'\n        # decoded values shall be the same as in original dataset\n        for elem_in, elem_out in zip(ds, ds_out):\n            assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_changed_character_set", "self", "make", "sure", "that", "a", "changed", "character", "set", "is", "reflected", "in", "the", "written", "data", "elements", "ds", "dcmread", "multipn_name", "latin", "1", "original", "encoding", "assert", "ds", "get_item", "0x00100010", "value", "b", "buc", "j", "xe9r", "xf4me", "change", "encoding", "to", "utf", "8", "ds", "specificcharacterset", "iso_ir", "192", "fp", "dicombytesio", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_out", "dcmread", "fp", "patient", "name", "shall", "be", "utf", "8", "encoded", "assert", "ds_out", "get_item", "0x00100010", "value", "b", "buc", "j", "xc3", "xa9r", "xc3", "xb4me", "decoded", "values", "shall", "be", "the", "same", "as", "in", "original", "dataset", "for", "elem_in", "elem_out", "in", "zip", "ds", "ds_out", "assert", "elem_in", "elem_out"], "doc_len": 100}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_transfer_syntax_added", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_transfer_syntax_added", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_transfer_syntax_added(self):\n        \"\"\"Test TransferSyntaxUID is added/updated if possible.\"\"\"\n        # Only done for ImplVR LE and ExplVR BE\n        # Added\n        ds = dcmread(rtplan_name)\n        ds.is_implicit_VR = True\n        ds.is_little_endian = True\n        ds.save_as(DicomBytesIO(), write_like_original=False)\n        assert ds.file_meta.TransferSyntaxUID == ImplicitVRLittleEndian\n\n        # Updated\n        ds.is_implicit_VR = False\n        ds.is_little_endian = False\n        ds.save_as(DicomBytesIO(), write_like_original=False)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRBigEndian\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_transfer_syntax_added", "self", "test", "transfersyntaxuid", "is", "added", "updated", "if", "possible", "only", "done", "for", "implvr", "le", "and", "explvr", "be", "added", "ds", "dcmread", "rtplan_name", "ds", "is_implicit_vr", "true", "ds", "is_little_endian", "true", "ds", "save_as", "dicombytesio", "write_like_original", "false", "assert", "ds", "file_meta", "transfersyntaxuid", "implicitvrlittleendian", "updated", "ds", "is_implicit_vr", "false", "ds", "is_little_endian", "false", "ds", "save_as", "dicombytesio", "write_like_original", "false", "assert", "ds", "file_meta", "transfersyntaxuid", "explicitvrbigendian"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_private_tag_vr_from_implicit_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_private_tag_vr_from_implicit_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_private_tag_vr_from_implicit_data(self):\n        \"\"\"Test that private tags have the correct VR if converting\n        a dataset from implicit to explicit VR.\n        \"\"\"\n        # convert a dataset with private tags to Implicit VR\n        ds_orig = dcmread(ct_name)\n        ds_orig.is_implicit_VR = True\n        ds_orig.is_little_endian = True\n        fp = DicomBytesIO()\n        ds_orig.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_impl = dcmread(fp)\n\n        # convert the dataset back to explicit VR - private tag VR now unknown\n        ds_impl.is_implicit_VR = False\n        ds_impl.is_little_endian = True\n        ds_impl.file_meta.TransferSyntaxUID = uid.ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        ds_impl.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_expl = dcmread(fp)\n\n        assert ds_expl[(0x0009, 0x0010)].VR == 'LO'  # private creator\n        assert ds_expl[(0x0009, 0x1001)].VR == 'UN'  # originally LO\n        assert ds_expl[(0x0009, 0x10e7)].VR == 'UN'  # originally UL\n        assert ds_expl[(0x0043, 0x1010)].VR == 'UN'  # originally US\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_private_tag_vr_from_implicit_data", "self", "test", "that", "private", "tags", "have", "the", "correct", "vr", "if", "converting", "a", "dataset", "from", "implicit", "to", "explicit", "vr", "convert", "a", "dataset", "with", "private", "tags", "to", "implicit", "vr", "ds_orig", "dcmread", "ct_name", "ds_orig", "is_implicit_vr", "true", "ds_orig", "is_little_endian", "true", "fp", "dicombytesio", "ds_orig", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_impl", "dcmread", "fp", "convert", "the", "dataset", "back", "to", "explicit", "vr", "private", "tag", "vr", "now", "unknown", "ds_impl", "is_implicit_vr", "false", "ds_impl", "is_little_endian", "true", "ds_impl", "file_meta", "transfersyntaxuid", "uid", "explicitvrlittleendian", "fp", "dicombytesio", "ds_impl", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_expl", "dcmread", "fp", "assert", "ds_expl", "0x0009", "0x0010", "vr", "lo", "private", "creator", "assert", "ds_expl", "0x0009", "0x1001", "vr", "un", "originally", "lo", "assert", "ds_expl", "0x0009", "0x10e7", "vr", "un", "originally", "ul", "assert", "ds_expl", "0x0043", "0x1010", "vr", "un", "originally", "us"], "doc_len": 124}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_convert_rgb_from_implicit_to_explicit_vr", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_convert_rgb_from_implicit_to_explicit_vr", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_convert_rgb_from_implicit_to_explicit_vr(self):\n        \"\"\"Test converting an RGB dataset from implicit to explicit VR\n        and vice verse.\"\"\"\n        ds_orig = dcmread(sc_rgb_name)\n        ds_orig.is_implicit_VR = True\n        ds_orig.is_little_endian = True\n        fp = DicomBytesIO()\n        ds_orig.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        ds_impl = dcmread(fp)\n        for elem_orig, elem_conv in zip(ds_orig, ds_impl):\n            assert elem_orig.value == elem_conv.value\n        assert 'OW' == ds_impl[0x7fe00010].VR\n\n        ds_impl.is_implicit_VR = False\n        ds_impl.is_little_endian = True\n        ds_impl.file_meta.TransferSyntaxUID = uid.ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        ds_impl.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        # used to raise, see #620\n        ds_expl = dcmread(fp)\n        for elem_orig, elem_conv in zip(ds_orig, ds_expl):\n            assert elem_orig.value == elem_conv.value\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_convert_rgb_from_implicit_to_explicit_vr", "self", "test", "converting", "an", "rgb", "dataset", "from", "implicit", "to", "explicit", "vr", "and", "vice", "verse", "ds_orig", "dcmread", "sc_rgb_name", "ds_orig", "is_implicit_vr", "true", "ds_orig", "is_little_endian", "true", "fp", "dicombytesio", "ds_orig", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "ds_impl", "dcmread", "fp", "for", "elem_orig", "elem_conv", "in", "zip", "ds_orig", "ds_impl", "assert", "elem_orig", "value", "elem_conv", "value", "assert", "ow", "ds_impl", "0x7fe00010", "vr", "ds_impl", "is_implicit_vr", "false", "ds_impl", "is_little_endian", "true", "ds_impl", "file_meta", "transfersyntaxuid", "uid", "explicitvrlittleendian", "fp", "dicombytesio", "ds_impl", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "used", "to", "raise", "see", "620", "ds_expl", "dcmread", "fp", "for", "elem_orig", "elem_conv", "in", "zip", "ds_orig", "ds_expl", "assert", "elem_orig", "value", "elem_conv", "value"], "doc_len": 101}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_transfer_syntax_not_added", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_transfer_syntax_not_added", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_transfer_syntax_not_added(self):\n        \"\"\"Test TransferSyntaxUID is not added if ExplVRLE.\"\"\"\n        ds = dcmread(rtplan_name)\n        del ds.file_meta.TransferSyntaxUID\n        ds.is_implicit_VR = False\n        ds.is_little_endian = True\n        with pytest.raises(ValueError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n        assert 'TransferSyntaxUID' not in ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_transfer_syntax_not_added", "self", "test", "transfersyntaxuid", "is", "not", "added", "if", "explvrle", "ds", "dcmread", "rtplan_name", "del", "ds", "file_meta", "transfersyntaxuid", "ds", "is_implicit_vr", "false", "ds", "is_little_endian", "true", "with", "pytest", "raises", "valueerror", "ds", "save_as", "dicombytesio", "write_like_original", "false", "assert", "transfersyntaxuid", "not", "in", "ds", "file_meta"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_transfer_syntax_raises", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_transfer_syntax_raises", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_transfer_syntax_raises(self):\n        \"\"\"Test TransferSyntaxUID is raises\n           NotImplementedError if ImplVRBE.\"\"\"\n        ds = dcmread(rtplan_name)\n        ds.is_implicit_VR = True\n        ds.is_little_endian = False\n        with pytest.raises(NotImplementedError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_transfer_syntax_raises", "self", "test", "transfersyntaxuid", "is", "raises", "notimplementederror", "if", "implvrbe", "ds", "dcmread", "rtplan_name", "ds", "is_implicit_vr", "true", "ds", "is_little_endian", "false", "with", "pytest", "raises", "notimplementederror", "ds", "save_as", "dicombytesio", "write_like_original", "false"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_media_storage_sop_class_uid_added", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_media_storage_sop_class_uid_added", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_media_storage_sop_class_uid_added(self):\n        \"\"\"Test MediaStorageSOPClassUID and InstanceUID are added.\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        ds.SOPClassUID = CTImageStorage\n        ds.SOPInstanceUID = '1.2.3'\n        ds.save_as(fp, write_like_original=False)\n        assert ds.file_meta.MediaStorageSOPClassUID == CTImageStorage\n        assert ds.file_meta.MediaStorageSOPInstanceUID == '1.2.3'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_media_storage_sop_class_uid_added", "self", "test", "mediastoragesopclassuid", "and", "instanceuid", "are", "added", "fp", "dicombytesio", "ds", "dataset", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "ds", "sopclassuid", "ctimagestorage", "ds", "sopinstanceuid", "1", "2", "3", "ds", "save_as", "fp", "write_like_original", "false", "assert", "ds", "file_meta", "mediastoragesopclassuid", "ctimagestorage", "assert", "ds", "file_meta", "mediastoragesopinstanceuid", "1", "2", "3"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_write_no_file_meta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_write_no_file_meta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_write_no_file_meta(self):\n        \"\"\"Test writing a dataset with no file_meta\"\"\"\n        fp = DicomBytesIO()\n        version = 'PYDICOM ' + base_version\n        ds = dcmread(rtplan_name)\n        transfer_syntax = ds.file_meta.TransferSyntaxUID\n        ds.file_meta = Dataset()\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == ds.SOPClassUID\n        assert out.file_meta.MediaStorageSOPInstanceUID == ds.SOPInstanceUID\n        assert (out.file_meta.ImplementationClassUID ==\n                PYDICOM_IMPLEMENTATION_UID)\n        assert out.file_meta.ImplementationVersionName == version\n        assert out.file_meta.TransferSyntaxUID == transfer_syntax\n\n        fp = DicomBytesIO()\n        del ds.file_meta\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == ds.SOPClassUID\n        assert out.file_meta.MediaStorageSOPInstanceUID == ds.SOPInstanceUID\n        assert (out.file_meta.ImplementationClassUID ==\n                PYDICOM_IMPLEMENTATION_UID)\n        assert out.file_meta.ImplementationVersionName == version\n        assert out.file_meta.TransferSyntaxUID == transfer_syntax\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_write_no_file_meta", "self", "test", "writing", "a", "dataset", "with", "no", "file_meta", "fp", "dicombytesio", "version", "pydicom", "base_version", "ds", "dcmread", "rtplan_name", "transfer_syntax", "ds", "file_meta", "transfersyntaxuid", "ds", "file_meta", "dataset", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "out", "dcmread", "fp", "assert", "out", "file_meta", "mediastoragesopclassuid", "ds", "sopclassuid", "assert", "out", "file_meta", "mediastoragesopinstanceuid", "ds", "sopinstanceuid", "assert", "out", "file_meta", "implementationclassuid", "pydicom_implementation_uid", "assert", "out", "file_meta", "implementationversionname", "version", "assert", "out", "file_meta", "transfersyntaxuid", "transfer_syntax", "fp", "dicombytesio", "del", "ds", "file_meta", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "out", "dcmread", "fp", "assert", "out", "file_meta", "mediastoragesopclassuid", "ds", "sopclassuid", "assert", "out", "file_meta", "mediastoragesopinstanceuid", "ds", "sopinstanceuid", "assert", "out", "file_meta", "implementationclassuid", "pydicom_implementation_uid", "assert", "out", "file_meta", "implementationversionname", "version", "assert", "out", "file_meta", "transfersyntaxuid", "transfer_syntax"], "doc_len": 111}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_raise_no_file_meta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_raise_no_file_meta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_raise_no_file_meta(self):\n        \"\"\"Test exception is raised if trying to write with no file_meta.\"\"\"\n        ds = dcmread(rtplan_name)\n        del ds.SOPInstanceUID\n        ds.file_meta = Dataset()\n        with pytest.raises(ValueError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n        del ds.file_meta\n        with pytest.raises(ValueError):\n            ds.save_as(DicomBytesIO(), write_like_original=False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_raise_no_file_meta", "self", "test", "exception", "is", "raised", "if", "trying", "to", "write", "with", "no", "file_meta", "ds", "dcmread", "rtplan_name", "del", "ds", "sopinstanceuid", "ds", "file_meta", "dataset", "with", "pytest", "raises", "valueerror", "ds", "save_as", "dicombytesio", "write_like_original", "false", "del", "ds", "file_meta", "with", "pytest", "raises", "valueerror", "ds", "save_as", "dicombytesio", "write_like_original", "false"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_add_file_meta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_add_file_meta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_add_file_meta(self):\n        \"\"\"Test that file_meta is added if it doesn't exist\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        ds.SOPClassUID = CTImageStorage\n        ds.SOPInstanceUID = '1.2.3'\n        ds.save_as(fp, write_like_original=False)\n        assert isinstance(ds.file_meta, Dataset)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_add_file_meta", "self", "test", "that", "file_meta", "is", "added", "if", "it", "doesn", "t", "exist", "fp", "dicombytesio", "ds", "dataset", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "ds", "sopclassuid", "ctimagestorage", "ds", "sopinstanceuid", "1", "2", "3", "ds", "save_as", "fp", "write_like_original", "false", "assert", "isinstance", "ds", "file_meta", "dataset"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_standard", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_standard", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_standard(self):\n        \"\"\"Test preamble + file_meta + dataset written OK.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == preamble\n        assert fp.read(4) == b'DICM'\n\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert ds_out.preamble == preamble\n        assert 'PatientID' in ds_out\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_standard", "self", "test", "preamble", "file_meta", "dataset", "written", "ok", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "preamble", "assert", "fp", "read", "4", "b", "dicm", "fp", "seek", "0", "ds_out", "dcmread", "fp", "assert", "ds_out", "preamble", "preamble", "assert", "patientid", "in", "ds_out", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta"], "doc_len": 60}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteToStandard.test_commandset_no_written", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteToStandard", "func_name": "test_commandset_no_written", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteToStandard\n    def test_commandset_no_written(self):\n        \"\"\"Test that Command Set elements aren't written.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        ds.MessageID = 3\n        ds.save_as(fp, write_like_original=False)\n        fp.seek(0)\n        assert fp.read(128) == preamble\n        assert fp.read(4) == b'DICM'\n        assert 'MessageID' in ds\n\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert ds_out.preamble == preamble\n        assert 'PatientID' in ds_out\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n        assert 'MessageID' not in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetostandard", "def", "test_commandset_no_written", "self", "test", "that", "command", "set", "elements", "aren", "t", "written", "fp", "dicombytesio", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "ds", "messageid", "3", "ds", "save_as", "fp", "write_like_original", "false", "fp", "seek", "0", "assert", "fp", "read", "128", "preamble", "assert", "fp", "read", "4", "b", "dicm", "assert", "messageid", "in", "ds", "fp", "seek", "0", "ds_out", "dcmread", "fp", "assert", "ds_out", "preamble", "preamble", "assert", "patientid", "in", "ds_out", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "messageid", "not", "in", "ds_out"], "doc_len": 74}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_bad_elements", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_bad_elements", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_bad_elements(self):\n        \"\"\"Test that non-group 2 elements aren't written to the file meta.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.PatientID = '12345678'\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        with pytest.raises(ValueError):\n            write_file_meta_info(fp, meta, enforce_standard=True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_bad_elements", "self", "test", "that", "non", "group", "2", "elements", "aren", "t", "written", "to", "the", "file", "meta", "fp", "dicombytesio", "meta", "dataset", "meta", "patientid", "12345678", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "with", "pytest", "raises", "valueerror", "write_file_meta_info", "fp", "meta", "enforce_standard", "true"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_missing_elements", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_missing_elements", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_missing_elements(self):\n        \"\"\"Test that missing required elements raises ValueError.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        with pytest.raises(ValueError):\n            write_file_meta_info(fp, meta)\n        meta.MediaStorageSOPClassUID = '1.1'\n        with pytest.raises(ValueError):\n            write_file_meta_info(fp, meta)\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        with pytest.raises(ValueError):\n            write_file_meta_info(fp, meta)\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_missing_elements", "self", "test", "that", "missing", "required", "elements", "raises", "valueerror", "fp", "dicombytesio", "meta", "dataset", "with", "pytest", "raises", "valueerror", "write_file_meta_info", "fp", "meta", "meta", "mediastoragesopclassuid", "1", "1", "with", "pytest", "raises", "valueerror", "write_file_meta_info", "fp", "meta", "meta", "mediastoragesopinstanceuid", "1", "2", "with", "pytest", "raises", "valueerror", "write_file_meta_info", "fp", "meta", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_group_length", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_group_length", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_group_length(self):\n        \"\"\"Test that the value for FileMetaInformationGroupLength is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        fp.seek(8)\n        test_length = unpack('<I', fp.read(4))[0]\n        assert test_length == 66 + class_length + version_length\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_group_length", "self", "test", "that", "the", "value", "for", "filemetainformationgrouplength", "is", "ok", "fp", "dicombytesio", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "class_length", "len", "pydicom_implementation_uid", "if", "class_length", "2", "class_length", "1", "version_length", "len", "meta", "implementationversionname", "padded", "to", "even", "length", "if", "version_length", "2", "version_length", "1", "fp", "seek", "8", "test_length", "unpack", "i", "fp", "read", "4", "0", "assert", "test_length", "66", "class_length", "version_length"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_group_length_updated", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_group_length_updated", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_group_length_updated(self):\n        \"\"\"Test that FileMetaInformationGroupLength gets updated if present.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 100  # Not actual length\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        fp.seek(8)\n        test_length = unpack('<I', fp.read(4))[0]\n        assert test_length == (61 + class_length\n                               + version_length\n                               + len(base_version))\n        # Check original file meta is unchanged/updated\n        assert meta.FileMetaInformationGroupLength == test_length\n        assert meta.FileMetaInformationVersion == b'\\x00\\x01'\n        assert meta.MediaStorageSOPClassUID == '1.1'\n        assert meta.MediaStorageSOPInstanceUID == '1.2'\n        assert meta.TransferSyntaxUID == '1.3'\n        # Updated to meet standard\n        assert meta.ImplementationClassUID == PYDICOM_IMPLEMENTATION_UID\n        assert meta.ImplementationVersionName == 'PYDICOM ' + base_version\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_group_length_updated", "self", "test", "that", "filemetainformationgrouplength", "gets", "updated", "if", "present", "fp", "dicombytesio", "meta", "dataset", "meta", "filemetainformationgrouplength", "100", "not", "actual", "length", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "class_length", "len", "pydicom_implementation_uid", "if", "class_length", "2", "class_length", "1", "version_length", "len", "meta", "implementationversionname", "padded", "to", "even", "length", "if", "version_length", "2", "version_length", "1", "fp", "seek", "8", "test_length", "unpack", "i", "fp", "read", "4", "0", "assert", "test_length", "61", "class_length", "version_length", "len", "base_version", "check", "original", "file", "meta", "is", "unchanged", "updated", "assert", "meta", "filemetainformationgrouplength", "test_length", "assert", "meta", "filemetainformationversion", "b", "x00", "x01", "assert", "meta", "mediastoragesopclassuid", "1", "1", "assert", "meta", "mediastoragesopinstanceuid", "1", "2", "assert", "meta", "transfersyntaxuid", "1", "3", "updated", "to", "meet", "standard", "assert", "meta", "implementationclassuid", "pydicom_implementation_uid", "assert", "meta", "implementationversionname", "pydicom", "base_version"], "doc_len": 125}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_version", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_version", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_version(self):\n        \"\"\"Test that the value for FileMetaInformationVersion is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        fp.seek(12 + 12)\n        assert fp.read(2) == b'\\x00\\x01'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_version", "self", "test", "that", "the", "value", "for", "filemetainformationversion", "is", "ok", "fp", "dicombytesio", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "fp", "seek", "12", "12", "assert", "fp", "read", "2", "b", "x00", "x01"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_implementation_version_name_length", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_implementation_version_name_length", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_implementation_version_name_length(self):\n        \"\"\"Test that the written Implementation Version Name length is OK\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        version_length = len(meta.ImplementationVersionName)\n        # VR of SH, 16 bytes max\n        assert version_length <= 16\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_implementation_version_name_length", "self", "test", "that", "the", "written", "implementation", "version", "name", "length", "is", "ok", "fp", "dicombytesio", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "version_length", "len", "meta", "implementationversionname", "vr", "of", "sh", "16", "bytes", "max", "assert", "version_length", "16"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_implementation_class_uid_length", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_implementation_class_uid_length", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_implementation_class_uid_length(self):\n        \"\"\"Test that the written Implementation Class UID length is OK\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        class_length = len(meta.ImplementationClassUID)\n        # VR of UI, 64 bytes max\n        assert class_length <= 64\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_implementation_class_uid_length", "self", "test", "that", "the", "written", "implementation", "class", "uid", "length", "is", "ok", "fp", "dicombytesio", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "class_length", "len", "meta", "implementationclassuid", "vr", "of", "ui", "64", "bytes", "max", "assert", "class_length", "64"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoToStandard.test_filelike_position", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoToStandard", "func_name": "test_filelike_position", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoToStandard\n    def test_filelike_position(self):\n        \"\"\"Test that the file-like's ending position is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        # 8 + 4 bytes FileMetaInformationGroupLength\n        # 12 + 2 bytes FileMetaInformationVersion\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + XX bytes ImplementationClassUID\n        # 8 + YY bytes ImplementationVersionName\n        # 78 + XX + YY bytes total\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        assert fp.tell() == 78 + class_length + version_length\n\n        fp = DicomBytesIO()\n        # 8 + 6 bytes MediaStorageSOPInstanceUID\n        meta.MediaStorageSOPInstanceUID = '1.4.1'\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        # Check File Meta length\n        assert fp.tell() == 80 + class_length + version_length\n\n        # Check Group Length - 68 + XX + YY as bytes\n        fp.seek(8)\n        test_length = unpack('<I', fp.read(4))[0]\n        assert test_length == 68 + class_length + version_length\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfotostandard", "def", "test_filelike_position", "self", "test", "that", "the", "file", "like", "s", "ending", "position", "is", "ok", "fp", "dicombytesio", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "8", "4", "bytes", "filemetainformationgrouplength", "12", "2", "bytes", "filemetainformationversion", "8", "4", "bytes", "mediastoragesopclassuid", "8", "4", "bytes", "mediastoragesopinstanceuid", "8", "4", "bytes", "transfersyntaxuid", "8", "xx", "bytes", "implementationclassuid", "8", "yy", "bytes", "implementationversionname", "78", "xx", "yy", "bytes", "total", "class_length", "len", "pydicom_implementation_uid", "if", "class_length", "2", "class_length", "1", "version_length", "len", "meta", "implementationversionname", "padded", "to", "even", "length", "if", "version_length", "2", "version_length", "1", "assert", "fp", "tell", "78", "class_length", "version_length", "fp", "dicombytesio", "8", "6", "bytes", "mediastoragesopinstanceuid", "meta", "mediastoragesopinstanceuid", "1", "4", "1", "write_file_meta_info", "fp", "meta", "enforce_standard", "true", "check", "file", "meta", "length", "assert", "fp", "tell", "80", "class_length", "version_length", "check", "group", "length", "68", "xx", "yy", "as", "bytes", "fp", "seek", "8", "test_length", "unpack", "i", "fp", "read", "4", "0", "assert", "test_length", "68", "class_length", "version_length"], "doc_len": 148}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def setup(self):\n        \"\"\"Create an empty file-like for use in testing.\"\"\"\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = True\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "setup", "self", "create", "an", "empty", "file", "like", "for", "use", "in", "testing", "self", "fp", "dicombytesio", "self", "fp", "is_little_endian", "true", "self", "fp", "is_implicit_vr", "true"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.compare_bytes", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "compare_bytes", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def compare_bytes(self, bytes_in, bytes_out):\n        \"\"\"Compare two bytestreams for equality\"\"\"\n        same, pos = bytes_identical(bytes_in, bytes_out)\n        assert same\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "compare_bytes", "self", "bytes_in", "bytes_out", "compare", "two", "bytestreams", "for", "equality", "same", "pos", "bytes_identical", "bytes_in", "bytes_out", "assert", "same"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.ensure_no_raw_data_elements", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "ensure_no_raw_data_elements", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def ensure_no_raw_data_elements(self, ds):\n        for _ in ds.file_meta:\n            pass\n        for _ in ds:\n            pass\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "ensure_no_raw_data_elements", "self", "ds", "for", "_", "in", "ds", "file_meta", "pass", "for", "_", "in", "ds", "pass"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_default", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_default", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_default(self):\n        \"\"\"Test that the default preamble is written correctly when present.\"\"\"\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x00' * 128\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 == self.fp.read(128)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_default", "self", "test", "that", "the", "default", "preamble", "is", "written", "correctly", "when", "present", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x00", "128", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_custom", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_custom", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_custom(self):\n        \"\"\"Test that a custom preamble is written correctly when present.\"\"\"\n        ds = dcmread(ct_name)\n        ds.preamble = b'\\x01\\x02\\x03\\x04' + b'\\x00' * 124\n        self.fp.seek(0)\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert b'\\x01\\x02\\x03\\x04' + b'\\x00' * 124 == self.fp.read(128)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_custom", "self", "test", "that", "a", "custom", "preamble", "is", "written", "correctly", "when", "present", "ds", "dcmread", "ct_name", "ds", "preamble", "b", "x01", "x02", "x03", "x04", "b", "x00", "124", "self", "fp", "seek", "0", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "b", "x01", "x02", "x03", "x04", "b", "x00", "124", "self", "fp", "read", "128"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_no_preamble", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_no_preamble", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_no_preamble(self):\n        \"\"\"Test no preamble or prefix is written if preamble absent.\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_no_preamble", "self", "test", "no", "preamble", "or", "prefix", "is", "written", "if", "preamble", "absent", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "preamble", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_ds_unchanged", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_ds_unchanged", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_ds_unchanged(self):\n        \"\"\"Test writing the dataset doesn't change it.\"\"\"\n        ds = dcmread(rtplan_name)\n        ref_ds = dcmread(rtplan_name)\n        ds.save_as(self.fp, write_like_original=True)\n\n        self.ensure_no_raw_data_elements(ds)\n        self.ensure_no_raw_data_elements(ref_ds)\n        assert ref_ds == ds\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_ds_unchanged", "self", "test", "writing", "the", "dataset", "doesn", "t", "change", "it", "ds", "dcmread", "rtplan_name", "ref_ds", "dcmread", "rtplan_name", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "ensure_no_raw_data_elements", "ds", "self", "ensure_no_raw_data_elements", "ref_ds", "assert", "ref_ds", "ds"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_file_meta_unchanged", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_file_meta_unchanged", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_file_meta_unchanged(self):\n        \"\"\"Test no file_meta elements are added if missing.\"\"\"\n        ds = dcmread(rtplan_name)\n        ds.file_meta = Dataset()\n        ds.save_as(self.fp, write_like_original=True)\n        assert Dataset() == ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_file_meta_unchanged", "self", "test", "no", "file_meta", "elements", "are", "added", "if", "missing", "ds", "dcmread", "rtplan_name", "ds", "file_meta", "dataset", "ds", "save_as", "self", "fp", "write_like_original", "true", "assert", "dataset", "ds", "file_meta"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_dataset(self):\n        \"\"\"Test dataset written OK with no preamble or file meta\"\"\"\n        ds = dcmread(ct_name)\n        del ds.preamble\n        del ds.file_meta\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert ds_out.preamble is None\n        assert Dataset() == ds_out.file_meta\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_dataset", "self", "test", "dataset", "written", "ok", "with", "no", "preamble", "or", "file", "meta", "ds", "dcmread", "ct_name", "del", "ds", "preamble", "del", "ds", "file_meta", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "ds_out", "preamble", "is", "none", "assert", "dataset", "ds_out", "file_meta", "assert", "patientid", "in", "ds_out"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_dataset(self):\n        \"\"\"Test dataset written OK with no file meta\"\"\"\n        ds = dcmread(ct_name)\n        del ds.file_meta\n        preamble = ds.preamble[:]\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_dataset", "self", "test", "dataset", "written", "ok", "with", "no", "file", "meta", "ds", "dcmread", "ct_name", "del", "ds", "file_meta", "preamble", "ds", "preamble", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "dataset", "ds_out", "file_meta", "assert", "patientid", "in", "ds_out"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_filemeta_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_filemeta_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_filemeta_dataset(self):\n        \"\"\"Test file meta written OK if preamble absent.\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert 'ImplementationClassUID' in ds_out.file_meta\n        assert ds_out.preamble is None\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_filemeta_dataset", "self", "test", "file", "meta", "written", "ok", "if", "preamble", "absent", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "preamble", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "implementationclassuid", "in", "ds_out", "file_meta", "assert", "ds_out", "preamble", "is", "none", "assert", "patientid", "in", "ds_out"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_filemeta_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_filemeta_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_filemeta_dataset(self):\n        \"\"\"Test non-standard file meta written with preamble OK\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        self.ensure_no_raw_data_elements(ds)\n        self.ensure_no_raw_data_elements(ds_out)\n\n        assert ds.file_meta[:] == ds_out.file_meta[:]\n        assert 'TransferSyntaxUID' in ds_out.file_meta[:]\n        assert preamble == ds_out.preamble\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_filemeta_dataset", "self", "test", "non", "standard", "file", "meta", "written", "with", "preamble", "ok", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "self", "ensure_no_raw_data_elements", "ds", "self", "ensure_no_raw_data_elements", "ds_out", "assert", "ds", "file_meta", "ds_out", "file_meta", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "preamble", "ds_out", "preamble", "assert", "patientid", "in", "ds_out"], "doc_len": 80}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_commandset_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_commandset_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_commandset_dataset(self):\n        \"\"\"Test written OK with command set/dataset\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        del ds.file_meta\n        ds.is_little_endian = True\n        ds.is_implicit_VR = True\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VRe\n        self.fp.seek(0)\n        assert (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00' ==\n                self.fp.read(12))\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_commandset_dataset", "self", "test", "written", "ok", "with", "command", "set", "dataset", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "preamble", "del", "ds", "file_meta", "ds", "is_little_endian", "true", "ds", "is_implicit_vr", "true", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vre", "self", "fp", "seek", "0", "assert", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x08", "x00", "x00", "x00", "self", "fp", "read", "12", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "dataset", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "in", "ds_out"], "doc_len": 138}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_commandset_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_commandset_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_commandset_dataset(self):\n        \"\"\"Test written OK with preamble/command set/dataset\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.file_meta\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VR\n        assert (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00' ==\n                self.fp.read(12))\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_commandset_dataset", "self", "test", "written", "ok", "with", "preamble", "command", "set", "dataset", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "file_meta", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vr", "assert", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x08", "x00", "x00", "x00", "self", "fp", "read", "12", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "dataset", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "in", "ds_out"], "doc_len": 110}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_commandset_filemeta_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_commandset_filemeta_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_commandset_filemeta_dataset(self):\n        \"\"\"Test written OK with preamble/command set/file meta/dataset\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_commandset_filemeta_dataset", "self", "test", "written", "ok", "with", "preamble", "command", "set", "file", "meta", "dataset", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "in", "ds_out"], "doc_len": 82}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_commandset_filemeta_dataset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_commandset_filemeta_dataset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_commandset_filemeta_dataset(self):\n        \"\"\"Test written OK with command set/file meta/dataset\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'\\x00' * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VR\n        self.fp.seek(0)\n\n        ds_out = dcmread(self.fp, force=True)\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' in ds_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_commandset_filemeta_dataset", "self", "test", "written", "ok", "with", "command", "set", "file", "meta", "dataset", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "preamble", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "x00", "128", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vr", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "in", "ds_out"], "doc_len": 110}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_commandset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_commandset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_commandset(self):\n        \"\"\"Test written OK with command set\"\"\"\n        ds = dcmread(ct_name)\n        del ds[:]\n        del ds.preamble\n        del ds.file_meta\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        with pytest.raises(EOFError):\n            self.fp.read(128, need_exact_length=True)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VR\n        self.fp.seek(0)\n\n        fp = BytesIO(self.fp.getvalue())  # Workaround to avoid #358\n        ds_out = dcmread(fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' not in ds_out\n        assert Dataset() == ds_out[0x00010000:]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_commandset", "self", "test", "written", "ok", "with", "command", "set", "ds", "dcmread", "ct_name", "del", "ds", "del", "ds", "preamble", "del", "ds", "file_meta", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "with", "pytest", "raises", "eoferror", "self", "fp", "read", "128", "need_exact_length", "true", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vr", "self", "fp", "seek", "0", "fp", "bytesio", "self", "fp", "getvalue", "workaround", "to", "avoid", "358", "ds_out", "dcmread", "fp", "force", "true", "assert", "dataset", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "not", "in", "ds_out", "assert", "dataset", "ds_out", "0x00010000"], "doc_len": 113}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_commandset_filemeta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_commandset_filemeta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_commandset_filemeta(self):\n        \"\"\"Test dataset written OK with command set/file meta\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds[:]\n        del ds.preamble\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b'DICM' != self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VR\n        self.fp.seek(0)\n\n        fp = BytesIO(self.fp.getvalue())  # Workaround to avoid #358\n        ds_out = dcmread(fp, force=True)\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' not in ds_out\n        assert Dataset() == ds_out[0x00010000:]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_commandset_filemeta", "self", "test", "dataset", "written", "ok", "with", "command", "set", "file", "meta", "ds", "dcmread", "ct_name", "preamble", "ds", "preamble", "del", "ds", "del", "ds", "preamble", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "preamble", "self", "fp", "read", "128", "self", "fp", "seek", "0", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vr", "self", "fp", "seek", "0", "fp", "bytesio", "self", "fp", "getvalue", "workaround", "to", "avoid", "358", "ds_out", "dcmread", "fp", "force", "true", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "not", "in", "ds_out", "assert", "dataset", "ds_out", "0x00010000"], "doc_len": 113}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_commandset", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_commandset", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_commandset(self):\n        \"\"\"Test written OK with preamble/command set\"\"\"\n        ds = dcmread(ct_name)\n        del ds[:]\n        del ds.file_meta\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert ds.preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n        # Ensure Command Set Elements written as little endian implicit VR\n        assert (b'\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00' ==\n                self.fp.read(12))\n\n        fp = BytesIO(self.fp.getvalue())  # Workaround to avoid #358\n        ds_out = dcmread(fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert 'Status' in ds_out\n        assert 'PatientID' not in ds_out\n        assert Dataset() == ds_out[0x00010000:]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_commandset", "self", "test", "written", "ok", "with", "preamble", "command", "set", "ds", "dcmread", "ct_name", "del", "ds", "del", "ds", "file_meta", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "ds", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "ensure", "command", "set", "elements", "written", "as", "little", "endian", "implicit", "vr", "assert", "b", "x00", "x00", "x00", "x00", "x04", "x00", "x00", "x00", "x08", "x00", "x00", "x00", "self", "fp", "read", "12", "fp", "bytesio", "self", "fp", "getvalue", "workaround", "to", "avoid", "358", "ds_out", "dcmread", "fp", "force", "true", "assert", "dataset", "ds_out", "file_meta", "assert", "status", "in", "ds_out", "assert", "patientid", "not", "in", "ds_out", "assert", "dataset", "ds_out", "0x00010000"], "doc_len": 118}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_preamble_commandset_filemeta", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_preamble_commandset_filemeta", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_preamble_commandset_filemeta(self):\n        \"\"\"Test written OK with preamble/command set/file meta\"\"\"\n        ds = dcmread(ct_name)\n        del ds[:]\n        ds.CommandGroupLength = 8\n        ds.MessageID = 1\n        ds.MoveDestination = 'SOME_SCP'\n        ds.Status = 0x0000\n        ds.save_as(self.fp, write_like_original=True)\n        self.fp.seek(0)\n        assert ds.preamble == self.fp.read(128)\n        assert b'DICM' == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert 'Status' in ds_out\n        assert 'TransferSyntaxUID' in ds_out.file_meta\n        assert 'PatientID' not in ds_out\n        assert Dataset() == ds_out[0x00010000:]\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_preamble_commandset_filemeta", "self", "test", "written", "ok", "with", "preamble", "command", "set", "file", "meta", "ds", "dcmread", "ct_name", "del", "ds", "ds", "commandgrouplength", "8", "ds", "messageid", "1", "ds", "movedestination", "some_scp", "ds", "status", "0x0000", "ds", "save_as", "self", "fp", "write_like_original", "true", "self", "fp", "seek", "0", "assert", "ds", "preamble", "self", "fp", "read", "128", "assert", "b", "dicm", "self", "fp", "read", "4", "self", "fp", "seek", "0", "ds_out", "dcmread", "self", "fp", "force", "true", "assert", "status", "in", "ds_out", "assert", "transfersyntaxuid", "in", "ds_out", "file_meta", "assert", "patientid", "not", "in", "ds_out", "assert", "dataset", "ds_out", "0x00010000"], "doc_len": 86}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNonStandard.test_read_write_identical", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNonStandard", "func_name": "test_read_write_identical", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNonStandard\n    def test_read_write_identical(self):\n        \"\"\"Test the written bytes matches the read bytes.\"\"\"\n        for dcm_in in [rtplan_name, rtdose_name, ct_name, mr_name, jpeg_name,\n                       no_ts, unicode_name, multiPN_name]:\n            with open(dcm_in, 'rb') as f:\n                bytes_in = BytesIO(f.read())\n                ds_in = dcmread(bytes_in)\n                bytes_out = BytesIO()\n                ds_in.save_as(bytes_out, write_like_original=True)\n                self.compare_bytes(bytes_in.getvalue(), bytes_out.getvalue())\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenonstandard", "def", "test_read_write_identical", "self", "test", "the", "written", "bytes", "matches", "the", "read", "bytes", "for", "dcm_in", "in", "rtplan_name", "rtdose_name", "ct_name", "mr_name", "jpeg_name", "no_ts", "unicode_name", "multipn_name", "with", "open", "dcm_in", "rb", "as", "f", "bytes_in", "bytesio", "f", "read", "ds_in", "dcmread", "bytes_in", "bytes_out", "bytesio", "ds_in", "save_as", "bytes_out", "write_like_original", "true", "self", "compare_bytes", "bytes_in", "getvalue", "bytes_out", "getvalue"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def setup(self):\n        \"\"\"Create an empty file-like for use in testing.\"\"\"\n        self.fp = DicomBytesIO()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "setup", "self", "create", "an", "empty", "file", "like", "for", "use", "in", "testing", "self", "fp", "dicombytesio"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_transfer_syntax_not_added", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_transfer_syntax_not_added", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_transfer_syntax_not_added(self):\n        \"\"\"Test that the TransferSyntaxUID isn't added if missing\"\"\"\n        ds = dcmread(no_ts)\n        write_file_meta_info(self.fp, ds.file_meta, enforce_standard=False)\n        assert 'TransferSyntaxUID' not in ds.file_meta\n        assert 'ImplementationClassUID' in ds.file_meta\n\n        # Check written meta dataset doesn't contain TransferSyntaxUID\n        written_ds = dcmread(self.fp, force=True)\n        assert 'ImplementationClassUID' in written_ds.file_meta\n        assert 'TransferSyntaxUID' not in written_ds.file_meta\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_transfer_syntax_not_added", "self", "test", "that", "the", "transfersyntaxuid", "isn", "t", "added", "if", "missing", "ds", "dcmread", "no_ts", "write_file_meta_info", "self", "fp", "ds", "file_meta", "enforce_standard", "false", "assert", "transfersyntaxuid", "not", "in", "ds", "file_meta", "assert", "implementationclassuid", "in", "ds", "file_meta", "check", "written", "meta", "dataset", "doesn", "t", "contain", "transfersyntaxuid", "written_ds", "dcmread", "self", "fp", "force", "true", "assert", "implementationclassuid", "in", "written_ds", "file_meta", "assert", "transfersyntaxuid", "not", "in", "written_ds", "file_meta"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_bad_elements", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_bad_elements", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_bad_elements(self):\n        \"\"\"Test that non-group 2 elements aren't written to the file meta.\"\"\"\n        meta = Dataset()\n        meta.PatientID = '12345678'\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        with pytest.raises(ValueError):\n            write_file_meta_info(self.fp, meta, enforce_standard=False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_bad_elements", "self", "test", "that", "non", "group", "2", "elements", "aren", "t", "written", "to", "the", "file", "meta", "meta", "dataset", "meta", "patientid", "12345678", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "with", "pytest", "raises", "valueerror", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_missing_elements", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_missing_elements", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_missing_elements(self):\n        \"\"\"Test that missing required elements doesn't raise ValueError.\"\"\"\n        meta = Dataset()\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.MediaStorageSOPClassUID = '1.1'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.TransferSyntaxUID = '1.3'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.ImplementationClassUID = '1.4'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_missing_elements", "self", "test", "that", "missing", "required", "elements", "doesn", "t", "raise", "valueerror", "meta", "dataset", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "meta", "mediastoragesopclassuid", "1", "1", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "meta", "mediastoragesopinstanceuid", "1", "2", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "meta", "transfersyntaxuid", "1", "3", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "meta", "implementationclassuid", "1", "4", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_group_length_updated", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_group_length_updated", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_group_length_updated(self):\n        \"\"\"Test that FileMetaInformationGroupLength gets updated if present.\"\"\"\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 100\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n\n        # 8 + 4 bytes FileMetaInformationGroupLength\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + 4 bytes ImplementationClassUID\n        # 60 bytes total, - 12 for group length = 48\n        self.fp.seek(8)\n        assert b'\\x30\\x00\\x00\\x00' == self.fp.read(4)\n        # Check original file meta is unchanged/updated\n        assert 48 == meta.FileMetaInformationGroupLength\n        assert 'FileMetaInformationVersion' not in meta\n        assert '1.1' == meta.MediaStorageSOPClassUID\n        assert '1.2' == meta.MediaStorageSOPInstanceUID\n        assert '1.3' == meta.TransferSyntaxUID\n        assert '1.4' == meta.ImplementationClassUID\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_group_length_updated", "self", "test", "that", "filemetainformationgrouplength", "gets", "updated", "if", "present", "meta", "dataset", "meta", "filemetainformationgrouplength", "100", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "8", "4", "bytes", "filemetainformationgrouplength", "8", "4", "bytes", "mediastoragesopclassuid", "8", "4", "bytes", "mediastoragesopinstanceuid", "8", "4", "bytes", "transfersyntaxuid", "8", "4", "bytes", "implementationclassuid", "60", "bytes", "total", "12", "for", "group", "length", "48", "self", "fp", "seek", "8", "assert", "b", "x30", "x00", "x00", "x00", "self", "fp", "read", "4", "check", "original", "file", "meta", "is", "unchanged", "updated", "assert", "48", "meta", "filemetainformationgrouplength", "assert", "filemetainformationversion", "not", "in", "meta", "assert", "1", "1", "meta", "mediastoragesopclassuid", "assert", "1", "2", "meta", "mediastoragesopinstanceuid", "assert", "1", "3", "meta", "transfersyntaxuid", "assert", "1", "4", "meta", "implementationclassuid"], "doc_len": 120}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_filelike_position", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_filelike_position", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_filelike_position(self):\n        \"\"\"Test that the file-like's ending position is OK.\"\"\"\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + 4 bytes ImplementationClassUID\n        # 48 bytes total\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert 48 == self.fp.tell()\n\n        # 8 + 6 bytes ImplementationClassUID\n        # 50 bytes total\n        self.fp.seek(0)\n        meta.ImplementationClassUID = '1.4.1'\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        # Check File Meta length\n        assert 50 == self.fp.tell()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_filelike_position", "self", "test", "that", "the", "file", "like", "s", "ending", "position", "is", "ok", "8", "4", "bytes", "mediastoragesopclassuid", "8", "4", "bytes", "mediastoragesopinstanceuid", "8", "4", "bytes", "transfersyntaxuid", "8", "4", "bytes", "implementationclassuid", "48", "bytes", "total", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "assert", "48", "self", "fp", "tell", "8", "6", "bytes", "implementationclassuid", "50", "bytes", "total", "self", "fp", "seek", "0", "meta", "implementationclassuid", "1", "4", "1", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "check", "file", "meta", "length", "assert", "50", "self", "fp", "tell"], "doc_len": 97}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteFileMetaInfoNonStandard.test_meta_unchanged", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteFileMetaInfoNonStandard", "func_name": "test_meta_unchanged", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteFileMetaInfoNonStandard\n    def test_meta_unchanged(self):\n        \"\"\"Test that the meta dataset doesn't change when writing it\"\"\"\n        # Empty\n        meta = Dataset()\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert Dataset() == meta\n\n        # Incomplete\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        ref_meta = deepcopy(meta)\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert ref_meta == meta\n\n        # Conformant\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 62  # Correct length\n        meta.FileMetaInformationVersion = b'\\x00\\x01'\n        meta.MediaStorageSOPClassUID = '1.1'\n        meta.MediaStorageSOPInstanceUID = '1.2'\n        meta.TransferSyntaxUID = '1.3'\n        meta.ImplementationClassUID = '1.4'\n        ref_meta = deepcopy(meta)\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert ref_meta == meta\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritefilemetainfononstandard", "def", "test_meta_unchanged", "self", "test", "that", "the", "meta", "dataset", "doesn", "t", "change", "when", "writing", "it", "empty", "meta", "dataset", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "assert", "dataset", "meta", "incomplete", "meta", "dataset", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "ref_meta", "deepcopy", "meta", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "assert", "ref_meta", "meta", "conformant", "meta", "dataset", "meta", "filemetainformationgrouplength", "62", "correct", "length", "meta", "filemetainformationversion", "b", "x00", "x01", "meta", "mediastoragesopclassuid", "1", "1", "meta", "mediastoragesopinstanceuid", "1", "2", "meta", "transfersyntaxuid", "1", "3", "meta", "implementationclassuid", "1", "4", "ref_meta", "deepcopy", "meta", "write_file_meta_info", "self", "fp", "meta", "enforce_standard", "false", "assert", "ref_meta", "meta"], "doc_len": 103}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNumbers.test_write_empty_value", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNumbers", "func_name": "test_write_empty_value", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNumbers\n    def test_write_empty_value(self):\n        \"\"\"Test writing an empty value does nothing\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, 'US', '')\n        fmt = 'H'\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b''\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenumbers", "def", "test_write_empty_value", "self", "test", "writing", "an", "empty", "value", "does", "nothing", "fp", "dicombytesio", "fp", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "us", "fmt", "h", "write_numbers", "fp", "elem", "fmt", "assert", "fp", "getvalue", "b"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNumbers.test_write_list", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNumbers", "func_name": "test_write_list", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNumbers\n    def test_write_list(self):\n        \"\"\"Test writing an element value with VM > 1\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, 'US', [1, 2, 3, 4])\n        fmt = 'H'\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b'\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenumbers", "def", "test_write_list", "self", "test", "writing", "an", "element", "value", "with", "vm", "1", "fp", "dicombytesio", "fp", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "us", "1", "2", "3", "4", "fmt", "h", "write_numbers", "fp", "elem", "fmt", "assert", "fp", "getvalue", "b", "x01", "x00", "x02", "x00", "x03", "x00", "x04", "x00"], "doc_len": 47}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNumbers.test_write_singleton", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNumbers", "func_name": "test_write_singleton", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNumbers\n    def test_write_singleton(self):\n        \"\"\"Test writing an element value with VM = 1\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, 'US', 1)\n        fmt = 'H'\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b'\\x01\\x00'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenumbers", "def", "test_write_singleton", "self", "test", "writing", "an", "element", "value", "with", "vm", "1", "fp", "dicombytesio", "fp", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "us", "1", "fmt", "h", "write_numbers", "fp", "elem", "fmt", "assert", "fp", "getvalue", "b", "x01", "x00"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNumbers.test_exception", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNumbers", "func_name": "test_exception", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNumbers\n    def test_exception(self):\n        \"\"\"Test exceptions raise IOError\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, 'US', b'\\x00')\n        fmt = 'H'\n        with pytest.raises(IOError,\n                           match=r\"for data_element:\\n\\(0010, 0010\\)\"):\n            write_numbers(fp, elem, fmt)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenumbers", "def", "test_exception", "self", "test", "exceptions", "raise", "ioerror", "fp", "dicombytesio", "fp", "is_little_endian", "true", "elem", "dataelement", "0x00100010", "us", "b", "x00", "fmt", "h", "with", "pytest", "raises", "ioerror", "match", "r", "for", "data_element", "n", "0010", "0010", "write_numbers", "fp", "elem", "fmt"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteNumbers.test_write_big_endian", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteNumbers", "func_name": "test_write_big_endian", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteNumbers\n    def test_write_big_endian(self):\n        \"\"\"Test writing big endian\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        elem = DataElement(0x00100010, 'US', 1)\n        fmt = 'H'\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b'\\x00\\x01'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritenumbers", "def", "test_write_big_endian", "self", "test", "writing", "big", "endian", "fp", "dicombytesio", "fp", "is_little_endian", "false", "elem", "dataelement", "0x00100010", "us", "1", "fmt", "h", "write_numbers", "fp", "elem", "fmt", "assert", "fp", "getvalue", "b", "x00", "x01"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWritePN.test_no_encoding", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWritePN", "func_name": "test_no_encoding", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWritePN\n    def test_no_encoding(self):\n        \"\"\"If PN element has no encoding info, default is used\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with encoded value\n        elem = DataElement(0x00100010, 'PN', 'Test')\n        write_PN(fp, elem)\n        assert b'Test' == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100010, 'PN', u'Test')\n        write_PN(fp, elem)\n        assert b'Test' == fp.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritepn", "def", "test_no_encoding", "self", "if", "pn", "element", "has", "no", "encoding", "info", "default", "is", "used", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "encoded", "value", "elem", "dataelement", "0x00100010", "pn", "test", "write_pn", "fp", "elem", "assert", "b", "test", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00100010", "pn", "u", "test", "write_pn", "fp", "elem", "assert", "b", "test", "fp", "getvalue"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWritePN.test_single_byte_multi_charset_groups", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWritePN", "func_name": "test_single_byte_multi_charset_groups", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWritePN\n    def test_single_byte_multi_charset_groups(self):\n        \"\"\"Test component groups with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = ['latin_1', 'iso_ir_126']\n        # data element with encoded value\n        encoded = (b'Dionysios=\\x1b\\x2d\\x46'\n                   b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        elem = DataElement(0x00100010, 'PN', encoded)\n        write_PN(fp, elem)\n        assert encoded == fp.getvalue()\n\n        # regression test: make sure no warning is issued, e.g. the\n        # PersonName3 value has not saved the default encoding\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        with pytest.warns(None) as warnings:\n            write_PN(fp, elem, encodings)\n        assert not warnings\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100010, 'PN', u'Dionysios=Διονυσιος')\n        write_PN(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritepn", "def", "test_single_byte_multi_charset_groups", "self", "test", "component", "groups", "with", "different", "encodings", "fp", "dicombytesio", "fp", "is_little_endian", "true", "encodings", "latin_1", "iso_ir_126", "data", "element", "with", "encoded", "value", "encoded", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "elem", "dataelement", "0x00100010", "pn", "encoded", "write_pn", "fp", "elem", "assert", "encoded", "fp", "getvalue", "regression", "test", "make", "sure", "no", "warning", "is", "issued", "e", "g", "the", "personname3", "value", "has", "not", "saved", "the", "default", "encoding", "fp", "dicombytesio", "fp", "is_little_endian", "true", "with", "pytest", "warns", "none", "as", "warnings", "write_pn", "fp", "elem", "encodings", "assert", "not", "warnings", "assert", "encoded", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00100010", "pn", "u", "dionysios", "write_pn", "fp", "elem", "encodings", "encodings", "assert", "encoded", "fp", "getvalue"], "doc_len": 121}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWritePN.test_single_byte_multi_charset_values", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWritePN", "func_name": "test_single_byte_multi_charset_values", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWritePN\n    def test_single_byte_multi_charset_values(self):\n        \"\"\"Test multiple values with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = ['latin_1', 'iso_ir_144', 'iso_ir_126']\n        # data element with encoded value\n        encoded = (b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                   b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                   b'\\x1b\\x2d\\x4C'\n                   b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3 ')\n        elem = DataElement(0x00100060, 'PN', encoded)\n        write_PN(fp, elem)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100060, 'PN', [u'Buc^Jérôme', u'Διονυσιος',\n                                              u'Люкceмбypг'])\n        write_PN(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritepn", "def", "test_single_byte_multi_charset_values", "self", "test", "multiple", "values", "with", "different", "encodings", "fp", "dicombytesio", "fp", "is_little_endian", "true", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "data", "element", "with", "encoded", "value", "encoded", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "elem", "dataelement", "0x00100060", "pn", "encoded", "write_pn", "fp", "elem", "assert", "encoded", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00100060", "pn", "u", "buc", "j", "r", "me", "u", "u", "ce", "yp", "write_pn", "fp", "elem", "encodings", "encodings", "assert", "encoded", "fp", "getvalue"], "doc_len": 106}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.teardown", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def teardown(self):\n        config.enforce_valid_values = False\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "teardown", "self", "config", "enforce_valid_values", "false"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_no_encoding", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_no_encoding", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_no_encoding(self):\n        \"\"\"If text element has no encoding info, default is used\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with encoded value\n        elem = DataElement(0x00081039, 'LO', 'Test')\n        write_text(fp, elem)\n        assert b'Test' == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Test')\n        write_text(fp, elem)\n        assert b'Test' == fp.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_no_encoding", "self", "if", "text", "element", "has", "no", "encoding", "info", "default", "is", "used", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "encoded", "value", "elem", "dataelement", "0x00081039", "lo", "test", "write_text", "fp", "elem", "assert", "b", "test", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "test", "write_text", "fp", "elem", "assert", "b", "test", "fp", "getvalue"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_single_byte_multi_charset_text", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_single_byte_multi_charset_text", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_single_byte_multi_charset_text(self):\n        \"\"\"Test changed encoding inside the string\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encoded = (b'Dionysios=\\x1b\\x2d\\x46'\n                   b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        # data element with encoded value\n        elem = DataElement(0x00081039, 'LO', encoded)\n        encodings = ['latin_1', 'iso_ir_126']\n        write_text(fp, elem)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Dionysios is Διονυσιος')\n        write_text(fp, elem, encodings=encodings)\n        # encoding may not be the same, so decode it first\n        encoded = fp.getvalue()\n        assert u'Dionysios is Διονυσιος' == convert_text(encoded, encodings)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_single_byte_multi_charset_text", "self", "test", "changed", "encoding", "inside", "the", "string", "fp", "dicombytesio", "fp", "is_little_endian", "true", "encoded", "b", "dionysios", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "data", "element", "with", "encoded", "value", "elem", "dataelement", "0x00081039", "lo", "encoded", "encodings", "latin_1", "iso_ir_126", "write_text", "fp", "elem", "assert", "encoded", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "dionysios", "is", "write_text", "fp", "elem", "encodings", "encodings", "encoding", "may", "not", "be", "the", "same", "so", "decode", "it", "first", "encoded", "fp", "getvalue", "assert", "u", "dionysios", "is", "convert_text", "encoded", "encodings"], "doc_len": 97}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_encode_mixed_charsets_text", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_encode_mixed_charsets_text", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_encode_mixed_charsets_text(self):\n        \"\"\"Test encodings used inside the string in arbitrary order\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = ['latin_1', 'euc_kr', 'iso-2022-jp', 'iso_ir_127']\n        decoded = u'山田-قباني-吉洞-لنزار'\n\n        # data element with encoded value\n        elem = DataElement(0x00081039, 'LO', decoded)\n        write_text(fp, elem, encodings=encodings)\n        encoded = fp.getvalue()\n        # make sure that the encoded string can be converted back\n        assert decoded == convert_text(encoded, encodings)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_encode_mixed_charsets_text", "self", "test", "encodings", "used", "inside", "the", "string", "in", "arbitrary", "order", "fp", "dicombytesio", "fp", "is_little_endian", "true", "encodings", "latin_1", "euc_kr", "iso", "2022", "jp", "iso_ir_127", "decoded", "u", "data", "element", "with", "encoded", "value", "elem", "dataelement", "0x00081039", "lo", "decoded", "write_text", "fp", "elem", "encodings", "encodings", "encoded", "fp", "getvalue", "make", "sure", "that", "the", "encoded", "string", "can", "be", "converted", "back", "assert", "decoded", "convert_text", "encoded", "encodings"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_single_byte_multi_charset_text_multivalue", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_single_byte_multi_charset_text_multivalue", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_single_byte_multi_charset_text_multivalue(self):\n        \"\"\"Test multiple values with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encoded = (b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                   b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                   b'\\x1b\\x2d\\x4C'\n                   b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3 ')\n        # data element with encoded value\n        elem = DataElement(0x00081039, 'LO', encoded)\n        encodings = ['latin_1', 'iso_ir_144', 'iso_ir_126']\n        write_text(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        decoded = [u'Buc^Jérôme', u'Διονυσιος', u'Люкceмбypг']\n        elem = DataElement(0x00081039, 'LO', decoded)\n        write_text(fp, elem, encodings=encodings)\n        # encoding may not be the same, so decode it first\n        encoded = fp.getvalue()\n        assert decoded == convert_text(encoded, encodings)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_single_byte_multi_charset_text_multivalue", "self", "test", "multiple", "values", "with", "different", "encodings", "fp", "dicombytesio", "fp", "is_little_endian", "true", "encoded", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "data", "element", "with", "encoded", "value", "elem", "dataelement", "0x00081039", "lo", "encoded", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "write_text", "fp", "elem", "encodings", "encodings", "assert", "encoded", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "decoded", "u", "buc", "j", "r", "me", "u", "u", "ce", "yp", "elem", "dataelement", "0x00081039", "lo", "decoded", "write_text", "fp", "elem", "encodings", "encodings", "encoding", "may", "not", "be", "the", "same", "so", "decode", "it", "first", "encoded", "fp", "getvalue", "assert", "decoded", "convert_text", "encoded", "encodings"], "doc_len": 124}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_invalid_encoding", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_invalid_encoding", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_invalid_encoding(self):\n        \"\"\"Test encoding text with invalid encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Dionysios Διονυσιος')\n        msg = 'Failed to encode value with encodings: iso-2022-jp'\n        if 'PyPy' in python_implementation():\n            # PyPy seems to have a different implementation of\n            # replacement mode with regard to escape sequences\n            expected = b'Dionysios \\x1b$B&$&I&O&M&T&R&I&O?\\x1b(B '\n        else:\n            expected = b'Dionysios \\x1b$B&$&I&O&M&T&R&I&O\\x1b(B? '\n        with pytest.warns(UserWarning, match=msg):\n            # encode with one invalid encoding\n            write_text(fp, elem, encodings=['iso-2022-jp'])\n            assert expected == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Dionysios Διονυσιος')\n        msg = 'Failed to encode value with encodings: iso-2022-jp, iso_ir_58'\n        with pytest.warns(UserWarning, match=msg):\n            # encode with two invalid encodings\n            write_text(fp, elem, encodings=['iso-2022-jp', 'iso_ir_58'])\n            assert expected == fp.getvalue()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_invalid_encoding", "self", "test", "encoding", "text", "with", "invalid", "encodings", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "dionysios", "msg", "failed", "to", "encode", "value", "with", "encodings", "iso", "2022", "jp", "if", "pypy", "in", "python_implementation", "pypy", "seems", "to", "have", "a", "different", "implementation", "of", "replacement", "mode", "with", "regard", "to", "escape", "sequences", "expected", "b", "dionysios", "x1b", "b", "i", "o", "m", "t", "r", "i", "o", "x1b", "b", "else", "expected", "b", "dionysios", "x1b", "b", "i", "o", "m", "t", "r", "i", "o", "x1b", "b", "with", "pytest", "warns", "userwarning", "match", "msg", "encode", "with", "one", "invalid", "encoding", "write_text", "fp", "elem", "encodings", "iso", "2022", "jp", "assert", "expected", "fp", "getvalue", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "dionysios", "msg", "failed", "to", "encode", "value", "with", "encodings", "iso", "2022", "jp", "iso_ir_58", "with", "pytest", "warns", "userwarning", "match", "msg", "encode", "with", "two", "invalid", "encodings", "write_text", "fp", "elem", "encodings", "iso", "2022", "jp", "iso_ir_58", "assert", "expected", "fp", "getvalue"], "doc_len": 160}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_invalid_encoding_enforce_standard", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_invalid_encoding_enforce_standard", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_invalid_encoding_enforce_standard(self):\n        \"\"\"Test encoding text with invalid encodings with\n        `config.enforce_valid_values` enabled\"\"\"\n        config.enforce_valid_values = True\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Dionysios Διονυσιος')\n        msg = (r\"'iso2022_jp' codec can't encode character u?'\\\\u03c2' in \"\n               r\"position 18: illegal multibyte sequence\")\n        with pytest.raises(UnicodeEncodeError, match=msg):\n            # encode with one invalid encoding\n            write_text(fp, elem, encodings=['iso-2022-jp'])\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, 'LO', u'Dionysios Διονυσιος')\n        with pytest.raises(UnicodeEncodeError, match=msg):\n            # encode with two invalid encodings\n            write_text(fp, elem, encodings=['iso-2022-jp', 'iso_ir_58'])\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_invalid_encoding_enforce_standard", "self", "test", "encoding", "text", "with", "invalid", "encodings", "with", "config", "enforce_valid_values", "enabled", "config", "enforce_valid_values", "true", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "dionysios", "msg", "r", "iso2022_jp", "codec", "can", "t", "encode", "character", "u", "u03c2", "in", "r", "position", "18", "illegal", "multibyte", "sequence", "with", "pytest", "raises", "unicodeencodeerror", "match", "msg", "encode", "with", "one", "invalid", "encoding", "write_text", "fp", "elem", "encodings", "iso", "2022", "jp", "fp", "dicombytesio", "fp", "is_little_endian", "true", "data", "element", "with", "decoded", "value", "elem", "dataelement", "0x00081039", "lo", "u", "dionysios", "with", "pytest", "raises", "unicodeencodeerror", "match", "msg", "encode", "with", "two", "invalid", "encodings", "write_text", "fp", "elem", "encodings", "iso", "2022", "jp", "iso_ir_58"], "doc_len": 107}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteText.test_single_value_with_delimiters", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteText", "func_name": "test_single_value_with_delimiters", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteText\n    def test_single_value_with_delimiters(self):\n        \"\"\"Test that text with delimiters encodes correctly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        decoded = u'Διονυσιος\\r\\nJérôme/Люкceмбypг\\tJérôme'\n        elem = DataElement(0x00081039, 'LO', decoded)\n        encodings = ('latin_1', 'iso_ir_144', 'iso_ir_126')\n        write_text(fp, elem, encodings=encodings)\n        encoded = fp.getvalue()\n        assert decoded == convert_text(encoded, encodings)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritetext", "def", "test_single_value_with_delimiters", "self", "test", "that", "text", "with", "delimiters", "encodes", "correctly", "fp", "dicombytesio", "fp", "is_little_endian", "true", "decoded", "u", "r", "nj", "r", "me", "ce", "yp", "tj", "r", "me", "elem", "dataelement", "0x00081039", "lo", "decoded", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "write_text", "fp", "elem", "encodings", "encodings", "encoded", "fp", "getvalue", "assert", "decoded", "convert_text", "encoded", "encodings"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteDT.test_format_dt", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteDT", "func_name": "test_format_dt", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteDT\n    def test_format_dt(self):\n        \"\"\"Test _format_DT\"\"\"\n        elem = DataElement(0x00181078, 'DT', DT('20010203123456.123456'))\n        assert hasattr(elem.value, 'original_string')\n        assert _format_DT(elem.value) == '20010203123456.123456'\n        del elem.value.original_string\n        assert not hasattr(elem.value, 'original_string')\n        assert elem.value.microsecond > 0\n        assert _format_DT(elem.value) == '20010203123456.123456'\n\n        elem = DataElement(0x00181078, 'DT', DT('20010203123456'))\n        del elem.value.original_string\n        assert _format_DT(elem.value) == '20010203123456'\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwritedt", "def", "test_format_dt", "self", "test", "_format_dt", "elem", "dataelement", "0x00181078", "dt", "dt", "20010203123456", "123456", "assert", "hasattr", "elem", "value", "original_string", "assert", "_format_dt", "elem", "value", "20010203123456", "123456", "del", "elem", "value", "original_string", "assert", "not", "hasattr", "elem", "value", "original_string", "assert", "elem", "value", "microsecond", "0", "assert", "_format_dt", "elem", "value", "20010203123456", "123456", "elem", "dataelement", "0x00181078", "dt", "dt", "20010203123456", "del", "elem", "value", "original_string", "assert", "_format_dt", "elem", "value", "20010203123456"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.setup", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "setup", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def setup(self):\n        self.fp = DicomBytesIO()\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "setup", "self", "self", "fp", "dicombytesio"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_little_endian_correct_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_little_endian_correct_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_little_endian_correct_data(self):\n        \"\"\"Pixel data starting with an item tag is written.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(0x7fe00010, 'OB',\n                                 b'\\xfe\\xff\\x00\\xe0'\n                                 b'\\x00\\x01\\x02\\x03',\n                                 is_undefined_length=True)\n        write_data_element(self.fp, pixel_data)\n\n        expected = (b'\\xe0\\x7f\\x10\\x00'  # tag\n                    b'OB\\x00\\x00'  # VR\n                    b'\\xff\\xff\\xff\\xff'  # length\n                    b'\\xfe\\xff\\x00\\xe0\\x00\\x01\\x02\\x03'  # contents\n                    b'\\xfe\\xff\\xdd\\xe0\\x00\\x00\\x00\\x00')  # SQ delimiter\n        self.fp.seek(0)\n        assert self.fp.read() == expected\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_little_endian_correct_data", "self", "pixel", "data", "starting", "with", "an", "item", "tag", "is", "written", "self", "fp", "is_little_endian", "true", "self", "fp", "is_implicit_vr", "false", "pixel_data", "dataelement", "0x7fe00010", "ob", "b", "xfe", "xff", "x00", "xe0", "b", "x00", "x01", "x02", "x03", "is_undefined_length", "true", "write_data_element", "self", "fp", "pixel_data", "expected", "b", "xe0", "x7f", "x10", "x00", "tag", "b", "ob", "x00", "x00", "vr", "b", "xff", "xff", "xff", "xff", "length", "b", "xfe", "xff", "x00", "xe0", "x00", "x01", "x02", "x03", "contents", "b", "xfe", "xff", "xdd", "xe0", "x00", "x00", "x00", "x00", "sq", "delimiter", "self", "fp", "seek", "0", "assert", "self", "fp", "read", "expected"], "doc_len": 93}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_big_endian_correct_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_big_endian_correct_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_big_endian_correct_data(self):\n        \"\"\"Pixel data starting with an item tag is written.\"\"\"\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(0x7fe00010, 'OB',\n                                 b'\\xff\\xfe\\xe0\\x00'\n                                 b'\\x00\\x01\\x02\\x03',\n                                 is_undefined_length=True)\n        write_data_element(self.fp, pixel_data)\n        expected = (b'\\x7f\\xe0\\x00\\x10'  # tag\n                    b'OB\\x00\\x00'  # VR\n                    b'\\xff\\xff\\xff\\xff'  # length\n                    b'\\xff\\xfe\\xe0\\x00\\x00\\x01\\x02\\x03'  # contents\n                    b'\\xff\\xfe\\xe0\\xdd\\x00\\x00\\x00\\x00')  # SQ delimiter\n        self.fp.seek(0)\n        assert self.fp.read() == expected\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_big_endian_correct_data", "self", "pixel", "data", "starting", "with", "an", "item", "tag", "is", "written", "self", "fp", "is_little_endian", "false", "self", "fp", "is_implicit_vr", "false", "pixel_data", "dataelement", "0x7fe00010", "ob", "b", "xff", "xfe", "xe0", "x00", "b", "x00", "x01", "x02", "x03", "is_undefined_length", "true", "write_data_element", "self", "fp", "pixel_data", "expected", "b", "x7f", "xe0", "x00", "x10", "tag", "b", "ob", "x00", "x00", "vr", "b", "xff", "xff", "xff", "xff", "length", "b", "xff", "xfe", "xe0", "x00", "x00", "x01", "x02", "x03", "contents", "b", "xff", "xfe", "xe0", "xdd", "x00", "x00", "x00", "x00", "sq", "delimiter", "self", "fp", "seek", "0", "assert", "self", "fp", "read", "expected"], "doc_len": 93}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_little_endian_incorrect_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_little_endian_incorrect_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_little_endian_incorrect_data(self):\n        \"\"\"Writing pixel data not starting with an item tag raises.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(0x7fe00010, 'OB',\n                                 b'\\xff\\xff\\x00\\xe0'\n                                 b'\\x00\\x01\\x02\\x03'\n                                 b'\\xfe\\xff\\xdd\\xe0',\n                                 is_undefined_length=True)\n        with pytest.raises(ValueError, match='Pixel Data .* must '\n                                             'start with an item tag'):\n            write_data_element(self.fp, pixel_data)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_little_endian_incorrect_data", "self", "writing", "pixel", "data", "not", "starting", "with", "an", "item", "tag", "raises", "self", "fp", "is_little_endian", "true", "self", "fp", "is_implicit_vr", "false", "pixel_data", "dataelement", "0x7fe00010", "ob", "b", "xff", "xff", "x00", "xe0", "b", "x00", "x01", "x02", "x03", "b", "xfe", "xff", "xdd", "xe0", "is_undefined_length", "true", "with", "pytest", "raises", "valueerror", "match", "pixel", "data", "must", "start", "with", "an", "item", "tag", "write_data_element", "self", "fp", "pixel_data"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_big_endian_incorrect_data", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_big_endian_incorrect_data", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_big_endian_incorrect_data(self):\n        \"\"\"Writing pixel data not starting with an item tag raises.\"\"\"\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(0x7fe00010, 'OB',\n                                 b'\\x00\\x00\\x00\\x00'\n                                 b'\\x00\\x01\\x02\\x03'\n                                 b'\\xff\\xfe\\xe0\\xdd',\n                                 is_undefined_length=True)\n        with pytest.raises(ValueError, match='Pixel Data .+ must '\n                                             'start with an item tag'):\n            write_data_element(self.fp, pixel_data)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_big_endian_incorrect_data", "self", "writing", "pixel", "data", "not", "starting", "with", "an", "item", "tag", "raises", "self", "fp", "is_little_endian", "false", "self", "fp", "is_implicit_vr", "false", "pixel_data", "dataelement", "0x7fe00010", "ob", "b", "x00", "x00", "x00", "x00", "b", "x00", "x01", "x02", "x03", "b", "xff", "xfe", "xe0", "xdd", "is_undefined_length", "true", "with", "pytest", "raises", "valueerror", "match", "pixel", "data", "must", "start", "with", "an", "item", "tag", "write_data_element", "self", "fp", "pixel_data"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_writing_to_gzip", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_writing_to_gzip", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_writing_to_gzip(self):\n        file_path = tempfile.NamedTemporaryFile(suffix='.dcm').name\n        ds = dcmread(rtplan_name)\n        import gzip\n        with gzip.open(file_path, 'w') as fp:\n            ds.save_as(fp, write_like_original=False)\n        with gzip.open(file_path, 'r') as fp:\n            ds_unzipped = dcmread(fp)\n            for elem_in, elem_out in zip(ds, ds_unzipped):\n                assert elem_in == elem_out\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_writing_to_gzip", "self", "file_path", "tempfile", "namedtemporaryfile", "suffix", "dcm", "name", "ds", "dcmread", "rtplan_name", "import", "gzip", "with", "gzip", "open", "file_path", "w", "as", "fp", "ds", "save_as", "fp", "write_like_original", "false", "with", "gzip", "open", "file_path", "r", "as", "fp", "ds_unzipped", "dcmread", "fp", "for", "elem_in", "elem_out", "in", "zip", "ds", "ds_unzipped", "assert", "elem_in", "elem_out"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_filewriter.py::TestWriteUndefinedLengthPixelData.test_writing_too_big_data_in_explicit_encoding", "file_path": "pydicom/tests/test_filewriter.py", "class_name": "TestWriteUndefinedLengthPixelData", "func_name": "test_writing_too_big_data_in_explicit_encoding", "text": "文件路径: pydicom/tests/test_filewriter.py, 类名: TestWriteUndefinedLengthPixelData\n    def test_writing_too_big_data_in_explicit_encoding(self):\n        \"\"\"Data too large to be written in explicit transfer syntax.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = True\n        # make a multi-value larger than 64kB\n        single_value = b'123456.789012345'\n        large_value = b'\\\\'.join([single_value] * 4500)\n        # can be written with implicit transfer syntax,\n        # where the length field is 4 bytes long\n        pixel_data = DataElement(0x30040058, 'DS',\n                                 large_value,\n                                 is_undefined_length=False)\n        write_data_element(self.fp, pixel_data)\n\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n        # shall raise if trying to write it with explicit transfer syntax,\n        # where the length field is 2 bytes long\n        expected_message = (r'The value for the data element \\(3004, 0058\\) '\n                            r'exceeds the size of 64 kByte ')\n        with pytest.raises(ValueError, match=expected_message):\n            write_data_element(self.fp, pixel_data)\n\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        # we expect the same behavior in Big Endian transfer syntax\n        with pytest.raises(ValueError, match=expected_message):\n            write_data_element(self.fp, pixel_data)\n", "tokens": ["pydicom", "tests", "test_filewriter", "py", "testwriteundefinedlengthpixeldata", "def", "test_writing_too_big_data_in_explicit_encoding", "self", "data", "too", "large", "to", "be", "written", "in", "explicit", "transfer", "syntax", "self", "fp", "is_little_endian", "true", "self", "fp", "is_implicit_vr", "true", "make", "a", "multi", "value", "larger", "than", "64kb", "single_value", "b", "123456", "789012345", "large_value", "b", "join", "single_value", "4500", "can", "be", "written", "with", "implicit", "transfer", "syntax", "where", "the", "length", "field", "is", "4", "bytes", "long", "pixel_data", "dataelement", "0x30040058", "ds", "large_value", "is_undefined_length", "false", "write_data_element", "self", "fp", "pixel_data", "self", "fp", "dicombytesio", "self", "fp", "is_little_endian", "true", "self", "fp", "is_implicit_vr", "false", "shall", "raise", "if", "trying", "to", "write", "it", "with", "explicit", "transfer", "syntax", "where", "the", "length", "field", "is", "2", "bytes", "long", "expected_message", "r", "the", "value", "for", "the", "data", "element", "3004", "0058", "r", "exceeds", "the", "size", "of", "64", "kbyte", "with", "pytest", "raises", "valueerror", "match", "expected_message", "write_data_element", "self", "fp", "pixel_data", "self", "fp", "dicombytesio", "self", "fp", "is_little_endian", "false", "self", "fp", "is_implicit_vr", "false", "we", "expect", "the", "same", "behavior", "in", "big", "endian", "transfer", "syntax", "with", "pytest", "raises", "valueerror", "match", "expected_message", "write_data_element", "self", "fp", "pixel_data"], "doc_len": 156}
{"doc_id": "pydicom/tests/test_fixes.py::first_sunday_on_or_after", "file_path": "pydicom/tests/test_fixes.py", "class_name": null, "func_name": "first_sunday_on_or_after", "text": "文件路径: pydicom/tests/test_fixes.py\ndef first_sunday_on_or_after(dt):\n    days_to_go = 6 - dt.weekday()\n    if days_to_go:\n        dt += timedelta(days_to_go)\n    return dt\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "def", "first_sunday_on_or_after", "dt", "days_to_go", "6", "dt", "weekday", "if", "days_to_go", "dt", "timedelta", "days_to_go", "return", "dt"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_fixes.py::USTimeZone.__init__", "file_path": "pydicom/tests/test_fixes.py", "class_name": "USTimeZone", "func_name": "__init__", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: USTimeZone\n    def __init__(self, hours, reprname, stdname, dstname):\n        self.stdoffset = timedelta(hours=hours)\n        self.reprname = reprname\n        self.stdname = stdname\n        self.dstname = dstname\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "ustimezone", "def", "__init__", "self", "hours", "reprname", "stdname", "dstname", "self", "stdoffset", "timedelta", "hours", "hours", "self", "reprname", "reprname", "self", "stdname", "stdname", "self", "dstname", "dstname"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_fixes.py::USTimeZone.__repr__", "file_path": "pydicom/tests/test_fixes.py", "class_name": "USTimeZone", "func_name": "__repr__", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: USTimeZone\n    def __repr__(self):\n        return self.reprname\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "ustimezone", "def", "__repr__", "self", "return", "self", "reprname"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_fixes.py::USTimeZone.tzname", "file_path": "pydicom/tests/test_fixes.py", "class_name": "USTimeZone", "func_name": "tzname", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: USTimeZone\n    def tzname(self, dt):\n        if self.dst(dt):\n            return self.dstname\n        else:\n            return self.stdname\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "ustimezone", "def", "tzname", "self", "dt", "if", "self", "dst", "dt", "return", "self", "dstname", "else", "return", "self", "stdname"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_fixes.py::USTimeZone.utcoffset", "file_path": "pydicom/tests/test_fixes.py", "class_name": "USTimeZone", "func_name": "utcoffset", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: USTimeZone\n    def utcoffset(self, dt):\n        return self.stdoffset + self.dst(dt)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "ustimezone", "def", "utcoffset", "self", "dt", "return", "self", "stdoffset", "self", "dst", "dt"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_fixes.py::USTimeZone.dst", "file_path": "pydicom/tests/test_fixes.py", "class_name": "USTimeZone", "func_name": "dst", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: USTimeZone\n    def dst(self, dt):\n        if dt is None or dt.tzinfo is None:\n            # An exception instead may be sensible here, in one or more of\n            # the cases.\n            return ZERO\n        assert dt.tzinfo is self\n\n        # Find first Sunday in April.\n        start = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))\n        assert start.weekday() == 6 and start.month == 4 and start.day <= 7\n\n        # Find last Sunday in October.\n        end = first_sunday_on_or_after(DSTEND.replace(year=dt.year))\n        assert end.weekday() == 6 and end.month == 10 and end.day >= 25\n\n        # Can't compare naive to aware objects, so strip the timezone from\n        # dt first.\n        if start <= dt.replace(tzinfo=None) < end:\n            return HOUR\n        else:\n            return ZERO\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "ustimezone", "def", "dst", "self", "dt", "if", "dt", "is", "none", "or", "dt", "tzinfo", "is", "none", "an", "exception", "instead", "may", "be", "sensible", "here", "in", "one", "or", "more", "of", "the", "cases", "return", "zero", "assert", "dt", "tzinfo", "is", "self", "find", "first", "sunday", "in", "april", "start", "first_sunday_on_or_after", "dststart", "replace", "year", "dt", "year", "assert", "start", "weekday", "6", "and", "start", "month", "4", "and", "start", "day", "7", "find", "last", "sunday", "in", "october", "end", "first_sunday_on_or_after", "dstend", "replace", "year", "dt", "year", "assert", "end", "weekday", "6", "and", "end", "month", "10", "and", "end", "day", "25", "can", "t", "compare", "naive", "to", "aware", "objects", "so", "strip", "the", "timezone", "from", "dt", "first", "if", "start", "dt", "replace", "tzinfo", "none", "end", "return", "hour", "else", "return", "zero"], "doc_len": 113}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.setup", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "setup", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def setup(self):\n        self.ACDT = timezone(timedelta(hours=9.5), 'ACDT')\n        self.EST = timezone(-timedelta(hours=5), 'EST')\n        self.DT = datetime(2010, 1, 1)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "setup", "self", "self", "acdt", "timezone", "timedelta", "hours", "9", "5", "acdt", "self", "est", "timezone", "timedelta", "hours", "5", "est", "self", "dt", "datetime", "2010", "1", "1"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_str", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_str", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_str(self):\n        for tz in [self.ACDT, self.EST, timezone.utc,\n                   timezone.min, timezone.max]:\n            assert tz.tzname(None) == str(tz)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_str", "self", "for", "tz", "in", "self", "acdt", "self", "est", "timezone", "utc", "timezone", "min", "timezone", "max", "assert", "tz", "tzname", "none", "str", "tz"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_repr", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_repr", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_repr(self):\n        datetime = datetime_module\n        pydicom = pydicom_module\n        for tz in [self.ACDT, self.EST, timezone.utc,\n                   timezone.min, timezone.max]:\n            # test round-trip\n            tzrep = repr(tz)\n            assert tz == eval(tzrep)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_repr", "self", "datetime", "datetime_module", "pydicom", "pydicom_module", "for", "tz", "in", "self", "acdt", "self", "est", "timezone", "utc", "timezone", "min", "timezone", "max", "test", "round", "trip", "tzrep", "repr", "tz", "assert", "tz", "eval", "tzrep"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_class_members", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_class_members", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_class_members(self):\n        limit = timedelta(hours=23, minutes=59)\n        assert ZERO == timezone.utc.utcoffset(None)\n        assert -limit == timezone.min.utcoffset(None)\n        assert limit == timezone.max.utcoffset(None)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_class_members", "self", "limit", "timedelta", "hours", "23", "minutes", "59", "assert", "zero", "timezone", "utc", "utcoffset", "none", "assert", "limit", "timezone", "min", "utcoffset", "none", "assert", "limit", "timezone", "max", "utcoffset", "none"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_constructor", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_constructor", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_constructor(self):\n        assert timezone.utc is timezone(timedelta(0))\n        assert timezone.utc is not timezone(timedelta(0), 'UTC')\n        assert timezone(timedelta(0), 'UTC') == timezone.utc\n        # invalid offsets\n        for invalid in [timedelta(microseconds=1), timedelta(1, 1),\n                        timedelta(seconds=1), timedelta(1), -timedelta(1)]:\n            with pytest.raises(ValueError):\n                timezone(invalid)\n            with pytest.raises(ValueError):\n                timezone(-invalid)\n\n        with pytest.raises(TypeError):\n            timezone(None)\n        with pytest.raises(TypeError):\n            timezone(42)\n        with pytest.raises(TypeError):\n            timezone(ZERO, None)\n        with pytest.raises(TypeError):\n            timezone(ZERO, 42)\n        with pytest.raises(TypeError):\n            timezone(ZERO, 'ABC', 'extra')\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_constructor", "self", "assert", "timezone", "utc", "is", "timezone", "timedelta", "0", "assert", "timezone", "utc", "is", "not", "timezone", "timedelta", "0", "utc", "assert", "timezone", "timedelta", "0", "utc", "timezone", "utc", "invalid", "offsets", "for", "invalid", "in", "timedelta", "microseconds", "1", "timedelta", "1", "1", "timedelta", "seconds", "1", "timedelta", "1", "timedelta", "1", "with", "pytest", "raises", "valueerror", "timezone", "invalid", "with", "pytest", "raises", "valueerror", "timezone", "invalid", "with", "pytest", "raises", "typeerror", "timezone", "none", "with", "pytest", "raises", "typeerror", "timezone", "42", "with", "pytest", "raises", "typeerror", "timezone", "zero", "none", "with", "pytest", "raises", "typeerror", "timezone", "zero", "42", "with", "pytest", "raises", "typeerror", "timezone", "zero", "abc", "extra"], "doc_len": 95}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_inheritance", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_inheritance", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_inheritance(self):\n        assert isinstance(timezone.utc, tzinfo)\n        assert isinstance(self.EST, tzinfo)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_inheritance", "self", "assert", "isinstance", "timezone", "utc", "tzinfo", "assert", "isinstance", "self", "est", "tzinfo"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_utcoffset", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_utcoffset", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_utcoffset(self):\n        dummy = self.DT\n        for h in [0, 1.5, 12]:\n            offset = h * HOUR.total_seconds()\n            offset = timedelta(seconds=offset)\n            assert offset == timezone(offset).utcoffset(dummy)\n            assert -offset == timezone(-offset).utcoffset(dummy)\n\n        with pytest.raises(TypeError):\n            self.EST.utcoffset('')\n        with pytest.raises(TypeError):\n            self.EST.utcoffset(5)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_utcoffset", "self", "dummy", "self", "dt", "for", "h", "in", "0", "1", "5", "12", "offset", "h", "hour", "total_seconds", "offset", "timedelta", "seconds", "offset", "assert", "offset", "timezone", "offset", "utcoffset", "dummy", "assert", "offset", "timezone", "offset", "utcoffset", "dummy", "with", "pytest", "raises", "typeerror", "self", "est", "utcoffset", "with", "pytest", "raises", "typeerror", "self", "est", "utcoffset", "5"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_dst", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_dst", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_dst(self):\n        assert timezone.utc.dst(self.DT) is None\n\n        with pytest.raises(TypeError):\n            self.EST.dst('')\n        with pytest.raises(TypeError):\n            self.EST.dst(5)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_dst", "self", "assert", "timezone", "utc", "dst", "self", "dt", "is", "none", "with", "pytest", "raises", "typeerror", "self", "est", "dst", "with", "pytest", "raises", "typeerror", "self", "est", "dst", "5"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_tzname", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_tzname", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_tzname(self):\n        assert 'UTC' in timezone.utc.tzname(None)\n        assert 'UTC' in timezone(ZERO).tzname(None)\n        assert 'UTC-05:00' == timezone(timedelta(hours=-5)).tzname(None)\n        assert 'UTC+09:30' == timezone(timedelta(hours=9.5)).tzname(None)\n        assert 'UTC-00:01' == timezone(timedelta(minutes=-1)).tzname(None)\n        assert 'XYZ' == timezone(-5 * HOUR, 'XYZ').tzname(None)\n\n        with pytest.raises(TypeError):\n            self.EST.tzname('')\n        with pytest.raises(TypeError):\n            self.EST.tzname(5)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_tzname", "self", "assert", "utc", "in", "timezone", "utc", "tzname", "none", "assert", "utc", "in", "timezone", "zero", "tzname", "none", "assert", "utc", "05", "00", "timezone", "timedelta", "hours", "5", "tzname", "none", "assert", "utc", "09", "30", "timezone", "timedelta", "hours", "9", "5", "tzname", "none", "assert", "utc", "00", "01", "timezone", "timedelta", "minutes", "1", "tzname", "none", "assert", "xyz", "timezone", "5", "hour", "xyz", "tzname", "none", "with", "pytest", "raises", "typeerror", "self", "est", "tzname", "with", "pytest", "raises", "typeerror", "self", "est", "tzname", "5"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_fromutc", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_fromutc", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_fromutc(self):\n        with pytest.raises(ValueError):\n            timezone.utc.fromutc(self.DT)\n        with pytest.raises(TypeError):\n            timezone.utc.fromutc('not datetime')\n        for tz in [self.EST, self.ACDT, Eastern]:\n            utctime = self.DT.replace(tzinfo=tz)\n            local = tz.fromutc(utctime)\n            assert local - utctime == tz.utcoffset(local)\n            assert local == self.DT.replace(tzinfo=timezone.utc)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_fromutc", "self", "with", "pytest", "raises", "valueerror", "timezone", "utc", "fromutc", "self", "dt", "with", "pytest", "raises", "typeerror", "timezone", "utc", "fromutc", "not", "datetime", "for", "tz", "in", "self", "est", "self", "acdt", "eastern", "utctime", "self", "dt", "replace", "tzinfo", "tz", "local", "tz", "fromutc", "utctime", "assert", "local", "utctime", "tz", "utcoffset", "local", "assert", "local", "self", "dt", "replace", "tzinfo", "timezone", "utc"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_comparison", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_comparison", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_comparison(self):\n        assert timezone(ZERO) != timezone(HOUR)\n        assert timezone(HOUR) == timezone(HOUR)\n        assert timezone(-5 * HOUR) == timezone(-5 * HOUR, 'EST')\n        with pytest.raises(TypeError):\n            timezone(ZERO) < timezone(ZERO)\n        assert timezone(ZERO) in {timezone(ZERO)}\n        assert timezone(ZERO) is not None\n        assert not timezone(ZERO) is None\n        assert 'random' != timezone(ZERO)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_comparison", "self", "assert", "timezone", "zero", "timezone", "hour", "assert", "timezone", "hour", "timezone", "hour", "assert", "timezone", "5", "hour", "timezone", "5", "hour", "est", "with", "pytest", "raises", "typeerror", "timezone", "zero", "timezone", "zero", "assert", "timezone", "zero", "in", "timezone", "zero", "assert", "timezone", "zero", "is", "not", "none", "assert", "not", "timezone", "zero", "is", "none", "assert", "random", "timezone", "zero"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_aware_datetime", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_aware_datetime", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_aware_datetime(self):\n        # test that timezone instances can be used by datetime\n        t = datetime(1, 1, 1)\n        for tz in [timezone.min, timezone.max, timezone.utc]:\n            print(tz.tzname(t))\n            assert t.replace(tzinfo=tz).tzname() == tz.tzname(t)\n            assert t.replace(tzinfo=tz).utcoffset() == tz.utcoffset(t)\n            assert t.replace(tzinfo=tz).dst() == tz.dst(t)\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_aware_datetime", "self", "test", "that", "timezone", "instances", "can", "be", "used", "by", "datetime", "t", "datetime", "1", "1", "1", "for", "tz", "in", "timezone", "min", "timezone", "max", "timezone", "utc", "print", "tz", "tzname", "t", "assert", "t", "replace", "tzinfo", "tz", "tzname", "tz", "tzname", "t", "assert", "t", "replace", "tzinfo", "tz", "utcoffset", "tz", "utcoffset", "t", "assert", "t", "replace", "tzinfo", "tz", "dst", "tz", "dst", "t"], "doc_len": 62}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_pickle", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_pickle", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_pickle(self):\n        for tz in self.ACDT, self.EST, timezone.min, timezone.max:\n            for pickler, unpickler, proto in pickle_choices:\n                tz_copy = unpickler.loads(pickler.dumps(tz, proto))\n                assert tz == tz_copy\n        tz = timezone.utc\n        for pickler, unpickler, proto in pickle_choices:\n            tz_copy = unpickler.loads(pickler.dumps(tz, proto))\n            assert tz_copy is tz\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_pickle", "self", "for", "tz", "in", "self", "acdt", "self", "est", "timezone", "min", "timezone", "max", "for", "pickler", "unpickler", "proto", "in", "pickle_choices", "tz_copy", "unpickler", "loads", "pickler", "dumps", "tz", "proto", "assert", "tz", "tz_copy", "tz", "timezone", "utc", "for", "pickler", "unpickler", "proto", "in", "pickle_choices", "tz_copy", "unpickler", "loads", "pickler", "dumps", "tz", "proto", "assert", "tz_copy", "is", "tz"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_copy", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_copy", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_copy(self):\n        for tz in self.ACDT, self.EST, timezone.min, timezone.max:\n            tz_copy = copy.copy(tz)\n            assert tz == tz_copy\n        tz = timezone.utc\n        tz_copy = copy.copy(tz)\n        assert tz_copy is tz\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_copy", "self", "for", "tz", "in", "self", "acdt", "self", "est", "timezone", "min", "timezone", "max", "tz_copy", "copy", "copy", "tz", "assert", "tz", "tz_copy", "tz", "timezone", "utc", "tz_copy", "copy", "copy", "tz", "assert", "tz_copy", "is", "tz"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_fixes.py::TestTimeZone.test_deepcopy", "file_path": "pydicom/tests/test_fixes.py", "class_name": "TestTimeZone", "func_name": "test_deepcopy", "text": "文件路径: pydicom/tests/test_fixes.py, 类名: TestTimeZone\n    def test_deepcopy(self):\n        for tz in self.ACDT, self.EST, timezone.min, timezone.max:\n            tz_copy = copy.deepcopy(tz)\n            assert tz == tz_copy\n        tz = timezone.utc\n        tz_copy = copy.deepcopy(tz)\n        assert tz_copy is tz\n", "tokens": ["pydicom", "tests", "test_fixes", "py", "testtimezone", "def", "test_deepcopy", "self", "for", "tz", "in", "self", "acdt", "self", "est", "timezone", "min", "timezone", "max", "tz_copy", "copy", "deepcopy", "tz", "assert", "tz", "tz_copy", "tz", "timezone", "utc", "tz_copy", "copy", "deepcopy", "tz", "assert", "tz_copy", "is", "tz"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG_LS_no_gdcm.setup", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG_LS_no_gdcm", "func_name": "setup", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG_LS_no_gdcm\n    def setup(self):\n        if compat.in_py2:\n            self.utf8_filename = os.path.join(\n                tempfile.gettempdir(), \"ДИКОМ.dcm\")\n            self.unicode_filename = self.utf8_filename.decode(\"utf8\")\n            shutil.copyfile(jpeg_ls_lossless_name.decode(\"utf8\"),\n                            self.unicode_filename)\n        else:\n            self.unicode_filename = os.path.join(\n                tempfile.gettempdir(), \"ДИКОМ.dcm\")\n            shutil.copyfile(jpeg_ls_lossless_name, self.unicode_filename)\n        self.jpeg_ls_lossless = dcmread(self.unicode_filename)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg_ls_no_gdcm", "def", "setup", "self", "if", "compat", "in_py2", "self", "utf8_filename", "os", "path", "join", "tempfile", "gettempdir", "dcm", "self", "unicode_filename", "self", "utf8_filename", "decode", "utf8", "shutil", "copyfile", "jpeg_ls_lossless_name", "decode", "utf8", "self", "unicode_filename", "else", "self", "unicode_filename", "os", "path", "join", "tempfile", "gettempdir", "dcm", "shutil", "copyfile", "jpeg_ls_lossless_name", "self", "unicode_filename", "self", "jpeg_ls_lossless", "dcmread", "self", "unicode_filename", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG_LS_no_gdcm.teardown", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG_LS_no_gdcm", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG_LS_no_gdcm\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n        os.remove(self.unicode_filename)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg_ls_no_gdcm", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers", "os", "remove", "self", "unicode_filename"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG_LS_no_gdcm.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG_LS_no_gdcm", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG_LS_no_gdcm\n    def test_JPEG_LS_PixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg_ls_no_gdcm", "def", "test_jpeg_ls_pixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG_LS_no_gdcm.test_emri_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG_LS_no_gdcm", "func_name": "test_emri_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG_LS_no_gdcm\n    def test_emri_JPEG_LS_PixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg_ls_no_gdcm", "def", "test_emri_jpeg_ls_pixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.setup", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "setup", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def setup(self):\n        self.jpeg_2k = dcmread(jpeg2000_name)\n        self.jpeg_2k_lossless = dcmread(jpeg2000_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_2k_lossless = dcmread(emri_jpeg_2k_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.sc_rgb_jpeg2k_gdcm_KY = dcmread(sc_rgb_jpeg2k_gdcm_KY)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "setup", "self", "self", "jpeg_2k", "dcmread", "jpeg2000_name", "self", "jpeg_2k_lossless", "dcmread", "jpeg2000_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_2k_lossless", "dcmread", "emri_jpeg_2k_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "sc_rgb_jpeg2k_gdcm_ky", "dcmread", "sc_rgb_jpeg2k_gdcm_ky", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.teardown", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.test_JPEG2000", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "test_JPEG2000", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def test_JPEG2000(self):\n        \"\"\"JPEG2000: Returns correct values for sample data elements\"\"\"\n        # XX also tests multiple-valued AT data element\n        expected = [Tag(0x0054, 0x0010), Tag(0x0054, 0x0020)]\n        got = self.jpeg_2k.FrameIncrementPointer\n        assert expected == got\n\n        got = self.jpeg_2k.DerivationCodeSequence[0].CodeMeaning\n        expected = 'Lossy Compression'\n        assert expected == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "test_jpeg2000", "self", "jpeg2000", "returns", "correct", "values", "for", "sample", "data", "elements", "xx", "also", "tests", "multiple", "valued", "at", "data", "element", "expected", "tag", "0x0054", "0x0010", "tag", "0x0054", "0x0020", "got", "self", "jpeg_2k", "frameincrementpointer", "assert", "expected", "got", "got", "self", "jpeg_2k", "derivationcodesequence", "0", "codemeaning", "expected", "lossy", "compression", "assert", "expected", "got"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.test_JPEG2000_pixel_array", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "test_JPEG2000_pixel_array", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def test_JPEG2000_pixel_array(self):\n        with pytest.raises(NotImplementedError):\n            self.jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "test_jpeg2000_pixel_array", "self", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_2k_lossless", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.test_emri_JPEG2000_pixel_array", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "test_emri_JPEG2000_pixel_array", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def test_emri_JPEG2000_pixel_array(self):\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "test_emri_jpeg2000_pixel_array", "self", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_2k_lossless", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEG2000_no_gdcm.test_jpeg2000_lossy", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEG2000_no_gdcm", "func_name": "test_jpeg2000_lossy", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEG2000_no_gdcm\n    def test_jpeg2000_lossy(self):\n        with pytest.raises(NotImplementedError):\n            self.sc_rgb_jpeg2k_gdcm_KY.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeg2000_no_gdcm", "def", "test_jpeg2000_lossy", "self", "with", "pytest", "raises", "notimplementederror", "self", "sc_rgb_jpeg2k_gdcm_ky", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossy_no_gdcm.setup", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossy_no_gdcm", "func_name": "setup", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossy_no_gdcm\n    def setup(self):\n        self.jpeg_lossy = dcmread(jpeg_lossy_name)\n        self.color_3d_jpeg = dcmread(color_3d_jpeg_baseline)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossy_no_gdcm", "def", "setup", "self", "self", "jpeg_lossy", "dcmread", "jpeg_lossy_name", "self", "color_3d_jpeg", "dcmread", "color_3d_jpeg_baseline", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossy_no_gdcm.teardown", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossy_no_gdcm", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossy_no_gdcm\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossy_no_gdcm", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossy_no_gdcm.test_JPEGlossy", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossy_no_gdcm", "func_name": "test_JPEGlossy", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossy_no_gdcm\n    def test_JPEGlossy(self):\n        \"\"\"JPEG-lossy: Returns correct values for sample data elements\"\"\"\n        got = self.jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        expected = 'Lossy Compression'\n        assert expected == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossy_no_gdcm", "def", "test_jpeglossy", "self", "jpeg", "lossy", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "expected", "lossy", "compression", "assert", "expected", "got"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossy_no_gdcm.test_JPEGlossy_pixel_array", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossy_no_gdcm", "func_name": "test_JPEGlossy_pixel_array", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossy_no_gdcm\n    def test_JPEGlossy_pixel_array(self):\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossy.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossy_no_gdcm", "def", "test_jpeglossy_pixel_array", "self", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossy", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossy_no_gdcm.test_JPEGBaseline_color_3D_pixel_array", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossy_no_gdcm", "func_name": "test_JPEGBaseline_color_3D_pixel_array", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossy_no_gdcm\n    def test_JPEGBaseline_color_3D_pixel_array(self):\n        with pytest.raises(NotImplementedError):\n            self.color_3d_jpeg.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossy_no_gdcm", "def", "test_jpegbaseline_color_3d_pixel_array", "self", "with", "pytest", "raises", "notimplementederror", "self", "color_3d_jpeg", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossless_no_gdcm.setup", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossless_no_gdcm", "func_name": "setup", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossless_no_gdcm\n    def setup(self):\n        self.jpeg_lossless = dcmread(jpeg_lossless_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossless_no_gdcm", "def", "setup", "self", "self", "jpeg_lossless", "dcmread", "jpeg_lossless_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossless_no_gdcm.teardown", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossless_no_gdcm", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossless_no_gdcm\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossless_no_gdcm", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossless_no_gdcm.testJPEGlossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossless_no_gdcm", "func_name": "testJPEGlossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossless_no_gdcm\n    def testJPEGlossless(self):\n        \"\"\"JPEGlossless: Returns correct values for sample data elements\"\"\"\n        got = self.\\\n            jpeg_lossless.\\\n            SourceImageSequence[0].\\\n            PurposeOfReferenceCodeSequence[0].CodeMeaning\n        expected = 'Uncompressed predecessor'\n        assert expected == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossless_no_gdcm", "def", "testjpeglossless", "self", "jpeglossless", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossless", "sourceimagesequence", "0", "purposeofreferencecodesequence", "0", "codemeaning", "expected", "uncompressed", "predecessor", "assert", "expected", "got"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestGDCM_JPEGlossless_no_gdcm.testJPEGlossless_pixel_array", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestGDCM_JPEGlossless_no_gdcm", "func_name": "testJPEGlossless_pixel_array", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestGDCM_JPEGlossless_no_gdcm\n    def testJPEGlossless_pixel_array(self):\n        \"\"\"JPEGlossless: Fails gracefully when uncompressed data asked for\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testgdcm_jpeglossless_no_gdcm", "def", "testjpeglossless_pixel_array", "self", "jpeglossless", "fails", "gracefully", "when", "uncompressed", "data", "asked", "for", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.with_gdcm", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "with_gdcm", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def with_gdcm(self, request):\n        original_value = HAVE_GDCM_IN_MEMORY_SUPPORT\n        if request.param == 'File':\n            gdcm_handler.HAVE_GDCM_IN_MEMORY_SUPPORT = False\n        original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler, gdcm_handler]\n        yield\n        gdcm_handler.HAVE_GDCM_IN_MEMORY_SUPPORT = original_value\n        pydicom.config.pixel_data_handlers = original_handlers\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "with_gdcm", "self", "request", "original_value", "have_gdcm_in_memory_support", "if", "request", "param", "file", "gdcm_handler", "have_gdcm_in_memory_support", "false", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "gdcm_handler", "yield", "gdcm_handler", "have_gdcm_in_memory_support", "original_value", "pydicom", "config", "pixel_data_handlers", "original_handlers"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.unicode_filename", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "unicode_filename", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def unicode_filename(self):\n        if compat.in_py2:\n            utf8_filename = os.path.join(tempfile.gettempdir(), \"ДИКОМ.dcm\")\n            unicode_filename = utf8_filename.decode(\"utf8\")\n            shutil.copyfile(jpeg_ls_lossless_name.decode(\"utf8\"),\n                            unicode_filename)\n        else:\n            unicode_filename = os.path.join(\n                tempfile.gettempdir(), \"ДИКОМ.dcm\")\n            shutil.copyfile(jpeg_ls_lossless_name, unicode_filename)\n        yield unicode_filename\n        os.remove(unicode_filename)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "unicode_filename", "self", "if", "compat", "in_py2", "utf8_filename", "os", "path", "join", "tempfile", "gettempdir", "dcm", "unicode_filename", "utf8_filename", "decode", "utf8", "shutil", "copyfile", "jpeg_ls_lossless_name", "decode", "utf8", "unicode_filename", "else", "unicode_filename", "os", "path", "join", "tempfile", "gettempdir", "dcm", "shutil", "copyfile", "jpeg_ls_lossless_name", "unicode_filename", "yield", "unicode_filename", "os", "remove", "unicode_filename"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_ls_lossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_ls_lossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_ls_lossless(self, unicode_filename):\n        return dcmread(unicode_filename)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_ls_lossless", "self", "unicode_filename", "return", "dcmread", "unicode_filename"], "doc_len": 12}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.sc_rgb_jpeg2k_gdcm_KY", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "sc_rgb_jpeg2k_gdcm_KY", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def sc_rgb_jpeg2k_gdcm_KY(self):\n        return dcmread(sc_rgb_jpeg2k_gdcm_KY)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "sc_rgb_jpeg2k_gdcm_ky", "self", "return", "dcmread", "sc_rgb_jpeg2k_gdcm_ky"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm(self):\n        return dcmread(ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm", "self", "return", "dcmread", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_2k", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_2k", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_2k(self):\n        return dcmread(jpeg2000_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_2k", "self", "return", "dcmread", "jpeg2000_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_2k_lossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_2k_lossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_2k_lossless(self):\n        return dcmread(jpeg2000_lossless_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_2k_lossless", "self", "return", "dcmread", "jpeg2000_lossless_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.mr_small", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "mr_small", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def mr_small(self):\n        return dcmread(mr_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "mr_small", "self", "return", "dcmread", "mr_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.emri_small", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "emri_small", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def emri_small(self):\n        return dcmread(emri_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "emri_small", "self", "return", "dcmread", "emri_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.emri_jpeg_ls_lossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "emri_jpeg_ls_lossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def emri_jpeg_ls_lossless(self):\n        return dcmread(emri_jpeg_ls_lossless)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "emri_jpeg_ls_lossless", "self", "return", "dcmread", "emri_jpeg_ls_lossless"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.emri_jpeg_2k_lossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "emri_jpeg_2k_lossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def emri_jpeg_2k_lossless(self):\n        return dcmread(emri_jpeg_2k_lossless)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "emri_jpeg_2k_lossless", "self", "return", "dcmread", "emri_jpeg_2k_lossless"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.color_3d_jpeg", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "color_3d_jpeg", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def color_3d_jpeg(self):\n        return dcmread(color_3d_jpeg_baseline)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "color_3d_jpeg", "self", "return", "dcmread", "color_3d_jpeg_baseline"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_lossy", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_lossy", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_lossy(self):\n        return dcmread(jpeg_lossy_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_lossy", "self", "return", "dcmread", "jpeg_lossy_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_lossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_lossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_lossless(self):\n        return dcmread(jpeg_lossless_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_lossless", "self", "return", "dcmread", "jpeg_lossless_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.jpeg_lossless_odd_data_size", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "jpeg_lossless_odd_data_size", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def jpeg_lossless_odd_data_size(self):\n        return dcmread(jpeg_lossless_odd_data_size_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "jpeg_lossless_odd_data_size", "self", "return", "dcmread", "jpeg_lossless_odd_data_size_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEG_LS_PixelArray(self, jpeg_ls_lossless, mr_small):\n        a = jpeg_ls_lossless.pixel_array\n        b = mr_small.pixel_array\n        assert a.mean() == b.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeg_ls_pixelarray", "self", "jpeg_ls_lossless", "mr_small", "a", "jpeg_ls_lossless", "pixel_array", "b", "mr_small", "pixel_array", "assert", "a", "mean", "b", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_emri_JPEG_LS_PixelArray_with_gdcm", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_emri_JPEG_LS_PixelArray_with_gdcm", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_emri_JPEG_LS_PixelArray_with_gdcm(self, emri_jpeg_ls_lossless,\n                                               emri_small):\n        a = emri_jpeg_ls_lossless.pixel_array\n        b = emri_small.pixel_array\n        assert a.mean() == b.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_emri_jpeg_ls_pixelarray_with_gdcm", "self", "emri_jpeg_ls_lossless", "emri_small", "a", "emri_jpeg_ls_lossless", "pixel_array", "b", "emri_small", "pixel_array", "assert", "a", "mean", "b", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEG2000", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEG2000", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEG2000(self, jpeg_2k):\n        \"\"\"JPEG2000: Returns correct values for sample data elements\"\"\"\n        # XX also tests multiple-valued AT data element\n        expected = [Tag(0x0054, 0x0010), Tag(0x0054, 0x0020)]\n        got = jpeg_2k.FrameIncrementPointer\n        assert expected == got\n\n        got = jpeg_2k.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeg2000", "self", "jpeg_2k", "jpeg2000", "returns", "correct", "values", "for", "sample", "data", "elements", "xx", "also", "tests", "multiple", "valued", "at", "data", "element", "expected", "tag", "0x0054", "0x0010", "tag", "0x0054", "0x0020", "got", "jpeg_2k", "frameincrementpointer", "assert", "expected", "got", "got", "jpeg_2k", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 47}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEG2000PixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEG2000PixelArray(self, jpeg_2k_lossless, mr_small):\n        a = jpeg_2k_lossless.pixel_array\n        b = mr_small.pixel_array\n        assert a.mean() == b.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeg2000pixelarray", "self", "jpeg_2k_lossless", "mr_small", "a", "jpeg_2k_lossless", "pixel_array", "b", "mr_small", "pixel_array", "assert", "a", "mean", "b", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_emri_JPEG2000PixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_emri_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_emri_JPEG2000PixelArray(self, emri_jpeg_2k_lossless, emri_small):\n        a = emri_jpeg_2k_lossless.pixel_array\n        b = emri_small.pixel_array\n        assert a.mean() == b.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_emri_jpeg2000pixelarray", "self", "emri_jpeg_2k_lossless", "emri_small", "a", "emri_jpeg_2k_lossless", "pixel_array", "b", "emri_small", "pixel_array", "assert", "a", "mean", "b", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEG2000_lossy", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEG2000_lossy", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEG2000_lossy(self, sc_rgb_jpeg2k_gdcm_KY,\n                            ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm):\n        a = sc_rgb_jpeg2k_gdcm_KY.pixel_array\n        b = ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm.pixel_array\n        if have_numpy_testing:\n            numpy.testing.assert_array_equal(a, b)\n        else:\n            assert a.mean() == b.mean()\n\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeg2000_lossy", "self", "sc_rgb_jpeg2k_gdcm_ky", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm", "a", "sc_rgb_jpeg2k_gdcm_ky", "pixel_array", "b", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm", "pixel_array", "if", "have_numpy_testing", "numpy", "testing", "assert_array_equal", "a", "b", "else", "assert", "a", "mean", "b", "mean", "assert", "a", "flags", "writeable"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGlossless", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGlossless", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGlossless(self, jpeg_lossless):\n        \"\"\"JPEGlossless: Returns correct values for sample data elements\"\"\"\n        got = jpeg_lossless.\\\n            SourceImageSequence[0].\\\n            PurposeOfReferenceCodeSequence[0].CodeMeaning\n        assert 'Uncompressed predecessor' == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeglossless", "self", "jpeg_lossless", "jpeglossless", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "jpeg_lossless", "sourceimagesequence", "0", "purposeofreferencecodesequence", "0", "codemeaning", "assert", "uncompressed", "predecessor", "got"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGlosslessPixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGlosslessPixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGlosslessPixelArray(self, jpeg_lossless):\n        \"\"\"JPEGlossless: Fails gracefully when uncompressed data asked for\"\"\"\n        a = jpeg_lossless.pixel_array\n        assert (1024, 256) == a.shape\n        # this test points were manually identified in Osirix viewer\n        assert 227 == a[420, 140]\n        assert 105 == a[230, 120]\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeglosslesspixelarray", "self", "jpeg_lossless", "jpeglossless", "fails", "gracefully", "when", "uncompressed", "data", "asked", "for", "a", "jpeg_lossless", "pixel_array", "assert", "1024", "256", "a", "shape", "this", "test", "points", "were", "manually", "identified", "in", "osirix", "viewer", "assert", "227", "a", "420", "140", "assert", "105", "a", "230", "120", "assert", "a", "flags", "writeable"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGlossless_odd_data_size", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGlossless_odd_data_size", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGlossless_odd_data_size(self, jpeg_lossless_odd_data_size):\n        pixel_data = jpeg_lossless_odd_data_size.pixel_array\n        assert 27 == pixel_data.nbytes\n        assert (3, 3, 3) == pixel_data.shape\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeglossless_odd_data_size", "self", "jpeg_lossless_odd_data_size", "pixel_data", "jpeg_lossless_odd_data_size", "pixel_array", "assert", "27", "pixel_data", "nbytes", "assert", "3", "3", "3", "pixel_data", "shape"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGlossy", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGlossy", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGlossy(self, jpeg_lossy):\n        \"\"\"JPEG-lossy: Returns correct values for sample data elements\"\"\"\n        got = jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeglossy", "self", "jpeg_lossy", "jpeg", "lossy", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGlossyPixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGlossyPixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGlossyPixelArray(self, jpeg_lossy):\n        a = jpeg_lossy.pixel_array\n        assert (1024, 256) == a.shape\n        # this test points were manually identified in Osirix viewer\n        assert 244 == a[420, 140]\n        assert 95 == a[230, 120]\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpeglossypixelarray", "self", "jpeg_lossy", "a", "jpeg_lossy", "pixel_array", "assert", "1024", "256", "a", "shape", "this", "test", "points", "were", "manually", "identified", "in", "osirix", "viewer", "assert", "244", "a", "420", "140", "assert", "95", "a", "230", "120", "assert", "a", "flags", "writeable"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_JPEGBaselineColor3DPixelArray", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_JPEGBaselineColor3DPixelArray", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_JPEGBaselineColor3DPixelArray(self, color_3d_jpeg):\n        assert \"YBR_FULL_422\" == color_3d_jpeg.PhotometricInterpretation\n        a = color_3d_jpeg.pixel_array\n\n        assert a.flags.writeable\n        assert (120, 480, 640, 3) == a.shape\n        a = _convert_YBR_FULL_to_RGB(a)\n        # this test points were manually identified in Osirix viewer\n        assert (41, 41, 41) == tuple(a[3, 159, 290, :])\n        assert (57, 57, 57) == tuple(a[3, 169, 290, :])\n        assert \"YBR_FULL_422\" == color_3d_jpeg.PhotometricInterpretation\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_jpegbaselinecolor3dpixelarray", "self", "color_3d_jpeg", "assert", "ybr_full_422", "color_3d_jpeg", "photometricinterpretation", "a", "color_3d_jpeg", "pixel_array", "assert", "a", "flags", "writeable", "assert", "120", "480", "640", "3", "a", "shape", "a", "_convert_ybr_full_to_rgb", "a", "this", "test", "points", "were", "manually", "identified", "in", "osirix", "viewer", "assert", "41", "41", "41", "tuple", "a", "3", "159", "290", "assert", "57", "57", "57", "tuple", "a", "3", "169", "290", "assert", "ybr_full_422", "color_3d_jpeg", "photometricinterpretation"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestsWithGDCM.test_PI_RGB", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestsWithGDCM", "func_name": "test_PI_RGB", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestsWithGDCM\n    def test_PI_RGB(self, image, PhotometricInterpretation, results,\n                    convert_yuv_to_rgb):\n        t = dcmread(image)\n        assert t.PhotometricInterpretation == PhotometricInterpretation\n        a = t.pixel_array\n\n        assert a.flags.writeable\n\n        assert (100, 100, 3) == a.shape\n        if convert_yuv_to_rgb:\n            a = _convert_YBR_FULL_to_RGB(a)\n        # this test points are from the ImageComments tag\n        assert results[0] == tuple(a[5, 50, :])\n        assert results[1] == tuple(a[15, 50, :])\n        assert results[2] == tuple(a[25, 50, :])\n        assert results[3] == tuple(a[35, 50, :])\n        assert results[4] == tuple(a[45, 50, :])\n        assert results[5] == tuple(a[55, 50, :])\n        assert results[6] == tuple(a[65, 50, :])\n        assert results[7] == tuple(a[75, 50, :])\n        assert results[8] == tuple(a[85, 50, :])\n        assert results[9] == tuple(a[95, 50, :])\n        assert PhotometricInterpretation == t.PhotometricInterpretation\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testswithgdcm", "def", "test_pi_rgb", "self", "image", "photometricinterpretation", "results", "convert_yuv_to_rgb", "t", "dcmread", "image", "assert", "t", "photometricinterpretation", "photometricinterpretation", "a", "t", "pixel_array", "assert", "a", "flags", "writeable", "assert", "100", "100", "3", "a", "shape", "if", "convert_yuv_to_rgb", "a", "_convert_ybr_full_to_rgb", "a", "this", "test", "points", "are", "from", "the", "imagecomments", "tag", "assert", "results", "0", "tuple", "a", "5", "50", "assert", "results", "1", "tuple", "a", "15", "50", "assert", "results", "2", "tuple", "a", "25", "50", "assert", "results", "3", "tuple", "a", "35", "50", "assert", "results", "4", "tuple", "a", "45", "50", "assert", "results", "5", "tuple", "a", "55", "50", "assert", "results", "6", "tuple", "a", "65", "50", "assert", "results", "7", "tuple", "a", "75", "50", "assert", "results", "8", "tuple", "a", "85", "50", "assert", "results", "9", "tuple", "a", "95", "50", "assert", "photometricinterpretation", "t", "photometricinterpretation"], "doc_len": 119}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.dataset_2d", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "dataset_2d", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def dataset_2d(self):\n        return dcmread(mr_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "dataset_2d", "self", "return", "dcmread", "mr_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.dataset_2d_compressed", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "dataset_2d_compressed", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def dataset_2d_compressed(self):\n        return dcmread(jpeg2000_name)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "dataset_2d_compressed", "self", "return", "dcmread", "jpeg2000_name"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.dataset_3d", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "dataset_3d", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def dataset_3d(self):\n        return dcmread(color_3d_jpeg_baseline)\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "dataset_3d", "self", "return", "dcmread", "color_3d_jpeg_baseline"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_data_element_from_uncompressed_2d_dataset", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_data_element_from_uncompressed_2d_dataset", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_data_element_from_uncompressed_2d_dataset(\n            self, dataset_2d):\n        data_element = gdcm_handler.create_data_element(dataset_2d)\n\n        assert 0x7fe0 == data_element.GetTag().GetGroup()\n        assert 0x0010 == data_element.GetTag().GetElement()\n        assert data_element.GetSequenceOfFragments() is None\n        assert data_element.GetByteValue() is not None\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_data_element_from_uncompressed_2d_dataset", "self", "dataset_2d", "data_element", "gdcm_handler", "create_data_element", "dataset_2d", "assert", "0x7fe0", "data_element", "gettag", "getgroup", "assert", "0x0010", "data_element", "gettag", "getelement", "assert", "data_element", "getsequenceoffragments", "is", "none", "assert", "data_element", "getbytevalue", "is", "not", "none"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_data_element_from_compressed_2d_dataset", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_data_element_from_compressed_2d_dataset", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_data_element_from_compressed_2d_dataset(\n            self, dataset_2d_compressed):\n        data_element = gdcm_handler.create_data_element(dataset_2d_compressed)\n\n        assert 0x7fe0 == data_element.GetTag().GetGroup()\n        assert 0x0010 == data_element.GetTag().GetElement()\n        assert data_element.GetSequenceOfFragments() is not None\n        assert data_element.GetByteValue() is None\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_data_element_from_compressed_2d_dataset", "self", "dataset_2d_compressed", "data_element", "gdcm_handler", "create_data_element", "dataset_2d_compressed", "assert", "0x7fe0", "data_element", "gettag", "getgroup", "assert", "0x0010", "data_element", "gettag", "getelement", "assert", "data_element", "getsequenceoffragments", "is", "not", "none", "assert", "data_element", "getbytevalue", "is", "none"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_data_element_from_3d_dataset", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_data_element_from_3d_dataset", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_data_element_from_3d_dataset(self, dataset_3d):\n        data_element = gdcm_handler.create_data_element(dataset_3d)\n\n        assert 0x7fe0 == data_element.GetTag().GetGroup()\n        assert 0x0010 == data_element.GetTag().GetElement()\n        assert data_element.GetSequenceOfFragments() is not None\n        assert data_element.GetByteValue() is None\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_data_element_from_3d_dataset", "self", "dataset_3d", "data_element", "gdcm_handler", "create_data_element", "dataset_3d", "assert", "0x7fe0", "data_element", "gettag", "getgroup", "assert", "0x0010", "data_element", "gettag", "getelement", "assert", "data_element", "getsequenceoffragments", "is", "not", "none", "assert", "data_element", "getbytevalue", "is", "none"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_image_from_2d_dataset", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_image_from_2d_dataset", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_image_from_2d_dataset(self, dataset_2d):\n        data_element = gdcm_handler.create_data_element(dataset_2d)\n        image = gdcm_handler.create_image(dataset_2d, data_element)\n        assert 2 == image.GetNumberOfDimensions()\n        assert [dataset_2d.Rows, dataset_2d.Columns] == image.GetDimensions()\n        pi_type = gdcm.PhotometricInterpretation.GetPIType(\n            dataset_2d.PhotometricInterpretation\n        )\n        assert pi_type == image.GetPhotometricInterpretation().GetType()\n\n        uid = str.__str__(dataset_2d.file_meta.TransferSyntaxUID)\n        assert uid == image.GetTransferSyntax().GetString()\n        pixel_format = image.GetPixelFormat()\n        assert dataset_2d.SamplesPerPixel == pixel_format.GetSamplesPerPixel()\n        assert dataset_2d.BitsAllocated == pixel_format.GetBitsAllocated()\n        assert dataset_2d.BitsStored == pixel_format.GetBitsStored()\n        assert dataset_2d.HighBit == pixel_format.GetHighBit()\n        px_repr = dataset_2d.PixelRepresentation\n        assert px_repr == pixel_format.GetPixelRepresentation()\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_image_from_2d_dataset", "self", "dataset_2d", "data_element", "gdcm_handler", "create_data_element", "dataset_2d", "image", "gdcm_handler", "create_image", "dataset_2d", "data_element", "assert", "2", "image", "getnumberofdimensions", "assert", "dataset_2d", "rows", "dataset_2d", "columns", "image", "getdimensions", "pi_type", "gdcm", "photometricinterpretation", "getpitype", "dataset_2d", "photometricinterpretation", "assert", "pi_type", "image", "getphotometricinterpretation", "gettype", "uid", "str", "__str__", "dataset_2d", "file_meta", "transfersyntaxuid", "assert", "uid", "image", "gettransfersyntax", "getstring", "pixel_format", "image", "getpixelformat", "assert", "dataset_2d", "samplesperpixel", "pixel_format", "getsamplesperpixel", "assert", "dataset_2d", "bitsallocated", "pixel_format", "getbitsallocated", "assert", "dataset_2d", "bitsstored", "pixel_format", "getbitsstored", "assert", "dataset_2d", "highbit", "pixel_format", "gethighbit", "px_repr", "dataset_2d", "pixelrepresentation", "assert", "px_repr", "pixel_format", "getpixelrepresentation"], "doc_len": 81}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_image_from_3d_dataset", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_image_from_3d_dataset", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_image_from_3d_dataset(self, dataset_3d):\n        data_element = gdcm_handler.create_data_element(dataset_3d)\n        image = gdcm_handler.create_image(dataset_3d, data_element)\n        assert 3 == image.GetNumberOfDimensions()\n        assert [\n            dataset_3d.Columns, dataset_3d.Rows,\n            int(dataset_3d.NumberOfFrames)\n        ] == image.GetDimensions()\n        pi = gdcm.PhotometricInterpretation.GetPIType(\n            dataset_3d.PhotometricInterpretation\n        )\n        assert pi == image.GetPhotometricInterpretation().GetType()\n        uid = str.__str__(dataset_3d.file_meta.TransferSyntaxUID)\n        assert uid == image.GetTransferSyntax().GetString()\n        pixel_format = image.GetPixelFormat()\n        assert dataset_3d.SamplesPerPixel == pixel_format.GetSamplesPerPixel()\n        assert dataset_3d.BitsAllocated == pixel_format.GetBitsAllocated()\n        assert dataset_3d.BitsStored == pixel_format.GetBitsStored()\n        assert dataset_3d.HighBit == pixel_format.GetHighBit()\n        px_repr = dataset_3d.PixelRepresentation\n        assert px_repr == pixel_format.GetPixelRepresentation()\n        planar = dataset_3d.PlanarConfiguration\n        assert planar == image.GetPlanarConfiguration()\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_image_from_3d_dataset", "self", "dataset_3d", "data_element", "gdcm_handler", "create_data_element", "dataset_3d", "image", "gdcm_handler", "create_image", "dataset_3d", "data_element", "assert", "3", "image", "getnumberofdimensions", "assert", "dataset_3d", "columns", "dataset_3d", "rows", "int", "dataset_3d", "numberofframes", "image", "getdimensions", "pi", "gdcm", "photometricinterpretation", "getpitype", "dataset_3d", "photometricinterpretation", "assert", "pi", "image", "getphotometricinterpretation", "gettype", "uid", "str", "__str__", "dataset_3d", "file_meta", "transfersyntaxuid", "assert", "uid", "image", "gettransfersyntax", "getstring", "pixel_format", "image", "getpixelformat", "assert", "dataset_3d", "samplesperpixel", "pixel_format", "getsamplesperpixel", "assert", "dataset_3d", "bitsallocated", "pixel_format", "getbitsallocated", "assert", "dataset_3d", "bitsstored", "pixel_format", "getbitsstored", "assert", "dataset_3d", "highbit", "pixel_format", "gethighbit", "px_repr", "dataset_3d", "pixelrepresentation", "assert", "px_repr", "pixel_format", "getpixelrepresentation", "planar", "dataset_3d", "planarconfiguration", "assert", "planar", "image", "getplanarconfiguration"], "doc_len": 91}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_image_reader_with_string", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_image_reader_with_string", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_image_reader_with_string(self):\n        image_reader = gdcm_handler.create_image_reader(mr_name)\n        assert image_reader is not None\n        assert image_reader.Read()\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_image_reader_with_string", "self", "image_reader", "gdcm_handler", "create_image_reader", "mr_name", "assert", "image_reader", "is", "not", "none", "assert", "image_reader", "read"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_gdcm_pixel_data.py::TestSupportFunctions.test_create_image_reader_with_py2_unicode_string", "file_path": "pydicom/tests/test_gdcm_pixel_data.py", "class_name": "TestSupportFunctions", "func_name": "test_create_image_reader_with_py2_unicode_string", "text": "文件路径: pydicom/tests/test_gdcm_pixel_data.py, 类名: TestSupportFunctions\n    def test_create_image_reader_with_py2_unicode_string(self):\n        filename = mr_name.decode('utf-8')\n        image_reader = gdcm_handler.create_image_reader(filename)\n        assert image_reader is not None\n        assert image_reader.Read()\n", "tokens": ["pydicom", "tests", "test_gdcm_pixel_data", "py", "testsupportfunctions", "def", "test_create_image_reader_with_py2_unicode_string", "self", "filename", "mr_name", "decode", "utf", "8", "image_reader", "gdcm_handler", "create_image_reader", "filename", "assert", "image_reader", "is", "not", "none", "assert", "image_reader", "read"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNoNumpy.test_pixel_dtype_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNoNumpy", "func_name": "test_pixel_dtype_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNoNumpy\n    def test_pixel_dtype_raises(self):\n        \"\"\"Test that pixel_dtype raises exception without numpy.\"\"\"\n        with pytest.raises(ImportError,\n                           match=\"Numpy is required to determine the dtype\"):\n            pixel_dtype(None)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnonumpy", "def", "test_pixel_dtype_raises", "self", "test", "that", "pixel_dtype", "raises", "exception", "without", "numpy", "with", "pytest", "raises", "importerror", "match", "numpy", "is", "required", "to", "determine", "the", "dtype", "pixel_dtype", "none"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNoNumpy.test_reshape_pixel_array_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNoNumpy", "func_name": "test_reshape_pixel_array_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNoNumpy\n    def test_reshape_pixel_array_raises(self):\n        \"\"\"Test that reshape_pixel_array raises exception without numpy.\"\"\"\n        with pytest.raises(ImportError,\n                           match=\"Numpy is required to reshape\"):\n            reshape_pixel_array(None, None)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnonumpy", "def", "test_reshape_pixel_array_raises", "self", "test", "that", "reshape_pixel_array", "raises", "exception", "without", "numpy", "with", "pytest", "raises", "importerror", "match", "numpy", "is", "required", "to", "reshape", "reshape_pixel_array", "none", "none"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNoNumpy.test_convert_color_space_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNoNumpy", "func_name": "test_convert_color_space_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNoNumpy\n    def test_convert_color_space_raises(self):\n        \"\"\"Test that convert_color_space raises exception.\"\"\"\n        with pytest.raises(ImportError,\n                           match=\"Numpy is required to convert\"):\n            convert_color_space(None, None, None)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnonumpy", "def", "test_convert_color_space_raises", "self", "test", "that", "convert_color_space", "raises", "exception", "with", "pytest", "raises", "importerror", "match", "numpy", "is", "required", "to", "convert", "convert_color_space", "none", "none", "none"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.setup", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "setup", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def setup(self):\n        \"\"\"Setup the test dataset.\"\"\"\n        self.ds = Dataset()\n        self.ds.file_meta = Dataset()\n        self.ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "setup", "self", "setup", "the", "test", "dataset", "self", "ds", "dataset", "self", "ds", "file_meta", "dataset", "self", "ds", "file_meta", "transfersyntaxuid", "explicitvrlittleendian"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.test_unknown_pixel_representation_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "test_unknown_pixel_representation_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def test_unknown_pixel_representation_raises(self):\n        \"\"\"Test an unknown PixelRepresentation value raises exception.\"\"\"\n        self.ds.BitsAllocated = 16\n        self.ds.PixelRepresentation = -1\n        # The bracket needs to be escaped\n        with pytest.raises(ValueError,\n                           match=r\"value of '-1' for '\\(0028,0103\"):\n            pixel_dtype(self.ds)\n\n        self.ds.PixelRepresentation = 2\n        with pytest.raises(ValueError,\n                           match=r\"value of '2' for '\\(0028,0103\"):\n            pixel_dtype(self.ds)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "test_unknown_pixel_representation_raises", "self", "test", "an", "unknown", "pixelrepresentation", "value", "raises", "exception", "self", "ds", "bitsallocated", "16", "self", "ds", "pixelrepresentation", "1", "the", "bracket", "needs", "to", "be", "escaped", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "1", "for", "0028", "0103", "pixel_dtype", "self", "ds", "self", "ds", "pixelrepresentation", "2", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "2", "for", "0028", "0103", "pixel_dtype", "self", "ds"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.test_unknown_bits_allocated_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "test_unknown_bits_allocated_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def test_unknown_bits_allocated_raises(self):\n        \"\"\"Test an unknown BitsAllocated value raises exception.\"\"\"\n        self.ds.BitsAllocated = 0\n        self.ds.PixelRepresentation = 0\n        # The bracket needs to be escaped\n        with pytest.raises(ValueError,\n                           match=r\"value of '0' for '\\(0028,0100\"):\n            pixel_dtype(self.ds)\n\n        self.ds.BitsAllocated = 2\n        with pytest.raises(ValueError,\n                           match=r\"value of '2' for '\\(0028,0100\"):\n            pixel_dtype(self.ds)\n\n        self.ds.BitsAllocated = 15\n        with pytest.raises(ValueError,\n                           match=r\"value of '15' for '\\(0028,0100\"):\n            pixel_dtype(self.ds)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "test_unknown_bits_allocated_raises", "self", "test", "an", "unknown", "bitsallocated", "value", "raises", "exception", "self", "ds", "bitsallocated", "0", "self", "ds", "pixelrepresentation", "0", "the", "bracket", "needs", "to", "be", "escaped", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "0", "for", "0028", "0100", "pixel_dtype", "self", "ds", "self", "ds", "bitsallocated", "2", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "2", "for", "0028", "0100", "pixel_dtype", "self", "ds", "self", "ds", "bitsallocated", "15", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "15", "for", "0028", "0100", "pixel_dtype", "self", "ds"], "doc_len": 82}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.test_unsupported_dtypes", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "test_unsupported_dtypes", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def test_unsupported_dtypes(self):\n        \"\"\"Test unsupported dtypes raise exception.\"\"\"\n        self.ds.BitsAllocated = 24\n        self.ds.PixelRepresentation = 0\n\n        with pytest.raises(NotImplementedError,\n                           match=\"data type 'uint24' needed to contain\"):\n            pixel_dtype(self.ds)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "test_unsupported_dtypes", "self", "test", "unsupported", "dtypes", "raise", "exception", "self", "ds", "bitsallocated", "24", "self", "ds", "pixelrepresentation", "0", "with", "pytest", "raises", "notimplementederror", "match", "data", "type", "uint24", "needed", "to", "contain", "pixel_dtype", "self", "ds"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.test_supported_dtypes", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "test_supported_dtypes", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def test_supported_dtypes(self, bits, pixel_repr, dtype):\n        \"\"\"Test supported dtypes.\"\"\"\n        self.ds.BitsAllocated = bits\n        self.ds.PixelRepresentation = pixel_repr\n        # Correct for endianness of system\n        ref_dtype = np.dtype(dtype)\n        endianness = self.ds.file_meta.TransferSyntaxUID.is_little_endian\n        if endianness != (byteorder == 'little'):\n            ref_dtype = ref_dtype.newbyteorder('S')\n\n        assert ref_dtype == pixel_dtype(self.ds)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "test_supported_dtypes", "self", "bits", "pixel_repr", "dtype", "test", "supported", "dtypes", "self", "ds", "bitsallocated", "bits", "self", "ds", "pixelrepresentation", "pixel_repr", "correct", "for", "endianness", "of", "system", "ref_dtype", "np", "dtype", "dtype", "endianness", "self", "ds", "file_meta", "transfersyntaxuid", "is_little_endian", "if", "endianness", "byteorder", "little", "ref_dtype", "ref_dtype", "newbyteorder", "s", "assert", "ref_dtype", "pixel_dtype", "self", "ds"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_PixelDtype.test_byte_swapping", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_PixelDtype", "func_name": "test_byte_swapping", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_PixelDtype\n    def test_byte_swapping(self):\n        \"\"\"Test that the endianess of the system is taken into account.\"\"\"\n        # The main problem is that our testing environments are probably\n        #   all little endian, but we'll try our best\n        self.ds.BitsAllocated = 16\n        self.ds.PixelRepresentation = 0\n\n        # < is little, = is native, > is big\n        if byteorder == 'little':\n            self.ds.is_little_endian = True\n            assert pixel_dtype(self.ds).byteorder in ['<', '=']\n            self.ds.is_little_endian = False\n            assert pixel_dtype(self.ds).byteorder == '>'\n        elif byteorder == 'big':\n            self.ds.is_little_endian = True\n            assert pixel_dtype(self.ds).byteorder == '<'\n            self.ds.is_little_endian = False\n            assert pixel_dtype(self.ds).byteorder in ['>', '=']\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_pixeldtype", "def", "test_byte_swapping", "self", "test", "that", "the", "endianess", "of", "the", "system", "is", "taken", "into", "account", "the", "main", "problem", "is", "that", "our", "testing", "environments", "are", "probably", "all", "little", "endian", "but", "we", "ll", "try", "our", "best", "self", "ds", "bitsallocated", "16", "self", "ds", "pixelrepresentation", "0", "is", "little", "is", "native", "is", "big", "if", "byteorder", "little", "self", "ds", "is_little_endian", "true", "assert", "pixel_dtype", "self", "ds", "byteorder", "in", "self", "ds", "is_little_endian", "false", "assert", "pixel_dtype", "self", "ds", "byteorder", "elif", "byteorder", "big", "self", "ds", "is_little_endian", "true", "assert", "pixel_dtype", "self", "ds", "byteorder", "self", "ds", "is_little_endian", "false", "assert", "pixel_dtype", "self", "ds", "byteorder", "in"], "doc_len": 96}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.setup", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "setup", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def setup(self):\n        \"\"\"Setup the test dataset.\"\"\"\n        self.ds = Dataset()\n        self.ds.file_meta = Dataset()\n        self.ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        self.ds.Rows = 4\n        self.ds.Columns = 5\n\n        # Expected output ref_#frames_#samples\n        self.ref_1_1 = RESHAPE_ARRAYS['reference'][0, :, :, 0]\n        self.ref_1_3 = RESHAPE_ARRAYS['reference'][0]\n        self.ref_2_1 = RESHAPE_ARRAYS['reference'][:, :, :, 0]\n        self.ref_2_3 = RESHAPE_ARRAYS['reference']\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "setup", "self", "setup", "the", "test", "dataset", "self", "ds", "dataset", "self", "ds", "file_meta", "dataset", "self", "ds", "file_meta", "transfersyntaxuid", "explicitvrlittleendian", "self", "ds", "rows", "4", "self", "ds", "columns", "5", "expected", "output", "ref_", "frames_", "samples", "self", "ref_1_1", "reshape_arrays", "reference", "0", "0", "self", "ref_1_3", "reshape_arrays", "reference", "0", "self", "ref_2_1", "reshape_arrays", "reference", "0", "self", "ref_2_3", "reshape_arrays", "reference"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_reference_1frame_1sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_reference_1frame_1sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_reference_1frame_1sample(self):\n        \"\"\"Test the 1 frame 1 sample/pixel reference array is as expected.\"\"\"\n        # (rows, columns)\n        assert (4, 5) == self.ref_1_1.shape\n        assert np.array_equal(\n            self.ref_1_1,\n            np.asarray(\n                [[1, 2, 3, 4, 5],\n                 [2, 3, 4, 5, 6],\n                 [3, 4, 5, 6, 7],\n                 [4, 5, 6, 7, 8]]\n            )\n        )\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_reference_1frame_1sample", "self", "test", "the", "1", "frame", "1", "sample", "pixel", "reference", "array", "is", "as", "expected", "rows", "columns", "assert", "4", "5", "self", "ref_1_1", "shape", "assert", "np", "array_equal", "self", "ref_1_1", "np", "asarray", "1", "2", "3", "4", "5", "2", "3", "4", "5", "6", "3", "4", "5", "6", "7", "4", "5", "6", "7", "8"], "doc_len": 55}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_reference_1frame_3sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_reference_1frame_3sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_reference_1frame_3sample(self):\n        \"\"\"Test the 1 frame 3 sample/pixel reference array is as expected.\"\"\"\n        # (rows, columns, planes)\n        assert (4, 5, 3) == self.ref_1_3.shape\n\n        # Red channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 0],\n            np.asarray(\n                [[1, 2, 3, 4, 5],\n                 [2, 3, 4, 5, 6],\n                 [3, 4, 5, 6, 7],\n                 [4, 5, 6, 7, 8]]\n            )\n        )\n        # Green channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 1],\n            np.asarray(\n                [[9,  10, 11, 12, 13],\n                 [10, 11, 12, 13, 14],\n                 [11, 12, 13, 14, 15],\n                 [12, 13, 14, 15, 16]]\n            )\n        )\n        # Blue channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 2],\n            np.asarray(\n                [[17, 18, 19, 20, 21],\n                 [18, 19, 20, 21, 22],\n                 [19, 20, 21, 22, 23],\n                 [20, 21, 22, 23, 24]]\n            )\n        )\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_reference_1frame_3sample", "self", "test", "the", "1", "frame", "3", "sample", "pixel", "reference", "array", "is", "as", "expected", "rows", "columns", "planes", "assert", "4", "5", "3", "self", "ref_1_3", "shape", "red", "channel", "assert", "np", "array_equal", "self", "ref_1_3", "0", "np", "asarray", "1", "2", "3", "4", "5", "2", "3", "4", "5", "6", "3", "4", "5", "6", "7", "4", "5", "6", "7", "8", "green", "channel", "assert", "np", "array_equal", "self", "ref_1_3", "1", "np", "asarray", "9", "10", "11", "12", "13", "10", "11", "12", "13", "14", "11", "12", "13", "14", "15", "12", "13", "14", "15", "16", "blue", "channel", "assert", "np", "array_equal", "self", "ref_1_3", "2", "np", "asarray", "17", "18", "19", "20", "21", "18", "19", "20", "21", "22", "19", "20", "21", "22", "23", "20", "21", "22", "23", "24"], "doc_len": 120}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_reference_2frame_1sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_reference_2frame_1sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_reference_2frame_1sample(self):\n        \"\"\"Test the 2 frame 1 sample/pixel reference array is as expected.\"\"\"\n        # (nr frames, rows, columns)\n        assert (2, 4, 5) == self.ref_2_1.shape\n\n        # Frame 1\n        assert np.array_equal(\n            self.ref_2_1[0, :, :],\n            np.asarray(\n                [[1, 2, 3, 4, 5],\n                 [2, 3, 4, 5, 6],\n                 [3, 4, 5, 6, 7],\n                 [4, 5, 6, 7, 8]]\n            )\n        )\n        # Frame 2\n        assert np.array_equal(\n            self.ref_2_1[1, :, :],\n            np.asarray(\n                [[25, 26, 27, 28, 29],\n                 [26, 27, 28, 29, 30],\n                 [27, 28, 29, 30, 31],\n                 [28, 29, 30, 31, 32]]\n            )\n        )\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_reference_2frame_1sample", "self", "test", "the", "2", "frame", "1", "sample", "pixel", "reference", "array", "is", "as", "expected", "nr", "frames", "rows", "columns", "assert", "2", "4", "5", "self", "ref_2_1", "shape", "frame", "1", "assert", "np", "array_equal", "self", "ref_2_1", "0", "np", "asarray", "1", "2", "3", "4", "5", "2", "3", "4", "5", "6", "3", "4", "5", "6", "7", "4", "5", "6", "7", "8", "frame", "2", "assert", "np", "array_equal", "self", "ref_2_1", "1", "np", "asarray", "25", "26", "27", "28", "29", "26", "27", "28", "29", "30", "27", "28", "29", "30", "31", "28", "29", "30", "31", "32"], "doc_len": 91}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_reference_2frame_3sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_reference_2frame_3sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_reference_2frame_3sample(self):\n        \"\"\"Test the 2 frame 3 sample/pixel reference array is as expected.\"\"\"\n        # (nr frames, row, columns, planes)\n        assert (2, 4, 5, 3) == self.ref_2_3.shape\n\n        # Red channel, frame 1\n        assert np.array_equal(\n            self.ref_2_3[0, :, :, 0],\n            np.asarray(\n                [[1, 2, 3, 4, 5],\n                 [2, 3, 4, 5, 6],\n                 [3, 4, 5, 6, 7],\n                 [4, 5, 6, 7, 8]]\n            )\n        )\n        # Green channel, frame 2\n        assert np.array_equal(\n            self.ref_2_3[1, :, :, 1],\n            np.asarray(\n                [[33, 34, 35, 36, 37],\n                 [34, 35, 36, 37, 38],\n                 [35, 36, 37, 38, 39],\n                 [36, 37, 38, 39, 40]]\n            )\n        )\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_reference_2frame_3sample", "self", "test", "the", "2", "frame", "3", "sample", "pixel", "reference", "array", "is", "as", "expected", "nr", "frames", "row", "columns", "planes", "assert", "2", "4", "5", "3", "self", "ref_2_3", "shape", "red", "channel", "frame", "1", "assert", "np", "array_equal", "self", "ref_2_3", "0", "0", "np", "asarray", "1", "2", "3", "4", "5", "2", "3", "4", "5", "6", "3", "4", "5", "6", "7", "4", "5", "6", "7", "8", "green", "channel", "frame", "2", "assert", "np", "array_equal", "self", "ref_2_3", "1", "1", "np", "asarray", "33", "34", "35", "36", "37", "34", "35", "36", "37", "38", "35", "36", "37", "38", "39", "36", "37", "38", "39", "40"], "doc_len": 99}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_1frame_1sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_1frame_1sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_1frame_1sample(self):\n        \"\"\"Test reshaping 1 frame, 1 sample/pixel.\"\"\"\n        self.ds.SamplesPerPixel = 1\n        arr = reshape_pixel_array(self.ds, RESHAPE_ARRAYS['1frame_1sample'])\n        assert (4, 5) == arr.shape\n        assert np.array_equal(arr, self.ref_1_1)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_1frame_1sample", "self", "test", "reshaping", "1", "frame", "1", "sample", "pixel", "self", "ds", "samplesperpixel", "1", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_1sample", "assert", "4", "5", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_1"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_1frame_3sample_0conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_1frame_3sample_0conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_1frame_3sample_0conf(self):\n        \"\"\"Test reshaping 1 frame, 3 sample/pixel for 0 planar config.\"\"\"\n        self.ds.NumberOfFrames = 1\n        self.ds.SamplesPerPixel = 3\n        self.ds.PlanarConfiguration = 0\n        arr = reshape_pixel_array(self.ds,\n                                  RESHAPE_ARRAYS['1frame_3sample_0config'])\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_1frame_3sample_0conf", "self", "test", "reshaping", "1", "frame", "3", "sample", "pixel", "for", "0", "planar", "config", "self", "ds", "numberofframes", "1", "self", "ds", "samplesperpixel", "3", "self", "ds", "planarconfiguration", "0", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_0config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_1frame_3sample_1conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_1frame_3sample_1conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_1frame_3sample_1conf(self):\n        \"\"\"Test reshaping 1 frame, 3 sample/pixel for 1 planar config.\"\"\"\n        self.ds.NumberOfFrames = 1\n        self.ds.SamplesPerPixel = 3\n        self.ds.PlanarConfiguration = 1\n        arr = reshape_pixel_array(self.ds,\n                                  RESHAPE_ARRAYS['1frame_3sample_1config'])\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_1frame_3sample_1conf", "self", "test", "reshaping", "1", "frame", "3", "sample", "pixel", "for", "1", "planar", "config", "self", "ds", "numberofframes", "1", "self", "ds", "samplesperpixel", "3", "self", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_1config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_2frame_1sample", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_2frame_1sample", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_2frame_1sample(self):\n        \"\"\"Test reshaping 2 frame, 1 sample/pixel.\"\"\"\n        self.ds.NumberOfFrames = 2\n        self.ds.SamplesPerPixel = 1\n        arr = reshape_pixel_array(self.ds, RESHAPE_ARRAYS['2frame_1sample'])\n        assert (2, 4, 5) == arr.shape\n        assert np.array_equal(arr, self.ref_2_1)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_2frame_1sample", "self", "test", "reshaping", "2", "frame", "1", "sample", "pixel", "self", "ds", "numberofframes", "2", "self", "ds", "samplesperpixel", "1", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "2frame_1sample", "assert", "2", "4", "5", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_2_1"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_2frame_3sample_0conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_2frame_3sample_0conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_2frame_3sample_0conf(self):\n        \"\"\"Test reshaping 2 frame, 3 sample/pixel for 0 planar config.\"\"\"\n        self.ds.NumberOfFrames = 2\n        self.ds.SamplesPerPixel = 3\n        self.ds.PlanarConfiguration = 0\n        arr = reshape_pixel_array(self.ds,\n                                  RESHAPE_ARRAYS['2frame_3sample_0config'])\n        assert (2, 4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_2_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_2frame_3sample_0conf", "self", "test", "reshaping", "2", "frame", "3", "sample", "pixel", "for", "0", "planar", "config", "self", "ds", "numberofframes", "2", "self", "ds", "samplesperpixel", "3", "self", "ds", "planarconfiguration", "0", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "2frame_3sample_0config", "assert", "2", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_2_3"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_2frame_3sample_1conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_2frame_3sample_1conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_2frame_3sample_1conf(self):\n        \"\"\"Test reshaping 2 frame, 3 sample/pixel for 1 planar config.\"\"\"\n        self.ds.NumberOfFrames = 2\n        self.ds.SamplesPerPixel = 3\n        self.ds.PlanarConfiguration = 1\n        arr = reshape_pixel_array(self.ds,\n                                  RESHAPE_ARRAYS['2frame_3sample_1config'])\n        assert (2, 4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_2_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_2frame_3sample_1conf", "self", "test", "reshaping", "2", "frame", "3", "sample", "pixel", "for", "1", "planar", "config", "self", "ds", "numberofframes", "2", "self", "ds", "samplesperpixel", "3", "self", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "2frame_3sample_1config", "assert", "2", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_2_3"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_compressed_syntaxes_0conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_compressed_syntaxes_0conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_compressed_syntaxes_0conf(self):\n        \"\"\"Test the compressed syntaxes that are always 0 planar conf.\"\"\"\n        for uid in ['1.2.840.10008.1.2.4.50',\n                    '1.2.840.10008.1.2.4.57',\n                    '1.2.840.10008.1.2.4.70',\n                    '1.2.840.10008.1.2.4.90',\n                    '1.2.840.10008.1.2.4.91']:\n            self.ds.file_meta.TransferSyntaxUID = uid\n            self.ds.PlanarConfiguration = 1\n            self.ds.NumberOfFrames = 1\n            self.ds.SamplesPerPixel = 3\n\n            arr = reshape_pixel_array(self.ds,\n                                      RESHAPE_ARRAYS['1frame_3sample_0config'])\n            assert (4, 5, 3) == arr.shape\n            assert np.array_equal(arr, self.ref_1_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_compressed_syntaxes_0conf", "self", "test", "the", "compressed", "syntaxes", "that", "are", "always", "0", "planar", "conf", "for", "uid", "in", "1", "2", "840", "10008", "1", "2", "4", "50", "1", "2", "840", "10008", "1", "2", "4", "57", "1", "2", "840", "10008", "1", "2", "4", "70", "1", "2", "840", "10008", "1", "2", "4", "90", "1", "2", "840", "10008", "1", "2", "4", "91", "self", "ds", "file_meta", "transfersyntaxuid", "uid", "self", "ds", "planarconfiguration", "1", "self", "ds", "numberofframes", "1", "self", "ds", "samplesperpixel", "3", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_0config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3"], "doc_len": 96}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_compressed_syntaxes_1conf", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_compressed_syntaxes_1conf", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_compressed_syntaxes_1conf(self):\n        \"\"\"Test the compressed syntaxes that are always 1 planar conf.\"\"\"\n        for uid in ['1.2.840.10008.1.2.4.80',\n                    '1.2.840.10008.1.2.4.81',\n                    '1.2.840.10008.1.2.5']:\n            self.ds.file_meta.TransferSyntaxUID = uid\n            self.ds.PlanarConfiguration = 0\n            self.ds.NumberOfFrames = 1\n            self.ds.SamplesPerPixel = 3\n\n            arr = reshape_pixel_array(self.ds,\n                                      RESHAPE_ARRAYS['1frame_3sample_1config'])\n            assert (4, 5, 3) == arr.shape\n            assert np.array_equal(arr, self.ref_1_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_compressed_syntaxes_1conf", "self", "test", "the", "compressed", "syntaxes", "that", "are", "always", "1", "planar", "conf", "for", "uid", "in", "1", "2", "840", "10008", "1", "2", "4", "80", "1", "2", "840", "10008", "1", "2", "4", "81", "1", "2", "840", "10008", "1", "2", "5", "self", "ds", "file_meta", "transfersyntaxuid", "uid", "self", "ds", "planarconfiguration", "0", "self", "ds", "numberofframes", "1", "self", "ds", "samplesperpixel", "3", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_1config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_uncompressed_syntaxes", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_uncompressed_syntaxes", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_uncompressed_syntaxes(self):\n        \"\"\"Test that uncompressed syntaxes use the dataset planar conf.\"\"\"\n        for uid in UncompressedPixelTransferSyntaxes:\n            self.ds.file_meta.TransferSyntaxUID = uid\n            self.ds.PlanarConfiguration = 0\n            self.ds.NumberOfFrames = 1\n            self.ds.SamplesPerPixel = 3\n\n            arr = reshape_pixel_array(self.ds,\n                                      RESHAPE_ARRAYS['1frame_3sample_0config'])\n            assert (4, 5, 3) == arr.shape\n            assert np.array_equal(arr, self.ref_1_3)\n\n            self.ds.PlanarConfiguration = 1\n            arr = reshape_pixel_array(self.ds,\n                                      RESHAPE_ARRAYS['1frame_3sample_1config'])\n            assert (4, 5, 3) == arr.shape\n            assert np.array_equal(arr, self.ref_1_3)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_uncompressed_syntaxes", "self", "test", "that", "uncompressed", "syntaxes", "use", "the", "dataset", "planar", "conf", "for", "uid", "in", "uncompressedpixeltransfersyntaxes", "self", "ds", "file_meta", "transfersyntaxuid", "uid", "self", "ds", "planarconfiguration", "0", "self", "ds", "numberofframes", "1", "self", "ds", "samplesperpixel", "3", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_0config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3", "self", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_1config", "assert", "4", "5", "3", "arr", "shape", "assert", "np", "array_equal", "arr", "self", "ref_1_3"], "doc_len": 78}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_invalid_nr_frames_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_invalid_nr_frames_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_invalid_nr_frames_raises(self):\n        \"\"\"Test an invalid Number of Frames value raises exception.\"\"\"\n        self.ds.SamplesPerPixel = 1\n        self.ds.NumberOfFrames = 0\n        # Need to escape brackets\n        with pytest.raises(ValueError,\n                           match=r\"value of 0 for \\(0028,0008\\)\"):\n            reshape_pixel_array(self.ds, RESHAPE_ARRAYS['1frame_1sample'])\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_invalid_nr_frames_raises", "self", "test", "an", "invalid", "number", "of", "frames", "value", "raises", "exception", "self", "ds", "samplesperpixel", "1", "self", "ds", "numberofframes", "0", "need", "to", "escape", "brackets", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "0", "for", "0028", "0008", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_1sample"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_invalid_samples_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_invalid_samples_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_invalid_samples_raises(self):\n        \"\"\"Test an invalid Samples per Pixel value raises exception.\"\"\"\n        self.ds.SamplesPerPixel = 0\n        # Need to escape brackets\n        with pytest.raises(ValueError,\n                           match=r\"value of 0 for \\(0028,0002\\)\"):\n            reshape_pixel_array(self.ds, RESHAPE_ARRAYS['1frame_1sample'])\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_invalid_samples_raises", "self", "test", "an", "invalid", "samples", "per", "pixel", "value", "raises", "exception", "self", "ds", "samplesperpixel", "0", "need", "to", "escape", "brackets", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "0", "for", "0028", "0002", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_1sample"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ReshapePixelArray.test_invalid_planar_conf_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ReshapePixelArray", "func_name": "test_invalid_planar_conf_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ReshapePixelArray\n    def test_invalid_planar_conf_raises(self):\n        self.ds.SamplesPerPixel = 3\n        self.ds.PlanarConfiguration = 2\n        # Need to escape brackets\n        with pytest.raises(ValueError,\n                           match=r\"value of 2 for \\(0028,0006\\)\"):\n            reshape_pixel_array(self.ds,\n                                RESHAPE_ARRAYS['1frame_3sample_0config'])\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_reshapepixelarray", "def", "test_invalid_planar_conf_raises", "self", "self", "ds", "samplesperpixel", "3", "self", "ds", "planarconfiguration", "2", "need", "to", "escape", "brackets", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "2", "for", "0028", "0006", "reshape_pixel_array", "self", "ds", "reshape_arrays", "1frame_3sample_0config"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ConvertColourSpace.test_unknown_current_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ConvertColourSpace", "func_name": "test_unknown_current_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ConvertColourSpace\n    def test_unknown_current_raises(self):\n        \"\"\"Test an unknown current color space raises exception.\"\"\"\n        with pytest.raises(NotImplementedError,\n                           match=\"Conversion from TEST to RGB is not suppo\"):\n            convert_color_space(None, 'TEST', 'RGB')\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_convertcolourspace", "def", "test_unknown_current_raises", "self", "test", "an", "unknown", "current", "color", "space", "raises", "exception", "with", "pytest", "raises", "notimplementederror", "match", "conversion", "from", "test", "to", "rgb", "is", "not", "suppo", "convert_color_space", "none", "test", "rgb"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ConvertColourSpace.test_unknown_desired_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ConvertColourSpace", "func_name": "test_unknown_desired_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ConvertColourSpace\n    def test_unknown_desired_raises(self):\n        \"\"\"Test an unknown desdired color space raises exception.\"\"\"\n        with pytest.raises(NotImplementedError,\n                           match=\"Conversion from RGB to TEST is not suppo\"):\n            convert_color_space(None, 'RGB', 'TEST')\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_convertcolourspace", "def", "test_unknown_desired_raises", "self", "test", "an", "unknown", "desdired", "color", "space", "raises", "exception", "with", "pytest", "raises", "notimplementederror", "match", "conversion", "from", "rgb", "to", "test", "is", "not", "suppo", "convert_color_space", "none", "rgb", "test"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ConvertColourSpace.test_current_is_desired", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ConvertColourSpace", "func_name": "test_current_is_desired", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ConvertColourSpace\n    def test_current_is_desired(self):\n        \"\"\"Test that the array is unchanged when current matches desired.\"\"\"\n        arr = np.ones((2, 3))\n        assert np.array_equal(arr, convert_color_space(arr, 'RGB', 'RGB'))\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_convertcolourspace", "def", "test_current_is_desired", "self", "test", "that", "the", "array", "is", "unchanged", "when", "current", "matches", "desired", "arr", "np", "ones", "2", "3", "assert", "np", "array_equal", "arr", "convert_color_space", "arr", "rgb", "rgb"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ConvertColourSpace.test_rgb_ybr_rgb_single_frame", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ConvertColourSpace", "func_name": "test_rgb_ybr_rgb_single_frame", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ConvertColourSpace\n    def test_rgb_ybr_rgb_single_frame(self):\n        \"\"\"Test round trip conversion of single framed pixel data.\"\"\"\n        ds = dcmread(RGB_8_3_1F)\n\n        arr = ds.pixel_array\n        assert (255, 0, 0) == tuple(arr[5, 50, :])\n        assert (255, 128, 128) == tuple(arr[15, 50, :])\n        assert (0, 255, 0) == tuple(arr[25, 50, :])\n        assert (128, 255, 128) == tuple(arr[35, 50, :])\n        assert (0, 0, 255) == tuple(arr[45, 50, :])\n        assert (128, 128, 255) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (64, 64, 64) == tuple(arr[75, 50, :])\n        assert (192, 192, 192) == tuple(arr[85, 50, :])\n        assert (255, 255, 255) == tuple(arr[95, 50, :])\n\n        ybr = convert_color_space(arr, 'RGB', 'YBR_FULL')\n        assert (76, 85, 255) == tuple(ybr[5, 50, :])\n        assert (166, 107, 192) == tuple(ybr[15, 50, :])\n        assert (150, 44, 21) == tuple(ybr[25, 50, :])\n        assert (203, 86, 75) == tuple(ybr[35, 50, :])\n        assert (29, 255, 107) == tuple(ybr[45, 50, :])\n        assert (142, 192, 118) == tuple(ybr[55, 50, :])\n        assert (0, 128, 128) == tuple(ybr[65, 50, :])\n        assert (64, 128, 128) == tuple(ybr[75, 50, :])\n        assert (192, 128, 128) == tuple(ybr[85, 50, :])\n        assert (255, 128, 128) == tuple(ybr[95, 50, :])\n\n        # Round trip -> rounding errors get compounded\n        rgb = convert_color_space(ybr, 'YBR_FULL', 'RGB')\n        assert (254, 0, 0) == tuple(rgb[5, 50, :])\n        assert (255, 128, 129) == tuple(rgb[15, 50, :])\n        assert (0, 255, 1) == tuple(rgb[25, 50, :])\n        assert (129, 255, 129) == tuple(rgb[35, 50, :])\n        assert (0, 0, 254) == tuple(rgb[45, 50, :])\n        assert (128, 127, 255) == tuple(rgb[55, 50, :])\n        assert (0, 0, 0) == tuple(rgb[65, 50, :])\n        assert (64, 64, 64) == tuple(rgb[75, 50, :])\n        assert (192, 192, 192) == tuple(rgb[85, 50, :])\n        assert (255, 255, 255) == tuple(rgb[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_convertcolourspace", "def", "test_rgb_ybr_rgb_single_frame", "self", "test", "round", "trip", "conversion", "of", "single", "framed", "pixel", "data", "ds", "dcmread", "rgb_8_3_1f", "arr", "ds", "pixel_array", "assert", "255", "0", "0", "tuple", "arr", "5", "50", "assert", "255", "128", "128", "tuple", "arr", "15", "50", "assert", "0", "255", "0", "tuple", "arr", "25", "50", "assert", "128", "255", "128", "tuple", "arr", "35", "50", "assert", "0", "0", "255", "tuple", "arr", "45", "50", "assert", "128", "128", "255", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "64", "64", "64", "tuple", "arr", "75", "50", "assert", "192", "192", "192", "tuple", "arr", "85", "50", "assert", "255", "255", "255", "tuple", "arr", "95", "50", "ybr", "convert_color_space", "arr", "rgb", "ybr_full", "assert", "76", "85", "255", "tuple", "ybr", "5", "50", "assert", "166", "107", "192", "tuple", "ybr", "15", "50", "assert", "150", "44", "21", "tuple", "ybr", "25", "50", "assert", "203", "86", "75", "tuple", "ybr", "35", "50", "assert", "29", "255", "107", "tuple", "ybr", "45", "50", "assert", "142", "192", "118", "tuple", "ybr", "55", "50", "assert", "0", "128", "128", "tuple", "ybr", "65", "50", "assert", "64", "128", "128", "tuple", "ybr", "75", "50", "assert", "192", "128", "128", "tuple", "ybr", "85", "50", "assert", "255", "128", "128", "tuple", "ybr", "95", "50", "round", "trip", "rounding", "errors", "get", "compounded", "rgb", "convert_color_space", "ybr", "ybr_full", "rgb", "assert", "254", "0", "0", "tuple", "rgb", "5", "50", "assert", "255", "128", "129", "tuple", "rgb", "15", "50", "assert", "0", "255", "1", "tuple", "rgb", "25", "50", "assert", "129", "255", "129", "tuple", "rgb", "35", "50", "assert", "0", "0", "254", "tuple", "rgb", "45", "50", "assert", "128", "127", "255", "tuple", "rgb", "55", "50", "assert", "0", "0", "0", "tuple", "rgb", "65", "50", "assert", "64", "64", "64", "tuple", "rgb", "75", "50", "assert", "192", "192", "192", "tuple", "rgb", "85", "50", "assert", "255", "255", "255", "tuple", "rgb", "95", "50"], "doc_len": 279}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_ConvertColourSpace.test_rgb_ybr_rgb_multi_frame", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_ConvertColourSpace", "func_name": "test_rgb_ybr_rgb_multi_frame", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_ConvertColourSpace\n    def test_rgb_ybr_rgb_multi_frame(self):\n        \"\"\"Test round trip conversion of multi-framed pixel data.\"\"\"\n        ds = dcmread(RGB_8_3_2F)\n\n        arr = ds.pixel_array\n        assert (255, 0, 0) == tuple(arr[0, 5, 50, :])\n        assert (255, 128, 128) == tuple(arr[0, 15, 50, :])\n        assert (0, 255, 0) == tuple(arr[0, 25, 50, :])\n        assert (128, 255, 128) == tuple(arr[0, 35, 50, :])\n        assert (0, 0, 255) == tuple(arr[0, 45, 50, :])\n        assert (128, 128, 255) == tuple(arr[0, 55, 50, :])\n        assert (0, 0, 0) == tuple(arr[0, 65, 50, :])\n        assert (64, 64, 64) == tuple(arr[0, 75, 50, :])\n        assert (192, 192, 192) == tuple(arr[0, 85, 50, :])\n        assert (255, 255, 255) == tuple(arr[0, 95, 50, :])\n        # Frame 2 is frame 1 inverted\n        assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n\n        ybr = convert_color_space(arr, 'RGB', 'YBR_FULL')\n        assert (76, 85, 255) == tuple(ybr[0, 5, 50, :])\n        assert (166, 107, 192) == tuple(ybr[0, 15, 50, :])\n        assert (150, 44, 21) == tuple(ybr[0, 25, 50, :])\n        assert (203, 86, 75) == tuple(ybr[0, 35, 50, :])\n        assert (29, 255, 107) == tuple(ybr[0, 45, 50, :])\n        assert (142, 192, 118) == tuple(ybr[0, 55, 50, :])\n        assert (0, 128, 128) == tuple(ybr[0, 65, 50, :])\n        assert (64, 128, 128) == tuple(ybr[0, 75, 50, :])\n        assert (192, 128, 128) == tuple(ybr[0, 85, 50, :])\n        assert (255, 128, 128) == tuple(ybr[0, 95, 50, :])\n        # Frame 2\n        assert (179, 171, 1) == tuple(ybr[1, 5, 50, :])\n        assert (89, 149, 65) == tuple(ybr[1, 15, 50, :])\n        assert (105, 212, 235) == tuple(ybr[1, 25, 50, :])\n        assert (52, 170, 181) == tuple(ybr[1, 35, 50, :])\n        assert (226, 1, 149) == tuple(ybr[1, 45, 50, :])\n        assert (113, 65, 138) == tuple(ybr[1, 55, 50, :])\n        assert (255, 128, 128) == tuple(ybr[1, 65, 50, :])\n        assert (191, 128, 128) == tuple(ybr[1, 75, 50, :])\n        assert (63, 128, 128) == tuple(ybr[1, 85, 50, :])\n        assert (0, 128, 128) == tuple(ybr[1, 95, 50, :])\n\n        # Round trip -> rounding errors get compounded\n        rgb = convert_color_space(ybr, 'YBR_FULL', 'RGB')\n        assert (254, 0, 0) == tuple(rgb[0, 5, 50, :])\n        assert (255, 128, 129) == tuple(rgb[0, 15, 50, :])\n        assert (0, 255, 1) == tuple(rgb[0, 25, 50, :])\n        assert (129, 255, 129) == tuple(rgb[0, 35, 50, :])\n        assert (0, 0, 254) == tuple(rgb[0, 45, 50, :])\n        assert (128, 127, 255) == tuple(rgb[0, 55, 50, :])\n        assert (0, 0, 0) == tuple(rgb[0, 65, 50, :])\n        assert (64, 64, 64) == tuple(rgb[0, 75, 50, :])\n        assert (192, 192, 192) == tuple(rgb[0, 85, 50, :])\n        assert (255, 255, 255) == tuple(rgb[0, 95, 50, :])\n        # Frame 2\n        assert (1, 255, 255) == tuple(rgb[1, 5, 50, :])\n        assert (1, 127, 126) == tuple(rgb[1, 15, 50, :])\n        assert (255, 0, 254) == tuple(rgb[1, 25, 50, :])\n        assert (126, 0, 126) == tuple(rgb[1, 35, 50, :])\n        assert (255, 255, 1) == tuple(rgb[1, 45, 50, :])\n        assert (127, 128, 1) == tuple(rgb[1, 55, 50, :])\n        assert (255, 255, 255) == tuple(rgb[1, 65, 50, :])\n        assert (191, 191, 191) == tuple(rgb[1, 75, 50, :])\n        assert (63, 63, 63) == tuple(rgb[1, 85, 50, :])\n        assert (0, 0, 0) == tuple(rgb[1, 95, 50, :])\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_convertcolourspace", "def", "test_rgb_ybr_rgb_multi_frame", "self", "test", "round", "trip", "conversion", "of", "multi", "framed", "pixel", "data", "ds", "dcmread", "rgb_8_3_2f", "arr", "ds", "pixel_array", "assert", "255", "0", "0", "tuple", "arr", "0", "5", "50", "assert", "255", "128", "128", "tuple", "arr", "0", "15", "50", "assert", "0", "255", "0", "tuple", "arr", "0", "25", "50", "assert", "128", "255", "128", "tuple", "arr", "0", "35", "50", "assert", "0", "0", "255", "tuple", "arr", "0", "45", "50", "assert", "128", "128", "255", "tuple", "arr", "0", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "0", "65", "50", "assert", "64", "64", "64", "tuple", "arr", "0", "75", "50", "assert", "192", "192", "192", "tuple", "arr", "0", "85", "50", "assert", "255", "255", "255", "tuple", "arr", "0", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0", "ybr", "convert_color_space", "arr", "rgb", "ybr_full", "assert", "76", "85", "255", "tuple", "ybr", "0", "5", "50", "assert", "166", "107", "192", "tuple", "ybr", "0", "15", "50", "assert", "150", "44", "21", "tuple", "ybr", "0", "25", "50", "assert", "203", "86", "75", "tuple", "ybr", "0", "35", "50", "assert", "29", "255", "107", "tuple", "ybr", "0", "45", "50", "assert", "142", "192", "118", "tuple", "ybr", "0", "55", "50", "assert", "0", "128", "128", "tuple", "ybr", "0", "65", "50", "assert", "64", "128", "128", "tuple", "ybr", "0", "75", "50", "assert", "192", "128", "128", "tuple", "ybr", "0", "85", "50", "assert", "255", "128", "128", "tuple", "ybr", "0", "95", "50", "frame", "2", "assert", "179", "171", "1", "tuple", "ybr", "1", "5", "50", "assert", "89", "149", "65", "tuple", "ybr", "1", "15", "50", "assert", "105", "212", "235", "tuple", "ybr", "1", "25", "50", "assert", "52", "170", "181", "tuple", "ybr", "1", "35", "50", "assert", "226", "1", "149", "tuple", "ybr", "1", "45", "50", "assert", "113", "65", "138", "tuple", "ybr", "1", "55", "50", "assert", "255", "128", "128", "tuple", "ybr", "1", "65", "50", "assert", "191", "128", "128", "tuple", "ybr", "1", "75", "50", "assert", "63", "128", "128", "tuple", "ybr", "1", "85", "50", "assert", "0", "128", "128", "tuple", "ybr", "1", "95", "50", "round", "trip", "rounding", "errors", "get", "compounded", "rgb", "convert_color_space", "ybr", "ybr_full", "rgb", "assert", "254", "0", "0", "tuple", "rgb", "0", "5", "50", "assert", "255", "128", "129", "tuple", "rgb", "0", "15", "50", "assert", "0", "255", "1", "tuple", "rgb", "0", "25", "50", "assert", "129", "255", "129", "tuple", "rgb", "0", "35", "50", "assert", "0", "0", "254", "tuple", "rgb", "0", "45", "50", "assert", "128", "127", "255", "tuple", "rgb", "0", "55", "50", "assert", "0", "0", "0", "tuple", "rgb", "0", "65", "50", "assert", "64", "64", "64", "tuple", "rgb", "0", "75", "50", "assert", "192", "192", "192", "tuple", "rgb", "0", "85", "50", "assert", "255", "255", "255", "tuple", "rgb", "0", "95", "50", "frame", "2", "assert", "1", "255", "255", "tuple", "rgb", "1", "5", "50", "assert", "1", "127", "126", "tuple", "rgb", "1", "15", "50", "assert", "255", "0", "254", "tuple", "rgb", "1", "25", "50", "assert", "126", "0", "126", "tuple", "rgb", "1", "35", "50", "assert", "255", "255", "1", "tuple", "rgb", "1", "45", "50", "assert", "127", "128", "1", "tuple", "rgb", "1", "55", "50", "assert", "255", "255", "255", "tuple", "rgb", "1", "65", "50", "assert", "191", "191", "191", "tuple", "rgb", "1", "75", "50", "assert", "63", "63", "63", "tuple", "rgb", "1", "85", "50", "assert", "0", "0", "0", "tuple", "rgb", "1", "95", "50"], "doc_len": 510}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_DtypeCorrectedForEndianness.test_byte_swapping", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_DtypeCorrectedForEndianness", "func_name": "test_byte_swapping", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_DtypeCorrectedForEndianness\n    def test_byte_swapping(self):\n        \"\"\"Test that the endianess of the system is taken into account.\"\"\"\n        # The main problem is that our testing environments are probably\n        #   all little endian, but we'll try our best\n        dtype = np.dtype('uint16')\n\n        # < is little, = is native, > is big\n        if byteorder == 'little':\n            out = dtype_corrected_for_endianness(True, dtype)\n            assert out.byteorder in ['<', '=']\n            out = dtype_corrected_for_endianness(False, dtype)\n            assert out.byteorder == '>'\n        elif byteorder == 'big':\n            out = dtype_corrected_for_endianness(True, dtype)\n            assert out.byteorder == '<'\n            out = dtype_corrected_for_endianness(False, dtype)\n            assert out.byteorder in ['>', '=']\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_dtypecorrectedforendianness", "def", "test_byte_swapping", "self", "test", "that", "the", "endianess", "of", "the", "system", "is", "taken", "into", "account", "the", "main", "problem", "is", "that", "our", "testing", "environments", "are", "probably", "all", "little", "endian", "but", "we", "ll", "try", "our", "best", "dtype", "np", "dtype", "uint16", "is", "little", "is", "native", "is", "big", "if", "byteorder", "little", "out", "dtype_corrected_for_endianness", "true", "dtype", "assert", "out", "byteorder", "in", "out", "dtype_corrected_for_endianness", "false", "dtype", "assert", "out", "byteorder", "elif", "byteorder", "big", "out", "dtype_corrected_for_endianness", "true", "dtype", "assert", "out", "byteorder", "out", "dtype_corrected_for_endianness", "false", "dtype", "assert", "out", "byteorder", "in"], "doc_len": 84}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_DtypeCorrectedForEndianness.test_no_endian_raises", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_DtypeCorrectedForEndianness", "func_name": "test_no_endian_raises", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_DtypeCorrectedForEndianness\n    def test_no_endian_raises(self):\n        \"\"\"Test that an unset endianness raises exception.\"\"\"\n        with pytest.raises(ValueError,\n                           match=\"attribute 'is_little_endian' has\"):\n            dtype_corrected_for_endianness(None, None)\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_dtypecorrectedforendianness", "def", "test_no_endian_raises", "self", "test", "that", "an", "unset", "endianness", "raises", "exception", "with", "pytest", "raises", "valueerror", "match", "attribute", "is_little_endian", "has", "dtype_corrected_for_endianness", "none", "none"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_GetExpectedLength.test_length_in_bytes", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_GetExpectedLength", "func_name": "test_length_in_bytes", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_GetExpectedLength\n    def test_length_in_bytes(self, shape, bits, length):\n        \"\"\"Test get_expected_length(ds, unit='bytes').\"\"\"\n        ds = Dataset()\n        ds.Rows = shape[1]\n        ds.Columns = shape[2]\n        ds.BitsAllocated = bits\n        if shape[0] != 0:\n            ds.NumberOfFrames = shape[0]\n        ds.SamplesPerPixel = shape[3]\n\n        assert length[0] == get_expected_length(ds, unit='bytes')\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_getexpectedlength", "def", "test_length_in_bytes", "self", "shape", "bits", "length", "test", "get_expected_length", "ds", "unit", "bytes", "ds", "dataset", "ds", "rows", "shape", "1", "ds", "columns", "shape", "2", "ds", "bitsallocated", "bits", "if", "shape", "0", "0", "ds", "numberofframes", "shape", "0", "ds", "samplesperpixel", "shape", "3", "assert", "length", "0", "get_expected_length", "ds", "unit", "bytes"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_handler_util.py::TestNumpy_GetExpectedLength.test_length_in_pixels", "file_path": "pydicom/tests/test_handler_util.py", "class_name": "TestNumpy_GetExpectedLength", "func_name": "test_length_in_pixels", "text": "文件路径: pydicom/tests/test_handler_util.py, 类名: TestNumpy_GetExpectedLength\n    def test_length_in_pixels(self, shape, bits, length):\n        \"\"\"Test get_expected_length(ds, unit='pixels').\"\"\"\n        ds = Dataset()\n        ds.Rows = shape[1]\n        ds.Columns = shape[2]\n        ds.BitsAllocated = bits\n        if shape[0] != 0:\n            ds.NumberOfFrames = shape[0]\n        ds.SamplesPerPixel = shape[3]\n\n        assert length[1] == get_expected_length(ds, unit='pixels')\n", "tokens": ["pydicom", "tests", "test_handler_util", "py", "testnumpy_getexpectedlength", "def", "test_length_in_pixels", "self", "shape", "bits", "length", "test", "get_expected_length", "ds", "unit", "pixels", "ds", "dataset", "ds", "rows", "shape", "1", "ds", "columns", "shape", "2", "ds", "bitsallocated", "bits", "if", "shape", "0", "0", "ds", "numberofframes", "shape", "0", "ds", "samplesperpixel", "shape", "3", "assert", "length", "1", "get_expected_length", "ds", "unit", "pixels"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_no_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_no_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_no_jpeg_ls\n    def setup(self):\n        self.jpeg_ls_lossless = dcmread(jpeg_ls_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_no_jpeg_ls", "def", "setup", "self", "self", "jpeg_ls_lossless", "dcmread", "jpeg_ls_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_no_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_no_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_no_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_no_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_no_jpeg_ls.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_no_jpeg_ls", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_no_jpeg_ls\n    def test_JPEG_LS_PixelArray(self):\n        with pytest.raises((RuntimeError, NotImplementedError)):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_no_jpeg_ls", "def", "test_jpeg_ls_pixelarray", "self", "with", "pytest", "raises", "runtimeerror", "notimplementederror", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_no_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_no_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_no_jpeg_ls\n    def setup(self):\n        self.jpeg_2k = dcmread(jpeg2000_name)\n        self.jpeg_2k_lossless = dcmread(jpeg2000_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_2k_lossless = dcmread(emri_jpeg_2k_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_no_jpeg_ls", "def", "setup", "self", "self", "jpeg_2k", "dcmread", "jpeg2000_name", "self", "jpeg_2k_lossless", "dcmread", "jpeg2000_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_2k_lossless", "dcmread", "emri_jpeg_2k_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_no_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_no_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_no_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_no_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_no_jpeg_ls.test_JPEG2000PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_no_jpeg_ls", "func_name": "test_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_no_jpeg_ls\n    def test_JPEG2000PixelArray(self):\n        \"\"\"JPEG2000: Now works\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_2k.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_no_jpeg_ls", "def", "test_jpeg2000pixelarray", "self", "jpeg2000", "now", "works", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_2k", "pixel_array"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_no_jpeg_ls.test_emri_JPEG2000PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_no_jpeg_ls", "func_name": "test_emri_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_no_jpeg_ls\n    def test_emri_JPEG2000PixelArray(self):\n        \"\"\"JPEG2000: Now works\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_no_jpeg_ls", "def", "test_emri_jpeg2000pixelarray", "self", "jpeg2000", "now", "works", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_2k_lossless", "pixel_array"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_no_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_no_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_no_jpeg_ls\n    def setup(self):\n        self.jpeg_lossy = dcmread(jpeg_lossy_name)\n        self.color_3d_jpeg = dcmread(color_3d_jpeg_baseline)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_no_jpeg_ls", "def", "setup", "self", "self", "jpeg_lossy", "dcmread", "jpeg_lossy_name", "self", "color_3d_jpeg", "dcmread", "color_3d_jpeg_baseline", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_no_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_no_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_no_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_no_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_no_jpeg_ls.testJPEGlossy", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_no_jpeg_ls", "func_name": "testJPEGlossy", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_no_jpeg_ls\n    def testJPEGlossy(self):\n        \"\"\"JPEG-lossy: Returns correct values for sample data elements\"\"\"\n        got = self.jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_no_jpeg_ls", "def", "testjpeglossy", "self", "jpeg", "lossy", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_no_jpeg_ls.testJPEGlossyPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_no_jpeg_ls", "func_name": "testJPEGlossyPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_no_jpeg_ls\n    def testJPEGlossyPixelArray(self):\n        \"\"\"JPEG-lossy: Fails gracefully when uncompressed data is asked for\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossy.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_no_jpeg_ls", "def", "testjpeglossypixelarray", "self", "jpeg", "lossy", "fails", "gracefully", "when", "uncompressed", "data", "is", "asked", "for", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossy", "pixel_array"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_no_jpeg_ls.testJPEGBaselineColor3DPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_no_jpeg_ls", "func_name": "testJPEGBaselineColor3DPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_no_jpeg_ls\n    def testJPEGBaselineColor3DPixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.color_3d_jpeg.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_no_jpeg_ls", "def", "testjpegbaselinecolor3dpixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "color_3d_jpeg", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_no_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_no_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_no_jpeg_ls\n    def setup(self):\n        self.jpeg_lossless = dcmread(jpeg_lossless_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_no_jpeg_ls", "def", "setup", "self", "self", "jpeg_lossless", "dcmread", "jpeg_lossless_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_no_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_no_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_no_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_no_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_no_jpeg_ls.testJPEGlossless", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_no_jpeg_ls", "func_name": "testJPEGlossless", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_no_jpeg_ls\n    def testJPEGlossless(self):\n        \"\"\"JPEGlossless: Returns correct values for sample data elements\"\"\"\n        got = self.\\\n            jpeg_lossless.\\\n            SourceImageSequence[0].\\\n            PurposeOfReferenceCodeSequence[0].CodeMeaning\n        assert 'Uncompressed predecessor' == got\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_no_jpeg_ls", "def", "testjpeglossless", "self", "jpeglossless", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossless", "sourceimagesequence", "0", "purposeofreferencecodesequence", "0", "codemeaning", "assert", "uncompressed", "predecessor", "got"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_no_jpeg_ls.testJPEGlosslessPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_no_jpeg_ls", "func_name": "testJPEGlosslessPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_no_jpeg_ls\n    def testJPEGlosslessPixelArray(self):\n        \"\"\"JPEGlossless: Fails gracefully when uncompressed data asked for\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_no_jpeg_ls", "def", "testjpeglosslesspixelarray", "self", "jpeglossless", "fails", "gracefully", "when", "uncompressed", "data", "asked", "for", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG_LS_with_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG_LS_with_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG_LS_with_jpeg_ls\n    def setup(self):\n        self.jpeg_ls_lossless = dcmread(jpeg_ls_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [jpeg_ls_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg_ls_with_jpeg_ls", "def", "setup", "self", "self", "jpeg_ls_lossless", "dcmread", "jpeg_ls_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "jpeg_ls_handler", "numpy_handler"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG_LS_with_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG_LS_with_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG_LS_with_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg_ls_with_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG_LS_with_jpeg_ls.test_raises_if_endianess_not_set", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG_LS_with_jpeg_ls", "func_name": "test_raises_if_endianess_not_set", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG_LS_with_jpeg_ls\n    def test_raises_if_endianess_not_set(self):\n        self.jpeg_ls_lossless.is_little_endian = None\n        with pytest.raises(ValueError):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg_ls_with_jpeg_ls", "def", "test_raises_if_endianess_not_set", "self", "self", "jpeg_ls_lossless", "is_little_endian", "none", "with", "pytest", "raises", "valueerror", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG_LS_with_jpeg_ls.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG_LS_with_jpeg_ls", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG_LS_with_jpeg_ls\n    def test_JPEG_LS_PixelArray(self):\n        a = self.jpeg_ls_lossless.pixel_array\n        b = self.mr_small.pixel_array\n        assert b.mean() == a.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg_ls_with_jpeg_ls", "def", "test_jpeg_ls_pixelarray", "self", "a", "self", "jpeg_ls_lossless", "pixel_array", "b", "self", "mr_small", "pixel_array", "assert", "b", "mean", "a", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG_LS_with_jpeg_ls.test_emri_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG_LS_with_jpeg_ls", "func_name": "test_emri_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG_LS_with_jpeg_ls\n    def test_emri_JPEG_LS_PixelArray(self):\n        a = self.emri_jpeg_ls_lossless.pixel_array\n        b = self.emri_small.pixel_array\n        assert b.mean() == a.mean()\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg_ls_with_jpeg_ls", "def", "test_emri_jpeg_ls_pixelarray", "self", "a", "self", "emri_jpeg_ls_lossless", "pixel_array", "b", "self", "emri_small", "pixel_array", "assert", "b", "mean", "a", "mean", "assert", "a", "flags", "writeable"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_with_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_with_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_with_jpeg_ls\n    def setup(self):\n        self.jpeg_2k = dcmread(jpeg2000_name)\n        self.jpeg_2k_lossless = dcmread(jpeg2000_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_2k_lossless = dcmread(emri_jpeg_2k_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [jpeg_ls_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_with_jpeg_ls", "def", "setup", "self", "self", "jpeg_2k", "dcmread", "jpeg2000_name", "self", "jpeg_2k_lossless", "dcmread", "jpeg2000_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_2k_lossless", "dcmread", "emri_jpeg_2k_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "jpeg_ls_handler", "numpy_handler"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_with_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_with_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_with_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_with_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_with_jpeg_ls.test_JPEG2000PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_with_jpeg_ls", "func_name": "test_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_with_jpeg_ls\n    def test_JPEG2000PixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.jpeg_2k.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_with_jpeg_ls", "def", "test_jpeg2000pixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_2k", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEG2000_with_jpeg_ls.test_emri_JPEG2000PixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEG2000_with_jpeg_ls", "func_name": "test_emri_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEG2000_with_jpeg_ls\n    def test_emri_JPEG2000PixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeg2000_with_jpeg_ls", "def", "test_emri_jpeg2000pixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_2k_lossless", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_with_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_with_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_with_jpeg_ls\n    def setup(self):\n        self.jpeg_lossy = dcmread(jpeg_lossy_name)\n        self.color_3d_jpeg = dcmread(color_3d_jpeg_baseline)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [jpeg_ls_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_with_jpeg_ls", "def", "setup", "self", "self", "jpeg_lossy", "dcmread", "jpeg_lossy_name", "self", "color_3d_jpeg", "dcmread", "color_3d_jpeg_baseline", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "jpeg_ls_handler", "numpy_handler"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_with_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_with_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_with_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_with_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_with_jpeg_ls.testJPEGlossy", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_with_jpeg_ls", "func_name": "testJPEGlossy", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_with_jpeg_ls\n    def testJPEGlossy(self):\n        \"\"\"JPEG-lossy: Returns correct values for sample data elements\"\"\"\n        got = self.jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_with_jpeg_ls", "def", "testjpeglossy", "self", "jpeg", "lossy", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_with_jpeg_ls.testJPEGlossyPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_with_jpeg_ls", "func_name": "testJPEGlossyPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_with_jpeg_ls\n    def testJPEGlossyPixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossy.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_with_jpeg_ls", "def", "testjpeglossypixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossy", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossy_with_jpeg_ls.testJPEGBaselineColor3DPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossy_with_jpeg_ls", "func_name": "testJPEGBaselineColor3DPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossy_with_jpeg_ls\n    def testJPEGBaselineColor3DPixelArray(self):\n        with pytest.raises(NotImplementedError):\n            self.color_3d_jpeg.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossy_with_jpeg_ls", "def", "testjpegbaselinecolor3dpixelarray", "self", "with", "pytest", "raises", "notimplementederror", "self", "color_3d_jpeg", "pixel_array"], "doc_len": 15}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_with_jpeg_ls.setup", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_with_jpeg_ls", "func_name": "setup", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_with_jpeg_ls\n    def setup(self):\n        self.jpeg_lossless = dcmread(jpeg_lossless_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [jpeg_ls_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_with_jpeg_ls", "def", "setup", "self", "self", "jpeg_lossless", "dcmread", "jpeg_lossless_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "jpeg_ls_handler", "numpy_handler"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_with_jpeg_ls.teardown", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_with_jpeg_ls", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_with_jpeg_ls\n    def teardown(self):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_with_jpeg_ls", "def", "teardown", "self", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_with_jpeg_ls.testJPEGlossless", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_with_jpeg_ls", "func_name": "testJPEGlossless", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_with_jpeg_ls\n    def testJPEGlossless(self):\n        \"\"\"JPEGlossless: Returns correct values for sample data elements\"\"\"\n        got = self.\\\n            jpeg_lossless.\\\n            SourceImageSequence[0].\\\n            PurposeOfReferenceCodeSequence[0].CodeMeaning\n        assert 'Uncompressed predecessor' == got\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_with_jpeg_ls", "def", "testjpeglossless", "self", "jpeglossless", "returns", "correct", "values", "for", "sample", "data", "elements", "got", "self", "jpeg_lossless", "sourceimagesequence", "0", "purposeofreferencecodesequence", "0", "codemeaning", "assert", "uncompressed", "predecessor", "got"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_jpeg_ls_pixel_data.py::TestJPEGLS_JPEGlossless_with_jpeg_ls.testJPEGlosslessPixelArray", "file_path": "pydicom/tests/test_jpeg_ls_pixel_data.py", "class_name": "TestJPEGLS_JPEGlossless_with_jpeg_ls", "func_name": "testJPEGlosslessPixelArray", "text": "文件路径: pydicom/tests/test_jpeg_ls_pixel_data.py, 类名: TestJPEGLS_JPEGlossless_with_jpeg_ls\n    def testJPEGlosslessPixelArray(self):\n        \"\"\"JPEGlossless: Fails gracefully when uncompressed data asked for\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_pixel_data", "py", "testjpegls_jpeglossless_with_jpeg_ls", "def", "testjpeglosslesspixelarray", "self", "jpeglossless", "fails", "gracefully", "when", "uncompressed", "data", "asked", "for", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.setup_method", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "setup_method", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def setup_method(self, method):\n        self.jpeg_ls_lossless = dcmread(jpeg_ls_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "setup_method", "self", "method", "self", "jpeg_ls_lossless", "dcmread", "jpeg_ls_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.teardown_method", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "teardown_method", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def teardown_method(self, method):\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "teardown_method", "self", "method", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 14}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_mr_with_numpy", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_mr_with_numpy", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_mr_with_numpy(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_mr_with_numpy", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_emri_with_numpy", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_emri_with_numpy", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_emri_with_numpy(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_emri_with_numpy", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_mr_with_pillow", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_mr_with_pillow", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_mr_with_pillow(self):\n        pydicom.config.pixel_data_handlers = [pillow_handler]\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_mr_with_pillow", "self", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_emri_with_pillow", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_emri_with_pillow", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_emri_with_pillow(self):\n        pydicom.config.pixel_data_handlers = [pillow_handler]\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_emri_with_pillow", "self", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_mr_with_gdcm", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_mr_with_gdcm", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_mr_with_gdcm(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler, gdcm_handler]\n        a = self.jpeg_ls_lossless.pixel_array\n        b = self.mr_small.pixel_array\n        assert a.mean() == b.mean(), \\\n            \"using GDCM Decoded pixel data is not \" \\\n            \"all {0} (mean == {1})\".format(b.mean(), a.mean())\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_mr_with_gdcm", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "gdcm_handler", "a", "self", "jpeg_ls_lossless", "pixel_array", "b", "self", "mr_small", "pixel_array", "assert", "a", "mean", "b", "mean", "using", "gdcm", "decoded", "pixel", "data", "is", "not", "all", "0", "mean", "1", "format", "b", "mean", "a", "mean"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_emri_with_gdcm", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_emri_with_gdcm", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_emri_with_gdcm(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler, gdcm_handler]\n        a = self.emri_jpeg_ls_lossless.pixel_array\n        b = self.emri_small.pixel_array\n        assert a.mean() == b.mean(), \\\n            \"using GDCM Decoded pixel data is not \" \\\n            \"all {0} (mean == {1})\".format(b.mean(), a.mean())\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_emri_with_gdcm", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "gdcm_handler", "a", "self", "emri_jpeg_ls_lossless", "pixel_array", "b", "self", "emri_small", "pixel_array", "assert", "a", "mean", "b", "mean", "using", "gdcm", "decoded", "pixel", "data", "is", "not", "all", "0", "mean", "1", "format", "b", "mean", "a", "mean"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_mr_with_jpeg_ls", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_mr_with_jpeg_ls", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_mr_with_jpeg_ls(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler, jpeg_ls_handler]\n        a = self.jpeg_ls_lossless.pixel_array\n        b = self.mr_small.pixel_array\n        assert a.mean() == b.mean(), \\\n            \"using jpeg_ls decoded pixel data is not \" \\\n            \"all {0} (mean == {1})\".format(b.mean(), a.mean())\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_mr_with_jpeg_ls", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "jpeg_ls_handler", "a", "self", "jpeg_ls_lossless", "pixel_array", "b", "self", "mr_small", "pixel_array", "assert", "a", "mean", "b", "mean", "using", "jpeg_ls", "decoded", "pixel", "data", "is", "not", "all", "0", "mean", "1", "format", "b", "mean", "a", "mean"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_emri_with_jpeg_ls", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_emri_with_jpeg_ls", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_emri_with_jpeg_ls(self):\n        pydicom.config.pixel_data_handlers = [numpy_handler, jpeg_ls_handler]\n        a = self.emri_jpeg_ls_lossless.pixel_array\n        b = self.emri_small.pixel_array\n        assert a.mean() == b.mean(), \\\n            \"using jpeg_ls decoded pixel data is not all {0} \" \\\n            \"(mean == {1})\".format(b.mean(), a.mean())\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_emri_with_jpeg_ls", "self", "pydicom", "config", "pixel_data_handlers", "numpy_handler", "jpeg_ls_handler", "a", "self", "emri_jpeg_ls_lossless", "pixel_array", "b", "self", "emri_small", "pixel_array", "assert", "a", "mean", "b", "mean", "using", "jpeg_ls", "decoded", "pixel", "data", "is", "not", "all", "0", "mean", "1", "format", "b", "mean", "a", "mean"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_mr_without_any_handler", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_mr_without_any_handler", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_mr_without_any_handler(self):\n        pydicom.config.pixel_data_handlers = []\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_mr_without_any_handler", "self", "pydicom", "config", "pixel_data_handlers", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_JPEG_LS_transfer_syntax.py::Test_JPEG_LS_Lossless_transfer_syntax.test_read_emri_without_any_handler", "file_path": "pydicom/tests/test_JPEG_LS_transfer_syntax.py", "class_name": "Test_JPEG_LS_Lossless_transfer_syntax", "func_name": "test_read_emri_without_any_handler", "text": "文件路径: pydicom/tests/test_JPEG_LS_transfer_syntax.py, 类名: Test_JPEG_LS_Lossless_transfer_syntax\n    def test_read_emri_without_any_handler(self):\n        pydicom.config.pixel_data_handlers = []\n        msg = (\n            r\"Unable to decode pixel data with a transfer syntax UID of \"\n            r\"'1.2.840.10008.1.2.4.80' \\(JPEG-LS Lossless Image Compression\\) \"\n            r\"as there are no pixel data handlers available.\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_jpeg_ls_transfer_syntax", "py", "test_jpeg_ls_lossless_transfer_syntax", "def", "test_read_emri_without_any_handler", "self", "pydicom", "config", "pixel_data_handlers", "msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "1", "2", "840", "10008", "1", "2", "4", "80", "jpeg", "ls", "lossless", "image", "compression", "r", "as", "there", "are", "no", "pixel", "data", "handlers", "available", "with", "pytest", "raises", "notimplementederror", "match", "msg", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_json.py::test_json_PN", "file_path": "pydicom/tests/test_json.py", "class_name": null, "func_name": "test_json_PN", "text": "文件路径: pydicom/tests/test_json.py\ndef test_json_PN():\n    s = open(get_testdata_files(\"test_PN.json\")[0], \"r\").read()\n    ds = Dataset.from_json(s)\n    assert isinstance(ds[0x00080090].value,\n                      (PersonNameUnicode, PersonName3))\n    assert isinstance(ds[0x00100010].value,\n                      (PersonNameUnicode, PersonName3))\n    inner_seq = ds[0x04000561].value[0][0x04000550]\n    dataelem = inner_seq[0][0x00100010]\n    assert isinstance(dataelem.value, (PersonNameUnicode, PersonName3))\n", "tokens": ["pydicom", "tests", "test_json", "py", "def", "test_json_pn", "s", "open", "get_testdata_files", "test_pn", "json", "0", "r", "read", "ds", "dataset", "from_json", "s", "assert", "isinstance", "ds", "0x00080090", "value", "personnameunicode", "personname3", "assert", "isinstance", "ds", "0x00100010", "value", "personnameunicode", "personname3", "inner_seq", "ds", "0x04000561", "value", "0", "0x04000550", "dataelem", "inner_seq", "0", "0x00100010", "assert", "isinstance", "dataelem", "value", "personnameunicode", "personname3"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_json.py::test_dataelem_from_json", "file_path": "pydicom/tests/test_json.py", "class_name": null, "func_name": "test_dataelem_from_json", "text": "文件路径: pydicom/tests/test_json.py\ndef test_dataelem_from_json():\n    tag = 0x0080090\n    vr = \"PN\"\n    value = [{\"Alphabetic\": \"\"}]\n    dataelem = DataElement.from_json(Dataset, tag, vr, value, \"Value\")\n    assert isinstance(dataelem.value, (PersonNameUnicode, PersonName3))\n", "tokens": ["pydicom", "tests", "test_json", "py", "def", "test_dataelem_from_json", "tag", "0x0080090", "vr", "pn", "value", "alphabetic", "dataelem", "dataelement", "from_json", "dataset", "tag", "vr", "value", "value", "assert", "isinstance", "dataelem", "value", "personnameunicode", "personname3"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_json.py::test_json_roundtrip", "file_path": "pydicom/tests/test_json.py", "class_name": null, "func_name": "test_json_roundtrip", "text": "文件路径: pydicom/tests/test_json.py\ndef test_json_roundtrip():\n    ds = Dataset()\n    ds.add_new(0x00080005, 'CS', 'ISO_IR 100')\n    ds.add_new(0x00090010, 'LO', 'Creator 1.0')\n    ds.add_new(0x00091001, 'SH', 'Version1')\n    ds.add_new(0x00091002, 'OB', b'BinaryContent')\n    ds.add_new(0x00091003, 'OW', b'\\x0102\\x3040\\x5060')\n    ds.add_new(0x00091004, 'OF', b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07')\n    ds.add_new(0x00091005, 'OD', b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                                 b'\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07')\n    ds.add_new(0x00091006, 'OL', b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07'\n                                 b'\\x01\\x01\\x02\\x03')\n    ds.add_new(0x00091007, 'UI', '1.2.3.4.5.6')\n    ds.add_new(0x00091008, 'DA', '20200101')\n    ds.add_new(0x00091009, 'TM', '115500')\n    ds.add_new(0x0009100a, 'DT', '20200101115500.000000')\n    ds.add_new(0x0009100b, 'UL', 3000000000)\n    ds.add_new(0x0009100c, 'SL', -2000000000)\n    ds.add_new(0x0009100d, 'US', 40000)\n    ds.add_new(0x0009100e, 'SS', -22222)\n    ds.add_new(0x0009100f, 'FL', 3.14)\n    ds.add_new(0x00091010, 'FD', 3.14159265)\n    ds.add_new(0x00091011, 'CS', 'TEST MODE')\n    ds.add_new(0x00091012, 'PN', 'CITIZEN^1')\n    ds.add_new(0x00091013, 'PN', u'Yamada^Tarou=山田^太郎=やまだ^たろう')\n    ds.add_new(0x00091014, 'IS', '42')\n    ds.add_new(0x00091015, 'DS', '3.14159265')\n    ds.add_new(0x00091016, 'AE', b'CONQUESTSRV1')\n    ds.add_new(0x00091017, 'AS', '055Y')\n    ds.add_new(0x00091018, 'LT', 50 * u'Калинка,')\n    ds.add_new(0x00091019, 'UC', 'LONG CODE VALUE')\n    ds.add_new(0x0009101a, 'UN', b'\\x0102\\x3040\\x5060')\n    ds.add_new(0x0009101b, 'UR', 'https://example.com')\n    ds.add_new(0x0009101c, 'AT', b'\\x10\\x00\\x20\\x00\\x10\\x00\\x30\\x00\\x10')\n    ds.add_new(0x0009101d, 'ST', 100 * u'علي بابا')\n    ds.add_new(0x0009101e, 'SH', u'Διονυσιος')\n    ds.add_new(0x00090011, 'LO', 'Creator 2.0')\n    ds.add_new(0x00091101, 'SH', 'Version2')\n    ds.add_new(0x00091102, 'US', 2)\n\n    jsonmodel = ds.to_json(bulk_data_threshold=100)\n    ds2 = Dataset.from_json(jsonmodel)\n\n    assert ds2.SpecificCharacterSet == ['ISO_IR 100']\n", "tokens": ["pydicom", "tests", "test_json", "py", "def", "test_json_roundtrip", "ds", "dataset", "ds", "add_new", "0x00080005", "cs", "iso_ir", "100", "ds", "add_new", "0x00090010", "lo", "creator", "1", "0", "ds", "add_new", "0x00091001", "sh", "version1", "ds", "add_new", "0x00091002", "ob", "b", "binarycontent", "ds", "add_new", "0x00091003", "ow", "b", "x0102", "x3040", "x5060", "ds", "add_new", "0x00091004", "of", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "ds", "add_new", "0x00091005", "od", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "ds", "add_new", "0x00091006", "ol", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "b", "x01", "x01", "x02", "x03", "ds", "add_new", "0x00091007", "ui", "1", "2", "3", "4", "5", "6", "ds", "add_new", "0x00091008", "da", "20200101", "ds", "add_new", "0x00091009", "tm", "115500", "ds", "add_new", "0x0009100a", "dt", "20200101115500", "000000", "ds", "add_new", "0x0009100b", "ul", "3000000000", "ds", "add_new", "0x0009100c", "sl", "2000000000", "ds", "add_new", "0x0009100d", "us", "40000", "ds", "add_new", "0x0009100e", "ss", "22222", "ds", "add_new", "0x0009100f", "fl", "3", "14", "ds", "add_new", "0x00091010", "fd", "3", "14159265", "ds", "add_new", "0x00091011", "cs", "test", "mode", "ds", "add_new", "0x00091012", "pn", "citizen", "1", "ds", "add_new", "0x00091013", "pn", "u", "yamada", "tarou", "ds", "add_new", "0x00091014", "is", "42", "ds", "add_new", "0x00091015", "ds", "3", "14159265", "ds", "add_new", "0x00091016", "ae", "b", "conquestsrv1", "ds", "add_new", "0x00091017", "as", "055y", "ds", "add_new", "0x00091018", "lt", "50", "u", "ds", "add_new", "0x00091019", "uc", "long", "code", "value", "ds", "add_new", "0x0009101a", "un", "b", "x0102", "x3040", "x5060", "ds", "add_new", "0x0009101b", "ur", "https", "example", "com", "ds", "add_new", "0x0009101c", "at", "b", "x10", "x00", "x20", "x00", "x10", "x00", "x30", "x00", "x10", "ds", "add_new", "0x0009101d", "st", "100", "u", "ds", "add_new", "0x0009101e", "sh", "u", "ds", "add_new", "0x00090011", "lo", "creator", "2", "0", "ds", "add_new", "0x00091101", "sh", "version2", "ds", "add_new", "0x00091102", "us", "2", "jsonmodel", "ds", "to_json", "bulk_data_threshold", "100", "ds2", "dataset", "from_json", "jsonmodel", "assert", "ds2", "specificcharacterset", "iso_ir", "100"], "doc_len": 276}
{"doc_id": "pydicom/tests/test_json.py::test_json_private_DS_VM", "file_path": "pydicom/tests/test_json.py", "class_name": null, "func_name": "test_json_private_DS_VM", "text": "文件路径: pydicom/tests/test_json.py\ndef test_json_private_DS_VM():\n    test1_json = get_testdata_files(\"test1.json\")[0]\n    jsonmodel = open(test1_json, 'r').read()\n    ds = Dataset.from_json(jsonmodel)\n    import json\n    jsonmodel2 = ds.to_json(dump_handler=lambda d: json.dumps(d, indent=2))\n    ds2 = Dataset.from_json(jsonmodel2)\n\n    assert ds.PatientIdentityRemoved == 'YES'\n    assert ds2.PatientIdentityRemoved == 'YES'\n", "tokens": ["pydicom", "tests", "test_json", "py", "def", "test_json_private_ds_vm", "test1_json", "get_testdata_files", "test1", "json", "0", "jsonmodel", "open", "test1_json", "r", "read", "ds", "dataset", "from_json", "jsonmodel", "import", "json", "jsonmodel2", "ds", "to_json", "dump_handler", "lambda", "d", "json", "dumps", "d", "indent", "2", "ds2", "dataset", "from_json", "jsonmodel2", "assert", "ds", "patientidentityremoved", "yes", "assert", "ds2", "patientidentityremoved", "yes"], "doc_len": 45}
{"doc_id": "pydicom/tests/test_misc.py::TestMisc.test_is_dicom", "file_path": "pydicom/tests/test_misc.py", "class_name": "TestMisc", "func_name": "test_is_dicom", "text": "文件路径: pydicom/tests/test_misc.py, 类名: TestMisc\n    def test_is_dicom(self):\n        \"\"\"Test the is_dicom function.\"\"\"\n        invalid_file = test_file.replace('CT_', 'CT')  # invalid file\n        notdicom_file = os.path.abspath(__file__)  # use own file\n\n        # valid file returns True\n        assert is_dicom(test_file)\n\n        # return false for real file but not dicom\n        assert not is_dicom(notdicom_file)\n\n        # test invalid path\n        with pytest.raises(IOError):\n            is_dicom(invalid_file)\n\n        # Test no meta prefix/preamble fails\n        assert not is_dicom(no_meta_file)\n", "tokens": ["pydicom", "tests", "test_misc", "py", "testmisc", "def", "test_is_dicom", "self", "test", "the", "is_dicom", "function", "invalid_file", "test_file", "replace", "ct_", "ct", "invalid", "file", "notdicom_file", "os", "path", "abspath", "__file__", "use", "own", "file", "valid", "file", "returns", "true", "assert", "is_dicom", "test_file", "return", "false", "for", "real", "file", "but", "not", "dicom", "assert", "not", "is_dicom", "notdicom_file", "test", "invalid", "path", "with", "pytest", "raises", "ioerror", "is_dicom", "invalid_file", "test", "no", "meta", "prefix", "preamble", "fails", "assert", "not", "is_dicom", "no_meta_file"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_misc.py::TestMisc.test_size_in_bytes", "file_path": "pydicom/tests/test_misc.py", "class_name": "TestMisc", "func_name": "test_size_in_bytes", "text": "文件路径: pydicom/tests/test_misc.py, 类名: TestMisc\n    def test_size_in_bytes(self):\n        \"\"\"Test convenience function size_in_bytes().\"\"\"\n        # None or numbers shall be returned unchanged\n        assert size_in_bytes(None) is None\n        assert size_in_bytes(float('inf')) is None\n        assert size_in_bytes(1234) == 1234\n\n        # string shall be parsed\n        assert size_in_bytes('1234') == 1234\n        assert size_in_bytes('4 kb') == 4096\n        assert size_in_bytes('16 KB') == 0x4000\n        assert size_in_bytes('3  MB') == 0x300000\n        assert size_in_bytes('2gB') == 0x80000000\n\n        with pytest.raises(ValueError):\n            size_in_bytes('2 TB')\n        with pytest.raises(ValueError):\n            size_in_bytes('KB 2')\n", "tokens": ["pydicom", "tests", "test_misc", "py", "testmisc", "def", "test_size_in_bytes", "self", "test", "convenience", "function", "size_in_bytes", "none", "or", "numbers", "shall", "be", "returned", "unchanged", "assert", "size_in_bytes", "none", "is", "none", "assert", "size_in_bytes", "float", "inf", "is", "none", "assert", "size_in_bytes", "1234", "1234", "string", "shall", "be", "parsed", "assert", "size_in_bytes", "1234", "1234", "assert", "size_in_bytes", "4", "kb", "4096", "assert", "size_in_bytes", "16", "kb", "0x4000", "assert", "size_in_bytes", "3", "mb", "0x300000", "assert", "size_in_bytes", "2gb", "0x80000000", "with", "pytest", "raises", "valueerror", "size_in_bytes", "2", "tb", "with", "pytest", "raises", "valueerror", "size_in_bytes", "kb", "2"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testMultiDS", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testMultiDS", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testMultiDS(self):\n        \"\"\"MultiValue: Multi-valued data elements can be created........\"\"\"\n        multival = MultiValue(DS, ['11.1', '22.2', '33.3'])\n        for val in multival:\n            assert isinstance(val, (DSfloat, DSdecimal))\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testmultids", "self", "multivalue", "multi", "valued", "data", "elements", "can", "be", "created", "multival", "multivalue", "ds", "11", "1", "22", "2", "33", "3", "for", "val", "in", "multival", "assert", "isinstance", "val", "dsfloat", "dsdecimal"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testEmptyElements", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testEmptyElements", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testEmptyElements(self):\n        \"\"\"MultiValue: Empty number string elements are not converted...\"\"\"\n        multival = MultiValue(DSfloat, ['1.0', ''])\n        assert 1.0 == multival[0]\n        assert '' == multival[1]\n        multival = MultiValue(IS, ['1', ''])\n        assert 1 == multival[0]\n        assert '' == multival[1]\n        multival = MultiValue(DSdecimal, ['1', ''])\n        assert 1 == multival[0]\n        assert '' == multival[1]\n\n        multival = MultiValue(IS, [])\n        assert not multival\n        assert 0 == len(multival)\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testemptyelements", "self", "multivalue", "empty", "number", "string", "elements", "are", "not", "converted", "multival", "multivalue", "dsfloat", "1", "0", "assert", "1", "0", "multival", "0", "assert", "multival", "1", "multival", "multivalue", "is", "1", "assert", "1", "multival", "0", "assert", "multival", "1", "multival", "multivalue", "dsdecimal", "1", "assert", "1", "multival", "0", "assert", "multival", "1", "multival", "multivalue", "is", "assert", "not", "multival", "assert", "0", "len", "multival"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testLimits", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testLimits", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testLimits(self):\n        \"\"\"MultiValue: Raise error if any item outside DICOM limits....\"\"\"\n        original_flag = config.enforce_valid_values\n        config.enforce_valid_values = True\n        with pytest.raises(OverflowError):\n            MultiValue(IS, [1, -2 ** 31 - 1])\n        # Overflow error not raised for IS out of DICOM valid range\n        config.enforce_valid_values = original_flag\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testlimits", "self", "multivalue", "raise", "error", "if", "any", "item", "outside", "dicom", "limits", "original_flag", "config", "enforce_valid_values", "config", "enforce_valid_values", "true", "with", "pytest", "raises", "overflowerror", "multivalue", "is", "1", "2", "31", "1", "overflow", "error", "not", "raised", "for", "is", "out", "of", "dicom", "valid", "range", "config", "enforce_valid_values", "original_flag"], "doc_len": 47}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testAppend", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testAppend", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testAppend(self):\n        \"\"\"MultiValue: Append of item converts it to required type...\"\"\"\n        multival = MultiValue(IS, [1, 5, 10])\n        multival.append('5')\n        assert isinstance(multival[-1], IS)\n        assert 5 == multival[-1]\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testappend", "self", "multivalue", "append", "of", "item", "converts", "it", "to", "required", "type", "multival", "multivalue", "is", "1", "5", "10", "multival", "append", "5", "assert", "isinstance", "multival", "1", "is", "assert", "5", "multival", "1"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testSetIndex", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testSetIndex", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testSetIndex(self):\n        \"\"\"MultiValue: Setting list item converts it to required type\"\"\"\n        multival = MultiValue(IS, [1, 5, 10])\n        multival[1] = '7'\n        assert isinstance(multival[1], IS)\n        assert 7 == multival[1]\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testsetindex", "self", "multivalue", "setting", "list", "item", "converts", "it", "to", "required", "type", "multival", "multivalue", "is", "1", "5", "10", "multival", "1", "7", "assert", "isinstance", "multival", "1", "is", "assert", "7", "multival", "1"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testDeleteIndex", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testDeleteIndex", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testDeleteIndex(self):\n        \"\"\"MultiValue: Deleting item at index behaves as expected...\"\"\"\n        multival = MultiValue(IS, [1, 5, 10])\n        del multival[1]\n        assert 2 == len(multival)\n        assert 1 == multival[0]\n        assert 10 == multival[1]\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testdeleteindex", "self", "multivalue", "deleting", "item", "at", "index", "behaves", "as", "expected", "multival", "multivalue", "is", "1", "5", "10", "del", "multival", "1", "assert", "2", "len", "multival", "assert", "1", "multival", "0", "assert", "10", "multival", "1"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testExtend", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testExtend", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testExtend(self):\n        \"\"\"MultiValue: Extending a list converts all to required type\"\"\"\n        multival = MultiValue(IS, [1, 5, 10])\n        multival.extend(['7', 42])\n        assert isinstance(multival[-2], IS)\n        assert isinstance(multival[-1], IS)\n        assert 7 == multival[-2]\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testextend", "self", "multivalue", "extending", "a", "list", "converts", "all", "to", "required", "type", "multival", "multivalue", "is", "1", "5", "10", "multival", "extend", "7", "42", "assert", "isinstance", "multival", "2", "is", "assert", "isinstance", "multival", "1", "is", "assert", "7", "multival", "2"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testSlice", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testSlice", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testSlice(self):\n        \"\"\"MultiValue: Setting slice converts items to required type.\"\"\"\n        multival = MultiValue(IS, range(7))\n        multival[2:7:2] = [4, 16, 36]\n        for val in multival:\n            assert isinstance(val, IS)\n        assert 16 == multival[4]\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testslice", "self", "multivalue", "setting", "slice", "converts", "items", "to", "required", "type", "multival", "multivalue", "is", "range", "7", "multival", "2", "7", "2", "4", "16", "36", "for", "val", "in", "multival", "assert", "isinstance", "val", "is", "assert", "16", "multival", "4"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testIssue236DeepCopy", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testIssue236DeepCopy", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testIssue236DeepCopy(self):\n        \"\"\"MultiValue: deepcopy of MultiValue does not generate an error\"\"\"\n        multival = MultiValue(IS, range(7))\n        deepcopy(multival)\n        multival = MultiValue(DS, range(7))\n        deepcopy(multival)\n        multival = MultiValue(DSfloat, range(7))\n        deepcopy(multival)\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testissue236deepcopy", "self", "multivalue", "deepcopy", "of", "multivalue", "does", "not", "generate", "an", "error", "multival", "multivalue", "is", "range", "7", "deepcopy", "multival", "multival", "multivalue", "ds", "range", "7", "deepcopy", "multival", "multival", "multivalue", "dsfloat", "range", "7", "deepcopy", "multival"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.testSorting", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "testSorting", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def testSorting(self):\n        \"\"\"MultiValue: allow inline sort.\"\"\"\n        multival = MultiValue(DS, [12, 33, 5, 7, 1])\n        multival.sort()\n        assert [1, 5, 7, 12, 33] == multival\n        multival.sort(reverse=True)\n        assert [33, 12, 7, 5, 1] == multival\n        multival.sort(key=str)\n        assert [1, 12, 33, 5, 7] == multival\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "testsorting", "self", "multivalue", "allow", "inline", "sort", "multival", "multivalue", "ds", "12", "33", "5", "7", "1", "multival", "sort", "assert", "1", "5", "7", "12", "33", "multival", "multival", "sort", "reverse", "true", "assert", "33", "12", "7", "5", "1", "multival", "multival", "sort", "key", "str", "assert", "1", "12", "33", "5", "7", "multival"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.test_equal", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "test_equal", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def test_equal(self):\n        \"\"\"MultiValue: test equality operator\"\"\"\n        multival = MultiValue(DS, [12, 33, 5, 7, 1])\n        multival2 = MultiValue(DS, [12, 33, 5, 7, 1])\n        multival3 = MultiValue(DS, [33, 12, 5, 7, 1])\n        assert multival == multival2\n        assert not (multival == multival3)\n        multival = MultiValue(str, ['a', 'b', 'c'])\n        multival2 = MultiValue(str, ['a', 'b', 'c'])\n        multival3 = MultiValue(str, ['b', 'c', 'a'])\n        assert multival == multival2\n        assert not (multival == multival3)\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "test_equal", "self", "multivalue", "test", "equality", "operator", "multival", "multivalue", "ds", "12", "33", "5", "7", "1", "multival2", "multivalue", "ds", "12", "33", "5", "7", "1", "multival3", "multivalue", "ds", "33", "12", "5", "7", "1", "assert", "multival", "multival2", "assert", "not", "multival", "multival3", "multival", "multivalue", "str", "a", "b", "c", "multival2", "multivalue", "str", "a", "b", "c", "multival3", "multivalue", "str", "b", "c", "a", "assert", "multival", "multival2", "assert", "not", "multival", "multival3"], "doc_len": 68}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.test_not_equal", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "test_not_equal", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def test_not_equal(self):\n        \"\"\"MultiValue: test equality operator\"\"\"\n        multival = MultiValue(DS, [12, 33, 5, 7, 1])\n        multival2 = MultiValue(DS, [12, 33, 5, 7, 1])\n        multival3 = MultiValue(DS, [33, 12, 5, 7, 1])\n        assert not multival != multival2\n        assert multival != multival3\n        multival = MultiValue(str, ['a', 'b', 'c'])\n        multival2 = MultiValue(str, ['a', 'b', 'c'])\n        multival3 = MultiValue(str, ['b', 'c', 'a'])\n        assert not (multival != multival2)\n        assert multival != multival3\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "test_not_equal", "self", "multivalue", "test", "equality", "operator", "multival", "multivalue", "ds", "12", "33", "5", "7", "1", "multival2", "multivalue", "ds", "12", "33", "5", "7", "1", "multival3", "multivalue", "ds", "33", "12", "5", "7", "1", "assert", "not", "multival", "multival2", "assert", "multival", "multival3", "multival", "multivalue", "str", "a", "b", "c", "multival2", "multivalue", "str", "a", "b", "c", "multival3", "multivalue", "str", "b", "c", "a", "assert", "not", "multival", "multival2", "assert", "multival", "multival3"], "doc_len": 68}
{"doc_id": "pydicom/tests/test_multival.py::TestMultiValue.test_str_rep", "file_path": "pydicom/tests/test_multival.py", "class_name": "TestMultiValue", "func_name": "test_str_rep", "text": "文件路径: pydicom/tests/test_multival.py, 类名: TestMultiValue\n    def test_str_rep(self):\n        \"\"\"MultiValue: test print output\"\"\"\n        multival = MultiValue(IS, [])\n        assert '' == str(multival)\n        multival = MultiValue(compat.text_type, [1, 2, 3])\n        assert \"['1', '2', '3']\" == str(multival)\n        multival = MultiValue(int, [1, 2, 3])\n        assert '[1, 2, 3]' == str(multival)\n        multival = MultiValue(float, [1.1, 2.2, 3.3])\n        assert '[1.1, 2.2, 3.3]' == str(multival)\n", "tokens": ["pydicom", "tests", "test_multival", "py", "testmultivalue", "def", "test_str_rep", "self", "multivalue", "test", "print", "output", "multival", "multivalue", "is", "assert", "str", "multival", "multival", "multivalue", "compat", "text_type", "1", "2", "3", "assert", "1", "2", "3", "str", "multival", "multival", "multivalue", "int", "1", "2", "3", "assert", "1", "2", "3", "str", "multival", "multival", "multivalue", "float", "1", "1", "2", "2", "3", "3", "assert", "1", "1", "2", "2", "3", "3", "str", "multival"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::test_unsupported_syntaxes", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": null, "func_name": "test_unsupported_syntaxes", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py\ndef test_unsupported_syntaxes():\n    \"\"\"Test that UNSUPPORTED_SYNTAXES is as expected.\"\"\"\n    for syntax in SUPPORTED_SYNTAXES:\n        assert syntax not in UNSUPPORTED_SYNTAXES\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "def", "test_unsupported_syntaxes", "test", "that", "unsupported_syntaxes", "is", "as", "expected", "for", "syntax", "in", "supported_syntaxes", "assert", "syntax", "not", "in", "unsupported_syntaxes"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.setup", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.teardown", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.test_environment", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert not HAVE_NP\n        assert NP_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "not", "have_np", "assert", "np_handler", "is", "not", "none"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in dataset.\"\"\"\n        # Explicit little\n        ds = dcmread(EXPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Implicit little\n        ds = dcmread(IMPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Deflated little\n        ds = dcmread(DEFL_8_1_1F)\n        assert '^^^^' == ds.PatientName\n        assert 262144 == len(ds.PixelData)\n\n        # Explicit big\n        ds = dcmread(EXPB_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "dataset", "explicit", "little", "ds", "dcmread", "expl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "implicit", "little", "ds", "dcmread", "impl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "deflated", "little", "ds", "dcmread", "defl_8_1_1f", "assert", "ds", "patientname", "assert", "262144", "len", "ds", "pixeldata", "explicit", "big", "ds", "dcmread", "expb_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NoNumpyHandler.test_pixel_array_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NoNumpyHandler", "func_name": "test_pixel_array_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NoNumpyHandler\n    def test_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for all syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in ALL_TRANSFER_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            with pytest.raises(NotImplementedError,\n                               match=\"UID of '{}'\".format(uid)):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_nonumpyhandler", "def", "test_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "all", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "all_transfer_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "with", "pytest", "raises", "notimplementederror", "match", "uid", "of", "format", "uid", "ds", "pixel_array"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.setup", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [NP_HANDLER]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "np_handler"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.teardown", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.test_environment", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert not HAVE_NP\n        assert NP_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "not", "have_np", "assert", "np_handler", "is", "not", "none"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in dataset.\"\"\"\n        # Explicit little\n        ds = dcmread(EXPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Implicit little\n        ds = dcmread(IMPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Deflated little\n        ds = dcmread(DEFL_8_1_1F)\n        assert '^^^^' == ds.PatientName\n        assert 262144 == len(ds.PixelData)\n\n        # Explicit big\n        ds = dcmread(EXPB_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "dataset", "explicit", "little", "ds", "dcmread", "expl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "implicit", "little", "ds", "dcmread", "impl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "deflated", "little", "ds", "dcmread", "defl_8_1_1f", "assert", "ds", "patientname", "assert", "262144", "len", "ds", "pixeldata", "explicit", "big", "ds", "dcmread", "expb_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.test_unsupported_pixel_array_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "test_unsupported_pixel_array_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def test_unsupported_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for unsupported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in UNSUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            with pytest.raises(NotImplementedError,\n                               match=\"UID of '{}'\".format(uid)):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "test_unsupported_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "unsupported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "unsupported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "with", "pytest", "raises", "notimplementederror", "match", "uid", "of", "format", "uid", "ds", "pixel_array"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNoNumpy_NumpyHandler.test_supported_pixel_array_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNoNumpy_NumpyHandler", "func_name": "test_supported_pixel_array_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNoNumpy_NumpyHandler\n    def test_supported_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for supported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"The following handlers are available to decode the pixel \"\n                r\"data however they are missing required dependencies: \"\n                r\"Numpy \\(req. NumPy\\)\"\n            )\n            with pytest.raises(RuntimeError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnonumpy_numpyhandler", "def", "test_supported_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "supported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "the", "following", "handlers", "are", "available", "to", "decode", "the", "pixel", "r", "data", "however", "they", "are", "missing", "required", "dependencies", "r", "numpy", "req", "numpy", "with", "pytest", "raises", "runtimeerror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.setup", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.teardown", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.test_environment", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert HAVE_NP\n        # We numpy handler should still be available\n        assert NP_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "have_np", "we", "numpy", "handler", "should", "still", "be", "available", "assert", "np_handler", "is", "not", "none"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in dataset.\"\"\"\n        # Explicit little\n        ds = dcmread(EXPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Implicit little\n        ds = dcmread(IMPL_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n\n        # Deflated little\n        ds = dcmread(DEFL_8_1_1F)\n        assert '^^^^' == ds.PatientName\n        assert 262144 == len(ds.PixelData)\n\n        # Explicit big\n        ds = dcmread(EXPB_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 8192 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "dataset", "explicit", "little", "ds", "dcmread", "expl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "implicit", "little", "ds", "dcmread", "impl_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata", "deflated", "little", "ds", "dcmread", "defl_8_1_1f", "assert", "ds", "patientname", "assert", "262144", "len", "ds", "pixeldata", "explicit", "big", "ds", "dcmread", "expb_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "8192", "len", "ds", "pixeldata"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NoNumpyHandler.test_pixel_array_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NoNumpyHandler", "func_name": "test_pixel_array_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NoNumpyHandler\n    def test_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for all syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in ALL_TRANSFER_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            with pytest.raises((NotImplementedError, RuntimeError)):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_nonumpyhandler", "def", "test_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "all", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "all_transfer_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "with", "pytest", "raises", "notimplementederror", "runtimeerror", "ds", "pixel_array"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.setup", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def setup(self):\n        \"\"\"Setup the test datasets and the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [NP_HANDLER]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "setup", "self", "setup", "the", "test", "datasets", "and", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "np_handler"], "doc_len": 24}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.teardown", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_environment", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert HAVE_NP\n        assert NP_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "have_np", "assert", "np_handler", "is", "not", "none"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_unsupported_syntax_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_unsupported_syntax_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_unsupported_syntax_raises(self):\n        \"\"\"Test pixel_array raises exception for unsupported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n\n        for uid in UNSUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            with pytest.raises((NotImplementedError, RuntimeError)):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_unsupported_syntax_raises", "self", "test", "pixel_array", "raises", "exception", "for", "unsupported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "unsupported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "with", "pytest", "raises", "notimplementederror", "runtimeerror", "ds", "pixel_array"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_dataset_pixel_array_handler_needs_convert", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_dataset_pixel_array_handler_needs_convert", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_dataset_pixel_array_handler_needs_convert(self):\n        \"\"\"Test Dataset.pixel_array when converting to RGB.\"\"\"\n        ds = dcmread(EXPL_8_3_1F)\n        # Convert to YBR first\n        arr = ds.pixel_array\n        assert (255, 0, 0) == tuple(arr[5, 50, :])\n        arr = convert_color_space(arr, 'RGB', 'YBR_FULL')\n        ds.PixelData = arr.tobytes()\n        del ds._pixel_array  # Weird PyPy2 issue without this\n\n        # Test normal functioning (False)\n        assert (76, 85, 255) == tuple(ds.pixel_array[5, 50, :])\n\n        def needs_convert(ds):\n            \"\"\"Change the default return to True\"\"\"\n            return True\n\n        # Test modified\n        orig_fn = NP_HANDLER.needs_to_convert_to_RGB\n        NP_HANDLER.needs_to_convert_to_RGB = needs_convert\n\n        # Ensure the pixel array gets updated\n        ds._pixel_id = None\n        assert (254, 0, 0) == tuple(ds.pixel_array[5, 50, :])\n\n        # Reset\n        NP_HANDLER.needs_to_convert_to_RGB = orig_fn\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_dataset_pixel_array_handler_needs_convert", "self", "test", "dataset", "pixel_array", "when", "converting", "to", "rgb", "ds", "dcmread", "expl_8_3_1f", "convert", "to", "ybr", "first", "arr", "ds", "pixel_array", "assert", "255", "0", "0", "tuple", "arr", "5", "50", "arr", "convert_color_space", "arr", "rgb", "ybr_full", "ds", "pixeldata", "arr", "tobytes", "del", "ds", "_pixel_array", "weird", "pypy2", "issue", "without", "this", "test", "normal", "functioning", "false", "assert", "76", "85", "255", "tuple", "ds", "pixel_array", "5", "50", "def", "needs_convert", "ds", "change", "the", "default", "return", "to", "true", "return", "true", "test", "modified", "orig_fn", "np_handler", "needs_to_convert_to_rgb", "np_handler", "needs_to_convert_to_rgb", "needs_convert", "ensure", "the", "pixel", "array", "gets", "updated", "ds", "_pixel_id", "none", "assert", "254", "0", "0", "tuple", "ds", "pixel_array", "5", "50", "reset", "np_handler", "needs_to_convert_to_rgb", "orig_fn"], "doc_len": 104}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_pixel_array_8bit_un_signed", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_pixel_array_8bit_un_signed", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_pixel_array_8bit_un_signed(self):\n        \"\"\"Test pixel_array for 8-bit unsigned -> signed data.\"\"\"\n        ds = dcmread(EXPL_8_1_1F)\n        # 0 is unsigned int, 1 is 2's complement\n        assert ds.PixelRepresentation == 0\n        ds.PixelRepresentation = 1\n        arr = ds.pixel_array\n        ref = dcmread(EXPL_8_1_1F)\n\n        assert not np.array_equal(arr, ref.pixel_array)\n        assert (600, 800) == arr.shape\n        assert -12 == arr[0].min() == arr[0].max()\n        assert (1, -10, 1) == tuple(arr[300, 491:494])\n        assert 0 == arr[-1].min() == arr[-1].max()\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_pixel_array_8bit_un_signed", "self", "test", "pixel_array", "for", "8", "bit", "unsigned", "signed", "data", "ds", "dcmread", "expl_8_1_1f", "0", "is", "unsigned", "int", "1", "is", "2", "s", "complement", "assert", "ds", "pixelrepresentation", "0", "ds", "pixelrepresentation", "1", "arr", "ds", "pixel_array", "ref", "dcmread", "expl_8_1_1f", "assert", "not", "np", "array_equal", "arr", "ref", "pixel_array", "assert", "600", "800", "arr", "shape", "assert", "12", "arr", "0", "min", "arr", "0", "max", "assert", "1", "10", "1", "tuple", "arr", "300", "491", "494", "assert", "0", "arr", "1", "min", "arr", "1", "max"], "doc_len": 78}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_pixel_array_16bit_un_signed", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_pixel_array_16bit_un_signed", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_pixel_array_16bit_un_signed(self):\n        \"\"\"Test pixel_array for 16-bit unsigned -> signed.\"\"\"\n        ds = dcmread(EXPL_16_3_1F)\n        # 0 is unsigned int, 1 is 2's complement\n        assert ds.PixelRepresentation == 0\n        ds.PixelRepresentation = 1\n        arr = ds.pixel_array\n        ref = dcmread(EXPL_16_3_1F)\n\n        assert not np.array_equal(arr, ref.pixel_array)\n        assert (100, 100, 3) == arr.shape\n        assert -1 == arr[0, :, 0].min() == arr[0, :, 0].max()\n        assert -32640 == arr[50, :, 0].min() == arr[50, :, 0].max()\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_pixel_array_16bit_un_signed", "self", "test", "pixel_array", "for", "16", "bit", "unsigned", "signed", "ds", "dcmread", "expl_16_3_1f", "0", "is", "unsigned", "int", "1", "is", "2", "s", "complement", "assert", "ds", "pixelrepresentation", "0", "ds", "pixelrepresentation", "1", "arr", "ds", "pixel_array", "ref", "dcmread", "expl_16_3_1f", "assert", "not", "np", "array_equal", "arr", "ref", "pixel_array", "assert", "100", "100", "3", "arr", "shape", "assert", "1", "arr", "0", "0", "min", "arr", "0", "0", "max", "assert", "32640", "arr", "50", "0", "min", "arr", "50", "0", "max"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_pixel_array_32bit_un_signed", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_pixel_array_32bit_un_signed", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_pixel_array_32bit_un_signed(self):\n        \"\"\"Test pixel_array for 32-bit unsigned -> signed.\"\"\"\n        ds = dcmread(EXPL_32_3_1F)\n        # 0 is unsigned int, 1 is 2's complement\n        assert ds.PixelRepresentation == 0\n        ds.PixelRepresentation = 1\n        arr = ds.pixel_array\n        ref = dcmread(EXPL_32_3_1F)\n\n        assert not np.array_equal(arr, ref.pixel_array)\n        assert (100, 100, 3) == arr.shape\n        assert -1 == arr[0, :, 0].min() == arr[0, :, 0].max()\n        assert -2139062144 == arr[50, :, 0].min() == arr[50, :, 0].max()\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_pixel_array_32bit_un_signed", "self", "test", "pixel_array", "for", "32", "bit", "unsigned", "signed", "ds", "dcmread", "expl_32_3_1f", "0", "is", "unsigned", "int", "1", "is", "2", "s", "complement", "assert", "ds", "pixelrepresentation", "0", "ds", "pixelrepresentation", "1", "arr", "ds", "pixel_array", "ref", "dcmread", "expl_32_3_1f", "assert", "not", "np", "array_equal", "arr", "ref", "pixel_array", "assert", "100", "100", "3", "arr", "shape", "assert", "1", "arr", "0", "0", "min", "arr", "0", "0", "max", "assert", "2139062144", "arr", "50", "0", "min", "arr", "50", "0", "max"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_8bit_1sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_8bit_1sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_8bit_1sample_1frame(self):\n        \"\"\"Test pixel_array for 8-bit, 1 sample/pixel, 1 frame.\"\"\"\n        # Check supported syntaxes\n        ds = dcmread(EXPL_8_1_1F)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (600, 800) == arr.shape\n            assert 244 == arr[0].min() == arr[0].max()\n            assert (1, 246, 1) == tuple(arr[300, 491:494])\n            assert 0 == arr[-1].min() == arr[-1].max()\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_8bit_1sample_1frame", "self", "test", "pixel_array", "for", "8", "bit", "1", "sample", "pixel", "1", "frame", "check", "supported", "syntaxes", "ds", "dcmread", "expl_8_1_1f", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "600", "800", "arr", "shape", "assert", "244", "arr", "0", "min", "arr", "0", "max", "assert", "1", "246", "1", "tuple", "arr", "300", "491", "494", "assert", "0", "arr", "1", "min", "arr", "1", "max"], "doc_len": 69}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_8bit_1sample_2frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_8bit_1sample_2frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_8bit_1sample_2frame(self):\n        \"\"\"Test pixel_array for 8-bit, 1 sample/pixel, 2 frame.\"\"\"\n        # Check supported syntaxes\n        ds = dcmread(EXPL_8_1_2F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (2, 600, 800) == arr.shape\n            # Frame 1\n            assert 244 == arr[0, 0].min() == arr[0, 0].max()\n            assert (1, 246, 1) == tuple(arr[0, 300, 491:494])\n            assert 0 == arr[0, -1].min() == arr[0, -1].max()\n            # Frame 2 is frame 1 inverted\n            assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_8bit_1sample_2frame", "self", "test", "pixel_array", "for", "8", "bit", "1", "sample", "pixel", "2", "frame", "check", "supported", "syntaxes", "ds", "dcmread", "expl_8_1_2f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "2", "600", "800", "arr", "shape", "frame", "1", "assert", "244", "arr", "0", "0", "min", "arr", "0", "0", "max", "assert", "1", "246", "1", "tuple", "arr", "0", "300", "491", "494", "assert", "0", "arr", "0", "1", "min", "arr", "0", "1", "max", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 95}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_8bit_3sample_1frame_odd_size", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_8bit_3sample_1frame_odd_size", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_8bit_3sample_1frame_odd_size(self):\n        \"\"\"Test pixel_array for odd sized (3x3) pixel data.\"\"\"\n        # Check supported syntaxes\n        ds = dcmread(EXPL_8_3_1F_ODD)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert ds.pixel_array[0].tolist() == [\n                [166, 141, 52], [166, 141, 52], [166, 141, 52]\n            ]\n            assert ds.pixel_array[1].tolist() == [\n                [63, 87, 176], [63, 87, 176], [63, 87, 176]\n            ]\n            assert ds.pixel_array[2].tolist() == [\n                [158, 158, 158], [158, 158, 158], [158, 158, 158]\n            ]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_8bit_3sample_1frame_odd_size", "self", "test", "pixel_array", "for", "odd", "sized", "3x3", "pixel", "data", "check", "supported", "syntaxes", "ds", "dcmread", "expl_8_3_1f_odd", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "ds", "pixel_array", "0", "tolist", "166", "141", "52", "166", "141", "52", "166", "141", "52", "assert", "ds", "pixel_array", "1", "tolist", "63", "87", "176", "63", "87", "176", "63", "87", "176", "assert", "ds", "pixel_array", "2", "tolist", "158", "158", "158", "158", "158", "158", "158", "158", "158"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_8bit_3sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_8bit_3sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_8bit_3sample_1frame(self):\n        \"\"\"Test pixel_array for 8-bit, 3 sample/pixel, 1 frame.\"\"\"\n        # Check supported syntaxes\n        ds = dcmread(EXPL_8_3_1F)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (255, 0, 0) == tuple(arr[5, 50, :])\n            assert (255, 128, 128) == tuple(arr[15, 50, :])\n            assert (0, 255, 0) == tuple(arr[25, 50, :])\n            assert (128, 255, 128) == tuple(arr[35, 50, :])\n            assert (0, 0, 255) == tuple(arr[45, 50, :])\n            assert (128, 128, 255) == tuple(arr[55, 50, :])\n            assert (0, 0, 0) == tuple(arr[65, 50, :])\n            assert (64, 64, 64) == tuple(arr[75, 50, :])\n            assert (192, 192, 192) == tuple(arr[85, 50, :])\n            assert (255, 255, 255) == tuple(arr[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_8bit_3sample_1frame", "self", "test", "pixel_array", "for", "8", "bit", "3", "sample", "pixel", "1", "frame", "check", "supported", "syntaxes", "ds", "dcmread", "expl_8_3_1f", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "255", "0", "0", "tuple", "arr", "5", "50", "assert", "255", "128", "128", "tuple", "arr", "15", "50", "assert", "0", "255", "0", "tuple", "arr", "25", "50", "assert", "128", "255", "128", "tuple", "arr", "35", "50", "assert", "0", "0", "255", "tuple", "arr", "45", "50", "assert", "128", "128", "255", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "64", "64", "64", "tuple", "arr", "75", "50", "assert", "192", "192", "192", "tuple", "arr", "85", "50", "assert", "255", "255", "255", "tuple", "arr", "95", "50"], "doc_len": 119}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_8bit_3sample_2frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_8bit_3sample_2frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_8bit_3sample_2frame(self):\n        \"\"\"Test pixel_array for 8-bit, 3 sample/pixel, 2 frame.\"\"\"\n        # Check supported syntaxes\n        ds = dcmread(EXPL_8_3_2F)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            # Frame 1\n            frame = arr[0]\n            assert (255, 0, 0) == tuple(frame[5, 50, :])\n            assert (255, 128, 128) == tuple(frame[15, 50, :])\n            assert (0, 255, 0) == tuple(frame[25, 50, :])\n            assert (128, 255, 128) == tuple(frame[35, 50, :])\n            assert (0, 0, 255) == tuple(frame[45, 50, :])\n            assert (128, 128, 255) == tuple(frame[55, 50, :])\n            assert (0, 0, 0) == tuple(frame[65, 50, :])\n            assert (64, 64, 64) == tuple(frame[75, 50, :])\n            assert (192, 192, 192) == tuple(frame[85, 50, :])\n            assert (255, 255, 255) == tuple(frame[95, 50, :])\n            # Frame 2 is frame 1 inverted\n            assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_8bit_3sample_2frame", "self", "test", "pixel_array", "for", "8", "bit", "3", "sample", "pixel", "2", "frame", "check", "supported", "syntaxes", "ds", "dcmread", "expl_8_3_2f", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "frame", "1", "frame", "arr", "0", "assert", "255", "0", "0", "tuple", "frame", "5", "50", "assert", "255", "128", "128", "tuple", "frame", "15", "50", "assert", "0", "255", "0", "tuple", "frame", "25", "50", "assert", "128", "255", "128", "tuple", "frame", "35", "50", "assert", "0", "0", "255", "tuple", "frame", "45", "50", "assert", "128", "128", "255", "tuple", "frame", "55", "50", "assert", "0", "0", "0", "tuple", "frame", "65", "50", "assert", "64", "64", "64", "tuple", "frame", "75", "50", "assert", "192", "192", "192", "tuple", "frame", "85", "50", "assert", "255", "255", "255", "tuple", "frame", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 141}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_properties", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_properties", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_properties(self, fpath, data):\n        \"\"\"Test dataset and pixel array properties are as expected.\"\"\"\n        ds = dcmread(fpath)\n        assert ds.file_meta.TransferSyntaxUID == data[0]\n        assert ds.BitsAllocated == data[1]\n        assert ds.SamplesPerPixel == data[2]\n        assert ds.PixelRepresentation == data[3]\n        assert getattr(ds, 'NumberOfFrames', 1) == data[4]\n\n        # Check all little endian syntaxes\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n            assert data[5] == arr.shape\n            assert arr.dtype == data[6]\n\n            # Default to 1 if element not present\n            nr_frames = getattr(ds, 'NumberOfFrames', 1)\n            # Odd sized data is padded by a final 0x00 byte\n            size = ds.Rows * ds.Columns * nr_frames * data[1] / 8 * data[2]\n            assert len(ds.PixelData) == size + size % 2\n            if size % 2:\n                assert ds.PixelData[-1] == b'\\x00'[0]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_properties", "self", "fpath", "data", "test", "dataset", "and", "pixel", "array", "properties", "are", "as", "expected", "ds", "dcmread", "fpath", "assert", "ds", "file_meta", "transfersyntaxuid", "data", "0", "assert", "ds", "bitsallocated", "data", "1", "assert", "ds", "samplesperpixel", "data", "2", "assert", "ds", "pixelrepresentation", "data", "3", "assert", "getattr", "ds", "numberofframes", "1", "data", "4", "check", "all", "little", "endian", "syntaxes", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "data", "5", "arr", "shape", "assert", "arr", "dtype", "data", "6", "default", "to", "1", "if", "element", "not", "present", "nr_frames", "getattr", "ds", "numberofframes", "1", "odd", "sized", "data", "is", "padded", "by", "a", "final", "0x00", "byte", "size", "ds", "rows", "ds", "columns", "nr_frames", "data", "1", "8", "data", "2", "assert", "len", "ds", "pixeldata", "size", "size", "2", "if", "size", "2", "assert", "ds", "pixeldata", "1", "b", "x00", "0"], "doc_len": 127}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_1bit_1sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_1bit_1sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_1bit_1sample_1frame(self):\n        \"\"\"Test pixel_array for little 1-bit, 1 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_1_1_1F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert arr.max() == 1\n            assert arr.min() == 0\n\n            assert (0, 1, 1) == tuple(arr[155, 180:183])\n            assert (1, 0, 1, 0) == tuple(arr[155, 310:314])\n            assert (0, 1, 1) == tuple(arr[254, 78:81])\n            assert (1, 0, 0, 1, 1, 0) == tuple(arr[254, 304:310])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_1bit_1sample_1frame", "self", "test", "pixel_array", "for", "little", "1", "bit", "1", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_1_1_1f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "arr", "max", "1", "assert", "arr", "min", "0", "assert", "0", "1", "1", "tuple", "arr", "155", "180", "183", "assert", "1", "0", "1", "0", "tuple", "arr", "155", "310", "314", "assert", "0", "1", "1", "tuple", "arr", "254", "78", "81", "assert", "1", "0", "0", "1", "1", "0", "tuple", "arr", "254", "304", "310"], "doc_len": 91}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_1bit_1sample_3frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_1bit_1sample_3frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_1bit_1sample_3frame(self):\n        \"\"\"Test pixel_array for little 1-bit, 1 sample/pixel, 3 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_1_1_3F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert arr.max() == 1\n            assert arr.min() == 0\n\n            # Frame 1\n            assert (0, 1, 1) == tuple(arr[0, 155, 180:183])\n            assert (1, 0, 1, 0) == tuple(arr[0, 155, 310:314])\n            assert (0, 1, 1) == tuple(arr[0, 254, 78:81])\n            assert (1, 0, 0, 1, 1, 0) == tuple(arr[0, 254, 304:310])\n\n            assert 0 == arr[0][0][0]\n            assert 0 == arr[2][511][511]\n            assert 1 == arr[1][256][256]\n\n            # Frame 2\n            assert 0 == arr[1, 146, :254].max()\n            assert (0, 1, 1, 1, 1, 1, 0, 1) == tuple(arr[1, 146, 253:261])\n            assert 0 == arr[1, 146, 261:].max()\n\n            assert 0 == arr[1, 210, :97].max()\n            assert 1 == arr[1, 210, 97:350].max()\n            assert 0 == arr[1, 210, 350:].max()\n\n            # Frame 3\n            assert 0 == arr[2, 147, :249].max()\n            assert (0, 1, 0, 1, 1, 1) == tuple(arr[2, 147, 248:254])\n            assert (1, 0, 1, 0, 1, 1) == tuple(arr[2, 147, 260:266])\n            assert 0 == arr[2, 147, 283:].max()\n\n            assert 0 == arr[2, 364, :138].max()\n            assert (0, 1, 0, 1, 1, 0, 0, 1) == tuple(arr[2, 364, 137:145])\n            assert (1, 0, 0, 1, 0) == tuple(arr[2, 364, 152:157])\n            assert 0 == arr[2, 364, 157:].max()\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_1bit_1sample_3frame", "self", "test", "pixel_array", "for", "little", "1", "bit", "1", "sample", "pixel", "3", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_1_1_3f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "arr", "max", "1", "assert", "arr", "min", "0", "frame", "1", "assert", "0", "1", "1", "tuple", "arr", "0", "155", "180", "183", "assert", "1", "0", "1", "0", "tuple", "arr", "0", "155", "310", "314", "assert", "0", "1", "1", "tuple", "arr", "0", "254", "78", "81", "assert", "1", "0", "0", "1", "1", "0", "tuple", "arr", "0", "254", "304", "310", "assert", "0", "arr", "0", "0", "0", "assert", "0", "arr", "2", "511", "511", "assert", "1", "arr", "1", "256", "256", "frame", "2", "assert", "0", "arr", "1", "146", "254", "max", "assert", "0", "1", "1", "1", "1", "1", "0", "1", "tuple", "arr", "1", "146", "253", "261", "assert", "0", "arr", "1", "146", "261", "max", "assert", "0", "arr", "1", "210", "97", "max", "assert", "1", "arr", "1", "210", "97", "350", "max", "assert", "0", "arr", "1", "210", "350", "max", "frame", "3", "assert", "0", "arr", "2", "147", "249", "max", "assert", "0", "1", "0", "1", "1", "1", "tuple", "arr", "2", "147", "248", "254", "assert", "1", "0", "1", "0", "1", "1", "tuple", "arr", "2", "147", "260", "266", "assert", "0", "arr", "2", "147", "283", "max", "assert", "0", "arr", "2", "364", "138", "max", "assert", "0", "1", "0", "1", "1", "0", "0", "1", "tuple", "arr", "2", "364", "137", "145", "assert", "1", "0", "0", "1", "0", "tuple", "arr", "2", "364", "152", "157", "assert", "0", "arr", "2", "364", "157", "max"], "doc_len": 251}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_1bit_3sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_1bit_3sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_1bit_3sample_1frame(self):\n        \"\"\"Test pixel_array for little 1-bit, 3 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(None)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_1bit_3sample_1frame", "self", "test", "pixel_array", "for", "little", "1", "bit", "3", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "none", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_1bit_3sample_10frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_1bit_3sample_10frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_1bit_3sample_10frame(self):\n        \"\"\"Test pixel_array for little 1-bit, 3 sample/pixel, 10 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(None)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_1bit_3sample_10frame", "self", "test", "pixel_array", "for", "little", "1", "bit", "3", "sample", "pixel", "10", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "none", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_16bit_1sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_16bit_1sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_16bit_1sample_1frame(self):\n        \"\"\"Test pixel_array for little 16-bit, 1 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (422, 319, 361) == tuple(arr[0, 31:34])\n            assert (366, 363, 322) == tuple(arr[31, :3])\n            assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n            # Last pixel\n            assert 862 == arr[-1, -1]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_16bit_1sample_1frame", "self", "test", "pixel_array", "for", "little", "16", "bit", "1", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "422", "319", "361", "tuple", "arr", "0", "31", "34", "assert", "366", "363", "322", "tuple", "arr", "31", "3", "assert", "1369", "1129", "862", "tuple", "arr", "1", "3", "last", "pixel", "assert", "862", "arr", "1", "1"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_16bit_1sample_1frame_padded", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_16bit_1sample_1frame_padded", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_16bit_1sample_1frame_padded(self):\n        \"\"\"Test with padded little 16-bit, 1 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(EXPL_16_1_1F_PAD)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRLittleEndian\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 1\n        assert ds.PixelRepresentation == 1\n        nr_frames = getattr(ds, 'NumberOfFrames', 1)\n        assert nr_frames == 1\n\n        # Odd sized data is padded by a final 0x00 byte\n        size = ds.Rows * ds.Columns * nr_frames * 16 / 8 * ds.SamplesPerPixel\n        # Has excess padding\n        assert len(ds.PixelData) > size + size % 2\n\n        msg = (\n            r\"The length of the pixel data in the dataset \\(8320 bytes\\) \"\n            r\"indicates it contains excess padding. 128 bytes will be \"\n            r\"removed from the end of the data\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            arr = ds.pixel_array\n\n        assert (64, 64) == arr.shape\n        assert arr.dtype == 'int16'\n\n        assert arr.flags.writeable\n\n        assert (422, 319, 361) == tuple(arr[0, 31:34])\n        assert (366, 363, 322) == tuple(arr[31, :3])\n        assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n        # Last pixel\n        assert 862 == arr[-1, -1]\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_16bit_1sample_1frame_padded", "self", "test", "with", "padded", "little", "16", "bit", "1", "sample", "pixel", "1", "frame", "ds", "dcmread", "expl_16_1_1f_pad", "assert", "ds", "file_meta", "transfersyntaxuid", "explicitvrlittleendian", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "1", "assert", "ds", "pixelrepresentation", "1", "nr_frames", "getattr", "ds", "numberofframes", "1", "assert", "nr_frames", "1", "odd", "sized", "data", "is", "padded", "by", "a", "final", "0x00", "byte", "size", "ds", "rows", "ds", "columns", "nr_frames", "16", "8", "ds", "samplesperpixel", "has", "excess", "padding", "assert", "len", "ds", "pixeldata", "size", "size", "2", "msg", "r", "the", "length", "of", "the", "pixel", "data", "in", "the", "dataset", "8320", "bytes", "r", "indicates", "it", "contains", "excess", "padding", "128", "bytes", "will", "be", "r", "removed", "from", "the", "end", "of", "the", "data", "with", "pytest", "warns", "userwarning", "match", "msg", "arr", "ds", "pixel_array", "assert", "64", "64", "arr", "shape", "assert", "arr", "dtype", "int16", "assert", "arr", "flags", "writeable", "assert", "422", "319", "361", "tuple", "arr", "0", "31", "34", "assert", "366", "363", "322", "tuple", "arr", "31", "3", "assert", "1369", "1129", "862", "tuple", "arr", "1", "3", "last", "pixel", "assert", "862", "arr", "1", "1"], "doc_len": 162}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_16bit_1sample_10frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_16bit_1sample_10frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_16bit_1sample_10frame(self):\n        \"\"\"Test pixel_array for little 16-bit, 1 sample/pixel, 10 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_16_1_10F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            # Frame 1\n            assert (206, 197, 159) == tuple(arr[0, 0, 31:34])\n            assert (49, 78, 128) == tuple(arr[0, 31, :3])\n            assert (362, 219, 135) == tuple(arr[0, -1, -3:])\n            # Frame 5\n            assert (67, 82, 44) == tuple(arr[4, 0, 31:34])\n            assert (37, 41, 17) == tuple(arr[4, 31, :3])\n            assert (225, 380, 355) == tuple(arr[4, -1, -3:])\n            # Frame 10\n            assert (72, 86, 69) == tuple(arr[-1, 0, 31:34])\n            assert (25, 4, 9) == tuple(arr[-1, 31, :3])\n            assert (227, 300, 147) == tuple(arr[-1, -1, -3:])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_16bit_1sample_10frame", "self", "test", "pixel_array", "for", "little", "16", "bit", "1", "sample", "pixel", "10", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_16_1_10f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "frame", "1", "assert", "206", "197", "159", "tuple", "arr", "0", "0", "31", "34", "assert", "49", "78", "128", "tuple", "arr", "0", "31", "3", "assert", "362", "219", "135", "tuple", "arr", "0", "1", "3", "frame", "5", "assert", "67", "82", "44", "tuple", "arr", "4", "0", "31", "34", "assert", "37", "41", "17", "tuple", "arr", "4", "31", "3", "assert", "225", "380", "355", "tuple", "arr", "4", "1", "3", "frame", "10", "assert", "72", "86", "69", "tuple", "arr", "1", "0", "31", "34", "assert", "25", "4", "9", "tuple", "arr", "1", "31", "3", "assert", "227", "300", "147", "tuple", "arr", "1", "1", "3"], "doc_len": 133}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_16bit_3sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_16bit_3sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_16bit_3sample_1frame(self):\n        \"\"\"Test pixel_array for little 16-bit, 3 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_16_3_1F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (65535, 0, 0) == tuple(arr[5, 50, :])\n            assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n            assert (0, 65535, 0) == tuple(arr[25, 50, :])\n            assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n            assert (0, 0, 65535) == tuple(arr[45, 50, :])\n            assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n            assert (0, 0, 0) == tuple(arr[65, 50, :])\n            assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n            assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n            assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_16bit_3sample_1frame", "self", "test", "pixel_array", "for", "little", "16", "bit", "3", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_16_3_1f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "65535", "0", "0", "tuple", "arr", "5", "50", "assert", "65535", "32896", "32896", "tuple", "arr", "15", "50", "assert", "0", "65535", "0", "tuple", "arr", "25", "50", "assert", "32896", "65535", "32896", "tuple", "arr", "35", "50", "assert", "0", "0", "65535", "tuple", "arr", "45", "50", "assert", "32896", "32896", "65535", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "16448", "16448", "16448", "tuple", "arr", "75", "50", "assert", "49344", "49344", "49344", "tuple", "arr", "85", "50", "assert", "65535", "65535", "65535", "tuple", "arr", "95", "50"], "doc_len": 123}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_16bit_3sample_2frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_16bit_3sample_2frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_16bit_3sample_2frame(self):\n        \"\"\"Test pixel_array for little 16-bit, 3 sample/pixel, 2 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_16_3_2F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            # Frame 1\n            assert (65535, 0, 0) == tuple(arr[0, 5, 50, :])\n            assert (65535, 32896, 32896) == tuple(arr[0, 15, 50, :])\n            assert (0, 65535, 0) == tuple(arr[0, 25, 50, :])\n            assert (32896, 65535, 32896) == tuple(arr[0, 35, 50, :])\n            assert (0, 0, 65535) == tuple(arr[0, 45, 50, :])\n            assert (32896, 32896, 65535) == tuple(arr[0, 55, 50, :])\n            assert (0, 0, 0) == tuple(arr[0, 65, 50, :])\n            assert (16448, 16448, 16448) == tuple(arr[0, 75, 50, :])\n            assert (49344, 49344, 49344) == tuple(arr[0, 85, 50, :])\n            assert (65535, 65535, 65535) == tuple(arr[0, 95, 50, :])\n            # Frame 2 is frame 1 inverted\n            assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_16bit_3sample_2frame", "self", "test", "pixel_array", "for", "little", "16", "bit", "3", "sample", "pixel", "2", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_16_3_2f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "frame", "1", "assert", "65535", "0", "0", "tuple", "arr", "0", "5", "50", "assert", "65535", "32896", "32896", "tuple", "arr", "0", "15", "50", "assert", "0", "65535", "0", "tuple", "arr", "0", "25", "50", "assert", "32896", "65535", "32896", "tuple", "arr", "0", "35", "50", "assert", "0", "0", "65535", "tuple", "arr", "0", "45", "50", "assert", "32896", "32896", "65535", "tuple", "arr", "0", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "0", "65", "50", "assert", "16448", "16448", "16448", "tuple", "arr", "0", "75", "50", "assert", "49344", "49344", "49344", "tuple", "arr", "0", "85", "50", "assert", "65535", "65535", "65535", "tuple", "arr", "0", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 152}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_32bit_1sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_32bit_1sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_32bit_1sample_1frame(self):\n        \"\"\"Test pixel_array for little 32-bit, 1 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(IMPL_32_1_1F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n            assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n            assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_32bit_1sample_1frame", "self", "test", "pixel_array", "for", "little", "32", "bit", "1", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "impl_32_1_1f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "1249000", "1249000", "1250000", "tuple", "arr", "0", "3", "assert", "1031000", "1029000", "1027000", "tuple", "arr", "4", "3", "6", "assert", "803000", "801000", "798000", "tuple", "arr", "1", "3"], "doc_len": 68}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_32bit_1sample_15frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_32bit_1sample_15frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_32bit_1sample_15frame(self):\n        \"\"\"Test pixel_array for little 32-bit, 1 sample/pixel, 15 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(IMPL_32_1_15F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            # Frame 1\n            assert (1249000, 1249000, 1250000) == tuple(arr[0, 0, :3])\n            assert (1031000, 1029000, 1027000) == tuple(arr[0, 4, 3:6])\n            assert (803000, 801000, 798000) == tuple(arr[0, -1, -3:])\n            # Frame 8\n            assert (1253000, 1253000, 1249000) == tuple(arr[7, 0, :3])\n            assert (1026000, 1023000, 1022000) == tuple(arr[7, 4, 3:6])\n            assert (803000, 803000, 803000) == tuple(arr[7, -1, -3:])\n            # Frame 15\n            assert (1249000, 1250000, 1251000) == tuple(arr[-1, 0, :3])\n            assert (1031000, 1031000, 1031000) == tuple(arr[-1, 4, 3:6])\n            assert (801000, 800000, 799000) == tuple(arr[-1, -1, -3:])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_32bit_1sample_15frame", "self", "test", "pixel_array", "for", "little", "32", "bit", "1", "sample", "pixel", "15", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "impl_32_1_15f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "frame", "1", "assert", "1249000", "1249000", "1250000", "tuple", "arr", "0", "0", "3", "assert", "1031000", "1029000", "1027000", "tuple", "arr", "0", "4", "3", "6", "assert", "803000", "801000", "798000", "tuple", "arr", "0", "1", "3", "frame", "8", "assert", "1253000", "1253000", "1249000", "tuple", "arr", "7", "0", "3", "assert", "1026000", "1023000", "1022000", "tuple", "arr", "7", "4", "3", "6", "assert", "803000", "803000", "803000", "tuple", "arr", "7", "1", "3", "frame", "15", "assert", "1249000", "1250000", "1251000", "tuple", "arr", "1", "0", "3", "assert", "1031000", "1031000", "1031000", "tuple", "arr", "1", "4", "3", "6", "assert", "801000", "800000", "799000", "tuple", "arr", "1", "1", "3"], "doc_len": 133}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_32bit_3sample_1frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_32bit_3sample_1frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_32bit_3sample_1frame(self):\n        \"\"\"Test pixel_array for little 32-bit, 3 sample/pixel, 1 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_32_3_1F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            ar = ds.pixel_array\n\n            assert ar.flags.writeable\n\n            assert (4294967295, 0, 0) == tuple(ar[5, 50, :])\n            assert (4294967295, 2155905152, 2155905152) == tuple(ar[15, 50, :])\n            assert (0, 4294967295, 0) == tuple(ar[25, 50, :])\n            assert (2155905152, 4294967295, 2155905152) == tuple(ar[35, 50, :])\n            assert (0, 0, 4294967295) == tuple(ar[45, 50, :])\n            assert (2155905152, 2155905152, 4294967295) == tuple(ar[55, 50, :])\n            assert (0, 0, 0) == tuple(ar[65, 50, :])\n            assert (1077952576, 1077952576, 1077952576) == tuple(ar[75, 50, :])\n            assert (3233857728, 3233857728, 3233857728) == tuple(ar[85, 50, :])\n            assert (4294967295, 4294967295, 4294967295) == tuple(ar[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_32bit_3sample_1frame", "self", "test", "pixel_array", "for", "little", "32", "bit", "3", "sample", "pixel", "1", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_32_3_1f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "ar", "ds", "pixel_array", "assert", "ar", "flags", "writeable", "assert", "4294967295", "0", "0", "tuple", "ar", "5", "50", "assert", "4294967295", "2155905152", "2155905152", "tuple", "ar", "15", "50", "assert", "0", "4294967295", "0", "tuple", "ar", "25", "50", "assert", "2155905152", "4294967295", "2155905152", "tuple", "ar", "35", "50", "assert", "0", "0", "4294967295", "tuple", "ar", "45", "50", "assert", "2155905152", "2155905152", "4294967295", "tuple", "ar", "55", "50", "assert", "0", "0", "0", "tuple", "ar", "65", "50", "assert", "1077952576", "1077952576", "1077952576", "tuple", "ar", "75", "50", "assert", "3233857728", "3233857728", "3233857728", "tuple", "ar", "85", "50", "assert", "4294967295", "4294967295", "4294967295", "tuple", "ar", "95", "50"], "doc_len": 123}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_little_32bit_3sample_2frame", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_little_32bit_3sample_2frame", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_little_32bit_3sample_2frame(self):\n        \"\"\"Test pixel_array for little 32-bit, 3 sample/pixel, 10 frame.\"\"\"\n        # Check all little endian syntaxes\n        ds = dcmread(EXPL_32_3_2F)\n        for uid in SUPPORTED_SYNTAXES[:3]:\n            ds.file_meta.TransferSyntaxUID = uid\n            arr = ds.pixel_array\n\n            assert arr.flags.writeable\n\n            # Frame 1\n            assert (4294967295, 0, 0) == tuple(arr[0, 5, 50, :])\n            assert (4294967295, 2155905152, 2155905152) == tuple(\n                arr[0, 15, 50, :]\n            )\n            assert (0, 4294967295, 0) == tuple(arr[0, 25, 50, :])\n            assert (2155905152, 4294967295, 2155905152) == tuple(\n                arr[0, 35, 50, :]\n            )\n            assert (0, 0, 4294967295) == tuple(arr[0, 45, 50, :])\n            assert (2155905152, 2155905152, 4294967295) == tuple(\n                arr[0, 55, 50, :]\n            )\n            assert (0, 0, 0) == tuple(arr[0, 65, 50, :])\n            assert (1077952576, 1077952576, 1077952576) == tuple(\n                arr[0, 75, 50, :]\n            )\n            assert (3233857728, 3233857728, 3233857728) == tuple(\n                arr[0, 85, 50, :]\n            )\n            assert (4294967295, 4294967295, 4294967295) == tuple(\n                arr[0, 95, 50, :]\n            )\n            # Frame 2 is frame 1 inverted\n            assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_little_32bit_3sample_2frame", "self", "test", "pixel_array", "for", "little", "32", "bit", "3", "sample", "pixel", "10", "frame", "check", "all", "little", "endian", "syntaxes", "ds", "dcmread", "expl_32_3_2f", "for", "uid", "in", "supported_syntaxes", "3", "ds", "file_meta", "transfersyntaxuid", "uid", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "frame", "1", "assert", "4294967295", "0", "0", "tuple", "arr", "0", "5", "50", "assert", "4294967295", "2155905152", "2155905152", "tuple", "arr", "0", "15", "50", "assert", "0", "4294967295", "0", "tuple", "arr", "0", "25", "50", "assert", "2155905152", "4294967295", "2155905152", "tuple", "arr", "0", "35", "50", "assert", "0", "0", "4294967295", "tuple", "arr", "0", "45", "50", "assert", "2155905152", "2155905152", "4294967295", "tuple", "arr", "0", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "0", "65", "50", "assert", "1077952576", "1077952576", "1077952576", "tuple", "arr", "0", "75", "50", "assert", "3233857728", "3233857728", "3233857728", "tuple", "arr", "0", "85", "50", "assert", "4294967295", "4294967295", "4294967295", "tuple", "arr", "0", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 152}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_big_endian_datasets", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_big_endian_datasets", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_big_endian_datasets(self, little, big):\n        \"\"\"Test pixel_array for big endian matches little.\"\"\"\n        ds = dcmread(big)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRBigEndian\n        ref = dcmread(little)\n        assert ref.file_meta.TransferSyntaxUID != ExplicitVRBigEndian\n        assert np.array_equal(ds.pixel_array, ref.pixel_array)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_big_endian_datasets", "self", "little", "big", "test", "pixel_array", "for", "big", "endian", "matches", "little", "ds", "dcmread", "big", "assert", "ds", "file_meta", "transfersyntaxuid", "explicitvrbigendian", "ref", "dcmread", "little", "assert", "ref", "file_meta", "transfersyntaxuid", "explicitvrbigendian", "assert", "np", "array_equal", "ds", "pixel_array", "ref", "pixel_array"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_endianness_not_set", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_endianness_not_set", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_endianness_not_set(self):\n        \"\"\"Test for #704, Dataset.is_little_endian unset.\"\"\"\n        ds = Dataset()\n        ds.file_meta = Dataset()\n        ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        ds.Rows = 10\n        ds.Columns = 10\n        ds.BitsAllocated = 16\n        ds.PixelRepresentation = 0\n        ds.SamplesPerPixel = 1\n        arr = np.ones((10, 10), dtype='uint16')\n        ds.PixelData = arr.tobytes()\n\n        assert ds.pixel_array.max() == 1\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_endianness_not_set", "self", "test", "for", "704", "dataset", "is_little_endian", "unset", "ds", "dataset", "ds", "file_meta", "dataset", "ds", "file_meta", "transfersyntaxuid", "explicitvrlittleendian", "ds", "rows", "10", "ds", "columns", "10", "ds", "bitsallocated", "16", "ds", "pixelrepresentation", "0", "ds", "samplesperpixel", "1", "arr", "np", "ones", "10", "10", "dtype", "uint16", "ds", "pixeldata", "arr", "tobytes", "assert", "ds", "pixel_array", "max", "1"], "doc_len": 54}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_NumpyHandler.test_read_only", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_NumpyHandler", "func_name": "test_read_only", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_NumpyHandler\n    def test_read_only(self):\n        \"\"\"Test for #717, returned array read-only.\"\"\"\n        ds = dcmread(EXPL_8_1_1F)\n        arr = ds.pixel_array\n        assert 0 != arr[0, 0]\n        arr[0, 0] = 0\n        assert 0 == arr[0, 0]\n        assert arr.flags.writeable\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_numpyhandler", "def", "test_read_only", "self", "test", "for", "717", "returned", "array", "read", "only", "ds", "dcmread", "expl_8_1_1f", "arr", "ds", "pixel_array", "assert", "0", "arr", "0", "0", "arr", "0", "0", "0", "assert", "0", "arr", "0", "0", "assert", "arr", "flags", "writeable"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_no_pixel_data_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_no_pixel_data_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_no_pixel_data_raises(self):\n        \"\"\"Test get_pixeldata raises if dataset has no PixelData.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        del ds.PixelData\n        assert 'PixelData' not in ds\n        with pytest.raises(AttributeError, match=' dataset: PixelData'):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_no_pixel_data_raises", "self", "test", "get_pixeldata", "raises", "if", "dataset", "has", "no", "pixeldata", "ds", "dcmread", "expl_16_1_1f", "del", "ds", "pixeldata", "assert", "pixeldata", "not", "in", "ds", "with", "pytest", "raises", "attributeerror", "match", "dataset", "pixeldata", "get_pixeldata", "ds"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_unknown_pixel_representation_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_unknown_pixel_representation_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_unknown_pixel_representation_raises(self):\n        \"\"\"Test get_pixeldata raises if unsupported PixelRepresentation.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        ds.PixelRepresentation = 2\n        with pytest.raises(ValueError,\n                           match=r\"value of '2' for '\\(0028,0103\"):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_unknown_pixel_representation_raises", "self", "test", "get_pixeldata", "raises", "if", "unsupported", "pixelrepresentation", "ds", "dcmread", "expl_16_1_1f", "ds", "pixelrepresentation", "2", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "2", "for", "0028", "0103", "get_pixeldata", "ds"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_unsupported_syntaxes_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_unsupported_syntaxes_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_unsupported_syntaxes_raises(self):\n        \"\"\"Test get_pixeldata raises if unsupported Transfer Syntax.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        ds.file_meta.TransferSyntaxUID = '1.2.840.10008.1.2.4.50'\n        with pytest.raises(NotImplementedError,\n                           match=' the transfer syntax is not supported'):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_unsupported_syntaxes_raises", "self", "test", "get_pixeldata", "raises", "if", "unsupported", "transfer", "syntax", "ds", "dcmread", "expl_16_1_1f", "ds", "file_meta", "transfersyntaxuid", "1", "2", "840", "10008", "1", "2", "4", "50", "with", "pytest", "raises", "notimplementederror", "match", "the", "transfer", "syntax", "is", "not", "supported", "get_pixeldata", "ds"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_bad_length_raises", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_bad_length_raises", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_bad_length_raises(self):\n        \"\"\"Test bad pixel data length raises exception.\"\"\"\n        ds = dcmread(EXPL_8_1_1F)\n        # Too short\n        ds.PixelData = ds.PixelData[:-1]\n        msg = (\n            r\"The length of the pixel data in the dataset \\(479999 bytes\\) \"\n            r\"doesn't match the expected length \\(480000 bytes\\). \"\n            r\"The dataset may be corrupted or there may be an issue \"\n            r\"with the pixel data handler.\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_bad_length_raises", "self", "test", "bad", "pixel", "data", "length", "raises", "exception", "ds", "dcmread", "expl_8_1_1f", "too", "short", "ds", "pixeldata", "ds", "pixeldata", "1", "msg", "r", "the", "length", "of", "the", "pixel", "data", "in", "the", "dataset", "479999", "bytes", "r", "doesn", "t", "match", "the", "expected", "length", "480000", "bytes", "r", "the", "dataset", "may", "be", "corrupted", "or", "there", "may", "be", "an", "issue", "r", "with", "the", "pixel", "data", "handler", "with", "pytest", "raises", "valueerror", "match", "msg", "get_pixeldata", "ds"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_missing_padding_warns", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_missing_padding_warns", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_missing_padding_warns(self):\n        \"\"\"A warning shall be issued if the padding for odd data is missing.\"\"\"\n        ds = dcmread(EXPL_8_3_1F_ODD)\n        # remove the padding byte\n        ds.PixelData = ds.PixelData[:-1]\n        msg = \"The pixel data length is odd and misses a padding byte.\"\n        with pytest.warns(UserWarning, match=msg):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_missing_padding_warns", "self", "a", "warning", "shall", "be", "issued", "if", "the", "padding", "for", "odd", "data", "is", "missing", "ds", "dcmread", "expl_8_3_1f_odd", "remove", "the", "padding", "byte", "ds", "pixeldata", "ds", "pixeldata", "1", "msg", "the", "pixel", "data", "length", "is", "odd", "and", "misses", "a", "padding", "byte", "with", "pytest", "warns", "userwarning", "match", "msg", "get_pixeldata", "ds"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_change_photometric_interpretation", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_change_photometric_interpretation", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_change_photometric_interpretation(self):\n        \"\"\"Test get_pixeldata changes PhotometricInterpretation if required.\"\"\"\n        def to_rgb(ds):\n            \"\"\"Override the original function that returned False\"\"\"\n            return True\n\n        # Test default\n        ds = dcmread(EXPL_16_1_1F)\n        assert ds.PhotometricInterpretation == 'MONOCHROME2'\n\n        get_pixeldata(ds)\n        assert ds.PhotometricInterpretation == 'MONOCHROME2'\n\n        # Test modified\n        orig_fn = NP_HANDLER.should_change_PhotometricInterpretation_to_RGB\n        NP_HANDLER.should_change_PhotometricInterpretation_to_RGB = to_rgb\n\n        get_pixeldata(ds)\n        assert ds.PhotometricInterpretation == 'RGB'\n\n        NP_HANDLER.should_change_PhotometricInterpretation_to_RGB = orig_fn\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_change_photometric_interpretation", "self", "test", "get_pixeldata", "changes", "photometricinterpretation", "if", "required", "def", "to_rgb", "ds", "override", "the", "original", "function", "that", "returned", "false", "return", "true", "test", "default", "ds", "dcmread", "expl_16_1_1f", "assert", "ds", "photometricinterpretation", "monochrome2", "get_pixeldata", "ds", "assert", "ds", "photometricinterpretation", "monochrome2", "test", "modified", "orig_fn", "np_handler", "should_change_photometricinterpretation_to_rgb", "np_handler", "should_change_photometricinterpretation_to_rgb", "to_rgb", "get_pixeldata", "ds", "assert", "ds", "photometricinterpretation", "rgb", "np_handler", "should_change_photometricinterpretation_to_rgb", "orig_fn"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_array_read_only", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_array_read_only", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_array_read_only(self):\n        \"\"\"Test returning a read only array for BitsAllocated > 8.\"\"\"\n        ds = dcmread(EXPL_8_1_1F)\n        arr = get_pixeldata(ds, read_only=False)\n        assert arr.flags.writeable\n        assert 0 != arr[10]\n        arr[10] = 0\n        assert 0 == arr[10]\n\n        arr = get_pixeldata(ds, read_only=True)\n        assert not arr.flags.writeable\n        with pytest.raises(ValueError, match=\"is read-only\"):\n            arr[10] = 0\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_array_read_only", "self", "test", "returning", "a", "read", "only", "array", "for", "bitsallocated", "8", "ds", "dcmread", "expl_8_1_1f", "arr", "get_pixeldata", "ds", "read_only", "false", "assert", "arr", "flags", "writeable", "assert", "0", "arr", "10", "arr", "10", "0", "assert", "0", "arr", "10", "arr", "get_pixeldata", "ds", "read_only", "true", "assert", "not", "arr", "flags", "writeable", "with", "pytest", "raises", "valueerror", "match", "is", "read", "only", "arr", "10", "0"], "doc_len": 61}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_GetPixelData.test_array_read_only_bit_packed", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_array_read_only_bit_packed", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_array_read_only_bit_packed(self):\n        \"\"\"Test returning a read only array for BitsAllocated = 1.\"\"\"\n        ds = dcmread(EXPL_1_1_1F)\n        arr = get_pixeldata(ds, read_only=False)\n        assert arr.flags.writeable\n\n        arr = get_pixeldata(ds, read_only=True)\n        assert arr.flags.writeable\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_array_read_only_bit_packed", "self", "test", "returning", "a", "read", "only", "array", "for", "bitsallocated", "1", "ds", "dcmread", "expl_1_1_1f", "arr", "get_pixeldata", "ds", "read_only", "false", "assert", "arr", "flags", "writeable", "arr", "get_pixeldata", "ds", "read_only", "true", "assert", "arr", "flags", "writeable"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_UnpackBits.test_unpack", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_UnpackBits", "func_name": "test_unpack", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_UnpackBits\n    def test_unpack(self, input, output):\n        \"\"\"Test unpacking data.\"\"\"\n        assert np.array_equal(np.asarray(output), unpack_bits(input))\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_unpackbits", "def", "test_unpack", "self", "input", "output", "test", "unpacking", "data", "assert", "np", "array_equal", "np", "asarray", "output", "unpack_bits", "input"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_PackBits.test_pack", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_PackBits", "func_name": "test_pack", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_PackBits\n    def test_pack(self, input, output):\n        \"\"\"Test packing data.\"\"\"\n        assert output == pack_bits(np.asarray(input))\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_packbits", "def", "test_pack", "self", "input", "output", "test", "packing", "data", "assert", "output", "pack_bits", "np", "asarray", "input"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_PackBits.test_non_binary_input", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_PackBits", "func_name": "test_non_binary_input", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_PackBits\n    def test_non_binary_input(self):\n        \"\"\"Test non-binary input raises exception.\"\"\"\n        with pytest.raises(ValueError,\n                           match=r\"Only binary arrays \\(containing ones or\"):\n            pack_bits(np.asarray([0, 0, 2, 0, 0, 0, 0, 0]))\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_packbits", "def", "test_non_binary_input", "self", "test", "non", "binary", "input", "raises", "exception", "with", "pytest", "raises", "valueerror", "match", "r", "only", "binary", "arrays", "containing", "ones", "or", "pack_bits", "np", "asarray", "0", "0", "2", "0", "0", "0", "0", "0"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_PackBits.test_non_array_input", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_PackBits", "func_name": "test_non_array_input", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_PackBits\n    def test_non_array_input(self):\n        \"\"\"Test non 1D input raises exception.\"\"\"\n        with pytest.raises(ValueError, match='Only 1D arrays are supported'):\n            pack_bits(\n                np.asarray(\n                    [[0, 0, 0, 0, 0, 0, 0, 0],\n                     [1, 0, 1, 0, 1, 0, 1, 0]]\n                )\n            )\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_packbits", "def", "test_non_array_input", "self", "test", "non", "1d", "input", "raises", "exception", "with", "pytest", "raises", "valueerror", "match", "only", "1d", "arrays", "are", "supported", "pack_bits", "np", "asarray", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", "1", "0", "1", "0", "1", "0"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_PackBits.test_pack_partial", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_PackBits", "func_name": "test_pack_partial", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_PackBits\n    def test_pack_partial(self, input, output):\n        \"\"\"Test packing data that isn't a full byte long.\"\"\"\n        assert output == pack_bits(np.asarray(input))\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_packbits", "def", "test_pack_partial", "self", "input", "output", "test", "packing", "data", "that", "isn", "t", "a", "full", "byte", "long", "assert", "output", "pack_bits", "np", "asarray", "input"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_numpy_pixel_data.py::TestNumpy_PackBits.test_functional", "file_path": "pydicom/tests/test_numpy_pixel_data.py", "class_name": "TestNumpy_PackBits", "func_name": "test_functional", "text": "文件路径: pydicom/tests/test_numpy_pixel_data.py, 类名: TestNumpy_PackBits\n    def test_functional(self):\n        \"\"\"Test against a real dataset.\"\"\"\n        ds = dcmread(EXPL_1_1_3F)\n        arr = ds.pixel_array\n        arr = arr.ravel()\n        assert ds.PixelData == pack_bits(arr)\n", "tokens": ["pydicom", "tests", "test_numpy_pixel_data", "py", "testnumpy_packbits", "def", "test_functional", "self", "test", "against", "a", "real", "dataset", "ds", "dcmread", "expl_1_1_3f", "arr", "ds", "pixel_array", "arr", "arr", "ravel", "assert", "ds", "pixeldata", "pack_bits", "arr"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGLS_no_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGLS_no_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGLS_no_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_ls_lossless = dcmread(jpeg_ls_lossless_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpegls_no_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_ls_lossless", "dcmread", "jpeg_ls_lossless_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGLS_no_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGLS_no_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGLS_no_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpegls_no_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGLS_no_pillow.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGLS_no_pillow", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGLS_no_pillow\n    def test_JPEG_LS_PixelArray(self):\n        \"\"\"Test decoding JPEG LS with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpegls_no_pillow", "def", "test_jpeg_ls_pixelarray", "self", "test", "decoding", "jpeg", "ls", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGLS_no_pillow.test_emri_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGLS_no_pillow", "func_name": "test_emri_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGLS_no_pillow\n    def test_emri_JPEG_LS_PixelArray(self):\n        \"\"\"Test decoding JPEG LS with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpegls_no_pillow", "def", "test_emri_jpeg_ls_pixelarray", "self", "test", "decoding", "jpeg", "ls", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_2k = dcmread(jpeg2000_name)\n        self.jpeg_2k_lossless = dcmread(jpeg2000_lossless_name)\n        self.emri_jpeg_2k_lossless = dcmread(emri_jpeg_2k_lossless)\n        self.sc_rgb_jpeg2k_gdcm_KY = dcmread(sc_rgb_jpeg2k_gdcm_KY)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_2k", "dcmread", "jpeg2000_name", "self", "jpeg_2k_lossless", "dcmread", "jpeg2000_lossless_name", "self", "emri_jpeg_2k_lossless", "dcmread", "emri_jpeg_2k_lossless", "self", "sc_rgb_jpeg2k_gdcm_ky", "dcmread", "sc_rgb_jpeg2k_gdcm_ky", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.testJPEG2000", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "testJPEG2000", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def testJPEG2000(self):\n        \"\"\"Test reading element values works OK without Pillow.\"\"\"\n        # XX also tests multiple-valued AT data element\n        elem = self.jpeg_2k.FrameIncrementPointer\n        assert [Tag(0x0054, 0x0010), Tag(0x0054, 0x0020)] == elem\n\n        elem = self.jpeg_2k.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == elem\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "testjpeg2000", "self", "test", "reading", "element", "values", "works", "ok", "without", "pillow", "xx", "also", "tests", "multiple", "valued", "at", "data", "element", "elem", "self", "jpeg_2k", "frameincrementpointer", "assert", "tag", "0x0054", "0x0010", "tag", "0x0054", "0x0020", "elem", "elem", "self", "jpeg_2k", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "elem"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.testJPEG2000PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "testJPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def testJPEG2000PixelArray(self):\n        \"\"\"Test decoding JPEG2K with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "testjpeg2000pixelarray", "self", "test", "decoding", "jpeg2k", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_2k_lossless", "pixel_array"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.test_emri_JPEG2000PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "test_emri_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def test_emri_JPEG2000PixelArray(self):\n        \"\"\"Test decoding JPEG2K with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "test_emri_jpeg2000pixelarray", "self", "test", "decoding", "jpeg2k", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_2k_lossless", "pixel_array"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_no_pillow.test_jpeg2000_lossy", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_no_pillow", "func_name": "test_jpeg2000_lossy", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_no_pillow\n    def test_jpeg2000_lossy(self):\n        \"\"\"Test decoding JPEG2K with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.sc_rgb_jpeg2k_gdcm_KY.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_no_pillow", "def", "test_jpeg2000_lossy", "self", "test", "decoding", "jpeg2k", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "sc_rgb_jpeg2k_gdcm_ky", "pixel_array"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_no_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_no_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_no_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_lossy = dcmread(jpeg_lossy_name)\n        self.color_3d_jpeg = dcmread(color_3d_jpeg_baseline)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_no_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_lossy", "dcmread", "jpeg_lossy_name", "self", "color_3d_jpeg", "dcmread", "color_3d_jpeg_baseline", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_no_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_no_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_no_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_no_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_no_pillow.testJPEGlossy", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_no_pillow", "func_name": "testJPEGlossy", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_no_pillow\n    def testJPEGlossy(self):\n        \"\"\"Test reading element values works OK without Pillow.\"\"\"\n        elem = self.jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == elem\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_no_pillow", "def", "testjpeglossy", "self", "test", "reading", "element", "values", "works", "ok", "without", "pillow", "elem", "self", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "elem"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_no_pillow.testJPEGlossyPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_no_pillow", "func_name": "testJPEGlossyPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_no_pillow\n    def testJPEGlossyPixelArray(self):\n        \"\"\"Test decoding JPEG lossy with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossy.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_no_pillow", "def", "testjpeglossypixelarray", "self", "test", "decoding", "jpeg", "lossy", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossy", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_no_pillow.testJPEGBaselineColor3DPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_no_pillow", "func_name": "testJPEGBaselineColor3DPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_no_pillow\n    def testJPEGBaselineColor3DPixelArray(self):\n        \"\"\"Test decoding JPEG lossy with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.color_3d_jpeg.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_no_pillow", "def", "testjpegbaselinecolor3dpixelarray", "self", "test", "decoding", "jpeg", "lossy", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "color_3d_jpeg", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_no_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_no_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_no_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_lossless = dcmread(jpeg_lossless_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_no_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_lossless", "dcmread", "jpeg_lossless_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "numpy_handler"], "doc_len": 25}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_no_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_no_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_no_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_no_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_no_pillow.testJPEGlossless", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_no_pillow", "func_name": "testJPEGlossless", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_no_pillow\n    def testJPEGlossless(self):\n        \"\"\"Test reading element values works OK without Pillow.\"\"\"\n        elem = self.jpeg_lossless.SourceImageSequence[0]\n        elem = elem.PurposeOfReferenceCodeSequence[0].CodeMeaning\n        assert 'Uncompressed predecessor' == elem\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_no_pillow", "def", "testjpeglossless", "self", "test", "reading", "element", "values", "works", "ok", "without", "pillow", "elem", "self", "jpeg_lossless", "sourceimagesequence", "0", "elem", "elem", "purposeofreferencecodesequence", "0", "codemeaning", "assert", "uncompressed", "predecessor", "elem"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_no_pillow.testJPEGlosslessPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_no_pillow", "func_name": "testJPEGlosslessPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_no_pillow\n    def testJPEGlosslessPixelArray(self):\n        \"\"\"Test decoding JPEG lossless with only numpy fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_no_pillow", "def", "testjpeglosslesspixelarray", "self", "test", "decoding", "jpeg", "lossless", "with", "only", "numpy", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG_LS_with_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG_LS_with_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG_LS_with_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_ls_lossless = dcmread(jpeg_ls_lossless_name)\n        self.emri_jpeg_ls_lossless = dcmread(emri_jpeg_ls_lossless)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [pillow_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg_ls_with_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_ls_lossless", "dcmread", "jpeg_ls_lossless_name", "self", "emri_jpeg_ls_lossless", "dcmread", "emri_jpeg_ls_lossless", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "numpy_handler"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG_LS_with_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG_LS_with_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG_LS_with_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg_ls_with_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG_LS_with_pillow.test_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG_LS_with_pillow", "func_name": "test_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG_LS_with_pillow\n    def test_JPEG_LS_PixelArray(self):\n        \"\"\"Test decoding JPEG LS with pillow handler fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg_ls_with_pillow", "def", "test_jpeg_ls_pixelarray", "self", "test", "decoding", "jpeg", "ls", "with", "pillow", "handler", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_ls_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG_LS_with_pillow.test_emri_JPEG_LS_PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG_LS_with_pillow", "func_name": "test_emri_JPEG_LS_PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG_LS_with_pillow\n    def test_emri_JPEG_LS_PixelArray(self):\n        \"\"\"Test decoding JPEG LS with pillow handler fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.emri_jpeg_ls_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg_ls_with_pillow", "def", "test_emri_jpeg_ls_pixelarray", "self", "test", "decoding", "jpeg", "ls", "with", "pillow", "handler", "fails", "with", "pytest", "raises", "notimplementederror", "self", "emri_jpeg_ls_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_2k = dcmread(jpeg2000_name)\n        self.jpeg_2k_lossless = dcmread(jpeg2000_lossless_name)\n        self.mr_small = dcmread(mr_name)\n        self.emri_jpeg_2k_lossless = dcmread(emri_jpeg_2k_lossless)\n        self.emri_small = dcmread(emri_name)\n        self.sc_rgb_jpeg2k_gdcm_KY = dcmread(sc_rgb_jpeg2k_gdcm_KY)\n        self.ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm = dcmread(\n            ground_truth_sc_rgb_jpeg2k_gdcm_KY_gdcm)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [pillow_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_2k", "dcmread", "jpeg2000_name", "self", "jpeg_2k_lossless", "dcmread", "jpeg2000_lossless_name", "self", "mr_small", "dcmread", "mr_name", "self", "emri_jpeg_2k_lossless", "dcmread", "emri_jpeg_2k_lossless", "self", "emri_small", "dcmread", "emri_name", "self", "sc_rgb_jpeg2k_gdcm_ky", "dcmread", "sc_rgb_jpeg2k_gdcm_ky", "self", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm", "dcmread", "ground_truth_sc_rgb_jpeg2k_gdcm_ky_gdcm", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "numpy_handler"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.test_raises_if_endianess_not_set", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "test_raises_if_endianess_not_set", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def test_raises_if_endianess_not_set(self):\n        self.jpeg_2k_lossless.is_little_endian = None\n        with pytest.raises(ValueError):\n            _ = self.jpeg_2k_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "test_raises_if_endianess_not_set", "self", "self", "jpeg_2k_lossless", "is_little_endian", "none", "with", "pytest", "raises", "valueerror", "_", "self", "jpeg_2k_lossless", "pixel_array"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.testJPEG2000", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "testJPEG2000", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def testJPEG2000(self):\n        \"\"\"Test reading element values works OK with pillow pixel handler.\"\"\"\n        # XX also tests multiple-valued AT data element\n        got = self.jpeg_2k.FrameIncrementPointer\n        assert [Tag(0x0054, 0x0010), Tag(0x0054, 0x0020)] == got\n\n        got = self.jpeg_2k.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "testjpeg2000", "self", "test", "reading", "element", "values", "works", "ok", "with", "pillow", "pixel", "handler", "xx", "also", "tests", "multiple", "valued", "at", "data", "element", "got", "self", "jpeg_2k", "frameincrementpointer", "assert", "tag", "0x0054", "0x0010", "tag", "0x0054", "0x0020", "got", "got", "self", "jpeg_2k", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.testJPEG2000PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "testJPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def testJPEG2000PixelArray(self):\n        \"\"\"Test decoding JPEG2K with pillow handler succeeds.\"\"\"\n        a = self.jpeg_2k_lossless.pixel_array\n        b = self.mr_small.pixel_array\n        assert np.array_equal(a, b)\n\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "testjpeg2000pixelarray", "self", "test", "decoding", "jpeg2k", "with", "pillow", "handler", "succeeds", "a", "self", "jpeg_2k_lossless", "pixel_array", "b", "self", "mr_small", "pixel_array", "assert", "np", "array_equal", "a", "b", "assert", "a", "flags", "writeable"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.test_emri_JPEG2000PixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "test_emri_JPEG2000PixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def test_emri_JPEG2000PixelArray(self):\n        \"\"\"Test decoding JPEG2K with pillow handler succeeds.\"\"\"\n        a = self.emri_jpeg_2k_lossless.pixel_array\n        b = self.emri_small.pixel_array\n        assert np.array_equal(a, b)\n\n        assert a.flags.writeable\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "test_emri_jpeg2000pixelarray", "self", "test", "decoding", "jpeg2k", "with", "pillow", "handler", "succeeds", "a", "self", "emri_jpeg_2k_lossless", "pixel_array", "b", "self", "emri_small", "pixel_array", "assert", "np", "array_equal", "a", "b", "assert", "a", "flags", "writeable"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEG2000Tests_with_pillow.test_jpeg2000_lossy", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEG2000Tests_with_pillow", "func_name": "test_jpeg2000_lossy", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEG2000Tests_with_pillow\n    def test_jpeg2000_lossy(self):\n        \"\"\"Test decoding JPEG2K lossy with pillow handler fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.sc_rgb_jpeg2k_gdcm_KY.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeg2000tests_with_pillow", "def", "test_jpeg2000_lossy", "self", "test", "decoding", "jpeg2k", "lossy", "with", "pillow", "handler", "fails", "with", "pytest", "raises", "notimplementederror", "self", "sc_rgb_jpeg2k_gdcm_ky", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_lossy = dcmread(jpeg_lossy_name)\n        self.color_3d_jpeg = dcmread(color_3d_jpeg_baseline)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [pillow_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_lossy", "dcmread", "jpeg_lossy_name", "self", "color_3d_jpeg", "dcmread", "color_3d_jpeg_baseline", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "numpy_handler"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.testJPEGlossless_odd_data_size", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "testJPEGlossless_odd_data_size", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def testJPEGlossless_odd_data_size(self):\n        \"\"\"Test decoding JPEG with pillow handler succeeds.\"\"\"\n        test_file = get_testdata_files('SC_rgb_small_odd_jpeg.dcm')[0]\n        ds = dcmread(test_file)\n        pixel_data = ds.pixel_array\n        assert pixel_data.nbytes == 27\n        assert pixel_data.shape == (3, 3, 3)\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "testjpeglossless_odd_data_size", "self", "test", "decoding", "jpeg", "with", "pillow", "handler", "succeeds", "test_file", "get_testdata_files", "sc_rgb_small_odd_jpeg", "dcm", "0", "ds", "dcmread", "test_file", "pixel_data", "ds", "pixel_array", "assert", "pixel_data", "nbytes", "27", "assert", "pixel_data", "shape", "3", "3", "3"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.testJPEGlossy", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "testJPEGlossy", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def testJPEGlossy(self):\n        \"\"\"Test reading element values works OK with pillow pixel handler.\"\"\"\n        got = self.jpeg_lossy.DerivationCodeSequence[0].CodeMeaning\n        assert 'Lossy Compression' == got\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "testjpeglossy", "self", "test", "reading", "element", "values", "works", "ok", "with", "pillow", "pixel", "handler", "got", "self", "jpeg_lossy", "derivationcodesequence", "0", "codemeaning", "assert", "lossy", "compression", "got"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.testJPEGlossyPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "testJPEGlossyPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def testJPEGlossyPixelArray(self):\n        \"\"\"Test decoding JPEG lossy with pillow handler fails.\"\"\"\n        with pytest.raises(NotImplementedError):\n            self.jpeg_lossy.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "testjpeglossypixelarray", "self", "test", "decoding", "jpeg", "lossy", "with", "pillow", "handler", "fails", "with", "pytest", "raises", "notimplementederror", "self", "jpeg_lossy", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlossyTests_with_pillow.testJPEGBaselineColor3DPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlossyTests_with_pillow", "func_name": "testJPEGBaselineColor3DPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlossyTests_with_pillow\n    def testJPEGBaselineColor3DPixelArray(self):\n        \"\"\"Test decoding JPEG with pillow handler succeeds.\"\"\"\n        assert \"YBR_FULL_422\" == self.color_3d_jpeg.PhotometricInterpretation\n\n        a = self.color_3d_jpeg.pixel_array\n\n        assert a.flags.writeable\n\n        assert (120, 480, 640, 3) == a.shape\n        # this test points were manually identified in Osirix viewer\n        assert (41, 41, 41) == tuple(a[3, 159, 290, :])\n        assert (57, 57, 57) == tuple(a[3, 169, 290, :])\n\n        assert \"YBR_FULL_422\" == self.color_3d_jpeg.PhotometricInterpretation\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglossytests_with_pillow", "def", "testjpegbaselinecolor3dpixelarray", "self", "test", "decoding", "jpeg", "with", "pillow", "handler", "succeeds", "assert", "ybr_full_422", "self", "color_3d_jpeg", "photometricinterpretation", "a", "self", "color_3d_jpeg", "pixel_array", "assert", "a", "flags", "writeable", "assert", "120", "480", "640", "3", "a", "shape", "this", "test", "points", "were", "manually", "identified", "in", "osirix", "viewer", "assert", "41", "41", "41", "tuple", "a", "3", "159", "290", "assert", "57", "57", "57", "tuple", "a", "3", "169", "290", "assert", "ybr_full_422", "self", "color_3d_jpeg", "photometricinterpretation"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::test_with_pillow", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": null, "func_name": "test_with_pillow", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py\ndef test_with_pillow():\n    original_handlers = pydicom.config.pixel_data_handlers\n    pydicom.config.pixel_data_handlers = [pillow_handler, numpy_handler]\n    yield original_handlers\n    pydicom.config.pixel_data_handlers = original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "def", "test_with_pillow", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "numpy_handler", "yield", "original_handlers", "pydicom", "config", "pixel_data_handlers", "original_handlers"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::test_PI_RGB", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": null, "func_name": "test_PI_RGB", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py\ndef test_PI_RGB(test_with_pillow,\n                image,\n                PhotometricInterpretation,\n                results,\n                ground_truth):\n    t = dcmread(image)\n    assert t.PhotometricInterpretation == PhotometricInterpretation\n    a = t.pixel_array\n    assert a.shape == (100, 100, 3)\n\n    assert a.flags.writeable\n    \"\"\"\n    This complete test never gave a different result than\n    just the 10 point test below\n\n    gt = dcmread(ground_truth)\n    b = gt.pixel_array\n    for x in range(100):\n        for y in range(100):\n            assert tuple(a[x, y]) == tuple(b[x, y])\n    \"\"\"\n    # this test points are from the ImageComments tag\n    assert tuple(a[5, 50, :]) == results[0]\n    assert tuple(a[15, 50, :]) == results[1]\n    assert tuple(a[25, 50, :]) == results[2]\n    assert tuple(a[35, 50, :]) == results[3]\n    assert tuple(a[45, 50, :]) == results[4]\n    assert tuple(a[55, 50, :]) == results[5]\n    assert tuple(a[65, 50, :]) == results[6]\n    assert tuple(a[75, 50, :]) == results[7]\n    assert tuple(a[85, 50, :]) == results[8]\n    assert tuple(a[95, 50, :]) == results[9]\n    assert t.PhotometricInterpretation == PhotometricInterpretation\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "def", "test_pi_rgb", "test_with_pillow", "image", "photometricinterpretation", "results", "ground_truth", "t", "dcmread", "image", "assert", "t", "photometricinterpretation", "photometricinterpretation", "a", "t", "pixel_array", "assert", "a", "shape", "100", "100", "3", "assert", "a", "flags", "writeable", "this", "complete", "test", "never", "gave", "a", "different", "result", "than", "just", "the", "10", "point", "test", "below", "gt", "dcmread", "ground_truth", "b", "gt", "pixel_array", "for", "x", "in", "range", "100", "for", "y", "in", "range", "100", "assert", "tuple", "a", "x", "y", "tuple", "b", "x", "y", "this", "test", "points", "are", "from", "the", "imagecomments", "tag", "assert", "tuple", "a", "5", "50", "results", "0", "assert", "tuple", "a", "15", "50", "results", "1", "assert", "tuple", "a", "25", "50", "results", "2", "assert", "tuple", "a", "35", "50", "results", "3", "assert", "tuple", "a", "45", "50", "results", "4", "assert", "tuple", "a", "55", "50", "results", "5", "assert", "tuple", "a", "65", "50", "results", "6", "assert", "tuple", "a", "75", "50", "results", "7", "assert", "tuple", "a", "85", "50", "results", "8", "assert", "tuple", "a", "95", "50", "results", "9", "assert", "t", "photometricinterpretation", "photometricinterpretation"], "doc_len": 153}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_with_pillow.setup", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_with_pillow", "func_name": "setup", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_with_pillow\n    def setup(self):\n        \"\"\"Setup the test datasets.\"\"\"\n        self.jpeg_lossless = dcmread(jpeg_lossless_name)\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [pillow_handler, numpy_handler]\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_with_pillow", "def", "setup", "self", "setup", "the", "test", "datasets", "self", "jpeg_lossless", "dcmread", "jpeg_lossless_name", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "pillow_handler", "numpy_handler"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_with_pillow.teardown", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_with_pillow", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_with_pillow\n    def teardown(self):\n        \"\"\"Reset the pixel data handlers.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_with_pillow", "def", "teardown", "self", "reset", "the", "pixel", "data", "handlers", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 18}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_with_pillow.testJPEGlossless", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_with_pillow", "func_name": "testJPEGlossless", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_with_pillow\n    def testJPEGlossless(self):\n        \"\"\"Test reading element values works OK with pillow pixel handler.\"\"\"\n        got = self.jpeg_lossless.SourceImageSequence[0]\n        got = got.PurposeOfReferenceCodeSequence[0].CodeMeaning\n        assert 'Uncompressed predecessor' == got\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_with_pillow", "def", "testjpeglossless", "self", "test", "reading", "element", "values", "works", "ok", "with", "pillow", "pixel", "handler", "got", "self", "jpeg_lossless", "sourceimagesequence", "0", "got", "got", "purposeofreferencecodesequence", "0", "codemeaning", "assert", "uncompressed", "predecessor", "got"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_pillow_pixel_data.py::Test_JPEGlosslessTests_with_pillow.testJPEGlosslessPixelArray", "file_path": "pydicom/tests/test_pillow_pixel_data.py", "class_name": "Test_JPEGlosslessTests_with_pillow", "func_name": "testJPEGlosslessPixelArray", "text": "文件路径: pydicom/tests/test_pillow_pixel_data.py, 类名: Test_JPEGlosslessTests_with_pillow\n    def testJPEGlosslessPixelArray(self):\n        \"\"\"Test decoding JPEG lossless with pillow handler fails.\"\"\"\n        with pytest.raises(RuntimeError):\n            self.jpeg_lossless.pixel_array\n", "tokens": ["pydicom", "tests", "test_pillow_pixel_data", "py", "test_jpeglosslesstests_with_pillow", "def", "testjpeglosslesspixelarray", "self", "test", "decoding", "jpeg", "lossless", "with", "pillow", "handler", "fails", "with", "pytest", "raises", "runtimeerror", "self", "jpeg_lossless", "pixel_array"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawReaderExplVRTests.testExplVRLittleEndianLongLength", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawReaderExplVRTests", "func_name": "testExplVRLittleEndianLongLength", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawReaderExplVRTests\n    def testExplVRLittleEndianLongLength(self):\n        \"\"\"Raw read: Explicit VR Little Endian long length...\"\"\"\n        # (0002,0001) OB 2-byte-reserved 4-byte-length, value 0x00 0x01\n        bytes_input = \"02 00 01 00 4f 42 00 00 02 00 00 00 00 01\"\n        infile = BytesIO(hex2bytes(bytes_input))\n        expected = ((2, 1), 'OB',\n                    2, b'\\00\\01',\n                    0xc, False, True)\n\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=False,\n                                        is_little_endian=True)\n        assert expected == next(de_gen)\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawreaderexplvrtests", "def", "testexplvrlittleendianlonglength", "self", "raw", "read", "explicit", "vr", "little", "endian", "long", "length", "0002", "0001", "ob", "2", "byte", "reserved", "4", "byte", "length", "value", "0x00", "0x01", "bytes_input", "02", "00", "01", "00", "4f", "42", "00", "00", "02", "00", "00", "00", "00", "01", "infile", "bytesio", "hex2bytes", "bytes_input", "expected", "2", "1", "ob", "2", "b", "00", "01", "0xc", "false", "true", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "false", "is_little_endian", "true", "assert", "expected", "next", "de_gen"], "doc_len": 69}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawReaderExplVRTests.testExplVRLittleEndianShortLength", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawReaderExplVRTests", "func_name": "testExplVRLittleEndianShortLength", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawReaderExplVRTests\n    def testExplVRLittleEndianShortLength(self):\n        \"\"\"Raw read: Explicit VR Little Endian short length...\"\"\"\n        # (0008,212a) IS 2-byte-length, value '1 '\n        infile = BytesIO(hex2bytes(\"08 00 2a 21 49 53 02 00 31 20\"))\n        # XXX Assumes that a RawDataElement doesn't convert the value based\n        # upon the VR value, thus it will remain a byte string since that is\n        # the input\n        expected = ((8, 0x212a), 'IS', 2,\n                    b'1 ', 0x8, False, True)\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=False,\n                                        is_little_endian=True)\n        assert expected == next(de_gen)\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawreaderexplvrtests", "def", "testexplvrlittleendianshortlength", "self", "raw", "read", "explicit", "vr", "little", "endian", "short", "length", "0008", "212a", "is", "2", "byte", "length", "value", "1", "infile", "bytesio", "hex2bytes", "08", "00", "2a", "21", "49", "53", "02", "00", "31", "20", "xxx", "assumes", "that", "a", "rawdataelement", "doesn", "t", "convert", "the", "value", "based", "upon", "the", "vr", "value", "thus", "it", "will", "remain", "a", "byte", "string", "since", "that", "is", "the", "input", "expected", "8", "0x212a", "is", "2", "b", "1", "0x8", "false", "true", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "false", "is_little_endian", "true", "assert", "expected", "next", "de_gen"], "doc_len": 85}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawReaderExplVRTests.testExplVRLittleEndianUndefLength", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawReaderExplVRTests", "func_name": "testExplVRLittleEndianUndefLength", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawReaderExplVRTests\n    def testExplVRLittleEndianUndefLength(self):\n        \"\"\"Raw read: Expl VR Little Endian with undefined length...\"\"\"\n        # (7fe0,0010), OB, 2-byte reserved, 4-byte-length (UNDEFINED)\n        hexstr1 = \"e0 7f 10 00 4f 42 00 00 ff ff ff ff\"\n        hexstr2 = \" 41 42 43 44 45 46 47 48 49 4a\"  # 'content'\n        hexstr3 = \" fe ff dd e0 00 00 00 00\"        # Sequence Delimiter\n        hexstr = hexstr1 + hexstr2 + hexstr3\n        infile = BytesIO(hex2bytes(hexstr))\n        expected = ((0x7fe0, 0x10), 'OB',\n                    0xffffffff, b'ABCDEFGHIJ',\n                    0xc, False, True)\n\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=False,\n                                        is_little_endian=True)\n        assert expected == next(de_gen)\n\n        # Test again such that delimiter crosses default 128-byte \"chunks\"\n        for multiplier in (116, 117, 118, 120):\n            multiplier = 116\n            hexstr2b = hexstr2 + \" 00\" * multiplier\n            hexstr = hexstr1 + hexstr2b + hexstr3\n            infile = BytesIO(hex2bytes(hexstr))\n            expected = len('ABCDEFGHIJ' + '\\0' * multiplier)\n            de_gen = data_element_generator(infile,\n                                            is_implicit_VR=False,\n                                            is_little_endian=True)\n            got = next(de_gen)\n            got_len = len(got.value)\n            assert expected == got_len\n            assert got.value.startswith(b'ABCDEFGHIJ\\0')\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawreaderexplvrtests", "def", "testexplvrlittleendianundeflength", "self", "raw", "read", "expl", "vr", "little", "endian", "with", "undefined", "length", "7fe0", "0010", "ob", "2", "byte", "reserved", "4", "byte", "length", "undefined", "hexstr1", "e0", "7f", "10", "00", "4f", "42", "00", "00", "ff", "ff", "ff", "ff", "hexstr2", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "content", "hexstr3", "fe", "ff", "dd", "e0", "00", "00", "00", "00", "sequence", "delimiter", "hexstr", "hexstr1", "hexstr2", "hexstr3", "infile", "bytesio", "hex2bytes", "hexstr", "expected", "0x7fe0", "0x10", "ob", "0xffffffff", "b", "abcdefghij", "0xc", "false", "true", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "false", "is_little_endian", "true", "assert", "expected", "next", "de_gen", "test", "again", "such", "that", "delimiter", "crosses", "default", "128", "byte", "chunks", "for", "multiplier", "in", "116", "117", "118", "120", "multiplier", "116", "hexstr2b", "hexstr2", "00", "multiplier", "hexstr", "hexstr1", "hexstr2b", "hexstr3", "infile", "bytesio", "hex2bytes", "hexstr", "expected", "len", "abcdefghij", "0", "multiplier", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "false", "is_little_endian", "true", "got", "next", "de_gen", "got_len", "len", "got", "value", "assert", "expected", "got_len", "assert", "got", "value", "startswith", "b", "abcdefghij", "0"], "doc_len": 152}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawReaderImplVR.testImplVRLittleEndian", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawReaderImplVR", "func_name": "testImplVRLittleEndian", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawReaderImplVR\n    def testImplVRLittleEndian(self):\n        \"\"\"Raw read: Implicit VR Little Endian...\"\"\"\n        # (0008,212a) {IS} 4-byte-length, value '1 '\n        infile = BytesIO(hex2bytes(\"08 00 2a 21 02 00 00 00 31 20\"))\n\n        expected = ((8, 0x212a),\n                    None, 2, b'1 ',\n                    0x8, True, True)\n\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=True,\n                                        is_little_endian=True)\n        assert expected == next(de_gen)\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawreaderimplvr", "def", "testimplvrlittleendian", "self", "raw", "read", "implicit", "vr", "little", "endian", "0008", "212a", "is", "4", "byte", "length", "value", "1", "infile", "bytesio", "hex2bytes", "08", "00", "2a", "21", "02", "00", "00", "00", "31", "20", "expected", "8", "0x212a", "none", "2", "b", "1", "0x8", "true", "true", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "true", "is_little_endian", "true", "assert", "expected", "next", "de_gen"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawReaderImplVR.testImplVRLittleEndianUndefLength", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawReaderImplVR", "func_name": "testImplVRLittleEndianUndefLength", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawReaderImplVR\n    def testImplVRLittleEndianUndefLength(self):\n        \"\"\"Raw read: Impl VR Little Endian with undefined length...\"\"\"\n        # (7fe0,0010), OB, 2-byte reserved, 4-byte-length (UNDEFINED)\n        hexstr1 = \"e0 7f 10 00 ff ff ff ff\"\n        hexstr2 = \" 41 42 43 44 45 46 47 48 49 4a\"  # 'content'\n        hexstr3 = \" fe ff dd e0 00 00 00 00\"        # Sequence Delimiter\n        hexstr = hexstr1 + hexstr2 + hexstr3\n        infile = BytesIO(hex2bytes(hexstr))\n        expected = ((0x7fe0, 0x10), 'OB or OW',\n                    0xffffffff, b'ABCDEFGHIJ',\n                    0x8, True, True)\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=True,\n                                        is_little_endian=True)\n        assert expected == next(de_gen)\n\n        # Test again such that delimiter crosses default 128-byte \"chunks\"\n        for multiplier in (116, 117, 118, 120):\n            multiplier = 116\n            hexstr2b = hexstr2 + \" 00\" * multiplier\n            hexstr = hexstr1 + hexstr2b + hexstr3\n            infile = BytesIO(hex2bytes(hexstr))\n            expected = len('ABCDEFGHIJ' + '\\0' * multiplier)\n            de_gen = data_element_generator(infile,\n                                            is_implicit_VR=True,\n                                            is_little_endian=True)\n            got = next(de_gen)\n            assert expected == len(got.value)\n            assert got.value.startswith(b'ABCDEFGHIJ\\0')\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawreaderimplvr", "def", "testimplvrlittleendianundeflength", "self", "raw", "read", "impl", "vr", "little", "endian", "with", "undefined", "length", "7fe0", "0010", "ob", "2", "byte", "reserved", "4", "byte", "length", "undefined", "hexstr1", "e0", "7f", "10", "00", "ff", "ff", "ff", "ff", "hexstr2", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "content", "hexstr3", "fe", "ff", "dd", "e0", "00", "00", "00", "00", "sequence", "delimiter", "hexstr", "hexstr1", "hexstr2", "hexstr3", "infile", "bytesio", "hex2bytes", "hexstr", "expected", "0x7fe0", "0x10", "ob", "or", "ow", "0xffffffff", "b", "abcdefghij", "0x8", "true", "true", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "true", "is_little_endian", "true", "assert", "expected", "next", "de_gen", "test", "again", "such", "that", "delimiter", "crosses", "default", "128", "byte", "chunks", "for", "multiplier", "in", "116", "117", "118", "120", "multiplier", "116", "hexstr2b", "hexstr2", "00", "multiplier", "hexstr", "hexstr1", "hexstr2b", "hexstr3", "infile", "bytesio", "hex2bytes", "hexstr", "expected", "len", "abcdefghij", "0", "multiplier", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "true", "is_little_endian", "true", "got", "next", "de_gen", "assert", "expected", "len", "got", "value", "assert", "got", "value", "startswith", "b", "abcdefghij", "0"], "doc_len": 148}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawSequence.testEmptyItem", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawSequence", "func_name": "testEmptyItem", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawSequence\n    def testEmptyItem(self):\n        \"\"\"Read sequence with a single empty item...\"\"\"\n        # This is fix for issue 27\n        hexstr = (\n            \"08 00 32 10\"    # (0008, 1032) SQ \"Procedure Code Sequence\"\n            \" 08 00 00 00\"    # length 8\n            \" fe ff 00 e0\"    # (fffe, e000) Item Tag\n            \" 00 00 00 00\"    # length = 0\n        ) + (             # --------------- end of Sequence\n            \" 08 00 3e 10\"    # (0008, 103e) LO \"Series Description\"  nopep8\n            \" 0c 00 00 00\"    # length     nopep8\n            \" 52 20 41 44 44 20 56 49 45 57 53 20\"  # value     nopep8\n        )\n        # \"\\x08\\x00\\x32\\x10\\x08\\x00\\x00\\x00\\xfe\\xff\\x00\\xe0\\x00\\x00\\x00\\x00\"\n        # from issue 27, procedure code sequence (0008,1032)\n        # hexstr += \"\\x08\\x00\\x3e\\x10\\x0c\\x00\\x00\\x00\\x52\\x20\n        # \\x41\\x44\\x44\\x20\\x56\\x49\\x45\\x57\\x53\\x20\"\n        # data element following\n\n        fp = BytesIO(hex2bytes(hexstr))\n        gen = data_element_generator(fp,\n                                     is_implicit_VR=True,\n                                     is_little_endian=True)\n        raw_seq = next(gen)\n        seq = convert_value(\"SQ\", raw_seq)\n        assert isinstance(seq, Sequence)\n        assert 1 == len(seq)\n        assert 0 == len(seq[0])\n        elem2 = next(gen)\n        assert 0x0008103e == elem2.tag\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawsequence", "def", "testemptyitem", "self", "read", "sequence", "with", "a", "single", "empty", "item", "this", "is", "fix", "for", "issue", "27", "hexstr", "08", "00", "32", "10", "0008", "1032", "sq", "procedure", "code", "sequence", "08", "00", "00", "00", "length", "8", "fe", "ff", "00", "e0", "fffe", "e000", "item", "tag", "00", "00", "00", "00", "length", "0", "end", "of", "sequence", "08", "00", "3e", "10", "0008", "103e", "lo", "series", "description", "nopep8", "0c", "00", "00", "00", "length", "nopep8", "52", "20", "41", "44", "44", "20", "56", "49", "45", "57", "53", "20", "value", "nopep8", "x08", "x00", "x32", "x10", "x08", "x00", "x00", "x00", "xfe", "xff", "x00", "xe0", "x00", "x00", "x00", "x00", "from", "issue", "27", "procedure", "code", "sequence", "0008", "1032", "hexstr", "x08", "x00", "x3e", "x10", "x0c", "x00", "x00", "x00", "x52", "x20", "x41", "x44", "x44", "x20", "x56", "x49", "x45", "x57", "x53", "x20", "data", "element", "following", "fp", "bytesio", "hex2bytes", "hexstr", "gen", "data_element_generator", "fp", "is_implicit_vr", "true", "is_little_endian", "true", "raw_seq", "next", "gen", "seq", "convert_value", "sq", "raw_seq", "assert", "isinstance", "seq", "sequence", "assert", "1", "len", "seq", "assert", "0", "len", "seq", "0", "elem2", "next", "gen", "assert", "0x0008103e", "elem2", "tag"], "doc_len": 171}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawSequence.testImplVRLittleEndian_ExplicitLengthSeq", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawSequence", "func_name": "testImplVRLittleEndian_ExplicitLengthSeq", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawSequence\n    def testImplVRLittleEndian_ExplicitLengthSeq(self):\n        \"\"\"Raw read: ImplVR Little Endian SQ with explicit lengths...\"\"\"\n        # Create a fictional sequence with bytes directly,\n        #    similar to PS 3.5-2008 Table 7.5-1 p42\n        hexstr = (\n            \"0a 30 B0 00\"    # (300a, 00b0) Beam Sequence\n            \" 40 00 00 00\"    # length\n            \" fe ff 00 e0\"    # (fffe, e000) Item Tag\n            \" 18 00 00 00\"    # Item (dataset) Length\n            \" 0a 30 c0 00\"    # (300A, 00C0) Beam Number\n            \" 02 00 00 00\"    # length\n            \" 31 20\"          # value '1 '\n            \" 0a 30 c2 00\"    # (300A, 00C2) Beam Name\n            \" 06 00 00 00\"    # length\n            \" 42 65 61 6d 20 31\"  # value 'Beam 1'\n            # -------------\n            \" fe ff 00 e0\"    # (fffe, e000) Item Tag\n            \" 18 00 00 00\"    # Item (dataset) Length\n            \" 0a 30 c0 00\"    # (300A, 00C0) Beam Number\n            \" 02 00 00 00\"    # length\n            \" 32 20\"          # value '2 '\n            \" 0a 30 c2 00\"    # (300A, 00C2) Beam Name\n            \" 06 00 00 00\"    # length\n            \" 42 65 61 6d 20 32\"  # value 'Beam 2'\n        )\n\n        infile = BytesIO(hex2bytes(hexstr))\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=True,\n                                        is_little_endian=True)\n        raw_seq = next(de_gen)\n        seq = convert_value(\"SQ\", raw_seq)\n\n        # The sequence is parsed, but only into raw data elements.\n        # They will be converted when asked for. Check some:\n        assert 1 == seq[0].BeamNumber\n        assert 'Beam 2' == seq[1].BeamName\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawsequence", "def", "testimplvrlittleendian_explicitlengthseq", "self", "raw", "read", "implvr", "little", "endian", "sq", "with", "explicit", "lengths", "create", "a", "fictional", "sequence", "with", "bytes", "directly", "similar", "to", "ps", "3", "5", "2008", "table", "7", "5", "1", "p42", "hexstr", "0a", "30", "b0", "00", "300a", "00b0", "beam", "sequence", "40", "00", "00", "00", "length", "fe", "ff", "00", "e0", "fffe", "e000", "item", "tag", "18", "00", "00", "00", "item", "dataset", "length", "0a", "30", "c0", "00", "300a", "00c0", "beam", "number", "02", "00", "00", "00", "length", "31", "20", "value", "1", "0a", "30", "c2", "00", "300a", "00c2", "beam", "name", "06", "00", "00", "00", "length", "42", "65", "61", "6d", "20", "31", "value", "beam", "1", "fe", "ff", "00", "e0", "fffe", "e000", "item", "tag", "18", "00", "00", "00", "item", "dataset", "length", "0a", "30", "c0", "00", "300a", "00c0", "beam", "number", "02", "00", "00", "00", "length", "32", "20", "value", "2", "0a", "30", "c2", "00", "300a", "00c2", "beam", "name", "06", "00", "00", "00", "length", "42", "65", "61", "6d", "20", "32", "value", "beam", "2", "infile", "bytesio", "hex2bytes", "hexstr", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "true", "is_little_endian", "true", "raw_seq", "next", "de_gen", "seq", "convert_value", "sq", "raw_seq", "the", "sequence", "is", "parsed", "but", "only", "into", "raw", "data", "elements", "they", "will", "be", "converted", "when", "asked", "for", "check", "some", "assert", "1", "seq", "0", "beamnumber", "assert", "beam", "2", "seq", "1", "beamname"], "doc_len": 205}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawSequence.testImplVRBigEndian_ExplicitLengthSeq", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawSequence", "func_name": "testImplVRBigEndian_ExplicitLengthSeq", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawSequence\n    def testImplVRBigEndian_ExplicitLengthSeq(self):\n        \"\"\"Raw read: ImplVR BigEndian SQ with explicit lengths...\"\"\"\n        # Create a fictional sequence with bytes directly,\n        #    similar to PS 3.5-2008 Table 7.5-1 p42\n        hexstr = (\n            \"30 0a 00 B0\"    # (300a, 00b0) Beam Sequence\n            \" 00 00 00 40\"    # length\n            \" ff fe e0 00\"    # (fffe, e000) Item Tag\n            \" 00 00 00 18\"    # Item (dataset) Length\n            \" 30 0a 00 c0\"    # (300A, 00C0) Beam Number\n            \" 00 00 00 02\"    # length\n            \" 31 20\"          # value '1 '\n            \" 30 0a 00 c2\"    # (300A, 00C2) Beam Name\n            \" 00 00 00 06\"    # length\n            \" 42 65 61 6d 20 31\"  # value 'Beam 1'\n            # -------------\n            \" ff fe e0 00\"    # (fffe, e000) Item Tag\n            \" 00 00 00 18\"    # Item (dataset) Length\n            \" 30 0a 00 c0\"    # (300A, 00C0) Beam Number\n            \" 00 00 00 02\"    # length\n            \" 32 20\"          # value '2 '\n            \" 30 0a 00 c2\"    # (300A, 00C2) Beam Name\n            \" 00 00 00 06\"    # length\n            \" 42 65 61 6d 20 32\"  # value 'Beam 2'\n        )\n\n        infile = BytesIO(hex2bytes(hexstr))\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=True,\n                                        is_little_endian=False)\n        raw_seq = next(de_gen)\n        seq = convert_value(\"SQ\", raw_seq)\n\n        # The sequence is parsed, but only into raw data elements.\n        # They will be converted when asked for. Check some:\n        assert 1 == seq[0].BeamNumber\n        assert 'Beam 2' == seq[1].BeamName\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawsequence", "def", "testimplvrbigendian_explicitlengthseq", "self", "raw", "read", "implvr", "bigendian", "sq", "with", "explicit", "lengths", "create", "a", "fictional", "sequence", "with", "bytes", "directly", "similar", "to", "ps", "3", "5", "2008", "table", "7", "5", "1", "p42", "hexstr", "30", "0a", "00", "b0", "300a", "00b0", "beam", "sequence", "00", "00", "00", "40", "length", "ff", "fe", "e0", "00", "fffe", "e000", "item", "tag", "00", "00", "00", "18", "item", "dataset", "length", "30", "0a", "00", "c0", "300a", "00c0", "beam", "number", "00", "00", "00", "02", "length", "31", "20", "value", "1", "30", "0a", "00", "c2", "300a", "00c2", "beam", "name", "00", "00", "00", "06", "length", "42", "65", "61", "6d", "20", "31", "value", "beam", "1", "ff", "fe", "e0", "00", "fffe", "e000", "item", "tag", "00", "00", "00", "18", "item", "dataset", "length", "30", "0a", "00", "c0", "300a", "00c0", "beam", "number", "00", "00", "00", "02", "length", "32", "20", "value", "2", "30", "0a", "00", "c2", "300a", "00c2", "beam", "name", "00", "00", "00", "06", "length", "42", "65", "61", "6d", "20", "32", "value", "beam", "2", "infile", "bytesio", "hex2bytes", "hexstr", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "true", "is_little_endian", "false", "raw_seq", "next", "de_gen", "seq", "convert_value", "sq", "raw_seq", "the", "sequence", "is", "parsed", "but", "only", "into", "raw", "data", "elements", "they", "will", "be", "converted", "when", "asked", "for", "check", "some", "assert", "1", "seq", "0", "beamnumber", "assert", "beam", "2", "seq", "1", "beamname"], "doc_len": 204}
{"doc_id": "pydicom/tests/test_rawread.py::TestRawSequence.testExplVRBigEndian_UndefinedLengthSeq", "file_path": "pydicom/tests/test_rawread.py", "class_name": "TestRawSequence", "func_name": "testExplVRBigEndian_UndefinedLengthSeq", "text": "文件路径: pydicom/tests/test_rawread.py, 类名: TestRawSequence\n    def testExplVRBigEndian_UndefinedLengthSeq(self):\n        \"\"\"Raw read: ExplVR BigEndian Undefined Length SQ...\"\"\"\n        # Create a fictional sequence with bytes directly,\n        #    similar to PS 3.5-2008 Table 7.5-2 p42\n        hexstr = (\n            \"30 0a 00 B0\"    # (300a, 00b0) Beam Sequence\n            \" 53 51\"         # SQ\n            \" 00 00\"         # reserved\n            \" ff ff ff ff\"    # undefined length\n            \" ff fe e0 00\"    # (fffe, e000) Item Tag\n            \" 00 00 00 18\"    # Item (dataset) Length\n            \" 30 0a 00 c0\"    # (300A, 00C0) Beam Number\n            \" 49 53\"          # IS\n            \" 00 02\"          # length\n            \" 31 20\"          # value '1 '\n            \" 30 0a 00 c2\"    # (300A, 00C2) Beam Name\n            \" 4c 4F\"          # LO\n            \" 00 06\"          # length\n            \" 42 65 61 6d 20 31\"  # value 'Beam 1'\n            # -------------\n            \" ff fe e0 00\"    # (fffe, e000) Item Tag\n            \" 00 00 00 18\"    # Item (dataset) Length\n            \" 30 0a 00 c0\"    # (300A, 00C0) Beam Number\n            \" 49 53\"          # IS\n            \" 00 02\"          # length\n            \" 32 20\"          # value '2 '\n            \" 30 0a 00 c2\"    # (300A, 00C2) Beam Name\n            \" 4C 4F\"          # LO\n            \" 00 06\"          # length\n            \" 42 65 61 6d 20 32\"  # value 'Beam 2'\n            \" ff fe E0 dd\"    # SQ delimiter\n            \" 00 00 00 00\"    # zero length\n        )\n\n        infile = BytesIO(hex2bytes(hexstr))\n        de_gen = data_element_generator(infile,\n                                        is_implicit_VR=False,\n                                        is_little_endian=False)\n        seq = next(de_gen)\n        # Note seq itself is not a raw data element.\n        #     The parser does parse undefined length SQ\n\n        # The sequence is parsed, but only into raw data elements.\n        # They will be converted when asked for. Check some:\n        assert 1 == seq[0].BeamNumber\n        assert 'Beam 2' == seq[1].BeamName\n", "tokens": ["pydicom", "tests", "test_rawread", "py", "testrawsequence", "def", "testexplvrbigendian_undefinedlengthseq", "self", "raw", "read", "explvr", "bigendian", "undefined", "length", "sq", "create", "a", "fictional", "sequence", "with", "bytes", "directly", "similar", "to", "ps", "3", "5", "2008", "table", "7", "5", "2", "p42", "hexstr", "30", "0a", "00", "b0", "300a", "00b0", "beam", "sequence", "53", "51", "sq", "00", "00", "reserved", "ff", "ff", "ff", "ff", "undefined", "length", "ff", "fe", "e0", "00", "fffe", "e000", "item", "tag", "00", "00", "00", "18", "item", "dataset", "length", "30", "0a", "00", "c0", "300a", "00c0", "beam", "number", "49", "53", "is", "00", "02", "length", "31", "20", "value", "1", "30", "0a", "00", "c2", "300a", "00c2", "beam", "name", "4c", "4f", "lo", "00", "06", "length", "42", "65", "61", "6d", "20", "31", "value", "beam", "1", "ff", "fe", "e0", "00", "fffe", "e000", "item", "tag", "00", "00", "00", "18", "item", "dataset", "length", "30", "0a", "00", "c0", "300a", "00c0", "beam", "number", "49", "53", "is", "00", "02", "length", "32", "20", "value", "2", "30", "0a", "00", "c2", "300a", "00c2", "beam", "name", "4c", "4f", "lo", "00", "06", "length", "42", "65", "61", "6d", "20", "32", "value", "beam", "2", "ff", "fe", "e0", "dd", "sq", "delimiter", "00", "00", "00", "00", "zero", "length", "infile", "bytesio", "hex2bytes", "hexstr", "de_gen", "data_element_generator", "infile", "is_implicit_vr", "false", "is_little_endian", "false", "seq", "next", "de_gen", "note", "seq", "itself", "is", "not", "a", "raw", "data", "element", "the", "parser", "does", "parse", "undefined", "length", "sq", "the", "sequence", "is", "parsed", "but", "only", "into", "raw", "data", "elements", "they", "will", "be", "converted", "when", "asked", "for", "check", "some", "assert", "1", "seq", "0", "beamnumber", "assert", "beam", "2", "seq", "1", "beamname"], "doc_len": 238}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::test_unsupported_syntaxes", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": null, "func_name": "test_unsupported_syntaxes", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py\ndef test_unsupported_syntaxes():\n    \"\"\"Test that UNSUPPORTED_SYNTAXES is as expected.\"\"\"\n    assert RLELossless not in UNSUPPORTED_SYNTAXES\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "def", "test_unsupported_syntaxes", "test", "that", "unsupported_syntaxes", "is", "as", "expected", "assert", "rlelossless", "not", "in", "unsupported_syntaxes"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::_get_pixel_array", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": null, "func_name": "_get_pixel_array", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py\ndef _get_pixel_array(fpath):\n    \"\"\"Return the pixel data as a numpy ndarray.\n\n    Only suitable for transfer syntaxes supported by the numpy pixel data\n    handler.\n\n    Parameters\n    ----------\n    fpath : str\n        Path to the dataset containing the Pixel Data.\n\n    Returns\n    -------\n    numpy.ndarray\n    \"\"\"\n    if not HAVE_NP:\n        raise RuntimeError(\n            'Function only usable if the numpy handler is available'\n        )\n\n    original_handlers = pydicom.config.pixel_data_handlers\n    pydicom.config.pixel_data_handlers = [NP_HANDLER]\n\n    ds = dcmread(fpath)\n    arr = ds.pixel_array\n\n    pydicom.config.pixel_data_handlers = original_handlers\n\n    return arr\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "def", "_get_pixel_array", "fpath", "return", "the", "pixel", "data", "as", "a", "numpy", "ndarray", "only", "suitable", "for", "transfer", "syntaxes", "supported", "by", "the", "numpy", "pixel", "data", "handler", "parameters", "fpath", "str", "path", "to", "the", "dataset", "containing", "the", "pixel", "data", "returns", "numpy", "ndarray", "if", "not", "have_np", "raise", "runtimeerror", "function", "only", "usable", "if", "the", "numpy", "handler", "is", "available", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "np_handler", "ds", "dcmread", "fpath", "arr", "ds", "pixel_array", "pydicom", "config", "pixel_data_handlers", "original_handlers", "return", "arr"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.setup", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.teardown", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.test_environment", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert not HAVE_NP\n        # The RLE handler should still be available\n        assert RLE_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "not", "have_np", "the", "rle", "handler", "should", "still", "be", "available", "assert", "rle_handler", "is", "not", "none"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in an RLE dataset.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 6128 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "an", "rle", "dataset", "ds", "dcmread", "rle_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "6128", "len", "ds", "pixeldata"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_NoRLEHandler.test_pixel_array_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_NoRLEHandler", "func_name": "test_pixel_array_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_NoRLEHandler\n    def test_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for all syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in ALL_TRANSFER_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"Unable to decode pixel data with a transfer syntax UID of \"\n                r\"'{}'\".format(uid)\n            )\n            with pytest.raises(NotImplementedError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_norlehandler", "def", "test_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "all", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "all_transfer_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "format", "uid", "with", "pytest", "raises", "notimplementederror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.setup", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [RLE_HANDLER]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "rle_handler"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.teardown", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.test_environment", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert not HAVE_NP\n        # The RLE handler should still be available\n        assert RLE_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "not", "have_np", "the", "rle", "handler", "should", "still", "be", "available", "assert", "rle_handler", "is", "not", "none"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in an RLE dataset.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 6128 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "an", "rle", "dataset", "ds", "dcmread", "rle_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "6128", "len", "ds", "pixeldata"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.test_unsupported_pixel_array_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "test_unsupported_pixel_array_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def test_unsupported_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for unsupported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in UNSUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"Unable to decode pixel data with a transfer syntax UID of \"\n                r\"'{}'\".format(uid)\n            )\n            with pytest.raises(RuntimeError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "test_unsupported_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "unsupported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "unsupported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "format", "uid", "with", "pytest", "raises", "runtimeerror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNoNumpy_RLEHandler.test_supported_pixel_array_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNoNumpy_RLEHandler", "func_name": "test_supported_pixel_array_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNoNumpy_RLEHandler\n    def test_supported_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for supported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in SUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"The following handlers are available to decode the pixel \"\n                r\"data however they are missing required dependencies: \"\n                r\"RLE Lossless \\(req. NumPy\\)\"\n            )\n            with pytest.raises(RuntimeError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnonumpy_rlehandler", "def", "test_supported_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "supported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "supported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "the", "following", "handlers", "are", "available", "to", "decode", "the", "pixel", "r", "data", "however", "they", "are", "missing", "required", "dependencies", "r", "rle", "lossless", "req", "numpy", "with", "pytest", "raises", "runtimeerror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.setup", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = []\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.teardown", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.test_environment", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert HAVE_NP\n        # The RLE handler should still be available\n        assert RLE_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "have_np", "the", "rle", "handler", "should", "still", "be", "available", "assert", "rle_handler", "is", "not", "none"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.test_can_access_supported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "test_can_access_supported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def test_can_access_supported_dataset(self):\n        \"\"\"Test that we can read and access elements in an RLE dataset.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        assert 'CompressedSamples^MR1' == ds.PatientName\n        assert 6128 == len(ds.PixelData)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "test_can_access_supported_dataset", "self", "test", "that", "we", "can", "read", "and", "access", "elements", "in", "an", "rle", "dataset", "ds", "dcmread", "rle_16_1_1f", "assert", "compressedsamples", "mr1", "ds", "patientname", "assert", "6128", "len", "ds", "pixeldata"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_NoRLEHandler.test_pixel_array_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_NoRLEHandler", "func_name": "test_pixel_array_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_NoRLEHandler\n    def test_pixel_array_raises(self):\n        \"\"\"Test pixel_array raises exception for all syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in ALL_TRANSFER_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"Unable to decode pixel data with a transfer syntax UID of \"\n                r\"'{}'\".format(uid)\n            )\n            with pytest.raises(NotImplementedError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_norlehandler", "def", "test_pixel_array_raises", "self", "test", "pixel_array", "raises", "exception", "for", "all", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "all_transfer_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "format", "uid", "with", "pytest", "raises", "notimplementederror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.setup", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "setup", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def setup(self):\n        \"\"\"Setup the environment.\"\"\"\n        self.original_handlers = pydicom.config.pixel_data_handlers\n        pydicom.config.pixel_data_handlers = [RLE_HANDLER]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "setup", "self", "setup", "the", "environment", "self", "original_handlers", "pydicom", "config", "pixel_data_handlers", "pydicom", "config", "pixel_data_handlers", "rle_handler"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.teardown", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def teardown(self):\n        \"\"\"Restore the environment.\"\"\"\n        pydicom.config.pixel_data_handlers = self.original_handlers\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "teardown", "self", "restore", "the", "environment", "pydicom", "config", "pixel_data_handlers", "self", "original_handlers"], "doc_len": 16}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_environment", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_environment", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_environment(self):\n        \"\"\"Check that the testing environment is as expected.\"\"\"\n        assert HAVE_NP\n        assert RLE_HANDLER is not None\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_environment", "self", "check", "that", "the", "testing", "environment", "is", "as", "expected", "assert", "have_np", "assert", "rle_handler", "is", "not", "none"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_unsupported_syntax_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_unsupported_syntax_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_unsupported_syntax_raises(self):\n        \"\"\"Test pixel_array raises exception for unsupported syntaxes.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        for uid in UNSUPPORTED_SYNTAXES:\n            ds.file_meta.TransferSyntaxUID = uid\n            exc_msg = (\n                r\"Unable to decode pixel data with a transfer syntax UID of \"\n                r\"'{}'\".format(uid)\n            )\n            with pytest.raises(NotImplementedError, match=exc_msg):\n                ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_unsupported_syntax_raises", "self", "test", "pixel_array", "raises", "exception", "for", "unsupported", "syntaxes", "ds", "dcmread", "expl_16_1_1f", "for", "uid", "in", "unsupported_syntaxes", "ds", "file_meta", "transfersyntaxuid", "uid", "exc_msg", "r", "unable", "to", "decode", "pixel", "data", "with", "a", "transfer", "syntax", "uid", "of", "r", "format", "uid", "with", "pytest", "raises", "notimplementederror", "match", "exc_msg", "ds", "pixel_array"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_can_access_unsupported_dataset", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_can_access_unsupported_dataset", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_can_access_unsupported_dataset(self, fpath, data):\n        \"\"\"Test can read and access elements in unsupported datasets.\"\"\"\n        ds = dcmread(fpath)\n        assert data[0] == ds.file_meta.TransferSyntaxUID\n        assert data[1] == ds.PatientName\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_can_access_unsupported_dataset", "self", "fpath", "data", "test", "can", "read", "and", "access", "elements", "in", "unsupported", "datasets", "ds", "dcmread", "fpath", "assert", "data", "0", "ds", "file_meta", "transfersyntaxuid", "assert", "data", "1", "ds", "patientname"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_signed", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_signed", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_signed(self):\n        \"\"\"Test pixel_array for unsigned -> signed data.\"\"\"\n        ds = dcmread(RLE_8_1_1F)\n        # 0 is unsigned int, 1 is 2's complement\n        assert ds.PixelRepresentation == 0\n        ds.PixelRepresentation = 1\n        ref = _get_pixel_array(EXPL_8_1_1F)\n        arr = ds.pixel_array\n\n        assert not np.array_equal(arr, ref)\n        assert (600, 800) == arr.shape\n        assert -12 == arr[0].min() == arr[0].max()\n        assert (1, -10, 1) == tuple(arr[300, 491:494])\n        assert 0 == arr[-1].min() == arr[-1].max()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_signed", "self", "test", "pixel_array", "for", "unsigned", "signed", "data", "ds", "dcmread", "rle_8_1_1f", "0", "is", "unsigned", "int", "1", "is", "2", "s", "complement", "assert", "ds", "pixelrepresentation", "0", "ds", "pixelrepresentation", "1", "ref", "_get_pixel_array", "expl_8_1_1f", "arr", "ds", "pixel_array", "assert", "not", "np", "array_equal", "arr", "ref", "assert", "600", "800", "arr", "shape", "assert", "12", "arr", "0", "min", "arr", "0", "max", "assert", "1", "10", "1", "tuple", "arr", "300", "491", "494", "assert", "0", "arr", "1", "min", "arr", "1", "max"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_1bit_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_1bit_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_1bit_raises(self):\n        \"\"\"Test pixel_array for 1-bit raises exception.\"\"\"\n        ds = dcmread(RLE_8_3_1F)\n        ds.BitsAllocated = 1\n        with pytest.raises(NotImplementedError,\n                           match=\"Bits Allocated' value of 1\"):\n            ds.pixel_array\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_1bit_raises", "self", "test", "pixel_array", "for", "1", "bit", "raises", "exception", "ds", "dcmread", "rle_8_3_1f", "ds", "bitsallocated", "1", "with", "pytest", "raises", "notimplementederror", "match", "bits", "allocated", "value", "of", "1", "ds", "pixel_array"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_8bit_1sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_8bit_1sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_8bit_1sample_1f(self):\n        \"\"\"Test pixel_array for 8-bit, 1 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_8_1_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 8\n        assert ds.SamplesPerPixel == 1\n        assert 'NumberOfFrames' not in ds\n        ref = _get_pixel_array(EXPL_8_1_1F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (600, 800) == arr.shape\n        assert 244 == arr[0].min() == arr[0].max()\n        assert (1, 246, 1) == tuple(arr[300, 491:494])\n        assert 0 == arr[-1].min() == arr[-1].max()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_8bit_1sample_1f", "self", "test", "pixel_array", "for", "8", "bit", "1", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_8_1_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "8", "assert", "ds", "samplesperpixel", "1", "assert", "numberofframes", "not", "in", "ds", "ref", "_get_pixel_array", "expl_8_1_1f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "600", "800", "arr", "shape", "assert", "244", "arr", "0", "min", "arr", "0", "max", "assert", "1", "246", "1", "tuple", "arr", "300", "491", "494", "assert", "0", "arr", "1", "min", "arr", "1", "max"], "doc_len": 84}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_8bit_1sample_2f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_8bit_1sample_2f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_8bit_1sample_2f(self):\n        \"\"\"Test pixel_array for 8-bit, 1 sample/pixel, 2 frame.\"\"\"\n        ds = dcmread(RLE_8_1_2F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 8\n        assert ds.SamplesPerPixel == 1\n        assert ds.NumberOfFrames == 2\n        ref = _get_pixel_array(EXPL_8_1_2F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (2, 600, 800) == arr.shape\n        assert 244 == arr[0, 0].min() == arr[0, 0].max()\n        assert (1, 246, 1) == tuple(arr[0, 300, 491:494])\n        assert 0 == arr[0, -1].min() == arr[0, -1].max()\n\n        # Frame 2 is frame 1 inverted\n        assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_8bit_1sample_2f", "self", "test", "pixel_array", "for", "8", "bit", "1", "sample", "pixel", "2", "frame", "ds", "dcmread", "rle_8_1_2f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "8", "assert", "ds", "samplesperpixel", "1", "assert", "ds", "numberofframes", "2", "ref", "_get_pixel_array", "expl_8_1_2f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "2", "600", "800", "arr", "shape", "assert", "244", "arr", "0", "0", "min", "arr", "0", "0", "max", "assert", "1", "246", "1", "tuple", "arr", "0", "300", "491", "494", "assert", "0", "arr", "0", "1", "min", "arr", "0", "1", "max", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 106}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_8bit_3sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_8bit_3sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_8bit_3sample_1f(self):\n        \"\"\"Test pixel_array for 8-bit, 3 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_8_3_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 8\n        assert ds.SamplesPerPixel == 3\n        assert 'NumberOfFrames' not in ds\n        ref = _get_pixel_array(EXPL_8_3_1F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (255, 0, 0) == tuple(arr[5, 50, :])\n        assert (255, 128, 128) == tuple(arr[15, 50, :])\n        assert (0, 255, 0) == tuple(arr[25, 50, :])\n        assert (128, 255, 128) == tuple(arr[35, 50, :])\n        assert (0, 0, 255) == tuple(arr[45, 50, :])\n        assert (128, 128, 255) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (64, 64, 64) == tuple(arr[75, 50, :])\n        assert (192, 192, 192) == tuple(arr[85, 50, :])\n        assert (255, 255, 255) == tuple(arr[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_8bit_3sample_1f", "self", "test", "pixel_array", "for", "8", "bit", "3", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_8_3_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "8", "assert", "ds", "samplesperpixel", "3", "assert", "numberofframes", "not", "in", "ds", "ref", "_get_pixel_array", "expl_8_3_1f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "255", "0", "0", "tuple", "arr", "5", "50", "assert", "255", "128", "128", "tuple", "arr", "15", "50", "assert", "0", "255", "0", "tuple", "arr", "25", "50", "assert", "128", "255", "128", "tuple", "arr", "35", "50", "assert", "0", "0", "255", "tuple", "arr", "45", "50", "assert", "128", "128", "255", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "64", "64", "64", "tuple", "arr", "75", "50", "assert", "192", "192", "192", "tuple", "arr", "85", "50", "assert", "255", "255", "255", "tuple", "arr", "95", "50"], "doc_len": 134}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_8bit_3sample_2f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_8bit_3sample_2f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_8bit_3sample_2f(self):\n        \"\"\"Test pixel_array for 8-bit, 3 sample/pixel, 2 frame.\"\"\"\n        ds = dcmread(RLE_8_3_2F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 8\n        assert ds.SamplesPerPixel == 3\n        assert ds.NumberOfFrames == 2\n        ref = _get_pixel_array(EXPL_8_3_2F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n\n        # Frame 1\n        frame = arr[0]\n        assert (255, 0, 0) == tuple(frame[5, 50, :])\n        assert (255, 128, 128) == tuple(frame[15, 50, :])\n        assert (0, 255, 0) == tuple(frame[25, 50, :])\n        assert (128, 255, 128) == tuple(frame[35, 50, :])\n        assert (0, 0, 255) == tuple(frame[45, 50, :])\n        assert (128, 128, 255) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (64, 64, 64) == tuple(frame[75, 50, :])\n        assert (192, 192, 192) == tuple(frame[85, 50, :])\n        assert (255, 255, 255) == tuple(frame[95, 50, :])\n\n        # Frame 2 is frame 1 inverted\n        assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_8bit_3sample_2f", "self", "test", "pixel_array", "for", "8", "bit", "3", "sample", "pixel", "2", "frame", "ds", "dcmread", "rle_8_3_2f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "8", "assert", "ds", "samplesperpixel", "3", "assert", "ds", "numberofframes", "2", "ref", "_get_pixel_array", "expl_8_3_2f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "frame", "1", "frame", "arr", "0", "assert", "255", "0", "0", "tuple", "frame", "5", "50", "assert", "255", "128", "128", "tuple", "frame", "15", "50", "assert", "0", "255", "0", "tuple", "frame", "25", "50", "assert", "128", "255", "128", "tuple", "frame", "35", "50", "assert", "0", "0", "255", "tuple", "frame", "45", "50", "assert", "128", "128", "255", "tuple", "frame", "55", "50", "assert", "0", "0", "0", "tuple", "frame", "65", "50", "assert", "64", "64", "64", "tuple", "frame", "75", "50", "assert", "192", "192", "192", "tuple", "frame", "85", "50", "assert", "255", "255", "255", "tuple", "frame", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 155}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_16bit_1sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_16bit_1sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_16bit_1sample_1f(self):\n        \"\"\"Test pixel_array for 16-bit, 1 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 1\n        assert 'NumberOfFrames' not in ds\n        assert ds.PixelRepresentation == 1\n        ref = _get_pixel_array(EXPL_16_1_1F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (64, 64) == arr.shape\n\n        assert (422, 319, 361) == tuple(arr[0, 31:34])\n        assert (366, 363, 322) == tuple(arr[31, :3])\n        assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_16bit_1sample_1f", "self", "test", "pixel_array", "for", "16", "bit", "1", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_16_1_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "1", "assert", "numberofframes", "not", "in", "ds", "assert", "ds", "pixelrepresentation", "1", "ref", "_get_pixel_array", "expl_16_1_1f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "64", "64", "arr", "shape", "assert", "422", "319", "361", "tuple", "arr", "0", "31", "34", "assert", "366", "363", "322", "tuple", "arr", "31", "3", "assert", "1369", "1129", "862", "tuple", "arr", "1", "3"], "doc_len": 88}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_16bit_1sample_10f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_16bit_1sample_10f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_16bit_1sample_10f(self):\n        \"\"\"Test pixel_array for 16-bit, 1, sample/pixel, 10 frame.\"\"\"\n        ds = dcmread(RLE_16_1_10F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 1\n        assert ds.NumberOfFrames == 10\n        ref = _get_pixel_array(EXPL_16_1_10F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (10, 64, 64) == arr.shape\n\n        # Frame 1\n        assert (206, 197, 159) == tuple(arr[0, 0, 31:34])\n        assert (49, 78, 128) == tuple(arr[0, 31, :3])\n        assert (362, 219, 135) == tuple(arr[0, -1, -3:])\n\n        # Frame 5\n        assert (67, 82, 44) == tuple(arr[4, 0, 31:34])\n        assert (37, 41, 17) == tuple(arr[4, 31, :3])\n        assert (225, 380, 355) == tuple(arr[4, -1, -3:])\n\n        # Frame 10\n        assert (72, 86, 69) == tuple(arr[-1, 0, 31:34])\n        assert (25, 4, 9) == tuple(arr[-1, 31, :3])\n        assert (227, 300, 147) == tuple(arr[-1, -1, -3:])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_16bit_1sample_10f", "self", "test", "pixel_array", "for", "16", "bit", "1", "sample", "pixel", "10", "frame", "ds", "dcmread", "rle_16_1_10f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "1", "assert", "ds", "numberofframes", "10", "ref", "_get_pixel_array", "expl_16_1_10f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "10", "64", "64", "arr", "shape", "frame", "1", "assert", "206", "197", "159", "tuple", "arr", "0", "0", "31", "34", "assert", "49", "78", "128", "tuple", "arr", "0", "31", "3", "assert", "362", "219", "135", "tuple", "arr", "0", "1", "3", "frame", "5", "assert", "67", "82", "44", "tuple", "arr", "4", "0", "31", "34", "assert", "37", "41", "17", "tuple", "arr", "4", "31", "3", "assert", "225", "380", "355", "tuple", "arr", "4", "1", "3", "frame", "10", "assert", "72", "86", "69", "tuple", "arr", "1", "0", "31", "34", "assert", "25", "4", "9", "tuple", "arr", "1", "31", "3", "assert", "227", "300", "147", "tuple", "arr", "1", "1", "3"], "doc_len": 149}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_16bit_3sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_16bit_3sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_16bit_3sample_1f(self):\n        \"\"\"Test pixel_array for 16-bit, 3 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_16_3_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 3\n        assert 'NumberOfFrames' not in ds\n        arr = ds.pixel_array\n        ref = _get_pixel_array(EXPL_16_3_1F)\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(ds.pixel_array, ref)\n\n        assert (65535, 0, 0) == tuple(arr[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n        assert (0, 65535, 0) == tuple(arr[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n        assert (0, 0, 65535) == tuple(arr[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_16bit_3sample_1f", "self", "test", "pixel_array", "for", "16", "bit", "3", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_16_3_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "3", "assert", "numberofframes", "not", "in", "ds", "arr", "ds", "pixel_array", "ref", "_get_pixel_array", "expl_16_3_1f", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "ds", "pixel_array", "ref", "assert", "65535", "0", "0", "tuple", "arr", "5", "50", "assert", "65535", "32896", "32896", "tuple", "arr", "15", "50", "assert", "0", "65535", "0", "tuple", "arr", "25", "50", "assert", "32896", "65535", "32896", "tuple", "arr", "35", "50", "assert", "0", "0", "65535", "tuple", "arr", "45", "50", "assert", "32896", "32896", "65535", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "16448", "16448", "16448", "tuple", "arr", "75", "50", "assert", "49344", "49344", "49344", "tuple", "arr", "85", "50", "assert", "65535", "65535", "65535", "tuple", "arr", "95", "50"], "doc_len": 135}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_16bit_3sample_2f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_16bit_3sample_2f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_16bit_3sample_2f(self):\n        \"\"\"Test pixel_array for 16-bit, 3, sample/pixel, 10 frame.\"\"\"\n        ds = dcmread(RLE_16_3_2F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 3\n        assert ds.NumberOfFrames == 2\n        arr = ds.pixel_array\n        ref = _get_pixel_array(EXPL_16_3_2F)\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(ds.pixel_array, ref)\n\n        # Frame 1\n        frame = arr[0]\n        assert (65535, 0, 0) == tuple(frame[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(frame[15, 50, :])\n        assert (0, 65535, 0) == tuple(frame[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(frame[35, 50, :])\n        assert (0, 0, 65535) == tuple(frame[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(frame[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(frame[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[95, 50, :])\n\n        # Frame 2 is frame 1 inverted\n        assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_16bit_3sample_2f", "self", "test", "pixel_array", "for", "16", "bit", "3", "sample", "pixel", "10", "frame", "ds", "dcmread", "rle_16_3_2f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "3", "assert", "ds", "numberofframes", "2", "arr", "ds", "pixel_array", "ref", "_get_pixel_array", "expl_16_3_2f", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "ds", "pixel_array", "ref", "frame", "1", "frame", "arr", "0", "assert", "65535", "0", "0", "tuple", "frame", "5", "50", "assert", "65535", "32896", "32896", "tuple", "frame", "15", "50", "assert", "0", "65535", "0", "tuple", "frame", "25", "50", "assert", "32896", "65535", "32896", "tuple", "frame", "35", "50", "assert", "0", "0", "65535", "tuple", "frame", "45", "50", "assert", "32896", "32896", "65535", "tuple", "frame", "55", "50", "assert", "0", "0", "0", "tuple", "frame", "65", "50", "assert", "16448", "16448", "16448", "tuple", "frame", "75", "50", "assert", "49344", "49344", "49344", "tuple", "frame", "85", "50", "assert", "65535", "65535", "65535", "tuple", "frame", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 156}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_32bit_1sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_32bit_1sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_32bit_1sample_1f(self):\n        \"\"\"Test pixel_array for 32-bit, 1 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_32_1_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 32\n        assert ds.SamplesPerPixel == 1\n        assert 'NumberOfFrames' not in ds\n        ref = _get_pixel_array(EXPL_32_1_1F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (10, 10) == arr.shape\n        assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n        assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_32bit_1sample_1f", "self", "test", "pixel_array", "for", "32", "bit", "1", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_32_1_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "32", "assert", "ds", "samplesperpixel", "1", "assert", "numberofframes", "not", "in", "ds", "ref", "_get_pixel_array", "expl_32_1_1f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "10", "10", "arr", "shape", "assert", "1249000", "1249000", "1250000", "tuple", "arr", "0", "3", "assert", "1031000", "1029000", "1027000", "tuple", "arr", "4", "3", "6", "assert", "803000", "801000", "798000", "tuple", "arr", "1", "3"], "doc_len": 84}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_32bit_1sample_15f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_32bit_1sample_15f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_32bit_1sample_15f(self):\n        \"\"\"Test pixel_array for 32-bit, 1, sample/pixel, 15 frame.\"\"\"\n        ds = dcmread(RLE_32_1_15F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 32\n        assert ds.SamplesPerPixel == 1\n        assert ds.NumberOfFrames == 15\n        ref = _get_pixel_array(EXPL_32_1_15F)\n        arr = ds.pixel_array\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(arr, ref)\n        assert (15, 10, 10) == arr.shape\n\n        # Frame 1\n        assert (1249000, 1249000, 1250000) == tuple(arr[0, 0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(arr[0, 4, 3:6])\n        assert (803000, 801000, 798000) == tuple(arr[0, -1, -3:])\n\n        # Frame 8\n        assert (1253000, 1253000, 1249000) == tuple(arr[7, 0, :3])\n        assert (1026000, 1023000, 1022000) == tuple(arr[7, 4, 3:6])\n        assert (803000, 803000, 803000) == tuple(arr[7, -1, -3:])\n\n        # Frame 15\n        assert (1249000, 1250000, 1251000) == tuple(arr[-1, 0, :3])\n        assert (1031000, 1031000, 1031000) == tuple(arr[-1, 4, 3:6])\n        assert (801000, 800000, 799000) == tuple(arr[-1, -1, -3:])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_32bit_1sample_15f", "self", "test", "pixel_array", "for", "32", "bit", "1", "sample", "pixel", "15", "frame", "ds", "dcmread", "rle_32_1_15f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "32", "assert", "ds", "samplesperpixel", "1", "assert", "ds", "numberofframes", "15", "ref", "_get_pixel_array", "expl_32_1_15f", "arr", "ds", "pixel_array", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "arr", "ref", "assert", "15", "10", "10", "arr", "shape", "frame", "1", "assert", "1249000", "1249000", "1250000", "tuple", "arr", "0", "0", "3", "assert", "1031000", "1029000", "1027000", "tuple", "arr", "0", "4", "3", "6", "assert", "803000", "801000", "798000", "tuple", "arr", "0", "1", "3", "frame", "8", "assert", "1253000", "1253000", "1249000", "tuple", "arr", "7", "0", "3", "assert", "1026000", "1023000", "1022000", "tuple", "arr", "7", "4", "3", "6", "assert", "803000", "803000", "803000", "tuple", "arr", "7", "1", "3", "frame", "15", "assert", "1249000", "1250000", "1251000", "tuple", "arr", "1", "0", "3", "assert", "1031000", "1031000", "1031000", "tuple", "arr", "1", "4", "3", "6", "assert", "801000", "800000", "799000", "tuple", "arr", "1", "1", "3"], "doc_len": 149}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_32bit_3sample_1f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_32bit_3sample_1f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_32bit_3sample_1f(self):\n        \"\"\"Test pixel_array for 32-bit, 3 sample/pixel, 1 frame.\"\"\"\n        ds = dcmread(RLE_32_3_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 32\n        assert ds.SamplesPerPixel == 3\n        assert 'NumberOfFrames' not in ds\n        arr = ds.pixel_array\n        ref = _get_pixel_array(EXPL_32_3_1F)\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(ds.pixel_array, ref)\n\n        assert (4294967295, 0, 0) == tuple(arr[5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(arr[15, 50, :])\n        assert (0, 4294967295, 0) == tuple(arr[25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(arr[35, 50, :])\n        assert (0, 0, 4294967295) == tuple(arr[45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(arr[75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(arr[85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(arr[95, 50, :])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_32bit_3sample_1f", "self", "test", "pixel_array", "for", "32", "bit", "3", "sample", "pixel", "1", "frame", "ds", "dcmread", "rle_32_3_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "32", "assert", "ds", "samplesperpixel", "3", "assert", "numberofframes", "not", "in", "ds", "arr", "ds", "pixel_array", "ref", "_get_pixel_array", "expl_32_3_1f", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "ds", "pixel_array", "ref", "assert", "4294967295", "0", "0", "tuple", "arr", "5", "50", "assert", "4294967295", "2155905152", "2155905152", "tuple", "arr", "15", "50", "assert", "0", "4294967295", "0", "tuple", "arr", "25", "50", "assert", "2155905152", "4294967295", "2155905152", "tuple", "arr", "35", "50", "assert", "0", "0", "4294967295", "tuple", "arr", "45", "50", "assert", "2155905152", "2155905152", "4294967295", "tuple", "arr", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "65", "50", "assert", "1077952576", "1077952576", "1077952576", "tuple", "arr", "75", "50", "assert", "3233857728", "3233857728", "3233857728", "tuple", "arr", "85", "50", "assert", "4294967295", "4294967295", "4294967295", "tuple", "arr", "95", "50"], "doc_len": 135}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEHandler.test_pixel_array_32bit_3sample_2f", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEHandler", "func_name": "test_pixel_array_32bit_3sample_2f", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEHandler\n    def test_pixel_array_32bit_3sample_2f(self):\n        \"\"\"Test pixel_array for 32-bit, 3, sample/pixel, 2 frame.\"\"\"\n        ds = dcmread(RLE_32_3_2F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 32\n        assert ds.SamplesPerPixel == 3\n        assert ds.NumberOfFrames == 2\n        arr = ds.pixel_array\n        ref = _get_pixel_array(EXPL_32_3_2F)\n\n        assert arr.flags.writeable\n\n        assert np.array_equal(ds.pixel_array, ref)\n\n        # Frame 1\n        assert (4294967295, 0, 0) == tuple(arr[0, 5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(arr[0, 15, 50, :])\n        assert (0, 4294967295, 0) == tuple(arr[0, 25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(arr[0, 35, 50, :])\n        assert (0, 0, 4294967295) == tuple(arr[0, 45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(arr[0, 55, 50, :])\n        assert (0, 0, 0) == tuple(arr[0, 65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(arr[0, 75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(arr[0, 85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(arr[0, 95, 50, :])\n\n        # Frame 2 is frame 1 inverted\n        assert np.array_equal((2**ds.BitsAllocated - 1) - arr[1], arr[0])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rlehandler", "def", "test_pixel_array_32bit_3sample_2f", "self", "test", "pixel_array", "for", "32", "bit", "3", "sample", "pixel", "2", "frame", "ds", "dcmread", "rle_32_3_2f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "32", "assert", "ds", "samplesperpixel", "3", "assert", "ds", "numberofframes", "2", "arr", "ds", "pixel_array", "ref", "_get_pixel_array", "expl_32_3_2f", "assert", "arr", "flags", "writeable", "assert", "np", "array_equal", "ds", "pixel_array", "ref", "frame", "1", "assert", "4294967295", "0", "0", "tuple", "arr", "0", "5", "50", "assert", "4294967295", "2155905152", "2155905152", "tuple", "arr", "0", "15", "50", "assert", "0", "4294967295", "0", "tuple", "arr", "0", "25", "50", "assert", "2155905152", "4294967295", "2155905152", "tuple", "arr", "0", "35", "50", "assert", "0", "0", "4294967295", "tuple", "arr", "0", "45", "50", "assert", "2155905152", "2155905152", "4294967295", "tuple", "arr", "0", "55", "50", "assert", "0", "0", "0", "tuple", "arr", "0", "65", "50", "assert", "1077952576", "1077952576", "1077952576", "tuple", "arr", "0", "75", "50", "assert", "3233857728", "3233857728", "3233857728", "tuple", "arr", "0", "85", "50", "assert", "4294967295", "4294967295", "4294967295", "tuple", "arr", "0", "95", "50", "frame", "2", "is", "frame", "1", "inverted", "assert", "np", "array_equal", "2", "ds", "bitsallocated", "1", "arr", "1", "arr", "0"], "doc_len": 163}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_GetPixelData.test_no_pixel_data_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_no_pixel_data_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_no_pixel_data_raises(self):\n        \"\"\"Test get_pixeldata raises if dataset has no PixelData.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        del ds.PixelData\n        assert 'PixelData' not in ds\n        with pytest.raises(AttributeError, match=' dataset: PixelData'):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_no_pixel_data_raises", "self", "test", "get_pixeldata", "raises", "if", "dataset", "has", "no", "pixeldata", "ds", "dcmread", "rle_16_1_1f", "del", "ds", "pixeldata", "assert", "pixeldata", "not", "in", "ds", "with", "pytest", "raises", "attributeerror", "match", "dataset", "pixeldata", "get_pixeldata", "ds"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_GetPixelData.test_unknown_pixel_representation_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_unknown_pixel_representation_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_unknown_pixel_representation_raises(self):\n        \"\"\"Test get_pixeldata raises if invalid PixelRepresentation.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        ds.PixelRepresentation = 2\n        with pytest.raises(ValueError, match=r\"value of '2' for '\\(0028,0103\"):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_unknown_pixel_representation_raises", "self", "test", "get_pixeldata", "raises", "if", "invalid", "pixelrepresentation", "ds", "dcmread", "rle_16_1_1f", "ds", "pixelrepresentation", "2", "with", "pytest", "raises", "valueerror", "match", "r", "value", "of", "2", "for", "0028", "0103", "get_pixeldata", "ds"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_GetPixelData.test_unsupported_syntaxes_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_unsupported_syntaxes_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_unsupported_syntaxes_raises(self):\n        \"\"\"Test get_pixeldata raises if unsupported Transfer Syntax.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        with pytest.raises(NotImplementedError,\n                           match='syntax is not supported by the RLE pixel'):\n            get_pixeldata(ds)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_unsupported_syntaxes_raises", "self", "test", "get_pixeldata", "raises", "if", "unsupported", "transfer", "syntax", "ds", "dcmread", "expl_16_1_1f", "with", "pytest", "raises", "notimplementederror", "match", "syntax", "is", "not", "supported", "by", "the", "rle", "pixel", "get_pixeldata", "ds"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_GetPixelData.test_change_photometric_interpretation", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_change_photometric_interpretation", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_change_photometric_interpretation(self):\n        \"\"\"Test get_pixeldata changes PhotometricInterpretation if required.\"\"\"\n        def to_rgb(ds):\n            \"\"\"Override the original function that returned False\"\"\"\n            return True\n\n        # Test default\n        ds = dcmread(RLE_16_1_1F)\n        assert ds.PhotometricInterpretation == 'MONOCHROME2'\n\n        get_pixeldata(ds)\n        assert ds.PhotometricInterpretation == 'MONOCHROME2'\n\n        # Test opposite\n        orig_fn = RLE_HANDLER.should_change_PhotometricInterpretation_to_RGB\n        RLE_HANDLER.should_change_PhotometricInterpretation_to_RGB = to_rgb\n\n        get_pixeldata(ds)\n        assert ds.PhotometricInterpretation == 'RGB'\n\n        RLE_HANDLER.should_change_PhotometricInterpretation_to_RGB = orig_fn\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_change_photometric_interpretation", "self", "test", "get_pixeldata", "changes", "photometricinterpretation", "if", "required", "def", "to_rgb", "ds", "override", "the", "original", "function", "that", "returned", "false", "return", "true", "test", "default", "ds", "dcmread", "rle_16_1_1f", "assert", "ds", "photometricinterpretation", "monochrome2", "get_pixeldata", "ds", "assert", "ds", "photometricinterpretation", "monochrome2", "test", "opposite", "orig_fn", "rle_handler", "should_change_photometricinterpretation_to_rgb", "rle_handler", "should_change_photometricinterpretation_to_rgb", "to_rgb", "get_pixeldata", "ds", "assert", "ds", "photometricinterpretation", "rgb", "rle_handler", "should_change_photometricinterpretation_to_rgb", "orig_fn"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_GetPixelData.test_little_endian_segment_order", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_GetPixelData", "func_name": "test_little_endian_segment_order", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_GetPixelData\n    def test_little_endian_segment_order(self):\n        \"\"\"Test interpreting segment order as little endian.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        assert ds.file_meta.TransferSyntaxUID == RLELossless\n        assert ds.BitsAllocated == 16\n        assert ds.SamplesPerPixel == 1\n        assert 'NumberOfFrames' not in ds\n        assert ds.PixelRepresentation == 1  # signed\n\n        # Big endian\n        arr = get_pixeldata(ds, rle_segment_order='>')\n        arr = reshape_pixel_array(ds, arr)\n\n        assert (64, 64) == arr.shape\n        assert (422, 319, 361) == tuple(arr[0, 31:34])\n        assert (366, 363, 322) == tuple(arr[31, :3])\n        assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n\n        # Little endian\n        arr = get_pixeldata(ds, rle_segment_order='<')\n        arr = reshape_pixel_array(ds, arr)\n\n        assert (64, 64) == arr.shape\n        assert (-23039, 16129, 26881) == tuple(arr[0, 31:34])\n        assert (28161, 27393, 16897) == tuple(arr[31, :3])\n        assert (22789, 26884, 24067) == tuple(arr[-1, -3:])\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_getpixeldata", "def", "test_little_endian_segment_order", "self", "test", "interpreting", "segment", "order", "as", "little", "endian", "ds", "dcmread", "rle_16_1_1f", "assert", "ds", "file_meta", "transfersyntaxuid", "rlelossless", "assert", "ds", "bitsallocated", "16", "assert", "ds", "samplesperpixel", "1", "assert", "numberofframes", "not", "in", "ds", "assert", "ds", "pixelrepresentation", "1", "signed", "big", "endian", "arr", "get_pixeldata", "ds", "rle_segment_order", "arr", "reshape_pixel_array", "ds", "arr", "assert", "64", "64", "arr", "shape", "assert", "422", "319", "361", "tuple", "arr", "0", "31", "34", "assert", "366", "363", "322", "tuple", "arr", "31", "3", "assert", "1369", "1129", "862", "tuple", "arr", "1", "3", "little", "endian", "arr", "get_pixeldata", "ds", "rle_segment_order", "arr", "reshape_pixel_array", "ds", "arr", "assert", "64", "64", "arr", "shape", "assert", "23039", "16129", "26881", "tuple", "arr", "0", "31", "34", "assert", "28161", "27393", "16897", "tuple", "arr", "31", "3", "assert", "22789", "26884", "24067", "tuple", "arr", "1", "3"], "doc_len": 121}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEParseHeader.test_invalid_header_length", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEParseHeader", "func_name": "test_invalid_header_length", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEParseHeader\n    def test_invalid_header_length(self):\n        \"\"\"Test exception raised if header is not 64 bytes long.\"\"\"\n        for length in [0, 1, 63, 65]:\n            with pytest.raises(ValueError,\n                               match='RLE header can only be 64 bytes long'):\n                _parse_rle_header(b'\\x00' * length)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleparseheader", "def", "test_invalid_header_length", "self", "test", "exception", "raised", "if", "header", "is", "not", "64", "bytes", "long", "for", "length", "in", "0", "1", "63", "65", "with", "pytest", "raises", "valueerror", "match", "rle", "header", "can", "only", "be", "64", "bytes", "long", "_parse_rle_header", "b", "x00", "length"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEParseHeader.test_invalid_nr_segments_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEParseHeader", "func_name": "test_invalid_nr_segments_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEParseHeader\n    def test_invalid_nr_segments_raises(self):\n        \"\"\"Test that more than 15 segments raises exception.\"\"\"\n        with pytest.raises(ValueError, match=\"invalid number of segments\"):\n            _parse_rle_header(b'\\x10' + b'\\x00' * 63)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleparseheader", "def", "test_invalid_nr_segments_raises", "self", "test", "that", "more", "than", "15", "segments", "raises", "exception", "with", "pytest", "raises", "valueerror", "match", "invalid", "number", "of", "segments", "_parse_rle_header", "b", "x10", "b", "x00", "63"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEParseHeader.test_parse_header", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEParseHeader", "func_name": "test_parse_header", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEParseHeader\n    def test_parse_header(self, nr_segments, offsets):\n        \"\"\"Test parsing header data.\"\"\"\n        # Encode the header\n        header = bytearray()\n        header.extend(pack('<L', nr_segments))\n        header.extend(pack('<{}L'.format(len(offsets)), *offsets))\n        # Add padding\n        header.extend(b'\\x00' * (64 - len(header)))\n\n        assert len(header) == 64\n        assert offsets == _parse_rle_header(header)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleparseheader", "def", "test_parse_header", "self", "nr_segments", "offsets", "test", "parsing", "header", "data", "encode", "the", "header", "header", "bytearray", "header", "extend", "pack", "l", "nr_segments", "header", "extend", "pack", "l", "format", "len", "offsets", "offsets", "add", "padding", "header", "extend", "b", "x00", "64", "len", "header", "assert", "len", "header", "64", "assert", "offsets", "_parse_rle_header", "header"], "doc_len": 49}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_unsupported_bits_allocated_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_unsupported_bits_allocated_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_unsupported_bits_allocated_raises(self):\n        \"\"\"Test exception raised for BitsAllocated not a multiple of 8.\"\"\"\n        msg = (\n            r\"Unable to decode RLE encoded pixel data with a \\(0028,0100\\) \"\n            r\"'Bits Allocated' value of 12\"\n        )\n        with pytest.raises(NotImplementedError, match=msg):\n            _rle_decode_frame(b'\\x00\\x00\\x00\\x00', 1, 1, 1, 12)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_unsupported_bits_allocated_raises", "self", "test", "exception", "raised", "for", "bitsallocated", "not", "a", "multiple", "of", "8", "msg", "r", "unable", "to", "decode", "rle", "encoded", "pixel", "data", "with", "a", "0028", "0100", "r", "bits", "allocated", "value", "of", "12", "with", "pytest", "raises", "notimplementederror", "match", "msg", "_rle_decode_frame", "b", "x00", "x00", "x00", "x00", "1", "1", "1", "12"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_invalid_nr_segments_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_invalid_nr_segments_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_invalid_nr_segments_raises(self, header, samples, bits):\n        \"\"\"Test having too many segments in the data raises exception.\"\"\"\n        # This should probably be ValueError\n        expected = samples * bits // 8\n        actual = unpack('<L', header)[0]\n        header += b'\\x00' * (64 - len(header))\n        msg = (\n            r\"expected amount \\({} vs. {} segments\\)\".format(actual, expected)\n        )\n        with pytest.raises(ValueError, match=msg):\n            _rle_decode_frame(header,\n                              rows=1,\n                              columns=1,\n                              nr_samples=samples,\n                              nr_bits=bits)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_invalid_nr_segments_raises", "self", "header", "samples", "bits", "test", "having", "too", "many", "segments", "in", "the", "data", "raises", "exception", "this", "should", "probably", "be", "valueerror", "expected", "samples", "bits", "8", "actual", "unpack", "l", "header", "0", "header", "b", "x00", "64", "len", "header", "msg", "r", "expected", "amount", "vs", "segments", "format", "actual", "expected", "with", "pytest", "raises", "valueerror", "match", "msg", "_rle_decode_frame", "header", "rows", "1", "columns", "1", "nr_samples", "samples", "nr_bits", "bits"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_invalid_frame_data_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_invalid_frame_data_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_invalid_frame_data_raises(self):\n        \"\"\"Test that invalid segment data raises exception.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        # Missing byte\n        with pytest.raises(ValueError,\n                           match=r'amount \\(4095 vs. 4096 bytes\\)'):\n            _rle_decode_frame(pixel_data[:-1],\n                              ds.Rows,\n                              ds.Columns,\n                              ds.SamplesPerPixel,\n                              ds.BitsAllocated)\n\n        # Extra byte\n        with pytest.raises(ValueError,\n                           match=r'amount \\(4097 vs. 4096 bytes\\)'):\n            _rle_decode_frame(pixel_data + b'\\x00\\x01',\n                              ds.Rows,\n                              ds.Columns,\n                              ds.SamplesPerPixel,\n                              ds.BitsAllocated)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_invalid_frame_data_raises", "self", "test", "that", "invalid", "segment", "data", "raises", "exception", "ds", "dcmread", "rle_16_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "missing", "byte", "with", "pytest", "raises", "valueerror", "match", "r", "amount", "4095", "vs", "4096", "bytes", "_rle_decode_frame", "pixel_data", "1", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "extra", "byte", "with", "pytest", "raises", "valueerror", "match", "r", "amount", "4097", "vs", "4096", "bytes", "_rle_decode_frame", "pixel_data", "b", "x00", "x01", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated"], "doc_len": 72}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_8bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_8bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_8bit_1sample(self):\n        \"\"\"Test decoding 8-bit, 1 sample/pixel.\"\"\"\n        header = (\n            b'\\x01\\x00\\x00\\x00'\n            b'\\x40\\x00\\x00\\x00'\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        # 0, 64, 128, 160, 192, 255\n        data = b'\\x05\\x00\\x40\\x80\\xA0\\xC0\\xFF'\n        decoded = _rle_decode_frame(header + data, 2, 3, 1, 8)\n        arr = np.frombuffer(decoded, np.dtype('>u1'))\n        assert [0, 64, 128, 160, 192, 255] == arr.tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_8bit_1sample", "self", "test", "decoding", "8", "bit", "1", "sample", "pixel", "header", "b", "x01", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "0", "64", "128", "160", "192", "255", "data", "b", "x05", "x00", "x40", "x80", "xa0", "xc0", "xff", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "1", "8", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u1", "assert", "0", "64", "128", "160", "192", "255", "arr", "tolist"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_8bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_8bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_8bit_3sample(self):\n        \"\"\"Test decoding 8-bit, 3 sample/pixel.\"\"\"\n        header = (\n            b'\\x03\\x00\\x00\\x00'  # 3 segments\n            b'\\x40\\x00\\x00\\x00'  # 64\n            b'\\x47\\x00\\x00\\x00'  # 71\n            b'\\x4E\\x00\\x00\\x00'  # 78\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        # 0, 64, 128, 160, 192, 255\n        data = (\n            b'\\x05\\x00\\x40\\x80\\xA0\\xC0\\xFF'  # R\n            b'\\x05\\xFF\\xC0\\x80\\x40\\x00\\xFF'  # B\n            b'\\x05\\x01\\x40\\x80\\xA0\\xC0\\xFE'  # G\n        )\n        decoded = _rle_decode_frame(header + data, 2, 3, 3, 8)\n        arr = np.frombuffer(decoded, np.dtype('>u1'))\n        # Ordered all R, all G, all B\n        assert [0, 64, 128, 160, 192, 255] == arr[:6].tolist()\n        assert [255, 192, 128, 64, 0, 255] == arr[6:12].tolist()\n        assert [1, 64, 128, 160, 192, 254] == arr[12:].tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_8bit_3sample", "self", "test", "decoding", "8", "bit", "3", "sample", "pixel", "header", "b", "x03", "x00", "x00", "x00", "3", "segments", "b", "x40", "x00", "x00", "x00", "64", "b", "x47", "x00", "x00", "x00", "71", "b", "x4e", "x00", "x00", "x00", "78", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "0", "64", "128", "160", "192", "255", "data", "b", "x05", "x00", "x40", "x80", "xa0", "xc0", "xff", "r", "b", "x05", "xff", "xc0", "x80", "x40", "x00", "xff", "b", "b", "x05", "x01", "x40", "x80", "xa0", "xc0", "xfe", "g", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "3", "8", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u1", "ordered", "all", "r", "all", "g", "all", "b", "assert", "0", "64", "128", "160", "192", "255", "arr", "6", "tolist", "assert", "255", "192", "128", "64", "0", "255", "arr", "6", "12", "tolist", "assert", "1", "64", "128", "160", "192", "254", "arr", "12", "tolist"], "doc_len": 138}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_16bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_16bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_16bit_1sample(self):\n        \"\"\"Test decoding 16-bit, 1 sample/pixel.\"\"\"\n        header = (\n            b'\\x02\\x00\\x00\\x00'\n            b'\\x40\\x00\\x00\\x00'\n            b'\\x47\\x00\\x00\\x00'\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        data = (\n            # 0, 1, 256, 255, 65280, 65535\n            b'\\x05\\x00\\x00\\x01\\x00\\xFF\\xFF'  # MSB\n            b'\\x05\\x00\\x01\\x00\\xFF\\x00\\xFF'  # LSB\n        )\n        decoded = _rle_decode_frame(header + data, 2, 3, 1, 16)\n        arr = np.frombuffer(decoded, np.dtype('>u2'))\n        assert [0, 1, 256, 255, 65280, 65535] == arr.tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_16bit_1sample", "self", "test", "decoding", "16", "bit", "1", "sample", "pixel", "header", "b", "x02", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "x47", "x00", "x00", "x00", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "data", "0", "1", "256", "255", "65280", "65535", "b", "x05", "x00", "x00", "x01", "x00", "xff", "xff", "msb", "b", "x05", "x00", "x01", "x00", "xff", "x00", "xff", "lsb", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "1", "16", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u2", "assert", "0", "1", "256", "255", "65280", "65535", "arr", "tolist"], "doc_len": 90}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_16bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_16bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_16bit_3sample(self):\n        \"\"\"Test decoding 16-bit, 3 sample/pixel.\"\"\"\n        header = (\n            b'\\x06\\x00\\x00\\x00'  # 6 segments\n            b'\\x40\\x00\\x00\\x00'  # 64\n            b'\\x47\\x00\\x00\\x00'  # 71\n            b'\\x4E\\x00\\x00\\x00'  # 78\n            b'\\x55\\x00\\x00\\x00'  # 85\n            b'\\x5C\\x00\\x00\\x00'  # 92\n            b'\\x63\\x00\\x00\\x00'  # 99\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        data = (\n            # 0, 1, 256, 255, 65280, 65535\n            b'\\x05\\x00\\x00\\x01\\x00\\xFF\\xFF'  # MSB\n            b'\\x05\\x00\\x01\\x00\\xFF\\x00\\xFF'  # LSB\n            b'\\x05\\xFF\\x00\\x01\\x00\\xFF\\x00'  # MSB\n            b'\\x05\\xFF\\x01\\x00\\xFF\\x00\\x00'  # LSB\n            b'\\x05\\x00\\x00\\x01\\x00\\xFF\\xFF'  # MSB\n            b'\\x05\\x01\\x01\\x00\\xFF\\x00\\xFE'  # LSB\n        )\n        decoded = _rle_decode_frame(header + data, 2, 3, 3, 16)\n        arr = np.frombuffer(decoded, np.dtype('>u2'))\n        assert [0, 1, 256, 255, 65280, 65535] == arr[:6].tolist()\n        assert [65535, 1, 256, 255, 65280, 0] == arr[6:12].tolist()\n        assert [1, 1, 256, 255, 65280, 65534] == arr[12:].tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_16bit_3sample", "self", "test", "decoding", "16", "bit", "3", "sample", "pixel", "header", "b", "x06", "x00", "x00", "x00", "6", "segments", "b", "x40", "x00", "x00", "x00", "64", "b", "x47", "x00", "x00", "x00", "71", "b", "x4e", "x00", "x00", "x00", "78", "b", "x55", "x00", "x00", "x00", "85", "b", "x5c", "x00", "x00", "x00", "92", "b", "x63", "x00", "x00", "x00", "99", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "data", "0", "1", "256", "255", "65280", "65535", "b", "x05", "x00", "x00", "x01", "x00", "xff", "xff", "msb", "b", "x05", "x00", "x01", "x00", "xff", "x00", "xff", "lsb", "b", "x05", "xff", "x00", "x01", "x00", "xff", "x00", "msb", "b", "x05", "xff", "x01", "x00", "xff", "x00", "x00", "lsb", "b", "x05", "x00", "x00", "x01", "x00", "xff", "xff", "msb", "b", "x05", "x01", "x01", "x00", "xff", "x00", "xfe", "lsb", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "3", "16", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u2", "assert", "0", "1", "256", "255", "65280", "65535", "arr", "6", "tolist", "assert", "65535", "1", "256", "255", "65280", "0", "arr", "6", "12", "tolist", "assert", "1", "1", "256", "255", "65280", "65534", "arr", "12", "tolist"], "doc_len": 176}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_32bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_32bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_32bit_1sample(self):\n        \"\"\"Test decoding 32-bit, 1 sample/pixel.\"\"\"\n        header = (\n            b'\\x04\\x00\\x00\\x00'  # 4 segments\n            b'\\x40\\x00\\x00\\x00'  # 64 offset\n            b'\\x47\\x00\\x00\\x00'  # 71 offset\n            b'\\x4E\\x00\\x00\\x00'  # 78 offset\n            b'\\x55\\x00\\x00\\x00'  # 85 offset\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        data = (\n            # 0, 16777216, 65536, 256, 4294967295\n            b'\\x05\\x00\\x01\\x00\\x00\\x00\\xFF'  # MSB\n            b'\\x05\\x00\\x00\\x01\\x00\\x00\\xFF'\n            b'\\x05\\x00\\x00\\x00\\x01\\x00\\xFF'\n            b'\\x05\\x00\\x00\\x00\\x00\\x01\\xFF'  # LSB\n        )\n        decoded = _rle_decode_frame(header + data, 2, 3, 1, 32)\n        arr = np.frombuffer(decoded, np.dtype('>u4'))\n        assert [0, 16777216, 65536, 256, 1, 4294967295] == arr.tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_32bit_1sample", "self", "test", "decoding", "32", "bit", "1", "sample", "pixel", "header", "b", "x04", "x00", "x00", "x00", "4", "segments", "b", "x40", "x00", "x00", "x00", "64", "offset", "b", "x47", "x00", "x00", "x00", "71", "offset", "b", "x4e", "x00", "x00", "x00", "78", "offset", "b", "x55", "x00", "x00", "x00", "85", "offset", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "data", "0", "16777216", "65536", "256", "4294967295", "b", "x05", "x00", "x01", "x00", "x00", "x00", "xff", "msb", "b", "x05", "x00", "x00", "x01", "x00", "x00", "xff", "b", "x05", "x00", "x00", "x00", "x01", "x00", "xff", "b", "x05", "x00", "x00", "x00", "x00", "x01", "xff", "lsb", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "1", "32", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u4", "assert", "0", "16777216", "65536", "256", "1", "4294967295", "arr", "tolist"], "doc_len": 125}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeFrame.test_32bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeFrame", "func_name": "test_32bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeFrame\n    def test_32bit_3sample(self):\n        \"\"\"Test decoding 32-bit, 3 sample/pixel.\"\"\"\n        header = (\n            b'\\x0C\\x00\\x00\\x00'  # 12 segments\n            b'\\x40\\x00\\x00\\x00'  # 64\n            b'\\x47\\x00\\x00\\x00'  # 71\n            b'\\x4E\\x00\\x00\\x00'  # 78\n            b'\\x55\\x00\\x00\\x00'  # 85\n            b'\\x5C\\x00\\x00\\x00'  # 92\n            b'\\x63\\x00\\x00\\x00'  # 99\n            b'\\x6A\\x00\\x00\\x00'  # 106\n            b'\\x71\\x00\\x00\\x00'  # 113\n            b'\\x78\\x00\\x00\\x00'  # 120\n            b'\\x7F\\x00\\x00\\x00'  # 127\n            b'\\x86\\x00\\x00\\x00'  # 134\n            b'\\x8D\\x00\\x00\\x00'  # 141\n        )\n        header += (64 - len(header)) * b'\\x00'\n        # 2 x 3 data\n        data = (\n            # 0, 16777216, 65536, 256, 4294967295\n            b'\\x05\\x00\\x01\\x00\\x00\\x00\\xFF'  # MSB\n            b'\\x05\\x00\\x00\\x01\\x00\\x00\\xFF'\n            b'\\x05\\x00\\x00\\x00\\x01\\x00\\xFF'\n            b'\\x05\\x00\\x00\\x00\\x00\\x01\\xFF'  # LSB\n            b'\\x05\\xFF\\x01\\x00\\x00\\x00\\x00'  # MSB\n            b'\\x05\\xFF\\x00\\x01\\x00\\x00\\x00'\n            b'\\x05\\xFF\\x00\\x00\\x01\\x00\\x00'\n            b'\\x05\\xFF\\x00\\x00\\x00\\x01\\x00'  # LSB\n            b'\\x05\\x00\\x01\\x00\\x00\\x00\\xFF'  # MSB\n            b'\\x05\\x00\\x00\\x01\\x00\\x00\\xFF'\n            b'\\x05\\x00\\x00\\x00\\x01\\x00\\xFF'\n            b'\\x05\\x01\\x00\\x00\\x00\\x01\\xFE'  # LSB\n        )\n        decoded = _rle_decode_frame(header + data, 2, 3, 3, 32)\n        arr = np.frombuffer(decoded, np.dtype('>u4'))\n        assert [0, 16777216, 65536, 256, 1, 4294967295] == arr[:6].tolist()\n        assert [4294967295, 16777216, 65536, 256, 1, 0] == arr[6:12].tolist()\n        assert [1, 16777216, 65536, 256, 1, 4294967294] == arr[12:].tolist()\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodeframe", "def", "test_32bit_3sample", "self", "test", "decoding", "32", "bit", "3", "sample", "pixel", "header", "b", "x0c", "x00", "x00", "x00", "12", "segments", "b", "x40", "x00", "x00", "x00", "64", "b", "x47", "x00", "x00", "x00", "71", "b", "x4e", "x00", "x00", "x00", "78", "b", "x55", "x00", "x00", "x00", "85", "b", "x5c", "x00", "x00", "x00", "92", "b", "x63", "x00", "x00", "x00", "99", "b", "x6a", "x00", "x00", "x00", "106", "b", "x71", "x00", "x00", "x00", "113", "b", "x78", "x00", "x00", "x00", "120", "b", "x7f", "x00", "x00", "x00", "127", "b", "x86", "x00", "x00", "x00", "134", "b", "x8d", "x00", "x00", "x00", "141", "header", "64", "len", "header", "b", "x00", "2", "x", "3", "data", "data", "0", "16777216", "65536", "256", "4294967295", "b", "x05", "x00", "x01", "x00", "x00", "x00", "xff", "msb", "b", "x05", "x00", "x00", "x01", "x00", "x00", "xff", "b", "x05", "x00", "x00", "x00", "x01", "x00", "xff", "b", "x05", "x00", "x00", "x00", "x00", "x01", "xff", "lsb", "b", "x05", "xff", "x01", "x00", "x00", "x00", "x00", "msb", "b", "x05", "xff", "x00", "x01", "x00", "x00", "x00", "b", "x05", "xff", "x00", "x00", "x01", "x00", "x00", "b", "x05", "xff", "x00", "x00", "x00", "x01", "x00", "lsb", "b", "x05", "x00", "x01", "x00", "x00", "x00", "xff", "msb", "b", "x05", "x00", "x00", "x01", "x00", "x00", "xff", "b", "x05", "x00", "x00", "x00", "x01", "x00", "xff", "b", "x05", "x01", "x00", "x00", "x00", "x01", "xfe", "lsb", "decoded", "_rle_decode_frame", "header", "data", "2", "3", "3", "32", "arr", "np", "frombuffer", "decoded", "np", "dtype", "u4", "assert", "0", "16777216", "65536", "256", "1", "4294967295", "arr", "6", "tolist", "assert", "4294967295", "16777216", "65536", "256", "1", "0", "arr", "6", "12", "tolist", "assert", "1", "16777216", "65536", "256", "1", "4294967294", "arr", "12", "tolist"], "doc_len": 259}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeSegment.test_noop", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeSegment", "func_name": "test_noop", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeSegment\n    def test_noop(self):\n        \"\"\"Test no-operation output.\"\"\"\n        # For n == 128, do nothing\n        # data is only noop, 0x80 = 128\n        data = b'\\x80\\x80\\x80'\n        assert b'' == bytes(_rle_decode_segment(data))\n\n        # noop at start, data after\n        data = (\n            b'\\x80\\x80'  # No operation\n            b'\\x05\\x01\\x02\\x03\\x04\\x05\\x06'  # Literal\n            b'\\xFE\\x01'  # Copy\n            b'\\x80'\n        )\n        assert (\n            b'\\x01\\x02\\x03\\x04\\x05\\x06'\n            b'\\x01\\x01\\x01'\n        ) == bytes(_rle_decode_segment(data))\n\n        # data at start, noop middle, data at end\n        data = (\n            b'\\x05\\x01\\x02\\x03\\x04\\x05\\x06'  # Literal\n            b'\\x80'  # No operation\n            b'\\xFE\\x01'  # Copy\n            b'\\x80'\n        )\n        assert (\n            b'\\x01\\x02\\x03\\x04\\x05\\x06'\n            b'\\x01\\x01\\x01'\n        ) == bytes(_rle_decode_segment(data))\n\n        # data at start, noop end\n        # Copy 6 bytes literally, then 3 x 0x01\n        data = (\n            b'\\x05\\x01\\x02\\x03\\x04\\x05\\x06'\n            b'\\xFE\\x01'\n            b'\\x80'\n        )\n        assert (\n            b'\\x01\\x02\\x03\\x04\\x05\\x06'\n            b'\\x01\\x01\\x01'\n        ) == bytes(_rle_decode_segment(data))\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodesegment", "def", "test_noop", "self", "test", "no", "operation", "output", "for", "n", "128", "do", "nothing", "data", "is", "only", "noop", "0x80", "128", "data", "b", "x80", "x80", "x80", "assert", "b", "bytes", "_rle_decode_segment", "data", "noop", "at", "start", "data", "after", "data", "b", "x80", "x80", "no", "operation", "b", "x05", "x01", "x02", "x03", "x04", "x05", "x06", "literal", "b", "xfe", "x01", "copy", "b", "x80", "assert", "b", "x01", "x02", "x03", "x04", "x05", "x06", "b", "x01", "x01", "x01", "bytes", "_rle_decode_segment", "data", "data", "at", "start", "noop", "middle", "data", "at", "end", "data", "b", "x05", "x01", "x02", "x03", "x04", "x05", "x06", "literal", "b", "x80", "no", "operation", "b", "xfe", "x01", "copy", "b", "x80", "assert", "b", "x01", "x02", "x03", "x04", "x05", "x06", "b", "x01", "x01", "x01", "bytes", "_rle_decode_segment", "data", "data", "at", "start", "noop", "end", "copy", "6", "bytes", "literally", "then", "3", "x", "0x01", "data", "b", "x05", "x01", "x02", "x03", "x04", "x05", "x06", "b", "xfe", "x01", "b", "x80", "assert", "b", "x01", "x02", "x03", "x04", "x05", "x06", "b", "x01", "x01", "x01", "bytes", "_rle_decode_segment", "data"], "doc_len": 159}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeSegment.test_literal", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeSegment", "func_name": "test_literal", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeSegment\n    def test_literal(self):\n        \"\"\"Test literal output.\"\"\"\n        # For n < 128, read the next (n + 1) bytes literally\n        # n = 0 (0x80 is 128 -> no operation)\n        data = b'\\x00\\x02\\x80'\n        assert b'\\x02' == bytes(_rle_decode_segment(data))\n        # n = 1\n        data = b'\\x01\\x02\\x03\\x80'\n        assert b'\\x02\\x03' == bytes(_rle_decode_segment(data))\n        # n = 127\n        data = b'\\x7f' + b'\\x40' * 128 + b'\\x80'\n        assert b'\\x40' * 128 == bytes(_rle_decode_segment(data))\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodesegment", "def", "test_literal", "self", "test", "literal", "output", "for", "n", "128", "read", "the", "next", "n", "1", "bytes", "literally", "n", "0", "0x80", "is", "128", "no", "operation", "data", "b", "x00", "x02", "x80", "assert", "b", "x02", "bytes", "_rle_decode_segment", "data", "n", "1", "data", "b", "x01", "x02", "x03", "x80", "assert", "b", "x02", "x03", "bytes", "_rle_decode_segment", "data", "n", "127", "data", "b", "x7f", "b", "x40", "128", "b", "x80", "assert", "b", "x40", "128", "bytes", "_rle_decode_segment", "data"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEDecodeSegment.test_copy", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEDecodeSegment", "func_name": "test_copy", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEDecodeSegment\n    def test_copy(self):\n        \"\"\"Test copy output.\"\"\"\n        # For n > 128, copy the next byte (257 - n) times\n        # n = 255, copy x2 (0x80 is 128 -> no operation)\n        data = b'\\xFF\\x02\\x80'\n        assert b'\\x02\\x02' == bytes(_rle_decode_segment(data))\n        # n = 254, copy x3\n        data = b'\\xFE\\x02\\x80'\n        assert b'\\x02\\x02\\x02' == bytes(_rle_decode_segment(data))\n        # n = 129, copy x128\n        data = b'\\x81\\x02\\x80'\n        assert b'\\x02' * 128 == bytes(_rle_decode_segment(data))\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rledecodesegment", "def", "test_copy", "self", "test", "copy", "output", "for", "n", "128", "copy", "the", "next", "byte", "257", "n", "times", "n", "255", "copy", "x2", "0x80", "is", "128", "no", "operation", "data", "b", "xff", "x02", "x80", "assert", "b", "x02", "x02", "bytes", "_rle_decode_segment", "data", "n", "254", "copy", "x3", "data", "b", "xfe", "x02", "x80", "assert", "b", "x02", "x02", "x02", "bytes", "_rle_decode_segment", "data", "n", "129", "copy", "x128", "data", "b", "x81", "x02", "x80", "assert", "b", "x02", "128", "bytes", "_rle_decode_segment", "data"], "doc_len": 75}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeRow.test_encode", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeRow", "func_name": "test_encode", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeRow\n    def test_encode(self, input, output):\n        \"\"\"Test encoding an empty row.\"\"\"\n        assert output == _rle_encode_row(np.asarray(input))\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencoderow", "def", "test_encode", "self", "input", "output", "test", "encoding", "an", "empty", "row", "assert", "output", "_rle_encode_row", "np", "asarray", "input"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.setup", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "setup", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def setup(self):\n        \"\"\"Setup the tests.\"\"\"\n        # Create a dataset skeleton for use in the cycle tests\n        ds = Dataset()\n        ds.file_meta = Dataset()\n        ds.file_meta.TransferSyntaxUID = '1.2.840.10008.1.2'\n        ds.Rows = 2\n        ds.Columns = 4\n        ds.SamplesPerPixel = 3\n        ds.PlanarConfiguration = 1\n        self.ds = ds\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "setup", "self", "setup", "the", "tests", "create", "a", "dataset", "skeleton", "for", "use", "in", "the", "cycle", "tests", "ds", "dataset", "ds", "file_meta", "dataset", "ds", "file_meta", "transfersyntaxuid", "1", "2", "840", "10008", "1", "2", "ds", "rows", "2", "ds", "columns", "4", "ds", "samplesperpixel", "3", "ds", "planarconfiguration", "1", "self", "ds", "ds"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_8bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_8bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_8bit_1sample(self):\n        \"\"\"Test an encode/decode cycle for 8-bit 1 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_8_1_1F)\n        ref = ds.pixel_array\n        assert 8 == ds.BitsAllocated\n        assert 1 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        dtype = np.dtype('uint8').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype)\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_8bit_1sample", "self", "test", "an", "encode", "decode", "cycle", "for", "8", "bit", "1", "sample", "pixel", "ds", "dcmread", "expl_8_1_1f", "ref", "ds", "pixel_array", "assert", "8", "ds", "bitsallocated", "assert", "1", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "dtype", "np", "dtype", "uint8", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_8bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_8bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_8bit_3sample(self):\n        \"\"\"Test an encode/decode cycle for 8-bit 3 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_8_3_1F)\n        ref = ds.pixel_array\n        assert 8 == ds.BitsAllocated\n        assert 3 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        arr = np.frombuffer(decoded, 'uint8')\n        # The decoded data is planar configuration 1\n        ds.PlanarConfiguration = 1\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_8bit_3sample", "self", "test", "an", "encode", "decode", "cycle", "for", "8", "bit", "3", "sample", "pixel", "ds", "dcmread", "expl_8_3_1f", "ref", "ds", "pixel_array", "assert", "8", "ds", "bitsallocated", "assert", "3", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "arr", "np", "frombuffer", "decoded", "uint8", "the", "decoded", "data", "is", "planar", "configuration", "1", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_16bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_16bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_16bit_1sample(self):\n        \"\"\"Test an encode/decode cycle for 16-bit 1 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_16_1_1F)\n        ref = ds.pixel_array\n        assert 16 == ds.BitsAllocated\n        assert 1 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        dtype = np.dtype('uint16').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype)\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_16bit_1sample", "self", "test", "an", "encode", "decode", "cycle", "for", "16", "bit", "1", "sample", "pixel", "ds", "dcmread", "expl_16_1_1f", "ref", "ds", "pixel_array", "assert", "16", "ds", "bitsallocated", "assert", "1", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "dtype", "np", "dtype", "uint16", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_16bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_16bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_16bit_3sample(self):\n        \"\"\"Test an encode/decode cycle for 16-bit 3 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_16_3_1F)\n        ref = ds.pixel_array\n        assert 16 == ds.BitsAllocated\n        assert 3 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        dtype = np.dtype('uint16').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype)\n        # The decoded data is planar configuration 1\n        ds.PlanarConfiguration = 1\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_16bit_3sample", "self", "test", "an", "encode", "decode", "cycle", "for", "16", "bit", "3", "sample", "pixel", "ds", "dcmread", "expl_16_3_1f", "ref", "ds", "pixel_array", "assert", "16", "ds", "bitsallocated", "assert", "3", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "dtype", "np", "dtype", "uint16", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "the", "decoded", "data", "is", "planar", "configuration", "1", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_32bit_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_32bit_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_32bit_1sample(self):\n        \"\"\"Test an encode/decode cycle for 32-bit 1 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_32_1_1F)\n        ref = ds.pixel_array\n        assert 32 == ds.BitsAllocated\n        assert 1 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        dtype = np.dtype('uint32').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype)\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_32bit_1sample", "self", "test", "an", "encode", "decode", "cycle", "for", "32", "bit", "1", "sample", "pixel", "ds", "dcmread", "expl_32_1_1f", "ref", "ds", "pixel_array", "assert", "32", "ds", "bitsallocated", "assert", "1", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "dtype", "np", "dtype", "uint32", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_cycle_32bit_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_cycle_32bit_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_cycle_32bit_3sample(self):\n        \"\"\"Test an encode/decode cycle for 32-bit 3 sample/pixel.\"\"\"\n        ds = dcmread(EXPL_32_3_1F)\n        ref = ds.pixel_array\n        assert 32 == ds.BitsAllocated\n        assert 3 == ds.SamplesPerPixel\n\n        encoded = rle_encode_frame(ref)\n        decoded = _rle_decode_frame(encoded, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        dtype = np.dtype('uint32').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype)\n        # The decoded data is planar configuration 1\n        ds.PlanarConfiguration = 1\n        arr = reshape_pixel_array(ds, arr)\n\n        assert np.array_equal(ref, arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_cycle_32bit_3sample", "self", "test", "an", "encode", "decode", "cycle", "for", "32", "bit", "3", "sample", "pixel", "ds", "dcmread", "expl_32_3_1f", "ref", "ds", "pixel_array", "assert", "32", "ds", "bitsallocated", "assert", "3", "ds", "samplesperpixel", "encoded", "rle_encode_frame", "ref", "decoded", "_rle_decode_frame", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "dtype", "np", "dtype", "uint32", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "the", "decoded", "data", "is", "planar", "configuration", "1", "ds", "planarconfiguration", "1", "arr", "reshape_pixel_array", "ds", "arr", "assert", "np", "array_equal", "ref", "arr"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_16_segments_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_16_segments_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_16_segments_raises(self):\n        \"\"\"Test that trying to encode 16-segments raises exception.\"\"\"\n        arr = np.asarray([[[1, 2, 3, 4]]], dtype='uint32')\n        assert (1, 1, 4) == arr.shape\n        assert 4 == arr.dtype.itemsize\n\n        msg = (\n            r\"Unable to encode as the DICOM standard only allows \"\n            r\"a maximum of 15 segments in RLE encoded data\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            rle_encode_frame(arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_16_segments_raises", "self", "test", "that", "trying", "to", "encode", "16", "segments", "raises", "exception", "arr", "np", "asarray", "1", "2", "3", "4", "dtype", "uint32", "assert", "1", "1", "4", "arr", "shape", "assert", "4", "arr", "dtype", "itemsize", "msg", "r", "unable", "to", "encode", "as", "the", "dicom", "standard", "only", "allows", "r", "a", "maximum", "of", "15", "segments", "in", "rle", "encoded", "data", "with", "pytest", "raises", "valueerror", "match", "msg", "rle_encode_frame", "arr"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_15_segment", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_15_segment", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_15_segment(self):\n        \"\"\"Test encoding 15-segments works as expected.\"\"\"\n        arr = np.asarray(\n            [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]],\n            dtype='uint8'\n        )\n        assert (1, 1, 15) == arr.shape\n        assert 1 == arr.dtype.itemsize\n\n        encoded = rle_encode_frame(arr)\n        header = (\n            b'\\x0f\\x00\\x00\\x00'\n            b'\\x40\\x00\\x00\\x00'\n            b'\\x42\\x00\\x00\\x00'\n            b'\\x44\\x00\\x00\\x00'\n            b'\\x46\\x00\\x00\\x00'\n            b'\\x48\\x00\\x00\\x00'\n            b'\\x4a\\x00\\x00\\x00'\n            b'\\x4c\\x00\\x00\\x00'\n            b'\\x4e\\x00\\x00\\x00'\n            b'\\x50\\x00\\x00\\x00'\n            b'\\x52\\x00\\x00\\x00'\n            b'\\x54\\x00\\x00\\x00'\n            b'\\x56\\x00\\x00\\x00'\n            b'\\x58\\x00\\x00\\x00'\n            b'\\x5a\\x00\\x00\\x00'\n            b'\\x5c\\x00\\x00\\x00'\n        )\n        assert header == encoded[:64]\n        assert (\n            b'\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06'\n            b'\\x00\\x07\\x00\\x08\\x00\\x09\\x00\\x0a\\x00\\x0b\\x00\\x0c'\n            b'\\x00\\x0d\\x00\\x0e\\x00\\x0f'\n        ) == encoded[64:]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_15_segment", "self", "test", "encoding", "15", "segments", "works", "as", "expected", "arr", "np", "asarray", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "dtype", "uint8", "assert", "1", "1", "15", "arr", "shape", "assert", "1", "arr", "dtype", "itemsize", "encoded", "rle_encode_frame", "arr", "header", "b", "x0f", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "x42", "x00", "x00", "x00", "b", "x44", "x00", "x00", "x00", "b", "x46", "x00", "x00", "x00", "b", "x48", "x00", "x00", "x00", "b", "x4a", "x00", "x00", "x00", "b", "x4c", "x00", "x00", "x00", "b", "x4e", "x00", "x00", "x00", "b", "x50", "x00", "x00", "x00", "b", "x52", "x00", "x00", "x00", "b", "x54", "x00", "x00", "x00", "b", "x56", "x00", "x00", "x00", "b", "x58", "x00", "x00", "x00", "b", "x5a", "x00", "x00", "x00", "b", "x5c", "x00", "x00", "x00", "assert", "header", "encoded", "64", "assert", "b", "x00", "x01", "x00", "x02", "x00", "x03", "x00", "x04", "x00", "x05", "x00", "x06", "b", "x00", "x07", "x00", "x08", "x00", "x09", "x00", "x0a", "x00", "x0b", "x00", "x0c", "b", "x00", "x0d", "x00", "x0e", "x00", "x0f", "encoded", "64"], "doc_len": 170}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_encoding_multiple_frames_raises", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_encoding_multiple_frames_raises", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_encoding_multiple_frames_raises(self):\n        \"\"\"Test encoding multiple framed pixel data raises exception.\"\"\"\n        # Note: only works with multi-sample data\n        ds = dcmread(EXPL_8_3_2F)\n        arr = ds.pixel_array\n        assert ds.NumberOfFrames > 1\n        assert len(arr.shape) == 4\n        msg = (\n            r\"Unable to encode multiple frames at once, please encode one \"\n            r\"frame at a time\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            rle_encode_frame(arr)\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_encoding_multiple_frames_raises", "self", "test", "encoding", "multiple", "framed", "pixel", "data", "raises", "exception", "note", "only", "works", "with", "multi", "sample", "data", "ds", "dcmread", "expl_8_3_2f", "arr", "ds", "pixel_array", "assert", "ds", "numberofframes", "1", "assert", "len", "arr", "shape", "4", "msg", "r", "unable", "to", "encode", "multiple", "frames", "at", "once", "please", "encode", "one", "r", "frame", "at", "a", "time", "with", "pytest", "raises", "valueerror", "match", "msg", "rle_encode_frame", "arr"], "doc_len": 63}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_single_row_1sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_single_row_1sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_single_row_1sample(self):\n        \"\"\"Test encoding a single row of 1 sample/pixel data.\"\"\"\n        # Rows 1, Columns 5, SamplesPerPixel 1\n        arr = np.asarray([[0, 1, 2, 3, 4]], dtype='uint8')\n        assert (1, 5) == arr.shape\n        encoded = rle_encode_frame(arr)\n        header = b'\\x01\\x00\\x00\\x00\\x40\\x00\\x00\\x00' + b'\\x00' * 56\n        assert header == encoded[:64]\n        assert b'\\x04\\x00\\x01\\x02\\x03\\x04' == encoded[64:]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_single_row_1sample", "self", "test", "encoding", "a", "single", "row", "of", "1", "sample", "pixel", "data", "rows", "1", "columns", "5", "samplesperpixel", "1", "arr", "np", "asarray", "0", "1", "2", "3", "4", "dtype", "uint8", "assert", "1", "5", "arr", "shape", "encoded", "rle_encode_frame", "arr", "header", "b", "x01", "x00", "x00", "x00", "x40", "x00", "x00", "x00", "b", "x00", "56", "assert", "header", "encoded", "64", "assert", "b", "x04", "x00", "x01", "x02", "x03", "x04", "encoded", "64"], "doc_len": 69}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeFrame.test_single_row_3sample", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeFrame", "func_name": "test_single_row_3sample", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeFrame\n    def test_single_row_3sample(self):\n        \"\"\"Test encoding a single row of 3 samples/pixel data.\"\"\"\n        # Rows 1, Columns 5, SamplesPerPixel 3\n        arr = np.asarray(\n            [[[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]],\n            dtype='uint8'\n        )\n        assert (1, 5, 3) == arr.shape\n        encoded = rle_encode_frame(arr)\n        header = (\n            b'\\x03\\x00\\x00\\x00'\n            b'\\x40\\x00\\x00\\x00'\n            b'\\x46\\x00\\x00\\x00'\n            b'\\x4c\\x00\\x00\\x00'\n        )\n        header += b'\\x00' * (64 - len(header))\n        assert header == encoded[:64]\n        assert (\n            b'\\x04\\x00\\x01\\x02\\x03\\x04'\n            b'\\x04\\x00\\x01\\x02\\x03\\x04'\n            b'\\x04\\x00\\x01\\x02\\x03\\x04'\n        ) == encoded[64:]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeframe", "def", "test_single_row_3sample", "self", "test", "encoding", "a", "single", "row", "of", "3", "samples", "pixel", "data", "rows", "1", "columns", "5", "samplesperpixel", "3", "arr", "np", "asarray", "0", "0", "0", "1", "1", "1", "2", "2", "2", "3", "3", "3", "4", "4", "4", "dtype", "uint8", "assert", "1", "5", "3", "arr", "shape", "encoded", "rle_encode_frame", "arr", "header", "b", "x03", "x00", "x00", "x00", "b", "x40", "x00", "x00", "x00", "b", "x46", "x00", "x00", "x00", "b", "x4c", "x00", "x00", "x00", "header", "b", "x00", "64", "len", "header", "assert", "header", "encoded", "64", "assert", "b", "x04", "x00", "x01", "x02", "x03", "x04", "b", "x04", "x00", "x01", "x02", "x03", "x04", "b", "x04", "x00", "x01", "x02", "x03", "x04", "encoded", "64"], "doc_len": 108}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_8bit", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_8bit", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_8bit(self):\n        \"\"\"Test encoding an 8-bit plane into 1 segment.\"\"\"\n        ds = dcmread(RLE_8_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        decoded = _rle_decode_frame(pixel_data, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.BitsAllocated // 8 == len(decoded)\n        arr = np.frombuffer(decoded, 'uint8').reshape(ds.Rows, ds.Columns)\n        # Re-encode the decoded data\n        encoded = bytearray()\n        nr_segments = 0\n        for segment in _rle_encode_plane(arr):\n            encoded.extend(segment)\n            nr_segments += 1\n\n        # Add header\n        header = b'\\x01\\x00\\x00\\x00\\x40\\x00\\x00\\x00'\n        header += b'\\x00' * (64 - len(header))\n\n        assert 1 == nr_segments\n\n        # Decode the re-encoded data and check that it's the same\n        redecoded = _rle_decode_frame(header + encoded,\n                                      ds.Rows, ds.Columns,\n                                      ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.SamplesPerPixel == len(redecoded)\n        assert decoded == redecoded\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_8bit", "self", "test", "encoding", "an", "8", "bit", "plane", "into", "1", "segment", "ds", "dcmread", "rle_8_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "decoded", "_rle_decode_frame", "pixel_data", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "bitsallocated", "8", "len", "decoded", "arr", "np", "frombuffer", "decoded", "uint8", "reshape", "ds", "rows", "ds", "columns", "re", "encode", "the", "decoded", "data", "encoded", "bytearray", "nr_segments", "0", "for", "segment", "in", "_rle_encode_plane", "arr", "encoded", "extend", "segment", "nr_segments", "1", "add", "header", "header", "b", "x01", "x00", "x00", "x00", "x40", "x00", "x00", "x00", "header", "b", "x00", "64", "len", "header", "assert", "1", "nr_segments", "decode", "the", "re", "encoded", "data", "and", "check", "that", "it", "s", "the", "same", "redecoded", "_rle_decode_frame", "header", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "len", "redecoded", "assert", "decoded", "redecoded"], "doc_len": 131}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_16bit", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_16bit", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_16bit(self):\n        \"\"\"Test encoding a 16-bit plane into 2 segments.\"\"\"\n        ds = dcmread(RLE_16_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        decoded = _rle_decode_frame(pixel_data, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.BitsAllocated // 8 == len(decoded)\n\n        # `decoded` is in big endian byte ordering\n        dtype = np.dtype('uint16').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype).reshape(ds.Rows, ds.Columns)\n\n        # Re-encode the decoded data\n        encoded = bytearray()\n        nr_segments = 0\n        offsets = [64]\n        for segment in _rle_encode_plane(arr):\n            offsets.append(offsets[nr_segments] + len(segment))\n            encoded.extend(segment)\n            nr_segments += 1\n\n        assert 2 == nr_segments\n\n        # Add header\n        header = b'\\x02\\x00\\x00\\x00'\n        header += pack('<2L', *offsets[:-1])\n        header += b'\\x00' * (64 - len(header))\n\n        # Decode the re-encoded data and check that it's the same\n        redecoded = _rle_decode_frame(header + encoded,\n                                      ds.Rows, ds.Columns,\n                                      ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.BitsAllocated // 8 == len(redecoded)\n        assert decoded == redecoded\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_16bit", "self", "test", "encoding", "a", "16", "bit", "plane", "into", "2", "segments", "ds", "dcmread", "rle_16_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "decoded", "_rle_decode_frame", "pixel_data", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "bitsallocated", "8", "len", "decoded", "decoded", "is", "in", "big", "endian", "byte", "ordering", "dtype", "np", "dtype", "uint16", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "reshape", "ds", "rows", "ds", "columns", "re", "encode", "the", "decoded", "data", "encoded", "bytearray", "nr_segments", "0", "offsets", "64", "for", "segment", "in", "_rle_encode_plane", "arr", "offsets", "append", "offsets", "nr_segments", "len", "segment", "encoded", "extend", "segment", "nr_segments", "1", "assert", "2", "nr_segments", "add", "header", "header", "b", "x02", "x00", "x00", "x00", "header", "pack", "2l", "offsets", "1", "header", "b", "x00", "64", "len", "header", "decode", "the", "re", "encoded", "data", "and", "check", "that", "it", "s", "the", "same", "redecoded", "_rle_decode_frame", "header", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "bitsallocated", "8", "len", "redecoded", "assert", "decoded", "redecoded"], "doc_len": 153}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_16bit_segment_order", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_16bit_segment_order", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_16bit_segment_order(self):\n        \"\"\"Test that the segment order per 16-bit sample is correct.\"\"\"\n        # Native byte ordering\n        data = b'\\x00\\x00\\x01\\xFF\\xFE\\x00\\xFF\\xFF\\x10\\x12'\n        dtype = np.dtype('uint16')\n        arr = np.frombuffer(data, dtype)\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 2 == len(segments)\n\n        # Each segment should start with a literal run marker of 0x04\n        # and MSB should be first segment, then LSB in second\n        if sys.byteorder == 'little':\n            assert b'\\x04\\x00\\xFF\\x00\\xFF\\x12' == segments[0]\n            assert b'\\x04\\x00\\x01\\xFE\\xFF\\x10' == segments[1]\n        else:\n            assert b'\\x04\\x00\\x01\\xFE\\xFF\\x10' == segments[0]\n            assert b'\\x04\\x00\\xFF\\x00\\xFF\\x12' == segments[1]\n\n        # Little endian\n        arr = np.frombuffer(data, dtype.newbyteorder('<'))\n        assert [0, 65281, 254, 65535, 4624] == arr.tolist()\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 2 == len(segments)\n        assert b'\\x04\\x00\\xFF\\x00\\xFF\\x12' == segments[0]\n        assert b'\\x04\\x00\\x01\\xFE\\xFF\\x10' == segments[1]\n\n        # Big endian\n        arr = np.frombuffer(data, dtype.newbyteorder('>'))\n        assert [0, 511, 65024, 65535, 4114] == arr.tolist()\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 2 == len(segments)\n        assert b'\\x04\\x00\\x01\\xFE\\xFF\\x10' == segments[0]\n        assert b'\\x04\\x00\\xFF\\x00\\xFF\\x12' == segments[1]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_16bit_segment_order", "self", "test", "that", "the", "segment", "order", "per", "16", "bit", "sample", "is", "correct", "native", "byte", "ordering", "data", "b", "x00", "x00", "x01", "xff", "xfe", "x00", "xff", "xff", "x10", "x12", "dtype", "np", "dtype", "uint16", "arr", "np", "frombuffer", "data", "dtype", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "2", "len", "segments", "each", "segment", "should", "start", "with", "a", "literal", "run", "marker", "of", "0x04", "and", "msb", "should", "be", "first", "segment", "then", "lsb", "in", "second", "if", "sys", "byteorder", "little", "assert", "b", "x04", "x00", "xff", "x00", "xff", "x12", "segments", "0", "assert", "b", "x04", "x00", "x01", "xfe", "xff", "x10", "segments", "1", "else", "assert", "b", "x04", "x00", "x01", "xfe", "xff", "x10", "segments", "0", "assert", "b", "x04", "x00", "xff", "x00", "xff", "x12", "segments", "1", "little", "endian", "arr", "np", "frombuffer", "data", "dtype", "newbyteorder", "assert", "0", "65281", "254", "65535", "4624", "arr", "tolist", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "2", "len", "segments", "assert", "b", "x04", "x00", "xff", "x00", "xff", "x12", "segments", "0", "assert", "b", "x04", "x00", "x01", "xfe", "xff", "x10", "segments", "1", "big", "endian", "arr", "np", "frombuffer", "data", "dtype", "newbyteorder", "assert", "0", "511", "65024", "65535", "4114", "arr", "tolist", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "2", "len", "segments", "assert", "b", "x04", "x00", "x01", "xfe", "xff", "x10", "segments", "0", "assert", "b", "x04", "x00", "xff", "x00", "xff", "x12", "segments", "1"], "doc_len": 220}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_32bit", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_32bit", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_32bit(self):\n        \"\"\"Test encoding a 32-bit plane into 4 segments.\"\"\"\n        ds = dcmread(RLE_32_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        decoded = _rle_decode_frame(pixel_data, ds.Rows, ds.Columns,\n                                    ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.BitsAllocated // 8 == len(decoded)\n\n        # `decoded` is in big endian byte ordering\n        dtype = np.dtype('uint32').newbyteorder('>')\n        arr = np.frombuffer(decoded, dtype).reshape(ds.Rows, ds.Columns)\n\n        # Re-encode the decoded data\n        encoded = bytearray()\n        nr_segments = 0\n        offsets = [64]\n        for segment in _rle_encode_plane(arr):\n            offsets.append(offsets[nr_segments] + len(segment))\n            encoded.extend(segment)\n            nr_segments += 1\n\n        assert 4 == nr_segments\n\n        # Add header\n        header = b'\\x04\\x00\\x00\\x00'\n        header += pack('<4L', *offsets[:-1])\n        header += b'\\x00' * (64 - len(header))\n\n        # Decode the re-encoded data and check that it's the same\n        redecoded = _rle_decode_frame(header + encoded,\n                                      ds.Rows, ds.Columns,\n                                      ds.SamplesPerPixel, ds.BitsAllocated)\n        assert ds.Rows * ds.Columns * ds.BitsAllocated // 8 == len(redecoded)\n        assert decoded == redecoded\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_32bit", "self", "test", "encoding", "a", "32", "bit", "plane", "into", "4", "segments", "ds", "dcmread", "rle_32_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "decoded", "_rle_decode_frame", "pixel_data", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "bitsallocated", "8", "len", "decoded", "decoded", "is", "in", "big", "endian", "byte", "ordering", "dtype", "np", "dtype", "uint32", "newbyteorder", "arr", "np", "frombuffer", "decoded", "dtype", "reshape", "ds", "rows", "ds", "columns", "re", "encode", "the", "decoded", "data", "encoded", "bytearray", "nr_segments", "0", "offsets", "64", "for", "segment", "in", "_rle_encode_plane", "arr", "offsets", "append", "offsets", "nr_segments", "len", "segment", "encoded", "extend", "segment", "nr_segments", "1", "assert", "4", "nr_segments", "add", "header", "header", "b", "x04", "x00", "x00", "x00", "header", "pack", "4l", "offsets", "1", "header", "b", "x00", "64", "len", "header", "decode", "the", "re", "encoded", "data", "and", "check", "that", "it", "s", "the", "same", "redecoded", "_rle_decode_frame", "header", "encoded", "ds", "rows", "ds", "columns", "ds", "samplesperpixel", "ds", "bitsallocated", "assert", "ds", "rows", "ds", "columns", "ds", "bitsallocated", "8", "len", "redecoded", "assert", "decoded", "redecoded"], "doc_len": 153}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_32bit_segment_order", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_32bit_segment_order", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_32bit_segment_order(self):\n        \"\"\"Test that the segment order per 32-bit sample is correct.\"\"\"\n        # Native byte ordering\n        data = b'\\x00\\x00\\x00\\x00\\x01\\xFF\\xFE\\x0A\\xFF\\xFC\\x10\\x12'\n        dtype = np.dtype('uint32')\n        arr = np.frombuffer(data, dtype)\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 4 == len(segments)\n\n        # Each segment should start with a literal run marker of 0x02\n        if sys.byteorder == 'little':\n            assert b'\\x02\\x00\\x0A\\x12' == segments[0]\n            assert b'\\x02\\x00\\xFE\\x10' == segments[1]\n            assert b'\\x02\\x00\\xFF\\xFC' == segments[2]\n            assert b'\\x02\\x00\\x01\\xFF' == segments[3]\n        else:\n            assert b'\\x02\\x00\\x01\\xFF' == segments[0]\n            assert b'\\x02\\x00\\xFF\\xFC' == segments[1]\n            assert b'\\x02\\x00\\xFE\\x10' == segments[2]\n            assert b'\\x02\\x00\\x0A\\x12' == segments[3]\n\n        # Little endian\n        arr = np.frombuffer(data, dtype.newbyteorder('<'))\n        assert [0, 184483585, 303103231] == arr.tolist()\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 4 == len(segments)\n        assert b'\\x02\\x00\\x0A\\x12' == segments[0]\n        assert b'\\x02\\x00\\xFE\\x10' == segments[1]\n        assert b'\\x02\\x00\\xFF\\xFC' == segments[2]\n        assert b'\\x02\\x00\\x01\\xFF' == segments[3]\n\n        # Big endian\n        arr = np.frombuffer(data, dtype.newbyteorder('>'))\n        assert [0, 33553930, 4294709266] == arr.tolist()\n\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        assert 4 == len(segments)\n        assert b'\\x02\\x00\\x01\\xFF' == segments[0]\n        assert b'\\x02\\x00\\xFF\\xFC' == segments[1]\n        assert b'\\x02\\x00\\xFE\\x10' == segments[2]\n        assert b'\\x02\\x00\\x0A\\x12' == segments[3]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_32bit_segment_order", "self", "test", "that", "the", "segment", "order", "per", "32", "bit", "sample", "is", "correct", "native", "byte", "ordering", "data", "b", "x00", "x00", "x00", "x00", "x01", "xff", "xfe", "x0a", "xff", "xfc", "x10", "x12", "dtype", "np", "dtype", "uint32", "arr", "np", "frombuffer", "data", "dtype", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "4", "len", "segments", "each", "segment", "should", "start", "with", "a", "literal", "run", "marker", "of", "0x02", "if", "sys", "byteorder", "little", "assert", "b", "x02", "x00", "x0a", "x12", "segments", "0", "assert", "b", "x02", "x00", "xfe", "x10", "segments", "1", "assert", "b", "x02", "x00", "xff", "xfc", "segments", "2", "assert", "b", "x02", "x00", "x01", "xff", "segments", "3", "else", "assert", "b", "x02", "x00", "x01", "xff", "segments", "0", "assert", "b", "x02", "x00", "xff", "xfc", "segments", "1", "assert", "b", "x02", "x00", "xfe", "x10", "segments", "2", "assert", "b", "x02", "x00", "x0a", "x12", "segments", "3", "little", "endian", "arr", "np", "frombuffer", "data", "dtype", "newbyteorder", "assert", "0", "184483585", "303103231", "arr", "tolist", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "4", "len", "segments", "assert", "b", "x02", "x00", "x0a", "x12", "segments", "0", "assert", "b", "x02", "x00", "xfe", "x10", "segments", "1", "assert", "b", "x02", "x00", "xff", "xfc", "segments", "2", "assert", "b", "x02", "x00", "x01", "xff", "segments", "3", "big", "endian", "arr", "np", "frombuffer", "data", "dtype", "newbyteorder", "assert", "0", "33553930", "4294709266", "arr", "tolist", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "assert", "4", "len", "segments", "assert", "b", "x02", "x00", "x01", "xff", "segments", "0", "assert", "b", "x02", "x00", "xff", "xfc", "segments", "1", "assert", "b", "x02", "x00", "xfe", "x10", "segments", "2", "assert", "b", "x02", "x00", "x0a", "x12", "segments", "3"], "doc_len": 256}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodePlane.test_padding", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodePlane", "func_name": "test_padding", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodePlane\n    def test_padding(self):\n        \"\"\"Test that odd length encoded segments are padded.\"\"\"\n        data = b'\\x00\\x04\\x01\\x15'\n        arr = np.frombuffer(data, 'uint8')\n        segments = []\n        for segment in _rle_encode_plane(arr):\n            segments.append(segment)\n\n        # The segment should start with a literal run marker of 0x03\n        #   then 4 bytes of RLE encoded data, then 0x00 padding\n        assert b'\\x03\\x00\\x04\\x01\\x15\\x00' == segments[0]\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodeplane", "def", "test_padding", "self", "test", "that", "odd", "length", "encoded", "segments", "are", "padded", "data", "b", "x00", "x04", "x01", "x15", "arr", "np", "frombuffer", "data", "uint8", "segments", "for", "segment", "in", "_rle_encode_plane", "arr", "segments", "append", "segment", "the", "segment", "should", "start", "with", "a", "literal", "run", "marker", "of", "0x03", "then", "4", "bytes", "of", "rle", "encoded", "data", "then", "0x00", "padding", "assert", "b", "x03", "x00", "x04", "x01", "x15", "x00", "segments", "0"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeSegment.test_one_row", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeSegment", "func_name": "test_one_row", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeSegment\n    def test_one_row(self):\n        \"\"\"Test encoding data that contains only a single row.\"\"\"\n        ds = dcmread(RLE_8_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        decoded = _rle_decode_segment(pixel_data[64:])\n        assert ds.Rows * ds.Columns == len(decoded)\n        arr = np.frombuffer(decoded, 'uint8').reshape(ds.Rows, ds.Columns)\n\n        # Re-encode a single row of the decoded data\n        row = arr[0]\n        assert (ds.Columns,) == row.shape\n        encoded = _rle_encode_segment(row)\n\n        # Decode the re-encoded data and check that it's the same\n        redecoded = _rle_decode_segment(encoded)\n        assert ds.Columns == len(redecoded)\n        assert decoded[:ds.Columns] == redecoded\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodesegment", "def", "test_one_row", "self", "test", "encoding", "data", "that", "contains", "only", "a", "single", "row", "ds", "dcmread", "rle_8_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "decoded", "_rle_decode_segment", "pixel_data", "64", "assert", "ds", "rows", "ds", "columns", "len", "decoded", "arr", "np", "frombuffer", "decoded", "uint8", "reshape", "ds", "rows", "ds", "columns", "re", "encode", "a", "single", "row", "of", "the", "decoded", "data", "row", "arr", "0", "assert", "ds", "columns", "row", "shape", "encoded", "_rle_encode_segment", "row", "decode", "the", "re", "encoded", "data", "and", "check", "that", "it", "s", "the", "same", "redecoded", "_rle_decode_segment", "encoded", "assert", "ds", "columns", "len", "redecoded", "assert", "decoded", "ds", "columns", "redecoded"], "doc_len": 90}
{"doc_id": "pydicom/tests/test_rle_pixel_data.py::TestNumpy_RLEEncodeSegment.test_cycle", "file_path": "pydicom/tests/test_rle_pixel_data.py", "class_name": "TestNumpy_RLEEncodeSegment", "func_name": "test_cycle", "text": "文件路径: pydicom/tests/test_rle_pixel_data.py, 类名: TestNumpy_RLEEncodeSegment\n    def test_cycle(self):\n        \"\"\"Test the decoded data remains the same after encoding/decoding.\"\"\"\n        ds = dcmread(RLE_8_1_1F)\n        pixel_data = defragment_data(ds.PixelData)\n        decoded = _rle_decode_segment(pixel_data[64:])\n        assert ds.Rows * ds.Columns == len(decoded)\n        arr = np.frombuffer(decoded, 'uint8').reshape(ds.Rows, ds.Columns)\n        # Re-encode the decoded data\n        encoded = _rle_encode_segment(arr)\n\n        # Decode the re-encoded data and check that it's the same\n        redecoded = _rle_decode_segment(encoded)\n        assert ds.Rows * ds.Columns == len(redecoded)\n        assert decoded == redecoded\n", "tokens": ["pydicom", "tests", "test_rle_pixel_data", "py", "testnumpy_rleencodesegment", "def", "test_cycle", "self", "test", "the", "decoded", "data", "remains", "the", "same", "after", "encoding", "decoding", "ds", "dcmread", "rle_8_1_1f", "pixel_data", "defragment_data", "ds", "pixeldata", "decoded", "_rle_decode_segment", "pixel_data", "64", "assert", "ds", "rows", "ds", "columns", "len", "decoded", "arr", "np", "frombuffer", "decoded", "uint8", "reshape", "ds", "rows", "ds", "columns", "re", "encode", "the", "decoded", "data", "encoded", "_rle_encode_segment", "arr", "decode", "the", "re", "encoded", "data", "and", "check", "that", "it", "s", "the", "same", "redecoded", "_rle_decode_segment", "encoded", "assert", "ds", "rows", "ds", "columns", "len", "redecoded", "assert", "decoded", "redecoded"], "doc_len": 79}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.testDefaultInitialization", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "testDefaultInitialization", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def testDefaultInitialization(self):\n        \"\"\"Sequence: Ensure a valid Sequence is created\"\"\"\n        empty = Sequence()\n        assert 0 == len(empty)\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "testdefaultinitialization", "self", "sequence", "ensure", "a", "valid", "sequence", "is", "created", "empty", "sequence", "assert", "0", "len", "empty"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.testValidInitialization", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "testValidInitialization", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def testValidInitialization(self):\n        \"\"\"Sequence: Ensure valid creation of Sequences using Dataset inputs\"\"\"\n        inputs = {'PatientPosition': 'HFS',\n                  'PatientSetupNumber': '1',\n                  'SetupTechniqueDescription': ''}\n        patientSetups = Dataset()\n        patientSetups.update(inputs)\n\n        # Construct the sequence\n        seq = Sequence((patientSetups,))\n        assert isinstance(seq[0], Dataset)\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "testvalidinitialization", "self", "sequence", "ensure", "valid", "creation", "of", "sequences", "using", "dataset", "inputs", "inputs", "patientposition", "hfs", "patientsetupnumber", "1", "setuptechniquedescription", "patientsetups", "dataset", "patientsetups", "update", "inputs", "construct", "the", "sequence", "seq", "sequence", "patientsetups", "assert", "isinstance", "seq", "0", "dataset"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.testInvalidInitialization", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "testInvalidInitialization", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def testInvalidInitialization(self):\n        \"\"\"Sequence: Raise error if inputs are not iterables or Datasets\"\"\"\n        # Error on construction with single Dataset\n        with pytest.raises(TypeError):\n            Sequence(Dataset())\n        # Test for non-iterable\n        with pytest.raises(TypeError):\n            Sequence(1)\n        # Test for invalid iterable contents\n        with pytest.raises(TypeError):\n            Sequence([1, 2])\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "testinvalidinitialization", "self", "sequence", "raise", "error", "if", "inputs", "are", "not", "iterables", "or", "datasets", "error", "on", "construction", "with", "single", "dataset", "with", "pytest", "raises", "typeerror", "sequence", "dataset", "test", "for", "non", "iterable", "with", "pytest", "raises", "typeerror", "sequence", "1", "test", "for", "invalid", "iterable", "contents", "with", "pytest", "raises", "typeerror", "sequence", "1", "2"], "doc_len": 52}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.testInvalidAssignment", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "testInvalidAssignment", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def testInvalidAssignment(self):\n        \"\"\"Sequence: validate exception for invalid assignment\"\"\"\n        seq = Sequence([Dataset(), ])\n        # Attempt to assign an integer to the first element\n        with pytest.raises(TypeError):\n            seq.__setitem__(0, 1)\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "testinvalidassignment", "self", "sequence", "validate", "exception", "for", "invalid", "assignment", "seq", "sequence", "dataset", "attempt", "to", "assign", "an", "integer", "to", "the", "first", "element", "with", "pytest", "raises", "typeerror", "seq", "__setitem__", "0", "1"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.testValidAssignment", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "testValidAssignment", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def testValidAssignment(self):\n        \"\"\"Sequence: ensure ability to assign a Dataset to a Sequence item\"\"\"\n        ds = Dataset()\n        ds.add_new((1, 1), 'IS', 1)\n\n        # Create a single element Sequence first\n        seq = Sequence([Dataset(), ])\n        seq[0] = ds\n\n        assert ds == seq[0]\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "testvalidassignment", "self", "sequence", "ensure", "ability", "to", "assign", "a", "dataset", "to", "a", "sequence", "item", "ds", "dataset", "ds", "add_new", "1", "1", "is", "1", "create", "a", "single", "element", "sequence", "first", "seq", "sequence", "dataset", "seq", "0", "ds", "assert", "ds", "seq", "0"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_sequence.py::TestSequence.test_str", "file_path": "pydicom/tests/test_sequence.py", "class_name": "TestSequence", "func_name": "test_str", "text": "文件路径: pydicom/tests/test_sequence.py, 类名: TestSequence\n    def test_str(self):\n        \"\"\"Test string output of the sequence\"\"\"\n        ds = Dataset()\n        ds.BeamSequence = [Dataset()]\n        ds.BeamSequence[0].PatientName = 'TEST'\n        ds.BeamSequence[0].PatientID = '12345'\n\n        out = str(ds.BeamSequence)\n        assert \"[(0010, 0010) Patient's Name\" in out\n        assert \"PN: 'TEST'\" in out\n        assert \"(0010, 0020) Patient ID\" in out\n        assert \"LO: '12345']\" in out\n", "tokens": ["pydicom", "tests", "test_sequence", "py", "testsequence", "def", "test_str", "self", "test", "string", "output", "of", "the", "sequence", "ds", "dataset", "ds", "beamsequence", "dataset", "ds", "beamsequence", "0", "patientname", "test", "ds", "beamsequence", "0", "patientid", "12345", "out", "str", "ds", "beamsequence", "assert", "0010", "0010", "patient", "s", "name", "in", "out", "assert", "pn", "test", "in", "out", "assert", "0010", "0020", "patient", "id", "in", "out", "assert", "lo", "12345", "in", "out"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_le_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_le_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_le_same_class(self):\n        \"\"\"Test __le__ of two classes with same type.\"\"\"\n        assert BaseTag(0x00000000) <= BaseTag(0x00000001)\n        assert BaseTag(0x00000001) <= BaseTag(0x00000001)\n        assert not BaseTag(0x00000001) <= BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_le_same_class", "self", "test", "__le__", "of", "two", "classes", "with", "same", "type", "assert", "basetag", "0x00000000", "basetag", "0x00000001", "assert", "basetag", "0x00000001", "basetag", "0x00000001", "assert", "not", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_le_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_le_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_le_diff_class(self):\n        \"\"\"Test __le__ of two classes with different type.\"\"\"\n        assert BaseTag(0x00000000) <= 1\n        assert BaseTag(0x00000001) <= 1\n        assert not BaseTag(0x00000001) <= 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_le_diff_class", "self", "test", "__le__", "of", "two", "classes", "with", "different", "type", "assert", "basetag", "0x00000000", "1", "assert", "basetag", "0x00000001", "1", "assert", "not", "basetag", "0x00000001", "0"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_le_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_le_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_le_subclass(self):\n        \"\"\"Test __le__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert BaseTagPlus(0x00000000) <= BaseTag(0x00000001)\n        assert BaseTagPlus(0x00000001) <= BaseTag(0x00000001)\n        assert not BaseTagPlus(0x00000001) <= BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_le_subclass", "self", "test", "__le__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "basetagplus", "0x00000000", "basetag", "0x00000001", "assert", "basetagplus", "0x00000001", "basetag", "0x00000001", "assert", "not", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_le_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_le_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_le_tuple(self):\n        \"\"\"Test __le__ of tuple with BaseTag.\"\"\"\n        assert BaseTag(0x00010001) <= (0x0001, 0x0002)\n        assert BaseTag(0x00010002) <= (0x0001, 0x0002)\n        assert not BaseTag(0x00010002) <= (0x0001, 0x0001)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_le_tuple", "self", "test", "__le__", "of", "tuple", "with", "basetag", "assert", "basetag", "0x00010001", "0x0001", "0x0002", "assert", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "not", "basetag", "0x00010002", "0x0001", "0x0001"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_le_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_le_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_le_raises(self):\n        \"\"\"Test __le__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) <= 'Somethin'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_le_raises", "self", "test", "__le__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "somethin", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_lt_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_lt_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_lt_same_class(self):\n        \"\"\"Test __lt__ of two classes with same type.\"\"\"\n        assert BaseTag(0x00000000) < BaseTag(0x00000001)\n        assert not BaseTag(0x00000001) < BaseTag(0x00000001)\n        assert not BaseTag(0x00000001) < BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_lt_same_class", "self", "test", "__lt__", "of", "two", "classes", "with", "same", "type", "assert", "basetag", "0x00000000", "basetag", "0x00000001", "assert", "not", "basetag", "0x00000001", "basetag", "0x00000001", "assert", "not", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_lt_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_lt_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_lt_diff_class(self):\n        \"\"\"Test __lt__ of two classes with different type.\"\"\"\n        assert BaseTag(0x00000000) < 1\n        assert not BaseTag(0x00000001) < 1\n        assert not BaseTag(0x00000001) < 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_lt_diff_class", "self", "test", "__lt__", "of", "two", "classes", "with", "different", "type", "assert", "basetag", "0x00000000", "1", "assert", "not", "basetag", "0x00000001", "1", "assert", "not", "basetag", "0x00000001", "0"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_lt_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_lt_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_lt_subclass(self):\n        \"\"\"Test __lt__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert BaseTagPlus(0x00000000) < BaseTag(0x00000001)\n        assert not BaseTagPlus(0x00000001) < BaseTag(0x00000001)\n        assert not BaseTagPlus(0x00000001) < BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_lt_subclass", "self", "test", "__lt__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "basetagplus", "0x00000000", "basetag", "0x00000001", "assert", "not", "basetagplus", "0x00000001", "basetag", "0x00000001", "assert", "not", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_lt_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_lt_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_lt_tuple(self):\n        \"\"\"Test __lt__ of tuple with BaseTag.\"\"\"\n        assert BaseTag(0x00010001) < (0x0001, 0x0002)\n        assert not BaseTag(0x00010002) < (0x0001, 0x0002)\n        assert not BaseTag(0x00010002) < (0x0001, 0x0001)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_lt_tuple", "self", "test", "__lt__", "of", "tuple", "with", "basetag", "assert", "basetag", "0x00010001", "0x0001", "0x0002", "assert", "not", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "not", "basetag", "0x00010002", "0x0001", "0x0001"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_lt_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_lt_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_lt_raises(self):\n        \"\"\"Test __lt__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) < 'Somethin'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_lt_raises", "self", "test", "__lt__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "somethin", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ge_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ge_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ge_same_class(self):\n        \"\"\"Test __ge__ of two classes with same type.\"\"\"\n        assert not BaseTag(0x00000000) >= BaseTag(0x00000001)\n        assert BaseTag(0x00000001) >= BaseTag(0x00000001)\n        assert BaseTag(0x00000001) >= BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ge_same_class", "self", "test", "__ge__", "of", "two", "classes", "with", "same", "type", "assert", "not", "basetag", "0x00000000", "basetag", "0x00000001", "assert", "basetag", "0x00000001", "basetag", "0x00000001", "assert", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ge_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ge_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ge_diff_class(self):\n        \"\"\"Test __ge__ of two classes with different type.\"\"\"\n        assert not BaseTag(0x00000000) >= 1\n        assert BaseTag(0x00000001) >= 1\n        assert BaseTag(0x00000001) >= 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ge_diff_class", "self", "test", "__ge__", "of", "two", "classes", "with", "different", "type", "assert", "not", "basetag", "0x00000000", "1", "assert", "basetag", "0x00000001", "1", "assert", "basetag", "0x00000001", "0"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ge_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ge_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ge_subclass(self):\n        \"\"\"Test __ge__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert not BaseTagPlus(0x00000000) >= BaseTag(0x00000001)\n        assert BaseTagPlus(0x00000001) >= BaseTag(0x00000001)\n        assert BaseTagPlus(0x00000001) >= BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ge_subclass", "self", "test", "__ge__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "not", "basetagplus", "0x00000000", "basetag", "0x00000001", "assert", "basetagplus", "0x00000001", "basetag", "0x00000001", "assert", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ge_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ge_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ge_tuple(self):\n        \"\"\"Test __ge__ of tuple with BaseTag.\"\"\"\n        assert not BaseTag(0x00010001) >= (0x0001, 0x0002)\n        assert BaseTag(0x00010002) >= (0x0001, 0x0002)\n        assert BaseTag(0x00010002) >= (0x0001, 0x0001)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ge_tuple", "self", "test", "__ge__", "of", "tuple", "with", "basetag", "assert", "not", "basetag", "0x00010001", "0x0001", "0x0002", "assert", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "basetag", "0x00010002", "0x0001", "0x0001"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ge_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ge_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ge_raises(self):\n        \"\"\"Test __ge__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) >= 'AGHIJJJJ'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ge_raises", "self", "test", "__ge__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "aghijjjj", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_gt_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_gt_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_gt_same_class(self):\n        \"\"\"Test __gt__ of two classes with same type.\"\"\"\n        assert not BaseTag(0x00000000) > BaseTag(0x00000001)\n        assert not BaseTag(0x00000001) > BaseTag(0x00000001)\n        assert BaseTag(0x00000001) > BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_gt_same_class", "self", "test", "__gt__", "of", "two", "classes", "with", "same", "type", "assert", "not", "basetag", "0x00000000", "basetag", "0x00000001", "assert", "not", "basetag", "0x00000001", "basetag", "0x00000001", "assert", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_gt_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_gt_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_gt_diff_class(self):\n        \"\"\"Test __gt__ of two classes with different type.\"\"\"\n        assert not BaseTag(0x00000000) > 1\n        assert not BaseTag(0x00000001) > 1\n        assert BaseTag(0x00000001) > 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_gt_diff_class", "self", "test", "__gt__", "of", "two", "classes", "with", "different", "type", "assert", "not", "basetag", "0x00000000", "1", "assert", "not", "basetag", "0x00000001", "1", "assert", "basetag", "0x00000001", "0"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_gt_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_gt_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_gt_subclass(self):\n        \"\"\"Test __gt__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert not BaseTagPlus(0x00000000) > BaseTag(0x00000001)\n        assert not BaseTagPlus(0x00000001) > BaseTag(0x00000001)\n        assert BaseTagPlus(0x00000001) > BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_gt_subclass", "self", "test", "__gt__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "not", "basetagplus", "0x00000000", "basetag", "0x00000001", "assert", "not", "basetagplus", "0x00000001", "basetag", "0x00000001", "assert", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_gt_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_gt_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_gt_tuple(self):\n        \"\"\"Test __gt__ of tuple with BaseTag.\"\"\"\n        assert not BaseTag(0x00010001) > (0x0001, 0x0002)\n        assert not BaseTag(0x00010002) > (0x0001, 0x0002)\n        assert BaseTag(0x00010002) > (0x0001, 0x0001)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_gt_tuple", "self", "test", "__gt__", "of", "tuple", "with", "basetag", "assert", "not", "basetag", "0x00010001", "0x0001", "0x0002", "assert", "not", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "basetag", "0x00010002", "0x0001", "0x0001"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_gt_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_gt_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_gt_raises(self):\n        \"\"\"Test __gt__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) > 'BLUH'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_gt_raises", "self", "test", "__gt__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "bluh", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_eq_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_eq_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_eq_same_class(self):\n        \"\"\"Test __eq__ of two classes with same type.\"\"\"\n        assert BaseTag(0x00000000) == BaseTag(0x00000000)\n        assert not BaseTag(0x00000001) == BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_eq_same_class", "self", "test", "__eq__", "of", "two", "classes", "with", "same", "type", "assert", "basetag", "0x00000000", "basetag", "0x00000000", "assert", "not", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_eq_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_eq_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_eq_diff_class(self):\n        \"\"\"Test __eq__ of two classes with different type.\"\"\"\n        # Make sure to test BaseTag.__eq__() not int.__eq__()\n        assert BaseTag(0x00000000) == 0\n        assert not BaseTag(0x00000001) == 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_eq_diff_class", "self", "test", "__eq__", "of", "two", "classes", "with", "different", "type", "make", "sure", "to", "test", "basetag", "__eq__", "not", "int", "__eq__", "assert", "basetag", "0x00000000", "0", "assert", "not", "basetag", "0x00000001", "0"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_eq_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_eq_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_eq_subclass(self):\n        \"\"\"Test __eq__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert BaseTagPlus(0x00000000) == BaseTag(0x00000000)\n        assert not BaseTagPlus(0x00000001) == BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_eq_subclass", "self", "test", "__eq__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "basetagplus", "0x00000000", "basetag", "0x00000000", "assert", "not", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_eq_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_eq_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_eq_tuple(self):\n        \"\"\"Test __eq__ of tuple with BaseTag.\"\"\"\n        # Make sure to test BaseTag.__eq__() not tuple.__eq__()\n        assert BaseTag(0x00010002) == (0x0001, 0x0002)\n        assert not BaseTag(0x00010001) == (0x0001, 0x0002)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_eq_tuple", "self", "test", "__eq__", "of", "tuple", "with", "basetag", "make", "sure", "to", "test", "basetag", "__eq__", "not", "tuple", "__eq__", "assert", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "not", "basetag", "0x00010001", "0x0001", "0x0002"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_eq_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_eq_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_eq_raises(self):\n        \"\"\"Test __eq__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) == 'eraa'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_eq_raises", "self", "test", "__eq__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "eraa", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ne_same_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ne_same_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ne_same_class(self):\n        \"\"\"Test __ne__ of two classes with same type.\"\"\"\n        assert not BaseTag(0x00000000) != BaseTag(0x00000000)\n        assert BaseTag(0x00000001) != BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ne_same_class", "self", "test", "__ne__", "of", "two", "classes", "with", "same", "type", "assert", "not", "basetag", "0x00000000", "basetag", "0x00000000", "assert", "basetag", "0x00000001", "basetag", "0x00000000"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ne_diff_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ne_diff_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ne_diff_class(self):\n        \"\"\"Test __ne__ of two classes with different type.\"\"\"\n        # Make sure to test BaseTag.__ne__() not int.__ne__()\n        assert not BaseTag(0x00000000) != 0\n        assert BaseTag(0x00000001) != 0\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ne_diff_class", "self", "test", "__ne__", "of", "two", "classes", "with", "different", "type", "make", "sure", "to", "test", "basetag", "__ne__", "not", "int", "__ne__", "assert", "not", "basetag", "0x00000000", "0", "assert", "basetag", "0x00000001", "0"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ne_subclass", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ne_subclass", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ne_subclass(self):\n        \"\"\"Test __ne__ of two classes with one as a subclass.\"\"\"\n        class BaseTagPlus(BaseTag):\n            pass\n        assert not BaseTagPlus(0x00000000) != BaseTag(0x00000000)\n        assert BaseTagPlus(0x00000001) != BaseTag(0x00000000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ne_subclass", "self", "test", "__ne__", "of", "two", "classes", "with", "one", "as", "a", "subclass", "class", "basetagplus", "basetag", "pass", "assert", "not", "basetagplus", "0x00000000", "basetag", "0x00000000", "assert", "basetagplus", "0x00000001", "basetag", "0x00000000"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ne_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ne_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ne_tuple(self):\n        \"\"\"Test __ne__ of tuple with BaseTag.\"\"\"\n        # Make sure to test BaseTag.__ne__() not tuple.__ne__()\n        assert not BaseTag(0x00010002) != (0x0001, 0x0002)\n        assert BaseTag(0x00010001) != (0x0001, 0x0002)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ne_tuple", "self", "test", "__ne__", "of", "tuple", "with", "basetag", "make", "sure", "to", "test", "basetag", "__ne__", "not", "tuple", "__ne__", "assert", "not", "basetag", "0x00010002", "0x0001", "0x0002", "assert", "basetag", "0x00010001", "0x0001", "0x0002"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_ne_raises", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_ne_raises", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_ne_raises(self):\n        \"\"\"Test __ne__ raises TypeError when comparing to non numeric.\"\"\"\n        def test_raise():\n            BaseTag(0x00010002) != 'aaag'\n        pytest.raises(TypeError, test_raise)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_ne_raises", "self", "test", "__ne__", "raises", "typeerror", "when", "comparing", "to", "non", "numeric", "def", "test_raise", "basetag", "0x00010002", "aaag", "pytest", "raises", "typeerror", "test_raise"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_hash", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_hash(self):\n        \"\"\"Test hash of BaseTag class.\"\"\"\n        assert hash(BaseTag(0x00010001)) == hash(BaseTag(0x00010001))\n        assert hash(BaseTag(0x00010001)) != hash(BaseTag(0x00010002))\n        assert hash(BaseTag(0x00020001)) != hash(BaseTag(0x00010002))\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_hash", "self", "test", "hash", "of", "basetag", "class", "assert", "hash", "basetag", "0x00010001", "hash", "basetag", "0x00010001", "assert", "hash", "basetag", "0x00010001", "hash", "basetag", "0x00010002", "assert", "hash", "basetag", "0x00020001", "hash", "basetag", "0x00010002"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_str", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_str", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_str(self):\n        \"\"\"Test str(BaseTag) produces correct value.\"\"\"\n        assert '(0000, 0000)' == str(BaseTag(0x00000000))\n        assert '(0001, 0002)' == str(BaseTag(0x00010002))\n        assert '(1000, 2000)' == str(BaseTag(0x10002000))\n        assert '(ffff, fffe)' == str(BaseTag(0xFFFFFFFE))\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_str", "self", "test", "str", "basetag", "produces", "correct", "value", "assert", "0000", "0000", "str", "basetag", "0x00000000", "assert", "0001", "0002", "str", "basetag", "0x00010002", "assert", "1000", "2000", "str", "basetag", "0x10002000", "assert", "ffff", "fffe", "str", "basetag", "0xfffffffe"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_group", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_group", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_group(self):\n        \"\"\"Test BaseTag.group returns correct values.\"\"\"\n        assert 0x0000 == BaseTag(0x00000001).group\n        assert 0x0002 == BaseTag(0x00020001).group\n        assert 0xFFFF == BaseTag(0xFFFF0001).group\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_group", "self", "test", "basetag", "group", "returns", "correct", "values", "assert", "0x0000", "basetag", "0x00000001", "group", "assert", "0x0002", "basetag", "0x00020001", "group", "assert", "0xffff", "basetag", "0xffff0001", "group"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_element", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_element", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_element(self):\n        \"\"\"Test BaseTag.element returns correct values.\"\"\"\n        assert 0x0000 == BaseTag(0x00010000).element\n        assert 0x0002 == BaseTag(0x00010002).element\n        assert 0xFFFF == BaseTag(0x0001FFFF).element\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_element", "self", "test", "basetag", "element", "returns", "correct", "values", "assert", "0x0000", "basetag", "0x00010000", "element", "assert", "0x0002", "basetag", "0x00010002", "element", "assert", "0xffff", "basetag", "0x0001ffff", "element"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_private", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_private", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_private(self):\n        \"\"\"Test BaseTag.is_private returns correct values.\"\"\"\n        # Odd groups private\n        assert BaseTag(0x00010001).is_private\n        # Even groups not private\n        assert not BaseTag(0x00020001).is_private\n        # Group 0 not private\n        assert not BaseTag(0x00000001).is_private\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_private", "self", "test", "basetag", "is_private", "returns", "correct", "values", "odd", "groups", "private", "assert", "basetag", "0x00010001", "is_private", "even", "groups", "not", "private", "assert", "not", "basetag", "0x00020001", "is_private", "group", "0", "not", "private", "assert", "not", "basetag", "0x00000001", "is_private"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_private_creator", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_private_creator", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_private_creator(self):\n        \"\"\"Test BaseTag.is_private_creator returns correct values.\"\"\"\n        # Non-private tag\n        assert not BaseTag(0x00080010).is_private_creator\n        # private creator have element 0x0010 - 0x00FF\n        assert not BaseTag(0x0009000F).is_private_creator\n        assert BaseTag(0x00090010).is_private_creator\n        assert BaseTag(0x000900FF).is_private_creator\n        assert not BaseTag(0x00090100).is_private_creator\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_private_creator", "self", "test", "basetag", "is_private_creator", "returns", "correct", "values", "non", "private", "tag", "assert", "not", "basetag", "0x00080010", "is_private_creator", "private", "creator", "have", "element", "0x0010", "0x00ff", "assert", "not", "basetag", "0x0009000f", "is_private_creator", "assert", "basetag", "0x00090010", "is_private_creator", "assert", "basetag", "0x000900ff", "is_private_creator", "assert", "not", "basetag", "0x00090100", "is_private_creator"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_tag.py::TestBaseTag.test_base_class", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestBaseTag", "func_name": "test_base_class", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestBaseTag\n    def test_base_class(self):\n        \"\"\"Test the class BaseTag inherits from.\"\"\"\n        if in_py2:\n            # Test for overflow of int\n            tag = Tag(0xFFFFFFFF)\n            assert isinstance(tag, long)\n        else:\n            tag = Tag(0xFFFFFFFF)\n            assert isinstance(tag, int)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testbasetag", "def", "test_base_class", "self", "test", "the", "class", "basetag", "inherits", "from", "if", "in_py2", "test", "for", "overflow", "of", "int", "tag", "tag", "0xffffffff", "assert", "isinstance", "tag", "long", "else", "tag", "tag", "0xffffffff", "assert", "isinstance", "tag", "int"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_single_int", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_single_int", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_single_int(self):\n        \"\"\"Test creating a Tag from a single int.\"\"\"\n        assert Tag(0x0000) == BaseTag(0x00000000)\n        assert Tag(10) == BaseTag(0x0000000A)\n        assert Tag(0xFFFF) == BaseTag(0x0000FFFF)\n        assert Tag(0x00010002) == BaseTag(0x00010002)\n\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, 0xFFFFFFFF1)\n        # Must be positive\n        pytest.raises(ValueError, Tag, -1)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_single_int", "self", "test", "creating", "a", "tag", "from", "a", "single", "int", "assert", "tag", "0x0000", "basetag", "0x00000000", "assert", "tag", "10", "basetag", "0x0000000a", "assert", "tag", "0xffff", "basetag", "0x0000ffff", "assert", "tag", "0x00010002", "basetag", "0x00010002", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "0xffffffff1", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "1"], "doc_len": 53}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_single_tuple", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_single_tuple", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_single_tuple(self):\n        \"\"\"Test creating a Tag from a single tuple.\"\"\"\n        assert Tag((0x0000, 0x0000)) == BaseTag(0x00000000)\n        assert Tag((0x22, 0xFF)) == BaseTag(0x002200FF)\n        assert Tag((14, 0xF)) == BaseTag(0x000E000F)\n        assert Tag((0x1000, 0x2000)) == BaseTag(0x10002000)\n        assert Tag(('0x01', '0x02')) == BaseTag(0x00010002)\n\n        # Must be 2 tuple\n        pytest.raises(ValueError, Tag, (0x1000, 0x2000, 0x0030))\n        pytest.raises(ValueError, Tag, ('0x10', '0x20', '0x03'))\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, (0xFFFF, 0xFFFF1))\n        pytest.raises(OverflowError, Tag, ('0xFFFF', '0xFFFF1'))\n        # Must be positive\n        pytest.raises(ValueError, Tag, (-1, 0))\n        pytest.raises(ValueError, Tag, (0, -1))\n        pytest.raises(ValueError, Tag, ('0x0', '-0x1'))\n        pytest.raises(ValueError, Tag, ('-0x1', '0x0'))\n        # Can't have second parameter\n        pytest.raises(ValueError, Tag, (0x01, 0x02), 0x01)\n        pytest.raises(ValueError, Tag, (0x01, 0x02), '0x01')\n        pytest.raises(ValueError, Tag, ('0x01', '0x02'), '0x01')\n        pytest.raises(ValueError, Tag, ('0x01', '0x02'), 0x01)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_single_tuple", "self", "test", "creating", "a", "tag", "from", "a", "single", "tuple", "assert", "tag", "0x0000", "0x0000", "basetag", "0x00000000", "assert", "tag", "0x22", "0xff", "basetag", "0x002200ff", "assert", "tag", "14", "0xf", "basetag", "0x000e000f", "assert", "tag", "0x1000", "0x2000", "basetag", "0x10002000", "assert", "tag", "0x01", "0x02", "basetag", "0x00010002", "must", "be", "2", "tuple", "pytest", "raises", "valueerror", "tag", "0x1000", "0x2000", "0x0030", "pytest", "raises", "valueerror", "tag", "0x10", "0x20", "0x03", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "0xffff", "0xffff1", "pytest", "raises", "overflowerror", "tag", "0xffff", "0xffff1", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "1", "0", "pytest", "raises", "valueerror", "tag", "0", "1", "pytest", "raises", "valueerror", "tag", "0x0", "0x1", "pytest", "raises", "valueerror", "tag", "0x1", "0x0", "can", "t", "have", "second", "parameter", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01"], "doc_len": 140}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_single_list", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_single_list", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_single_list(self):\n        \"\"\"Test creating a Tag from a single list.\"\"\"\n        assert Tag([0x0000, 0x0000]) == BaseTag(0x00000000)\n        assert Tag([0x99, 0xFE]) == BaseTag(0x009900FE)\n        assert Tag([15, 0xE]) == BaseTag(0x000F000E)\n        assert Tag([0x1000, 0x2000]) == BaseTag(0x10002000)\n        assert Tag(['0x01', '0x02']) == BaseTag(0x00010002)\n\n        # Must be 2 list\n        pytest.raises(ValueError, Tag, [0x1000, 0x2000, 0x0030])\n        pytest.raises(ValueError, Tag, ['0x10', '0x20', '0x03'])\n        pytest.raises(ValueError, Tag, [0x1000])\n        pytest.raises(ValueError, Tag, ['0x10'])\n\n        # Must be int or string\n        pytest.raises(ValueError, Tag, [1., 2.])\n\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, [65536, 0])\n        pytest.raises(OverflowError, Tag, [0, 65536])\n        pytest.raises(OverflowError, Tag, ('0xFFFF', '0xFFFF1'))\n        # Must be positive\n        pytest.raises(ValueError, Tag, [-1, 0])\n        pytest.raises(ValueError, Tag, [0, -1])\n        pytest.raises(ValueError, Tag, ('0x0', '-0x1'))\n        pytest.raises(ValueError, Tag, ('-0x1', '0x0'))\n        # Can't have second parameter\n        pytest.raises(ValueError, Tag, [0x01, 0x02], 0x01)\n        pytest.raises(ValueError, Tag, [0x01, 0x02], '0x01')\n        pytest.raises(ValueError, Tag, ['0x01', '0x02'], '0x01')\n        pytest.raises(ValueError, Tag, ['0x01', '0x02'], 0x01)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_single_list", "self", "test", "creating", "a", "tag", "from", "a", "single", "list", "assert", "tag", "0x0000", "0x0000", "basetag", "0x00000000", "assert", "tag", "0x99", "0xfe", "basetag", "0x009900fe", "assert", "tag", "15", "0xe", "basetag", "0x000f000e", "assert", "tag", "0x1000", "0x2000", "basetag", "0x10002000", "assert", "tag", "0x01", "0x02", "basetag", "0x00010002", "must", "be", "2", "list", "pytest", "raises", "valueerror", "tag", "0x1000", "0x2000", "0x0030", "pytest", "raises", "valueerror", "tag", "0x10", "0x20", "0x03", "pytest", "raises", "valueerror", "tag", "0x1000", "pytest", "raises", "valueerror", "tag", "0x10", "must", "be", "int", "or", "string", "pytest", "raises", "valueerror", "tag", "1", "2", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "65536", "0", "pytest", "raises", "overflowerror", "tag", "0", "65536", "pytest", "raises", "overflowerror", "tag", "0xffff", "0xffff1", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "1", "0", "pytest", "raises", "valueerror", "tag", "0", "1", "pytest", "raises", "valueerror", "tag", "0x0", "0x1", "pytest", "raises", "valueerror", "tag", "0x1", "0x0", "can", "t", "have", "second", "parameter", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01", "pytest", "raises", "valueerror", "tag", "0x01", "0x02", "0x01"], "doc_len": 167}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_mixed_long_int", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_mixed_long_int", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_mixed_long_int(self):\n        assert Tag([0x1000, long(0x2000)]) == BaseTag(0x10002000)\n        assert Tag([long(0x1000), 0x2000]) == BaseTag(0x10002000)\n        assert Tag([long(0x1000), long(0x2000)]) == BaseTag(0x10002000)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_mixed_long_int", "self", "assert", "tag", "0x1000", "long", "0x2000", "basetag", "0x10002000", "assert", "tag", "long", "0x1000", "0x2000", "basetag", "0x10002000", "assert", "tag", "long", "0x1000", "long", "0x2000", "basetag", "0x10002000"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_single_str", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_single_str", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_single_str(self):\n        \"\"\"Test creating a Tag from a single str.\"\"\"\n        assert Tag('0x10002000') == BaseTag(0x10002000)\n        assert Tag('0x2000') == BaseTag(0x00002000)\n        assert Tag('15') == BaseTag(0x00000015)\n        assert Tag('0xF') == BaseTag(0x0000000F)\n        assert Tag(\"PatientName\") == BaseTag(0x00100010)\n\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, '0xFFFFFFFF1')\n        # Must be positive\n        pytest.raises(ValueError, Tag, '-0x01')\n        # Must be numeric str or DICOM keyword\n        pytest.raises(ValueError, Tag, 'hello')\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_single_str", "self", "test", "creating", "a", "tag", "from", "a", "single", "str", "assert", "tag", "0x10002000", "basetag", "0x10002000", "assert", "tag", "0x2000", "basetag", "0x00002000", "assert", "tag", "15", "basetag", "0x00000015", "assert", "tag", "0xf", "basetag", "0x0000000f", "assert", "tag", "patientname", "basetag", "0x00100010", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "0xffffffff1", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "0x01", "must", "be", "numeric", "str", "or", "dicom", "keyword", "pytest", "raises", "valueerror", "tag", "hello"], "doc_len": 70}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_double_str", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_double_str", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_double_str(self):\n        \"\"\"Test creating a Tag from two str.\"\"\"\n        assert Tag('0x1000', '0x2000') == BaseTag(0x10002000)\n        assert Tag('0x10', '0x20') == BaseTag(0x00100020)\n        assert Tag('15', '0') == BaseTag(0x00150000)\n        assert Tag('0xF', '0') == BaseTag(0x000F0000)\n\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, '0xFFFF1', '0')\n        pytest.raises(OverflowError, Tag, '0', '0xFFFF1')\n        # Must be positive\n        pytest.raises(ValueError, Tag, '-0x01', '0')\n        pytest.raises(ValueError, Tag, '0', '-0x01')\n        pytest.raises(ValueError, Tag, '-1', '-0x01')\n        # Must both be str\n        pytest.raises(ValueError, Tag, '0x01', 0)\n        pytest.raises(ValueError, Tag, 0, '0x01')\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_double_str", "self", "test", "creating", "a", "tag", "from", "two", "str", "assert", "tag", "0x1000", "0x2000", "basetag", "0x10002000", "assert", "tag", "0x10", "0x20", "basetag", "0x00100020", "assert", "tag", "15", "0", "basetag", "0x00150000", "assert", "tag", "0xf", "0", "basetag", "0x000f0000", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "0xffff1", "0", "pytest", "raises", "overflowerror", "tag", "0", "0xffff1", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "0x01", "0", "pytest", "raises", "valueerror", "tag", "0", "0x01", "pytest", "raises", "valueerror", "tag", "1", "0x01", "must", "both", "be", "str", "pytest", "raises", "valueerror", "tag", "0x01", "0", "pytest", "raises", "valueerror", "tag", "0", "0x01"], "doc_len": 92}
{"doc_id": "pydicom/tests/test_tag.py::TestTag.test_tag_double_int", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTag", "func_name": "test_tag_double_int", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTag\n    def test_tag_double_int(self):\n        \"\"\"Test creating a Tag from a two ints.\"\"\"\n        assert Tag(0x0000, 0x0000) == BaseTag(0x00000000)\n        assert Tag(2, 0) == BaseTag(0x00020000)\n        assert Tag(2, 0).elem == 0x0000\n        assert Tag(0x99, 0xFE) == BaseTag(0x009900FE)\n        assert Tag(15, 14) == BaseTag(0x000F000E)\n        assert Tag(0x1000, 0x2000) == BaseTag(0x10002000)\n\n        # Must be 32-bit\n        pytest.raises(OverflowError, Tag, 65536, 0)\n        pytest.raises(OverflowError, Tag, 0, 65536)\n        # Must be positive\n        pytest.raises(ValueError, Tag, -1, 0)\n        pytest.raises(ValueError, Tag, 0, -1)\n        pytest.raises(ValueError, Tag, -65535, -1)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtag", "def", "test_tag_double_int", "self", "test", "creating", "a", "tag", "from", "a", "two", "ints", "assert", "tag", "0x0000", "0x0000", "basetag", "0x00000000", "assert", "tag", "2", "0", "basetag", "0x00020000", "assert", "tag", "2", "0", "elem", "0x0000", "assert", "tag", "0x99", "0xfe", "basetag", "0x009900fe", "assert", "tag", "15", "14", "basetag", "0x000f000e", "assert", "tag", "0x1000", "0x2000", "basetag", "0x10002000", "must", "be", "32", "bit", "pytest", "raises", "overflowerror", "tag", "65536", "0", "pytest", "raises", "overflowerror", "tag", "0", "65536", "must", "be", "positive", "pytest", "raises", "valueerror", "tag", "1", "0", "pytest", "raises", "valueerror", "tag", "0", "1", "pytest", "raises", "valueerror", "tag", "65535", "1"], "doc_len": 89}
{"doc_id": "pydicom/tests/test_tag.py::TestTupleTag.test_tuple_tag", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTupleTag", "func_name": "test_tuple_tag", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTupleTag\n    def test_tuple_tag(self):\n        \"\"\"Test quick tag construction with TupleTag.\"\"\"\n        assert TupleTag((0xFFFF, 0xFFee)) == BaseTag(0xFFFFFFEE)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtupletag", "def", "test_tuple_tag", "self", "test", "quick", "tag", "construction", "with", "tupletag", "assert", "tupletag", "0xffff", "0xffee", "basetag", "0xffffffee"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_tag.py::TestTagInException.test_raise_exception", "file_path": "pydicom/tests/test_tag.py", "class_name": "TestTagInException", "func_name": "test_raise_exception", "text": "文件路径: pydicom/tests/test_tag.py, 类名: TestTagInException\n    def test_raise_exception(self):\n        \"\"\"\"\"\"\n        def test():\n            tag = Tag(0x00100010)\n            with tag_in_exception(tag) as tag:\n                raise ValueError('Test message.')\n        pytest.raises(ValueError, test)\n", "tokens": ["pydicom", "tests", "test_tag", "py", "testtaginexception", "def", "test_raise_exception", "self", "def", "test", "tag", "tag", "0x00100010", "with", "tag_in_exception", "tag", "as", "tag", "raise", "valueerror", "test", "message", "pytest", "raises", "valueerror", "test"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_uid.py::TestGenerateUID.test_generate_uid", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestGenerateUID", "func_name": "test_generate_uid", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestGenerateUID\n    def test_generate_uid(self):\n        \"\"\"Test UID generator\"\"\"\n        # Test standard UID generation with pydicom prefix\n        uid = generate_uid()\n        assert uid[:26] == PYDICOM_ROOT_UID\n        assert len(uid) <= 64\n\n        # Test standard UID generation with no prefix\n        uid = generate_uid(None)\n        assert uid[:5] == '2.25.'\n        assert len(uid) <= 64\n\n        # Test invalid UID prefixes\n        for invalid_prefix in (('1' * 63) + '.',\n                               '',\n                               '.',\n                               '1',\n                               '1.2',\n                               '1.2..3.',\n                               '1.a.2.',\n                               '1.01.1.'):\n            with pytest.raises(ValueError):\n                generate_uid(prefix=invalid_prefix)\n\n        # Test some valid prefixes and make sure they survive\n        for valid_prefix in ('0.',\n                             '1.',\n                             '1.23.',\n                             '1.0.23.',\n                             ('1' * 62) + '.',\n                             '1.2.3.444444.'):\n            uid = generate_uid(prefix=valid_prefix)\n\n            assert uid[:len(valid_prefix)] == valid_prefix\n            assert len(uid) <= 64\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testgenerateuid", "def", "test_generate_uid", "self", "test", "uid", "generator", "test", "standard", "uid", "generation", "with", "pydicom", "prefix", "uid", "generate_uid", "assert", "uid", "26", "pydicom_root_uid", "assert", "len", "uid", "64", "test", "standard", "uid", "generation", "with", "no", "prefix", "uid", "generate_uid", "none", "assert", "uid", "5", "2", "25", "assert", "len", "uid", "64", "test", "invalid", "uid", "prefixes", "for", "invalid_prefix", "in", "1", "63", "1", "1", "2", "1", "2", "3", "1", "a", "2", "1", "01", "1", "with", "pytest", "raises", "valueerror", "generate_uid", "prefix", "invalid_prefix", "test", "some", "valid", "prefixes", "and", "make", "sure", "they", "survive", "for", "valid_prefix", "in", "0", "1", "1", "23", "1", "0", "23", "1", "62", "1", "2", "3", "444444", "uid", "generate_uid", "prefix", "valid_prefix", "assert", "uid", "len", "valid_prefix", "valid_prefix", "assert", "len", "uid", "64"], "doc_len": 113}
{"doc_id": "pydicom/tests/test_uid.py::TestGenerateUID.test_entropy_src", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestGenerateUID", "func_name": "test_entropy_src", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestGenerateUID\n    def test_entropy_src(self):\n        \"\"\"Test UID generator with default entropy sources\"\"\"\n        # Should be different\n        uid = generate_uid(entropy_srcs=None)\n        assert uid != generate_uid(entropy_srcs=None)\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testgenerateuid", "def", "test_entropy_src", "self", "test", "uid", "generator", "with", "default", "entropy", "sources", "should", "be", "different", "uid", "generate_uid", "entropy_srcs", "none", "assert", "uid", "generate_uid", "entropy_srcs", "none"], "doc_len": 27}
{"doc_id": "pydicom/tests/test_uid.py::TestGenerateUID.test_entropy_src_custom", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestGenerateUID", "func_name": "test_entropy_src_custom", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestGenerateUID\n    def test_entropy_src_custom(self):\n        \"\"\"Test UID generator with custom entropy sources\"\"\"\n        # Should be identical\n        uid = generate_uid(entropy_srcs=['lorem', 'ipsum'])\n        rf = '1.2.826.0.1.3680043.8.498.87507166259346337659265156363895084463'\n        assert uid == rf\n        assert len(uid) == 64\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testgenerateuid", "def", "test_entropy_src_custom", "self", "test", "uid", "generator", "with", "custom", "entropy", "sources", "should", "be", "identical", "uid", "generate_uid", "entropy_srcs", "lorem", "ipsum", "rf", "1", "2", "826", "0", "1", "3680043", "8", "498", "87507166259346337659265156363895084463", "assert", "uid", "rf", "assert", "len", "uid", "64"], "doc_len": 40}
{"doc_id": "pydicom/tests/test_uid.py::TestGenerateUID.test_none", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestGenerateUID", "func_name": "test_none", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestGenerateUID\n    def test_none(self):\n        \"\"\"Test generate_uid(None).\"\"\"\n        uid = generate_uid(prefix=None)\n        # Check prefix\n        assert '2.25.' == uid[:5]\n        # Check UUID suffix\n        as_uuid = uuid.UUID(int=int(uid[5:]))\n        assert isinstance(as_uuid, uuid.UUID)\n        assert as_uuid.version == 4\n        assert as_uuid.variant == uuid.RFC_4122\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testgenerateuid", "def", "test_none", "self", "test", "generate_uid", "none", "uid", "generate_uid", "prefix", "none", "check", "prefix", "assert", "2", "25", "uid", "5", "check", "uuid", "suffix", "as_uuid", "uuid", "uuid", "int", "int", "uid", "5", "assert", "isinstance", "as_uuid", "uuid", "uuid", "assert", "as_uuid", "version", "4", "assert", "as_uuid", "variant", "uuid", "rfc_4122"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_uid.py::TestGenerateUID.test_none_iterate", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestGenerateUID", "func_name": "test_none_iterate", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestGenerateUID\n    def test_none_iterate(self):\n        \"\"\"Test generate_uid(None) generates valid UIDs.\"\"\"\n        # Generate random UIDs, if a bad method then should eventually fail\n        for ii in range(100000):\n            uid = generate_uid(None)\n            assert uid.is_valid\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testgenerateuid", "def", "test_none_iterate", "self", "test", "generate_uid", "none", "generates", "valid", "uids", "generate", "random", "uids", "if", "a", "bad", "method", "then", "should", "eventually", "fail", "for", "ii", "in", "range", "100000", "uid", "generate_uid", "none", "assert", "uid", "is_valid"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.setup_class", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "setup_class", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def setup_class(self):\n        \"\"\"Set default UID\"\"\"\n        self.uid = UID('1.2.840.10008.1.2')\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "setup_class", "self", "set", "default", "uid", "self", "uid", "uid", "1", "2", "840", "10008", "1", "2"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_equality", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_equality", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_equality(self):\n        \"\"\"Test that UID.__eq__ works.\"\"\"\n        assert self.uid == UID('1.2.840.10008.1.2')\n        assert self.uid == '1.2.840.10008.1.2'\n        assert '1.2.840.10008.1.2' == self.uid\n        assert not self.uid == 'Implicit VR Little Endian'\n        assert not 'Implicit VR Little Endian' == self.uid\n        assert not self.uid == UID('1.2.840.10008.1.2.1')\n        assert not self.uid == '1.2.840.10008.1.2.1'\n        assert not '1.2.840.10008.1.2.1' == self.uid\n        # Issue 96\n        assert not self.uid == 3\n        assert self.uid is not None\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_equality", "self", "test", "that", "uid", "__eq__", "works", "assert", "self", "uid", "uid", "1", "2", "840", "10008", "1", "2", "assert", "self", "uid", "1", "2", "840", "10008", "1", "2", "assert", "1", "2", "840", "10008", "1", "2", "self", "uid", "assert", "not", "self", "uid", "implicit", "vr", "little", "endian", "assert", "not", "implicit", "vr", "little", "endian", "self", "uid", "assert", "not", "self", "uid", "uid", "1", "2", "840", "10008", "1", "2", "1", "assert", "not", "self", "uid", "1", "2", "840", "10008", "1", "2", "1", "assert", "not", "1", "2", "840", "10008", "1", "2", "1", "self", "uid", "issue", "96", "assert", "not", "self", "uid", "3", "assert", "self", "uid", "is", "not", "none"], "doc_len": 104}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_inequality", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_inequality", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_inequality(self):\n        \"\"\"Test that UID.__ne__ works.\"\"\"\n        assert not self.uid != UID('1.2.840.10008.1.2')\n        assert not self.uid != '1.2.840.10008.1.2'\n        assert not '1.2.840.10008.1.2' != self.uid\n        assert self.uid != 'Implicit VR Little Endian'\n        assert 'Implicit VR Little Endian' != self.uid\n        assert self.uid != UID('1.2.840.10008.1.2.1')\n        assert self.uid != '1.2.840.10008.1.2.1'\n        assert '1.2.840.10008.1.2.1' != self.uid\n        # Issue 96\n        assert self.uid != 3\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_inequality", "self", "test", "that", "uid", "__ne__", "works", "assert", "not", "self", "uid", "uid", "1", "2", "840", "10008", "1", "2", "assert", "not", "self", "uid", "1", "2", "840", "10008", "1", "2", "assert", "not", "1", "2", "840", "10008", "1", "2", "self", "uid", "assert", "self", "uid", "implicit", "vr", "little", "endian", "assert", "implicit", "vr", "little", "endian", "self", "uid", "assert", "self", "uid", "uid", "1", "2", "840", "10008", "1", "2", "1", "assert", "self", "uid", "1", "2", "840", "10008", "1", "2", "1", "assert", "1", "2", "840", "10008", "1", "2", "1", "self", "uid", "issue", "96", "assert", "self", "uid", "3"], "doc_len": 95}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_hash", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_hash(self):\n        \"\"\"Test that UID.__hash_- works.\"\"\"\n        assert hash(self.uid) == hash(self.uid)\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_hash", "self", "test", "that", "uid", "__hash_", "works", "assert", "hash", "self", "uid", "hash", "self", "uid"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_str", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_str", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_str(self):\n        \"\"\"Test that UID.__str__ works.\"\"\"\n        assert self.uid.__str__() == '1.2.840.10008.1.2'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_str", "self", "test", "that", "uid", "__str__", "works", "assert", "self", "uid", "__str__", "1", "2", "840", "10008", "1", "2"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_implicit_vr", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_implicit_vr", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_implicit_vr(self):\n        \"\"\"Test that UID.is_implicit_VR works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert UID('1.2.840.10008.1.2').is_implicit_VR\n        assert not UID('1.2.840.10008.1.2.1').is_implicit_VR\n        assert not UID('1.2.840.10008.1.2.1.99').is_implicit_VR\n        assert not UID('1.2.840.10008.1.2.2').is_implicit_VR\n        assert not UID('1.2.840.10008.1.2.4.50').is_implicit_VR\n\n        with pytest.raises(ValueError):\n            UID('1.2.840.10008.5.1.4.1.1.2').is_implicit_VR\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_implicit_vr", "self", "test", "that", "uid", "is_implicit_vr", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "uid", "1", "2", "840", "10008", "1", "2", "is_implicit_vr", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_implicit_vr", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_implicit_vr", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_implicit_vr", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_implicit_vr", "with", "pytest", "raises", "valueerror", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_implicit_vr"], "doc_len": 141}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_little_endian", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_little_endian", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_little_endian(self):\n        \"\"\"Test that UID.is_little_endian works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert UID('1.2.840.10008.1.2').is_little_endian\n        assert UID('1.2.840.10008.1.2.1').is_little_endian\n        assert UID('1.2.840.10008.1.2.1.99').is_little_endian\n        assert not UID('1.2.840.10008.1.2.2').is_little_endian\n        assert UID('1.2.840.10008.1.2.4.50').is_little_endian\n\n        with pytest.raises(ValueError):\n            UID('1.2.840.10008.5.1.4.1.1.2').is_little_endian\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_little_endian", "self", "test", "that", "uid", "is_little_endian", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "uid", "1", "2", "840", "10008", "1", "2", "is_little_endian", "assert", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_little_endian", "assert", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_little_endian", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_little_endian", "assert", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_little_endian", "with", "pytest", "raises", "valueerror", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_little_endian"], "doc_len": 138}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_deflated", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_deflated", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_deflated(self):\n        \"\"\"Test that UID.is_deflated works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert not UID('1.2.840.10008.1.2').is_deflated\n        assert not UID('1.2.840.10008.1.2.1').is_deflated\n        assert UID('1.2.840.10008.1.2.1.99').is_deflated\n        assert not UID('1.2.840.10008.1.2.2').is_deflated\n        assert not UID('1.2.840.10008.1.2.4.50').is_deflated\n\n        with pytest.raises(ValueError):\n            UID('1.2.840.10008.5.1.4.1.1.2').is_deflated\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_deflated", "self", "test", "that", "uid", "is_deflated", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "is_deflated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_deflated", "assert", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_deflated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_deflated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_deflated", "with", "pytest", "raises", "valueerror", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_deflated"], "doc_len": 141}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_transfer_syntax", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_transfer_syntax", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_transfer_syntax(self):\n        \"\"\"Test that UID.is_transfer_syntax works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert UID('1.2.840.10008.1.2').is_transfer_syntax\n        assert UID('1.2.840.10008.1.2.1').is_transfer_syntax\n        assert UID('1.2.840.10008.1.2.1.99').is_transfer_syntax\n        assert UID('1.2.840.10008.1.2.2').is_transfer_syntax\n        assert UID('1.2.840.10008.1.2.4.50').is_transfer_syntax\n\n        assert not UID('1.2.840.10008.5.1.4.1.1.2').is_transfer_syntax\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_transfer_syntax", "self", "test", "that", "uid", "is_transfer_syntax", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "uid", "1", "2", "840", "10008", "1", "2", "is_transfer_syntax", "assert", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_transfer_syntax", "assert", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_transfer_syntax", "assert", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_transfer_syntax", "assert", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_transfer_syntax", "assert", "not", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_transfer_syntax"], "doc_len": 135}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_compressed", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_compressed", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_compressed(self):\n        \"\"\"Test that UID.is_compressed works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert not UID('1.2.840.10008.1.2').is_compressed\n        assert not UID('1.2.840.10008.1.2.1').is_compressed\n        assert not UID('1.2.840.10008.1.2.1.99').is_compressed\n        assert not UID('1.2.840.10008.1.2.2').is_compressed\n        assert UID('1.2.840.10008.1.2.4.50').is_compressed\n\n        with pytest.raises(ValueError):\n            UID('1.2.840.10008.5.1.4.1.1.2').is_compressed\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_compressed", "self", "test", "that", "uid", "is_compressed", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "is_compressed", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_compressed", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_compressed", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_compressed", "assert", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_compressed", "with", "pytest", "raises", "valueerror", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_compressed"], "doc_len": 141}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_encapsulated", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_encapsulated", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_encapsulated(self):\n        \"\"\"Test that UID.is_encapsulated works.\"\"\"\n        # '1.2.840.10008.1.2' Implicit VR Little Endian\n        # '1.2.840.10008.1.2.1' Explicit VR Little Endian\n        # '1.2.840.10008.1.2.1.99' Deflated Explicit VR Little Endian\n        # '1.2.840.10008.1.2.2' Explicit VR Big Endian\n        # '1.2.840.10008.1.2.4.50'JPEG Baseline (Process 1)\n        assert not UID('1.2.840.10008.1.2').is_encapsulated\n        assert not UID('1.2.840.10008.1.2.1').is_encapsulated\n        assert not UID('1.2.840.10008.1.2.1.99').is_encapsulated\n        assert not UID('1.2.840.10008.1.2.2').is_encapsulated\n        assert UID('1.2.840.10008.1.2.4.50').is_encapsulated\n\n        with pytest.raises(ValueError):\n            UID('1.2.840.10008.5.1.4.1.1.2').is_encapsulated\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_encapsulated", "self", "test", "that", "uid", "is_encapsulated", "works", "1", "2", "840", "10008", "1", "2", "implicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "1", "99", "deflated", "explicit", "vr", "little", "endian", "1", "2", "840", "10008", "1", "2", "2", "explicit", "vr", "big", "endian", "1", "2", "840", "10008", "1", "2", "4", "50", "jpeg", "baseline", "process", "1", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "is_encapsulated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "is_encapsulated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "1", "99", "is_encapsulated", "assert", "not", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_encapsulated", "assert", "uid", "1", "2", "840", "10008", "1", "2", "4", "50", "is_encapsulated", "with", "pytest", "raises", "valueerror", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "is_encapsulated"], "doc_len": 141}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_name", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_name", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_name(self):\n        \"\"\"Test that UID.name works.\"\"\"\n        assert self.uid.name == 'Implicit VR Little Endian'\n        assert UID('1.2.840.10008.5.1.4.1.1.2').name == 'CT Image Storage'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_name", "self", "test", "that", "uid", "name", "works", "assert", "self", "uid", "name", "implicit", "vr", "little", "endian", "assert", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "name", "ct", "image", "storage"], "doc_len": 37}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_name_with_equal_hash", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_name_with_equal_hash", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_name_with_equal_hash(self):\n        \"\"\"Test that UID name works for UID with same hash as predefined UID.\n        \"\"\"\n        class MockedUID(UID):\n            # Force the UID to return the same hash as one of the\n            # uid dictionary entries (any will work).\n            # The resulting hash collision forces the usage of the `eq`\n            # operator while checking for containment in the uid dictionary\n            # (regression test for issue #499)\n            def __hash__(self):\n                return hash(JPEGLSLossy)\n\n        uid = MockedUID('1.2.3')\n        assert uid.name == '1.2.3'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_name_with_equal_hash", "self", "test", "that", "uid", "name", "works", "for", "uid", "with", "same", "hash", "as", "predefined", "uid", "class", "mockeduid", "uid", "force", "the", "uid", "to", "return", "the", "same", "hash", "as", "one", "of", "the", "uid", "dictionary", "entries", "any", "will", "work", "the", "resulting", "hash", "collision", "forces", "the", "usage", "of", "the", "eq", "operator", "while", "checking", "for", "containment", "in", "the", "uid", "dictionary", "regression", "test", "for", "issue", "499", "def", "__hash__", "self", "return", "hash", "jpeglslossy", "uid", "mockeduid", "1", "2", "3", "assert", "uid", "name", "1", "2", "3"], "doc_len": 83}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_type", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_type", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_type(self):\n        \"\"\"Test that UID.type works.\"\"\"\n        assert self.uid.type == 'Transfer Syntax'\n        assert UID('1.2.840.10008.5.1.4.1.1.2').type == 'SOP Class'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_type", "self", "test", "that", "uid", "type", "works", "assert", "self", "uid", "type", "transfer", "syntax", "assert", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "type", "sop", "class"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_info", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_info", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_info(self):\n        \"\"\"Test that UID.info works.\"\"\"\n        assert self.uid.info == 'Default Transfer Syntax for DICOM'\n        assert UID('1.2.840.10008.5.1.4.1.1.2').info == ''\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_info", "self", "test", "that", "uid", "info", "works", "assert", "self", "uid", "info", "default", "transfer", "syntax", "for", "dicom", "assert", "uid", "1", "2", "840", "10008", "5", "1", "4", "1", "1", "2", "info"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_retired", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_retired", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_retired(self):\n        \"\"\"Test that UID.is_retired works.\"\"\"\n        assert not self.uid.is_retired\n        assert UID('1.2.840.10008.1.2.2').is_retired\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_retired", "self", "test", "that", "uid", "is_retired", "works", "assert", "not", "self", "uid", "is_retired", "assert", "uid", "1", "2", "840", "10008", "1", "2", "2", "is_retired"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_valid", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_valid", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_valid(self):\n        \"\"\"Test that UID.is_valid works.\"\"\"\n        for invalid_uid in ('1' * 65,\n                            '1.' + ('2' * 63),\n                            '',\n                            '.',\n                            '1.',\n                            '1.01',\n                            '1.a.2'):\n            assert not UID(invalid_uid).is_valid\n\n        for valid_uid in ('0',\n                          '1',\n                          '0.1',\n                          '1' * 64,\n                          '1.' + ('2' * 62),\n                          '1.0.23'):\n            assert UID(valid_uid).is_valid\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_valid", "self", "test", "that", "uid", "is_valid", "works", "for", "invalid_uid", "in", "1", "65", "1", "2", "63", "1", "1", "01", "1", "a", "2", "assert", "not", "uid", "invalid_uid", "is_valid", "for", "valid_uid", "in", "0", "1", "0", "1", "1", "64", "1", "2", "62", "1", "0", "23", "assert", "uid", "valid_uid", "is_valid"], "doc_len": 51}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_is_private", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_is_private", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_is_private(self):\n        \"\"\"Test the is_private property\"\"\"\n        private_uid = UID('1.2.840.10009.1.2')\n        assert private_uid.is_private\n        assert not self.uid.is_private\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_is_private", "self", "test", "the", "is_private", "property", "private_uid", "uid", "1", "2", "840", "10009", "1", "2", "assert", "private_uid", "is_private", "assert", "not", "self", "uid", "is_private"], "doc_len": 28}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_raises", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_raises", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_raises(self):\n        \"\"\"Test raises exception if not a str type\"\"\"\n        with pytest.raises(TypeError):\n            UID(1234)\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_raises", "self", "test", "raises", "exception", "if", "not", "a", "str", "type", "with", "pytest", "raises", "typeerror", "uid", "1234"], "doc_len": 22}
{"doc_id": "pydicom/tests/test_uid.py::TestUID.test_transitive", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUID", "func_name": "test_transitive", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUID\n    def test_transitive(self):\n        \"\"\"Test for #256\"\"\"\n        a = '1.2.840.10008.1.1'\n        uid = UID(a)\n        b = str(uid)\n        assert uid.name == 'Verification SOP Class'\n        assert uid == a\n        assert uid == b\n        assert a == b\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuid", "def", "test_transitive", "self", "test", "for", "256", "a", "1", "2", "840", "10008", "1", "1", "uid", "uid", "a", "b", "str", "uid", "assert", "uid", "name", "verification", "sop", "class", "assert", "uid", "a", "assert", "uid", "b", "assert", "a", "b"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.setup_class", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "setup_class", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def setup_class(self):\n        \"\"\"Set default UID\"\"\"\n        self.uid = UID('9.9.999.90009.1.2')\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "setup_class", "self", "set", "default", "uid", "self", "uid", "uid", "9", "9", "999", "90009", "1", "2"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_equality", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_equality", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_equality(self):\n        \"\"\"Test that UID.__eq__ works with private UIDs.\"\"\"\n        assert self.uid == UID('9.9.999.90009.1.2')\n        assert self.uid == '9.9.999.90009.1.2'\n        assert not self.uid == UID('9.9.999.90009.1.3')\n        assert not self.uid == '9.9.999.90009.1.3'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_equality", "self", "test", "that", "uid", "__eq__", "works", "with", "private", "uids", "assert", "self", "uid", "uid", "9", "9", "999", "90009", "1", "2", "assert", "self", "uid", "9", "9", "999", "90009", "1", "2", "assert", "not", "self", "uid", "uid", "9", "9", "999", "90009", "1", "3", "assert", "not", "self", "uid", "9", "9", "999", "90009", "1", "3"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_inequality", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_inequality", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_inequality(self):\n        \"\"\"Test that UID.__ne__ works with private UIDs.\"\"\"\n        assert not self.uid != UID('9.9.999.90009.1.2')\n        assert not self.uid != '9.9.999.90009.1.2'\n        assert self.uid != UID('9.9.999.90009.1.3')\n        assert self.uid != '9.9.999.90009.1.3'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_inequality", "self", "test", "that", "uid", "__ne__", "works", "with", "private", "uids", "assert", "not", "self", "uid", "uid", "9", "9", "999", "90009", "1", "2", "assert", "not", "self", "uid", "9", "9", "999", "90009", "1", "2", "assert", "self", "uid", "uid", "9", "9", "999", "90009", "1", "3", "assert", "self", "uid", "9", "9", "999", "90009", "1", "3"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_hash", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_hash(self):\n        \"\"\"Test that UID.__hash_- works with private UIDs.\"\"\"\n        assert hash(self.uid) == hash(self.uid)\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_hash", "self", "test", "that", "uid", "__hash_", "works", "with", "private", "uids", "assert", "hash", "self", "uid", "hash", "self", "uid"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_str", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_str", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_str(self):\n        \"\"\"Test that UID.__str__ works with private UIDs.\"\"\"\n        assert self.uid.__str__() == '9.9.999.90009.1.2'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_str", "self", "test", "that", "uid", "__str__", "works", "with", "private", "uids", "assert", "self", "uid", "__str__", "9", "9", "999", "90009", "1", "2"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_implicit_vr", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_implicit_vr", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_implicit_vr(self):\n        \"\"\"Test that UID.is_implicit_VR works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_implicit_VR\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_implicit_vr", "self", "test", "that", "uid", "is_implicit_vr", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_implicit_vr"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_little_endian", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_little_endian", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_little_endian(self):\n        \"\"\"Test that UID.is_little_endian works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_little_endian\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_little_endian", "self", "test", "that", "uid", "is_little_endian", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_little_endian"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_deflated", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_deflated", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_deflated(self):\n        \"\"\"Test that UID.is_deflated works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_deflated\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_deflated", "self", "test", "that", "uid", "is_deflated", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_deflated"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_transfer_syntax", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_transfer_syntax", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_transfer_syntax(self):\n        \"\"\"Test that UID.is_transfer_syntax works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_transfer_syntax\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_transfer_syntax", "self", "test", "that", "uid", "is_transfer_syntax", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_transfer_syntax"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_compressed", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_compressed", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_compressed(self):\n        \"\"\"Test that UID.is_compressed works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_compressed\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_compressed", "self", "test", "that", "uid", "is_compressed", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_compressed"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_encapsulated", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_encapsulated", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_encapsulated(self):\n        \"\"\"Test that UID.is_encapsulated works with private UIDs.\"\"\"\n        with pytest.raises(ValueError):\n            self.uid.is_encapsulated\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_encapsulated", "self", "test", "that", "uid", "is_encapsulated", "works", "with", "private", "uids", "with", "pytest", "raises", "valueerror", "self", "uid", "is_encapsulated"], "doc_len": 23}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_name", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_name", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_name(self):\n        \"\"\"Test that UID.name works with private UIDs.\"\"\"\n        assert self.uid.name == '9.9.999.90009.1.2'\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_name", "self", "test", "that", "uid", "name", "works", "with", "private", "uids", "assert", "self", "uid", "name", "9", "9", "999", "90009", "1", "2"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_type", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_type", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_type(self):\n        \"\"\"Test that UID.type works with private UIDs.\"\"\"\n        assert self.uid.type == ''\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_type", "self", "test", "that", "uid", "type", "works", "with", "private", "uids", "assert", "self", "uid", "type"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_info", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_info", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_info(self):\n        \"\"\"Test that UID.info works with private UIDs.\"\"\"\n        assert self.uid.info == ''\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_info", "self", "test", "that", "uid", "info", "works", "with", "private", "uids", "assert", "self", "uid", "info"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_retired", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_retired", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_retired(self):\n        \"\"\"Test that UID.is_retired works with private UIDs.\"\"\"\n        assert not self.uid.is_retired\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_retired", "self", "test", "that", "uid", "is_retired", "works", "with", "private", "uids", "assert", "not", "self", "uid", "is_retired"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_valid", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_valid", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_valid(self):\n        \"\"\"Test that UID.is_valid works with private UIDs.\"\"\"\n        assert self.uid.is_valid\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_valid", "self", "test", "that", "uid", "is_valid", "works", "with", "private", "uids", "assert", "self", "uid", "is_valid"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_uid.py::TestUIDPrivate.test_is_private", "file_path": "pydicom/tests/test_uid.py", "class_name": "TestUIDPrivate", "func_name": "test_is_private", "text": "文件路径: pydicom/tests/test_uid.py, 类名: TestUIDPrivate\n    def test_is_private(self):\n        \"\"\"Test that UID.is_private works with private UIDs.\"\"\"\n        assert self.uid.is_private\n", "tokens": ["pydicom", "tests", "test_uid", "py", "testuidprivate", "def", "test_is_private", "self", "test", "that", "uid", "is_private", "works", "with", "private", "uids", "assert", "self", "uid", "is_private"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_unicode.py::TestUnicodeFilenames.test_read", "file_path": "pydicom/tests/test_unicode.py", "class_name": "TestUnicodeFilenames", "func_name": "test_read", "text": "文件路径: pydicom/tests/test_unicode.py, 类名: TestUnicodeFilenames\n    def test_read(self):\n        \"\"\"Unicode: Can read a file with unicode characters in name...\"\"\"\n        uni_name = u'test°'\n\n        # verify first that we could encode file name in this environment\n        try:\n            _ = uni_name.encode(sys.getfilesystemencoding())\n        except UnicodeEncodeError:\n            print(\"SKIP: Environment doesn't support unicode filenames\")\n            return\n\n        try:\n            dcmread(uni_name)\n        except UnicodeEncodeError:\n            self.fail(\"UnicodeEncodeError generated for unicode name\")\n        # ignore file doesn't exist error\n        except IOError:\n            pass\n", "tokens": ["pydicom", "tests", "test_unicode", "py", "testunicodefilenames", "def", "test_read", "self", "unicode", "can", "read", "a", "file", "with", "unicode", "characters", "in", "name", "uni_name", "u", "test", "verify", "first", "that", "we", "could", "encode", "file", "name", "in", "this", "environment", "try", "_", "uni_name", "encode", "sys", "getfilesystemencoding", "except", "unicodeencodeerror", "print", "skip", "environment", "doesn", "t", "support", "unicode", "filenames", "return", "try", "dcmread", "uni_name", "except", "unicodeencodeerror", "self", "fail", "unicodeencodeerror", "generated", "for", "unicode", "name", "ignore", "file", "doesn", "t", "exist", "error", "except", "ioerror", "pass"], "doc_len": 70}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_camel_to_underscore", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_camel_to_underscore", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_camel_to_underscore(self):\n        \"\"\"Test utils.codify.camel_to_underscore\"\"\"\n        input_str = ['TheNameToConvert', 'Some12Variable_Name']\n        output_str = ['the_name_to_convert', 'some12_variable__name']\n        for in_str, out_str in zip(input_str, output_str):\n            assert out_str == camel_to_underscore(in_str)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_camel_to_underscore", "self", "test", "utils", "codify", "camel_to_underscore", "input_str", "thenametoconvert", "some12variable_name", "output_str", "the_name_to_convert", "some12_variable__name", "for", "in_str", "out_str", "in", "zip", "input_str", "output_str", "assert", "out_str", "camel_to_underscore", "in_str"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_tag_repr", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_tag_repr", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_tag_repr(self):\n        \"\"\"Test utils.codify.tag_repr\"\"\"\n        input_tag = [0x00000000, 0x00100010, 0x7fe00010, 0x11110001]\n        output_str = ['(0x0000, 0x0000)', '(0x0010, 0x0010)',\n                      '(0x7fe0, 0x0010)', '(0x1111, 0x0001)']\n        for tag, out_str in zip(input_tag, output_str):\n            assert out_str == tag_repr(Tag(tag))\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_tag_repr", "self", "test", "utils", "codify", "tag_repr", "input_tag", "0x00000000", "0x00100010", "0x7fe00010", "0x11110001", "output_str", "0x0000", "0x0000", "0x0010", "0x0010", "0x7fe0", "0x0010", "0x1111", "0x0001", "for", "tag", "out_str", "in", "zip", "input_tag", "output_str", "assert", "out_str", "tag_repr", "tag", "tag"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_default_name_filter", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_default_name_filter", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_default_name_filter(self):\n        \"\"\"Test utils.codify.default_name_filter\"\"\"\n        input_keyword = ['ControlPointSet', 'ReferenceDataSet',\n                         'FractionGroupThing']\n        output_str = ['cp_set', 'ref_data_set', 'frxn_gp_thing']\n        for in_str, out_str in zip(input_keyword, output_str):\n            assert out_str == default_name_filter(in_str)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_default_name_filter", "self", "test", "utils", "codify", "default_name_filter", "input_keyword", "controlpointset", "referencedataset", "fractiongroupthing", "output_str", "cp_set", "ref_data_set", "frxn_gp_thing", "for", "in_str", "out_str", "in", "zip", "input_keyword", "output_str", "assert", "out_str", "default_name_filter", "in_str"], "doc_len": 31}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_imports", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_imports", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_imports(self):\n        \"\"\"Test utils.codify.code_imports\"\"\"\n        out = \"from __future__ import unicode_literals\"\n        out += \"  # Only for python2.7 and save_as unicode filename\\n\"\n        out += 'import pydicom\\n'\n        out += 'from pydicom.dataset import Dataset\\n'\n        out += 'from pydicom.sequence import Sequence'\n        assert out == code_imports()\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_imports", "self", "test", "utils", "codify", "code_imports", "out", "from", "__future__", "import", "unicode_literals", "out", "only", "for", "python2", "7", "and", "save_as", "unicode", "filename", "n", "out", "import", "pydicom", "n", "out", "from", "pydicom", "dataset", "import", "dataset", "n", "out", "from", "pydicom", "sequence", "import", "sequence", "assert", "out", "code_imports"], "doc_len": 47}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_dataelem_standard", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_dataelem_standard", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_dataelem_standard(self):\n        \"\"\"Test utils.codify.code_dataelem for standard element\"\"\"\n        # Element keyword in data dictionary\n        input_elem = [DataElement(0x00100010, 'PN', 'CITIZEN'),\n                      DataElement(0x0008010c, 'UI', '1.1.2.3.4.5'),\n                      DataElement(0x00080301, 'US', 1200)]\n        out_str = [\"ds.PatientName = 'CITIZEN'\",\n                   \"ds.CodingSchemeUID = '1.1.2.3.4.5'\",\n                   \"ds.PrivateGroupReference = 1200\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_dataelem_standard", "self", "test", "utils", "codify", "code_dataelem", "for", "standard", "element", "element", "keyword", "in", "data", "dictionary", "input_elem", "dataelement", "0x00100010", "pn", "citizen", "dataelement", "0x0008010c", "ui", "1", "1", "2", "3", "4", "5", "dataelement", "0x00080301", "us", "1200", "out_str", "ds", "patientname", "citizen", "ds", "codingschemeuid", "1", "1", "2", "3", "4", "5", "ds", "privategroupreference", "1200", "for", "elem", "out", "in", "zip", "input_elem", "out_str", "assert", "out", "code_dataelem", "elem"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_dataelem_exclude_size", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_dataelem_exclude_size", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_dataelem_exclude_size(self):\n        \"\"\"Test utils.codify.code_dataelem exclude_size param\"\"\"\n        input_elem = [DataElement(0x00100010, 'OB', 'CITIZEN'),\n                      DataElement(0x0008010c, 'UI', '1.1'),\n                      DataElement(0x00200011, 'IS', 3)]\n        # Fails\n        # DataElement(0x00080301, 'US', 1200)]\n        out_str = [\"ds.PatientName = # XXX Array of 7 bytes excluded\",\n                   \"ds.CodingSchemeUID = '1.1'\",\n                   'ds.SeriesNumber = \"3\"']\n        # Fails\n        # \"ds.PrivateGroupReference = 1200\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem, exclude_size=4)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_dataelem_exclude_size", "self", "test", "utils", "codify", "code_dataelem", "exclude_size", "param", "input_elem", "dataelement", "0x00100010", "ob", "citizen", "dataelement", "0x0008010c", "ui", "1", "1", "dataelement", "0x00200011", "is", "3", "fails", "dataelement", "0x00080301", "us", "1200", "out_str", "ds", "patientname", "xxx", "array", "of", "7", "bytes", "excluded", "ds", "codingschemeuid", "1", "1", "ds", "seriesnumber", "3", "fails", "ds", "privategroupreference", "1200", "for", "elem", "out", "in", "zip", "input_elem", "out_str", "assert", "out", "code_dataelem", "elem", "exclude_size", "4"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_dataelem_private", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_dataelem_private", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_dataelem_private(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # Element keyword not in data dictionary\n        input_elem = [DataElement(0x00111010, 'PN', 'CITIZEN'),\n                      DataElement(0x0081010c, 'UI', '1.1.2.3.4.5'),\n                      DataElement(0x11110301, 'US', 1200)]\n        out_str = [\"ds.add_new((0x0011, 0x1010), 'PN', 'CITIZEN')\",\n                   \"ds.add_new((0x0081, 0x010c), 'UI', '1.1.2.3.4.5')\",\n                   \"ds.add_new((0x1111, 0x0301), 'US', 1200)\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_dataelem_private", "self", "test", "utils", "codify", "code_dataelem", "element", "keyword", "not", "in", "data", "dictionary", "input_elem", "dataelement", "0x00111010", "pn", "citizen", "dataelement", "0x0081010c", "ui", "1", "1", "2", "3", "4", "5", "dataelement", "0x11110301", "us", "1200", "out_str", "ds", "add_new", "0x0011", "0x1010", "pn", "citizen", "ds", "add_new", "0x0081", "0x010c", "ui", "1", "1", "2", "3", "4", "5", "ds", "add_new", "0x1111", "0x0301", "us", "1200", "for", "elem", "out", "in", "zip", "input_elem", "out_str", "assert", "out", "code_dataelem", "elem"], "doc_len": 71}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_dataelem_sequence", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_dataelem_sequence", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_dataelem_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # ControlPointSequence\n        elem = DataElement(0x300A0111, 'SQ', [])\n        out = \"\\n# Control Point Sequence\\n\"\n        out += \"cp_sequence = Sequence()\\n\"\n        out += \"ds.ControlPointSequence = cp_sequence\"\n        assert out == code_dataelem(elem)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_dataelem_sequence", "self", "test", "utils", "codify", "code_dataelem", "controlpointsequence", "elem", "dataelement", "0x300a0111", "sq", "out", "n", "control", "point", "sequence", "n", "out", "cp_sequence", "sequence", "n", "out", "ds", "controlpointsequence", "cp_sequence", "assert", "out", "code_dataelem", "elem"], "doc_len": 35}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_sequence", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_sequence", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # ControlPointSequence\n        elem = DataElement(0x300A0111, 'SQ', [])\n        elem.value.append(Dataset())\n        elem[0].PatientID = '1234'\n        out = \"\\n\"\n        out += \"# Control Point Sequence\\n\"\n        out += \"cp_sequence = Sequence()\\n\"\n        out += \"ds.ControlPointSequence = cp_sequence\\n\"\n        out += \"\\n\"\n        out += \"# Control Point Sequence: Control Point 1\\n\"\n        out += \"cp1 = Dataset()\\n\"\n        out += \"cp1.PatientID = '1234'\\n\"\n        out += \"cp_sequence.append(cp1)\"\n\n        assert out == code_dataelem(elem)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_sequence", "self", "test", "utils", "codify", "code_dataelem", "controlpointsequence", "elem", "dataelement", "0x300a0111", "sq", "elem", "value", "append", "dataset", "elem", "0", "patientid", "1234", "out", "n", "out", "control", "point", "sequence", "n", "out", "cp_sequence", "sequence", "n", "out", "ds", "controlpointsequence", "cp_sequence", "n", "out", "n", "out", "control", "point", "sequence", "control", "point", "1", "n", "out", "cp1", "dataset", "n", "out", "cp1", "patientid", "1234", "n", "out", "cp_sequence", "append", "cp1", "assert", "out", "code_dataelem", "elem"], "doc_len": 68}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_dataset", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_dataset", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_dataset(self):\n        \"\"\"Test utils.codify.code_dataset\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_dataset", "self", "test", "utils", "codify", "code_dataset", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestCodify.test_code_file", "file_path": "pydicom/tests/test_util.py", "class_name": "TestCodify", "func_name": "test_code_file", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestCodify\n    def test_code_file(self, capsys):\n        \"\"\"Test utils.codify.code_file\"\"\"\n        filename = get_testdata_files(\"rtplan.dcm\")[0]\n        args = [\"--save-as\", r\"c:\\temp\\testout.dcm\", filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert r\"c:\\temp\\testout.dcm\" in out\n", "tokens": ["pydicom", "tests", "test_util", "py", "testcodify", "def", "test_code_file", "self", "capsys", "test", "utils", "codify", "code_file", "filename", "get_testdata_files", "rtplan", "dcm", "0", "args", "save", "as", "r", "c", "temp", "testout", "dcm", "filename", "codify_main", "100", "args", "out", "err", "capsys", "readouterr", "assert", "r", "c", "temp", "testout", "dcm", "in", "out"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_util.py::TestDump.test_print_character", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDump", "func_name": "test_print_character", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDump\n    def test_print_character(self):\n        \"\"\"Test utils.dump.print_character\"\"\"\n        # assert print_character(0x30) == '0'  # Missing!\n        assert '1' == print_character(0x31)\n        assert '9' == print_character(0x39)\n        assert 'A' == print_character(0x41)\n        assert 'Z' == print_character(0x5A)\n        assert 'a' == print_character(0x61)\n        assert 'z' == print_character(0x7A)\n        assert '.' == print_character(0x00)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdump", "def", "test_print_character", "self", "test", "utils", "dump", "print_character", "assert", "print_character", "0x30", "0", "missing", "assert", "1", "print_character", "0x31", "assert", "9", "print_character", "0x39", "assert", "a", "print_character", "0x41", "assert", "z", "print_character", "0x5a", "assert", "a", "print_character", "0x61", "assert", "z", "print_character", "0x7a", "assert", "print_character", "0x00"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_util.py::TestDump.test_filedump", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDump", "func_name": "test_filedump", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDump\n    def test_filedump(self):\n        \"\"\"Test utils.dump.filedump\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdump", "def", "test_filedump", "self", "test", "utils", "dump", "filedump", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestDump.test_datadump", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDump", "func_name": "test_datadump", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDump\n    def test_datadump(self):\n        \"\"\"Test utils.dump.datadump\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdump", "def", "test_datadump", "self", "test", "utils", "dump", "datadump", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestDump.test_hexdump", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDump", "func_name": "test_hexdump", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDump\n    def test_hexdump(self):\n        \"\"\"Test utils.dump.hexdump\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdump", "def", "test_hexdump", "self", "test", "utils", "dump", "hexdump", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestDump.test_pretty_print", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDump", "func_name": "test_pretty_print", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDump\n    def test_pretty_print(self):\n        \"\"\"Test utils.dump.pretty_print\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdump", "def", "test_pretty_print", "self", "test", "utils", "dump", "pretty_print", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestFixer.test_fix_separator_callback", "file_path": "pydicom/tests/test_util.py", "class_name": "TestFixer", "func_name": "test_fix_separator_callback", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestFixer\n    def test_fix_separator_callback(self):\n        \"\"\"Test utils.fixer.fix_separator_callback\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testfixer", "def", "test_fix_separator_callback", "self", "test", "utils", "fixer", "fix_separator_callback", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestFixer.test_fix_separator", "file_path": "pydicom/tests/test_util.py", "class_name": "TestFixer", "func_name": "test_fix_separator", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestFixer\n    def test_fix_separator(self):\n        \"\"\"Test utils.fixer.fix_separator\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testfixer", "def", "test_fix_separator", "self", "test", "utils", "fixer", "fix_separator", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestFixer.test_mismatch_callback", "file_path": "pydicom/tests/test_util.py", "class_name": "TestFixer", "func_name": "test_mismatch_callback", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestFixer\n    def test_mismatch_callback(self):\n        \"\"\"Test utils.fixer.mismatch_callback\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testfixer", "def", "test_mismatch_callback", "self", "test", "utils", "fixer", "mismatch_callback", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestFixer.test_fix_mismatch", "file_path": "pydicom/tests/test_util.py", "class_name": "TestFixer", "func_name": "test_fix_mismatch", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestFixer\n    def test_fix_mismatch(self):\n        \"\"\"Test utils.fixer.fix_mismatch\"\"\"\n        pass\n", "tokens": ["pydicom", "tests", "test_util", "py", "testfixer", "def", "test_fix_mismatch", "self", "test", "utils", "fixer", "fix_mismatch", "pass"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_util.py::TestHexUtil.test_hex_to_bytes", "file_path": "pydicom/tests/test_util.py", "class_name": "TestHexUtil", "func_name": "test_hex_to_bytes", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestHexUtil\n    def test_hex_to_bytes(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = \"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\"\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09' \\\n                     b'\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F'\n        assert bytestring == hex2bytes(hexstring)\n\n        hexstring = b\"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\"\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09' \\\n                     b'\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F'\n        assert bytestring == hex2bytes(hexstring)\n\n        hexstring = \"00 10 20 30 40 50 60 70 80 90 A0 B0 C0 D0 E0 F0\"\n        bytestring = b'\\x00\\x10\\x20\\x30\\x40\\x50\\x60\\x70\\x80\\x90' \\\n                     b'\\xA0\\xB0\\xC0\\xD0\\xE0\\xF0'\n        assert bytestring == hex2bytes(hexstring)\n\n        with pytest.raises(TypeError):\n            hex2bytes(0x1234)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testhexutil", "def", "test_hex_to_bytes", "self", "test", "utils", "hexutil", "hex2bytes", "hexstring", "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "x09", "b", "x0a", "x0b", "x0c", "x0d", "x0e", "x0f", "assert", "bytestring", "hex2bytes", "hexstring", "hexstring", "b", "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "x09", "b", "x0a", "x0b", "x0c", "x0d", "x0e", "x0f", "assert", "bytestring", "hex2bytes", "hexstring", "hexstring", "00", "10", "20", "30", "40", "50", "60", "70", "80", "90", "a0", "b0", "c0", "d0", "e0", "f0", "bytestring", "b", "x00", "x10", "x20", "x30", "x40", "x50", "x60", "x70", "x80", "x90", "b", "xa0", "xb0", "xc0", "xd0", "xe0", "xf0", "assert", "bytestring", "hex2bytes", "hexstring", "with", "pytest", "raises", "typeerror", "hex2bytes", "0x1234"], "doc_len": 139}
{"doc_id": "pydicom/tests/test_util.py::TestHexUtil.test_bytes_to_hex", "file_path": "pydicom/tests/test_util.py", "class_name": "TestHexUtil", "func_name": "test_bytes_to_hex", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestHexUtil\n    def test_bytes_to_hex(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\"\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09' \\\n                     b'\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F'\n        assert hexstring == bytes2hex(bytestring)\n\n        hexstring = \"00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0\"\n        bytestring = b'\\x00\\x10\\x20\\x30\\x40\\x50\\x60\\x70\\x80\\x90' \\\n                     b'\\xA0\\xB0\\xC0\\xD0\\xE0\\xF0'\n        assert hexstring == bytes2hex(bytestring)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testhexutil", "def", "test_bytes_to_hex", "self", "test", "utils", "hexutil", "hex2bytes", "hexstring", "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "bytestring", "b", "x00", "x01", "x02", "x03", "x04", "x05", "x06", "x07", "x08", "x09", "b", "x0a", "x0b", "x0c", "x0d", "x0e", "x0f", "assert", "hexstring", "bytes2hex", "bytestring", "hexstring", "00", "10", "20", "30", "40", "50", "60", "70", "80", "90", "a0", "b0", "c0", "d0", "e0", "f0", "bytestring", "b", "x00", "x10", "x20", "x30", "x40", "x50", "x60", "x70", "x80", "x90", "b", "xa0", "xb0", "xc0", "xd0", "xe0", "xf0", "assert", "hexstring", "bytes2hex", "bytestring"], "doc_len": 92}
{"doc_id": "pydicom/tests/test_util.py::TestDataElementCallbackTests.setup", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDataElementCallbackTests", "func_name": "setup", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDataElementCallbackTests\n    def setup(self):\n        # Set up a dataset with commas in one item instead of backslash\n        config.enforce_valid_values = True\n        namespace = {}\n        exec(raw_hex_code, {}, namespace)\n        ds_bytes = hexutil.hex2bytes(namespace['impl_LE_deflen_std_hex'])\n        # Change \"2\\4\\8\\16\" to \"2,4,8,16\"\n        ds_bytes = ds_bytes.replace(b\"\\x32\\x5c\\x34\\x5c\\x38\\x5c\\x31\\x36\",\n                                    b\"\\x32\\x2c\\x34\\x2c\\x38\\x2c\\x31\\x36\")\n\n        self.bytesio = BytesIO(ds_bytes)\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdataelementcallbacktests", "def", "setup", "self", "set", "up", "a", "dataset", "with", "commas", "in", "one", "item", "instead", "of", "backslash", "config", "enforce_valid_values", "true", "namespace", "exec", "raw_hex_code", "namespace", "ds_bytes", "hexutil", "hex2bytes", "namespace", "impl_le_deflen_std_hex", "change", "2", "4", "8", "16", "to", "2", "4", "8", "16", "ds_bytes", "ds_bytes", "replace", "b", "x32", "x5c", "x34", "x5c", "x38", "x5c", "x31", "x36", "b", "x32", "x2c", "x34", "x2c", "x38", "x2c", "x31", "x36", "self", "bytesio", "bytesio", "ds_bytes"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_util.py::TestDataElementCallbackTests.teardown", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDataElementCallbackTests", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDataElementCallbackTests\n    def teardown(self):\n        config.enforce_valid_values = False\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdataelementcallbacktests", "def", "teardown", "self", "config", "enforce_valid_values", "false"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_util.py::TestDataElementCallbackTests.testBadSeparator", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDataElementCallbackTests", "func_name": "testBadSeparator", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDataElementCallbackTests\n    def testBadSeparator(self):\n        \"\"\"Ensure that unchanged bad separator does raise an error...\"\"\"\n        ds = filereader.read_dataset(self.bytesio, is_little_endian=True,\n                                     is_implicit_VR=True)\n        contour = ds.ROIContourSequence[0].ContourSequence[0]\n        with pytest.raises(ValueError):\n            getattr(contour, \"ContourData\")\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdataelementcallbacktests", "def", "testbadseparator", "self", "ensure", "that", "unchanged", "bad", "separator", "does", "raise", "an", "error", "ds", "filereader", "read_dataset", "self", "bytesio", "is_little_endian", "true", "is_implicit_vr", "true", "contour", "ds", "roicontoursequence", "0", "contoursequence", "0", "with", "pytest", "raises", "valueerror", "getattr", "contour", "contourdata"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_util.py::TestDataElementCallbackTests.testImplVRcomma", "file_path": "pydicom/tests/test_util.py", "class_name": "TestDataElementCallbackTests", "func_name": "testImplVRcomma", "text": "文件路径: pydicom/tests/test_util.py, 类名: TestDataElementCallbackTests\n    def testImplVRcomma(self):\n        \"\"\"util.fix_separator:\n           Able to replace comma in Implicit VR dataset..\"\"\"\n        fixer.fix_separator(b\",\", for_VRs=[\"DS\", \"IS\"],\n                            process_unknown_VRs=False)\n        ds = filereader.read_dataset(self.bytesio, is_little_endian=True,\n                                     is_implicit_VR=True)\n        expected = [valuerep.DSfloat(x) for x in [\"2\", \"4\", \"8\", \"16\"]]\n        got = ds.ROIContourSequence[0].ContourSequence[0].ContourData\n        config.reset_data_element_callback()\n\n        assert expected == got\n", "tokens": ["pydicom", "tests", "test_util", "py", "testdataelementcallbacktests", "def", "testimplvrcomma", "self", "util", "fix_separator", "able", "to", "replace", "comma", "in", "implicit", "vr", "dataset", "fixer", "fix_separator", "b", "for_vrs", "ds", "is", "process_unknown_vrs", "false", "ds", "filereader", "read_dataset", "self", "bytesio", "is_little_endian", "true", "is_implicit_vr", "true", "expected", "valuerep", "dsfloat", "x", "for", "x", "in", "2", "4", "8", "16", "got", "ds", "roicontoursequence", "0", "contoursequence", "0", "contourdata", "config", "reset_data_element_callback", "assert", "expected", "got"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_valuerep.py::TestTM.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestTM", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestTM\n    def test_pickling(self):\n        # Check that a pickled TM is read back properly\n        x = pydicom.valuerep.TM(\"212223\")\n        x.original_string = 'hello'\n        assert 'hello' == x.original_string\n        assert time(21, 22, 23) == x\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x == x2\n        assert x.original_string == x2.original_string\n        assert str(x) == str(x2)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testtm", "def", "test_pickling", "self", "check", "that", "a", "pickled", "tm", "is", "read", "back", "properly", "x", "pydicom", "valuerep", "tm", "212223", "x", "original_string", "hello", "assert", "hello", "x", "original_string", "assert", "time", "21", "22", "23", "x", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "x2", "assert", "x", "original_string", "x2", "original_string", "assert", "str", "x", "str", "x2"], "doc_len": 56}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDT.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDT", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDT\n    def test_pickling(self):\n        # Check that a pickled DT is read back properly\n        x = pydicom.valuerep.DT(\"19111213212123\")\n        x.original_string = 'hello'\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x == x2\n        assert x.original_string == x2.original_string\n        assert str(x) == str(x2)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdt", "def", "test_pickling", "self", "check", "that", "a", "pickled", "dt", "is", "read", "back", "properly", "x", "pydicom", "valuerep", "dt", "19111213212123", "x", "original_string", "hello", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "x2", "assert", "x", "original_string", "x2", "original_string", "assert", "str", "x", "str", "x2"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDA.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDA", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDA\n    def test_pickling(self):\n        # Check that a pickled DA is read back properly\n        x = pydicom.valuerep.DA(\"19111213\")\n        x.original_string = 'hello'\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x == x2\n        assert x.original_string == x2.original_string\n        assert str(x) == str(x2)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testda", "def", "test_pickling", "self", "check", "that", "a", "pickled", "da", "is", "read", "back", "properly", "x", "pydicom", "valuerep", "da", "19111213", "x", "original_string", "hello", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "x2", "assert", "x", "original_string", "x2", "original_string", "assert", "str", "x", "str", "x2"], "doc_len": 46}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDS.test_empty_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDS", "func_name": "test_empty_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDS\n    def test_empty_value(self):\n        assert '' == DS(None)\n        assert '' == DS('')\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testds", "def", "test_empty_value", "self", "assert", "ds", "none", "assert", "ds"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDS.test_float_values", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDS", "func_name": "test_float_values", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDS\n    def test_float_values(self):\n        val = DS(0.9)\n        assert isinstance(val, pydicom.valuerep.DSfloat)\n        assert 0.9 == val\n        val = DS('0.9')\n        assert isinstance(val, pydicom.valuerep.DSfloat)\n        assert 0.9 == val\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testds", "def", "test_float_values", "self", "val", "ds", "0", "9", "assert", "isinstance", "val", "pydicom", "valuerep", "dsfloat", "assert", "0", "9", "val", "val", "ds", "0", "9", "assert", "isinstance", "val", "pydicom", "valuerep", "dsfloat", "assert", "0", "9", "val"], "doc_len": 36}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDSfloat.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDSfloat", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDSfloat\n    def test_pickling(self):\n        # Check that a pickled DSFloat is read back properly\n        x = pydicom.valuerep.DSfloat(9.0)\n        x.original_string = 'hello'\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x.real == x2.real\n        assert x.original_string == x2.original_string\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdsfloat", "def", "test_pickling", "self", "check", "that", "a", "pickled", "dsfloat", "is", "read", "back", "properly", "x", "pydicom", "valuerep", "dsfloat", "9", "0", "x", "original_string", "hello", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "real", "x2", "real", "assert", "x", "original_string", "x2", "original_string"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDSdecimal.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDSdecimal", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDSdecimal\n    def test_pickling(self):\n        # Check that a pickled DSdecimal is read back properly\n        # DSdecimal actually prefers original_string when\n        # reading back\n        x = pydicom.valuerep.DSdecimal(19)\n        x.original_string = '19'\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x.real == x2.real\n        assert x.original_string == x2.original_string\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdsdecimal", "def", "test_pickling", "self", "check", "that", "a", "pickled", "dsdecimal", "is", "read", "back", "properly", "dsdecimal", "actually", "prefers", "original_string", "when", "reading", "back", "x", "pydicom", "valuerep", "dsdecimal", "19", "x", "original_string", "19", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "real", "x2", "real", "assert", "x", "original_string", "x2", "original_string"], "doc_len": 50}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDSdecimal.test_float_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDSdecimal", "func_name": "test_float_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDSdecimal\n    def test_float_value(self):\n        config.allow_DS_float = False\n        with pytest.raises(TypeError,\n                           match='cannot be instantiated with a float value'):\n            pydicom.valuerep.DSdecimal(9.0)\n        config.allow_DS_float = True\n        assert 9 == pydicom.valuerep.DSdecimal(9.0)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdsdecimal", "def", "test_float_value", "self", "config", "allow_ds_float", "false", "with", "pytest", "raises", "typeerror", "match", "cannot", "be", "instantiated", "with", "a", "float", "value", "pydicom", "valuerep", "dsdecimal", "9", "0", "config", "allow_ds_float", "true", "assert", "9", "pydicom", "valuerep", "dsdecimal", "9", "0"], "doc_len": 38}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_empty_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_empty_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_empty_value(self):\n        assert '' == IS(None)\n        assert '' == IS('')\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_empty_value", "self", "assert", "is", "none", "assert", "is"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_valid_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_valid_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_valid_value(self):\n        assert 42 == IS(42)\n        assert 42 == IS('42')\n        assert 42 == IS(42.0)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_valid_value", "self", "assert", "42", "is", "42", "assert", "42", "is", "42", "assert", "42", "is", "42", "0"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_invalid_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_invalid_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_invalid_value(self):\n        with pytest.raises(TypeError, match='Could not convert value'):\n            IS(0.9)\n        with pytest.raises(ValueError, match='invalid literal for int()'):\n            IS('0.9')\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_invalid_value", "self", "with", "pytest", "raises", "typeerror", "match", "could", "not", "convert", "value", "is", "0", "9", "with", "pytest", "raises", "valueerror", "match", "invalid", "literal", "for", "int", "is", "0", "9"], "doc_len": 32}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_pickling", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_pickling", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_pickling(self):\n        # Check that a pickled IS is read back properly\n        x = pydicom.valuerep.IS(921)\n        x.original_string = 'hello'\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x.real == x2.real\n        assert x.original_string == x2.original_string\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_pickling", "self", "check", "that", "a", "pickled", "is", "is", "read", "back", "properly", "x", "pydicom", "valuerep", "is", "921", "x", "original_string", "hello", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "real", "x2", "real", "assert", "x", "original_string", "x2", "original_string"], "doc_len": 43}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_longint", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_longint", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_longint(self):\n        # Check that a long int is read properly\n        # Will not work with enforce_valid_values\n        x = pydicom.valuerep.IS(3103050000)\n        data1_string = pickle.dumps(x)\n        x2 = pickle.loads(data1_string)\n        assert x.real == x2.real\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_longint", "self", "check", "that", "a", "long", "int", "is", "read", "properly", "will", "not", "work", "with", "enforce_valid_values", "x", "pydicom", "valuerep", "is", "3103050000", "data1_string", "pickle", "dumps", "x", "x2", "pickle", "loads", "data1_string", "assert", "x", "real", "x2", "real"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_valuerep.py::TestIS.test_overflow", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestIS", "func_name": "test_overflow", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestIS\n    def test_overflow(self):\n        original_flag = config.enforce_valid_values\n        config.enforce_valid_values = True\n        with pytest.raises(OverflowError, match=\"Value exceeds DICOM limits*\"):\n            pydicom.valuerep.IS(3103050000)\n        config.enforce_valid_values = original_flag\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testis", "def", "test_overflow", "self", "original_flag", "config", "enforce_valid_values", "config", "enforce_valid_values", "true", "with", "pytest", "raises", "overflowerror", "match", "value", "exceeds", "dicom", "limits", "pydicom", "valuerep", "is", "3103050000", "config", "enforce_valid_values", "original_flag"], "doc_len": 30}
{"doc_id": "pydicom/tests/test_valuerep.py::TestBadValueRead.setup", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestBadValueRead", "func_name": "setup", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestBadValueRead\n    def setup(self):\n        class TagLike(object):\n            pass\n\n        self.tag = TagLike()\n        self.tag.value = b'1A'\n        self.tag.is_little_endian = True\n        self.tag.is_implicit_VR = False\n        self.tag.tag = Tag(0x0010, 0x0020)\n        self.default_retry_order = pydicom.values.convert_retry_VR_order\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testbadvalueread", "def", "setup", "self", "class", "taglike", "object", "pass", "self", "tag", "taglike", "self", "tag", "value", "b", "1a", "self", "tag", "is_little_endian", "true", "self", "tag", "is_implicit_vr", "false", "self", "tag", "tag", "tag", "0x0010", "0x0020", "self", "default_retry_order", "pydicom", "values", "convert_retry_vr_order"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_valuerep.py::TestBadValueRead.teardown", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestBadValueRead", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestBadValueRead\n    def teardown(self):\n        pydicom.values.convert_retry_VR_order = self.default_retry_order\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testbadvalueread", "def", "teardown", "self", "pydicom", "values", "convert_retry_vr_order", "self", "default_retry_order"], "doc_len": 13}
{"doc_id": "pydicom/tests/test_valuerep.py::TestBadValueRead.test_read_bad_value_in_VR_default", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestBadValueRead", "func_name": "test_read_bad_value_in_VR_default", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestBadValueRead\n    def test_read_bad_value_in_VR_default(self):\n        # found a conversion\n        assert '1A' == convert_value('SH', self.tag)\n        # converted with fallback vr \"SH\"\n        assert '1A' == convert_value('IS', self.tag)\n\n        pydicom.values.convert_retry_VR_order = ['FL', 'UL']\n        # no fallback VR succeeded, returned original value untranslated\n        assert b'1A' == convert_value('IS', self.tag)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testbadvalueread", "def", "test_read_bad_value_in_vr_default", "self", "found", "a", "conversion", "assert", "1a", "convert_value", "sh", "self", "tag", "converted", "with", "fallback", "vr", "sh", "assert", "1a", "convert_value", "is", "self", "tag", "pydicom", "values", "convert_retry_vr_order", "fl", "ul", "no", "fallback", "vr", "succeeded", "returned", "original", "value", "untranslated", "assert", "b", "1a", "convert_value", "is", "self", "tag"], "doc_len": 48}
{"doc_id": "pydicom/tests/test_valuerep.py::TestBadValueRead.test_read_bad_value_in_VR_enforce_valid_value", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestBadValueRead", "func_name": "test_read_bad_value_in_VR_enforce_valid_value", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestBadValueRead\n    def test_read_bad_value_in_VR_enforce_valid_value(self):\n        pydicom.config.enforce_valid_values = True\n        # found a conversion\n        assert '1A' == convert_value('SH', self.tag)\n        # invalid literal for base 10\n        with pytest.raises(ValueError):\n            convert_value('IS', self.tag)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testbadvalueread", "def", "test_read_bad_value_in_vr_enforce_valid_value", "self", "pydicom", "config", "enforce_valid_values", "true", "found", "a", "conversion", "assert", "1a", "convert_value", "sh", "self", "tag", "invalid", "literal", "for", "base", "10", "with", "pytest", "raises", "valueerror", "convert_value", "is", "self", "tag"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDecimalString.setup", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDecimalString", "func_name": "setup", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDecimalString\n    def setup(self):\n        config.DS_decimal(True)\n        config.enforce_valid_values = True\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdecimalstring", "def", "setup", "self", "config", "ds_decimal", "true", "config", "enforce_valid_values", "true"], "doc_len": 14}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDecimalString.teardown", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDecimalString", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDecimalString\n    def teardown(self):\n        config.DS_decimal(False)\n        config.enforce_valid_values = False\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdecimalstring", "def", "teardown", "self", "config", "ds_decimal", "false", "config", "enforce_valid_values", "false"], "doc_len": 14}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDecimalString.test_valid_decimal_strings", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDecimalString", "func_name": "test_valid_decimal_strings", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDecimalString\n    def test_valid_decimal_strings(self):\n        # Ensures that decimal.Decimal doesn't cause a valid string to become\n        # invalid\n        valid_str = '-9.81338674e-006'\n        ds = valuerep.DS(valid_str)\n        assert len(str(ds)) <= 16\n\n        # Now the input string is too long but decimal.Decimal can convert it\n        # to a valid 16-character string\n        long_str = '-0.000000981338674'\n        ds = valuerep.DS(long_str)\n        assert len(str(ds)) <= 16\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdecimalstring", "def", "test_valid_decimal_strings", "self", "ensures", "that", "decimal", "decimal", "doesn", "t", "cause", "a", "valid", "string", "to", "become", "invalid", "valid_str", "9", "81338674e", "006", "ds", "valuerep", "ds", "valid_str", "assert", "len", "str", "ds", "16", "now", "the", "input", "string", "is", "too", "long", "but", "decimal", "decimal", "can", "convert", "it", "to", "a", "valid", "16", "character", "string", "long_str", "0", "000000981338674", "ds", "valuerep", "ds", "long_str", "assert", "len", "str", "ds", "16"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDecimalString.test_invalid_decimal_strings", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDecimalString", "func_name": "test_invalid_decimal_strings", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDecimalString\n    def test_invalid_decimal_strings(self):\n        # Now the input string truly is invalid\n        invalid_string = '-9.813386743e-006'\n        with pytest.raises(OverflowError):\n            valuerep.DS(invalid_string)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdecimalstring", "def", "test_invalid_decimal_strings", "self", "now", "the", "input", "string", "truly", "is", "invalid", "invalid_string", "9", "813386743e", "006", "with", "pytest", "raises", "overflowerror", "valuerep", "ds", "invalid_string"], "doc_len": 26}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_last_first", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_last_first", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_last_first(self):\n        \"\"\"PN: Simple Family-name^Given-name works...\"\"\"\n        pn = PersonName(\"Family^Given\")\n        assert \"Family\" == pn.family_name\n        assert 'Given' == pn.given_name\n        assert '' == pn.name_suffix\n        assert '' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_last_first", "self", "pn", "simple", "family", "name", "given", "name", "works", "pn", "personname", "family", "given", "assert", "family", "pn", "family_name", "assert", "given", "pn", "given_name", "assert", "pn", "name_suffix", "assert", "pn", "phonetic"], "doc_len": 33}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_copy", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_copy", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_copy(self):\n        \"\"\"PN: Copy and deepcopy works...\"\"\"\n        pn = PersonNameUnicode(\n            'Hong^Gildong='\n            '\\033$)C\\373\\363^\\033$)C\\321\\316\\324\\327='\n            '\\033$)C\\310\\253^\\033$)C\\261\\346\\265\\277',\n            [default_encoding, 'euc_kr'])\n        pn_copy = copy.copy(pn)\n        assert pn == pn_copy\n        assert pn.components == pn_copy.components\n        # the copied object references the original components\n        assert pn_copy.components is pn.components\n        assert pn.encodings == pn_copy.encodings\n\n        pn_copy = copy.deepcopy(pn)\n        assert pn == pn_copy\n        assert pn.components == pn_copy.components\n        # deepcopy() returns the same immutable objects (tuples)\n        assert pn_copy.components is pn.components\n        assert pn.encodings is pn_copy.encodings\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_copy", "self", "pn", "copy", "and", "deepcopy", "works", "pn", "personnameunicode", "hong", "gildong", "033", "c", "373", "363", "033", "c", "321", "316", "324", "327", "033", "c", "310", "253", "033", "c", "261", "346", "265", "277", "default_encoding", "euc_kr", "pn_copy", "copy", "copy", "pn", "assert", "pn", "pn_copy", "assert", "pn", "components", "pn_copy", "components", "the", "copied", "object", "references", "the", "original", "components", "assert", "pn_copy", "components", "is", "pn", "components", "assert", "pn", "encodings", "pn_copy", "encodings", "pn_copy", "copy", "deepcopy", "pn", "assert", "pn", "pn_copy", "assert", "pn", "components", "pn_copy", "components", "deepcopy", "returns", "the", "same", "immutable", "objects", "tuples", "assert", "pn_copy", "components", "is", "pn", "components", "assert", "pn", "encodings", "is", "pn_copy", "encodings"], "doc_len": 100}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_three_component", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_three_component", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_three_component(self):\n        \"\"\"PN: 3component (single-byte, ideographic,\n        phonetic characters) works...\"\"\"\n        # Example name from PS3.5-2008 section I.2 p. 108\n        pn = PersonName('Hong^Gildong='\n                        '\\033$)C\\373\\363^\\033$)C\\321\\316\\324\\327='\n                        '\\033$)C\\310\\253^\\033$)C\\261\\346\\265\\277')\n        assert (\"Hong\", \"Gildong\") == (pn.family_name, pn.given_name)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_three_component", "self", "pn", "3component", "single", "byte", "ideographic", "phonetic", "characters", "works", "example", "name", "from", "ps3", "5", "2008", "section", "i", "2", "p", "108", "pn", "personname", "hong", "gildong", "033", "c", "373", "363", "033", "c", "321", "316", "324", "327", "033", "c", "310", "253", "033", "c", "261", "346", "265", "277", "assert", "hong", "gildong", "pn", "family_name", "pn", "given_name"], "doc_len": 58}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_formatting", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_formatting", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_formatting(self):\n        \"\"\"PN: Formatting works...\"\"\"\n        pn = PersonName(\"Family^Given\")\n        assert \"Family, Given\" == pn.family_comma_given()\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_formatting", "self", "pn", "formatting", "works", "pn", "personname", "family", "given", "assert", "family", "given", "pn", "family_comma_given"], "doc_len": 20}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_unicode_kr", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_unicode_kr", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_unicode_kr(self):\n        \"\"\"PN: 3component in unicode works (Korean)...\"\"\"\n        # Example name from PS3.5-2008 section I.2 p. 101\n        pn = PersonNameUnicode(b'Hong^Gildong='\n                               b'\\033$)C\\373\\363^\\033$)C\\321\\316\\324\\327='\n                               b'\\033$)C\\310\\253^\\033$)C\\261\\346\\265\\277',\n                               [default_encoding, 'euc_kr'])\n        # PersonNameUnicode and PersonName3 behave differently:\n        # PersonName3 does not decode the components automatically\n        if not in_py2:\n            pn = pn.decode()\n        assert (u'Hong', u'Gildong') == (pn.family_name, pn.given_name)\n        assert u'洪^吉洞' == pn.ideographic\n        assert u'홍^길동' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_unicode_kr", "self", "pn", "3component", "in", "unicode", "works", "korean", "example", "name", "from", "ps3", "5", "2008", "section", "i", "2", "p", "101", "pn", "personnameunicode", "b", "hong", "gildong", "b", "033", "c", "373", "363", "033", "c", "321", "316", "324", "327", "b", "033", "c", "310", "253", "033", "c", "261", "346", "265", "277", "default_encoding", "euc_kr", "personnameunicode", "and", "personname3", "behave", "differently", "personname3", "does", "not", "decode", "the", "components", "automatically", "if", "not", "in_py2", "pn", "pn", "decode", "assert", "u", "hong", "u", "gildong", "pn", "family_name", "pn", "given_name", "assert", "u", "pn", "ideographic", "assert", "u", "pn", "phonetic"], "doc_len": 89}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_unicode_jp_from_bytes", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_unicode_jp_from_bytes", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_unicode_jp_from_bytes(self):\n        \"\"\"PN: 3component in unicode works (Japanese)...\"\"\"\n        # Example name from PS3.5-2008 section H  p. 98\n        pn = PersonNameUnicode(b'Yamada^Tarou='\n                               b'\\033$B;3ED\\033(B^\\033$BB@O:\\033(B='\n                               b'\\033$B$d$^$@\\033(B^\\033$B$?$m$&\\033(B',\n                               [default_encoding, 'iso2022_jp'])\n        if not in_py2:\n            pn = pn.decode()\n        assert (u'Yamada', u'Tarou') == (pn.family_name, pn.given_name)\n        assert u'山田^太郎' == pn.ideographic\n        assert u'やまだ^たろう' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_unicode_jp_from_bytes", "self", "pn", "3component", "in", "unicode", "works", "japanese", "example", "name", "from", "ps3", "5", "2008", "section", "h", "p", "98", "pn", "personnameunicode", "b", "yamada", "tarou", "b", "033", "b", "3ed", "033", "b", "033", "bb", "o", "033", "b", "b", "033", "b", "d", "033", "b", "033", "b", "m", "033", "b", "default_encoding", "iso2022_jp", "if", "not", "in_py2", "pn", "pn", "decode", "assert", "u", "yamada", "u", "tarou", "pn", "family_name", "pn", "given_name", "assert", "u", "pn", "ideographic", "assert", "u", "pn", "phonetic"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_unicode_jp_from_bytes_comp_delimiter", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_unicode_jp_from_bytes_comp_delimiter", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_unicode_jp_from_bytes_comp_delimiter(self):\n        \"\"\"The example encoding without the escape sequence before '='\"\"\"\n        pn = PersonNameUnicode(b'Yamada^Tarou='\n                               b'\\033$B;3ED\\033(B^\\033$BB@O:='\n                               b'\\033$B$d$^$@\\033(B^\\033$B$?$m$&\\033(B',\n                               [default_encoding, 'iso2022_jp'])\n        if not in_py2:\n            pn = pn.decode()\n        assert (u'Yamada', u'Tarou') == (pn.family_name, pn.given_name)\n        assert u'山田^太郎' == pn.ideographic\n        assert u'やまだ^たろう' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_unicode_jp_from_bytes_comp_delimiter", "self", "the", "example", "encoding", "without", "the", "escape", "sequence", "before", "pn", "personnameunicode", "b", "yamada", "tarou", "b", "033", "b", "3ed", "033", "b", "033", "bb", "o", "b", "033", "b", "d", "033", "b", "033", "b", "m", "033", "b", "default_encoding", "iso2022_jp", "if", "not", "in_py2", "pn", "pn", "decode", "assert", "u", "yamada", "u", "tarou", "pn", "family_name", "pn", "given_name", "assert", "u", "pn", "ideographic", "assert", "u", "pn", "phonetic"], "doc_len": 66}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_unicode_jp_from_bytes_caret_delimiter", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_unicode_jp_from_bytes_caret_delimiter", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_unicode_jp_from_bytes_caret_delimiter(self):\n        \"\"\"PN: 3component in unicode works (Japanese)...\"\"\"\n        # Example name from PS3.5-2008 section H  p. 98\n        pn = PersonNameUnicode(b'Yamada^Tarou='\n                               b'\\033$B;3ED\\033(B^\\033$BB@O:\\033(B='\n                               b'\\033$B$d$^$@\\033(B^\\033$B$?$m$&\\033(B',\n                               [default_encoding, 'iso2022_jp'])\n        if not in_py2:\n            pn = pn.decode()\n        assert (u'Yamada', u'Tarou') == (pn.family_name, pn.given_name)\n        assert u'山田^太郎' == pn.ideographic\n        assert u'やまだ^たろう' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_unicode_jp_from_bytes_caret_delimiter", "self", "pn", "3component", "in", "unicode", "works", "japanese", "example", "name", "from", "ps3", "5", "2008", "section", "h", "p", "98", "pn", "personnameunicode", "b", "yamada", "tarou", "b", "033", "b", "3ed", "033", "b", "033", "bb", "o", "033", "b", "b", "033", "b", "d", "033", "b", "033", "b", "m", "033", "b", "default_encoding", "iso2022_jp", "if", "not", "in_py2", "pn", "pn", "decode", "assert", "u", "yamada", "u", "tarou", "pn", "family_name", "pn", "given_name", "assert", "u", "pn", "ideographic", "assert", "u", "pn", "phonetic"], "doc_len": 76}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_unicode_jp_from_unicode", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_unicode_jp_from_unicode", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_unicode_jp_from_unicode(self):\n        \"\"\"A person name initialized from unicode is already decoded\"\"\"\n        pn = PersonNameUnicode(u'Yamada^Tarou=山田^太郎=やまだ^たろう',\n                               [default_encoding, 'iso2022_jp'])\n        assert (u'Yamada', u'Tarou') == (pn.family_name, pn.given_name)\n        assert u'山田^太郎' == pn.ideographic\n        assert u'やまだ^たろう' == pn.phonetic\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_unicode_jp_from_unicode", "self", "a", "person", "name", "initialized", "from", "unicode", "is", "already", "decoded", "pn", "personnameunicode", "u", "yamada", "tarou", "default_encoding", "iso2022_jp", "assert", "u", "yamada", "u", "tarou", "pn", "family_name", "pn", "given_name", "assert", "u", "pn", "ideographic", "assert", "u", "pn", "phonetic"], "doc_len": 41}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_not_equal", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_not_equal", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_not_equal(self):\n        \"\"\"PN3: Not equal works correctly (issue 121)...\"\"\"\n        # Meant to only be used in python 3 but doing simple check here\n        from pydicom.valuerep import PersonName3\n        pn = PersonName3(\"John^Doe\")\n        assert not pn != \"John^Doe\"\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_not_equal", "self", "pn3", "not", "equal", "works", "correctly", "issue", "121", "meant", "to", "only", "be", "used", "in", "python", "3", "but", "doing", "simple", "check", "here", "from", "pydicom", "valuerep", "import", "personname3", "pn", "personname3", "john", "doe", "assert", "not", "pn", "john", "doe"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_encoding_carried", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_encoding_carried", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_encoding_carried(self):\n        \"\"\"Test encoding is carried over to a new PN3 object\"\"\"\n        # Issue 466\n        from pydicom.valuerep import PersonName3\n        pn = PersonName3(\"John^Doe\", encodings='iso_ir_126')\n        assert pn.encodings == ('iso_ir_126',)\n        pn2 = PersonName3(pn)\n        assert pn2.encodings == ('iso_ir_126',)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_encoding_carried", "self", "test", "encoding", "is", "carried", "over", "to", "a", "new", "pn3", "object", "issue", "466", "from", "pydicom", "valuerep", "import", "personname3", "pn", "personname3", "john", "doe", "encodings", "iso_ir_126", "assert", "pn", "encodings", "iso_ir_126", "pn2", "personname3", "pn", "assert", "pn2", "encodings", "iso_ir_126"], "doc_len": 42}
{"doc_id": "pydicom/tests/test_valuerep.py::TestPersonName.test_hash", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestPersonName", "func_name": "test_hash", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestPersonName\n    def test_hash(self):\n        \"\"\"Test that the same name creates the same hash.\"\"\"\n        # Regression test for #785 in Python 3\n        pn1 = PersonNameUnicode(\"John^Doe^^Dr\", encodings=default_encoding)\n        pn2 = PersonNameUnicode(\"John^Doe^^Dr\", encodings=default_encoding)\n        assert hash(pn1) == hash(pn2)\n        pn3 = PersonNameUnicode(\"John^Doe\", encodings=default_encoding)\n        assert hash(pn1) != hash(pn3)\n\n        pn1 = PersonNameUnicode(u'Yamada^Tarou=山田^太郎=やまだ^たろう',\n                                [default_encoding, 'iso2022_jp'])\n        pn2 = PersonNameUnicode(u'Yamada^Tarou=山田^太郎=やまだ^たろう',\n                                [default_encoding, 'iso2022_jp'])\n        assert hash(pn1) == hash(pn2)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testpersonname", "def", "test_hash", "self", "test", "that", "the", "same", "name", "creates", "the", "same", "hash", "regression", "test", "for", "785", "in", "python", "3", "pn1", "personnameunicode", "john", "doe", "dr", "encodings", "default_encoding", "pn2", "personnameunicode", "john", "doe", "dr", "encodings", "default_encoding", "assert", "hash", "pn1", "hash", "pn2", "pn3", "personnameunicode", "john", "doe", "encodings", "default_encoding", "assert", "hash", "pn1", "hash", "pn3", "pn1", "personnameunicode", "u", "yamada", "tarou", "default_encoding", "iso2022_jp", "pn2", "personnameunicode", "u", "yamada", "tarou", "default_encoding", "iso2022_jp", "assert", "hash", "pn1", "hash", "pn2"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDateTime.setup", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDateTime", "func_name": "setup", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDateTime\n    def setup(self):\n        config.datetime_conversion = True\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdatetime", "def", "setup", "self", "config", "datetime_conversion", "true"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDateTime.teardown", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDateTime", "func_name": "teardown", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDateTime\n    def teardown(self):\n        config.datetime_conversion = False\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdatetime", "def", "teardown", "self", "config", "datetime_conversion", "false"], "doc_len": 11}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDateTime.test_date", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDateTime", "func_name": "test_date", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDateTime\n    def test_date(self):\n        \"\"\"DA conversion to datetime.date ...\"\"\"\n        dicom_date = \"19610804\"\n        da = valuerep.DA(dicom_date)\n        # Assert `da` equals to correct `date`\n        assert date(1961, 8, 4) == da\n        # Assert `da.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_date) == repr(da)\n\n        dicom_date = \"1961.08.04\"  # ACR-NEMA Standard 300\n        da = valuerep.DA(dicom_date)\n        # Assert `da` equals to correct `date`\n        datetime_date = date(1961, 8, 4)\n        assert date(1961, 8, 4) == da\n        # Assert `da.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_date) == repr(da)\n\n        dicom_date = \"\"\n        da = valuerep.DA(dicom_date)\n        # Assert `da` equals to no date\n        assert da is None\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdatetime", "def", "test_date", "self", "da", "conversion", "to", "datetime", "date", "dicom_date", "19610804", "da", "valuerep", "da", "dicom_date", "assert", "da", "equals", "to", "correct", "date", "assert", "date", "1961", "8", "4", "da", "assert", "da", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_date", "repr", "da", "dicom_date", "1961", "08", "04", "acr", "nema", "standard", "300", "da", "valuerep", "da", "dicom_date", "assert", "da", "equals", "to", "correct", "date", "datetime_date", "date", "1961", "8", "4", "assert", "date", "1961", "8", "4", "da", "assert", "da", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_date", "repr", "da", "dicom_date", "da", "valuerep", "da", "dicom_date", "assert", "da", "equals", "to", "no", "date", "assert", "da", "is", "none"], "doc_len": 99}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDateTime.test_date_time", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDateTime", "func_name": "test_date_time", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDateTime\n    def test_date_time(self):\n        \"\"\"DT conversion to datetime.datetime ...\"\"\"\n        dicom_datetime = \"1961\"\n        dt = valuerep.DT(dicom_datetime)\n        # Assert `dt` equals to correct `datetime`\n        assert datetime(1961, 1, 1) == dt\n        # Assert `dt.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_datetime) == repr(dt)\n\n        dicom_datetime = \"19610804\"\n        dt = valuerep.DT(dicom_datetime)\n        # Assert `dt` equals to correct `datetime`\n        assert datetime(1961, 8, 4) == dt\n        # Assert `dt.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_datetime) == repr(dt)\n\n        dicom_datetime = \"19610804192430.123\"\n        dt = valuerep.DT(dicom_datetime)\n        # Assert `dt` equals to correct `datetime`\n        assert datetime(1961, 8, 4, 19, 24, 30, 123000) == dt\n        # Assert `dt.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_datetime) == repr(dt)\n\n        dicom_datetime = \"196108041924-1000\"\n        dt = valuerep.DT(dicom_datetime)\n        # Assert `dt` equals to correct `datetime`\n        datetime_datetime = datetime(1961, 8, 4, 19, 24, 0, 0,\n                                     timezone(timedelta(seconds=-10 * 3600)))\n        assert datetime_datetime == dt\n        assert timedelta(0, 0, 0, 0, 0, -10) == dt.utcoffset()\n\n        # Assert `dt.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_datetime) == repr(dt)\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdatetime", "def", "test_date_time", "self", "dt", "conversion", "to", "datetime", "datetime", "dicom_datetime", "1961", "dt", "valuerep", "dt", "dicom_datetime", "assert", "dt", "equals", "to", "correct", "datetime", "assert", "datetime", "1961", "1", "1", "dt", "assert", "dt", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_datetime", "repr", "dt", "dicom_datetime", "19610804", "dt", "valuerep", "dt", "dicom_datetime", "assert", "dt", "equals", "to", "correct", "datetime", "assert", "datetime", "1961", "8", "4", "dt", "assert", "dt", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_datetime", "repr", "dt", "dicom_datetime", "19610804192430", "123", "dt", "valuerep", "dt", "dicom_datetime", "assert", "dt", "equals", "to", "correct", "datetime", "assert", "datetime", "1961", "8", "4", "19", "24", "30", "123000", "dt", "assert", "dt", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_datetime", "repr", "dt", "dicom_datetime", "196108041924", "1000", "dt", "valuerep", "dt", "dicom_datetime", "assert", "dt", "equals", "to", "correct", "datetime", "datetime_datetime", "datetime", "1961", "8", "4", "19", "24", "0", "0", "timezone", "timedelta", "seconds", "10", "3600", "assert", "datetime_datetime", "dt", "assert", "timedelta", "0", "0", "0", "0", "0", "10", "dt", "utcoffset", "assert", "dt", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_datetime", "repr", "dt"], "doc_len": 160}
{"doc_id": "pydicom/tests/test_valuerep.py::TestDateTime.test_time", "file_path": "pydicom/tests/test_valuerep.py", "class_name": "TestDateTime", "func_name": "test_time", "text": "文件路径: pydicom/tests/test_valuerep.py, 类名: TestDateTime\n    def test_time(self):\n        \"\"\"TM conversion to datetime.time...\"\"\"\n        dicom_time = \"2359\"\n        tm = valuerep.TM(dicom_time)\n        # Assert `tm` equals to correct `time`\n        assert time(23, 59) == tm\n        # Assert `tm.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_time) == repr(tm)\n\n        dicom_time = \"235900.123\"\n        tm = valuerep.TM(dicom_time)\n        # Assert `tm` equals to correct `time`\n        assert time(23, 59, 00, 123000) == tm\n        # Assert `tm.__repr__` holds original string\n        assert '\"{0}\"'.format(dicom_time) == repr(tm)\n\n        # Assert `tm` equals to no `time`\n        tm = valuerep.TM(\"\")\n        assert tm is None\n", "tokens": ["pydicom", "tests", "test_valuerep", "py", "testdatetime", "def", "test_time", "self", "tm", "conversion", "to", "datetime", "time", "dicom_time", "2359", "tm", "valuerep", "tm", "dicom_time", "assert", "tm", "equals", "to", "correct", "time", "assert", "time", "23", "59", "tm", "assert", "tm", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_time", "repr", "tm", "dicom_time", "235900", "123", "tm", "valuerep", "tm", "dicom_time", "assert", "tm", "equals", "to", "correct", "time", "assert", "time", "23", "59", "00", "123000", "tm", "assert", "tm", "__repr__", "holds", "original", "string", "assert", "0", "format", "dicom_time", "repr", "tm", "assert", "tm", "equals", "to", "no", "time", "tm", "valuerep", "tm", "assert", "tm", "is", "none"], "doc_len": 87}
{"doc_id": "pydicom/tests/test_values.py::TestConvertTag.test_big_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertTag", "func_name": "test_big_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertTag\n    def test_big_endian(self):\n        \"\"\"Test convert_tag with a big endian byte string\"\"\"\n        bytestring = b'\\x00\\x10\\x00\\x20'\n        assert convert_tag(bytestring, False) == Tag(0x0010, 0x0020)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttag", "def", "test_big_endian", "self", "test", "convert_tag", "with", "a", "big", "endian", "byte", "string", "bytestring", "b", "x00", "x10", "x00", "x20", "assert", "convert_tag", "bytestring", "false", "tag", "0x0010", "0x0020"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_values.py::TestConvertTag.test_little_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertTag", "func_name": "test_little_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertTag\n    def test_little_endian(self):\n        \"\"\"Test convert_tag with a little endian byte string\"\"\"\n        bytestring = b'\\x10\\x00\\x20\\x00'\n        assert convert_tag(bytestring, True) == Tag(0x0010, 0x0020)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttag", "def", "test_little_endian", "self", "test", "convert_tag", "with", "a", "little", "endian", "byte", "string", "bytestring", "b", "x10", "x00", "x20", "x00", "assert", "convert_tag", "bytestring", "true", "tag", "0x0010", "0x0020"], "doc_len": 29}
{"doc_id": "pydicom/tests/test_values.py::TestConvertTag.test_offset", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertTag", "func_name": "test_offset", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertTag\n    def test_offset(self):\n        \"\"\"Test convert_tag with an offset\"\"\"\n        bytestring = b'\\x12\\x23\\x10\\x00\\x20\\x00\\x34\\x45'\n        assert convert_tag(bytestring, True, 0) == Tag(0x2312, 0x0010)\n        assert convert_tag(bytestring, True, 2) == Tag(0x0010, 0x0020)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttag", "def", "test_offset", "self", "test", "convert_tag", "with", "an", "offset", "bytestring", "b", "x12", "x23", "x10", "x00", "x20", "x00", "x34", "x45", "assert", "convert_tag", "bytestring", "true", "0", "tag", "0x2312", "0x0010", "assert", "convert_tag", "bytestring", "true", "2", "tag", "0x0010", "0x0020"], "doc_len": 39}
{"doc_id": "pydicom/tests/test_values.py::TestConvertTag.test_empty_bytestring", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertTag", "func_name": "test_empty_bytestring", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertTag\n    def test_empty_bytestring(self):\n        \"\"\"Test convert_tag with empty bytestring\"\"\"\n        bytestring = b''\n        assert convert_tag(bytestring, True) == ''\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttag", "def", "test_empty_bytestring", "self", "test", "convert_tag", "with", "empty", "bytestring", "bytestring", "b", "assert", "convert_tag", "bytestring", "true"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_values.py::TestConvertTag.test_bad_bytestring", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertTag", "func_name": "test_bad_bytestring", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertTag\n    def test_bad_bytestring(self):\n        \"\"\"Test convert_tag with a bad bytestring\"\"\"\n        bytestring = b'\\x10\\x00'\n        convert_tag(bytestring, True)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttag", "def", "test_bad_bytestring", "self", "test", "convert_tag", "with", "a", "bad", "bytestring", "bytestring", "b", "x10", "x00", "convert_tag", "bytestring", "true"], "doc_len": 21}
{"doc_id": "pydicom/tests/test_values.py::TestConvertAE.test_strip_blanks", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertAE", "func_name": "test_strip_blanks", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertAE\n    def test_strip_blanks(self):\n        bytestring = b'  AE_TITLE '\n        assert u'AE_TITLE' == convert_AE_string(bytestring, True)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertae", "def", "test_strip_blanks", "self", "bytestring", "b", "ae_title", "assert", "u", "ae_title", "convert_ae_string", "bytestring", "true"], "doc_len": 17}
{"doc_id": "pydicom/tests/test_values.py::TestConvertText.test_single_value", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertText", "func_name": "test_single_value", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertText\n    def test_single_value(self):\n        \"\"\"Test that encoding can change inside a text string\"\"\"\n        bytestring = (b'Dionysios is \\x1b\\x2d\\x46'\n                      b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2')\n        encodings = ('latin_1', 'iso_ir_126')\n        assert u'Dionysios is Διονυσιος' == convert_text(bytestring, encodings)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttext", "def", "test_single_value", "self", "test", "that", "encoding", "can", "change", "inside", "a", "text", "string", "bytestring", "b", "dionysios", "is", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "encodings", "latin_1", "iso_ir_126", "assert", "u", "dionysios", "is", "convert_text", "bytestring", "encodings"], "doc_len": 44}
{"doc_id": "pydicom/tests/test_values.py::TestConvertText.test_multi_value", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertText", "func_name": "test_multi_value", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertText\n    def test_multi_value(self):\n        \"\"\"Test that backslash is handled as value separator\"\"\"\n        bytestring = (b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                      b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                      b'\\x1b\\x2d\\x4C'\n                      b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3')\n        encodings = ('latin_1', 'iso_ir_144', 'iso_ir_126')\n        assert [u'Buc^Jérôme', u'Διονυσιος', u'Люкceмбypг'] == convert_text(\n            bytestring, encodings)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttext", "def", "test_multi_value", "self", "test", "that", "backslash", "is", "handled", "as", "value", "separator", "bytestring", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "assert", "u", "buc", "j", "r", "me", "u", "u", "ce", "yp", "convert_text", "bytestring", "encodings"], "doc_len": 67}
{"doc_id": "pydicom/tests/test_values.py::TestConvertText.test_single_value_with_backslash", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertText", "func_name": "test_single_value_with_backslash", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertText\n    def test_single_value_with_backslash(self):\n        \"\"\"Test that backslash is handled as character\"\"\"\n        bytestring = (b'Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46'\n                      b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\'\n                      b'\\x1b\\x2d\\x4C'\n                      b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3')\n        encodings = ('latin_1', 'iso_ir_144', 'iso_ir_126')\n        assert u'Buc^Jérôme\\\\Διονυσιος\\\\Люкceмбypг' == convert_single_string(\n            bytestring, encodings)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttext", "def", "test_single_value_with_backslash", "self", "test", "that", "backslash", "is", "handled", "as", "character", "bytestring", "b", "buc", "j", "xe9r", "xf4me", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "assert", "u", "buc", "j", "r", "me", "ce", "yp", "convert_single_string", "bytestring", "encodings"], "doc_len": 64}
{"doc_id": "pydicom/tests/test_values.py::TestConvertText.test_single_value_with_delimiters", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertText", "func_name": "test_single_value_with_delimiters", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertText\n    def test_single_value_with_delimiters(self):\n        \"\"\"Test that delimiters reset the encoding\"\"\"\n        bytestring = (b'\\x1b\\x2d\\x46'\n                      b'\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2'\n                      b'\\r\\nJ\\xe9r\\xf4me/'\n                      b'\\x1b\\x2d\\x4C'\n                      b'\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3'\n                      b'\\tJ\\xe9r\\xf4me')\n        encodings = ('latin_1', 'iso_ir_144', 'iso_ir_126')\n        expected = u'Διονυσιος\\r\\nJérôme/Люкceмбypг\\tJérôme'\n        assert expected == convert_single_string(bytestring, encodings)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconverttext", "def", "test_single_value_with_delimiters", "self", "test", "that", "delimiters", "reset", "the", "encoding", "bytestring", "b", "x1b", "x2d", "x46", "b", "xc4", "xe9", "xef", "xed", "xf5", "xf3", "xe9", "xef", "xf2", "b", "r", "nj", "xe9r", "xf4me", "b", "x1b", "x2d", "x4c", "b", "xbb", "xee", "xda", "x63", "x65", "xdc", "xd1", "x79", "x70", "xd3", "b", "tj", "xe9r", "xf4me", "encodings", "latin_1", "iso_ir_144", "iso_ir_126", "expected", "u", "r", "nj", "r", "me", "ce", "yp", "tj", "r", "me", "assert", "expected", "convert_single_string", "bytestring", "encodings"], "doc_len": 73}
{"doc_id": "pydicom/tests/test_values.py::TestConvertAT.test_big_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertAT", "func_name": "test_big_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertAT\n    def test_big_endian(self):\n        \"\"\"Test convert_ATvalue with a big endian byte string\"\"\"\n        # VM 1\n        bytestring = b'\\x00\\x10\\x00\\x20'\n        assert convert_ATvalue(bytestring, False) == Tag(0x0010, 0x0020)\n\n        # VM 3\n        bytestring += b'\\x00\\x10\\x00\\x30\\x00\\x10\\x00\\x40'\n        out = convert_ATvalue(bytestring, False)\n        assert Tag(0x0010, 0x0020) in out\n        assert Tag(0x0010, 0x0030) in out\n        assert Tag(0x0010, 0x0040) in out\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertat", "def", "test_big_endian", "self", "test", "convert_atvalue", "with", "a", "big", "endian", "byte", "string", "vm", "1", "bytestring", "b", "x00", "x10", "x00", "x20", "assert", "convert_atvalue", "bytestring", "false", "tag", "0x0010", "0x0020", "vm", "3", "bytestring", "b", "x00", "x10", "x00", "x30", "x00", "x10", "x00", "x40", "out", "convert_atvalue", "bytestring", "false", "assert", "tag", "0x0010", "0x0020", "in", "out", "assert", "tag", "0x0010", "0x0030", "in", "out", "assert", "tag", "0x0010", "0x0040", "in", "out"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_values.py::TestConvertAT.test_little_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertAT", "func_name": "test_little_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertAT\n    def test_little_endian(self):\n        \"\"\"Test convert_ATvalue with a little endian byte string\"\"\"\n        # VM 1\n        bytestring = b'\\x10\\x00\\x20\\x00'\n        assert convert_ATvalue(bytestring, True) == Tag(0x0010, 0x0020)\n\n        # VM 3\n        bytestring += b'\\x10\\x00\\x30\\x00\\x10\\x00\\x40\\x00'\n        out = convert_ATvalue(bytestring, True)\n        assert Tag(0x0010, 0x0020) in out\n        assert Tag(0x0010, 0x0030) in out\n        assert Tag(0x0010, 0x0040) in out\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertat", "def", "test_little_endian", "self", "test", "convert_atvalue", "with", "a", "little", "endian", "byte", "string", "vm", "1", "bytestring", "b", "x10", "x00", "x20", "x00", "assert", "convert_atvalue", "bytestring", "true", "tag", "0x0010", "0x0020", "vm", "3", "bytestring", "b", "x10", "x00", "x30", "x00", "x10", "x00", "x40", "x00", "out", "convert_atvalue", "bytestring", "true", "assert", "tag", "0x0010", "0x0020", "in", "out", "assert", "tag", "0x0010", "0x0030", "in", "out", "assert", "tag", "0x0010", "0x0040", "in", "out"], "doc_len": 65}
{"doc_id": "pydicom/tests/test_values.py::TestConvertAT.test_empty_bytestring", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertAT", "func_name": "test_empty_bytestring", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertAT\n    def test_empty_bytestring(self):\n        \"\"\"Test convert_ATvalue with empty bytestring\"\"\"\n        bytestring = b''\n        assert convert_ATvalue(bytestring, True) == []\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertat", "def", "test_empty_bytestring", "self", "test", "convert_atvalue", "with", "empty", "bytestring", "bytestring", "b", "assert", "convert_atvalue", "bytestring", "true"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_values.py::TestConvertAT.test_bad_length", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertAT", "func_name": "test_bad_length", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertAT\n    def test_bad_length(self):\n        \"\"\"Test convert_ATvalue with bad length bytestring\"\"\"\n        bytestring = b''\n        assert convert_ATvalue(bytestring, True) == ''\n\n        bytestring = b'\\x10\\x00\\x20\\x00\\x10\\x00\\x30\\x00\\x10'\n        convert_ATvalue(bytestring, True)\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertat", "def", "test_bad_length", "self", "test", "convert_atvalue", "with", "bad", "length", "bytestring", "bytestring", "b", "assert", "convert_atvalue", "bytestring", "true", "bytestring", "b", "x10", "x00", "x20", "x00", "x10", "x00", "x30", "x00", "x10", "convert_atvalue", "bytestring", "true"], "doc_len": 34}
{"doc_id": "pydicom/tests/test_values.py::TestConvertDA.test_big_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertDA", "func_name": "test_big_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertDA\n    def test_big_endian(self):\n        \"\"\"Test convert_DA_string with a big endian byte string\"\"\"\n        # VM 1\n        bytestring = b'\\x32\\x30\\x30\\x34\\x30\\x31\\x31\\x39'\n        # byte ordering independent\n        assert convert_DA_string(bytestring, False) == '20040119'\n\n        # VM 2\n        bytestring += b'\\x5c\\x31\\x39\\x39\\x39\\x31\\x32\\x31\\x32'\n        out = convert_DA_string(bytestring, False)\n        assert out == ['20040119', '19991212']\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertda", "def", "test_big_endian", "self", "test", "convert_da_string", "with", "a", "big", "endian", "byte", "string", "vm", "1", "bytestring", "b", "x32", "x30", "x30", "x34", "x30", "x31", "x31", "x39", "byte", "ordering", "independent", "assert", "convert_da_string", "bytestring", "false", "20040119", "vm", "2", "bytestring", "b", "x5c", "x31", "x39", "x39", "x39", "x31", "x32", "x31", "x32", "out", "convert_da_string", "bytestring", "false", "assert", "out", "20040119", "19991212"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_values.py::TestConvertDA.test_little_endian", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertDA", "func_name": "test_little_endian", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertDA\n    def test_little_endian(self):\n        \"\"\"Test convert_DA_string with a little endian byte string\"\"\"\n        # VM 1\n        bytestring = b'\\x32\\x30\\x30\\x34\\x30\\x31\\x31\\x39'\n        # byte ordering independent\n        assert convert_DA_string(bytestring, True) == '20040119'\n\n        # VM 2\n        bytestring += b'\\x5c\\x31\\x39\\x39\\x39\\x31\\x32\\x31\\x32'\n        out = convert_DA_string(bytestring, True)\n        assert out == ['20040119', '19991212']\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertda", "def", "test_little_endian", "self", "test", "convert_da_string", "with", "a", "little", "endian", "byte", "string", "vm", "1", "bytestring", "b", "x32", "x30", "x30", "x34", "x30", "x31", "x31", "x39", "byte", "ordering", "independent", "assert", "convert_da_string", "bytestring", "true", "20040119", "vm", "2", "bytestring", "b", "x5c", "x31", "x39", "x39", "x39", "x31", "x32", "x31", "x32", "out", "convert_da_string", "bytestring", "true", "assert", "out", "20040119", "19991212"], "doc_len": 57}
{"doc_id": "pydicom/tests/test_values.py::TestConvertDA.test_empty_bytestring", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertDA", "func_name": "test_empty_bytestring", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertDA\n    def test_empty_bytestring(self):\n        \"\"\"Test convert_DA_string with empty bytestring\"\"\"\n        bytestring = b''\n        assert convert_DA_string(bytestring, True) == ''\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertda", "def", "test_empty_bytestring", "self", "test", "convert_da_string", "with", "empty", "bytestring", "bytestring", "b", "assert", "convert_da_string", "bytestring", "true"], "doc_len": 19}
{"doc_id": "pydicom/tests/test_values.py::TestConvertValue.test_convert_value_raises", "file_path": "pydicom/tests/test_values.py", "class_name": "TestConvertValue", "func_name": "test_convert_value_raises", "text": "文件路径: pydicom/tests/test_values.py, 类名: TestConvertValue\n    def test_convert_value_raises(self):\n        \"\"\"Test convert_value raises exception if unsupported VR\"\"\"\n        converter_func = converters['PN']\n        del converters['PN']\n\n        with pytest.raises(NotImplementedError,\n                           match=\"Unknown Value Representation 'PN'\"):\n            convert_value('PN', None)\n\n        # Fix converters\n        converters['PN'] = converter_func\n        assert 'PN' in converters\n", "tokens": ["pydicom", "tests", "test_values", "py", "testconvertvalue", "def", "test_convert_value_raises", "self", "test", "convert_value", "raises", "exception", "if", "unsupported", "vr", "converter_func", "converters", "pn", "del", "converters", "pn", "with", "pytest", "raises", "notimplementederror", "match", "unknown", "value", "representation", "pn", "convert_value", "pn", "none", "fix", "converters", "converters", "pn", "converter_func", "assert", "pn", "in", "converters"], "doc_len": 42}
{"doc_id": "pydicom/tests/performance/raw_convert_test.py::test_full_read", "file_path": "pydicom/tests/performance/raw_convert_test.py", "class_name": null, "func_name": "test_full_read", "text": "文件路径: pydicom/tests/performance/raw_convert_test.py\ndef test_full_read(filename):\n    dataset = pydicom.dcmread(filename)\n    return dataset\n", "tokens": ["pydicom", "tests", "performance", "raw_convert_test", "py", "def", "test_full_read", "filename", "dataset", "pydicom", "dcmread", "filename", "return", "dataset"], "doc_len": 14}
{"doc_id": "pydicom/tests/performance/raw_convert_test.py::walkval", "file_path": "pydicom/tests/performance/raw_convert_test.py", "class_name": null, "func_name": "walkval", "text": "文件路径: pydicom/tests/performance/raw_convert_test.py\ndef walkval(dataset, dataelem):\n    dataelem.value\n", "tokens": ["pydicom", "tests", "performance", "raw_convert_test", "py", "def", "walkval", "dataset", "dataelem", "dataelem", "value"], "doc_len": 11}
{"doc_id": "pydicom/tests/performance/raw_convert_test.py::test_convert_from_raw", "file_path": "pydicom/tests/performance/raw_convert_test.py", "class_name": null, "func_name": "test_convert_from_raw", "text": "文件路径: pydicom/tests/performance/raw_convert_test.py\ndef test_convert_from_raw(dataset):\n    # s = str(dataset)\n    dataset.walk(walkval)\n", "tokens": ["pydicom", "tests", "performance", "raw_convert_test", "py", "def", "test_convert_from_raw", "dataset", "s", "str", "dataset", "dataset", "walk", "walkval"], "doc_len": 14}
{"doc_id": "pydicom/tests/performance/raw_convert_test.py::test_write_file", "file_path": "pydicom/tests/performance/raw_convert_test.py", "class_name": null, "func_name": "test_write_file", "text": "文件路径: pydicom/tests/performance/raw_convert_test.py\ndef test_write_file(dataset, write_filename):\n    dataset.save_as(write_filename)\n", "tokens": ["pydicom", "tests", "performance", "raw_convert_test", "py", "def", "test_write_file", "dataset", "write_filename", "dataset", "save_as", "write_filename"], "doc_len": 12}
{"doc_id": "pydicom/tests/performance/time_test.py::test_full_read", "file_path": "pydicom/tests/performance/time_test.py", "class_name": null, "func_name": "test_full_read", "text": "文件路径: pydicom/tests/performance/time_test.py\ndef test_full_read():\n    rf = pydicom.dcmread\n    datasets = [rf(fn) for fn in filenames1]\n    return datasets\n", "tokens": ["pydicom", "tests", "performance", "time_test", "py", "def", "test_full_read", "rf", "pydicom", "dcmread", "datasets", "rf", "fn", "for", "fn", "in", "filenames1", "return", "datasets"], "doc_len": 19}
{"doc_id": "pydicom/tests/performance/time_test.py::test_partial", "file_path": "pydicom/tests/performance/time_test.py", "class_name": null, "func_name": "test_partial", "text": "文件路径: pydicom/tests/performance/time_test.py\ndef test_partial():\n    rp = read_partial\n    [rp(open(fn, 'rb'), stop_when=_at_pixel_data) for fn in filenames2]\n", "tokens": ["pydicom", "tests", "performance", "time_test", "py", "def", "test_partial", "rp", "read_partial", "rp", "open", "fn", "rb", "stop_when", "_at_pixel_data", "for", "fn", "in", "filenames2"], "doc_len": 19}
{"doc_id": "pydicom/tests/performance/time_test.py::test_mem_read_full", "file_path": "pydicom/tests/performance/time_test.py", "class_name": null, "func_name": "test_mem_read_full", "text": "文件路径: pydicom/tests/performance/time_test.py\ndef test_mem_read_full():\n    rf = pydicom.dcmread\n    str_io = BytesIO\n    memory_files = (str_io(open(fn, 'rb').read()) for fn in filenames3)\n    [rf(memory_file) for memory_file in memory_files]\n", "tokens": ["pydicom", "tests", "performance", "time_test", "py", "def", "test_mem_read_full", "rf", "pydicom", "dcmread", "str_io", "bytesio", "memory_files", "str_io", "open", "fn", "rb", "read", "for", "fn", "in", "filenames3", "rf", "memory_file", "for", "memory_file", "in", "memory_files"], "doc_len": 28}
{"doc_id": "pydicom/tests/performance/time_test.py::test_mem_read_small", "file_path": "pydicom/tests/performance/time_test.py", "class_name": null, "func_name": "test_mem_read_small", "text": "文件路径: pydicom/tests/performance/time_test.py\ndef test_mem_read_small():\n    rf = pydicom.dcmread\n    str_io = BytesIO  # avoid global lookup, make local instead\n    memory_files = (str_io(open(fn, 'rb').read(4000)) for fn in filenames4)\n    [rf(memory_file) for memory_file in memory_files]\n", "tokens": ["pydicom", "tests", "performance", "time_test", "py", "def", "test_mem_read_small", "rf", "pydicom", "dcmread", "str_io", "bytesio", "avoid", "global", "lookup", "make", "local", "instead", "memory_files", "str_io", "open", "fn", "rb", "read", "4000", "for", "fn", "in", "filenames4", "rf", "memory_file", "for", "memory_file", "in", "memory_files"], "doc_len": 35}
{"doc_id": "pydicom/tests/performance/time_test.py::test_python_read_files", "file_path": "pydicom/tests/performance/time_test.py", "class_name": null, "func_name": "test_python_read_files", "text": "文件路径: pydicom/tests/performance/time_test.py\ndef test_python_read_files():\n    [open(fn, 'rb').read() for fn in filenames4]\n", "tokens": ["pydicom", "tests", "performance", "time_test", "py", "def", "test_python_read_files", "open", "fn", "rb", "read", "for", "fn", "in", "filenames4"], "doc_len": 15}
{"doc_id": "pydicom/tests/performance/write_profiling.py::trace_calls", "file_path": "pydicom/tests/performance/write_profiling.py", "class_name": null, "func_name": "trace_calls", "text": "文件路径: pydicom/tests/performance/write_profiling.py\ndef trace_calls(frame, event, arg):\n    if event != 'call':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    func_line_no = frame.f_lineno\n    func_filename = co.co_filename\n\n    if func_name not in [\"__getitem__\", \"__setitem__\"]:\n        return\n    if \"dataset.py\" not in func_filename:\n        return\n\n    caller = frame.f_back\n    caller_line_no = caller.f_lineno\n    caller_filename = caller.f_code.co_filename\n    caller_mosh = os.path.basename(caller_filename) + \":\" + str(caller_line_no)\n\n    if func_name == \"__getitem__\":\n        get_calls.append(caller_mosh)\n    else:\n        set_calls.append(caller_mosh)\n", "tokens": ["pydicom", "tests", "performance", "write_profiling", "py", "def", "trace_calls", "frame", "event", "arg", "if", "event", "call", "return", "co", "frame", "f_code", "func_name", "co", "co_name", "func_line_no", "frame", "f_lineno", "func_filename", "co", "co_filename", "if", "func_name", "not", "in", "__getitem__", "__setitem__", "return", "if", "dataset", "py", "not", "in", "func_filename", "return", "caller", "frame", "f_back", "caller_line_no", "caller", "f_lineno", "caller_filename", "caller", "f_code", "co_filename", "caller_mosh", "os", "path", "basename", "caller_filename", "str", "caller_line_no", "if", "func_name", "__getitem__", "get_calls", "append", "caller_mosh", "else", "set_calls", "append", "caller_mosh"], "doc_len": 67}
{"doc_id": "pydicom/tests/performance/write_profiling.py::test_write", "file_path": "pydicom/tests/performance/write_profiling.py", "class_name": null, "func_name": "test_write", "text": "文件路径: pydicom/tests/performance/write_profiling.py\ndef test_write():\n    for i in range(len(datasets)):\n        datasets[i].save_as(ds_new_filenames[i])\n", "tokens": ["pydicom", "tests", "performance", "write_profiling", "py", "def", "test_write", "for", "i", "in", "range", "len", "datasets", "datasets", "i", "save_as", "ds_new_filenames", "i"], "doc_len": 18}
{"doc_id": "pydicom/tests/performance/write_profiling.py::test_python_write_files", "file_path": "pydicom/tests/performance/write_profiling.py", "class_name": null, "func_name": "test_python_write_files", "text": "文件路径: pydicom/tests/performance/write_profiling.py\ndef test_python_write_files():\n    [open(fn, 'rb').read() for fn in filenames4]\n", "tokens": ["pydicom", "tests", "performance", "write_profiling", "py", "def", "test_python_write_files", "open", "fn", "rb", "read", "for", "fn", "in", "filenames4"], "doc_len": 15}
{"doc_id": "pydicom/util/codify.py::camel_to_underscore", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "camel_to_underscore", "text": "文件路径: pydicom/util/codify.py\ndef camel_to_underscore(name):\n    \"\"\"Convert name from CamelCase to lower_case_with_underscores\"\"\"\n    # From http://stackoverflow.com/questions/1175208\n    s1 = first_cap_re.sub(r'\\1_\\2', name)\n    return all_cap_re.sub(r'\\1_\\2', s1).lower()\n", "tokens": ["pydicom", "util", "codify", "py", "def", "camel_to_underscore", "name", "convert", "name", "from", "camelcase", "to", "lower_case_with_underscores", "from", "http", "stackoverflow", "com", "questions", "1175208", "s1", "first_cap_re", "sub", "r", "1_", "2", "name", "return", "all_cap_re", "sub", "r", "1_", "2", "s1", "lower"], "doc_len": 34}
{"doc_id": "pydicom/util/codify.py::tag_repr", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "tag_repr", "text": "文件路径: pydicom/util/codify.py\ndef tag_repr(tag):\n    \"\"\"String of tag value as (0xgggg, 0xeeee)\"\"\"\n    return \"(0x{group:04x}, 0x{elem:04x})\".format(\n        group=tag.group, elem=tag.element)\n", "tokens": ["pydicom", "util", "codify", "py", "def", "tag_repr", "tag", "string", "of", "tag", "value", "as", "0xgggg", "0xeeee", "return", "0x", "group", "04x", "0x", "elem", "04x", "format", "group", "tag", "group", "elem", "tag", "element"], "doc_len": 28}
{"doc_id": "pydicom/util/codify.py::default_name_filter", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "default_name_filter", "text": "文件路径: pydicom/util/codify.py\ndef default_name_filter(name):\n    \"\"\"Callable to reduce some names in code to more readable short form\n\n    :arg name: a sequence variable name or sequence item name\n    :return: a shorter version of name if a known conversion,\n             else return original name\n\n    \"\"\"\n    name = camel_to_underscore(name)\n    name = name.replace(\"control_point\", \"cp\")\n    name = name.replace(\"reference\", \"ref\")\n    name = name.replace(\"fraction_group\", \"frxn_gp\")\n    return name\n", "tokens": ["pydicom", "util", "codify", "py", "def", "default_name_filter", "name", "callable", "to", "reduce", "some", "names", "in", "code", "to", "more", "readable", "short", "form", "arg", "name", "a", "sequence", "variable", "name", "or", "sequence", "item", "name", "return", "a", "shorter", "version", "of", "name", "if", "a", "known", "conversion", "else", "return", "original", "name", "name", "camel_to_underscore", "name", "name", "name", "replace", "control_point", "cp", "name", "name", "replace", "reference", "ref", "name", "name", "replace", "fraction_group", "frxn_gp", "return", "name"], "doc_len": 63}
{"doc_id": "pydicom/util/codify.py::code_imports", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "code_imports", "text": "文件路径: pydicom/util/codify.py\ndef code_imports():\n    \"\"\"Code the import statements needed by other codify results\n\n    :return: a string of import statement lines\n\n    \"\"\"\n    line0 = \"from __future__ import unicode_literals\"\n    line0 += \"  # Only for python2.7 and save_as unicode filename\"\n    line1 = \"import pydicom\"\n    line2 = \"from pydicom.dataset import Dataset\"\n    line3 = \"from pydicom.sequence import Sequence\"\n    return line_term.join((line0, line1, line2, line3))\n", "tokens": ["pydicom", "util", "codify", "py", "def", "code_imports", "code", "the", "import", "statements", "needed", "by", "other", "codify", "results", "return", "a", "string", "of", "import", "statement", "lines", "line0", "from", "__future__", "import", "unicode_literals", "line0", "only", "for", "python2", "7", "and", "save_as", "unicode", "filename", "line1", "import", "pydicom", "line2", "from", "pydicom", "dataset", "import", "dataset", "line3", "from", "pydicom", "sequence", "import", "sequence", "return", "line_term", "join", "line0", "line1", "line2", "line3"], "doc_len": 58}
{"doc_id": "pydicom/util/codify.py::code_dataelem", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "code_dataelem", "text": "文件路径: pydicom/util/codify.py\ndef code_dataelem(dataelem,\n                  dataset_name=\"ds\",\n                  exclude_size=None,\n                  include_private=False):\n    \"\"\"Code lines for a single DICOM data element\n\n    :arg dataelem: the DataElement instance to turn into code\n    :arg dataset_name: variable name of the Dataset containing dataelem\n    :arg exclude_size: if specified, values longer than this (in bytes)\n                       will only have a commented string for a value,\n                       causing a syntax error when the code is run,\n                       and thus prompting the user to remove or fix that line.\n    :return: a string containing code to recreate the data element\n             If the data element is a sequence, calls code_sequence\n\n    \"\"\"\n\n    if dataelem.VR == \"SQ\":\n        return code_sequence(dataelem, dataset_name, exclude_size,\n                             include_private)\n\n    # If in DICOM dictionary, set using the keyword\n    # If not (e.g. is private element), set using add_new method\n    have_keyword = True\n    try:\n        keyword = dictionary_keyword(dataelem.tag)\n    except KeyError:\n        have_keyword = False\n\n    valuerep = repr(dataelem.value)\n\n    if exclude_size:\n        if (dataelem.VR in byte_VRs and\n                len(dataelem.value) > exclude_size):\n            valuerep = (\n                \"# XXX Array of %d bytes excluded\" % len(dataelem.value))\n\n    if have_keyword:\n        format_str = \"{ds_name}.{keyword} = {valuerep}\"\n        line = format_str.format(\n            ds_name=dataset_name, keyword=keyword, valuerep=valuerep)\n    else:\n        format_str = \"{ds_name}.add_new({tag}, '{VR}', {valuerep})\"\n        line = format_str.format(\n            ds_name=dataset_name,\n            tag=tag_repr(dataelem.tag),\n            VR=dataelem.VR,\n            valuerep=valuerep)\n    return line\n", "tokens": ["pydicom", "util", "codify", "py", "def", "code_dataelem", "dataelem", "dataset_name", "ds", "exclude_size", "none", "include_private", "false", "code", "lines", "for", "a", "single", "dicom", "data", "element", "arg", "dataelem", "the", "dataelement", "instance", "to", "turn", "into", "code", "arg", "dataset_name", "variable", "name", "of", "the", "dataset", "containing", "dataelem", "arg", "exclude_size", "if", "specified", "values", "longer", "than", "this", "in", "bytes", "will", "only", "have", "a", "commented", "string", "for", "a", "value", "causing", "a", "syntax", "error", "when", "the", "code", "is", "run", "and", "thus", "prompting", "the", "user", "to", "remove", "or", "fix", "that", "line", "return", "a", "string", "containing", "code", "to", "recreate", "the", "data", "element", "if", "the", "data", "element", "is", "a", "sequence", "calls", "code_sequence", "if", "dataelem", "vr", "sq", "return", "code_sequence", "dataelem", "dataset_name", "exclude_size", "include_private", "if", "in", "dicom", "dictionary", "set", "using", "the", "keyword", "if", "not", "e", "g", "is", "private", "element", "set", "using", "add_new", "method", "have_keyword", "true", "try", "keyword", "dictionary_keyword", "dataelem", "tag", "except", "keyerror", "have_keyword", "false", "valuerep", "repr", "dataelem", "value", "if", "exclude_size", "if", "dataelem", "vr", "in", "byte_vrs", "and", "len", "dataelem", "value", "exclude_size", "valuerep", "xxx", "array", "of", "d", "bytes", "excluded", "len", "dataelem", "value", "if", "have_keyword", "format_str", "ds_name", "keyword", "valuerep", "line", "format_str", "format", "ds_name", "dataset_name", "keyword", "keyword", "valuerep", "valuerep", "else", "format_str", "ds_name", "add_new", "tag", "vr", "valuerep", "line", "format_str", "format", "ds_name", "dataset_name", "tag", "tag_repr", "dataelem", "tag", "vr", "dataelem", "vr", "valuerep", "valuerep", "return", "line"], "doc_len": 201}
{"doc_id": "pydicom/util/codify.py::code_sequence", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "code_sequence", "text": "文件路径: pydicom/util/codify.py\ndef code_sequence(dataelem,\n                  dataset_name=\"ds\",\n                  exclude_size=None,\n                  include_private=False,\n                  name_filter=default_name_filter):\n    \"\"\"Code lines for recreating a Sequence data element\n\n    :arg dataelem: the DataElement instance of the Sequence\n    :arg dataset_name: variable name of the dataset containing the Sequence\n    :arg exclude_size: if specified, values longer than this (in bytes)\n                       will only have a commented string for a value,\n                       causing a syntax error when the code is run,\n                       and thus prompting the user to remove or fix that line.\n    :arg include_private: If True, private data elements will be coded.\n                          If False, private elements are skipped\n    :arg name_filter: a callable taking a sequence name or sequence item name,\n                      and returning a shorter name for easier code reading\n    :return: a string containing code lines to recreate a DICOM sequence\n\n    \"\"\"\n    lines = []\n    seq = dataelem.value\n    seq_name = dataelem.name\n    seq_item_name = seq_name.replace(' Sequence', '')\n    seq_keyword = dictionary_keyword(dataelem.tag)\n\n    # Create comment line to document the start of Sequence\n    lines.append('')\n    lines.append(\"# \" + seq_name)\n\n    # Code line to create a new Sequence object\n    if name_filter:\n        seq_var = name_filter(seq_keyword)\n    lines.append(seq_var + \" = Sequence()\")\n\n    # Code line to add the sequence to its parent\n    lines.append(dataset_name + \".\" + seq_keyword + \" = \" + seq_var)\n\n    # Code lines to add sequence items to the Sequence\n    for i, ds in enumerate(seq):\n        # Determine index to use. If seq item has a data element with 'Index',\n        #    use that; if one with 'Number', use that, else start at 1\n        index_keyword = seq_keyword.replace(\"Sequence\", \"\") + \"Index\"\n        number_keyword = seq_keyword.replace(\"Sequence\", \"\") + \"Number\"\n        if index_keyword in ds:\n            index_str = str(getattr(ds, index_keyword))\n        elif number_keyword in ds:\n            index_str = str(getattr(ds, number_keyword))\n        else:\n            index_str = str(i + 1)\n\n        # Code comment line to mark start of sequence item\n        lines.append('')\n        lines.append(\"# \" + seq_name + \": \" + seq_item_name + \" \" + index_str)\n\n        # Determine the variable name to use for the sequence item (dataset)\n        ds_name = seq_var.replace(\"_sequence\", \"\") + index_str\n\n        # Code the sequence item\n        code_item = code_dataset(ds, ds_name, exclude_size, include_private)\n        lines.append(code_item)\n\n        # Code the line to append the item to its parent sequence\n        lines.append(seq_var + \".append(\" + ds_name + \")\")\n\n    # Join the lines and return a single string\n    return line_term.join(lines)\n", "tokens": ["pydicom", "util", "codify", "py", "def", "code_sequence", "dataelem", "dataset_name", "ds", "exclude_size", "none", "include_private", "false", "name_filter", "default_name_filter", "code", "lines", "for", "recreating", "a", "sequence", "data", "element", "arg", "dataelem", "the", "dataelement", "instance", "of", "the", "sequence", "arg", "dataset_name", "variable", "name", "of", "the", "dataset", "containing", "the", "sequence", "arg", "exclude_size", "if", "specified", "values", "longer", "than", "this", "in", "bytes", "will", "only", "have", "a", "commented", "string", "for", "a", "value", "causing", "a", "syntax", "error", "when", "the", "code", "is", "run", "and", "thus", "prompting", "the", "user", "to", "remove", "or", "fix", "that", "line", "arg", "include_private", "if", "true", "private", "data", "elements", "will", "be", "coded", "if", "false", "private", "elements", "are", "skipped", "arg", "name_filter", "a", "callable", "taking", "a", "sequence", "name", "or", "sequence", "item", "name", "and", "returning", "a", "shorter", "name", "for", "easier", "code", "reading", "return", "a", "string", "containing", "code", "lines", "to", "recreate", "a", "dicom", "sequence", "lines", "seq", "dataelem", "value", "seq_name", "dataelem", "name", "seq_item_name", "seq_name", "replace", "sequence", "seq_keyword", "dictionary_keyword", "dataelem", "tag", "create", "comment", "line", "to", "document", "the", "start", "of", "sequence", "lines", "append", "lines", "append", "seq_name", "code", "line", "to", "create", "a", "new", "sequence", "object", "if", "name_filter", "seq_var", "name_filter", "seq_keyword", "lines", "append", "seq_var", "sequence", "code", "line", "to", "add", "the", "sequence", "to", "its", "parent", "lines", "append", "dataset_name", "seq_keyword", "seq_var", "code", "lines", "to", "add", "sequence", "items", "to", "the", "sequence", "for", "i", "ds", "in", "enumerate", "seq", "determine", "index", "to", "use", "if", "seq", "item", "has", "a", "data", "element", "with", "index", "use", "that", "if", "one", "with", "number", "use", "that", "else", "start", "at", "1", "index_keyword", "seq_keyword", "replace", "sequence", "index", "number_keyword", "seq_keyword", "replace", "sequence", "number", "if", "index_keyword", "in", "ds", "index_str", "str", "getattr", "ds", "index_keyword", "elif", "number_keyword", "in", "ds", "index_str", "str", "getattr", "ds", "number_keyword", "else", "index_str", "str", "i", "1", "code", "comment", "line", "to", "mark", "start", "of", "sequence", "item", "lines", "append", "lines", "append", "seq_name", "seq_item_name", "index_str", "determine", "the", "variable", "name", "to", "use", "for", "the", "sequence", "item", "dataset", "ds_name", "seq_var", "replace", "_sequence", "index_str", "code", "the", "sequence", "item", "code_item", "code_dataset", "ds", "ds_name", "exclude_size", "include_private", "lines", "append", "code_item", "code", "the", "line", "to", "append", "the", "item", "to", "its", "parent", "sequence", "lines", "append", "seq_var", "append", "ds_name", "join", "the", "lines", "and", "return", "a", "single", "string", "return", "line_term", "join", "lines"], "doc_len": 334}
{"doc_id": "pydicom/util/codify.py::code_dataset", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "code_dataset", "text": "文件路径: pydicom/util/codify.py\ndef code_dataset(ds,\n                 dataset_name=\"ds\",\n                 exclude_size=None,\n                 include_private=False):\n    \"\"\"Return python code lines for import statements needed by other code\n\n    :arg exclude_size: if specified, values longer than this (in bytes)\n                       will only have a commented string for a value,\n                       causing a syntax error when the code is run,\n                       and thus prompting the user to remove or fix that line.\n    :arg include_private: If True, private data elements will be coded.\n                          If False, private elements are skipped\n    :return: a list of code lines containing import statements\n\n    \"\"\"\n    lines = []\n    lines.append(dataset_name + \" = Dataset()\")\n    for dataelem in ds:\n        # If a private data element and flag says so, skip it and go to next\n        if not include_private and dataelem.tag.is_private:\n            continue\n        # Otherwise code the line and add it to the lines list\n        code_line = code_dataelem(dataelem, dataset_name, exclude_size,\n                                  include_private)\n        lines.append(code_line)\n        # Add blank line if just coded a sequence\n        if dataelem.VR == \"SQ\":\n            lines.append('')\n    # If sequence was end of this dataset, remove the extra blank line\n    if len(lines) and lines[-1] == '':\n        lines.pop()\n    # Join all the code lines and return them\n    return line_term.join(lines)\n", "tokens": ["pydicom", "util", "codify", "py", "def", "code_dataset", "ds", "dataset_name", "ds", "exclude_size", "none", "include_private", "false", "return", "python", "code", "lines", "for", "import", "statements", "needed", "by", "other", "code", "arg", "exclude_size", "if", "specified", "values", "longer", "than", "this", "in", "bytes", "will", "only", "have", "a", "commented", "string", "for", "a", "value", "causing", "a", "syntax", "error", "when", "the", "code", "is", "run", "and", "thus", "prompting", "the", "user", "to", "remove", "or", "fix", "that", "line", "arg", "include_private", "if", "true", "private", "data", "elements", "will", "be", "coded", "if", "false", "private", "elements", "are", "skipped", "return", "a", "list", "of", "code", "lines", "containing", "import", "statements", "lines", "lines", "append", "dataset_name", "dataset", "for", "dataelem", "in", "ds", "if", "a", "private", "data", "element", "and", "flag", "says", "so", "skip", "it", "and", "go", "to", "next", "if", "not", "include_private", "and", "dataelem", "tag", "is_private", "continue", "otherwise", "code", "the", "line", "and", "add", "it", "to", "the", "lines", "list", "code_line", "code_dataelem", "dataelem", "dataset_name", "exclude_size", "include_private", "lines", "append", "code_line", "add", "blank", "line", "if", "just", "coded", "a", "sequence", "if", "dataelem", "vr", "sq", "lines", "append", "if", "sequence", "was", "end", "of", "this", "dataset", "remove", "the", "extra", "blank", "line", "if", "len", "lines", "and", "lines", "1", "lines", "pop", "join", "all", "the", "code", "lines", "and", "return", "them", "return", "line_term", "join", "lines"], "doc_len": 186}
{"doc_id": "pydicom/util/codify.py::code_file", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "code_file", "text": "文件路径: pydicom/util/codify.py\ndef code_file(filename, exclude_size=None, include_private=False):\n    \"\"\"Write a complete source code file to recreate a DICOM file\n\n    :arg filename: complete path and filename of a DICOM file to convert\n    :arg exclude_size: if specified, values longer than this (in bytes)\n                       will only have a commented string for a value,\n                       causing a syntax error when the code is run,\n                       and thus prompting the user to remove or fix that line.\n    :arg include_private: If True, private data elements will be coded.\n                          If False, private elements are skipped\n    :return: a string containing code lines to recreate entire file\n\n    \"\"\"\n    lines = []\n\n    ds = pydicom.dcmread(filename, force=True)\n\n    # Code a nice header for the python file\n    lines.append(\"# Coded version of DICOM file '{0}'\".format(filename))\n    lines.append(\"# Produced by pydicom codify utility script\")\n\n    # Code the necessary imports\n    lines.append(code_imports())\n    lines.append('')\n\n    # Code the file_meta information\n    lines.append(\"# File meta info data elements\")\n    code_meta = code_dataset(ds.file_meta, \"file_meta\", exclude_size,\n                             include_private)\n    lines.append(code_meta)\n    lines.append('')\n\n    # Code the main dataset\n    lines.append(\"# Main data elements\")\n    code_ds = code_dataset(\n        ds, exclude_size=exclude_size, include_private=include_private)\n    lines.append(code_ds)\n    lines.append('')\n\n    # Add the file meta to the dataset, and set transfer syntax\n    lines.append(\"ds.file_meta = file_meta\")\n    lines.append(\"ds.is_implicit_VR = \" + str(ds.is_implicit_VR))\n    lines.append(\"ds.is_little_endian = \" + str(ds.is_little_endian))\n\n    # Return the complete code string\n    return line_term.join(lines)\n", "tokens": ["pydicom", "util", "codify", "py", "def", "code_file", "filename", "exclude_size", "none", "include_private", "false", "write", "a", "complete", "source", "code", "file", "to", "recreate", "a", "dicom", "file", "arg", "filename", "complete", "path", "and", "filename", "of", "a", "dicom", "file", "to", "convert", "arg", "exclude_size", "if", "specified", "values", "longer", "than", "this", "in", "bytes", "will", "only", "have", "a", "commented", "string", "for", "a", "value", "causing", "a", "syntax", "error", "when", "the", "code", "is", "run", "and", "thus", "prompting", "the", "user", "to", "remove", "or", "fix", "that", "line", "arg", "include_private", "if", "true", "private", "data", "elements", "will", "be", "coded", "if", "false", "private", "elements", "are", "skipped", "return", "a", "string", "containing", "code", "lines", "to", "recreate", "entire", "file", "lines", "ds", "pydicom", "dcmread", "filename", "force", "true", "code", "a", "nice", "header", "for", "the", "python", "file", "lines", "append", "coded", "version", "of", "dicom", "file", "0", "format", "filename", "lines", "append", "produced", "by", "pydicom", "codify", "utility", "script", "code", "the", "necessary", "imports", "lines", "append", "code_imports", "lines", "append", "code", "the", "file_meta", "information", "lines", "append", "file", "meta", "info", "data", "elements", "code_meta", "code_dataset", "ds", "file_meta", "file_meta", "exclude_size", "include_private", "lines", "append", "code_meta", "lines", "append", "code", "the", "main", "dataset", "lines", "append", "main", "data", "elements", "code_ds", "code_dataset", "ds", "exclude_size", "exclude_size", "include_private", "include_private", "lines", "append", "code_ds", "lines", "append", "add", "the", "file", "meta", "to", "the", "dataset", "and", "set", "transfer", "syntax", "lines", "append", "ds", "file_meta", "file_meta", "lines", "append", "ds", "is_implicit_vr", "str", "ds", "is_implicit_vr", "lines", "append", "ds", "is_little_endian", "str", "ds", "is_little_endian", "return", "the", "complete", "code", "string", "return", "line_term", "join", "lines"], "doc_len": 224}
{"doc_id": "pydicom/util/codify.py::main", "file_path": "pydicom/util/codify.py", "class_name": null, "func_name": "main", "text": "文件路径: pydicom/util/codify.py\ndef main(default_exclude_size, args=None):\n    \"\"\"Create python code according to user options\n\n    Parameters:\n    -----------\n    default_exclude_size:  int\n        Values longer than this will be coded as a commented syntax error\n\n    args: list\n        Command-line arguments to parse.  If None, then sys.argv is used\n    \"\"\"\n\n    try:\n        import argparse\n    except ImportError:\n        print(\"The argparse module is required to run this script\")\n        print(\"argparse is standard in python >= 2.7,\")\n        print(\"   or can be installed with 'pip install argparse'\")\n        sys.exit(-1)\n\n    parser = argparse.ArgumentParser(\n        description=\"Produce python/pydicom code from a DICOM file\",\n        epilog=\"Binary data (e.g. pixels) larger than --exclude-size \"\n        \"(default %d bytes) is not included. A dummy line \"\n        \"with a syntax error is produced. \"\n        \"Private data elements are not included \"\n        \"by default.\" % default_exclude_size)\n    parser.add_argument(\n        'infile', help=\"DICOM file from which to produce code lines\")\n    parser.add_argument(\n        'outfile',\n        nargs='?',\n        type=argparse.FileType('w'),\n        help=(\"Filename to write python code to. \"\n              \"If not specified, code is written to stdout\"),\n        default=sys.stdout)\n    help_exclude_size = 'Exclude binary data larger than specified (bytes). '\n    help_exclude_size += 'Default is %d bytes' % default_exclude_size\n    parser.add_argument(\n        '-e',\n        '--exclude-size',\n        type=int_type,\n        default=default_exclude_size,\n        help=help_exclude_size)\n    parser.add_argument(\n        '-p',\n        '--include-private',\n        action=\"store_true\",\n        help='Include private data elements '\n        '(default is to exclude them)')\n    parser.add_argument(\n        '-s',\n        '--save-as',\n        help=(\"Specify the filename for ds.save_as(save_filename); \"\n              \"otherwise the input name + '_from_codify' will be used\"))\n\n    args = parser.parse_args(args)\n\n    # Read the requested file and convert to python/pydicom code lines\n    filename = args.infile  # name\n    code_lines = code_file(filename, args.exclude_size, args.include_private)\n\n    # If requested, write a code line to save the dataset\n    if args.save_as:\n        save_as_filename = args.save_as\n    else:\n        base, ext = os.path.splitext(filename)\n        save_as_filename = base + \"_from_codify\" + \".dcm\"\n    line = \"\\nds.save_as(r'{filename}', write_like_original=False)\"\n    save_line = line.format(filename=save_as_filename)\n    code_lines += save_line\n\n    # Write the code lines to specified file or to standard output\n    # For test_util, captured output .name throws error, ignore it:\n    try:\n        if args.outfile.name != \"<stdout>\":\n            print(\"Writing code to file '%s'\" % args.outfile.name)\n    except AttributeError:\n        pass\n    args.outfile.write(code_lines)\n", "tokens": ["pydicom", "util", "codify", "py", "def", "main", "default_exclude_size", "args", "none", "create", "python", "code", "according", "to", "user", "options", "parameters", "default_exclude_size", "int", "values", "longer", "than", "this", "will", "be", "coded", "as", "a", "commented", "syntax", "error", "args", "list", "command", "line", "arguments", "to", "parse", "if", "none", "then", "sys", "argv", "is", "used", "try", "import", "argparse", "except", "importerror", "print", "the", "argparse", "module", "is", "required", "to", "run", "this", "script", "print", "argparse", "is", "standard", "in", "python", "2", "7", "print", "or", "can", "be", "installed", "with", "pip", "install", "argparse", "sys", "exit", "1", "parser", "argparse", "argumentparser", "description", "produce", "python", "pydicom", "code", "from", "a", "dicom", "file", "epilog", "binary", "data", "e", "g", "pixels", "larger", "than", "exclude", "size", "default", "d", "bytes", "is", "not", "included", "a", "dummy", "line", "with", "a", "syntax", "error", "is", "produced", "private", "data", "elements", "are", "not", "included", "by", "default", "default_exclude_size", "parser", "add_argument", "infile", "help", "dicom", "file", "from", "which", "to", "produce", "code", "lines", "parser", "add_argument", "outfile", "nargs", "type", "argparse", "filetype", "w", "help", "filename", "to", "write", "python", "code", "to", "if", "not", "specified", "code", "is", "written", "to", "stdout", "default", "sys", "stdout", "help_exclude_size", "exclude", "binary", "data", "larger", "than", "specified", "bytes", "help_exclude_size", "default", "is", "d", "bytes", "default_exclude_size", "parser", "add_argument", "e", "exclude", "size", "type", "int_type", "default", "default_exclude_size", "help", "help_exclude_size", "parser", "add_argument", "p", "include", "private", "action", "store_true", "help", "include", "private", "data", "elements", "default", "is", "to", "exclude", "them", "parser", "add_argument", "s", "save", "as", "help", "specify", "the", "filename", "for", "ds", "save_as", "save_filename", "otherwise", "the", "input", "name", "_from_codify", "will", "be", "used", "args", "parser", "parse_args", "args", "read", "the", "requested", "file", "and", "convert", "to", "python", "pydicom", "code", "lines", "filename", "args", "infile", "name", "code_lines", "code_file", "filename", "args", "exclude_size", "args", "include_private", "if", "requested", "write", "a", "code", "line", "to", "save", "the", "dataset", "if", "args", "save_as", "save_as_filename", "args", "save_as", "else", "base", "ext", "os", "path", "splitext", "filename", "save_as_filename", "base", "_from_codify", "dcm", "line", "nds", "save_as", "r", "filename", "write_like_original", "false", "save_line", "line", "format", "filename", "save_as_filename", "code_lines", "save_line", "write", "the", "code", "lines", "to", "specified", "file", "or", "to", "standard", "output", "for", "test_util", "captured", "output", "name", "throws", "error", "ignore", "it", "try", "if", "args", "outfile", "name", "stdout", "print", "writing", "code", "to", "file", "s", "args", "outfile", "name", "except", "attributeerror", "pass", "args", "outfile", "write", "code_lines"], "doc_len": 336}
{"doc_id": "pydicom/util/dump.py::print_character", "file_path": "pydicom/util/dump.py", "class_name": null, "func_name": "print_character", "text": "文件路径: pydicom/util/dump.py\ndef print_character(ordchr):\n    \"\"\"Return a printable character, or '.' for non-printable ones.\"\"\"\n    if 31 < ordchr < 126 and ordchr != 92:\n        return chr(ordchr)\n    else:\n        return '.'\n", "tokens": ["pydicom", "util", "dump", "py", "def", "print_character", "ordchr", "return", "a", "printable", "character", "or", "for", "non", "printable", "ones", "if", "31", "ordchr", "126", "and", "ordchr", "92", "return", "chr", "ordchr", "else", "return"], "doc_len": 28}
{"doc_id": "pydicom/util/dump.py::filedump", "file_path": "pydicom/util/dump.py", "class_name": null, "func_name": "filedump", "text": "文件路径: pydicom/util/dump.py\ndef filedump(filename, start_address=0, stop_address=None):\n    \"\"\"Dump out the contents of a file to a\n       standard hex dump 16 bytes wide\"\"\"\n\n    fp = open(filename, 'rb')\n    return hexdump(fp, start_address, stop_address)\n", "tokens": ["pydicom", "util", "dump", "py", "def", "filedump", "filename", "start_address", "0", "stop_address", "none", "dump", "out", "the", "contents", "of", "a", "file", "to", "a", "standard", "hex", "dump", "16", "bytes", "wide", "fp", "open", "filename", "rb", "return", "hexdump", "fp", "start_address", "stop_address"], "doc_len": 35}
{"doc_id": "pydicom/util/dump.py::datadump", "file_path": "pydicom/util/dump.py", "class_name": null, "func_name": "datadump", "text": "文件路径: pydicom/util/dump.py\ndef datadump(data):\n    stop_address = len(data) + 1\n    fp = BytesIO(data)\n    print(hexdump(fp, 0, stop_address))\n", "tokens": ["pydicom", "util", "dump", "py", "def", "datadump", "data", "stop_address", "len", "data", "1", "fp", "bytesio", "data", "print", "hexdump", "fp", "0", "stop_address"], "doc_len": 19}
{"doc_id": "pydicom/util/dump.py::hexdump", "file_path": "pydicom/util/dump.py", "class_name": null, "func_name": "hexdump", "text": "文件路径: pydicom/util/dump.py\ndef hexdump(file_in, start_address=0, stop_address=None, showAddress=True):\n    \"\"\"Return a formatted string of hex bytes and characters in data.\n\n    This is a utility function for debugging file writing.\n\n    file_in -- a file-like object to get the bytes to show from\"\"\"\n\n    str_out = BytesIO()\n    # space taken up if row has a full 16 bytes\n    byteslen = 16 * 3 - 1\n    blanks = ' ' * byteslen\n\n    file_in.seek(start_address)\n    data = True  # dummy to start the loop\n    while data:\n        if stop_address and file_in.tell() > stop_address:\n            break\n        if showAddress:\n            # address at start of line\n            str_out.write(\"%04x : \" % (file_in.tell()))\n        data = file_in.read(16)\n        if not data:\n            break\n        row = [ord(x) for x in data]  # need ord twice below so convert once\n\n        # string of two digit hex bytes\n        byte_string = ' '.join([\"%02x\" % x for x in row])\n        str_out.write(byte_string)\n\n        # if not 16, pad\n        str_out.write(blanks[:byteslen - len(byte_string)])\n        str_out.write('  ')\n\n        # character rep of bytes\n        str_out.write(''.join([print_character(x) for x in row]))\n        str_out.write(\"\\n\")\n\n    return str_out.getvalue()\n", "tokens": ["pydicom", "util", "dump", "py", "def", "hexdump", "file_in", "start_address", "0", "stop_address", "none", "showaddress", "true", "return", "a", "formatted", "string", "of", "hex", "bytes", "and", "characters", "in", "data", "this", "is", "a", "utility", "function", "for", "debugging", "file", "writing", "file_in", "a", "file", "like", "object", "to", "get", "the", "bytes", "to", "show", "from", "str_out", "bytesio", "space", "taken", "up", "if", "row", "has", "a", "full", "16", "bytes", "byteslen", "16", "3", "1", "blanks", "byteslen", "file_in", "seek", "start_address", "data", "true", "dummy", "to", "start", "the", "loop", "while", "data", "if", "stop_address", "and", "file_in", "tell", "stop_address", "break", "if", "showaddress", "address", "at", "start", "of", "line", "str_out", "write", "04x", "file_in", "tell", "data", "file_in", "read", "16", "if", "not", "data", "break", "row", "ord", "x", "for", "x", "in", "data", "need", "ord", "twice", "below", "so", "convert", "once", "string", "of", "two", "digit", "hex", "bytes", "byte_string", "join", "02x", "x", "for", "x", "in", "row", "str_out", "write", "byte_string", "if", "not", "16", "pad", "str_out", "write", "blanks", "byteslen", "len", "byte_string", "str_out", "write", "character", "rep", "of", "bytes", "str_out", "write", "join", "print_character", "x", "for", "x", "in", "row", "str_out", "write", "n", "return", "str_out", "getvalue"], "doc_len": 164}
{"doc_id": "pydicom/util/dump.py::pretty_print", "file_path": "pydicom/util/dump.py", "class_name": null, "func_name": "pretty_print", "text": "文件路径: pydicom/util/dump.py\ndef pretty_print(ds, indent=0, indent_chars=\"   \"):\n    \"\"\"Print a dataset directly, with indented levels.\n\n    This is just like Dataset._pretty_str, but more useful for debugging as it\n    prints each item immediately rather than composing a string, making it\n    easier to immediately see where an error in processing a dataset starts.\n\n    \"\"\"\n\n    indentStr = indent_chars * indent\n    nextIndentStr = indent_chars * (indent + 1)\n    for data_element in ds:\n        if data_element.VR == \"SQ\":  # a sequence\n            fmt_str = \"{0:s}{1:s} {2:s}  {3:d} item(s) ---\"\n            new_str = fmt_str.format(indentStr,\n                                     str(data_element.tag), data_element.name,\n                                     len(data_element.value))\n            print(new_str)\n            for dataset in data_element.value:\n                pretty_print(dataset, indent + 1)\n                print(nextIndentStr + \"---------\")\n        else:\n            print(indentStr + repr(data_element))\n", "tokens": ["pydicom", "util", "dump", "py", "def", "pretty_print", "ds", "indent", "0", "indent_chars", "print", "a", "dataset", "directly", "with", "indented", "levels", "this", "is", "just", "like", "dataset", "_pretty_str", "but", "more", "useful", "for", "debugging", "as", "it", "prints", "each", "item", "immediately", "rather", "than", "composing", "a", "string", "making", "it", "easier", "to", "immediately", "see", "where", "an", "error", "in", "processing", "a", "dataset", "starts", "indentstr", "indent_chars", "indent", "nextindentstr", "indent_chars", "indent", "1", "for", "data_element", "in", "ds", "if", "data_element", "vr", "sq", "a", "sequence", "fmt_str", "0", "s", "1", "s", "2", "s", "3", "d", "item", "s", "new_str", "fmt_str", "format", "indentstr", "str", "data_element", "tag", "data_element", "name", "len", "data_element", "value", "print", "new_str", "for", "dataset", "in", "data_element", "value", "pretty_print", "dataset", "indent", "1", "print", "nextindentstr", "else", "print", "indentstr", "repr", "data_element"], "doc_len": 111}
{"doc_id": "pydicom/util/fixer.py::fix_separator_callback", "file_path": "pydicom/util/fixer.py", "class_name": null, "func_name": "fix_separator_callback", "text": "文件路径: pydicom/util/fixer.py\ndef fix_separator_callback(raw_elem, **kwargs):\n    \"\"\"Used by fix_separator as the callback function from read_dataset\n    \"\"\"\n    return_val = raw_elem\n    try_replace = False\n\n    # If elements are implicit VR, attempt to determine the VR\n    if raw_elem.VR is None:\n        try:\n            VR = datadict.dictionary_VR(raw_elem.tag)\n        # Not in the dictionary, process if flag says to do so\n        except KeyError:\n            try_replace = kwargs['process_unkown_VR']\n        else:\n            try_replace = VR in kwargs['for_VRs']\n    else:\n        try_replace = raw_elem.VR in kwargs['for_VRs']\n\n    if try_replace:\n        # Note value has not been decoded yet when this function called,\n        #    so need to replace backslash as bytes\n        new_value = raw_elem.value.replace(kwargs['invalid_separator'], b\"\\\\\")\n        return_val = raw_elem._replace(value=new_value)\n\n    return return_val\n", "tokens": ["pydicom", "util", "fixer", "py", "def", "fix_separator_callback", "raw_elem", "kwargs", "used", "by", "fix_separator", "as", "the", "callback", "function", "from", "read_dataset", "return_val", "raw_elem", "try_replace", "false", "if", "elements", "are", "implicit", "vr", "attempt", "to", "determine", "the", "vr", "if", "raw_elem", "vr", "is", "none", "try", "vr", "datadict", "dictionary_vr", "raw_elem", "tag", "not", "in", "the", "dictionary", "process", "if", "flag", "says", "to", "do", "so", "except", "keyerror", "try_replace", "kwargs", "process_unkown_vr", "else", "try_replace", "vr", "in", "kwargs", "for_vrs", "else", "try_replace", "raw_elem", "vr", "in", "kwargs", "for_vrs", "if", "try_replace", "note", "value", "has", "not", "been", "decoded", "yet", "when", "this", "function", "called", "so", "need", "to", "replace", "backslash", "as", "bytes", "new_value", "raw_elem", "value", "replace", "kwargs", "invalid_separator", "b", "return_val", "raw_elem", "_replace", "value", "new_value", "return", "return_val"], "doc_len": 105}
{"doc_id": "pydicom/util/fixer.py::fix_separator", "file_path": "pydicom/util/fixer.py", "class_name": null, "func_name": "fix_separator", "text": "文件路径: pydicom/util/fixer.py\ndef fix_separator(invalid_separator,\n                  for_VRs=[\"DS\", \"IS\"],\n                  process_unknown_VRs=True):\n    \"\"\"A callback function to fix RawDataElement values using\n    some other separator than the dicom standard backslash character\n\n    Parameters\n    ----------\n    invalid_separator : bytes\n        A single byte to replace with dicom backslash, in raw data element\n        values before they have been decoded or processed by pydicom\n    for_VRs : list, optional\n        A list of VRs for which the replacement will be done.\n        If the VR is unknown (for example, if a private element),\n        then process_unknown_VR is used to determine whether to replace or not.\n    process_unknown_VRs: boolean, optional\n        If True (default) then attempt the fix even if the VR is not known.\n\n    Returns\n    -------\n    No return value.  However, the callback function will return either\n    the original RawDataElement instance, or a fixed one.\n    \"\"\"\n    config.data_element_callback = fix_separator_callback\n    config.data_element_callback_kwargs = {\n        'invalid_separator': invalid_separator,\n        'for_VRs': for_VRs\n    }\n", "tokens": ["pydicom", "util", "fixer", "py", "def", "fix_separator", "invalid_separator", "for_vrs", "ds", "is", "process_unknown_vrs", "true", "a", "callback", "function", "to", "fix", "rawdataelement", "values", "using", "some", "other", "separator", "than", "the", "dicom", "standard", "backslash", "character", "parameters", "invalid_separator", "bytes", "a", "single", "byte", "to", "replace", "with", "dicom", "backslash", "in", "raw", "data", "element", "values", "before", "they", "have", "been", "decoded", "or", "processed", "by", "pydicom", "for_vrs", "list", "optional", "a", "list", "of", "vrs", "for", "which", "the", "replacement", "will", "be", "done", "if", "the", "vr", "is", "unknown", "for", "example", "if", "a", "private", "element", "then", "process_unknown_vr", "is", "used", "to", "determine", "whether", "to", "replace", "or", "not", "process_unknown_vrs", "boolean", "optional", "if", "true", "default", "then", "attempt", "the", "fix", "even", "if", "the", "vr", "is", "not", "known", "returns", "no", "return", "value", "however", "the", "callback", "function", "will", "return", "either", "the", "original", "rawdataelement", "instance", "or", "a", "fixed", "one", "config", "data_element_callback", "fix_separator_callback", "config", "data_element_callback_kwargs", "invalid_separator", "invalid_separator", "for_vrs", "for_vrs"], "doc_len": 135}
{"doc_id": "pydicom/util/fixer.py::fix_mismatch_callback", "file_path": "pydicom/util/fixer.py", "class_name": null, "func_name": "fix_mismatch_callback", "text": "文件路径: pydicom/util/fixer.py\ndef fix_mismatch_callback(raw_elem, **kwargs):\n    try:\n        values.convert_value(raw_elem.VR, raw_elem)\n    except ValueError:\n        for vr in kwargs['with_VRs']:\n            try:\n                values.convert_value(vr, raw_elem)\n            except ValueError:\n                pass\n            else:\n                raw_elem = raw_elem._replace(VR=vr)\n    return raw_elem\n", "tokens": ["pydicom", "util", "fixer", "py", "def", "fix_mismatch_callback", "raw_elem", "kwargs", "try", "values", "convert_value", "raw_elem", "vr", "raw_elem", "except", "valueerror", "for", "vr", "in", "kwargs", "with_vrs", "try", "values", "convert_value", "vr", "raw_elem", "except", "valueerror", "pass", "else", "raw_elem", "raw_elem", "_replace", "vr", "vr", "return", "raw_elem"], "doc_len": 37}
{"doc_id": "pydicom/util/fixer.py::fix_mismatch", "file_path": "pydicom/util/fixer.py", "class_name": null, "func_name": "fix_mismatch", "text": "文件路径: pydicom/util/fixer.py\ndef fix_mismatch(with_VRs=['PN', 'DS', 'IS']):\n    \"\"\"A callback function to check that RawDataElements are translatable\n    with their provided VRs.  If not, re-attempt translation using\n    some other translators.\n\n    Parameters\n    ----------\n    with_VRs : list, [['PN', 'DS', 'IS']]\n        A list of VR strings to attempt if the raw data element value cannot\n        be translated with the raw data element's VR.\n\n    Returns\n    -------\n    No return value.  The callback function will return either\n    the original RawDataElement instance, or one with a fixed VR.\n    \"\"\"\n    config.data_element_callback = fix_mismatch_callback\n    config.data_element_callback_kwargs = {\n        'with_VRs': with_VRs,\n    }\n", "tokens": ["pydicom", "util", "fixer", "py", "def", "fix_mismatch", "with_vrs", "pn", "ds", "is", "a", "callback", "function", "to", "check", "that", "rawdataelements", "are", "translatable", "with", "their", "provided", "vrs", "if", "not", "re", "attempt", "translation", "using", "some", "other", "translators", "parameters", "with_vrs", "list", "pn", "ds", "is", "a", "list", "of", "vr", "strings", "to", "attempt", "if", "the", "raw", "data", "element", "value", "cannot", "be", "translated", "with", "the", "raw", "data", "element", "s", "vr", "returns", "no", "return", "value", "the", "callback", "function", "will", "return", "either", "the", "original", "rawdataelement", "instance", "or", "one", "with", "a", "fixed", "vr", "config", "data_element_callback", "fix_mismatch_callback", "config", "data_element_callback_kwargs", "with_vrs", "with_vrs"], "doc_len": 88}
{"doc_id": "pydicom/util/hexutil.py::hex2bytes", "file_path": "pydicom/util/hexutil.py", "class_name": null, "func_name": "hex2bytes", "text": "文件路径: pydicom/util/hexutil.py\ndef hex2bytes(hexstring):\n    \"\"\"Return bytestring for a string of hex bytes separated by whitespace\n\n    This is useful for creating specific byte sequences for testing, using\n    python's implied concatenation for strings with comments allowed.\n    Example:\n        hex_string = (\n         \"08 00 32 10\"     # (0008, 1032) SQ \"Procedure Code Sequence\"\n         \" 08 00 00 00\"    # length 8\n         \" fe ff 00 e0\"    # (fffe, e000) Item Tag\n        )\n        byte_string = hex2bytes(hex_string)\n    Note in the example that all lines except the first must\n    start with a space, alternatively the space could\n    end the previous line.\n    \"\"\"\n\n    # This works in both 3.x and 2.x because the first conditional evaluates to\n    # true in 2.x so the difference in bytes constructor doesn't matter\n    if isinstance(hexstring, bytes):\n        return a2b_hex(hexstring.replace(b\" \", b\"\"))\n    elif isinstance(hexstring, compat.string_types):\n        return a2b_hex(bytes(hexstring.replace(\" \", \"\"), default_encoding))\n    raise TypeError('argument shall be bytes or string type')\n", "tokens": ["pydicom", "util", "hexutil", "py", "def", "hex2bytes", "hexstring", "return", "bytestring", "for", "a", "string", "of", "hex", "bytes", "separated", "by", "whitespace", "this", "is", "useful", "for", "creating", "specific", "byte", "sequences", "for", "testing", "using", "python", "s", "implied", "concatenation", "for", "strings", "with", "comments", "allowed", "example", "hex_string", "08", "00", "32", "10", "0008", "1032", "sq", "procedure", "code", "sequence", "08", "00", "00", "00", "length", "8", "fe", "ff", "00", "e0", "fffe", "e000", "item", "tag", "byte_string", "hex2bytes", "hex_string", "note", "in", "the", "example", "that", "all", "lines", "except", "the", "first", "must", "start", "with", "a", "space", "alternatively", "the", "space", "could", "end", "the", "previous", "line", "this", "works", "in", "both", "3", "x", "and", "2", "x", "because", "the", "first", "conditional", "evaluates", "to", "true", "in", "2", "x", "so", "the", "difference", "in", "bytes", "constructor", "doesn", "t", "matter", "if", "isinstance", "hexstring", "bytes", "return", "a2b_hex", "hexstring", "replace", "b", "b", "elif", "isinstance", "hexstring", "compat", "string_types", "return", "a2b_hex", "bytes", "hexstring", "replace", "default_encoding", "raise", "typeerror", "argument", "shall", "be", "bytes", "or", "string", "type"], "doc_len": 148}
{"doc_id": "pydicom/util/hexutil.py::bytes2hex", "file_path": "pydicom/util/hexutil.py", "class_name": null, "func_name": "bytes2hex", "text": "文件路径: pydicom/util/hexutil.py\ndef bytes2hex(byte_string):\n    s = b2a_hex(byte_string)\n    if not in_py2:\n        s = s.decode()\n    return \" \".join(s[i:i + 2] for i in range(0, len(s), 2))\n", "tokens": ["pydicom", "util", "hexutil", "py", "def", "bytes2hex", "byte_string", "s", "b2a_hex", "byte_string", "if", "not", "in_py2", "s", "s", "decode", "return", "join", "s", "i", "i", "2", "for", "i", "in", "range", "0", "len", "s", "2"], "doc_len": 30}
{"doc_id": "pydicom/util/leanread.py::dicomfile.__init__", "file_path": "pydicom/util/leanread.py", "class_name": "dicomfile", "func_name": "__init__", "text": "文件路径: pydicom/util/leanread.py, 类名: dicomfile\n    def __init__(self, filename):\n        self.fobj = fobj = open(filename, \"rb\")\n\n        # Read the DICOM preamble, if present\n        self.preamble = fobj.read(0x80)\n        dicom_prefix = fobj.read(4)\n        if dicom_prefix != b\"DICM\":\n            self.preamble = None\n            fobj.seek(0)\n", "tokens": ["pydicom", "util", "leanread", "py", "dicomfile", "def", "__init__", "self", "filename", "self", "fobj", "fobj", "open", "filename", "rb", "read", "the", "dicom", "preamble", "if", "present", "self", "preamble", "fobj", "read", "0x80", "dicom_prefix", "fobj", "read", "4", "if", "dicom_prefix", "b", "dicm", "self", "preamble", "none", "fobj", "seek", "0"], "doc_len": 40}
{"doc_id": "pydicom/util/leanread.py::dicomfile.__enter__", "file_path": "pydicom/util/leanread.py", "class_name": "dicomfile", "func_name": "__enter__", "text": "文件路径: pydicom/util/leanread.py, 类名: dicomfile\n    def __enter__(self):\n        return self\n", "tokens": ["pydicom", "util", "leanread", "py", "dicomfile", "def", "__enter__", "self", "return", "self"], "doc_len": 10}
{"doc_id": "pydicom/util/leanread.py::dicomfile.__exit__", "file_path": "pydicom/util/leanread.py", "class_name": "dicomfile", "func_name": "__exit__", "text": "文件路径: pydicom/util/leanread.py, 类名: dicomfile\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.fobj.close()\n", "tokens": ["pydicom", "util", "leanread", "py", "dicomfile", "def", "__exit__", "self", "exc_type", "exc_value", "traceback", "self", "fobj", "close"], "doc_len": 14}
{"doc_id": "pydicom/util/leanread.py::dicomfile.__iter__", "file_path": "pydicom/util/leanread.py", "class_name": "dicomfile", "func_name": "__iter__", "text": "文件路径: pydicom/util/leanread.py, 类名: dicomfile\n    def __iter__(self):\n        # Need the transfer_syntax later\n        transfer_syntax_uid = None\n\n        # Yield the file meta info elements\n        file_meta_gen = data_element_generator(\n            self.fobj,\n            is_implicit_VR=False,\n            is_little_endian=True,\n            stop_when=lambda gp, elem: gp != 2)\n        for data_elem in file_meta_gen:\n            if data_elem[0] == (0x0002, 0x0010):\n                transfer_syntax_uid = data_elem[3]\n            yield data_elem\n\n        # Continue to yield elements from the main data\n        if transfer_syntax_uid:\n            if transfer_syntax_uid.endswith(b' ') or \\\n                    transfer_syntax_uid.endswith(b'\\0'):\n                transfer_syntax_uid = transfer_syntax_uid[:-1]\n            is_implicit_VR, is_little_endian = transfer_syntax(\n                transfer_syntax_uid)\n            # print is_implicit_VR\n        else:\n            raise NotImplementedError(\"No transfer syntax in file meta info\")\n\n        ds_gen = data_element_generator(self.fobj, is_implicit_VR,\n                                        is_little_endian)\n        for data_elem in ds_gen:\n            yield data_elem\n\n        raise StopIteration\n", "tokens": ["pydicom", "util", "leanread", "py", "dicomfile", "def", "__iter__", "self", "need", "the", "transfer_syntax", "later", "transfer_syntax_uid", "none", "yield", "the", "file", "meta", "info", "elements", "file_meta_gen", "data_element_generator", "self", "fobj", "is_implicit_vr", "false", "is_little_endian", "true", "stop_when", "lambda", "gp", "elem", "gp", "2", "for", "data_elem", "in", "file_meta_gen", "if", "data_elem", "0", "0x0002", "0x0010", "transfer_syntax_uid", "data_elem", "3", "yield", "data_elem", "continue", "to", "yield", "elements", "from", "the", "main", "data", "if", "transfer_syntax_uid", "if", "transfer_syntax_uid", "endswith", "b", "or", "transfer_syntax_uid", "endswith", "b", "0", "transfer_syntax_uid", "transfer_syntax_uid", "1", "is_implicit_vr", "is_little_endian", "transfer_syntax", "transfer_syntax_uid", "print", "is_implicit_vr", "else", "raise", "notimplementederror", "no", "transfer", "syntax", "in", "file", "meta", "info", "ds_gen", "data_element_generator", "self", "fobj", "is_implicit_vr", "is_little_endian", "for", "data_elem", "in", "ds_gen", "yield", "data_elem", "raise", "stopiteration"], "doc_len": 100}
{"doc_id": "pydicom/util/leanread.py::transfer_syntax", "file_path": "pydicom/util/leanread.py", "class_name": null, "func_name": "transfer_syntax", "text": "文件路径: pydicom/util/leanread.py\ndef transfer_syntax(uid):\n    \"\"\"Parse the transfer syntax\n    :return: is_implicit_VR, is_little_endian\n    \"\"\"\n    # Assume a transfer syntax, correct it as necessary\n    is_implicit_VR = True\n    is_little_endian = True\n    if uid == ImplicitVRLittleEndian:\n        pass\n    elif uid == ExplicitVRLittleEndian:\n        is_implicit_VR = False\n    elif uid == ExplicitVRBigEndian:\n        is_implicit_VR = False\n        is_little_endian = False\n    elif uid == DeflatedExplicitVRLittleEndian:\n        raise NotImplementedError(\"This reader does not handle deflate files\")\n    else:\n        # PS 3.5-2008 A.4 (p63): other syntax (e.g all compressed)\n        #    should be Explicit VR Little Endian,\n        is_implicit_VR = False\n    return is_implicit_VR, is_little_endian\n", "tokens": ["pydicom", "util", "leanread", "py", "def", "transfer_syntax", "uid", "parse", "the", "transfer", "syntax", "return", "is_implicit_vr", "is_little_endian", "assume", "a", "transfer", "syntax", "correct", "it", "as", "necessary", "is_implicit_vr", "true", "is_little_endian", "true", "if", "uid", "implicitvrlittleendian", "pass", "elif", "uid", "explicitvrlittleendian", "is_implicit_vr", "false", "elif", "uid", "explicitvrbigendian", "is_implicit_vr", "false", "is_little_endian", "false", "elif", "uid", "deflatedexplicitvrlittleendian", "raise", "notimplementederror", "this", "reader", "does", "not", "handle", "deflate", "files", "else", "ps", "3", "5", "2008", "a", "4", "p63", "other", "syntax", "e", "g", "all", "compressed", "should", "be", "explicit", "vr", "little", "endian", "is_implicit_vr", "false", "return", "is_implicit_vr", "is_little_endian"], "doc_len": 79}
{"doc_id": "pydicom/util/leanread.py::data_element_generator", "file_path": "pydicom/util/leanread.py", "class_name": null, "func_name": "data_element_generator", "text": "文件路径: pydicom/util/leanread.py\ndef data_element_generator(fp,\n                           is_implicit_VR,\n                           is_little_endian,\n                           stop_when=None,\n                           defer_size=None):\n    \"\"\":return: (tag, VR, length, value, value_tell,\n                                 is_implicit_VR, is_little_endian)\n    \"\"\"\n    if is_little_endian:\n        endian_chr = \"<\"\n    else:\n        endian_chr = \">\"\n    if is_implicit_VR:\n        element_struct = Struct(endian_chr + \"HHL\")\n    else:  # Explicit VR\n        # tag, VR, 2-byte length (or 0 if special VRs)\n        element_struct = Struct(endian_chr + \"HH2sH\")\n        extra_length_struct = Struct(endian_chr + \"L\")  # for special VRs\n        extra_length_unpack = extra_length_struct.unpack  # for lookup speed\n\n    # Make local variables so have faster lookup\n    fp_read = fp.read\n    fp_tell = fp.tell\n    element_struct_unpack = element_struct.unpack\n    defer_size = size_in_bytes(defer_size)\n\n    while True:\n        # Read tag, VR, length, get ready to read value\n        bytes_read = fp_read(8)\n        if len(bytes_read) < 8:\n            raise StopIteration  # at end of file\n\n        if is_implicit_VR:\n            # must reset VR each time; could have set last iteration (e.g. SQ)\n            VR = None\n            group, elem, length = element_struct_unpack(bytes_read)\n        else:  # explicit VR\n            group, elem, VR, length = element_struct_unpack(bytes_read)\n            if VR in extra_length_VRs_b:\n                bytes_read = fp_read(4)\n                length = extra_length_unpack(bytes_read)[0]\n\n        # Positioned to read the value, but may not want to -- check stop_when\n        value_tell = fp_tell()\n        if stop_when is not None:\n            if stop_when(group, elem):\n                rewind_length = 8\n                if not is_implicit_VR and VR in extra_length_VRs_b:\n                    rewind_length += 4\n                fp.seek(value_tell - rewind_length)\n                raise StopIteration\n\n        # Reading the value\n        # First case (most common): reading a value with a defined length\n        if length != 0xFFFFFFFF:\n            if defer_size is not None and length > defer_size:\n                # Flag as deferred by setting value to None, and skip bytes\n                value = None\n                fp.seek(fp_tell() + length)\n            else:\n                value = fp_read(length)\n            # import pdb;pdb.set_trace()\n            yield ((group, elem), VR, length, value, value_tell)\n\n        # Second case: undefined length - must seek to delimiter,\n        # unless is SQ type, in which case is easier to parse it, because\n        # undefined length SQs and items of undefined lengths can be nested\n        # and it would be error-prone to read to the correct outer delimiter\n        else:\n            # Try to look up type to see if is a SQ\n            # if private tag, won't be able to look it up in dictionary,\n            #   in which case just ignore it and read the bytes unless it is\n            #   identified as a Sequence\n            if VR is None:\n                try:\n                    VR = dictionary_VR(tag)\n                except KeyError:\n                    # Look ahead to see if it consists of items and\n                    # is thus a SQ\n                    next_tag = TupleTag(unpack(endian_chr + \"HH\", fp_read(4)))\n                    # Rewind the file\n                    fp.seek(fp_tell() - 4)\n                    if next_tag == ItemTag:\n                        VR = b'SQ'\n\n            if VR == b'SQ':\n                yield ((group, elem), VR, length, None, value_tell)\n                # seq = read_sequence(fp, is_implicit_VR,\n                #                     is_little_endian, length, encoding)\n                # yield DataElement(tag, VR, seq, value_tell,\n                #                   is_undefined_length=True)\n            else:\n                raise NotImplementedError(\"This reader does not handle \"\n                                          \"undefined length except for SQ\")\n                from pydicom.fileio.fileutil import read_undefined_length_value\n\n                delimiter = SequenceDelimiterTag\n                value = read_undefined_length_value(fp, is_little_endian,\n                                                    delimiter, defer_size)\n                yield ((group, elem), VR, length, value, value_tell)\n", "tokens": ["pydicom", "util", "leanread", "py", "def", "data_element_generator", "fp", "is_implicit_vr", "is_little_endian", "stop_when", "none", "defer_size", "none", "return", "tag", "vr", "length", "value", "value_tell", "is_implicit_vr", "is_little_endian", "if", "is_little_endian", "endian_chr", "else", "endian_chr", "if", "is_implicit_vr", "element_struct", "struct", "endian_chr", "hhl", "else", "explicit", "vr", "tag", "vr", "2", "byte", "length", "or", "0", "if", "special", "vrs", "element_struct", "struct", "endian_chr", "hh2sh", "extra_length_struct", "struct", "endian_chr", "l", "for", "special", "vrs", "extra_length_unpack", "extra_length_struct", "unpack", "for", "lookup", "speed", "make", "local", "variables", "so", "have", "faster", "lookup", "fp_read", "fp", "read", "fp_tell", "fp", "tell", "element_struct_unpack", "element_struct", "unpack", "defer_size", "size_in_bytes", "defer_size", "while", "true", "read", "tag", "vr", "length", "get", "ready", "to", "read", "value", "bytes_read", "fp_read", "8", "if", "len", "bytes_read", "8", "raise", "stopiteration", "at", "end", "of", "file", "if", "is_implicit_vr", "must", "reset", "vr", "each", "time", "could", "have", "set", "last", "iteration", "e", "g", "sq", "vr", "none", "group", "elem", "length", "element_struct_unpack", "bytes_read", "else", "explicit", "vr", "group", "elem", "vr", "length", "element_struct_unpack", "bytes_read", "if", "vr", "in", "extra_length_vrs_b", "bytes_read", "fp_read", "4", "length", "extra_length_unpack", "bytes_read", "0", "positioned", "to", "read", "the", "value", "but", "may", "not", "want", "to", "check", "stop_when", "value_tell", "fp_tell", "if", "stop_when", "is", "not", "none", "if", "stop_when", "group", "elem", "rewind_length", "8", "if", "not", "is_implicit_vr", "and", "vr", "in", "extra_length_vrs_b", "rewind_length", "4", "fp", "seek", "value_tell", "rewind_length", "raise", "stopiteration", "reading", "the", "value", "first", "case", "most", "common", "reading", "a", "value", "with", "a", "defined", "length", "if", "length", "0xffffffff", "if", "defer_size", "is", "not", "none", "and", "length", "defer_size", "flag", "as", "deferred", "by", "setting", "value", "to", "none", "and", "skip", "bytes", "value", "none", "fp", "seek", "fp_tell", "length", "else", "value", "fp_read", "length", "import", "pdb", "pdb", "set_trace", "yield", "group", "elem", "vr", "length", "value", "value_tell", "second", "case", "undefined", "length", "must", "seek", "to", "delimiter", "unless", "is", "sq", "type", "in", "which", "case", "is", "easier", "to", "parse", "it", "because", "undefined", "length", "sqs", "and", "items", "of", "undefined", "lengths", "can", "be", "nested", "and", "it", "would", "be", "error", "prone", "to", "read", "to", "the", "correct", "outer", "delimiter", "else", "try", "to", "look", "up", "type", "to", "see", "if", "is", "a", "sq", "if", "private", "tag", "won", "t", "be", "able", "to", "look", "it", "up", "in", "dictionary", "in", "which", "case", "just", "ignore", "it", "and", "read", "the", "bytes", "unless", "it", "is", "identified", "as", "a", "sequence", "if", "vr", "is", "none", "try", "vr", "dictionary_vr", "tag", "except", "keyerror", "look", "ahead", "to", "see", "if", "it", "consists", "of", "items", "and", "is", "thus", "a", "sq", "next_tag", "tupletag", "unpack", "endian_chr", "hh", "fp_read", "4", "rewind", "the", "file", "fp", "seek", "fp_tell", "4", "if", "next_tag", "itemtag", "vr", "b", "sq", "if", "vr", "b", "sq", "yield", "group", "elem", "vr", "length", "none", "value_tell", "seq", "read_sequence", "fp", "is_implicit_vr", "is_little_endian", "length", "encoding", "yield", "dataelement", "tag", "vr", "seq", "value_tell", "is_undefined_length", "true", "else", "raise", "notimplementederror", "this", "reader", "does", "not", "handle", "undefined", "length", "except", "for", "sq", "from", "pydicom", "fileio", "fileutil", "import", "read_undefined_length_value", "delimiter", "sequencedelimitertag", "value", "read_undefined_length_value", "fp", "is_little_endian", "delimiter", "defer_size", "yield", "group", "elem", "vr", "length", "value", "value_tell"], "doc_len": 435}
{"doc_id": "source/generate_dict/generate_dicom_dict.py::write_dict", "file_path": "source/generate_dict/generate_dicom_dict.py", "class_name": null, "func_name": "write_dict", "text": "文件路径: source/generate_dict/generate_dicom_dict.py\ndef write_dict(fp, dict_name, attributes, tag_is_string):\n    \"\"\"Write the `dict_name` dict to file `fp`.\n\n    Parameters\n    ----------\n    fp : file\n        The file to write the dict to.\n    dict_name : str\n        The name of the dict variable.\n    attributes : list of str\n        List of attributes of the dict entries.\n    tag_is_string : bool\n        If the tag is a string (as it is for the RepeatersDictionary)\n    \"\"\"\n    tag_content = \"\"\"('{VR}', '{VM}', \"{Name}\", '{Retired}', '{Keyword}')\"\"\"\n    if tag_is_string:\n        entry_format = \"'{Tag}': %s\" % (tag_content)\n    else:\n        entry_format = \"{Tag}: %s\" % (tag_content)\n\n    fp.write(\"\\n%s = {\\n    \" % dict_name)\n    fp.write(\",  # noqa\\n    \".join(entry_format.format(**attr)\n                                    for attr in attributes))\n    fp.write(\"  # noqa\\n}\\n\")\n", "tokens": ["source", "generate_dict", "generate_dicom_dict", "py", "def", "write_dict", "fp", "dict_name", "attributes", "tag_is_string", "write", "the", "dict_name", "dict", "to", "file", "fp", "parameters", "fp", "file", "the", "file", "to", "write", "the", "dict", "to", "dict_name", "str", "the", "name", "of", "the", "dict", "variable", "attributes", "list", "of", "str", "list", "of", "attributes", "of", "the", "dict", "entries", "tag_is_string", "bool", "if", "the", "tag", "is", "a", "string", "as", "it", "is", "for", "the", "repeatersdictionary", "tag_content", "vr", "vm", "name", "retired", "keyword", "if", "tag_is_string", "entry_format", "tag", "s", "tag_content", "else", "entry_format", "tag", "s", "tag_content", "fp", "write", "n", "s", "n", "dict_name", "fp", "write", "noqa", "n", "join", "entry_format", "format", "attr", "for", "attr", "in", "attributes", "fp", "write", "noqa", "n", "n"], "doc_len": 100}
{"doc_id": "source/generate_dict/generate_dicom_dict.py::parse_docbook_table", "file_path": "source/generate_dict/generate_dicom_dict.py", "class_name": null, "func_name": "parse_docbook_table", "text": "文件路径: source/generate_dict/generate_dicom_dict.py\ndef parse_docbook_table(book_root, caption):\n    \"\"\"Parses the XML `book_root` for the table with `caption`.\n\n    Parameters\n    ----------\n    book_root\n        The XML book root\n    caption : str\n        The caption of the table to parse\n\n    Returns\n    -------\n    row_attrs : list of dict\n        A list of the Element dicts generated by parsing the table.\n    \"\"\"\n    br = '{http://docbook.org/ns/docbook}'  # Shorthand variable\n\n    for table in book_root.iter('%stable' % br):\n        # Find the table in book_root with caption\n        if table.find('%scaption' % br).text == caption:\n\n            def parse_header(header_row):\n                \"\"\"Parses the table's thead/tr row, header_row, for the column\n                headers\n\n                The header_row should be <thead><tr>...</tr></thead>\n                Which leaves the following:\n                    <th><para><emphasis>Header 1</emphasis></para></th>\n                    <th><para><emphasis>Header 2</emphasis></para></th>\n                    etc...\n                Note that for the part06 tables the last col header\n                (Retired) is:\n                    <th><para/></th>\n\n                Parameters\n                ----------\n                header_row\n                    The XML for the header row of the table\n\n                Returns\n                -------\n                field_names : list of str\n                    A list of the field header names used in the table\n                \"\"\"\n                field_names = []\n                for x in header_row.iter('%sth' % br):\n                    # If there is an emphasis tag under the para tag then its\n                    #   text is the column header\n                    if x.find('%spara' % br).find('%semphasis' % br) is not None:  # noqa\n                        col_label = x.find('%spara' % br).find('%semphasis' % br).text  # noqa\n                        field_names.append(col_label)\n\n                    # If there isn't an emphasis tag under the para tag then it\n                    #   must be the Retired header\n                    else:\n                        field_names.append(\"Retired\")\n\n                return field_names\n\n            # Get the column headers\n            element = table.find('%sthead' % br).find('%str' % br)\n            field_names = parse_header(element)\n\n            def parse_row(field_names, row):\n                \"\"\"Parses the table's tbody tr row, row, for the Element data.\n\n                The row should be <tbody><tr>...</tr></tbody>\n                Which leaves the following:\n                    <td><para>Value 1</para></td>\n                    <td><para>Value 2</para></td>\n                    etc...\n                Some rows are\n                    <td><para><emphasis>Value 1</emphasis></para></td>\n                    <td><para><emphasis>Value 2</emphasis></para></td>\n                    etc...\n                There are also some without text values\n                    <td><para/></td>\n                    <td><para><emphasis/></para></td>\n\n                Parameters\n                ----------\n                field_names : list of str\n                    The field header names\n                row\n                    The XML for the row to parse\n\n                Returns\n                -------\n                dict\n                    {header1 : val1, header2 : val2, ...} representing the\n                    information for the row.\n                \"\"\"\n                cell_values = []\n                for cell in row.iter('%spara' % (br)):\n                    # If we have an emphasis tag under the para tag\n                    emph_value = cell.find('%semphasis' % (br))\n                    if emph_value is not None:\n                        # If there is a text value add it, otherwise add \"\"\n                        if emph_value.text is not None:\n                            # 200b is a zero width space\n                            cell_values.append(emph_value.text.strip()\n                                               .replace(u\"\\u200b\", \"\"))\n                        else:\n                            cell_values.append(\"\")\n\n                    # Otherwise just grab the para tag text\n                    else:\n                        if cell.text is not None:\n                            cell_values.append(cell.text.strip()\n                                               .replace(u\"\\u200b\", \"\"))\n                        else:\n                            cell_values.append(\"\")\n\n                return {key: value for key, value in zip(field_names,\n                                                         cell_values)}\n\n            # Get all the Element data from the table\n            row_attrs = [parse_row(field_names, row)\n                         for row in table.find('%stbody' % br)\n                         .iter('%str' % br)]\n            return row_attrs\n", "tokens": ["source", "generate_dict", "generate_dicom_dict", "py", "def", "parse_docbook_table", "book_root", "caption", "parses", "the", "xml", "book_root", "for", "the", "table", "with", "caption", "parameters", "book_root", "the", "xml", "book", "root", "caption", "str", "the", "caption", "of", "the", "table", "to", "parse", "returns", "row_attrs", "list", "of", "dict", "a", "list", "of", "the", "element", "dicts", "generated", "by", "parsing", "the", "table", "br", "http", "docbook", "org", "ns", "docbook", "shorthand", "variable", "for", "table", "in", "book_root", "iter", "stable", "br", "find", "the", "table", "in", "book_root", "with", "caption", "if", "table", "find", "scaption", "br", "text", "caption", "def", "parse_header", "header_row", "parses", "the", "table", "s", "thead", "tr", "row", "header_row", "for", "the", "column", "headers", "the", "header_row", "should", "be", "thead", "tr", "tr", "thead", "which", "leaves", "the", "following", "th", "para", "emphasis", "header", "1", "emphasis", "para", "th", "th", "para", "emphasis", "header", "2", "emphasis", "para", "th", "etc", "note", "that", "for", "the", "part06", "tables", "the", "last", "col", "header", "retired", "is", "th", "para", "th", "parameters", "header_row", "the", "xml", "for", "the", "header", "row", "of", "the", "table", "returns", "field_names", "list", "of", "str", "a", "list", "of", "the", "field", "header", "names", "used", "in", "the", "table", "field_names", "for", "x", "in", "header_row", "iter", "sth", "br", "if", "there", "is", "an", "emphasis", "tag", "under", "the", "para", "tag", "then", "its", "text", "is", "the", "column", "header", "if", "x", "find", "spara", "br", "find", "semphasis", "br", "is", "not", "none", "noqa", "col_label", "x", "find", "spara", "br", "find", "semphasis", "br", "text", "noqa", "field_names", "append", "col_label", "if", "there", "isn", "t", "an", "emphasis", "tag", "under", "the", "para", "tag", "then", "it", "must", "be", "the", "retired", "header", "else", "field_names", "append", "retired", "return", "field_names", "get", "the", "column", "headers", "element", "table", "find", "sthead", "br", "find", "str", "br", "field_names", "parse_header", "element", "def", "parse_row", "field_names", "row", "parses", "the", "table", "s", "tbody", "tr", "row", "row", "for", "the", "element", "data", "the", "row", "should", "be", "tbody", "tr", "tr", "tbody", "which", "leaves", "the", "following", "td", "para", "value", "1", "para", "td", "td", "para", "value", "2", "para", "td", "etc", "some", "rows", "are", "td", "para", "emphasis", "value", "1", "emphasis", "para", "td", "td", "para", "emphasis", "value", "2", "emphasis", "para", "td", "etc", "there", "are", "also", "some", "without", "text", "values", "td", "para", "td", "td", "para", "emphasis", "para", "td", "parameters", "field_names", "list", "of", "str", "the", "field", "header", "names", "row", "the", "xml", "for", "the", "row", "to", "parse", "returns", "dict", "header1", "val1", "header2", "val2", "representing", "the", "information", "for", "the", "row", "cell_values", "for", "cell", "in", "row", "iter", "spara", "br", "if", "we", "have", "an", "emphasis", "tag", "under", "the", "para", "tag", "emph_value", "cell", "find", "semphasis", "br", "if", "emph_value", "is", "not", "none", "if", "there", "is", "a", "text", "value", "add", "it", "otherwise", "add", "if", "emph_value", "text", "is", "not", "none", "200b", "is", "a", "zero", "width", "space", "cell_values", "append", "emph_value", "text", "strip", "replace", "u", "u200b", "else", "cell_values", "append", "otherwise", "just", "grab", "the", "para", "tag", "text", "else", "if", "cell", "text", "is", "not", "none", "cell_values", "append", "cell", "text", "strip", "replace", "u", "u200b", "else", "cell_values", "append", "return", "key", "value", "for", "key", "value", "in", "zip", "field_names", "cell_values", "get", "all", "the", "element", "data", "from", "the", "table", "row_attrs", "parse_row", "field_names", "row", "for", "row", "in", "table", "find", "stbody", "br", "iter", "str", "br", "return", "row_attrs"], "doc_len": 477}
{"doc_id": "source/generate_dict/generate_private_dict.py::parse_private_docbook", "file_path": "source/generate_dict/generate_private_dict.py", "class_name": null, "func_name": "parse_private_docbook", "text": "文件路径: source/generate_dict/generate_private_dict.py\ndef parse_private_docbook(doc_root):\n    \"\"\"Return a dict containing the private dictionary data\"\"\"\n    entries = {}\n    for entry in root:\n        owner = entry.attrib['owner']\n        if owner not in entries:\n            entries[owner] = {}\n\n        tag = entry.attrib['group'] + entry.attrib['element']\n\n        # Covert unknown element names to 'Unknown'\n        if entry.attrib['name'] == '?':\n            entry.attrib['name'] = 'Unknown'\n        # If backslash in element name escape it\n        if \"\\\\\" in entry.attrib['name']:\n            entry.attrib['name'] = entry.attrib['name'].replace(\"\\\\\", \"\\\\\\\\\")\n\n        entries[owner][tag] = (entry.attrib['vr'],\n                               entry.attrib['vm'],\n                               entry.attrib['name'],\n                               '')\n\n    return entries\n", "tokens": ["source", "generate_dict", "generate_private_dict", "py", "def", "parse_private_docbook", "doc_root", "return", "a", "dict", "containing", "the", "private", "dictionary", "data", "entries", "for", "entry", "in", "root", "owner", "entry", "attrib", "owner", "if", "owner", "not", "in", "entries", "entries", "owner", "tag", "entry", "attrib", "group", "entry", "attrib", "element", "covert", "unknown", "element", "names", "to", "unknown", "if", "entry", "attrib", "name", "entry", "attrib", "name", "unknown", "if", "backslash", "in", "element", "name", "escape", "it", "if", "in", "entry", "attrib", "name", "entry", "attrib", "name", "entry", "attrib", "name", "replace", "entries", "owner", "tag", "entry", "attrib", "vr", "entry", "attrib", "vm", "entry", "attrib", "name", "return", "entries"], "doc_len": 85}
{"doc_id": "source/generate_dict/generate_private_dict.py::write_dict", "file_path": "source/generate_dict/generate_private_dict.py", "class_name": null, "func_name": "write_dict", "text": "文件路径: source/generate_dict/generate_private_dict.py\ndef write_dict(fp, dict_name, dict_entries):\n    \"\"\"Write the `dict_name` dict to file `fp`.\n\n    Dict Format\n    -----------\n    private_dictionaries = {\n        'CREATOR_1' : {\n            '0029xx00': ('US', '1', 'Unknown', ''),\n            '0029xx01': ('US', '1', 'Unknown', ''),\n        },\n        ...\n        'CREATOR_N' : {\n            '0029xx00': ('US', '1', 'Unknown', ''),\n            '0029xx01': ('US', '1', 'Unknown', ''),\n        },\n    }\n\n    Parameters\n    ----------\n    fp : file\n        The file to write the dict to.\n    dict_name : str\n        The name of the dict variable.\n    attributes : list of str\n        List of attributes of the dict entries.\n    \"\"\"\n    fp.write(\"\\n{0} = {{\\n\".format(dict_name))\n    for owner in sorted(dict_entries):\n        fp.write(\"    '{0}': {{\\n\".format(owner))\n        for entry in sorted(dict_entries[owner]):\n            if \"'\" in dict_entries[owner][entry][2]:\n                format_str = \"        '{0}': ('{1}', '{2}', \\\"{3}\\\", '{4}'),  # noqa\\n\"\n            else:\n                format_str = \"        '{0}': ('{1}', '{2}', '{3}', '{4}'),  # noqa\\n\"\n            fp.write(format_str.format(entry,\n                                       dict_entries[owner][entry][0],\n                                       dict_entries[owner][entry][1],\n                                       dict_entries[owner][entry][2],\n                                       dict_entries[owner][entry][3]))\n        fp.write(\"    },\\n\")\n    fp.write(\"}\\n\")\n", "tokens": ["source", "generate_dict", "generate_private_dict", "py", "def", "write_dict", "fp", "dict_name", "dict_entries", "write", "the", "dict_name", "dict", "to", "file", "fp", "dict", "format", "private_dictionaries", "creator_1", "0029xx00", "us", "1", "unknown", "0029xx01", "us", "1", "unknown", "creator_n", "0029xx00", "us", "1", "unknown", "0029xx01", "us", "1", "unknown", "parameters", "fp", "file", "the", "file", "to", "write", "the", "dict", "to", "dict_name", "str", "the", "name", "of", "the", "dict", "variable", "attributes", "list", "of", "str", "list", "of", "attributes", "of", "the", "dict", "entries", "fp", "write", "n", "0", "n", "format", "dict_name", "for", "owner", "in", "sorted", "dict_entries", "fp", "write", "0", "n", "format", "owner", "for", "entry", "in", "sorted", "dict_entries", "owner", "if", "in", "dict_entries", "owner", "entry", "2", "format_str", "0", "1", "2", "3", "4", "noqa", "n", "else", "format_str", "0", "1", "2", "3", "4", "noqa", "n", "fp", "write", "format_str", "format", "entry", "dict_entries", "owner", "entry", "0", "dict_entries", "owner", "entry", "1", "dict_entries", "owner", "entry", "2", "dict_entries", "owner", "entry", "3", "fp", "write", "n", "fp", "write", "n"], "doc_len": 140}
{"doc_id": "source/generate_dict/generate_uid_dict.py::write_dict", "file_path": "source/generate_dict/generate_uid_dict.py", "class_name": null, "func_name": "write_dict", "text": "文件路径: source/generate_dict/generate_uid_dict.py\ndef write_dict(fp, dict_name, attributes):\n    \"\"\"Write the `dict_name` dict to file `fp`.\n\n    Parameters\n    ----------\n    fp : file\n        The file to write the dict to.\n    dict_name : str\n        The name of the dict variable.\n    attributes : list of str\n        List of attributes of the dict entries.\n    \"\"\"\n    uid_entry = \"('{UID Name}', '{UID Type}', '{UID Info}', '{Retired}')\"\n    entry_format = \"'{UID Value}': %s\" % (uid_entry)\n\n    fp.write(\"\\n%s = {\\n    \" % dict_name)\n    fp.write(\",  # noqa\\n    \".join(entry_format.format(**attr)\n                                    for attr in attributes))\n    fp.write(\"  # noqa\\n}\\n\")\n", "tokens": ["source", "generate_dict", "generate_uid_dict", "py", "def", "write_dict", "fp", "dict_name", "attributes", "write", "the", "dict_name", "dict", "to", "file", "fp", "parameters", "fp", "file", "the", "file", "to", "write", "the", "dict", "to", "dict_name", "str", "the", "name", "of", "the", "dict", "variable", "attributes", "list", "of", "str", "list", "of", "attributes", "of", "the", "dict", "entries", "uid_entry", "uid", "name", "uid", "type", "uid", "info", "retired", "entry_format", "uid", "value", "s", "uid_entry", "fp", "write", "n", "s", "n", "dict_name", "fp", "write", "noqa", "n", "join", "entry_format", "format", "attr", "for", "attr", "in", "attributes", "fp", "write", "noqa", "n", "n"], "doc_len": 81}
{"doc_id": "source/generate_dict/generate_uid_dict.py::parse_docbook_table", "file_path": "source/generate_dict/generate_uid_dict.py", "class_name": null, "func_name": "parse_docbook_table", "text": "文件路径: source/generate_dict/generate_uid_dict.py\ndef parse_docbook_table(book_root, caption):\n    \"\"\"Parses the XML `book_root` for the table with `caption`.\n\n    Parameters\n    ----------\n    book_root\n        The XML book root\n    caption : str\n        The caption of the table to parse\n\n    Returns\n    -------\n    row_attrs : list of dict\n        A list of the Element dicts generated by parsing the table.\n    \"\"\"\n    br = '{http://docbook.org/ns/docbook}'  # Shorthand variable\n\n    # Find the table in book_root with caption\n    for table in book_root.iter('%stable' % (br)):\n        if table.find('%scaption' % (br)).text == caption:\n\n            def parse_row(column_names, row):\n                \"\"\"Parses `row` for the DICOM Element data.\n\n                The row should be <tbody><tr>...</tr></tbody>\n                Which leaves the following:\n                    <td><para>Value 1</para></td>\n                    <td><para>Value 2</para></td>\n                    etc...\n                Some rows are\n                    <td><para><emphasis>Value 1</emphasis></para></td>\n                    <td><para><emphasis>Value 2</emphasis></para></td>\n                    etc...\n                There are also some without text values\n                    <td><para/></td>\n                    <td><para><emphasis/></para></td>\n\n                Parameters\n                ----------\n                column_names : list of str\n                    The column header names\n                row\n                    The XML for the header row of the table\n\n                Returns\n                -------\n                dict\n                    {header1 : val1, header2 : val2, ...} representing the\n                    information for the row.\n                \"\"\"\n                cell_values = []\n                for cell in row.iter('%spara' % (br)):\n                    # If we have an emphasis tag under the para tag\n                    emph_value = cell.find('%semphasis' % (br))\n                    if emph_value is not None:\n\n                        # If there is a text value add it, otherwise add \"\"\n                        if emph_value.text is not None:\n                            # 200b is a zero width space\n                            cell_values.append(emph_value.text.strip()\n                                               .replace(u\"\\u200b\", \"\"))\n                        else:\n                            cell_values.append(\"\")\n\n                    # Otherwise just grab the para tag text\n                    else:\n                        if cell.text is not None:\n                            cell_values.append(cell.text.strip()\n                                               .replace(u\"\\u200b\", \"\"))\n                        else:\n                            cell_values.append(\"\")\n\n                cell_values[3] = ''\n                cell_values.append('')\n\n                if '(Retired)' in cell_values[1]:\n                    cell_values[4] = 'Retired'\n                    cell_values[1] = cell_values[1].replace('(Retired)',\n                                                            '').strip()\n\n                if ':' in cell_values[1]:\n                    cell_values[3] = cell_values[1].split(':')[-1].strip()\n                    cell_values[1] = cell_values[1].split(':')[0].strip()\n\n                return {key: value for key,\n                        value in zip(column_names, cell_values)}\n\n            # Get all the Element data from the table\n            column_names = ['UID Value',\n                            'UID Name',\n                            'UID Type',\n                            'UID Info',\n                            'Retired']\n\n            row_attrs = [parse_row(column_names, row)\n                         for row in table.find('%stbody' % (br))\n                         .iter('%str' % (br))]\n\n            return row_attrs\n", "tokens": ["source", "generate_dict", "generate_uid_dict", "py", "def", "parse_docbook_table", "book_root", "caption", "parses", "the", "xml", "book_root", "for", "the", "table", "with", "caption", "parameters", "book_root", "the", "xml", "book", "root", "caption", "str", "the", "caption", "of", "the", "table", "to", "parse", "returns", "row_attrs", "list", "of", "dict", "a", "list", "of", "the", "element", "dicts", "generated", "by", "parsing", "the", "table", "br", "http", "docbook", "org", "ns", "docbook", "shorthand", "variable", "find", "the", "table", "in", "book_root", "with", "caption", "for", "table", "in", "book_root", "iter", "stable", "br", "if", "table", "find", "scaption", "br", "text", "caption", "def", "parse_row", "column_names", "row", "parses", "row", "for", "the", "dicom", "element", "data", "the", "row", "should", "be", "tbody", "tr", "tr", "tbody", "which", "leaves", "the", "following", "td", "para", "value", "1", "para", "td", "td", "para", "value", "2", "para", "td", "etc", "some", "rows", "are", "td", "para", "emphasis", "value", "1", "emphasis", "para", "td", "td", "para", "emphasis", "value", "2", "emphasis", "para", "td", "etc", "there", "are", "also", "some", "without", "text", "values", "td", "para", "td", "td", "para", "emphasis", "para", "td", "parameters", "column_names", "list", "of", "str", "the", "column", "header", "names", "row", "the", "xml", "for", "the", "header", "row", "of", "the", "table", "returns", "dict", "header1", "val1", "header2", "val2", "representing", "the", "information", "for", "the", "row", "cell_values", "for", "cell", "in", "row", "iter", "spara", "br", "if", "we", "have", "an", "emphasis", "tag", "under", "the", "para", "tag", "emph_value", "cell", "find", "semphasis", "br", "if", "emph_value", "is", "not", "none", "if", "there", "is", "a", "text", "value", "add", "it", "otherwise", "add", "if", "emph_value", "text", "is", "not", "none", "200b", "is", "a", "zero", "width", "space", "cell_values", "append", "emph_value", "text", "strip", "replace", "u", "u200b", "else", "cell_values", "append", "otherwise", "just", "grab", "the", "para", "tag", "text", "else", "if", "cell", "text", "is", "not", "none", "cell_values", "append", "cell", "text", "strip", "replace", "u", "u200b", "else", "cell_values", "append", "cell_values", "3", "cell_values", "append", "if", "retired", "in", "cell_values", "1", "cell_values", "4", "retired", "cell_values", "1", "cell_values", "1", "replace", "retired", "strip", "if", "in", "cell_values", "1", "cell_values", "3", "cell_values", "1", "split", "1", "strip", "cell_values", "1", "cell_values", "1", "split", "0", "strip", "return", "key", "value", "for", "key", "value", "in", "zip", "column_names", "cell_values", "get", "all", "the", "element", "data", "from", "the", "table", "column_names", "uid", "value", "uid", "name", "uid", "type", "uid", "info", "retired", "row_attrs", "parse_row", "column_names", "row", "for", "row", "in", "table", "find", "stbody", "br", "iter", "str", "br", "return", "row_attrs"], "doc_len": 346}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::is_storage_class", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "is_storage_class", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef is_storage_class(attributes):\n    return (attributes[1] == 'SOP Class' and\n            STORAGE_REGEX.match(attributes[0]) and\n            attributes[3] != 'Retired')\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "is_storage_class", "attributes", "return", "attributes", "1", "sop", "class", "and", "storage_regex", "match", "attributes", "0", "and", "attributes", "3", "retired"], "doc_len": 21}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::replace_number", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "replace_number", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef replace_number(number):\n    \"\"\"Replace the given number bey a literal representation.\"\"\"\n    numbers = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five',\n               'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven',\n               'Twelve', 'Thirteen', 'Fourteen', 'Fifteen']\n    if number < len(numbers):\n        return numbers[number]\n\n    # return the original string if not found - will raise later\n    return str(number)\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "replace_number", "number", "replace", "the", "given", "number", "bey", "a", "literal", "representation", "numbers", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "if", "number", "len", "numbers", "return", "numbers", "number", "return", "the", "original", "string", "if", "not", "found", "will", "raise", "later", "return", "str", "number"], "doc_len": 52}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::replace_digits", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "replace_digits", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef replace_digits(name):\n    \"\"\"Replace the leading digits in the given string by\n    a literal representation.\n    \"\"\"\n    number_regex = re.compile(r'^(?P<number>\\d*)(?P<rest>.*)')\n    match = number_regex.match(name)\n    number = replace_number(int(match.group('number')))\n    rest = match.group('rest')\n    return number + rest[0].upper() + rest[1:]\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "replace_digits", "name", "replace", "the", "leading", "digits", "in", "the", "given", "string", "by", "a", "literal", "representation", "number_regex", "re", "compile", "r", "p", "number", "d", "p", "rest", "match", "number_regex", "match", "name", "number", "replace_number", "int", "match", "group", "number", "rest", "match", "group", "rest", "return", "number", "rest", "0", "upper", "rest", "1"], "doc_len": 49}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::sop_class_name", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "sop_class_name", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef sop_class_name(description):\n    \"\"\"Return a name used as class identifier for the given SOP class\n    description.\n    \"\"\"\n    name = description\n    if name.endswith(' SOP Class'):\n        name = name[:-10]\n\n    name = replace_bad_characters(name)\n\n    if name[:1].isdigit():\n        name = replace_digits(name)\n    if not re.match(tokenize.Name + '$', name):\n        raise NotImplementedError(\n            'Cannot create name for SOP class \"{}\"'.format(description))\n    return name\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "sop_class_name", "description", "return", "a", "name", "used", "as", "class", "identifier", "for", "the", "given", "sop", "class", "description", "name", "description", "if", "name", "endswith", "sop", "class", "name", "name", "10", "name", "replace_bad_characters", "name", "if", "name", "1", "isdigit", "name", "replace_digits", "name", "if", "not", "re", "match", "tokenize", "name", "name", "raise", "notimplementederror", "cannot", "create", "name", "for", "sop", "class", "format", "description", "return", "name"], "doc_len": 59}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::replace_bad_characters", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "replace_bad_characters", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef replace_bad_characters(name):\n    bad_chars = r'!@#$%^&*(),;:.?\\|{}[]+-=/ '\n    if not in_py2:\n        translate_table = dict((ord(char), None) for char in bad_chars)\n        name = name.translate(translate_table)\n    else:\n        import string\n        translate_table = string.maketrans('', '')\n        name = name.translate(translate_table, bad_chars)\n    return name\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "replace_bad_characters", "name", "bad_chars", "r", "if", "not", "in_py2", "translate_table", "dict", "ord", "char", "none", "for", "char", "in", "bad_chars", "name", "name", "translate", "translate_table", "else", "import", "string", "translate_table", "string", "maketrans", "name", "name", "translate", "translate_table", "bad_chars", "return", "name"], "doc_len": 38}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::uid_line", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "uid_line", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef uid_line(uid, name):\n    \"\"\"Return the UID class definition line to be written into the python file.\n    \"\"\"\n    # add a line break after UID to avoid too long lines\n    return \"{} = UID(\\n    '{}')\\n\".format(sop_class_name(name), uid)\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "uid_line", "uid", "name", "return", "the", "uid", "class", "definition", "line", "to", "be", "written", "into", "the", "python", "file", "add", "a", "line", "break", "after", "uid", "to", "avoid", "too", "long", "lines", "return", "uid", "n", "n", "format", "sop_class_name", "name", "uid"], "doc_len": 40}
{"doc_id": "source/generate_uids/generate_storage_sopclass_uids.py::generate_uids", "file_path": "source/generate_uids/generate_storage_sopclass_uids.py", "class_name": null, "func_name": "generate_uids", "text": "文件路径: source/generate_uids/generate_storage_sopclass_uids.py\ndef generate_uids(filename):\n    \"\"\"Generate python file with SOP Class UID definitions.\"\"\"\n    with open(filename, 'w') as uid_file:\n        doc_string = (\n            '\"\"\"\\nStorage SOP Class UIDs auto-generated by %s\\n\"\"\"\\n\\n'\n            % os.path.basename(__file__))\n        uid_file.write(doc_string)\n        uid_file.write('from __future__ import absolute_import\\n')\n        uid_file.write('from pydicom.uid import UID\\n\\n')\n\n        for uid, attribs in sorted(UID_dictionary.items()):\n            if is_storage_class(attribs):\n                uid_file.write(uid_line(uid, attribs[0]))\n", "tokens": ["source", "generate_uids", "generate_storage_sopclass_uids", "py", "def", "generate_uids", "filename", "generate", "python", "file", "with", "sop", "class", "uid", "definitions", "with", "open", "filename", "w", "as", "uid_file", "doc_string", "nstorage", "sop", "class", "uids", "auto", "generated", "by", "s", "n", "n", "n", "os", "path", "basename", "__file__", "uid_file", "write", "doc_string", "uid_file", "write", "from", "__future__", "import", "absolute_import", "n", "uid_file", "write", "from", "pydicom", "uid", "import", "uid", "n", "n", "for", "uid", "attribs", "in", "sorted", "uid_dictionary", "items", "if", "is_storage_class", "attribs", "uid_file", "write", "uid_line", "uid", "attribs", "0"], "doc_len": 72}
