{"doc_id": "docs/conf.py::github_link", "file_path": "docs/conf.py", "class_name": null, "func_name": "github_link", "text": "文件路径: docs/conf.py\ndef github_link(name, rawtext, text, lineno, inliner, options=None, content=None):\n    app = inliner.document.settings.env.app\n    release = app.config.release\n    base_url = \"https://github.com/pallets/flask/tree/\"\n\n    if text.endswith(\">\"):\n        words, text = text[:-1].rsplit(\"<\", 1)\n        words = words.strip()\n    else:\n        words = None\n\n    if packaging.version.parse(release).is_devrelease:\n        url = f\"{base_url}main/{text}\"\n    else:\n        url = f\"{base_url}{release}/{text}\"\n\n    if words is None:\n        words = url\n\n    from docutils.nodes import reference\n    from docutils.parsers.rst.roles import set_classes\n\n    options = options or {}\n    set_classes(options)\n    node = reference(rawtext, words, refuri=url, **options)\n    return [node], []\n", "tokens": ["docs", "conf", "py", "def", "github_link", "name", "rawtext", "text", "lineno", "inliner", "options", "none", "content", "none", "app", "inliner", "document", "settings", "env", "app", "release", "app", "config", "release", "base_url", "https", "github", "com", "pallets", "flask", "tree", "if", "text", "endswith", "words", "text", "text", "1", "rsplit", "1", "words", "words", "strip", "else", "words", "none", "if", "packaging", "version", "parse", "release", "is_devrelease", "url", "f", "base_url", "main", "text", "else", "url", "f", "base_url", "release", "text", "if", "words", "is", "none", "words", "url", "from", "docutils", "nodes", "import", "reference", "from", "docutils", "parsers", "rst", "roles", "import", "set_classes", "options", "options", "or", "set_classes", "options", "node", "reference", "rawtext", "words", "refuri", "url", "options", "return", "node"], "doc_len": 95}
{"doc_id": "docs/conf.py::setup", "file_path": "docs/conf.py", "class_name": null, "func_name": "setup", "text": "文件路径: docs/conf.py\ndef setup(app):\n    app.add_role(\"gh\", github_link)\n", "tokens": ["docs", "conf", "py", "def", "setup", "app", "app", "add_role", "gh", "github_link"], "doc_len": 10}
{"doc_id": "examples/celery/src/task_app/tasks.py::add", "file_path": "examples/celery/src/task_app/tasks.py", "class_name": null, "func_name": "add", "text": "文件路径: examples/celery/src/task_app/tasks.py\ndef add(a: int, b: int) -> int:\n    return a + b\n", "tokens": ["examples", "celery", "src", "task_app", "tasks", "py", "def", "add", "a", "int", "b", "int", "int", "return", "a", "b"], "doc_len": 16}
{"doc_id": "examples/celery/src/task_app/tasks.py::block", "file_path": "examples/celery/src/task_app/tasks.py", "class_name": null, "func_name": "block", "text": "文件路径: examples/celery/src/task_app/tasks.py\ndef block() -> None:\n    time.sleep(5)\n", "tokens": ["examples", "celery", "src", "task_app", "tasks", "py", "def", "block", "none", "time", "sleep", "5"], "doc_len": 12}
{"doc_id": "examples/celery/src/task_app/tasks.py::process", "file_path": "examples/celery/src/task_app/tasks.py", "class_name": null, "func_name": "process", "text": "文件路径: examples/celery/src/task_app/tasks.py\ndef process(self: Task, total: int) -> object:\n    for i in range(total):\n        self.update_state(state=\"PROGRESS\", meta={\"current\": i + 1, \"total\": total})\n        time.sleep(1)\n\n    return {\"current\": total, \"total\": total}\n", "tokens": ["examples", "celery", "src", "task_app", "tasks", "py", "def", "process", "self", "task", "total", "int", "object", "for", "i", "in", "range", "total", "self", "update_state", "state", "progress", "meta", "current", "i", "1", "total", "total", "time", "sleep", "1", "return", "current", "total", "total", "total"], "doc_len": 36}
{"doc_id": "examples/celery/src/task_app/views.py::result", "file_path": "examples/celery/src/task_app/views.py", "class_name": null, "func_name": "result", "text": "文件路径: examples/celery/src/task_app/views.py\ndef result(id: str) -> dict[str, object]:\n    result = AsyncResult(id)\n    ready = result.ready()\n    return {\n        \"ready\": ready,\n        \"successful\": result.successful() if ready else None,\n        \"value\": result.get() if ready else result.result,\n    }\n", "tokens": ["examples", "celery", "src", "task_app", "views", "py", "def", "result", "id", "str", "dict", "str", "object", "result", "asyncresult", "id", "ready", "result", "ready", "return", "ready", "ready", "successful", "result", "successful", "if", "ready", "else", "none", "value", "result", "get", "if", "ready", "else", "result", "result"], "doc_len": 37}
{"doc_id": "examples/celery/src/task_app/views.py::add", "file_path": "examples/celery/src/task_app/views.py", "class_name": null, "func_name": "add", "text": "文件路径: examples/celery/src/task_app/views.py\ndef add() -> dict[str, object]:\n    a = request.form.get(\"a\", type=int)\n    b = request.form.get(\"b\", type=int)\n    result = tasks.add.delay(a, b)\n    return {\"result_id\": result.id}\n", "tokens": ["examples", "celery", "src", "task_app", "views", "py", "def", "add", "dict", "str", "object", "a", "request", "form", "get", "a", "type", "int", "b", "request", "form", "get", "b", "type", "int", "result", "tasks", "add", "delay", "a", "b", "return", "result_id", "result", "id"], "doc_len": 35}
{"doc_id": "examples/celery/src/task_app/views.py::block", "file_path": "examples/celery/src/task_app/views.py", "class_name": null, "func_name": "block", "text": "文件路径: examples/celery/src/task_app/views.py\ndef block() -> dict[str, object]:\n    result = tasks.block.delay()\n    return {\"result_id\": result.id}\n", "tokens": ["examples", "celery", "src", "task_app", "views", "py", "def", "block", "dict", "str", "object", "result", "tasks", "block", "delay", "return", "result_id", "result", "id"], "doc_len": 19}
{"doc_id": "examples/celery/src/task_app/views.py::process", "file_path": "examples/celery/src/task_app/views.py", "class_name": null, "func_name": "process", "text": "文件路径: examples/celery/src/task_app/views.py\ndef process() -> dict[str, object]:\n    result = tasks.process.delay(total=request.form.get(\"total\", type=int))\n    return {\"result_id\": result.id}\n", "tokens": ["examples", "celery", "src", "task_app", "views", "py", "def", "process", "dict", "str", "object", "result", "tasks", "process", "delay", "total", "request", "form", "get", "total", "type", "int", "return", "result_id", "result", "id"], "doc_len": 26}
{"doc_id": "examples/celery/src/task_app/__init__.py::create_app", "file_path": "examples/celery/src/task_app/__init__.py", "class_name": null, "func_name": "create_app", "text": "文件路径: examples/celery/src/task_app/__init__.py\ndef create_app() -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        CELERY=dict(\n            broker_url=\"redis://localhost\",\n            result_backend=\"redis://localhost\",\n            task_ignore_result=True,\n        ),\n    )\n    app.config.from_prefixed_env()\n    celery_init_app(app)\n\n    @app.route(\"/\")\n    def index() -> str:\n        return render_template(\"index.html\")\n\n    from . import views\n\n    app.register_blueprint(views.bp)\n    return app\n", "tokens": ["examples", "celery", "src", "task_app", "__init__", "py", "def", "create_app", "flask", "app", "flask", "__name__", "app", "config", "from_mapping", "celery", "dict", "broker_url", "redis", "localhost", "result_backend", "redis", "localhost", "task_ignore_result", "true", "app", "config", "from_prefixed_env", "celery_init_app", "app", "app", "route", "def", "index", "str", "return", "render_template", "index", "html", "from", "import", "views", "app", "register_blueprint", "views", "bp", "return", "app"], "doc_len": 48}
{"doc_id": "examples/celery/src/task_app/__init__.py::celery_init_app", "file_path": "examples/celery/src/task_app/__init__.py", "class_name": null, "func_name": "celery_init_app", "text": "文件路径: examples/celery/src/task_app/__init__.py\ndef celery_init_app(app: Flask) -> Celery:\n    class FlaskTask(Task):\n        def __call__(self, *args: object, **kwargs: object) -> object:\n            with app.app_context():\n                return self.run(*args, **kwargs)\n\n    celery_app = Celery(app.name, task_cls=FlaskTask)\n    celery_app.config_from_object(app.config[\"CELERY\"])\n    celery_app.set_default()\n    app.extensions[\"celery\"] = celery_app\n    return celery_app\n", "tokens": ["examples", "celery", "src", "task_app", "__init__", "py", "def", "celery_init_app", "app", "flask", "celery", "class", "flasktask", "task", "def", "__call__", "self", "args", "object", "kwargs", "object", "object", "with", "app", "app_context", "return", "self", "run", "args", "kwargs", "celery_app", "celery", "app", "name", "task_cls", "flasktask", "celery_app", "config_from_object", "app", "config", "celery", "celery_app", "set_default", "app", "extensions", "celery", "celery_app", "return", "celery_app"], "doc_len": 49}
{"doc_id": "examples/javascript/js_example/views.py::index", "file_path": "examples/javascript/js_example/views.py", "class_name": null, "func_name": "index", "text": "文件路径: examples/javascript/js_example/views.py\ndef index(js):\n    return render_template(f\"{js}.html\", js=js)\n", "tokens": ["examples", "javascript", "js_example", "views", "py", "def", "index", "js", "return", "render_template", "f", "js", "html", "js", "js"], "doc_len": 15}
{"doc_id": "examples/javascript/js_example/views.py::add", "file_path": "examples/javascript/js_example/views.py", "class_name": null, "func_name": "add", "text": "文件路径: examples/javascript/js_example/views.py\ndef add():\n    a = request.form.get(\"a\", 0, type=float)\n    b = request.form.get(\"b\", 0, type=float)\n    return jsonify(result=a + b)\n", "tokens": ["examples", "javascript", "js_example", "views", "py", "def", "add", "a", "request", "form", "get", "a", "0", "type", "float", "b", "request", "form", "get", "b", "0", "type", "float", "return", "jsonify", "result", "a", "b"], "doc_len": 28}
{"doc_id": "examples/javascript/tests/conftest.py::fixture_app", "file_path": "examples/javascript/tests/conftest.py", "class_name": null, "func_name": "fixture_app", "text": "文件路径: examples/javascript/tests/conftest.py\ndef fixture_app():\n    app.testing = True\n    yield app\n    app.testing = False\n", "tokens": ["examples", "javascript", "tests", "conftest", "py", "def", "fixture_app", "app", "testing", "true", "yield", "app", "app", "testing", "false"], "doc_len": 15}
{"doc_id": "examples/javascript/tests/conftest.py::client", "file_path": "examples/javascript/tests/conftest.py", "class_name": null, "func_name": "client", "text": "文件路径: examples/javascript/tests/conftest.py\ndef client(app):\n    return app.test_client()\n", "tokens": ["examples", "javascript", "tests", "conftest", "py", "def", "client", "app", "return", "app", "test_client"], "doc_len": 11}
{"doc_id": "examples/javascript/tests/test_js_example.py::test_index", "file_path": "examples/javascript/tests/test_js_example.py", "class_name": null, "func_name": "test_index", "text": "文件路径: examples/javascript/tests/test_js_example.py\ndef test_index(app, client, path, template_name):\n    def check(sender, template, context):\n        assert template.name == template_name\n\n    with template_rendered.connected_to(check, app):\n        client.get(path)\n", "tokens": ["examples", "javascript", "tests", "test_js_example", "py", "def", "test_index", "app", "client", "path", "template_name", "def", "check", "sender", "template", "context", "assert", "template", "name", "template_name", "with", "template_rendered", "connected_to", "check", "app", "client", "get", "path"], "doc_len": 28}
{"doc_id": "examples/javascript/tests/test_js_example.py::test_add", "file_path": "examples/javascript/tests/test_js_example.py", "class_name": null, "func_name": "test_add", "text": "文件路径: examples/javascript/tests/test_js_example.py\ndef test_add(client, a, b, result):\n    response = client.post(\"/add\", data={\"a\": a, \"b\": b})\n    assert response.get_json()[\"result\"] == result\n", "tokens": ["examples", "javascript", "tests", "test_js_example", "py", "def", "test_add", "client", "a", "b", "result", "response", "client", "post", "add", "data", "a", "a", "b", "b", "assert", "response", "get_json", "result", "result"], "doc_len": 25}
{"doc_id": "examples/tutorial/flaskr/auth.py::login_required", "file_path": "examples/tutorial/flaskr/auth.py", "class_name": null, "func_name": "login_required", "text": "文件路径: examples/tutorial/flaskr/auth.py\ndef login_required(view):\n    \"\"\"View decorator that redirects anonymous users to the login page.\"\"\"\n\n    @functools.wraps(view)\n    def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)\n\n    return wrapped_view\n", "tokens": ["examples", "tutorial", "flaskr", "auth", "py", "def", "login_required", "view", "view", "decorator", "that", "redirects", "anonymous", "users", "to", "the", "login", "page", "functools", "wraps", "view", "def", "wrapped_view", "kwargs", "if", "g", "user", "is", "none", "return", "redirect", "url_for", "auth", "login", "return", "view", "kwargs", "return", "wrapped_view"], "doc_len": 39}
{"doc_id": "examples/tutorial/flaskr/auth.py::load_logged_in_user", "file_path": "examples/tutorial/flaskr/auth.py", "class_name": null, "func_name": "load_logged_in_user", "text": "文件路径: examples/tutorial/flaskr/auth.py\ndef load_logged_in_user():\n    \"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"\n    user_id = session.get(\"user_id\")\n\n    if user_id is None:\n        g.user = None\n    else:\n        g.user = (\n            get_db().execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )\n", "tokens": ["examples", "tutorial", "flaskr", "auth", "py", "def", "load_logged_in_user", "if", "a", "user", "id", "is", "stored", "in", "the", "session", "load", "the", "user", "object", "from", "the", "database", "into", "g", "user", "user_id", "session", "get", "user_id", "if", "user_id", "is", "none", "g", "user", "none", "else", "g", "user", "get_db", "execute", "select", "from", "user", "where", "id", "user_id", "fetchone"], "doc_len": 49}
{"doc_id": "examples/tutorial/flaskr/auth.py::register", "file_path": "examples/tutorial/flaskr/auth.py", "class_name": null, "func_name": "register", "text": "文件路径: examples/tutorial/flaskr/auth.py\ndef register():\n    \"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n\n        if error is None:\n            try:\n                db.execute(\n                    \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                    (username, generate_password_hash(password)),\n                )\n                db.commit()\n            except db.IntegrityError:\n                # The username was already taken, which caused the\n                # commit to fail. Show a validation error.\n                error = f\"User {username} is already registered.\"\n            else:\n                # Success, go to the login page.\n                return redirect(url_for(\"auth.login\"))\n\n        flash(error)\n\n    return render_template(\"auth/register.html\")\n", "tokens": ["examples", "tutorial", "flaskr", "auth", "py", "def", "register", "register", "a", "new", "user", "validates", "that", "the", "username", "is", "not", "already", "taken", "hashes", "the", "password", "for", "security", "if", "request", "method", "post", "username", "request", "form", "username", "password", "request", "form", "password", "db", "get_db", "error", "none", "if", "not", "username", "error", "username", "is", "required", "elif", "not", "password", "error", "password", "is", "required", "if", "error", "is", "none", "try", "db", "execute", "insert", "into", "user", "username", "password", "values", "username", "generate_password_hash", "password", "db", "commit", "except", "db", "integrityerror", "the", "username", "was", "already", "taken", "which", "caused", "the", "commit", "to", "fail", "show", "a", "validation", "error", "error", "f", "user", "username", "is", "already", "registered", "else", "success", "go", "to", "the", "login", "page", "return", "redirect", "url_for", "auth", "login", "flash", "error", "return", "render_template", "auth", "register", "html"], "doc_len": 116}
{"doc_id": "examples/tutorial/flaskr/auth.py::login", "file_path": "examples/tutorial/flaskr/auth.py", "class_name": null, "func_name": "login", "text": "文件路径: examples/tutorial/flaskr/auth.py\ndef login():\n    \"\"\"Log in a registered user by adding the user id to the session.\"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n        user = db.execute(\n            \"SELECT * FROM user WHERE username = ?\", (username,)\n        ).fetchone()\n\n        if user is None:\n            error = \"Incorrect username.\"\n        elif not check_password_hash(user[\"password\"], password):\n            error = \"Incorrect password.\"\n\n        if error is None:\n            # store the user id in a new session and return to the index\n            session.clear()\n            session[\"user_id\"] = user[\"id\"]\n            return redirect(url_for(\"index\"))\n\n        flash(error)\n\n    return render_template(\"auth/login.html\")\n", "tokens": ["examples", "tutorial", "flaskr", "auth", "py", "def", "login", "log", "in", "a", "registered", "user", "by", "adding", "the", "user", "id", "to", "the", "session", "if", "request", "method", "post", "username", "request", "form", "username", "password", "request", "form", "password", "db", "get_db", "error", "none", "user", "db", "execute", "select", "from", "user", "where", "username", "username", "fetchone", "if", "user", "is", "none", "error", "incorrect", "username", "elif", "not", "check_password_hash", "user", "password", "password", "error", "incorrect", "password", "if", "error", "is", "none", "store", "the", "user", "id", "in", "a", "new", "session", "and", "return", "to", "the", "index", "session", "clear", "session", "user_id", "user", "id", "return", "redirect", "url_for", "index", "flash", "error", "return", "render_template", "auth", "login", "html"], "doc_len": 96}
{"doc_id": "examples/tutorial/flaskr/auth.py::logout", "file_path": "examples/tutorial/flaskr/auth.py", "class_name": null, "func_name": "logout", "text": "文件路径: examples/tutorial/flaskr/auth.py\ndef logout():\n    \"\"\"Clear the current session, including the stored user id.\"\"\"\n    session.clear()\n    return redirect(url_for(\"index\"))\n", "tokens": ["examples", "tutorial", "flaskr", "auth", "py", "def", "logout", "clear", "the", "current", "session", "including", "the", "stored", "user", "id", "session", "clear", "return", "redirect", "url_for", "index"], "doc_len": 22}
{"doc_id": "examples/tutorial/flaskr/blog.py::index", "file_path": "examples/tutorial/flaskr/blog.py", "class_name": null, "func_name": "index", "text": "文件路径: examples/tutorial/flaskr/blog.py\ndef index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog/index.html\", posts=posts)\n", "tokens": ["examples", "tutorial", "flaskr", "blog", "py", "def", "index", "show", "all", "the", "posts", "most", "recent", "first", "db", "get_db", "posts", "db", "execute", "select", "p", "id", "title", "body", "created", "author_id", "username", "from", "post", "p", "join", "user", "u", "on", "p", "author_id", "u", "id", "order", "by", "created", "desc", "fetchall", "return", "render_template", "blog", "index", "html", "posts", "posts"], "doc_len": 50}
{"doc_id": "examples/tutorial/flaskr/blog.py::get_post", "file_path": "examples/tutorial/flaskr/blog.py", "class_name": null, "func_name": "get_post", "text": "文件路径: examples/tutorial/flaskr/blog.py\ndef get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, f\"Post id {id} doesn't exist.\")\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post\n", "tokens": ["examples", "tutorial", "flaskr", "blog", "py", "def", "get_post", "id", "check_author", "true", "get", "a", "post", "and", "its", "author", "by", "id", "checks", "that", "the", "id", "exists", "and", "optionally", "that", "the", "current", "user", "is", "the", "author", "param", "id", "id", "of", "post", "to", "get", "param", "check_author", "require", "the", "current", "user", "to", "be", "the", "author", "return", "the", "post", "with", "author", "information", "raise", "404", "if", "a", "post", "with", "the", "given", "id", "doesn", "t", "exist", "raise", "403", "if", "the", "current", "user", "isn", "t", "the", "author", "post", "get_db", "execute", "select", "p", "id", "title", "body", "created", "author_id", "username", "from", "post", "p", "join", "user", "u", "on", "p", "author_id", "u", "id", "where", "p", "id", "id", "fetchone", "if", "post", "is", "none", "abort", "404", "f", "post", "id", "id", "doesn", "t", "exist", "if", "check_author", "and", "post", "author_id", "g", "user", "id", "abort", "403", "return", "post"], "doc_len": 129}
{"doc_id": "examples/tutorial/flaskr/blog.py::create", "file_path": "examples/tutorial/flaskr/blog.py", "class_name": null, "func_name": "create", "text": "文件路径: examples/tutorial/flaskr/blog.py\ndef create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id) VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/create.html\")\n", "tokens": ["examples", "tutorial", "flaskr", "blog", "py", "def", "create", "create", "a", "new", "post", "for", "the", "current", "user", "if", "request", "method", "post", "title", "request", "form", "title", "body", "request", "form", "body", "error", "none", "if", "not", "title", "error", "title", "is", "required", "if", "error", "is", "not", "none", "flash", "error", "else", "db", "get_db", "db", "execute", "insert", "into", "post", "title", "body", "author_id", "values", "title", "body", "g", "user", "id", "db", "commit", "return", "redirect", "url_for", "blog", "index", "return", "render_template", "blog", "create", "html"], "doc_len": 72}
{"doc_id": "examples/tutorial/flaskr/blog.py::update", "file_path": "examples/tutorial/flaskr/blog.py", "class_name": null, "func_name": "update", "text": "文件路径: examples/tutorial/flaskr/blog.py\ndef update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/update.html\", post=post)\n", "tokens": ["examples", "tutorial", "flaskr", "blog", "py", "def", "update", "id", "update", "a", "post", "if", "the", "current", "user", "is", "the", "author", "post", "get_post", "id", "if", "request", "method", "post", "title", "request", "form", "title", "body", "request", "form", "body", "error", "none", "if", "not", "title", "error", "title", "is", "required", "if", "error", "is", "not", "none", "flash", "error", "else", "db", "get_db", "db", "execute", "update", "post", "set", "title", "body", "where", "id", "title", "body", "id", "db", "commit", "return", "redirect", "url_for", "blog", "index", "return", "render_template", "blog", "update", "html", "post", "post"], "doc_len": 78}
{"doc_id": "examples/tutorial/flaskr/blog.py::delete", "file_path": "examples/tutorial/flaskr/blog.py", "class_name": null, "func_name": "delete", "text": "文件路径: examples/tutorial/flaskr/blog.py\ndef delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))\n", "tokens": ["examples", "tutorial", "flaskr", "blog", "py", "def", "delete", "id", "delete", "a", "post", "ensures", "that", "the", "post", "exists", "and", "that", "the", "logged", "in", "user", "is", "the", "author", "of", "the", "post", "get_post", "id", "db", "get_db", "db", "execute", "delete", "from", "post", "where", "id", "id", "db", "commit", "return", "redirect", "url_for", "blog", "index"], "doc_len": 47}
{"doc_id": "examples/tutorial/flaskr/db.py::get_db", "file_path": "examples/tutorial/flaskr/db.py", "class_name": null, "func_name": "get_db", "text": "文件路径: examples/tutorial/flaskr/db.py\ndef get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n", "tokens": ["examples", "tutorial", "flaskr", "db", "py", "def", "get_db", "connect", "to", "the", "application", "s", "configured", "database", "the", "connection", "is", "unique", "for", "each", "request", "and", "will", "be", "reused", "if", "this", "is", "called", "again", "if", "db", "not", "in", "g", "g", "db", "sqlite3", "connect", "current_app", "config", "database", "detect_types", "sqlite3", "parse_decltypes", "g", "db", "row_factory", "sqlite3", "row", "return", "g", "db"], "doc_len": 53}
{"doc_id": "examples/tutorial/flaskr/db.py::close_db", "file_path": "examples/tutorial/flaskr/db.py", "class_name": null, "func_name": "close_db", "text": "文件路径: examples/tutorial/flaskr/db.py\ndef close_db(e=None):\n    \"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()\n", "tokens": ["examples", "tutorial", "flaskr", "db", "py", "def", "close_db", "e", "none", "if", "this", "request", "connected", "to", "the", "database", "close", "the", "connection", "db", "g", "pop", "db", "none", "if", "db", "is", "not", "none", "db", "close"], "doc_len": 31}
{"doc_id": "examples/tutorial/flaskr/db.py::init_db", "file_path": "examples/tutorial/flaskr/db.py", "class_name": null, "func_name": "init_db", "text": "文件路径: examples/tutorial/flaskr/db.py\ndef init_db():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))\n", "tokens": ["examples", "tutorial", "flaskr", "db", "py", "def", "init_db", "clear", "existing", "data", "and", "create", "new", "tables", "db", "get_db", "with", "current_app", "open_resource", "schema", "sql", "as", "f", "db", "executescript", "f", "read", "decode", "utf8"], "doc_len": 29}
{"doc_id": "examples/tutorial/flaskr/db.py::init_db_command", "file_path": "examples/tutorial/flaskr/db.py", "class_name": null, "func_name": "init_db_command", "text": "文件路径: examples/tutorial/flaskr/db.py\ndef init_db_command():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    init_db()\n    click.echo(\"Initialized the database.\")\n", "tokens": ["examples", "tutorial", "flaskr", "db", "py", "def", "init_db_command", "clear", "existing", "data", "and", "create", "new", "tables", "init_db", "click", "echo", "initialized", "the", "database"], "doc_len": 20}
{"doc_id": "examples/tutorial/flaskr/db.py::init_app", "file_path": "examples/tutorial/flaskr/db.py", "class_name": null, "func_name": "init_app", "text": "文件路径: examples/tutorial/flaskr/db.py\ndef init_app(app):\n    \"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)\n", "tokens": ["examples", "tutorial", "flaskr", "db", "py", "def", "init_app", "app", "register", "database", "functions", "with", "the", "flask", "app", "this", "is", "called", "by", "the", "application", "factory", "app", "teardown_appcontext", "close_db", "app", "cli", "add_command", "init_db_command"], "doc_len": 29}
{"doc_id": "examples/tutorial/flaskr/__init__.py::create_app", "file_path": "examples/tutorial/flaskr/__init__.py", "class_name": null, "func_name": "create_app", "text": "文件路径: examples/tutorial/flaskr/__init__.py\ndef create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from flaskr import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from flaskr import auth, blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app\n", "tokens": ["examples", "tutorial", "flaskr", "__init__", "py", "def", "create_app", "test_config", "none", "create", "and", "configure", "an", "instance", "of", "the", "flask", "application", "app", "flask", "__name__", "instance_relative_config", "true", "app", "config", "from_mapping", "a", "default", "secret", "that", "should", "be", "overridden", "by", "instance", "config", "secret_key", "dev", "store", "the", "database", "in", "the", "instance", "folder", "database", "os", "path", "join", "app", "instance_path", "flaskr", "sqlite", "if", "test_config", "is", "none", "load", "the", "instance", "config", "if", "it", "exists", "when", "not", "testing", "app", "config", "from_pyfile", "config", "py", "silent", "true", "else", "load", "the", "test", "config", "if", "passed", "in", "app", "config", "update", "test_config", "ensure", "the", "instance", "folder", "exists", "try", "os", "makedirs", "app", "instance_path", "except", "oserror", "pass", "app", "route", "hello", "def", "hello", "return", "hello", "world", "register", "the", "database", "commands", "from", "flaskr", "import", "db", "db", "init_app", "app", "apply", "the", "blueprints", "to", "the", "app", "from", "flaskr", "import", "auth", "blog", "app", "register_blueprint", "auth", "bp", "app", "register_blueprint", "blog", "bp", "make", "url_for", "index", "url_for", "blog", "index", "in", "another", "app", "you", "might", "define", "a", "separate", "main", "index", "here", "with", "app", "route", "while", "giving", "the", "blog", "blueprint", "a", "url_prefix", "but", "for", "the", "tutorial", "the", "blog", "will", "be", "the", "main", "index", "app", "add_url_rule", "endpoint", "index", "return", "app"], "doc_len": 181}
{"doc_id": "examples/tutorial/tests/conftest.py::app", "file_path": "examples/tutorial/tests/conftest.py", "class_name": null, "func_name": "app", "text": "文件路径: examples/tutorial/tests/conftest.py\ndef app():\n    \"\"\"Create and configure a new app instance for each test.\"\"\"\n    # create a temporary file to isolate the database for each test\n    db_fd, db_path = tempfile.mkstemp()\n    # create the app with common test config\n    app = create_app({\"TESTING\": True, \"DATABASE\": db_path})\n\n    # create the database and load test data\n    with app.app_context():\n        init_db()\n        get_db().executescript(_data_sql)\n\n    yield app\n\n    # close and remove the temporary database\n    os.close(db_fd)\n    os.unlink(db_path)\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "def", "app", "create", "and", "configure", "a", "new", "app", "instance", "for", "each", "test", "create", "a", "temporary", "file", "to", "isolate", "the", "database", "for", "each", "test", "db_fd", "db_path", "tempfile", "mkstemp", "create", "the", "app", "with", "common", "test", "config", "app", "create_app", "testing", "true", "database", "db_path", "create", "the", "database", "and", "load", "test", "data", "with", "app", "app_context", "init_db", "get_db", "executescript", "_data_sql", "yield", "app", "close", "and", "remove", "the", "temporary", "database", "os", "close", "db_fd", "os", "unlink", "db_path"], "doc_len": 73}
{"doc_id": "examples/tutorial/tests/conftest.py::client", "file_path": "examples/tutorial/tests/conftest.py", "class_name": null, "func_name": "client", "text": "文件路径: examples/tutorial/tests/conftest.py\ndef client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "def", "client", "app", "a", "test", "client", "for", "the", "app", "return", "app", "test_client"], "doc_len": 17}
{"doc_id": "examples/tutorial/tests/conftest.py::runner", "file_path": "examples/tutorial/tests/conftest.py", "class_name": null, "func_name": "runner", "text": "文件路径: examples/tutorial/tests/conftest.py\ndef runner(app):\n    \"\"\"A test runner for the app's Click commands.\"\"\"\n    return app.test_cli_runner()\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "def", "runner", "app", "a", "test", "runner", "for", "the", "app", "s", "click", "commands", "return", "app", "test_cli_runner"], "doc_len": 20}
{"doc_id": "examples/tutorial/tests/conftest.py::AuthActions.__init__", "file_path": "examples/tutorial/tests/conftest.py", "class_name": "AuthActions", "func_name": "__init__", "text": "文件路径: examples/tutorial/tests/conftest.py, 类名: AuthActions\n    def __init__(self, client):\n        self._client = client\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "authactions", "def", "__init__", "self", "client", "self", "_client", "client"], "doc_len": 13}
{"doc_id": "examples/tutorial/tests/conftest.py::AuthActions.login", "file_path": "examples/tutorial/tests/conftest.py", "class_name": "AuthActions", "func_name": "login", "text": "文件路径: examples/tutorial/tests/conftest.py, 类名: AuthActions\n    def login(self, username=\"test\", password=\"test\"):\n        return self._client.post(\n            \"/auth/login\", data={\"username\": username, \"password\": password}\n        )\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "authactions", "def", "login", "self", "username", "test", "password", "test", "return", "self", "_client", "post", "auth", "login", "data", "username", "username", "password", "password"], "doc_len": 24}
{"doc_id": "examples/tutorial/tests/conftest.py::AuthActions.logout", "file_path": "examples/tutorial/tests/conftest.py", "class_name": "AuthActions", "func_name": "logout", "text": "文件路径: examples/tutorial/tests/conftest.py, 类名: AuthActions\n    def logout(self):\n        return self._client.get(\"/auth/logout\")\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "authactions", "def", "logout", "self", "return", "self", "_client", "get", "auth", "logout"], "doc_len": 15}
{"doc_id": "examples/tutorial/tests/conftest.py::auth", "file_path": "examples/tutorial/tests/conftest.py", "class_name": null, "func_name": "auth", "text": "文件路径: examples/tutorial/tests/conftest.py\ndef auth(client):\n    return AuthActions(client)\n", "tokens": ["examples", "tutorial", "tests", "conftest", "py", "def", "auth", "client", "return", "authactions", "client"], "doc_len": 11}
{"doc_id": "examples/tutorial/tests/test_auth.py::test_register", "file_path": "examples/tutorial/tests/test_auth.py", "class_name": null, "func_name": "test_register", "text": "文件路径: examples/tutorial/tests/test_auth.py\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"/auth/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert response.headers[\"Location\"] == \"/auth/login\"\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"SELECT * FROM user WHERE username = 'a'\").fetchone()\n            is not None\n        )\n", "tokens": ["examples", "tutorial", "tests", "test_auth", "py", "def", "test_register", "client", "app", "test", "that", "viewing", "the", "page", "renders", "without", "template", "errors", "assert", "client", "get", "auth", "register", "status_code", "200", "test", "that", "successful", "registration", "redirects", "to", "the", "login", "page", "response", "client", "post", "auth", "register", "data", "username", "a", "password", "a", "assert", "response", "headers", "location", "auth", "login", "test", "that", "the", "user", "was", "inserted", "into", "the", "database", "with", "app", "app_context", "assert", "get_db", "execute", "select", "from", "user", "where", "username", "a", "fetchone", "is", "not", "none"], "doc_len": 75}
{"doc_id": "examples/tutorial/tests/test_auth.py::test_register_validate_input", "file_path": "examples/tutorial/tests/test_auth.py", "class_name": null, "func_name": "test_register_validate_input", "text": "文件路径: examples/tutorial/tests/test_auth.py\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"/auth/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n", "tokens": ["examples", "tutorial", "tests", "test_auth", "py", "def", "test_register_validate_input", "client", "username", "password", "message", "response", "client", "post", "auth", "register", "data", "username", "username", "password", "password", "assert", "message", "in", "response", "data"], "doc_len": 26}
{"doc_id": "examples/tutorial/tests/test_auth.py::test_login", "file_path": "examples/tutorial/tests/test_auth.py", "class_name": null, "func_name": "test_login", "text": "文件路径: examples/tutorial/tests/test_auth.py\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n", "tokens": ["examples", "tutorial", "tests", "test_auth", "py", "def", "test_login", "client", "auth", "test", "that", "viewing", "the", "page", "renders", "without", "template", "errors", "assert", "client", "get", "auth", "login", "status_code", "200", "test", "that", "successful", "login", "redirects", "to", "the", "index", "page", "response", "auth", "login", "assert", "response", "headers", "location", "login", "request", "set", "the", "user_id", "in", "the", "session", "check", "that", "the", "user", "is", "loaded", "from", "the", "session", "with", "client", "client", "get", "assert", "session", "user_id", "1", "assert", "g", "user", "username", "test"], "doc_len": 71}
{"doc_id": "examples/tutorial/tests/test_auth.py::test_login_validate_input", "file_path": "examples/tutorial/tests/test_auth.py", "class_name": null, "func_name": "test_login_validate_input", "text": "文件路径: examples/tutorial/tests/test_auth.py\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n", "tokens": ["examples", "tutorial", "tests", "test_auth", "py", "def", "test_login_validate_input", "auth", "username", "password", "message", "response", "auth", "login", "username", "password", "assert", "message", "in", "response", "data"], "doc_len": 21}
{"doc_id": "examples/tutorial/tests/test_auth.py::test_logout", "file_path": "examples/tutorial/tests/test_auth.py", "class_name": null, "func_name": "test_logout", "text": "文件路径: examples/tutorial/tests/test_auth.py\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n", "tokens": ["examples", "tutorial", "tests", "test_auth", "py", "def", "test_logout", "client", "auth", "auth", "login", "with", "client", "auth", "logout", "assert", "user_id", "not", "in", "session"], "doc_len": 20}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_index", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_index", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_index(client, auth):\n    response = client.get(\"/\")\n    assert b\"Log In\" in response.data\n    assert b\"Register\" in response.data\n\n    auth.login()\n    response = client.get(\"/\")\n    assert b\"test title\" in response.data\n    assert b\"by test on 2018-01-01\" in response.data\n    assert b\"test\\nbody\" in response.data\n    assert b'href=\"/1/update\"' in response.data\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_index", "client", "auth", "response", "client", "get", "assert", "b", "log", "in", "in", "response", "data", "assert", "b", "register", "in", "response", "data", "auth", "login", "response", "client", "get", "assert", "b", "test", "title", "in", "response", "data", "assert", "b", "by", "test", "on", "2018", "01", "01", "in", "response", "data", "assert", "b", "test", "nbody", "in", "response", "data", "assert", "b", "href", "1", "update", "in", "response", "data"], "doc_len": 63}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_login_required", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_login_required", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_login_required(client, path):\n    response = client.post(path)\n    assert response.headers[\"Location\"] == \"/auth/login\"\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_login_required", "client", "path", "response", "client", "post", "path", "assert", "response", "headers", "location", "auth", "login"], "doc_len": 19}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_author_required", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_author_required", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_author_required(app, client, auth):\n    # change the post author to another user\n    with app.app_context():\n        db = get_db()\n        db.execute(\"UPDATE post SET author_id = 2 WHERE id = 1\")\n        db.commit()\n\n    auth.login()\n    # current user can't modify other user's post\n    assert client.post(\"/1/update\").status_code == 403\n    assert client.post(\"/1/delete\").status_code == 403\n    # current user doesn't see edit link\n    assert b'href=\"/1/update\"' not in client.get(\"/\").data\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_author_required", "app", "client", "auth", "change", "the", "post", "author", "to", "another", "user", "with", "app", "app_context", "db", "get_db", "db", "execute", "update", "post", "set", "author_id", "2", "where", "id", "1", "db", "commit", "auth", "login", "current", "user", "can", "t", "modify", "other", "user", "s", "post", "assert", "client", "post", "1", "update", "status_code", "403", "assert", "client", "post", "1", "delete", "status_code", "403", "current", "user", "doesn", "t", "see", "edit", "link", "assert", "b", "href", "1", "update", "not", "in", "client", "get", "data"], "doc_len": 76}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_exists_required", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_exists_required", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_exists_required(client, auth, path):\n    auth.login()\n    assert client.post(path).status_code == 404\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_exists_required", "client", "auth", "path", "auth", "login", "assert", "client", "post", "path", "status_code", "404"], "doc_len": 18}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_create", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_create", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_create(client, auth, app):\n    auth.login()\n    assert client.get(\"/create\").status_code == 200\n    client.post(\"/create\", data={\"title\": \"created\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        count = db.execute(\"SELECT COUNT(id) FROM post\").fetchone()[0]\n        assert count == 2\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_create", "client", "auth", "app", "auth", "login", "assert", "client", "get", "create", "status_code", "200", "client", "post", "create", "data", "title", "created", "body", "with", "app", "app_context", "db", "get_db", "count", "db", "execute", "select", "count", "id", "from", "post", "fetchone", "0", "assert", "count", "2"], "doc_len": 43}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_update", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_update", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_update(client, auth, app):\n    auth.login()\n    assert client.get(\"/1/update\").status_code == 200\n    client.post(\"/1/update\", data={\"title\": \"updated\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post[\"title\"] == \"updated\"\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_update", "client", "auth", "app", "auth", "login", "assert", "client", "get", "1", "update", "status_code", "200", "client", "post", "1", "update", "data", "title", "updated", "body", "with", "app", "app_context", "db", "get_db", "post", "db", "execute", "select", "from", "post", "where", "id", "1", "fetchone", "assert", "post", "title", "updated"], "doc_len": 46}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_create_update_validate", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_create_update_validate", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_create_update_validate(client, auth, path):\n    auth.login()\n    response = client.post(path, data={\"title\": \"\", \"body\": \"\"})\n    assert b\"Title is required.\" in response.data\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_create_update_validate", "client", "auth", "path", "auth", "login", "response", "client", "post", "path", "data", "title", "body", "assert", "b", "title", "is", "required", "in", "response", "data"], "doc_len": 27}
{"doc_id": "examples/tutorial/tests/test_blog.py::test_delete", "file_path": "examples/tutorial/tests/test_blog.py", "class_name": null, "func_name": "test_delete", "text": "文件路径: examples/tutorial/tests/test_blog.py\ndef test_delete(client, auth, app):\n    auth.login()\n    response = client.post(\"/1/delete\")\n    assert response.headers[\"Location\"] == \"/\"\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post is None\n", "tokens": ["examples", "tutorial", "tests", "test_blog", "py", "def", "test_delete", "client", "auth", "app", "auth", "login", "response", "client", "post", "1", "delete", "assert", "response", "headers", "location", "with", "app", "app_context", "db", "get_db", "post", "db", "execute", "select", "from", "post", "where", "id", "1", "fetchone", "assert", "post", "is", "none"], "doc_len": 40}
{"doc_id": "examples/tutorial/tests/test_db.py::test_get_close_db", "file_path": "examples/tutorial/tests/test_db.py", "class_name": null, "func_name": "test_get_close_db", "text": "文件路径: examples/tutorial/tests/test_db.py\ndef test_get_close_db(app):\n    with app.app_context():\n        db = get_db()\n        assert db is get_db()\n\n    with pytest.raises(sqlite3.ProgrammingError) as e:\n        db.execute(\"SELECT 1\")\n\n    assert \"closed\" in str(e.value)\n", "tokens": ["examples", "tutorial", "tests", "test_db", "py", "def", "test_get_close_db", "app", "with", "app", "app_context", "db", "get_db", "assert", "db", "is", "get_db", "with", "pytest", "raises", "sqlite3", "programmingerror", "as", "e", "db", "execute", "select", "1", "assert", "closed", "in", "str", "e", "value"], "doc_len": 34}
{"doc_id": "examples/tutorial/tests/test_db.py::test_init_db_command", "file_path": "examples/tutorial/tests/test_db.py", "class_name": null, "func_name": "test_init_db_command", "text": "文件路径: examples/tutorial/tests/test_db.py\ndef test_init_db_command(runner, monkeypatch):\n    class Recorder:\n        called = False\n\n    def fake_init_db():\n        Recorder.called = True\n\n    monkeypatch.setattr(\"flaskr.db.init_db\", fake_init_db)\n    result = runner.invoke(args=[\"init-db\"])\n    assert \"Initialized\" in result.output\n    assert Recorder.called\n", "tokens": ["examples", "tutorial", "tests", "test_db", "py", "def", "test_init_db_command", "runner", "monkeypatch", "class", "recorder", "called", "false", "def", "fake_init_db", "recorder", "called", "true", "monkeypatch", "setattr", "flaskr", "db", "init_db", "fake_init_db", "result", "runner", "invoke", "args", "init", "db", "assert", "initialized", "in", "result", "output", "assert", "recorder", "called"], "doc_len": 38}
{"doc_id": "examples/tutorial/tests/test_factory.py::test_config", "file_path": "examples/tutorial/tests/test_factory.py", "class_name": null, "func_name": "test_config", "text": "文件路径: examples/tutorial/tests/test_factory.py\ndef test_config():\n    \"\"\"Test create_app without passing test config.\"\"\"\n    assert not create_app().testing\n    assert create_app({\"TESTING\": True}).testing\n", "tokens": ["examples", "tutorial", "tests", "test_factory", "py", "def", "test_config", "test", "create_app", "without", "passing", "test", "config", "assert", "not", "create_app", "testing", "assert", "create_app", "testing", "true", "testing"], "doc_len": 22}
{"doc_id": "examples/tutorial/tests/test_factory.py::test_hello", "file_path": "examples/tutorial/tests/test_factory.py", "class_name": null, "func_name": "test_hello", "text": "文件路径: examples/tutorial/tests/test_factory.py\ndef test_hello(client):\n    response = client.get(\"/hello\")\n    assert response.data == b\"Hello, World!\"\n", "tokens": ["examples", "tutorial", "tests", "test_factory", "py", "def", "test_hello", "client", "response", "client", "get", "hello", "assert", "response", "data", "b", "hello", "world"], "doc_len": 18}
{"doc_id": "src/flask/app.py::_make_timedelta", "file_path": "src/flask/app.py", "class_name": null, "func_name": "_make_timedelta", "text": "文件路径: src/flask/app.py\ndef _make_timedelta(value: t.Union[timedelta, int, None]) -> t.Optional[timedelta]:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)\n", "tokens": ["src", "flask", "app", "py", "def", "_make_timedelta", "value", "t", "union", "timedelta", "int", "none", "t", "optional", "timedelta", "if", "value", "is", "none", "or", "isinstance", "value", "timedelta", "return", "value", "return", "timedelta", "seconds", "value"], "doc_len": 29}
{"doc_id": "src/flask/app.py::Flask.__init__", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "__init__", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def __init__(\n        self,\n        import_name: str,\n        static_url_path: t.Optional[str] = None,\n        static_folder: t.Optional[t.Union[str, os.PathLike]] = \"static\",\n        static_host: t.Optional[str] = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: t.Optional[t.Union[str, os.PathLike]] = \"templates\",\n        instance_path: t.Optional[str] = None,\n        instance_relative_config: bool = False,\n        root_path: t.Optional[str] = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                \"If an instance path is provided it must be absolute.\"\n                \" A relative path was given instead.\"\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        \"\"\"Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python's built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        \"\"\"\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: t.List[\n            t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: t.Dict[str, \"Blueprint\"] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a \"Flask-Foo\" extension in `flask_foo`, the key would be\n        #: ``'foo'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(',')\n        #:        def to_url(self, values):\n        #:            return ','.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters['list'] = ListConverter\n        self.url_map = self.url_map_class()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), \"Invalid static_host/host_matching combination\"\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                endpoint=\"static\",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "__init__", "self", "import_name", "str", "static_url_path", "t", "optional", "str", "none", "static_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "static", "static_host", "t", "optional", "str", "none", "host_matching", "bool", "false", "subdomain_matching", "bool", "false", "template_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "templates", "instance_path", "t", "optional", "str", "none", "instance_relative_config", "bool", "false", "root_path", "t", "optional", "str", "none", "super", "__init__", "import_name", "import_name", "static_folder", "static_folder", "static_url_path", "static_url_path", "template_folder", "template_folder", "root_path", "root_path", "if", "instance_path", "is", "none", "instance_path", "self", "auto_find_instance_path", "elif", "not", "os", "path", "isabs", "instance_path", "raise", "valueerror", "if", "an", "instance", "path", "is", "provided", "it", "must", "be", "absolute", "a", "relative", "path", "was", "given", "instead", "holds", "the", "path", "to", "the", "instance", "folder", "versionadded", "0", "8", "self", "instance_path", "instance_path", "the", "configuration", "dictionary", "as", "class", "config", "this", "behaves", "exactly", "like", "a", "regular", "dictionary", "but", "supports", "additional", "methods", "to", "load", "a", "config", "from", "files", "self", "config", "self", "make_config", "instance_relative_config", "an", "instance", "of", "attr", "aborter_class", "created", "by", "meth", "make_aborter", "this", "is", "called", "by", "func", "flask", "abort", "to", "raise", "http", "errors", "and", "can", "be", "called", "directly", "as", "well", "versionadded", "2", "2", "moved", "from", "flask", "abort", "which", "calls", "this", "object", "self", "aborter", "self", "make_aborter", "self", "json", "jsonprovider", "self", "json_provider_class", "self", "provides", "access", "to", "json", "methods", "functions", "in", "flask", "json", "will", "call", "methods", "on", "this", "provider", "when", "the", "application", "context", "is", "active", "used", "for", "handling", "json", "requests", "and", "responses", "an", "instance", "of", "attr", "json_provider_class", "can", "be", "customized", "by", "changing", "that", "attribute", "on", "a", "subclass", "or", "by", "assigning", "to", "this", "attribute", "afterwards", "the", "default", "class", "flask", "json", "provider", "defaultjsonprovider", "uses", "python", "s", "built", "in", "mod", "json", "library", "a", "different", "provider", "can", "use", "a", "different", "json", "library", "versionadded", "2", "2", "a", "list", "of", "functions", "that", "are", "called", "by", "meth", "handle_url_build_error", "when", "meth", "url_for", "raises", "a", "exc", "werkzeug", "routing", "builderror", "each", "function", "is", "called", "with", "error", "endpoint", "and", "values", "if", "a", "function", "returns", "none", "or", "raises", "a", "builderror", "it", "is", "skipped", "otherwise", "its", "return", "value", "is", "returned", "by", "url_for", "versionadded", "0", "9", "self", "url_build_error_handlers", "t", "list", "t", "callable", "exception", "str", "t", "dict", "str", "t", "any", "str", "a", "list", "of", "functions", "that", "are", "called", "when", "the", "application", "context", "is", "destroyed", "since", "the", "application", "context", "is", "also", "torn", "down", "if", "the", "request", "ends", "this", "is", "the", "place", "to", "store", "code", "that", "disconnects", "from", "databases", "versionadded", "0", "9", "self", "teardown_appcontext_funcs", "t", "list", "ft", "teardowncallable", "a", "list", "of", "shell", "context", "processor", "functions", "that", "should", "be", "run", "when", "a", "shell", "context", "is", "created", "versionadded", "0", "11", "self", "shell_context_processors", "t", "list", "ft", "shellcontextprocessorcallable", "maps", "registered", "blueprint", "names", "to", "blueprint", "objects", "the", "dict", "retains", "the", "order", "the", "blueprints", "were", "registered", "in", "blueprints", "can", "be", "registered", "multiple", "times", "this", "dict", "does", "not", "track", "how", "often", "they", "were", "attached", "versionadded", "0", "7", "self", "blueprints", "t", "dict", "str", "blueprint", "a", "place", "where", "extensions", "can", "store", "application", "specific", "state", "for", "example", "this", "is", "where", "an", "extension", "could", "store", "database", "engines", "and", "similar", "things", "the", "key", "must", "match", "the", "name", "of", "the", "extension", "module", "for", "example", "in", "case", "of", "a", "flask", "foo", "extension", "in", "flask_foo", "the", "key", "would", "be", "foo", "versionadded", "0", "7", "self", "extensions", "dict", "the", "class", "werkzeug", "routing", "map", "for", "this", "instance", "you", "can", "use", "this", "to", "change", "the", "routing", "converters", "after", "the", "class", "was", "created", "but", "before", "any", "routes", "are", "connected", "example", "from", "werkzeug", "routing", "import", "baseconverter", "class", "listconverter", "baseconverter", "def", "to_python", "self", "value", "return", "value", "split", "def", "to_url", "self", "values", "return", "join", "super", "listconverter", "self", "to_url", "value", "for", "value", "in", "values", "app", "flask", "__name__", "app", "url_map", "converters", "list", "listconverter", "self", "url_map", "self", "url_map_class", "self", "url_map", "host_matching", "host_matching", "self", "subdomain_matching", "subdomain_matching", "tracks", "internally", "if", "the", "application", "already", "handled", "at", "least", "one", "request", "self", "_got_first_request", "false", "add", "a", "static", "route", "using", "the", "provided", "static_url_path", "static_host", "and", "static_folder", "if", "there", "is", "a", "configured", "static_folder", "note", "we", "do", "this", "without", "checking", "if", "static_folder", "exists", "for", "one", "it", "might", "be", "created", "while", "the", "server", "is", "running", "e", "g", "during", "development", "also", "google", "app", "engine", "stores", "static", "files", "somewhere", "if", "self", "has_static_folder", "assert", "bool", "static_host", "host_matching", "invalid", "static_host", "host_matching", "combination", "use", "a", "weakref", "to", "avoid", "creating", "a", "reference", "cycle", "between", "the", "app", "and", "the", "view", "function", "see", "3761", "self_ref", "weakref", "ref", "self", "self", "add_url_rule", "f", "self", "static_url_path", "path", "filename", "endpoint", "static", "host", "static_host", "view_func", "lambda", "kw", "self_ref", "send_static_file", "kw", "type", "ignore", "noqa", "b950", "set", "the", "name", "of", "the", "click", "group", "in", "case", "someone", "wants", "to", "add", "the", "app", "s", "commands", "to", "another", "cli", "tool", "self", "cli", "name", "self", "name"], "doc_len": 720}
{"doc_id": "src/flask/app.py::Flask._check_setup_finished", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "_check_setup_finished", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_first_request:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called\"\n                \" on the application. It has already handled its first\"\n                \" request, any changes will not be applied\"\n                \" consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc.\"\n                \" needed to set up the application are done before\"\n                \" running it.\"\n            )\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "_check_setup_finished", "self", "f_name", "str", "none", "if", "self", "_got_first_request", "raise", "assertionerror", "f", "the", "setup", "method", "f_name", "can", "no", "longer", "be", "called", "on", "the", "application", "it", "has", "already", "handled", "its", "first", "request", "any", "changes", "will", "not", "be", "applied", "consistently", "n", "make", "sure", "all", "imports", "decorators", "functions", "etc", "needed", "to", "set", "up", "the", "application", "are", "done", "before", "running", "it"], "doc_len": 62}
{"doc_id": "src/flask/app.py::Flask.name", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "name", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def name(self) -> str:  # type: ignore\n        \"\"\"The name of the application.  This is usually the import name\n        with the difference that it's guessed from the run file if the\n        import name is main.  This name is used as a display name when\n        Flask needs the name of the application.  It can be set and overridden\n        to change the value.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.import_name == \"__main__\":\n            fn = getattr(sys.modules[\"__main__\"], \"__file__\", None)\n            if fn is None:\n                return \"__main__\"\n            return os.path.splitext(os.path.basename(fn))[0]\n        return self.import_name\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "name", "self", "str", "type", "ignore", "the", "name", "of", "the", "application", "this", "is", "usually", "the", "import", "name", "with", "the", "difference", "that", "it", "s", "guessed", "from", "the", "run", "file", "if", "the", "import", "name", "is", "main", "this", "name", "is", "used", "as", "a", "display", "name", "when", "flask", "needs", "the", "name", "of", "the", "application", "it", "can", "be", "set", "and", "overridden", "to", "change", "the", "value", "versionadded", "0", "8", "if", "self", "import_name", "__main__", "fn", "getattr", "sys", "modules", "__main__", "__file__", "none", "if", "fn", "is", "none", "return", "__main__", "return", "os", "path", "splitext", "os", "path", "basename", "fn", "0", "return", "self", "import_name"], "doc_len": 97}
{"doc_id": "src/flask/app.py::Flask.logger", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "logger", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def logger(self) -> logging.Logger:\n        \"\"\"A standard Python :class:`~logging.Logger` for the app, with\n        the same name as :attr:`name`.\n\n        In debug mode, the logger's :attr:`~logging.Logger.level` will\n        be set to :data:`~logging.DEBUG`.\n\n        If there are no handlers configured, a default handler will be\n        added. See :doc:`/logging` for more information.\n\n        .. versionchanged:: 1.1.0\n            The logger takes the same name as :attr:`name` rather than\n            hard-coding ``\"flask.app\"``.\n\n        .. versionchanged:: 1.0.0\n            Behavior was simplified. The logger is always named\n            ``\"flask.app\"``. The level is only set during configuration,\n            it doesn't check ``app.debug`` each time. Only one format is\n            used, not different ones depending on ``app.debug``. No\n            handlers are removed, and a handler is only added if no\n            handlers are already configured.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        return create_logger(self)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "logger", "self", "logging", "logger", "a", "standard", "python", "class", "logging", "logger", "for", "the", "app", "with", "the", "same", "name", "as", "attr", "name", "in", "debug", "mode", "the", "logger", "s", "attr", "logging", "logger", "level", "will", "be", "set", "to", "data", "logging", "debug", "if", "there", "are", "no", "handlers", "configured", "a", "default", "handler", "will", "be", "added", "see", "doc", "logging", "for", "more", "information", "versionchanged", "1", "1", "0", "the", "logger", "takes", "the", "same", "name", "as", "attr", "name", "rather", "than", "hard", "coding", "flask", "app", "versionchanged", "1", "0", "0", "behavior", "was", "simplified", "the", "logger", "is", "always", "named", "flask", "app", "the", "level", "is", "only", "set", "during", "configuration", "it", "doesn", "t", "check", "app", "debug", "each", "time", "only", "one", "format", "is", "used", "not", "different", "ones", "depending", "on", "app", "debug", "no", "handlers", "are", "removed", "and", "a", "handler", "is", "only", "added", "if", "no", "handlers", "are", "already", "configured", "versionadded", "0", "3", "return", "create_logger", "self"], "doc_len": 143}
{"doc_id": "src/flask/app.py::Flask.jinja_env", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "jinja_env", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def jinja_env(self) -> Environment:\n        \"\"\"The Jinja environment used to load templates.\n\n        The environment is created the first time this property is\n        accessed. Changing :attr:`jinja_options` after that will have no\n        effect.\n        \"\"\"\n        return self.create_jinja_environment()\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "jinja_env", "self", "environment", "the", "jinja", "environment", "used", "to", "load", "templates", "the", "environment", "is", "created", "the", "first", "time", "this", "property", "is", "accessed", "changing", "attr", "jinja_options", "after", "that", "will", "have", "no", "effect", "return", "self", "create_jinja_environment"], "doc_len": 39}
{"doc_id": "src/flask/app.py::Flask.got_first_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "got_first_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def got_first_request(self) -> bool:\n        \"\"\"This attribute is set to ``True`` if the application started\n        handling the first request.\n\n        .. deprecated:: 2.3\n            Will be removed in Flask 2.4.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        import warnings\n\n        warnings.warn(\n            \"'got_first_request' is deprecated and will be removed in Flask 2.4.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self._got_first_request\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "got_first_request", "self", "bool", "this", "attribute", "is", "set", "to", "true", "if", "the", "application", "started", "handling", "the", "first", "request", "deprecated", "2", "3", "will", "be", "removed", "in", "flask", "2", "4", "versionadded", "0", "8", "import", "warnings", "warnings", "warn", "got_first_request", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "deprecationwarning", "stacklevel", "2", "return", "self", "_got_first_request"], "doc_len": 57}
{"doc_id": "src/flask/app.py::Flask.make_config", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "make_config", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def make_config(self, instance_relative: bool = False) -> Config:\n        \"\"\"Used to create the config attribute by the Flask constructor.\n        The `instance_relative` parameter is passed in from the constructor\n        of Flask (there named `instance_relative_config`) and indicates if\n        the config should be relative to the instance path or the root path\n        of the application.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        root_path = self.root_path\n        if instance_relative:\n            root_path = self.instance_path\n        defaults = dict(self.default_config)\n        defaults[\"DEBUG\"] = get_debug_flag()\n        return self.config_class(root_path, defaults)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "make_config", "self", "instance_relative", "bool", "false", "config", "used", "to", "create", "the", "config", "attribute", "by", "the", "flask", "constructor", "the", "instance_relative", "parameter", "is", "passed", "in", "from", "the", "constructor", "of", "flask", "there", "named", "instance_relative_config", "and", "indicates", "if", "the", "config", "should", "be", "relative", "to", "the", "instance", "path", "or", "the", "root", "path", "of", "the", "application", "versionadded", "0", "8", "root_path", "self", "root_path", "if", "instance_relative", "root_path", "self", "instance_path", "defaults", "dict", "self", "default_config", "defaults", "debug", "get_debug_flag", "return", "self", "config_class", "root_path", "defaults"], "doc_len": 78}
{"doc_id": "src/flask/app.py::Flask.make_aborter", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "make_aborter", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def make_aborter(self) -> Aborter:\n        \"\"\"Create the object to assign to :attr:`aborter`. That object\n        is called by :func:`flask.abort` to raise HTTP errors, and can\n        be called directly as well.\n\n        By default, this creates an instance of :attr:`aborter_class`,\n        which defaults to :class:`werkzeug.exceptions.Aborter`.\n\n        .. versionadded:: 2.2\n        \"\"\"\n        return self.aborter_class()\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "make_aborter", "self", "aborter", "create", "the", "object", "to", "assign", "to", "attr", "aborter", "that", "object", "is", "called", "by", "func", "flask", "abort", "to", "raise", "http", "errors", "and", "can", "be", "called", "directly", "as", "well", "by", "default", "this", "creates", "an", "instance", "of", "attr", "aborter_class", "which", "defaults", "to", "class", "werkzeug", "exceptions", "aborter", "versionadded", "2", "2", "return", "self", "aborter_class"], "doc_len": 58}
{"doc_id": "src/flask/app.py::Flask.auto_find_instance_path", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "auto_find_instance_path", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def auto_find_instance_path(self) -> str:\n        \"\"\"Tries to locate the instance path if it was not provided to the\n        constructor of the application class.  It will basically calculate\n        the path to a folder named ``instance`` next to your main file or\n        the package.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        prefix, package_path = find_package(self.import_name)\n        if prefix is None:\n            return os.path.join(package_path, \"instance\")\n        return os.path.join(prefix, \"var\", f\"{self.name}-instance\")\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "auto_find_instance_path", "self", "str", "tries", "to", "locate", "the", "instance", "path", "if", "it", "was", "not", "provided", "to", "the", "constructor", "of", "the", "application", "class", "it", "will", "basically", "calculate", "the", "path", "to", "a", "folder", "named", "instance", "next", "to", "your", "main", "file", "or", "the", "package", "versionadded", "0", "8", "prefix", "package_path", "find_package", "self", "import_name", "if", "prefix", "is", "none", "return", "os", "path", "join", "package_path", "instance", "return", "os", "path", "join", "prefix", "var", "f", "self", "name", "instance"], "doc_len": 74}
{"doc_id": "src/flask/app.py::Flask.open_instance_resource", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "open_instance_resource", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def open_instance_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n        \"\"\"Opens a resource from the application's instance folder\n        (:attr:`instance_path`).  Otherwise works like\n        :meth:`open_resource`.  Instance resources can also be opened for\n        writing.\n\n        :param resource: the name of the resource.  To access resources within\n                         subfolders use forward slashes as separator.\n        :param mode: resource file opening mode, default is 'rb'.\n        \"\"\"\n        return open(os.path.join(self.instance_path, resource), mode)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "open_instance_resource", "self", "resource", "str", "mode", "str", "rb", "t", "io", "t", "anystr", "opens", "a", "resource", "from", "the", "application", "s", "instance", "folder", "attr", "instance_path", "otherwise", "works", "like", "meth", "open_resource", "instance", "resources", "can", "also", "be", "opened", "for", "writing", "param", "resource", "the", "name", "of", "the", "resource", "to", "access", "resources", "within", "subfolders", "use", "forward", "slashes", "as", "separator", "param", "mode", "resource", "file", "opening", "mode", "default", "is", "rb", "return", "open", "os", "path", "join", "self", "instance_path", "resource", "mode"], "doc_len": 76}
{"doc_id": "src/flask/app.py::Flask.create_jinja_environment", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "create_jinja_environment", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def create_jinja_environment(self) -> Environment:\n        \"\"\"Create the Jinja environment based on :attr:`jinja_options`\n        and the various Jinja-related methods of the app. Changing\n        :attr:`jinja_options` after this will have no effect. Also adds\n        Flask-related globals and filters to the environment.\n\n        .. versionchanged:: 0.11\n           ``Environment.auto_reload`` set in accordance with\n           ``TEMPLATES_AUTO_RELOAD`` configuration option.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        options = dict(self.jinja_options)\n\n        if \"autoescape\" not in options:\n            options[\"autoescape\"] = self.select_jinja_autoescape\n\n        if \"auto_reload\" not in options:\n            auto_reload = self.config[\"TEMPLATES_AUTO_RELOAD\"]\n\n            if auto_reload is None:\n                auto_reload = self.debug\n\n            options[\"auto_reload\"] = auto_reload\n\n        rv = self.jinja_environment(self, **options)\n        rv.globals.update(\n            url_for=self.url_for,\n            get_flashed_messages=get_flashed_messages,\n            config=self.config,\n            # request, session and g are normally added with the\n            # context processor for efficiency reasons but for imported\n            # templates we also want the proxies in there.\n            request=request,\n            session=session,\n            g=g,\n        )\n        rv.policies[\"json.dumps_function\"] = self.json.dumps\n        return rv\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "create_jinja_environment", "self", "environment", "create", "the", "jinja", "environment", "based", "on", "attr", "jinja_options", "and", "the", "various", "jinja", "related", "methods", "of", "the", "app", "changing", "attr", "jinja_options", "after", "this", "will", "have", "no", "effect", "also", "adds", "flask", "related", "globals", "and", "filters", "to", "the", "environment", "versionchanged", "0", "11", "environment", "auto_reload", "set", "in", "accordance", "with", "templates_auto_reload", "configuration", "option", "versionadded", "0", "5", "options", "dict", "self", "jinja_options", "if", "autoescape", "not", "in", "options", "options", "autoescape", "self", "select_jinja_autoescape", "if", "auto_reload", "not", "in", "options", "auto_reload", "self", "config", "templates_auto_reload", "if", "auto_reload", "is", "none", "auto_reload", "self", "debug", "options", "auto_reload", "auto_reload", "rv", "self", "jinja_environment", "self", "options", "rv", "globals", "update", "url_for", "self", "url_for", "get_flashed_messages", "get_flashed_messages", "config", "self", "config", "request", "session", "and", "g", "are", "normally", "added", "with", "the", "context", "processor", "for", "efficiency", "reasons", "but", "for", "imported", "templates", "we", "also", "want", "the", "proxies", "in", "there", "request", "request", "session", "session", "g", "g", "rv", "policies", "json", "dumps_function", "self", "json", "dumps", "return", "rv"], "doc_len": 148}
{"doc_id": "src/flask/app.py::Flask.create_global_jinja_loader", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "create_global_jinja_loader", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def create_global_jinja_loader(self) -> DispatchingJinjaLoader:\n        \"\"\"Creates the loader for the Jinja2 environment.  Can be used to\n        override just the loader and keeping the rest unchanged.  It's\n        discouraged to override this function.  Instead one should override\n        the :meth:`jinja_loader` function instead.\n\n        The global loader dispatches between the loaders of the application\n        and the individual blueprints.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        return DispatchingJinjaLoader(self)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "create_global_jinja_loader", "self", "dispatchingjinjaloader", "creates", "the", "loader", "for", "the", "jinja2", "environment", "can", "be", "used", "to", "override", "just", "the", "loader", "and", "keeping", "the", "rest", "unchanged", "it", "s", "discouraged", "to", "override", "this", "function", "instead", "one", "should", "override", "the", "meth", "jinja_loader", "function", "instead", "the", "global", "loader", "dispatches", "between", "the", "loaders", "of", "the", "application", "and", "the", "individual", "blueprints", "versionadded", "0", "7", "return", "dispatchingjinjaloader", "self"], "doc_len": 65}
{"doc_id": "src/flask/app.py::Flask.select_jinja_autoescape", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "select_jinja_autoescape", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def select_jinja_autoescape(self, filename: str) -> bool:\n        \"\"\"Returns ``True`` if autoescaping should be active for the given\n        template name. If no template name is given, returns `True`.\n\n        .. versionchanged:: 2.2\n            Autoescaping is now enabled by default for ``.svg`` files.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if filename is None:\n            return True\n        return filename.endswith((\".html\", \".htm\", \".xml\", \".xhtml\", \".svg\"))\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "select_jinja_autoescape", "self", "filename", "str", "bool", "returns", "true", "if", "autoescaping", "should", "be", "active", "for", "the", "given", "template", "name", "if", "no", "template", "name", "is", "given", "returns", "true", "versionchanged", "2", "2", "autoescaping", "is", "now", "enabled", "by", "default", "for", "svg", "files", "versionadded", "0", "5", "if", "filename", "is", "none", "return", "true", "return", "filename", "endswith", "html", "htm", "xml", "xhtml", "svg"], "doc_len": 60}
{"doc_id": "src/flask/app.py::Flask.update_template_context", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "update_template_context", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def update_template_context(self, context: dict) -> None:\n        \"\"\"Update the template context with some commonly used variables.\n        This injects request, session, config and g into the template\n        context as well as everything template context processors want\n        to inject.  Note that the as of Flask 0.6, the original values\n        in the context will not be overridden if a context processor\n        decides to return a value with the same key.\n\n        :param context: the context as a dictionary that is updated in place\n                        to add extra variables.\n        \"\"\"\n        names: t.Iterable[t.Optional[str]] = (None,)\n\n        # A template may be rendered outside a request context.\n        if request:\n            names = chain(names, reversed(request.blueprints))\n\n        # The values passed to render_template take precedence. Keep a\n        # copy to re-apply after all context functions.\n        orig_ctx = context.copy()\n\n        for name in names:\n            if name in self.template_context_processors:\n                for func in self.template_context_processors[name]:\n                    context.update(func())\n\n        context.update(orig_ctx)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "update_template_context", "self", "context", "dict", "none", "update", "the", "template", "context", "with", "some", "commonly", "used", "variables", "this", "injects", "request", "session", "config", "and", "g", "into", "the", "template", "context", "as", "well", "as", "everything", "template", "context", "processors", "want", "to", "inject", "note", "that", "the", "as", "of", "flask", "0", "6", "the", "original", "values", "in", "the", "context", "will", "not", "be", "overridden", "if", "a", "context", "processor", "decides", "to", "return", "a", "value", "with", "the", "same", "key", "param", "context", "the", "context", "as", "a", "dictionary", "that", "is", "updated", "in", "place", "to", "add", "extra", "variables", "names", "t", "iterable", "t", "optional", "str", "none", "a", "template", "may", "be", "rendered", "outside", "a", "request", "context", "if", "request", "names", "chain", "names", "reversed", "request", "blueprints", "the", "values", "passed", "to", "render_template", "take", "precedence", "keep", "a", "copy", "to", "re", "apply", "after", "all", "context", "functions", "orig_ctx", "context", "copy", "for", "name", "in", "names", "if", "name", "in", "self", "template_context_processors", "for", "func", "in", "self", "template_context_processors", "name", "context", "update", "func", "context", "update", "orig_ctx"], "doc_len": 153}
{"doc_id": "src/flask/app.py::Flask.make_shell_context", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "make_shell_context", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def make_shell_context(self) -> dict:\n        \"\"\"Returns the shell context for an interactive shell for this\n        application.  This runs all the registered shell context\n        processors.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {\"app\": self, \"g\": g}\n        for processor in self.shell_context_processors:\n            rv.update(processor())\n        return rv\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "make_shell_context", "self", "dict", "returns", "the", "shell", "context", "for", "an", "interactive", "shell", "for", "this", "application", "this", "runs", "all", "the", "registered", "shell", "context", "processors", "versionadded", "0", "11", "rv", "app", "self", "g", "g", "for", "processor", "in", "self", "shell_context_processors", "rv", "update", "processor", "return", "rv"], "doc_len": 46}
{"doc_id": "src/flask/app.py::Flask.debug", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "debug", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def debug(self) -> bool:\n        \"\"\"Whether debug mode is enabled. When using ``flask run`` to start the\n        development server, an interactive debugger will be shown for unhandled\n        exceptions, and the server will be reloaded when code changes. This maps to the\n        :data:`DEBUG` config key. It may not behave as expected if set late.\n\n        **Do not enable debug mode when deploying in production.**\n\n        Default: ``False``\n        \"\"\"\n        return self.config[\"DEBUG\"]\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "debug", "self", "bool", "whether", "debug", "mode", "is", "enabled", "when", "using", "flask", "run", "to", "start", "the", "development", "server", "an", "interactive", "debugger", "will", "be", "shown", "for", "unhandled", "exceptions", "and", "the", "server", "will", "be", "reloaded", "when", "code", "changes", "this", "maps", "to", "the", "data", "debug", "config", "key", "it", "may", "not", "behave", "as", "expected", "if", "set", "late", "do", "not", "enable", "debug", "mode", "when", "deploying", "in", "production", "default", "false", "return", "self", "config", "debug"], "doc_len": 73}
{"doc_id": "src/flask/app.py::Flask.debug", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "debug", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def debug(self, value: bool) -> None:\n        self.config[\"DEBUG\"] = value\n\n        if self.config[\"TEMPLATES_AUTO_RELOAD\"] is None:\n            self.jinja_env.auto_reload = value\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "debug", "self", "value", "bool", "none", "self", "config", "debug", "value", "if", "self", "config", "templates_auto_reload", "is", "none", "self", "jinja_env", "auto_reload", "value"], "doc_len": 25}
{"doc_id": "src/flask/app.py::Flask.run", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "run", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def run(\n        self,\n        host: t.Optional[str] = None,\n        port: t.Optional[int] = None,\n        debug: t.Optional[bool] = None,\n        load_dotenv: bool = True,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Runs the application on a local development server.\n\n        Do not use ``run()`` in a production setting. It is not intended to\n        meet security and performance requirements for a production server.\n        Instead, see :doc:`/deploying/index` for WSGI server recommendations.\n\n        If the :attr:`debug` flag is set the server will automatically reload\n        for code changes and show a debugger in case an exception happened.\n\n        If you want to run the application in debug mode, but disable the\n        code execution on the interactive debugger, you can pass\n        ``use_evalex=False`` as parameter.  This will keep the debugger's\n        traceback screen active, but disable code execution.\n\n        It is not recommended to use this function for development with\n        automatic reloading as this is badly supported.  Instead you should\n        be using the :command:`flask` command line script's ``run`` support.\n\n        .. admonition:: Keep in Mind\n\n           Flask will suppress any server error with a generic error page\n           unless it is in debug mode.  As such to enable just the\n           interactive debugger without the code reloading, you have to\n           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.\n           Setting ``use_debugger`` to ``True`` without being in debug mode\n           won't catch any exceptions because there won't be any to\n           catch.\n\n        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to\n            have the server available externally as well. Defaults to\n            ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable\n            if present.\n        :param port: the port of the webserver. Defaults to ``5000`` or the\n            port defined in the ``SERVER_NAME`` config variable if present.\n        :param debug: if given, enable or disable debug mode. See\n            :attr:`debug`.\n        :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`\n            files to set environment variables. Will also change the working\n            directory to the directory containing the first file found.\n        :param options: the options to be forwarded to the underlying Werkzeug\n            server. See :func:`werkzeug.serving.run_simple` for more\n            information.\n\n        .. versionchanged:: 1.0\n            If installed, python-dotenv will be used to load environment\n            variables from :file:`.env` and :file:`.flaskenv` files.\n\n            The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.\n\n            Threaded mode is enabled by default.\n\n        .. versionchanged:: 0.10\n            The default port is now picked from the ``SERVER_NAME``\n            variable.\n        \"\"\"\n        # Ignore this call so that it doesn't start another server if\n        # the 'flask run' command is used.\n        if os.environ.get(\"FLASK_RUN_FROM_CLI\") == \"true\":\n            if not is_running_from_reloader():\n                click.secho(\n                    \" * Ignoring a call to 'app.run()' that would block\"\n                    \" the current 'flask' CLI command.\\n\"\n                    \"   Only call 'app.run()' in an 'if __name__ ==\"\n                    ' \"__main__\"\\' guard.',\n                    fg=\"red\",\n                )\n\n            return\n\n        if get_load_dotenv(load_dotenv):\n            cli.load_dotenv()\n\n            # if set, env var overrides existing value\n            if \"FLASK_DEBUG\" in os.environ:\n                self.debug = get_debug_flag()\n\n        # debug passed to method overrides all other sources\n        if debug is not None:\n            self.debug = bool(debug)\n\n        server_name = self.config.get(\"SERVER_NAME\")\n        sn_host = sn_port = None\n\n        if server_name:\n            sn_host, _, sn_port = server_name.partition(\":\")\n\n        if not host:\n            if sn_host:\n                host = sn_host\n            else:\n                host = \"127.0.0.1\"\n\n        if port or port == 0:\n            port = int(port)\n        elif sn_port:\n            port = int(sn_port)\n        else:\n            port = 5000\n\n        options.setdefault(\"use_reloader\", self.debug)\n        options.setdefault(\"use_debugger\", self.debug)\n        options.setdefault(\"threaded\", True)\n\n        cli.show_server_banner(self.debug, self.name)\n\n        from werkzeug.serving import run_simple\n\n        try:\n            run_simple(t.cast(str, host), port, self, **options)\n        finally:\n            # reset the first request information if the development server\n            # reset normally.  This makes it possible to restart the server\n            # without reloader and that stuff from an interactive shell.\n            self._got_first_request = False\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "run", "self", "host", "t", "optional", "str", "none", "port", "t", "optional", "int", "none", "debug", "t", "optional", "bool", "none", "load_dotenv", "bool", "true", "options", "t", "any", "none", "runs", "the", "application", "on", "a", "local", "development", "server", "do", "not", "use", "run", "in", "a", "production", "setting", "it", "is", "not", "intended", "to", "meet", "security", "and", "performance", "requirements", "for", "a", "production", "server", "instead", "see", "doc", "deploying", "index", "for", "wsgi", "server", "recommendations", "if", "the", "attr", "debug", "flag", "is", "set", "the", "server", "will", "automatically", "reload", "for", "code", "changes", "and", "show", "a", "debugger", "in", "case", "an", "exception", "happened", "if", "you", "want", "to", "run", "the", "application", "in", "debug", "mode", "but", "disable", "the", "code", "execution", "on", "the", "interactive", "debugger", "you", "can", "pass", "use_evalex", "false", "as", "parameter", "this", "will", "keep", "the", "debugger", "s", "traceback", "screen", "active", "but", "disable", "code", "execution", "it", "is", "not", "recommended", "to", "use", "this", "function", "for", "development", "with", "automatic", "reloading", "as", "this", "is", "badly", "supported", "instead", "you", "should", "be", "using", "the", "command", "flask", "command", "line", "script", "s", "run", "support", "admonition", "keep", "in", "mind", "flask", "will", "suppress", "any", "server", "error", "with", "a", "generic", "error", "page", "unless", "it", "is", "in", "debug", "mode", "as", "such", "to", "enable", "just", "the", "interactive", "debugger", "without", "the", "code", "reloading", "you", "have", "to", "invoke", "meth", "run", "with", "debug", "true", "and", "use_reloader", "false", "setting", "use_debugger", "to", "true", "without", "being", "in", "debug", "mode", "won", "t", "catch", "any", "exceptions", "because", "there", "won", "t", "be", "any", "to", "catch", "param", "host", "the", "hostname", "to", "listen", "on", "set", "this", "to", "0", "0", "0", "0", "to", "have", "the", "server", "available", "externally", "as", "well", "defaults", "to", "127", "0", "0", "1", "or", "the", "host", "in", "the", "server_name", "config", "variable", "if", "present", "param", "port", "the", "port", "of", "the", "webserver", "defaults", "to", "5000", "or", "the", "port", "defined", "in", "the", "server_name", "config", "variable", "if", "present", "param", "debug", "if", "given", "enable", "or", "disable", "debug", "mode", "see", "attr", "debug", "param", "load_dotenv", "load", "the", "nearest", "file", "env", "and", "file", "flaskenv", "files", "to", "set", "environment", "variables", "will", "also", "change", "the", "working", "directory", "to", "the", "directory", "containing", "the", "first", "file", "found", "param", "options", "the", "options", "to", "be", "forwarded", "to", "the", "underlying", "werkzeug", "server", "see", "func", "werkzeug", "serving", "run_simple", "for", "more", "information", "versionchanged", "1", "0", "if", "installed", "python", "dotenv", "will", "be", "used", "to", "load", "environment", "variables", "from", "file", "env", "and", "file", "flaskenv", "files", "the", "envvar", "flask_debug", "environment", "variable", "will", "override", "attr", "debug", "threaded", "mode", "is", "enabled", "by", "default", "versionchanged", "0", "10", "the", "default", "port", "is", "now", "picked", "from", "the", "server_name", "variable", "ignore", "this", "call", "so", "that", "it", "doesn", "t", "start", "another", "server", "if", "the", "flask", "run", "command", "is", "used", "if", "os", "environ", "get", "flask_run_from_cli", "true", "if", "not", "is_running_from_reloader", "click", "secho", "ignoring", "a", "call", "to", "app", "run", "that", "would", "block", "the", "current", "flask", "cli", "command", "n", "only", "call", "app", "run", "in", "an", "if", "__name__", "__main__", "guard", "fg", "red", "return", "if", "get_load_dotenv", "load_dotenv", "cli", "load_dotenv", "if", "set", "env", "var", "overrides", "existing", "value", "if", "flask_debug", "in", "os", "environ", "self", "debug", "get_debug_flag", "debug", "passed", "to", "method", "overrides", "all", "other", "sources", "if", "debug", "is", "not", "none", "self", "debug", "bool", "debug", "server_name", "self", "config", "get", "server_name", "sn_host", "sn_port", "none", "if", "server_name", "sn_host", "_", "sn_port", "server_name", "partition", "if", "not", "host", "if", "sn_host", "host", "sn_host", "else", "host", "127", "0", "0", "1", "if", "port", "or", "port", "0", "port", "int", "port", "elif", "sn_port", "port", "int", "sn_port", "else", "port", "5000", "options", "setdefault", "use_reloader", "self", "debug", "options", "setdefault", "use_debugger", "self", "debug", "options", "setdefault", "threaded", "true", "cli", "show_server_banner", "self", "debug", "self", "name", "from", "werkzeug", "serving", "import", "run_simple", "try", "run_simple", "t", "cast", "str", "host", "port", "self", "options", "finally", "reset", "the", "first", "request", "information", "if", "the", "development", "server", "reset", "normally", "this", "makes", "it", "possible", "to", "restart", "the", "server", "without", "reloader", "and", "that", "stuff", "from", "an", "interactive", "shell", "self", "_got_first_request", "false"], "doc_len": 604}
{"doc_id": "src/flask/app.py::Flask.test_client", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "test_client", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> \"FlaskClient\":\n        \"\"\"Creates a test client for this application.  For information\n        about unit testing head over to :doc:`/testing`.\n\n        Note that if you are testing for assertions or exceptions in your\n        application code, you must set ``app.testing = True`` in order for the\n        exceptions to propagate to the test client.  Otherwise, the exception\n        will be handled by the application (not visible to the test client) and\n        the only indication of an AssertionError or other exception will be a\n        500 status code response to the test client.  See the :attr:`testing`\n        attribute.  For example::\n\n            app.testing = True\n            client = app.test_client()\n\n        The test client can be used in a ``with`` block to defer the closing down\n        of the context until the end of the ``with`` block.  This is useful if\n        you want to access the context locals for testing::\n\n            with app.test_client() as c:\n                rv = c.get('/?vodka=42')\n                assert request.args['vodka'] == '42'\n\n        Additionally, you may pass optional keyword arguments that will then\n        be passed to the application's :attr:`test_client_class` constructor.\n        For example::\n\n            from flask.testing import FlaskClient\n\n            class CustomClient(FlaskClient):\n                def __init__(self, *args, **kwargs):\n                    self._authentication = kwargs.pop(\"authentication\")\n                    super(CustomClient,self).__init__( *args, **kwargs)\n\n            app.test_client_class = CustomClient\n            client = app.test_client(authentication='Basic ....')\n\n        See :class:`~flask.testing.FlaskClient` for more information.\n\n        .. versionchanged:: 0.4\n           added support for ``with`` block usage for the client.\n\n        .. versionadded:: 0.7\n           The `use_cookies` parameter was added as well as the ability\n           to override the client to be used by setting the\n           :attr:`test_client_class` attribute.\n\n        .. versionchanged:: 0.11\n           Added `**kwargs` to support passing additional keyword arguments to\n           the constructor of :attr:`test_client_class`.\n        \"\"\"\n        cls = self.test_client_class\n        if cls is None:\n            from .testing import FlaskClient as cls\n        return cls(  # type: ignore\n            self, self.response_class, use_cookies=use_cookies, **kwargs\n        )\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "test_client", "self", "use_cookies", "bool", "true", "kwargs", "t", "any", "flaskclient", "creates", "a", "test", "client", "for", "this", "application", "for", "information", "about", "unit", "testing", "head", "over", "to", "doc", "testing", "note", "that", "if", "you", "are", "testing", "for", "assertions", "or", "exceptions", "in", "your", "application", "code", "you", "must", "set", "app", "testing", "true", "in", "order", "for", "the", "exceptions", "to", "propagate", "to", "the", "test", "client", "otherwise", "the", "exception", "will", "be", "handled", "by", "the", "application", "not", "visible", "to", "the", "test", "client", "and", "the", "only", "indication", "of", "an", "assertionerror", "or", "other", "exception", "will", "be", "a", "500", "status", "code", "response", "to", "the", "test", "client", "see", "the", "attr", "testing", "attribute", "for", "example", "app", "testing", "true", "client", "app", "test_client", "the", "test", "client", "can", "be", "used", "in", "a", "with", "block", "to", "defer", "the", "closing", "down", "of", "the", "context", "until", "the", "end", "of", "the", "with", "block", "this", "is", "useful", "if", "you", "want", "to", "access", "the", "context", "locals", "for", "testing", "with", "app", "test_client", "as", "c", "rv", "c", "get", "vodka", "42", "assert", "request", "args", "vodka", "42", "additionally", "you", "may", "pass", "optional", "keyword", "arguments", "that", "will", "then", "be", "passed", "to", "the", "application", "s", "attr", "test_client_class", "constructor", "for", "example", "from", "flask", "testing", "import", "flaskclient", "class", "customclient", "flaskclient", "def", "__init__", "self", "args", "kwargs", "self", "_authentication", "kwargs", "pop", "authentication", "super", "customclient", "self", "__init__", "args", "kwargs", "app", "test_client_class", "customclient", "client", "app", "test_client", "authentication", "basic", "see", "class", "flask", "testing", "flaskclient", "for", "more", "information", "versionchanged", "0", "4", "added", "support", "for", "with", "block", "usage", "for", "the", "client", "versionadded", "0", "7", "the", "use_cookies", "parameter", "was", "added", "as", "well", "as", "the", "ability", "to", "override", "the", "client", "to", "be", "used", "by", "setting", "the", "attr", "test_client_class", "attribute", "versionchanged", "0", "11", "added", "kwargs", "to", "support", "passing", "additional", "keyword", "arguments", "to", "the", "constructor", "of", "attr", "test_client_class", "cls", "self", "test_client_class", "if", "cls", "is", "none", "from", "testing", "import", "flaskclient", "as", "cls", "return", "cls", "type", "ignore", "self", "self", "response_class", "use_cookies", "use_cookies", "kwargs"], "doc_len": 304}
{"doc_id": "src/flask/app.py::Flask.test_cli_runner", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "test_cli_runner", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def test_cli_runner(self, **kwargs: t.Any) -> \"FlaskCliRunner\":\n        \"\"\"Create a CLI runner for testing CLI commands.\n        See :ref:`testing-cli`.\n\n        Returns an instance of :attr:`test_cli_runner_class`, by default\n        :class:`~flask.testing.FlaskCliRunner`. The Flask app object is\n        passed as the first argument.\n\n        .. versionadded:: 1.0\n        \"\"\"\n        cls = self.test_cli_runner_class\n\n        if cls is None:\n            from .testing import FlaskCliRunner as cls\n\n        return cls(self, **kwargs)  # type: ignore\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "test_cli_runner", "self", "kwargs", "t", "any", "flaskclirunner", "create", "a", "cli", "runner", "for", "testing", "cli", "commands", "see", "ref", "testing", "cli", "returns", "an", "instance", "of", "attr", "test_cli_runner_class", "by", "default", "class", "flask", "testing", "flaskclirunner", "the", "flask", "app", "object", "is", "passed", "as", "the", "first", "argument", "versionadded", "1", "0", "cls", "self", "test_cli_runner_class", "if", "cls", "is", "none", "from", "testing", "import", "flaskclirunner", "as", "cls", "return", "cls", "self", "kwargs", "type", "ignore"], "doc_len": 68}
{"doc_id": "src/flask/app.py::Flask.register_blueprint", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "register_blueprint", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on the application. Keyword\n        arguments passed to this method will override the defaults set on the\n        blueprint.\n\n        Calls the blueprint's :meth:`~flask.Blueprint.register` method after\n        recording the blueprint in the application's :attr:`blueprints`.\n\n        :param blueprint: The blueprint to register.\n        :param url_prefix: Blueprint routes will be prefixed with this.\n        :param subdomain: Blueprint routes will match on this subdomain.\n        :param url_defaults: Blueprint routes will use these default values for\n            view arguments.\n        :param options: Additional keyword arguments are passed to\n            :class:`~flask.blueprints.BlueprintSetupState`. They can be\n            accessed in :meth:`~flask.Blueprint.record` callbacks.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        blueprint.register(self, options)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "register_blueprint", "self", "blueprint", "blueprint", "options", "t", "any", "none", "register", "a", "class", "flask", "blueprint", "on", "the", "application", "keyword", "arguments", "passed", "to", "this", "method", "will", "override", "the", "defaults", "set", "on", "the", "blueprint", "calls", "the", "blueprint", "s", "meth", "flask", "blueprint", "register", "method", "after", "recording", "the", "blueprint", "in", "the", "application", "s", "attr", "blueprints", "param", "blueprint", "the", "blueprint", "to", "register", "param", "url_prefix", "blueprint", "routes", "will", "be", "prefixed", "with", "this", "param", "subdomain", "blueprint", "routes", "will", "match", "on", "this", "subdomain", "param", "url_defaults", "blueprint", "routes", "will", "use", "these", "default", "values", "for", "view", "arguments", "param", "options", "additional", "keyword", "arguments", "are", "passed", "to", "class", "flask", "blueprints", "blueprintsetupstate", "they", "can", "be", "accessed", "in", "meth", "flask", "blueprint", "record", "callbacks", "versionchanged", "2", "0", "1", "the", "name", "option", "can", "be", "used", "to", "change", "the", "pre", "dotted", "name", "the", "blueprint", "is", "registered", "with", "this", "allows", "the", "same", "blueprint", "to", "be", "registered", "multiple", "times", "with", "unique", "names", "for", "url_for", "versionadded", "0", "7", "blueprint", "register", "self", "options"], "doc_len": 156}
{"doc_id": "src/flask/app.py::Flask.iter_blueprints", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "iter_blueprints", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def iter_blueprints(self) -> t.ValuesView[\"Blueprint\"]:\n        \"\"\"Iterates over all blueprints by the order they were registered.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.blueprints.values()\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "iter_blueprints", "self", "t", "valuesview", "blueprint", "iterates", "over", "all", "blueprints", "by", "the", "order", "they", "were", "registered", "versionadded", "0", "11", "return", "self", "blueprints", "values"], "doc_len": 28}
{"doc_id": "src/flask/app.py::Flask.add_url_rule", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "add_url_rule", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[ft.RouteCallable] = None,\n        provide_automatic_options: t.Optional[bool] = None,\n        **options: t.Any,\n    ) -> None:\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        options[\"endpoint\"] = endpoint\n        methods = options.pop(\"methods\", None)\n\n        # if the methods are not given and the view_func object knows its\n        # methods we can use that instead.  If neither exists, we go with\n        # a tuple of only ``GET`` as default.\n        if methods is None:\n            methods = getattr(view_func, \"methods\", None) or (\"GET\",)\n        if isinstance(methods, str):\n            raise TypeError(\n                \"Allowed methods must be a list of strings, for\"\n                ' example: @app.route(..., methods=[\"POST\"])'\n            )\n        methods = {item.upper() for item in methods}\n\n        # Methods that should always be added\n        required_methods = set(getattr(view_func, \"required_methods\", ()))\n\n        # starting with Flask 0.8 the view_func object can disable and\n        # force-enable the automatic options handling.\n        if provide_automatic_options is None:\n            provide_automatic_options = getattr(\n                view_func, \"provide_automatic_options\", None\n            )\n\n        if provide_automatic_options is None:\n            if \"OPTIONS\" not in methods:\n                provide_automatic_options = True\n                required_methods.add(\"OPTIONS\")\n            else:\n                provide_automatic_options = False\n\n        # Add the required methods now.\n        methods |= required_methods\n\n        rule = self.url_rule_class(rule, methods=methods, **options)\n        rule.provide_automatic_options = provide_automatic_options  # type: ignore\n\n        self.url_map.add(rule)\n        if view_func is not None:\n            old_func = self.view_functions.get(endpoint)\n            if old_func is not None and old_func != view_func:\n                raise AssertionError(\n                    \"View function mapping is overwriting an existing\"\n                    f\" endpoint function: {endpoint}\"\n                )\n            self.view_functions[endpoint] = view_func\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "add_url_rule", "self", "rule", "str", "endpoint", "t", "optional", "str", "none", "view_func", "t", "optional", "ft", "routecallable", "none", "provide_automatic_options", "t", "optional", "bool", "none", "options", "t", "any", "none", "if", "endpoint", "is", "none", "endpoint", "_endpoint_from_view_func", "view_func", "type", "ignore", "options", "endpoint", "endpoint", "methods", "options", "pop", "methods", "none", "if", "the", "methods", "are", "not", "given", "and", "the", "view_func", "object", "knows", "its", "methods", "we", "can", "use", "that", "instead", "if", "neither", "exists", "we", "go", "with", "a", "tuple", "of", "only", "get", "as", "default", "if", "methods", "is", "none", "methods", "getattr", "view_func", "methods", "none", "or", "get", "if", "isinstance", "methods", "str", "raise", "typeerror", "allowed", "methods", "must", "be", "a", "list", "of", "strings", "for", "example", "app", "route", "methods", "post", "methods", "item", "upper", "for", "item", "in", "methods", "methods", "that", "should", "always", "be", "added", "required_methods", "set", "getattr", "view_func", "required_methods", "starting", "with", "flask", "0", "8", "the", "view_func", "object", "can", "disable", "and", "force", "enable", "the", "automatic", "options", "handling", "if", "provide_automatic_options", "is", "none", "provide_automatic_options", "getattr", "view_func", "provide_automatic_options", "none", "if", "provide_automatic_options", "is", "none", "if", "options", "not", "in", "methods", "provide_automatic_options", "true", "required_methods", "add", "options", "else", "provide_automatic_options", "false", "add", "the", "required", "methods", "now", "methods", "required_methods", "rule", "self", "url_rule_class", "rule", "methods", "methods", "options", "rule", "provide_automatic_options", "provide_automatic_options", "type", "ignore", "self", "url_map", "add", "rule", "if", "view_func", "is", "not", "none", "old_func", "self", "view_functions", "get", "endpoint", "if", "old_func", "is", "not", "none", "and", "old_func", "view_func", "raise", "assertionerror", "view", "function", "mapping", "is", "overwriting", "an", "existing", "f", "endpoint", "function", "endpoint", "self", "view_functions", "endpoint", "view_func"], "doc_len": 228}
{"doc_id": "src/flask/app.py::Flask.template_filter", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "template_filter", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def template_filter(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"A decorator that is used to register custom template filter.\n        You can specify a name for the filter, otherwise the function\n        name will be used. Example::\n\n          @app.template_filter()\n          def reverse(s):\n              return s[::-1]\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_template_filter(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "template_filter", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_filter", "t_template_filter", "a", "decorator", "that", "is", "used", "to", "register", "custom", "template", "filter", "you", "can", "specify", "a", "name", "for", "the", "filter", "otherwise", "the", "function", "name", "will", "be", "used", "example", "app", "template_filter", "def", "reverse", "s", "return", "s", "1", "param", "name", "the", "optional", "name", "of", "the", "filter", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_filter", "t_template_filter", "self", "add_template_filter", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 80}
{"doc_id": "src/flask/app.py::Flask.add_template_filter", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "add_template_filter", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def add_template_filter(\n        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a custom template filter.  Works exactly like the\n        :meth:`template_filter` decorator.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.filters[name or f.__name__] = f\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "add_template_filter", "self", "f", "ft", "templatefiltercallable", "name", "t", "optional", "str", "none", "none", "register", "a", "custom", "template", "filter", "works", "exactly", "like", "the", "meth", "template_filter", "decorator", "param", "name", "the", "optional", "name", "of", "the", "filter", "otherwise", "the", "function", "name", "will", "be", "used", "self", "jinja_env", "filters", "name", "or", "f", "__name__", "f"], "doc_len": 52}
{"doc_id": "src/flask/app.py::Flask.template_test", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "template_test", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def template_test(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_test], T_template_test]:\n        \"\"\"A decorator that is used to register custom template test.\n        You can specify a name for the test, otherwise the function\n        name will be used. Example::\n\n          @app.template_test()\n          def is_prime(n):\n              if n == 2:\n                  return True\n              for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n                  if n % i == 0:\n                      return False\n              return True\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_template_test(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "template_test", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_test", "t_template_test", "a", "decorator", "that", "is", "used", "to", "register", "custom", "template", "test", "you", "can", "specify", "a", "name", "for", "the", "test", "otherwise", "the", "function", "name", "will", "be", "used", "example", "app", "template_test", "def", "is_prime", "n", "if", "n", "2", "return", "true", "for", "i", "in", "range", "2", "int", "math", "ceil", "math", "sqrt", "n", "1", "if", "n", "i", "0", "return", "false", "return", "true", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "test", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_test", "t_template_test", "self", "add_template_test", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 105}
{"doc_id": "src/flask/app.py::Flask.add_template_test", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "add_template_test", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def add_template_test(\n        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a custom template test.  Works exactly like the\n        :meth:`template_test` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.tests[name or f.__name__] = f\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "add_template_test", "self", "f", "ft", "templatetestcallable", "name", "t", "optional", "str", "none", "none", "register", "a", "custom", "template", "test", "works", "exactly", "like", "the", "meth", "template_test", "decorator", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "test", "otherwise", "the", "function", "name", "will", "be", "used", "self", "jinja_env", "tests", "name", "or", "f", "__name__", "f"], "doc_len": 55}
{"doc_id": "src/flask/app.py::Flask.template_global", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "template_global", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def template_global(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_global], T_template_global]:\n        \"\"\"A decorator that is used to register a custom template global function.\n        You can specify a name for the global function, otherwise the function\n        name will be used. Example::\n\n            @app.template_global()\n            def double(n):\n                return 2 * n\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_template_global(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "template_global", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_global", "t_template_global", "a", "decorator", "that", "is", "used", "to", "register", "a", "custom", "template", "global", "function", "you", "can", "specify", "a", "name", "for", "the", "global", "function", "otherwise", "the", "function", "name", "will", "be", "used", "example", "app", "template_global", "def", "double", "n", "return", "2", "n", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "global", "function", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_global", "t_template_global", "self", "add_template_global", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 87}
{"doc_id": "src/flask/app.py::Flask.add_template_global", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "add_template_global", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def add_template_global(\n        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a custom template global function. Works exactly like the\n        :meth:`template_global` decorator.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global function, otherwise the\n                     function name will be used.\n        \"\"\"\n        self.jinja_env.globals[name or f.__name__] = f\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "add_template_global", "self", "f", "ft", "templateglobalcallable", "name", "t", "optional", "str", "none", "none", "register", "a", "custom", "template", "global", "function", "works", "exactly", "like", "the", "meth", "template_global", "decorator", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "global", "function", "otherwise", "the", "function", "name", "will", "be", "used", "self", "jinja_env", "globals", "name", "or", "f", "__name__", "f"], "doc_len": 57}
{"doc_id": "src/flask/app.py::Flask.teardown_appcontext", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "teardown_appcontext", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def teardown_appcontext(self, f: T_teardown) -> T_teardown:\n        \"\"\"Registers a function to be called when the application\n        context is popped. The application context is typically popped\n        after the request context for each request, at the end of CLI\n        commands, or after a manually pushed context ends.\n\n        .. code-block:: python\n\n            with app.app_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the app context is\n        made inactive. Since a request context typically also manages an\n        application context it would also be called when you pop a\n        request context.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        self.teardown_appcontext_funcs.append(f)\n        return f\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "teardown_appcontext", "self", "f", "t_teardown", "t_teardown", "registers", "a", "function", "to", "be", "called", "when", "the", "application", "context", "is", "popped", "the", "application", "context", "is", "typically", "popped", "after", "the", "request", "context", "for", "each", "request", "at", "the", "end", "of", "cli", "commands", "or", "after", "a", "manually", "pushed", "context", "ends", "code", "block", "python", "with", "app", "app_context", "when", "the", "with", "block", "exits", "or", "ctx", "pop", "is", "called", "the", "teardown", "functions", "are", "called", "just", "before", "the", "app", "context", "is", "made", "inactive", "since", "a", "request", "context", "typically", "also", "manages", "an", "application", "context", "it", "would", "also", "be", "called", "when", "you", "pop", "a", "request", "context", "when", "a", "teardown", "function", "was", "called", "because", "of", "an", "unhandled", "exception", "it", "will", "be", "passed", "an", "error", "object", "if", "an", "meth", "errorhandler", "is", "registered", "it", "will", "handle", "the", "exception", "and", "the", "teardown", "will", "not", "receive", "it", "teardown", "functions", "must", "avoid", "raising", "exceptions", "if", "they", "execute", "code", "that", "might", "fail", "they", "must", "surround", "that", "code", "with", "a", "try", "except", "block", "and", "log", "any", "errors", "the", "return", "values", "of", "teardown", "functions", "are", "ignored", "versionadded", "0", "9", "self", "teardown_appcontext_funcs", "append", "f", "return", "f"], "doc_len": 179}
{"doc_id": "src/flask/app.py::Flask.shell_context_processor", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "shell_context_processor", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def shell_context_processor(\n        self, f: T_shell_context_processor\n    ) -> T_shell_context_processor:\n        \"\"\"Registers a shell context processor function.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        self.shell_context_processors.append(f)\n        return f\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "shell_context_processor", "self", "f", "t_shell_context_processor", "t_shell_context_processor", "registers", "a", "shell", "context", "processor", "function", "versionadded", "0", "11", "self", "shell_context_processors", "append", "f", "return", "f"], "doc_len": 26}
{"doc_id": "src/flask/app.py::Flask._find_error_handler", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "_find_error_handler", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def _find_error_handler(self, e: Exception) -> t.Optional[ft.ErrorHandlerCallable]:\n        \"\"\"Return a registered error handler for an exception in this order:\n        blueprint handler for a specific code, app handler for a specific code,\n        blueprint handler for an exception class, app handler for an exception\n        class, or ``None`` if a suitable handler is not found.\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(type(e))\n        names = (*request.blueprints, None)\n\n        for c in (code, None) if code is not None else (None,):\n            for name in names:\n                handler_map = self.error_handler_spec[name][c]\n\n                if not handler_map:\n                    continue\n\n                for cls in exc_class.__mro__:\n                    handler = handler_map.get(cls)\n\n                    if handler is not None:\n                        return handler\n        return None\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "_find_error_handler", "self", "e", "exception", "t", "optional", "ft", "errorhandlercallable", "return", "a", "registered", "error", "handler", "for", "an", "exception", "in", "this", "order", "blueprint", "handler", "for", "a", "specific", "code", "app", "handler", "for", "a", "specific", "code", "blueprint", "handler", "for", "an", "exception", "class", "app", "handler", "for", "an", "exception", "class", "or", "none", "if", "a", "suitable", "handler", "is", "not", "found", "exc_class", "code", "self", "_get_exc_class_and_code", "type", "e", "names", "request", "blueprints", "none", "for", "c", "in", "code", "none", "if", "code", "is", "not", "none", "else", "none", "for", "name", "in", "names", "handler_map", "self", "error_handler_spec", "name", "c", "if", "not", "handler_map", "continue", "for", "cls", "in", "exc_class", "__mro__", "handler", "handler_map", "get", "cls", "if", "handler", "is", "not", "none", "return", "handler", "return", "none"], "doc_len": 111}
{"doc_id": "src/flask/app.py::Flask.handle_http_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "handle_http_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def handle_http_exception(\n        self, e: HTTPException\n    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:\n        \"\"\"Handles an HTTP exception.  By default this will invoke the\n        registered error handlers and fall back to returning the\n        exception as response.\n\n        .. versionchanged:: 1.0.3\n            ``RoutingException``, used internally for actions such as\n             slash redirects during routing, is not passed to error\n             handlers.\n\n        .. versionchanged:: 1.0\n            Exceptions are looked up by code *and* by MRO, so\n            ``HTTPException`` subclasses can be handled with a catch-all\n            handler for the base ``HTTPException``.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        # Proxy exceptions don't have error codes.  We want to always return\n        # those unchanged as errors\n        if e.code is None:\n            return e\n\n        # RoutingExceptions are used internally to trigger routing\n        # actions, such as slash redirects raising RequestRedirect. They\n        # are not raised or handled in user code.\n        if isinstance(e, RoutingException):\n            return e\n\n        handler = self._find_error_handler(e)\n        if handler is None:\n            return e\n        return self.ensure_sync(handler)(e)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "handle_http_exception", "self", "e", "httpexception", "t", "union", "httpexception", "ft", "responsereturnvalue", "handles", "an", "http", "exception", "by", "default", "this", "will", "invoke", "the", "registered", "error", "handlers", "and", "fall", "back", "to", "returning", "the", "exception", "as", "response", "versionchanged", "1", "0", "3", "routingexception", "used", "internally", "for", "actions", "such", "as", "slash", "redirects", "during", "routing", "is", "not", "passed", "to", "error", "handlers", "versionchanged", "1", "0", "exceptions", "are", "looked", "up", "by", "code", "and", "by", "mro", "so", "httpexception", "subclasses", "can", "be", "handled", "with", "a", "catch", "all", "handler", "for", "the", "base", "httpexception", "versionadded", "0", "3", "proxy", "exceptions", "don", "t", "have", "error", "codes", "we", "want", "to", "always", "return", "those", "unchanged", "as", "errors", "if", "e", "code", "is", "none", "return", "e", "routingexceptions", "are", "used", "internally", "to", "trigger", "routing", "actions", "such", "as", "slash", "redirects", "raising", "requestredirect", "they", "are", "not", "raised", "or", "handled", "in", "user", "code", "if", "isinstance", "e", "routingexception", "return", "e", "handler", "self", "_find_error_handler", "e", "if", "handler", "is", "none", "return", "e", "return", "self", "ensure_sync", "handler", "e"], "doc_len": 155}
{"doc_id": "src/flask/app.py::Flask.trap_http_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "trap_http_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def trap_http_exception(self, e: Exception) -> bool:\n        \"\"\"Checks if an HTTP exception should be trapped or not.  By default\n        this will return ``False`` for all exceptions except for a bad request\n        key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It\n        also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.\n\n        This is called for all HTTP exceptions raised by a view function.\n        If it returns ``True`` for any exception the error handler for this\n        exception is not called and it shows up as regular exception in the\n        traceback.  This is helpful for debugging implicitly raised HTTP\n        exceptions.\n\n        .. versionchanged:: 1.0\n            Bad request errors are not trapped by default in debug mode.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        if self.config[\"TRAP_HTTP_EXCEPTIONS\"]:\n            return True\n\n        trap_bad_request = self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n\n        # if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None\n            and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:\n            return isinstance(e, BadRequest)\n\n        return False\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "trap_http_exception", "self", "e", "exception", "bool", "checks", "if", "an", "http", "exception", "should", "be", "trapped", "or", "not", "by", "default", "this", "will", "return", "false", "for", "all", "exceptions", "except", "for", "a", "bad", "request", "key", "error", "if", "trap_bad_request_errors", "is", "set", "to", "true", "it", "also", "returns", "true", "if", "trap_http_exceptions", "is", "set", "to", "true", "this", "is", "called", "for", "all", "http", "exceptions", "raised", "by", "a", "view", "function", "if", "it", "returns", "true", "for", "any", "exception", "the", "error", "handler", "for", "this", "exception", "is", "not", "called", "and", "it", "shows", "up", "as", "regular", "exception", "in", "the", "traceback", "this", "is", "helpful", "for", "debugging", "implicitly", "raised", "http", "exceptions", "versionchanged", "1", "0", "bad", "request", "errors", "are", "not", "trapped", "by", "default", "in", "debug", "mode", "versionadded", "0", "8", "if", "self", "config", "trap_http_exceptions", "return", "true", "trap_bad_request", "self", "config", "trap_bad_request_errors", "if", "unset", "trap", "key", "errors", "in", "debug", "mode", "if", "trap_bad_request", "is", "none", "and", "self", "debug", "and", "isinstance", "e", "badrequestkeyerror", "return", "true", "if", "trap_bad_request", "return", "isinstance", "e", "badrequest", "return", "false"], "doc_len": 156}
{"doc_id": "src/flask/app.py::Flask.handle_user_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "handle_user_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def handle_user_exception(\n        self, e: Exception\n    ) -> t.Union[HTTPException, ft.ResponseReturnValue]:\n        \"\"\"This method is called whenever an exception occurs that\n        should be handled. A special case is :class:`~werkzeug\n        .exceptions.HTTPException` which is forwarded to the\n        :meth:`handle_http_exception` method. This function will either\n        return a response value or reraise the exception with the same\n        traceback.\n\n        .. versionchanged:: 1.0\n            Key errors raised from request data like ``form`` show the\n            bad key in debug mode rather than a generic bad request\n            message.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        if isinstance(e, BadRequestKeyError) and (\n            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]\n        ):\n            e.show_exception = True\n\n        if isinstance(e, HTTPException) and not self.trap_http_exception(e):\n            return self.handle_http_exception(e)\n\n        handler = self._find_error_handler(e)\n\n        if handler is None:\n            raise\n\n        return self.ensure_sync(handler)(e)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "handle_user_exception", "self", "e", "exception", "t", "union", "httpexception", "ft", "responsereturnvalue", "this", "method", "is", "called", "whenever", "an", "exception", "occurs", "that", "should", "be", "handled", "a", "special", "case", "is", "class", "werkzeug", "exceptions", "httpexception", "which", "is", "forwarded", "to", "the", "meth", "handle_http_exception", "method", "this", "function", "will", "either", "return", "a", "response", "value", "or", "reraise", "the", "exception", "with", "the", "same", "traceback", "versionchanged", "1", "0", "key", "errors", "raised", "from", "request", "data", "like", "form", "show", "the", "bad", "key", "in", "debug", "mode", "rather", "than", "a", "generic", "bad", "request", "message", "versionadded", "0", "7", "if", "isinstance", "e", "badrequestkeyerror", "and", "self", "debug", "or", "self", "config", "trap_bad_request_errors", "e", "show_exception", "true", "if", "isinstance", "e", "httpexception", "and", "not", "self", "trap_http_exception", "e", "return", "self", "handle_http_exception", "e", "handler", "self", "_find_error_handler", "e", "if", "handler", "is", "none", "raise", "return", "self", "ensure_sync", "handler", "e"], "doc_len": 128}
{"doc_id": "src/flask/app.py::Flask.handle_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "handle_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def handle_exception(self, e: Exception) -> Response:\n        \"\"\"Handle an exception that did not have an error handler\n        associated with it, or that was raised from an error handler.\n        This always causes a 500 ``InternalServerError``.\n\n        Always sends the :data:`got_request_exception` signal.\n\n        If :data:`PROPAGATE_EXCEPTIONS` is ``True``, such as in debug\n        mode, the error will be re-raised so that the debugger can\n        display it. Otherwise, the original exception is logged, and\n        an :exc:`~werkzeug.exceptions.InternalServerError` is returned.\n\n        If an error handler is registered for ``InternalServerError`` or\n        ``500``, it will be used. For consistency, the handler will\n        always receive the ``InternalServerError``. The original\n        unhandled exception is available as ``e.original_exception``.\n\n        .. versionchanged:: 1.1.0\n            Always passes the ``InternalServerError`` instance to the\n            handler, setting ``original_exception`` to the unhandled\n            error.\n\n        .. versionchanged:: 1.1.0\n            ``after_request`` functions and other finalization is done\n            even for the default 500 response when there is no handler.\n\n        .. versionadded:: 0.3\n        \"\"\"\n        exc_info = sys.exc_info()\n        got_request_exception.send(self, exception=e)\n        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]\n\n        if propagate is None:\n            propagate = self.testing or self.debug\n\n        if propagate:\n            # Re-raise if called with an active exception, otherwise\n            # raise the passed in exception.\n            if exc_info[1] is e:\n                raise\n\n            raise e\n\n        self.log_exception(exc_info)\n        server_error: t.Union[InternalServerError, ft.ResponseReturnValue]\n        server_error = InternalServerError(original_exception=e)\n        handler = self._find_error_handler(server_error)\n\n        if handler is not None:\n            server_error = self.ensure_sync(handler)(server_error)\n\n        return self.finalize_request(server_error, from_error_handler=True)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "handle_exception", "self", "e", "exception", "response", "handle", "an", "exception", "that", "did", "not", "have", "an", "error", "handler", "associated", "with", "it", "or", "that", "was", "raised", "from", "an", "error", "handler", "this", "always", "causes", "a", "500", "internalservererror", "always", "sends", "the", "data", "got_request_exception", "signal", "if", "data", "propagate_exceptions", "is", "true", "such", "as", "in", "debug", "mode", "the", "error", "will", "be", "re", "raised", "so", "that", "the", "debugger", "can", "display", "it", "otherwise", "the", "original", "exception", "is", "logged", "and", "an", "exc", "werkzeug", "exceptions", "internalservererror", "is", "returned", "if", "an", "error", "handler", "is", "registered", "for", "internalservererror", "or", "500", "it", "will", "be", "used", "for", "consistency", "the", "handler", "will", "always", "receive", "the", "internalservererror", "the", "original", "unhandled", "exception", "is", "available", "as", "e", "original_exception", "versionchanged", "1", "1", "0", "always", "passes", "the", "internalservererror", "instance", "to", "the", "handler", "setting", "original_exception", "to", "the", "unhandled", "error", "versionchanged", "1", "1", "0", "after_request", "functions", "and", "other", "finalization", "is", "done", "even", "for", "the", "default", "500", "response", "when", "there", "is", "no", "handler", "versionadded", "0", "3", "exc_info", "sys", "exc_info", "got_request_exception", "send", "self", "exception", "e", "propagate", "self", "config", "propagate_exceptions", "if", "propagate", "is", "none", "propagate", "self", "testing", "or", "self", "debug", "if", "propagate", "re", "raise", "if", "called", "with", "an", "active", "exception", "otherwise", "raise", "the", "passed", "in", "exception", "if", "exc_info", "1", "is", "e", "raise", "raise", "e", "self", "log_exception", "exc_info", "server_error", "t", "union", "internalservererror", "ft", "responsereturnvalue", "server_error", "internalservererror", "original_exception", "e", "handler", "self", "_find_error_handler", "server_error", "if", "handler", "is", "not", "none", "server_error", "self", "ensure_sync", "handler", "server_error", "return", "self", "finalize_request", "server_error", "from_error_handler", "true"], "doc_len": 235}
{"doc_id": "src/flask/app.py::Flask.log_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "log_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def log_exception(\n        self,\n        exc_info: t.Union[\n            t.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]\n        ],\n    ) -> None:\n        \"\"\"Logs an exception.  This is called by :meth:`handle_exception`\n        if debugging is disabled and right before the handler is called.\n        The default implementation logs the exception as error on the\n        :attr:`logger`.\n\n        .. versionadded:: 0.8\n        \"\"\"\n        self.logger.error(\n            f\"Exception on {request.path} [{request.method}]\", exc_info=exc_info\n        )\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "log_exception", "self", "exc_info", "t", "union", "t", "tuple", "type", "baseexception", "tracebacktype", "t", "tuple", "none", "none", "none", "none", "logs", "an", "exception", "this", "is", "called", "by", "meth", "handle_exception", "if", "debugging", "is", "disabled", "and", "right", "before", "the", "handler", "is", "called", "the", "default", "implementation", "logs", "the", "exception", "as", "error", "on", "the", "attr", "logger", "versionadded", "0", "8", "self", "logger", "error", "f", "exception", "on", "request", "path", "request", "method", "exc_info", "exc_info"], "doc_len": 69}
{"doc_id": "src/flask/app.py::Flask.raise_routing_exception", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "raise_routing_exception", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def raise_routing_exception(self, request: Request) -> \"te.NoReturn\":\n        \"\"\"Intercept routing exceptions and possibly do something else.\n\n        In debug mode, intercept a routing redirect and replace it with\n        an error if the body will be discarded.\n\n        With modern Werkzeug this shouldn't occur, since it now uses a\n        308 status which tells the browser to resend the method and\n        body.\n\n        .. versionchanged:: 2.1\n            Don't intercept 307 and 308 redirects.\n\n        :meta private:\n        :internal:\n        \"\"\"\n        if (\n            not self.debug\n            or not isinstance(request.routing_exception, RequestRedirect)\n            or request.routing_exception.code in {307, 308}\n            or request.method in {\"GET\", \"HEAD\", \"OPTIONS\"}\n        ):\n            raise request.routing_exception  # type: ignore\n\n        from .debughelpers import FormDataRoutingRedirect\n\n        raise FormDataRoutingRedirect(request)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "raise_routing_exception", "self", "request", "request", "te", "noreturn", "intercept", "routing", "exceptions", "and", "possibly", "do", "something", "else", "in", "debug", "mode", "intercept", "a", "routing", "redirect", "and", "replace", "it", "with", "an", "error", "if", "the", "body", "will", "be", "discarded", "with", "modern", "werkzeug", "this", "shouldn", "t", "occur", "since", "it", "now", "uses", "a", "308", "status", "which", "tells", "the", "browser", "to", "resend", "the", "method", "and", "body", "versionchanged", "2", "1", "don", "t", "intercept", "307", "and", "308", "redirects", "meta", "private", "internal", "if", "not", "self", "debug", "or", "not", "isinstance", "request", "routing_exception", "requestredirect", "or", "request", "routing_exception", "code", "in", "307", "308", "or", "request", "method", "in", "get", "head", "options", "raise", "request", "routing_exception", "type", "ignore", "from", "debughelpers", "import", "formdataroutingredirect", "raise", "formdataroutingredirect", "request"], "doc_len": 112}
{"doc_id": "src/flask/app.py::Flask.dispatch_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "dispatch_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"Does the request dispatching.  Matches the URL and returns the\n        return value of the view or error handler.  This does not have to\n        be a response object.  In order to convert the return value to a\n        proper response object, call :func:`make_response`.\n\n        .. versionchanged:: 0.7\n           This no longer does the exception handling, this code was\n           moved to the new :meth:`full_dispatch_request`.\n        \"\"\"\n        req = request_ctx.request\n        if req.routing_exception is not None:\n            self.raise_routing_exception(req)\n        rule: Rule = req.url_rule  # type: ignore[assignment]\n        # if we provide automatic options for this URL and the\n        # request came with the OPTIONS method, reply automatically\n        if (\n            getattr(rule, \"provide_automatic_options\", False)\n            and req.method == \"OPTIONS\"\n        ):\n            return self.make_default_options_response()\n        # otherwise dispatch to the handler for that endpoint\n        view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]\n        return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "dispatch_request", "self", "ft", "responsereturnvalue", "does", "the", "request", "dispatching", "matches", "the", "url", "and", "returns", "the", "return", "value", "of", "the", "view", "or", "error", "handler", "this", "does", "not", "have", "to", "be", "a", "response", "object", "in", "order", "to", "convert", "the", "return", "value", "to", "a", "proper", "response", "object", "call", "func", "make_response", "versionchanged", "0", "7", "this", "no", "longer", "does", "the", "exception", "handling", "this", "code", "was", "moved", "to", "the", "new", "meth", "full_dispatch_request", "req", "request_ctx", "request", "if", "req", "routing_exception", "is", "not", "none", "self", "raise_routing_exception", "req", "rule", "rule", "req", "url_rule", "type", "ignore", "assignment", "if", "we", "provide", "automatic", "options", "for", "this", "url", "and", "the", "request", "came", "with", "the", "options", "method", "reply", "automatically", "if", "getattr", "rule", "provide_automatic_options", "false", "and", "req", "method", "options", "return", "self", "make_default_options_response", "otherwise", "dispatch", "to", "the", "handler", "for", "that", "endpoint", "view_args", "t", "dict", "str", "t", "any", "req", "view_args", "type", "ignore", "assignment", "return", "self", "ensure_sync", "self", "view_functions", "rule", "endpoint", "view_args"], "doc_len": 147}
{"doc_id": "src/flask/app.py::Flask.full_dispatch_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "full_dispatch_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def full_dispatch_request(self) -> Response:\n        \"\"\"Dispatches the request and on top of that performs request\n        pre and postprocessing as well as HTTP exception catching and\n        error handling.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        self._got_first_request = True\n\n        try:\n            request_started.send(self)\n            rv = self.preprocess_request()\n            if rv is None:\n                rv = self.dispatch_request()\n        except Exception as e:\n            rv = self.handle_user_exception(e)\n        return self.finalize_request(rv)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "full_dispatch_request", "self", "response", "dispatches", "the", "request", "and", "on", "top", "of", "that", "performs", "request", "pre", "and", "postprocessing", "as", "well", "as", "http", "exception", "catching", "and", "error", "handling", "versionadded", "0", "7", "self", "_got_first_request", "true", "try", "request_started", "send", "self", "rv", "self", "preprocess_request", "if", "rv", "is", "none", "rv", "self", "dispatch_request", "except", "exception", "as", "e", "rv", "self", "handle_user_exception", "e", "return", "self", "finalize_request", "rv"], "doc_len": 63}
{"doc_id": "src/flask/app.py::Flask.finalize_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "finalize_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def finalize_request(\n        self,\n        rv: t.Union[ft.ResponseReturnValue, HTTPException],\n        from_error_handler: bool = False,\n    ) -> Response:\n        \"\"\"Given the return value from a view function this finalizes\n        the request by converting it into a response and invoking the\n        postprocessing functions.  This is invoked for both normal\n        request dispatching as well as error handlers.\n\n        Because this means that it might be called as a result of a\n        failure a special safe mode is available which can be enabled\n        with the `from_error_handler` flag.  If enabled, failures in\n        response processing will be logged and otherwise ignored.\n\n        :internal:\n        \"\"\"\n        response = self.make_response(rv)\n        try:\n            response = self.process_response(response)\n            request_finished.send(self, response=response)\n        except Exception:\n            if not from_error_handler:\n                raise\n            self.logger.exception(\n                \"Request finalizing failed with an error while handling an error\"\n            )\n        return response\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "finalize_request", "self", "rv", "t", "union", "ft", "responsereturnvalue", "httpexception", "from_error_handler", "bool", "false", "response", "given", "the", "return", "value", "from", "a", "view", "function", "this", "finalizes", "the", "request", "by", "converting", "it", "into", "a", "response", "and", "invoking", "the", "postprocessing", "functions", "this", "is", "invoked", "for", "both", "normal", "request", "dispatching", "as", "well", "as", "error", "handlers", "because", "this", "means", "that", "it", "might", "be", "called", "as", "a", "result", "of", "a", "failure", "a", "special", "safe", "mode", "is", "available", "which", "can", "be", "enabled", "with", "the", "from_error_handler", "flag", "if", "enabled", "failures", "in", "response", "processing", "will", "be", "logged", "and", "otherwise", "ignored", "internal", "response", "self", "make_response", "rv", "try", "response", "self", "process_response", "response", "request_finished", "send", "self", "response", "response", "except", "exception", "if", "not", "from_error_handler", "raise", "self", "logger", "exception", "request", "finalizing", "failed", "with", "an", "error", "while", "handling", "an", "error", "return", "response"], "doc_len": 130}
{"doc_id": "src/flask/app.py::Flask.make_default_options_response", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "make_default_options_response", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def make_default_options_response(self) -> Response:\n        \"\"\"This method is called to create the default ``OPTIONS`` response.\n        This can be changed through subclassing to change the default\n        behavior of ``OPTIONS`` responses.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        adapter = request_ctx.url_adapter\n        methods = adapter.allowed_methods()  # type: ignore[union-attr]\n        rv = self.response_class()\n        rv.allow.update(methods)\n        return rv\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "make_default_options_response", "self", "response", "this", "method", "is", "called", "to", "create", "the", "default", "options", "response", "this", "can", "be", "changed", "through", "subclassing", "to", "change", "the", "default", "behavior", "of", "options", "responses", "versionadded", "0", "7", "adapter", "request_ctx", "url_adapter", "methods", "adapter", "allowed_methods", "type", "ignore", "union", "attr", "rv", "self", "response_class", "rv", "allow", "update", "methods", "return", "rv"], "doc_len": 55}
{"doc_id": "src/flask/app.py::Flask.should_ignore_error", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "should_ignore_error", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def should_ignore_error(self, error: t.Optional[BaseException]) -> bool:\n        \"\"\"This is called to figure out if an error should be ignored\n        or not as far as the teardown system is concerned.  If this\n        function returns ``True`` then the teardown handlers will not be\n        passed the error.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return False\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "should_ignore_error", "self", "error", "t", "optional", "baseexception", "bool", "this", "is", "called", "to", "figure", "out", "if", "an", "error", "should", "be", "ignored", "or", "not", "as", "far", "as", "the", "teardown", "system", "is", "concerned", "if", "this", "function", "returns", "true", "then", "the", "teardown", "handlers", "will", "not", "be", "passed", "the", "error", "versionadded", "0", "10", "return", "false"], "doc_len": 55}
{"doc_id": "src/flask/app.py::Flask.ensure_sync", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "ensure_sync", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def ensure_sync(self, func: t.Callable) -> t.Callable:\n        \"\"\"Ensure that the function is synchronous for WSGI workers.\n        Plain ``def`` functions are returned as-is. ``async def``\n        functions are wrapped to run and wait for the response.\n\n        Override this method to change how the app runs async views.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if iscoroutinefunction(func):\n            return self.async_to_sync(func)\n\n        return func\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "ensure_sync", "self", "func", "t", "callable", "t", "callable", "ensure", "that", "the", "function", "is", "synchronous", "for", "wsgi", "workers", "plain", "def", "functions", "are", "returned", "as", "is", "async", "def", "functions", "are", "wrapped", "to", "run", "and", "wait", "for", "the", "response", "override", "this", "method", "to", "change", "how", "the", "app", "runs", "async", "views", "versionadded", "2", "0", "if", "iscoroutinefunction", "func", "return", "self", "async_to_sync", "func", "return", "func"], "doc_len": 64}
{"doc_id": "src/flask/app.py::Flask.async_to_sync", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "async_to_sync", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def async_to_sync(\n        self, func: t.Callable[..., t.Coroutine]\n    ) -> t.Callable[..., t.Any]:\n        \"\"\"Return a sync function that will run the coroutine function.\n\n        .. code-block:: python\n\n            result = app.async_to_sync(func)(*args, **kwargs)\n\n        Override this method to change how the app converts async code\n        to be synchronously callable.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        try:\n            from asgiref.sync import async_to_sync as asgiref_async_to_sync\n        except ImportError:\n            raise RuntimeError(\n                \"Install Flask with the 'async' extra in order to use async views.\"\n            ) from None\n\n        return asgiref_async_to_sync(func)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "async_to_sync", "self", "func", "t", "callable", "t", "coroutine", "t", "callable", "t", "any", "return", "a", "sync", "function", "that", "will", "run", "the", "coroutine", "function", "code", "block", "python", "result", "app", "async_to_sync", "func", "args", "kwargs", "override", "this", "method", "to", "change", "how", "the", "app", "converts", "async", "code", "to", "be", "synchronously", "callable", "versionadded", "2", "0", "try", "from", "asgiref", "sync", "import", "async_to_sync", "as", "asgiref_async_to_sync", "except", "importerror", "raise", "runtimeerror", "install", "flask", "with", "the", "async", "extra", "in", "order", "to", "use", "async", "views", "from", "none", "return", "asgiref_async_to_sync", "func"], "doc_len": 83}
{"doc_id": "src/flask/app.py::Flask.url_for", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "url_for", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def url_for(\n        self,\n        endpoint: str,\n        *,\n        _anchor: t.Optional[str] = None,\n        _method: t.Optional[str] = None,\n        _scheme: t.Optional[str] = None,\n        _external: t.Optional[bool] = None,\n        **values: t.Any,\n    ) -> str:\n        \"\"\"Generate a URL to the given endpoint with the given values.\n\n        This is called by :func:`flask.url_for`, and can be called\n        directly as well.\n\n        An *endpoint* is the name of a URL rule, usually added with\n        :meth:`@app.route() <route>`, and usually the same name as the\n        view function. A route defined in a :class:`~flask.Blueprint`\n        will prepend the blueprint's name separated by a ``.`` to the\n        endpoint.\n\n        In some cases, such as email messages, you want URLs to include\n        the scheme and domain, like ``https://example.com/hello``. When\n        not in an active request, URLs will be external by default, but\n        this requires setting :data:`SERVER_NAME` so Flask knows what\n        domain to use. :data:`APPLICATION_ROOT` and\n        :data:`PREFERRED_URL_SCHEME` should also be configured as\n        needed. This config is only used when not in an active request.\n\n        Functions can be decorated with :meth:`url_defaults` to modify\n        keyword arguments before the URL is built.\n\n        If building fails for some reason, such as an unknown endpoint\n        or incorrect values, the app's :meth:`handle_url_build_error`\n        method is called. If that returns a string, that is returned,\n        otherwise a :exc:`~werkzeug.routing.BuildError` is raised.\n\n        :param endpoint: The endpoint name associated with the URL to\n            generate. If this starts with a ``.``, the current blueprint\n            name (if any) will be used.\n        :param _anchor: If given, append this as ``#anchor`` to the URL.\n        :param _method: If given, generate the URL associated with this\n            method for the endpoint.\n        :param _scheme: If given, the URL will have this scheme if it\n            is external.\n        :param _external: If given, prefer the URL to be internal\n            (False) or require it to be external (True). External URLs\n            include the scheme and domain. When not in an active\n            request, URLs are external by default.\n        :param values: Values to use for the variable parts of the URL\n            rule. Unknown keys are appended as query string arguments,\n            like ``?a=b&c=d``.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.url_for``, which calls this method.\n        \"\"\"\n        req_ctx = _cv_request.get(None)\n\n        if req_ctx is not None:\n            url_adapter = req_ctx.url_adapter\n            blueprint_name = req_ctx.request.blueprint\n\n            # If the endpoint starts with \".\" and the request matches a\n            # blueprint, the endpoint is relative to the blueprint.\n            if endpoint[:1] == \".\":\n                if blueprint_name is not None:\n                    endpoint = f\"{blueprint_name}{endpoint}\"\n                else:\n                    endpoint = endpoint[1:]\n\n            # When in a request, generate a URL without scheme and\n            # domain by default, unless a scheme is given.\n            if _external is None:\n                _external = _scheme is not None\n        else:\n            app_ctx = _cv_app.get(None)\n\n            # If called by helpers.url_for, an app context is active,\n            # use its url_adapter. Otherwise, app.url_for was called\n            # directly, build an adapter.\n            if app_ctx is not None:\n                url_adapter = app_ctx.url_adapter\n            else:\n                url_adapter = self.create_url_adapter(None)\n\n            if url_adapter is None:\n                raise RuntimeError(\n                    \"Unable to build URLs outside an active request\"\n                    \" without 'SERVER_NAME' configured. Also configure\"\n                    \" 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as\"\n                    \" needed.\"\n                )\n\n            # When outside a request, generate a URL with scheme and\n            # domain by default.\n            if _external is None:\n                _external = True\n\n        # It is an error to set _scheme when _external=False, in order\n        # to avoid accidental insecure URLs.\n        if _scheme is not None and not _external:\n            raise ValueError(\"When specifying '_scheme', '_external' must be True.\")\n\n        self.inject_url_defaults(endpoint, values)\n\n        try:\n            rv = url_adapter.build(  # type: ignore[union-attr]\n                endpoint,\n                values,\n                method=_method,\n                url_scheme=_scheme,\n                force_external=_external,\n            )\n        except BuildError as error:\n            values.update(\n                _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n            )\n            return self.handle_url_build_error(error, endpoint, values)\n\n        if _anchor is not None:\n            rv = f\"{rv}#{url_quote(_anchor)}\"\n\n        return rv\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "url_for", "self", "endpoint", "str", "_anchor", "t", "optional", "str", "none", "_method", "t", "optional", "str", "none", "_scheme", "t", "optional", "str", "none", "_external", "t", "optional", "bool", "none", "values", "t", "any", "str", "generate", "a", "url", "to", "the", "given", "endpoint", "with", "the", "given", "values", "this", "is", "called", "by", "func", "flask", "url_for", "and", "can", "be", "called", "directly", "as", "well", "an", "endpoint", "is", "the", "name", "of", "a", "url", "rule", "usually", "added", "with", "meth", "app", "route", "route", "and", "usually", "the", "same", "name", "as", "the", "view", "function", "a", "route", "defined", "in", "a", "class", "flask", "blueprint", "will", "prepend", "the", "blueprint", "s", "name", "separated", "by", "a", "to", "the", "endpoint", "in", "some", "cases", "such", "as", "email", "messages", "you", "want", "urls", "to", "include", "the", "scheme", "and", "domain", "like", "https", "example", "com", "hello", "when", "not", "in", "an", "active", "request", "urls", "will", "be", "external", "by", "default", "but", "this", "requires", "setting", "data", "server_name", "so", "flask", "knows", "what", "domain", "to", "use", "data", "application_root", "and", "data", "preferred_url_scheme", "should", "also", "be", "configured", "as", "needed", "this", "config", "is", "only", "used", "when", "not", "in", "an", "active", "request", "functions", "can", "be", "decorated", "with", "meth", "url_defaults", "to", "modify", "keyword", "arguments", "before", "the", "url", "is", "built", "if", "building", "fails", "for", "some", "reason", "such", "as", "an", "unknown", "endpoint", "or", "incorrect", "values", "the", "app", "s", "meth", "handle_url_build_error", "method", "is", "called", "if", "that", "returns", "a", "string", "that", "is", "returned", "otherwise", "a", "exc", "werkzeug", "routing", "builderror", "is", "raised", "param", "endpoint", "the", "endpoint", "name", "associated", "with", "the", "url", "to", "generate", "if", "this", "starts", "with", "a", "the", "current", "blueprint", "name", "if", "any", "will", "be", "used", "param", "_anchor", "if", "given", "append", "this", "as", "anchor", "to", "the", "url", "param", "_method", "if", "given", "generate", "the", "url", "associated", "with", "this", "method", "for", "the", "endpoint", "param", "_scheme", "if", "given", "the", "url", "will", "have", "this", "scheme", "if", "it", "is", "external", "param", "_external", "if", "given", "prefer", "the", "url", "to", "be", "internal", "false", "or", "require", "it", "to", "be", "external", "true", "external", "urls", "include", "the", "scheme", "and", "domain", "when", "not", "in", "an", "active", "request", "urls", "are", "external", "by", "default", "param", "values", "values", "to", "use", "for", "the", "variable", "parts", "of", "the", "url", "rule", "unknown", "keys", "are", "appended", "as", "query", "string", "arguments", "like", "a", "b", "c", "d", "versionadded", "2", "2", "moved", "from", "flask", "url_for", "which", "calls", "this", "method", "req_ctx", "_cv_request", "get", "none", "if", "req_ctx", "is", "not", "none", "url_adapter", "req_ctx", "url_adapter", "blueprint_name", "req_ctx", "request", "blueprint", "if", "the", "endpoint", "starts", "with", "and", "the", "request", "matches", "a", "blueprint", "the", "endpoint", "is", "relative", "to", "the", "blueprint", "if", "endpoint", "1", "if", "blueprint_name", "is", "not", "none", "endpoint", "f", "blueprint_name", "endpoint", "else", "endpoint", "endpoint", "1", "when", "in", "a", "request", "generate", "a", "url", "without", "scheme", "and", "domain", "by", "default", "unless", "a", "scheme", "is", "given", "if", "_external", "is", "none", "_external", "_scheme", "is", "not", "none", "else", "app_ctx", "_cv_app", "get", "none", "if", "called", "by", "helpers", "url_for", "an", "app", "context", "is", "active", "use", "its", "url_adapter", "otherwise", "app", "url_for", "was", "called", "directly", "build", "an", "adapter", "if", "app_ctx", "is", "not", "none", "url_adapter", "app_ctx", "url_adapter", "else", "url_adapter", "self", "create_url_adapter", "none", "if", "url_adapter", "is", "none", "raise", "runtimeerror", "unable", "to", "build", "urls", "outside", "an", "active", "request", "without", "server_name", "configured", "also", "configure", "application_root", "and", "preferred_url_scheme", "as", "needed", "when", "outside", "a", "request", "generate", "a", "url", "with", "scheme", "and", "domain", "by", "default", "if", "_external", "is", "none", "_external", "true", "it", "is", "an", "error", "to", "set", "_scheme", "when", "_external", "false", "in", "order", "to", "avoid", "accidental", "insecure", "urls", "if", "_scheme", "is", "not", "none", "and", "not", "_external", "raise", "valueerror", "when", "specifying", "_scheme", "_external", "must", "be", "true", "self", "inject_url_defaults", "endpoint", "values", "try", "rv", "url_adapter", "build", "type", "ignore", "union", "attr", "endpoint", "values", "method", "_method", "url_scheme", "_scheme", "force_external", "_external", "except", "builderror", "as", "error", "values", "update", "_anchor", "_anchor", "_method", "_method", "_scheme", "_scheme", "_external", "_external", "return", "self", "handle_url_build_error", "error", "endpoint", "values", "if", "_anchor", "is", "not", "none", "rv", "f", "rv", "url_quote", "_anchor", "return", "rv"], "doc_len": 609}
{"doc_id": "src/flask/app.py::Flask.redirect", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "redirect", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def redirect(self, location: str, code: int = 302) -> BaseResponse:\n        \"\"\"Create a redirect response object.\n\n        This is called by :func:`flask.redirect`, and can be called\n        directly as well.\n\n        :param location: The URL to redirect to.\n        :param code: The status code for the redirect.\n\n        .. versionadded:: 2.2\n            Moved from ``flask.redirect``, which calls this method.\n        \"\"\"\n        return _wz_redirect(location, code=code, Response=self.response_class)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "redirect", "self", "location", "str", "code", "int", "302", "baseresponse", "create", "a", "redirect", "response", "object", "this", "is", "called", "by", "func", "flask", "redirect", "and", "can", "be", "called", "directly", "as", "well", "param", "location", "the", "url", "to", "redirect", "to", "param", "code", "the", "status", "code", "for", "the", "redirect", "versionadded", "2", "2", "moved", "from", "flask", "redirect", "which", "calls", "this", "method", "return", "_wz_redirect", "location", "code", "code", "response", "self", "response_class"], "doc_len": 67}
{"doc_id": "src/flask/app.py::Flask.make_response", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "make_response", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n        \"\"\"Convert the return value from a view function to an instance of\n        :attr:`response_class`.\n\n        :param rv: the return value from the view function. The view function\n            must return a response. Returning ``None``, or the view ending\n            without returning, is not allowed. The following types are allowed\n            for ``view_rv``:\n\n            ``str``\n                A response object is created with the string encoded to UTF-8\n                as the body.\n\n            ``bytes``\n                A response object is created with the bytes as the body.\n\n            ``dict``\n                A dictionary that will be jsonify'd before being returned.\n\n            ``list``\n                A list that will be jsonify'd before being returned.\n\n            ``generator`` or ``iterator``\n                A generator that returns ``str`` or ``bytes`` to be\n                streamed as the response.\n\n            ``tuple``\n                Either ``(body, status, headers)``, ``(body, status)``, or\n                ``(body, headers)``, where ``body`` is any of the other types\n                allowed here, ``status`` is a string or an integer, and\n                ``headers`` is a dictionary or a list of ``(key, value)``\n                tuples. If ``body`` is a :attr:`response_class` instance,\n                ``status`` overwrites the exiting value and ``headers`` are\n                extended.\n\n            :attr:`response_class`\n                The object is returned unchanged.\n\n            other :class:`~werkzeug.wrappers.Response` class\n                The object is coerced to :attr:`response_class`.\n\n            :func:`callable`\n                The function is called as a WSGI application. The result is\n                used to create a response object.\n\n        .. versionchanged:: 2.2\n            A generator will be converted to a streaming response.\n            A list will be converted to a JSON response.\n\n        .. versionchanged:: 1.1\n            A dict will be converted to a JSON response.\n\n        .. versionchanged:: 0.9\n           Previously a tuple was interpreted as the arguments for the\n           response object.\n        \"\"\"\n\n        status = headers = None\n\n        # unpack tuple returns\n        if isinstance(rv, tuple):\n            len_rv = len(rv)\n\n            # a 3-tuple is unpacked directly\n            if len_rv == 3:\n                rv, status, headers = rv  # type: ignore[misc]\n            # decide if a 2-tuple has status or headers\n            elif len_rv == 2:\n                if isinstance(rv[1], (Headers, dict, tuple, list)):\n                    rv, headers = rv\n                else:\n                    rv, status = rv  # type: ignore[assignment,misc]\n            # other sized tuples are not allowed\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid response tuple.\"\n                    \" The tuple must have the form (body, status, headers),\"\n                    \" (body, status), or (body, headers).\"\n                )\n\n        # the body must not be None\n        if rv is None:\n            raise TypeError(\n                f\"The view function for {request.endpoint!r} did not\"\n                \" return a valid response. The function either returned\"\n                \" None or ended without a return statement.\"\n            )\n\n        # make sure the body is an instance of the response class\n        if not isinstance(rv, self.response_class):\n            if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):\n                # let the response class set the status and headers instead of\n                # waiting to do it manually, so that the class can handle any\n                # special logic\n                rv = self.response_class(\n                    rv,\n                    status=status,\n                    headers=headers,  # type: ignore[arg-type]\n                )\n                status = headers = None\n            elif isinstance(rv, (dict, list)):\n                rv = self.json.response(rv)\n            elif isinstance(rv, BaseResponse) or callable(rv):\n                # evaluate a WSGI callable, or coerce a different response\n                # class to the correct type\n                try:\n                    rv = self.response_class.force_type(\n                        rv, request.environ  # type: ignore[arg-type]\n                    )\n                except TypeError as e:\n                    raise TypeError(\n                        f\"{e}\\nThe view function did not return a valid\"\n                        \" response. The return type must be a string,\"\n                        \" dict, list, tuple with headers or status,\"\n                        \" Response instance, or WSGI callable, but it\"\n                        f\" was a {type(rv).__name__}.\"\n                    ).with_traceback(sys.exc_info()[2]) from None\n            else:\n                raise TypeError(\n                    \"The view function did not return a valid\"\n                    \" response. The return type must be a string,\"\n                    \" dict, list, tuple with headers or status,\"\n                    \" Response instance, or WSGI callable, but it was a\"\n                    f\" {type(rv).__name__}.\"\n                )\n\n        rv = t.cast(Response, rv)\n        # prefer the status if it was provided\n        if status is not None:\n            if isinstance(status, (str, bytes, bytearray)):\n                rv.status = status\n            else:\n                rv.status_code = status\n\n        # extend existing headers with provided headers\n        if headers:\n            rv.headers.update(headers)  # type: ignore[arg-type]\n\n        return rv\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "make_response", "self", "rv", "ft", "responsereturnvalue", "response", "convert", "the", "return", "value", "from", "a", "view", "function", "to", "an", "instance", "of", "attr", "response_class", "param", "rv", "the", "return", "value", "from", "the", "view", "function", "the", "view", "function", "must", "return", "a", "response", "returning", "none", "or", "the", "view", "ending", "without", "returning", "is", "not", "allowed", "the", "following", "types", "are", "allowed", "for", "view_rv", "str", "a", "response", "object", "is", "created", "with", "the", "string", "encoded", "to", "utf", "8", "as", "the", "body", "bytes", "a", "response", "object", "is", "created", "with", "the", "bytes", "as", "the", "body", "dict", "a", "dictionary", "that", "will", "be", "jsonify", "d", "before", "being", "returned", "list", "a", "list", "that", "will", "be", "jsonify", "d", "before", "being", "returned", "generator", "or", "iterator", "a", "generator", "that", "returns", "str", "or", "bytes", "to", "be", "streamed", "as", "the", "response", "tuple", "either", "body", "status", "headers", "body", "status", "or", "body", "headers", "where", "body", "is", "any", "of", "the", "other", "types", "allowed", "here", "status", "is", "a", "string", "or", "an", "integer", "and", "headers", "is", "a", "dictionary", "or", "a", "list", "of", "key", "value", "tuples", "if", "body", "is", "a", "attr", "response_class", "instance", "status", "overwrites", "the", "exiting", "value", "and", "headers", "are", "extended", "attr", "response_class", "the", "object", "is", "returned", "unchanged", "other", "class", "werkzeug", "wrappers", "response", "class", "the", "object", "is", "coerced", "to", "attr", "response_class", "func", "callable", "the", "function", "is", "called", "as", "a", "wsgi", "application", "the", "result", "is", "used", "to", "create", "a", "response", "object", "versionchanged", "2", "2", "a", "generator", "will", "be", "converted", "to", "a", "streaming", "response", "a", "list", "will", "be", "converted", "to", "a", "json", "response", "versionchanged", "1", "1", "a", "dict", "will", "be", "converted", "to", "a", "json", "response", "versionchanged", "0", "9", "previously", "a", "tuple", "was", "interpreted", "as", "the", "arguments", "for", "the", "response", "object", "status", "headers", "none", "unpack", "tuple", "returns", "if", "isinstance", "rv", "tuple", "len_rv", "len", "rv", "a", "3", "tuple", "is", "unpacked", "directly", "if", "len_rv", "3", "rv", "status", "headers", "rv", "type", "ignore", "misc", "decide", "if", "a", "2", "tuple", "has", "status", "or", "headers", "elif", "len_rv", "2", "if", "isinstance", "rv", "1", "headers", "dict", "tuple", "list", "rv", "headers", "rv", "else", "rv", "status", "rv", "type", "ignore", "assignment", "misc", "other", "sized", "tuples", "are", "not", "allowed", "else", "raise", "typeerror", "the", "view", "function", "did", "not", "return", "a", "valid", "response", "tuple", "the", "tuple", "must", "have", "the", "form", "body", "status", "headers", "body", "status", "or", "body", "headers", "the", "body", "must", "not", "be", "none", "if", "rv", "is", "none", "raise", "typeerror", "f", "the", "view", "function", "for", "request", "endpoint", "r", "did", "not", "return", "a", "valid", "response", "the", "function", "either", "returned", "none", "or", "ended", "without", "a", "return", "statement", "make", "sure", "the", "body", "is", "an", "instance", "of", "the", "response", "class", "if", "not", "isinstance", "rv", "self", "response_class", "if", "isinstance", "rv", "str", "bytes", "bytearray", "or", "isinstance", "rv", "_abc_iterator", "let", "the", "response", "class", "set", "the", "status", "and", "headers", "instead", "of", "waiting", "to", "do", "it", "manually", "so", "that", "the", "class", "can", "handle", "any", "special", "logic", "rv", "self", "response_class", "rv", "status", "status", "headers", "headers", "type", "ignore", "arg", "type", "status", "headers", "none", "elif", "isinstance", "rv", "dict", "list", "rv", "self", "json", "response", "rv", "elif", "isinstance", "rv", "baseresponse", "or", "callable", "rv", "evaluate", "a", "wsgi", "callable", "or", "coerce", "a", "different", "response", "class", "to", "the", "correct", "type", "try", "rv", "self", "response_class", "force_type", "rv", "request", "environ", "type", "ignore", "arg", "type", "except", "typeerror", "as", "e", "raise", "typeerror", "f", "e", "nthe", "view", "function", "did", "not", "return", "a", "valid", "response", "the", "return", "type", "must", "be", "a", "string", "dict", "list", "tuple", "with", "headers", "or", "status", "response", "instance", "or", "wsgi", "callable", "but", "it", "f", "was", "a", "type", "rv", "__name__", "with_traceback", "sys", "exc_info", "2", "from", "none", "else", "raise", "typeerror", "the", "view", "function", "did", "not", "return", "a", "valid", "response", "the", "return", "type", "must", "be", "a", "string", "dict", "list", "tuple", "with", "headers", "or", "status", "response", "instance", "or", "wsgi", "callable", "but", "it", "was", "a", "f", "type", "rv", "__name__", "rv", "t", "cast", "response", "rv", "prefer", "the", "status", "if", "it", "was", "provided", "if", "status", "is", "not", "none", "if", "isinstance", "status", "str", "bytes", "bytearray", "rv", "status", "status", "else", "rv", "status_code", "status", "extend", "existing", "headers", "with", "provided", "headers", "if", "headers", "rv", "headers", "update", "headers", "type", "ignore", "arg", "type", "return", "rv"], "doc_len": 645}
{"doc_id": "src/flask/app.py::Flask.create_url_adapter", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "create_url_adapter", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def create_url_adapter(\n        self, request: t.Optional[Request]\n    ) -> t.Optional[MapAdapter]:\n        \"\"\"Creates a URL adapter for the given request. The URL adapter\n        is created at a point where the request context is not yet set\n        up so the request is passed explicitly.\n\n        .. versionadded:: 0.6\n\n        .. versionchanged:: 0.9\n           This can now also be called without a request object when the\n           URL adapter is created for the application context.\n\n        .. versionchanged:: 1.0\n            :data:`SERVER_NAME` no longer implicitly enables subdomain\n            matching. Use :attr:`subdomain_matching` instead.\n        \"\"\"\n        if request is not None:\n            # If subdomain matching is disabled (the default), use the\n            # default subdomain in all cases. This should be the default\n            # in Werkzeug but it currently does not have that feature.\n            if not self.subdomain_matching:\n                subdomain = self.url_map.default_subdomain or None\n            else:\n                subdomain = None\n\n            return self.url_map.bind_to_environ(\n                request.environ,\n                server_name=self.config[\"SERVER_NAME\"],\n                subdomain=subdomain,\n            )\n        # We need at the very least the server name to be set for this\n        # to work.\n        if self.config[\"SERVER_NAME\"] is not None:\n            return self.url_map.bind(\n                self.config[\"SERVER_NAME\"],\n                script_name=self.config[\"APPLICATION_ROOT\"],\n                url_scheme=self.config[\"PREFERRED_URL_SCHEME\"],\n            )\n\n        return None\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "create_url_adapter", "self", "request", "t", "optional", "request", "t", "optional", "mapadapter", "creates", "a", "url", "adapter", "for", "the", "given", "request", "the", "url", "adapter", "is", "created", "at", "a", "point", "where", "the", "request", "context", "is", "not", "yet", "set", "up", "so", "the", "request", "is", "passed", "explicitly", "versionadded", "0", "6", "versionchanged", "0", "9", "this", "can", "now", "also", "be", "called", "without", "a", "request", "object", "when", "the", "url", "adapter", "is", "created", "for", "the", "application", "context", "versionchanged", "1", "0", "data", "server_name", "no", "longer", "implicitly", "enables", "subdomain", "matching", "use", "attr", "subdomain_matching", "instead", "if", "request", "is", "not", "none", "if", "subdomain", "matching", "is", "disabled", "the", "default", "use", "the", "default", "subdomain", "in", "all", "cases", "this", "should", "be", "the", "default", "in", "werkzeug", "but", "it", "currently", "does", "not", "have", "that", "feature", "if", "not", "self", "subdomain_matching", "subdomain", "self", "url_map", "default_subdomain", "or", "none", "else", "subdomain", "none", "return", "self", "url_map", "bind_to_environ", "request", "environ", "server_name", "self", "config", "server_name", "subdomain", "subdomain", "we", "need", "at", "the", "very", "least", "the", "server", "name", "to", "be", "set", "for", "this", "to", "work", "if", "self", "config", "server_name", "is", "not", "none", "return", "self", "url_map", "bind", "self", "config", "server_name", "script_name", "self", "config", "application_root", "url_scheme", "self", "config", "preferred_url_scheme", "return", "none"], "doc_len": 186}
{"doc_id": "src/flask/app.py::Flask.inject_url_defaults", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "inject_url_defaults", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n        \"\"\"Injects the URL defaults for the given endpoint directly into\n        the values dictionary passed.  This is used internally and\n        automatically called on URL building.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        names: t.Iterable[t.Optional[str]] = (None,)\n\n        # url_for may be called outside a request context, parse the\n        # passed endpoint instead of using request.blueprints.\n        if \".\" in endpoint:\n            names = chain(\n                names, reversed(_split_blueprint_path(endpoint.rpartition(\".\")[0]))\n            )\n\n        for name in names:\n            if name in self.url_default_functions:\n                for func in self.url_default_functions[name]:\n                    func(endpoint, values)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "inject_url_defaults", "self", "endpoint", "str", "values", "dict", "none", "injects", "the", "url", "defaults", "for", "the", "given", "endpoint", "directly", "into", "the", "values", "dictionary", "passed", "this", "is", "used", "internally", "and", "automatically", "called", "on", "url", "building", "versionadded", "0", "7", "names", "t", "iterable", "t", "optional", "str", "none", "url_for", "may", "be", "called", "outside", "a", "request", "context", "parse", "the", "passed", "endpoint", "instead", "of", "using", "request", "blueprints", "if", "in", "endpoint", "names", "chain", "names", "reversed", "_split_blueprint_path", "endpoint", "rpartition", "0", "for", "name", "in", "names", "if", "name", "in", "self", "url_default_functions", "for", "func", "in", "self", "url_default_functions", "name", "func", "endpoint", "values"], "doc_len": 93}
{"doc_id": "src/flask/app.py::Flask.handle_url_build_error", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "handle_url_build_error", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]\n    ) -> str:\n        \"\"\"Called by :meth:`.url_for` if a\n        :exc:`~werkzeug.routing.BuildError` was raised. If this returns\n        a value, it will be returned by ``url_for``, otherwise the error\n        will be re-raised.\n\n        Each function in :attr:`url_build_error_handlers` is called with\n        ``error``, ``endpoint`` and ``values``. If a function returns\n        ``None`` or raises a ``BuildError``, it is skipped. Otherwise,\n        its return value is returned by ``url_for``.\n\n        :param error: The active ``BuildError`` being handled.\n        :param endpoint: The endpoint being built.\n        :param values: The keyword arguments passed to ``url_for``.\n        \"\"\"\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "handle_url_build_error", "self", "error", "builderror", "endpoint", "str", "values", "t", "dict", "str", "t", "any", "str", "called", "by", "meth", "url_for", "if", "a", "exc", "werkzeug", "routing", "builderror", "was", "raised", "if", "this", "returns", "a", "value", "it", "will", "be", "returned", "by", "url_for", "otherwise", "the", "error", "will", "be", "re", "raised", "each", "function", "in", "attr", "url_build_error_handlers", "is", "called", "with", "error", "endpoint", "and", "values", "if", "a", "function", "returns", "none", "or", "raises", "a", "builderror", "it", "is", "skipped", "otherwise", "its", "return", "value", "is", "returned", "by", "url_for", "param", "error", "the", "active", "builderror", "being", "handled", "param", "endpoint", "the", "endpoint", "being", "built", "param", "values", "the", "keyword", "arguments", "passed", "to", "url_for", "for", "handler", "in", "self", "url_build_error_handlers", "try", "rv", "handler", "error", "endpoint", "values", "except", "builderror", "as", "e", "make", "error", "available", "outside", "except", "block", "error", "e", "else", "if", "rv", "is", "not", "none", "return", "rv", "re", "raise", "if", "called", "with", "an", "active", "exception", "otherwise", "raise", "the", "passed", "in", "exception", "if", "error", "is", "sys", "exc_info", "1", "raise", "raise", "error"], "doc_len": 156}
{"doc_id": "src/flask/app.py::Flask.preprocess_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "preprocess_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def preprocess_request(self) -> t.Optional[ft.ResponseReturnValue]:\n        \"\"\"Called before the request is dispatched. Calls\n        :attr:`url_value_preprocessors` registered with the app and the\n        current blueprint (if any). Then calls :attr:`before_request_funcs`\n        registered with the app and the blueprint.\n\n        If any :meth:`before_request` handler returns a non-None value, the\n        value is handled as if it was the return value from the view, and\n        further request handling is stopped.\n        \"\"\"\n        names = (None, *reversed(request.blueprints))\n\n        for name in names:\n            if name in self.url_value_preprocessors:\n                for url_func in self.url_value_preprocessors[name]:\n                    url_func(request.endpoint, request.view_args)\n\n        for name in names:\n            if name in self.before_request_funcs:\n                for before_func in self.before_request_funcs[name]:\n                    rv = self.ensure_sync(before_func)()\n\n                    if rv is not None:\n                        return rv\n\n        return None\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "preprocess_request", "self", "t", "optional", "ft", "responsereturnvalue", "called", "before", "the", "request", "is", "dispatched", "calls", "attr", "url_value_preprocessors", "registered", "with", "the", "app", "and", "the", "current", "blueprint", "if", "any", "then", "calls", "attr", "before_request_funcs", "registered", "with", "the", "app", "and", "the", "blueprint", "if", "any", "meth", "before_request", "handler", "returns", "a", "non", "none", "value", "the", "value", "is", "handled", "as", "if", "it", "was", "the", "return", "value", "from", "the", "view", "and", "further", "request", "handling", "is", "stopped", "names", "none", "reversed", "request", "blueprints", "for", "name", "in", "names", "if", "name", "in", "self", "url_value_preprocessors", "for", "url_func", "in", "self", "url_value_preprocessors", "name", "url_func", "request", "endpoint", "request", "view_args", "for", "name", "in", "names", "if", "name", "in", "self", "before_request_funcs", "for", "before_func", "in", "self", "before_request_funcs", "name", "rv", "self", "ensure_sync", "before_func", "if", "rv", "is", "not", "none", "return", "rv", "return", "none"], "doc_len": 125}
{"doc_id": "src/flask/app.py::Flask.process_response", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "process_response", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def process_response(self, response: Response) -> Response:\n        \"\"\"Can be overridden in order to modify the response object\n        before it's sent to the WSGI server.  By default this will\n        call all the :meth:`after_request` decorated functions.\n\n        .. versionchanged:: 0.5\n           As of Flask 0.5 the functions registered for after request\n           execution are called in reverse order of registration.\n\n        :param response: a :attr:`response_class` object.\n        :return: a new response object or the same, has to be an\n                 instance of :attr:`response_class`.\n        \"\"\"\n        ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]\n\n        for func in ctx._after_request_functions:\n            response = self.ensure_sync(func)(response)\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.after_request_funcs:\n                for func in reversed(self.after_request_funcs[name]):\n                    response = self.ensure_sync(func)(response)\n\n        if not self.session_interface.is_null_session(ctx.session):\n            self.session_interface.save_session(self, ctx.session, response)\n\n        return response\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "process_response", "self", "response", "response", "response", "can", "be", "overridden", "in", "order", "to", "modify", "the", "response", "object", "before", "it", "s", "sent", "to", "the", "wsgi", "server", "by", "default", "this", "will", "call", "all", "the", "meth", "after_request", "decorated", "functions", "versionchanged", "0", "5", "as", "of", "flask", "0", "5", "the", "functions", "registered", "for", "after", "request", "execution", "are", "called", "in", "reverse", "order", "of", "registration", "param", "response", "a", "attr", "response_class", "object", "return", "a", "new", "response", "object", "or", "the", "same", "has", "to", "be", "an", "instance", "of", "attr", "response_class", "ctx", "request_ctx", "_get_current_object", "type", "ignore", "attr", "defined", "for", "func", "in", "ctx", "_after_request_functions", "response", "self", "ensure_sync", "func", "response", "for", "name", "in", "chain", "request", "blueprints", "none", "if", "name", "in", "self", "after_request_funcs", "for", "func", "in", "reversed", "self", "after_request_funcs", "name", "response", "self", "ensure_sync", "func", "response", "if", "not", "self", "session_interface", "is_null_session", "ctx", "session", "self", "session_interface", "save_session", "self", "ctx", "session", "response", "return", "response"], "doc_len": 141}
{"doc_id": "src/flask/app.py::Flask.do_teardown_request", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "do_teardown_request", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def do_teardown_request(\n        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n    ) -> None:\n        \"\"\"Called after the request is dispatched and the response is\n        returned, right before the request context is popped.\n\n        This calls all functions decorated with\n        :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`\n        if a blueprint handled the request. Finally, the\n        :data:`request_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,\n        which may be delayed during testing to maintain access to\n        resources.\n\n        :param exc: An unhandled exception raised while dispatching the\n            request. Detected from the current exception information if\n            not passed. Passed to each teardown function.\n\n        .. versionchanged:: 0.9\n            Added the ``exc`` argument.\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for name in chain(request.blueprints, (None,)):\n            if name in self.teardown_request_funcs:\n                for func in reversed(self.teardown_request_funcs[name]):\n                    self.ensure_sync(func)(exc)\n\n        request_tearing_down.send(self, exc=exc)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "do_teardown_request", "self", "exc", "t", "optional", "baseexception", "_sentinel", "type", "ignore", "none", "called", "after", "the", "request", "is", "dispatched", "and", "the", "response", "is", "returned", "right", "before", "the", "request", "context", "is", "popped", "this", "calls", "all", "functions", "decorated", "with", "meth", "teardown_request", "and", "meth", "blueprint", "teardown_request", "if", "a", "blueprint", "handled", "the", "request", "finally", "the", "data", "request_tearing_down", "signal", "is", "sent", "this", "is", "called", "by", "meth", "requestcontext", "pop", "flask", "ctx", "requestcontext", "pop", "which", "may", "be", "delayed", "during", "testing", "to", "maintain", "access", "to", "resources", "param", "exc", "an", "unhandled", "exception", "raised", "while", "dispatching", "the", "request", "detected", "from", "the", "current", "exception", "information", "if", "not", "passed", "passed", "to", "each", "teardown", "function", "versionchanged", "0", "9", "added", "the", "exc", "argument", "if", "exc", "is", "_sentinel", "exc", "sys", "exc_info", "1", "for", "name", "in", "chain", "request", "blueprints", "none", "if", "name", "in", "self", "teardown_request_funcs", "for", "func", "in", "reversed", "self", "teardown_request_funcs", "name", "self", "ensure_sync", "func", "exc", "request_tearing_down", "send", "self", "exc", "exc"], "doc_len": 148}
{"doc_id": "src/flask/app.py::Flask.do_teardown_appcontext", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "do_teardown_appcontext", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def do_teardown_appcontext(\n        self, exc: t.Optional[BaseException] = _sentinel  # type: ignore\n    ) -> None:\n        \"\"\"Called right before the application context is popped.\n\n        When handling a request, the application context is popped\n        after the request context. See :meth:`do_teardown_request`.\n\n        This calls all functions decorated with\n        :meth:`teardown_appcontext`. Then the\n        :data:`appcontext_tearing_down` signal is sent.\n\n        This is called by\n        :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        if exc is _sentinel:\n            exc = sys.exc_info()[1]\n\n        for func in reversed(self.teardown_appcontext_funcs):\n            self.ensure_sync(func)(exc)\n\n        appcontext_tearing_down.send(self, exc=exc)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "do_teardown_appcontext", "self", "exc", "t", "optional", "baseexception", "_sentinel", "type", "ignore", "none", "called", "right", "before", "the", "application", "context", "is", "popped", "when", "handling", "a", "request", "the", "application", "context", "is", "popped", "after", "the", "request", "context", "see", "meth", "do_teardown_request", "this", "calls", "all", "functions", "decorated", "with", "meth", "teardown_appcontext", "then", "the", "data", "appcontext_tearing_down", "signal", "is", "sent", "this", "is", "called", "by", "meth", "appcontext", "pop", "flask", "ctx", "appcontext", "pop", "versionadded", "0", "9", "if", "exc", "is", "_sentinel", "exc", "sys", "exc_info", "1", "for", "func", "in", "reversed", "self", "teardown_appcontext_funcs", "self", "ensure_sync", "func", "exc", "appcontext_tearing_down", "send", "self", "exc", "exc"], "doc_len": 92}
{"doc_id": "src/flask/app.py::Flask.app_context", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "app_context", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def app_context(self) -> AppContext:\n        \"\"\"Create an :class:`~flask.ctx.AppContext`. Use as a ``with``\n        block to push the context, which will make :data:`current_app`\n        point at this application.\n\n        An application context is automatically pushed by\n        :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`\n        when handling a request, and when running a CLI command. Use\n        this to manually create a context outside of these situations.\n\n        ::\n\n            with app.app_context():\n                init_db()\n\n        See :doc:`/appcontext`.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        return AppContext(self)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "app_context", "self", "appcontext", "create", "an", "class", "flask", "ctx", "appcontext", "use", "as", "a", "with", "block", "to", "push", "the", "context", "which", "will", "make", "data", "current_app", "point", "at", "this", "application", "an", "application", "context", "is", "automatically", "pushed", "by", "meth", "requestcontext", "push", "flask", "ctx", "requestcontext", "push", "when", "handling", "a", "request", "and", "when", "running", "a", "cli", "command", "use", "this", "to", "manually", "create", "a", "context", "outside", "of", "these", "situations", "with", "app", "app_context", "init_db", "see", "doc", "appcontext", "versionadded", "0", "9", "return", "appcontext", "self"], "doc_len": 81}
{"doc_id": "src/flask/app.py::Flask.request_context", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "request_context", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def request_context(self, environ: dict) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` representing a\n        WSGI environment. Use a ``with`` block to push the context,\n        which will make :data:`request` point at this request.\n\n        See :doc:`/reqcontext`.\n\n        Typically you should not call this from your own code. A request\n        context is automatically pushed by the :meth:`wsgi_app` when\n        handling a request. Use :meth:`test_request_context` to create\n        an environment and context instead of this method.\n\n        :param environ: a WSGI environment\n        \"\"\"\n        return RequestContext(self, environ)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "request_context", "self", "environ", "dict", "requestcontext", "create", "a", "class", "flask", "ctx", "requestcontext", "representing", "a", "wsgi", "environment", "use", "a", "with", "block", "to", "push", "the", "context", "which", "will", "make", "data", "request", "point", "at", "this", "request", "see", "doc", "reqcontext", "typically", "you", "should", "not", "call", "this", "from", "your", "own", "code", "a", "request", "context", "is", "automatically", "pushed", "by", "the", "meth", "wsgi_app", "when", "handling", "a", "request", "use", "meth", "test_request_context", "to", "create", "an", "environment", "and", "context", "instead", "of", "this", "method", "param", "environ", "a", "wsgi", "environment", "return", "requestcontext", "self", "environ"], "doc_len": 87}
{"doc_id": "src/flask/app.py::Flask.test_request_context", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "test_request_context", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:\n        \"\"\"Create a :class:`~flask.ctx.RequestContext` for a WSGI\n        environment created from the given values. This is mostly useful\n        during testing, where you may want to run a function that uses\n        request data without dispatching a full request.\n\n        See :doc:`/reqcontext`.\n\n        Use a ``with`` block to push the context, which will make\n        :data:`request` point at the request for the created\n        environment. ::\n\n            with app.test_request_context(...):\n                generate_report()\n\n        When using the shell, it may be easier to push and pop the\n        context manually to avoid indentation. ::\n\n            ctx = app.test_request_context(...)\n            ctx.push()\n            ...\n            ctx.pop()\n\n        Takes the same arguments as Werkzeug's\n        :class:`~werkzeug.test.EnvironBuilder`, with some defaults from\n        the application. See the linked Werkzeug docs for most of the\n        available arguments. Flask-specific behavior is listed here.\n\n        :param path: URL path being requested.\n        :param base_url: Base URL where the app is being served, which\n            ``path`` is relative to. If not given, built from\n            :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n            :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n        :param subdomain: Subdomain name to append to\n            :data:`SERVER_NAME`.\n        :param url_scheme: Scheme to use instead of\n            :data:`PREFERRED_URL_SCHEME`.\n        :param data: The request body, either as a string or a dict of\n            form keys and values.\n        :param json: If given, this is serialized as JSON and passed as\n            ``data``. Also defaults ``content_type`` to\n            ``application/json``.\n        :param args: other positional arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        :param kwargs: other keyword arguments passed to\n            :class:`~werkzeug.test.EnvironBuilder`.\n        \"\"\"\n        from .testing import EnvironBuilder\n\n        builder = EnvironBuilder(self, *args, **kwargs)\n\n        try:\n            return self.request_context(builder.get_environ())\n        finally:\n            builder.close()\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "test_request_context", "self", "args", "t", "any", "kwargs", "t", "any", "requestcontext", "create", "a", "class", "flask", "ctx", "requestcontext", "for", "a", "wsgi", "environment", "created", "from", "the", "given", "values", "this", "is", "mostly", "useful", "during", "testing", "where", "you", "may", "want", "to", "run", "a", "function", "that", "uses", "request", "data", "without", "dispatching", "a", "full", "request", "see", "doc", "reqcontext", "use", "a", "with", "block", "to", "push", "the", "context", "which", "will", "make", "data", "request", "point", "at", "the", "request", "for", "the", "created", "environment", "with", "app", "test_request_context", "generate_report", "when", "using", "the", "shell", "it", "may", "be", "easier", "to", "push", "and", "pop", "the", "context", "manually", "to", "avoid", "indentation", "ctx", "app", "test_request_context", "ctx", "push", "ctx", "pop", "takes", "the", "same", "arguments", "as", "werkzeug", "s", "class", "werkzeug", "test", "environbuilder", "with", "some", "defaults", "from", "the", "application", "see", "the", "linked", "werkzeug", "docs", "for", "most", "of", "the", "available", "arguments", "flask", "specific", "behavior", "is", "listed", "here", "param", "path", "url", "path", "being", "requested", "param", "base_url", "base", "url", "where", "the", "app", "is", "being", "served", "which", "path", "is", "relative", "to", "if", "not", "given", "built", "from", "data", "preferred_url_scheme", "subdomain", "data", "server_name", "and", "data", "application_root", "param", "subdomain", "subdomain", "name", "to", "append", "to", "data", "server_name", "param", "url_scheme", "scheme", "to", "use", "instead", "of", "data", "preferred_url_scheme", "param", "data", "the", "request", "body", "either", "as", "a", "string", "or", "a", "dict", "of", "form", "keys", "and", "values", "param", "json", "if", "given", "this", "is", "serialized", "as", "json", "and", "passed", "as", "data", "also", "defaults", "content_type", "to", "application", "json", "param", "args", "other", "positional", "arguments", "passed", "to", "class", "werkzeug", "test", "environbuilder", "param", "kwargs", "other", "keyword", "arguments", "passed", "to", "class", "werkzeug", "test", "environbuilder", "from", "testing", "import", "environbuilder", "builder", "environbuilder", "self", "args", "kwargs", "try", "return", "self", "request_context", "builder", "get_environ", "finally", "builder", "close"], "doc_len": 268}
{"doc_id": "src/flask/app.py::Flask.wsgi_app", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "wsgi_app", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:\n        \"\"\"The actual WSGI application. This is not implemented in\n        :meth:`__call__` so that middlewares can be applied without\n        losing a reference to the app object. Instead of doing this::\n\n            app = MyMiddleware(app)\n\n        It's a better idea to do this instead::\n\n            app.wsgi_app = MyMiddleware(app.wsgi_app)\n\n        Then you still have the original application object around and\n        can continue to call methods on it.\n\n        .. versionchanged:: 0.7\n            Teardown events for the request and app contexts are called\n            even if an unhandled error occurs. Other events may not be\n            called depending on when an error occurs during dispatch.\n            See :ref:`callbacks-and-errors`.\n\n        :param environ: A WSGI environment.\n        :param start_response: A callable accepting a status code,\n            a list of headers, and an optional exception context to\n            start the response.\n        \"\"\"\n        ctx = self.request_context(environ)\n        error: t.Optional[BaseException] = None\n        try:\n            try:\n                ctx.push()\n                response = self.full_dispatch_request()\n            except Exception as e:\n                error = e\n                response = self.handle_exception(e)\n            except:  # noqa: B001\n                error = sys.exc_info()[1]\n                raise\n            return response(environ, start_response)\n        finally:\n            if \"werkzeug.debug.preserve_context\" in environ:\n                environ[\"werkzeug.debug.preserve_context\"](_cv_app.get())\n                environ[\"werkzeug.debug.preserve_context\"](_cv_request.get())\n\n            if error is not None and self.should_ignore_error(error):\n                error = None\n\n            ctx.pop(error)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "wsgi_app", "self", "environ", "dict", "start_response", "t", "callable", "t", "any", "the", "actual", "wsgi", "application", "this", "is", "not", "implemented", "in", "meth", "__call__", "so", "that", "middlewares", "can", "be", "applied", "without", "losing", "a", "reference", "to", "the", "app", "object", "instead", "of", "doing", "this", "app", "mymiddleware", "app", "it", "s", "a", "better", "idea", "to", "do", "this", "instead", "app", "wsgi_app", "mymiddleware", "app", "wsgi_app", "then", "you", "still", "have", "the", "original", "application", "object", "around", "and", "can", "continue", "to", "call", "methods", "on", "it", "versionchanged", "0", "7", "teardown", "events", "for", "the", "request", "and", "app", "contexts", "are", "called", "even", "if", "an", "unhandled", "error", "occurs", "other", "events", "may", "not", "be", "called", "depending", "on", "when", "an", "error", "occurs", "during", "dispatch", "see", "ref", "callbacks", "and", "errors", "param", "environ", "a", "wsgi", "environment", "param", "start_response", "a", "callable", "accepting", "a", "status", "code", "a", "list", "of", "headers", "and", "an", "optional", "exception", "context", "to", "start", "the", "response", "ctx", "self", "request_context", "environ", "error", "t", "optional", "baseexception", "none", "try", "try", "ctx", "push", "response", "self", "full_dispatch_request", "except", "exception", "as", "e", "error", "e", "response", "self", "handle_exception", "e", "except", "noqa", "b001", "error", "sys", "exc_info", "1", "raise", "return", "response", "environ", "start_response", "finally", "if", "werkzeug", "debug", "preserve_context", "in", "environ", "environ", "werkzeug", "debug", "preserve_context", "_cv_app", "get", "environ", "werkzeug", "debug", "preserve_context", "_cv_request", "get", "if", "error", "is", "not", "none", "and", "self", "should_ignore_error", "error", "error", "none", "ctx", "pop", "error"], "doc_len": 213}
{"doc_id": "src/flask/app.py::Flask.__call__", "file_path": "src/flask/app.py", "class_name": "Flask", "func_name": "__call__", "text": "文件路径: src/flask/app.py, 类名: Flask\n    def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:\n        \"\"\"The WSGI server calls the Flask application object as the\n        WSGI application. This calls :meth:`wsgi_app`, which can be\n        wrapped to apply middleware.\n        \"\"\"\n        return self.wsgi_app(environ, start_response)\n", "tokens": ["src", "flask", "app", "py", "flask", "def", "__call__", "self", "environ", "dict", "start_response", "t", "callable", "t", "any", "the", "wsgi", "server", "calls", "the", "flask", "application", "object", "as", "the", "wsgi", "application", "this", "calls", "meth", "wsgi_app", "which", "can", "be", "wrapped", "to", "apply", "middleware", "return", "self", "wsgi_app", "environ", "start_response"], "doc_len": 43}
{"doc_id": "src/flask/blueprints.py::BlueprintSetupState.__init__", "file_path": "src/flask/blueprints.py", "class_name": "BlueprintSetupState", "func_name": "__init__", "text": "文件路径: src/flask/blueprints.py, 类名: BlueprintSetupState\n    def __init__(\n        self,\n        blueprint: \"Blueprint\",\n        app: \"Flask\",\n        options: t.Any,\n        first_registration: bool,\n    ) -> None:\n        #: a reference to the current application\n        self.app = app\n\n        #: a reference to the blueprint that created this setup state.\n        self.blueprint = blueprint\n\n        #: a dictionary with all options that were passed to the\n        #: :meth:`~flask.Flask.register_blueprint` method.\n        self.options = options\n\n        #: as blueprints can be registered multiple times with the\n        #: application and not everything wants to be registered\n        #: multiple times on it, this attribute can be used to figure\n        #: out if the blueprint was registered in the past already.\n        self.first_registration = first_registration\n\n        subdomain = self.options.get(\"subdomain\")\n        if subdomain is None:\n            subdomain = self.blueprint.subdomain\n\n        #: The subdomain that the blueprint should be active for, ``None``\n        #: otherwise.\n        self.subdomain = subdomain\n\n        url_prefix = self.options.get(\"url_prefix\")\n        if url_prefix is None:\n            url_prefix = self.blueprint.url_prefix\n        #: The prefix that should be used for all URLs defined on the\n        #: blueprint.\n        self.url_prefix = url_prefix\n\n        self.name = self.options.get(\"name\", blueprint.name)\n        self.name_prefix = self.options.get(\"name_prefix\", \"\")\n\n        #: A dictionary with URL defaults that is added to each and every\n        #: URL that was defined with the blueprint.\n        self.url_defaults = dict(self.blueprint.url_values_defaults)\n        self.url_defaults.update(self.options.get(\"url_defaults\", ()))\n", "tokens": ["src", "flask", "blueprints", "py", "blueprintsetupstate", "def", "__init__", "self", "blueprint", "blueprint", "app", "flask", "options", "t", "any", "first_registration", "bool", "none", "a", "reference", "to", "the", "current", "application", "self", "app", "app", "a", "reference", "to", "the", "blueprint", "that", "created", "this", "setup", "state", "self", "blueprint", "blueprint", "a", "dictionary", "with", "all", "options", "that", "were", "passed", "to", "the", "meth", "flask", "flask", "register_blueprint", "method", "self", "options", "options", "as", "blueprints", "can", "be", "registered", "multiple", "times", "with", "the", "application", "and", "not", "everything", "wants", "to", "be", "registered", "multiple", "times", "on", "it", "this", "attribute", "can", "be", "used", "to", "figure", "out", "if", "the", "blueprint", "was", "registered", "in", "the", "past", "already", "self", "first_registration", "first_registration", "subdomain", "self", "options", "get", "subdomain", "if", "subdomain", "is", "none", "subdomain", "self", "blueprint", "subdomain", "the", "subdomain", "that", "the", "blueprint", "should", "be", "active", "for", "none", "otherwise", "self", "subdomain", "subdomain", "url_prefix", "self", "options", "get", "url_prefix", "if", "url_prefix", "is", "none", "url_prefix", "self", "blueprint", "url_prefix", "the", "prefix", "that", "should", "be", "used", "for", "all", "urls", "defined", "on", "the", "blueprint", "self", "url_prefix", "url_prefix", "self", "name", "self", "options", "get", "name", "blueprint", "name", "self", "name_prefix", "self", "options", "get", "name_prefix", "a", "dictionary", "with", "url", "defaults", "that", "is", "added", "to", "each", "and", "every", "url", "that", "was", "defined", "with", "the", "blueprint", "self", "url_defaults", "dict", "self", "blueprint", "url_values_defaults", "self", "url_defaults", "update", "self", "options", "get", "url_defaults"], "doc_len": 201}
{"doc_id": "src/flask/blueprints.py::BlueprintSetupState.add_url_rule", "file_path": "src/flask/blueprints.py", "class_name": "BlueprintSetupState", "func_name": "add_url_rule", "text": "文件路径: src/flask/blueprints.py, 类名: BlueprintSetupState\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[t.Callable] = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"A helper method to register a rule (and optionally a view function)\n        to the application.  The endpoint is automatically prefixed with the\n        blueprint's name.\n        \"\"\"\n        if self.url_prefix is not None:\n            if rule:\n                rule = \"/\".join((self.url_prefix.rstrip(\"/\"), rule.lstrip(\"/\")))\n            else:\n                rule = self.url_prefix\n        options.setdefault(\"subdomain\", self.subdomain)\n        if endpoint is None:\n            endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n        defaults = self.url_defaults\n        if \"defaults\" in options:\n            defaults = dict(defaults, **options.pop(\"defaults\"))\n\n        self.app.add_url_rule(\n            rule,\n            f\"{self.name_prefix}.{self.name}.{endpoint}\".lstrip(\".\"),\n            view_func,\n            defaults=defaults,\n            **options,\n        )\n", "tokens": ["src", "flask", "blueprints", "py", "blueprintsetupstate", "def", "add_url_rule", "self", "rule", "str", "endpoint", "t", "optional", "str", "none", "view_func", "t", "optional", "t", "callable", "none", "options", "t", "any", "none", "a", "helper", "method", "to", "register", "a", "rule", "and", "optionally", "a", "view", "function", "to", "the", "application", "the", "endpoint", "is", "automatically", "prefixed", "with", "the", "blueprint", "s", "name", "if", "self", "url_prefix", "is", "not", "none", "if", "rule", "rule", "join", "self", "url_prefix", "rstrip", "rule", "lstrip", "else", "rule", "self", "url_prefix", "options", "setdefault", "subdomain", "self", "subdomain", "if", "endpoint", "is", "none", "endpoint", "_endpoint_from_view_func", "view_func", "type", "ignore", "defaults", "self", "url_defaults", "if", "defaults", "in", "options", "defaults", "dict", "defaults", "options", "pop", "defaults", "self", "app", "add_url_rule", "rule", "f", "self", "name_prefix", "self", "name", "endpoint", "lstrip", "view_func", "defaults", "defaults", "options"], "doc_len": 111}
{"doc_id": "src/flask/blueprints.py::Blueprint.__init__", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "__init__", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n        static_url_path: t.Optional[str] = None,\n        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n        url_prefix: t.Optional[str] = None,\n        subdomain: t.Optional[str] = None,\n        url_defaults: t.Optional[dict] = None,\n        root_path: t.Optional[str] = None,\n        cli_group: t.Optional[str] = _sentinel,  # type: ignore\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if \".\" in name:\n            raise ValueError(\"'name' may not contain a dot '.' character.\")\n\n        self.name = name\n        self.url_prefix = url_prefix\n        self.subdomain = subdomain\n        self.deferred_functions: t.List[DeferredSetupFunction] = []\n\n        if url_defaults is None:\n            url_defaults = {}\n\n        self.url_values_defaults = url_defaults\n        self.cli_group = cli_group\n        self._blueprints: t.List[t.Tuple[\"Blueprint\", dict]] = []\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "__init__", "self", "name", "str", "import_name", "str", "static_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "none", "static_url_path", "t", "optional", "str", "none", "template_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "none", "url_prefix", "t", "optional", "str", "none", "subdomain", "t", "optional", "str", "none", "url_defaults", "t", "optional", "dict", "none", "root_path", "t", "optional", "str", "none", "cli_group", "t", "optional", "str", "_sentinel", "type", "ignore", "super", "__init__", "import_name", "import_name", "static_folder", "static_folder", "static_url_path", "static_url_path", "template_folder", "template_folder", "root_path", "root_path", "if", "in", "name", "raise", "valueerror", "name", "may", "not", "contain", "a", "dot", "character", "self", "name", "name", "self", "url_prefix", "url_prefix", "self", "subdomain", "subdomain", "self", "deferred_functions", "t", "list", "deferredsetupfunction", "if", "url_defaults", "is", "none", "url_defaults", "self", "url_values_defaults", "url_defaults", "self", "cli_group", "cli_group", "self", "_blueprints", "t", "list", "t", "tuple", "blueprint", "dict"], "doc_len": 119}
{"doc_id": "src/flask/blueprints.py::Blueprint._check_setup_finished", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "_check_setup_finished", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def _check_setup_finished(self, f_name: str) -> None:\n        if self._got_registered_once:\n            raise AssertionError(\n                f\"The setup method '{f_name}' can no longer be called on the blueprint\"\n                f\" '{self.name}'. It has already been registered at least once, any\"\n                \" changes will not be applied consistently.\\n\"\n                \"Make sure all imports, decorators, functions, etc. needed to set up\"\n                \" the blueprint are done before registering it.\"\n            )\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "_check_setup_finished", "self", "f_name", "str", "none", "if", "self", "_got_registered_once", "raise", "assertionerror", "f", "the", "setup", "method", "f_name", "can", "no", "longer", "be", "called", "on", "the", "blueprint", "f", "self", "name", "it", "has", "already", "been", "registered", "at", "least", "once", "any", "changes", "will", "not", "be", "applied", "consistently", "n", "make", "sure", "all", "imports", "decorators", "functions", "etc", "needed", "to", "set", "up", "the", "blueprint", "are", "done", "before", "registering", "it"], "doc_len": 66}
{"doc_id": "src/flask/blueprints.py::Blueprint.record", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "record", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def record(self, func: t.Callable) -> None:\n        \"\"\"Registers a function that is called when the blueprint is\n        registered on the application.  This function is called with the\n        state as argument as returned by the :meth:`make_setup_state`\n        method.\n        \"\"\"\n        self.deferred_functions.append(func)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "record", "self", "func", "t", "callable", "none", "registers", "a", "function", "that", "is", "called", "when", "the", "blueprint", "is", "registered", "on", "the", "application", "this", "function", "is", "called", "with", "the", "state", "as", "argument", "as", "returned", "by", "the", "meth", "make_setup_state", "method", "self", "deferred_functions", "append", "func"], "doc_len": 46}
{"doc_id": "src/flask/blueprints.py::Blueprint.record_once", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "record_once", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def record_once(self, func: t.Callable) -> None:\n        \"\"\"Works like :meth:`record` but wraps the function in another\n        function that will ensure the function is only called once.  If the\n        blueprint is registered a second time on the application, the\n        function passed is not called.\n        \"\"\"\n\n        def wrapper(state: BlueprintSetupState) -> None:\n            if state.first_registration:\n                func(state)\n\n        self.record(update_wrapper(wrapper, func))\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "record_once", "self", "func", "t", "callable", "none", "works", "like", "meth", "record", "but", "wraps", "the", "function", "in", "another", "function", "that", "will", "ensure", "the", "function", "is", "only", "called", "once", "if", "the", "blueprint", "is", "registered", "a", "second", "time", "on", "the", "application", "the", "function", "passed", "is", "not", "called", "def", "wrapper", "state", "blueprintsetupstate", "none", "if", "state", "first_registration", "func", "state", "self", "record", "update_wrapper", "wrapper", "func"], "doc_len": 64}
{"doc_id": "src/flask/blueprints.py::Blueprint.make_setup_state", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "make_setup_state", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def make_setup_state(\n        self, app: \"Flask\", options: dict, first_registration: bool = False\n    ) -> BlueprintSetupState:\n        \"\"\"Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`\n        object that is later passed to the register callback functions.\n        Subclasses can override this to return a subclass of the setup state.\n        \"\"\"\n        return BlueprintSetupState(self, app, options, first_registration)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "make_setup_state", "self", "app", "flask", "options", "dict", "first_registration", "bool", "false", "blueprintsetupstate", "creates", "an", "instance", "of", "meth", "flask", "blueprints", "blueprintsetupstate", "object", "that", "is", "later", "passed", "to", "the", "register", "callback", "functions", "subclasses", "can", "override", "this", "to", "return", "a", "subclass", "of", "the", "setup", "state", "return", "blueprintsetupstate", "self", "app", "options", "first_registration"], "doc_len": 52}
{"doc_id": "src/flask/blueprints.py::Blueprint.register_blueprint", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "register_blueprint", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def register_blueprint(self, blueprint: \"Blueprint\", **options: t.Any) -> None:\n        \"\"\"Register a :class:`~flask.Blueprint` on this blueprint. Keyword\n        arguments passed to this method will override the defaults set\n        on the blueprint.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        if blueprint is self:\n            raise ValueError(\"Cannot register a blueprint on itself\")\n        self._blueprints.append((blueprint, options))\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "register_blueprint", "self", "blueprint", "blueprint", "options", "t", "any", "none", "register", "a", "class", "flask", "blueprint", "on", "this", "blueprint", "keyword", "arguments", "passed", "to", "this", "method", "will", "override", "the", "defaults", "set", "on", "the", "blueprint", "versionchanged", "2", "0", "1", "the", "name", "option", "can", "be", "used", "to", "change", "the", "pre", "dotted", "name", "the", "blueprint", "is", "registered", "with", "this", "allows", "the", "same", "blueprint", "to", "be", "registered", "multiple", "times", "with", "unique", "names", "for", "url_for", "versionadded", "2", "0", "if", "blueprint", "is", "self", "raise", "valueerror", "cannot", "register", "a", "blueprint", "on", "itself", "self", "_blueprints", "append", "blueprint", "options"], "doc_len": 92}
{"doc_id": "src/flask/blueprints.py::Blueprint.register", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "register", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def register(self, app: \"Flask\", options: dict) -> None:\n        \"\"\"Called by :meth:`Flask.register_blueprint` to register all\n        views and callbacks registered on the blueprint with the\n        application. Creates a :class:`.BlueprintSetupState` and calls\n        each :meth:`record` callback with it.\n\n        :param app: The application this blueprint is being registered\n            with.\n        :param options: Keyword arguments forwarded from\n            :meth:`~Flask.register_blueprint`.\n\n        .. versionchanged:: 2.3\n            Nested blueprints now correctly apply subdomains.\n\n        .. versionchanged:: 2.1\n            Registering the same blueprint with the same name multiple\n            times is an error.\n\n        .. versionchanged:: 2.0.1\n            Nested blueprints are registered with their dotted name.\n            This allows different blueprints with the same name to be\n            nested at different locations.\n\n        .. versionchanged:: 2.0.1\n            The ``name`` option can be used to change the (pre-dotted)\n            name the blueprint is registered with. This allows the same\n            blueprint to be registered multiple times with unique names\n            for ``url_for``.\n        \"\"\"\n        name_prefix = options.get(\"name_prefix\", \"\")\n        self_name = options.get(\"name\", self.name)\n        name = f\"{name_prefix}.{self_name}\".lstrip(\".\")\n\n        if name in app.blueprints:\n            bp_desc = \"this\" if app.blueprints[name] is self else \"a different\"\n            existing_at = f\" '{name}'\" if self_name != name else \"\"\n\n            raise ValueError(\n                f\"The name '{self_name}' is already registered for\"\n                f\" {bp_desc} blueprint{existing_at}. Use 'name=' to\"\n                f\" provide a unique name.\"\n            )\n\n        first_bp_registration = not any(bp is self for bp in app.blueprints.values())\n        first_name_registration = name not in app.blueprints\n\n        app.blueprints[name] = self\n        self._got_registered_once = True\n        state = self.make_setup_state(app, options, first_bp_registration)\n\n        if self.has_static_folder:\n            state.add_url_rule(\n                f\"{self.static_url_path}/<path:filename>\",\n                view_func=self.send_static_file,\n                endpoint=\"static\",\n            )\n\n        # Merge blueprint data into parent.\n        if first_bp_registration or first_name_registration:\n\n            def extend(bp_dict, parent_dict):\n                for key, values in bp_dict.items():\n                    key = name if key is None else f\"{name}.{key}\"\n                    parent_dict[key].extend(values)\n\n            for key, value in self.error_handler_spec.items():\n                key = name if key is None else f\"{name}.{key}\"\n                value = defaultdict(\n                    dict,\n                    {\n                        code: {\n                            exc_class: func for exc_class, func in code_values.items()\n                        }\n                        for code, code_values in value.items()\n                    },\n                )\n                app.error_handler_spec[key] = value\n\n            for endpoint, func in self.view_functions.items():\n                app.view_functions[endpoint] = func\n\n            extend(self.before_request_funcs, app.before_request_funcs)\n            extend(self.after_request_funcs, app.after_request_funcs)\n            extend(\n                self.teardown_request_funcs,\n                app.teardown_request_funcs,\n            )\n            extend(self.url_default_functions, app.url_default_functions)\n            extend(self.url_value_preprocessors, app.url_value_preprocessors)\n            extend(self.template_context_processors, app.template_context_processors)\n\n        for deferred in self.deferred_functions:\n            deferred(state)\n\n        cli_resolved_group = options.get(\"cli_group\", self.cli_group)\n\n        if self.cli.commands:\n            if cli_resolved_group is None:\n                app.cli.commands.update(self.cli.commands)\n            elif cli_resolved_group is _sentinel:\n                self.cli.name = name\n                app.cli.add_command(self.cli)\n            else:\n                self.cli.name = cli_resolved_group\n                app.cli.add_command(self.cli)\n\n        for blueprint, bp_options in self._blueprints:\n            bp_options = bp_options.copy()\n            bp_url_prefix = bp_options.get(\"url_prefix\")\n            bp_subdomain = bp_options.get(\"subdomain\")\n\n            if bp_subdomain is None:\n                bp_subdomain = blueprint.subdomain\n\n            if state.subdomain is not None and bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain\n            elif bp_subdomain is not None:\n                bp_options[\"subdomain\"] = bp_subdomain\n            elif state.subdomain is not None:\n                bp_options[\"subdomain\"] = state.subdomain\n\n            if bp_url_prefix is None:\n                bp_url_prefix = blueprint.url_prefix\n\n            if state.url_prefix is not None and bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = (\n                    state.url_prefix.rstrip(\"/\") + \"/\" + bp_url_prefix.lstrip(\"/\")\n                )\n            elif bp_url_prefix is not None:\n                bp_options[\"url_prefix\"] = bp_url_prefix\n            elif state.url_prefix is not None:\n                bp_options[\"url_prefix\"] = state.url_prefix\n\n            bp_options[\"name_prefix\"] = name\n            blueprint.register(app, bp_options)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "register", "self", "app", "flask", "options", "dict", "none", "called", "by", "meth", "flask", "register_blueprint", "to", "register", "all", "views", "and", "callbacks", "registered", "on", "the", "blueprint", "with", "the", "application", "creates", "a", "class", "blueprintsetupstate", "and", "calls", "each", "meth", "record", "callback", "with", "it", "param", "app", "the", "application", "this", "blueprint", "is", "being", "registered", "with", "param", "options", "keyword", "arguments", "forwarded", "from", "meth", "flask", "register_blueprint", "versionchanged", "2", "3", "nested", "blueprints", "now", "correctly", "apply", "subdomains", "versionchanged", "2", "1", "registering", "the", "same", "blueprint", "with", "the", "same", "name", "multiple", "times", "is", "an", "error", "versionchanged", "2", "0", "1", "nested", "blueprints", "are", "registered", "with", "their", "dotted", "name", "this", "allows", "different", "blueprints", "with", "the", "same", "name", "to", "be", "nested", "at", "different", "locations", "versionchanged", "2", "0", "1", "the", "name", "option", "can", "be", "used", "to", "change", "the", "pre", "dotted", "name", "the", "blueprint", "is", "registered", "with", "this", "allows", "the", "same", "blueprint", "to", "be", "registered", "multiple", "times", "with", "unique", "names", "for", "url_for", "name_prefix", "options", "get", "name_prefix", "self_name", "options", "get", "name", "self", "name", "name", "f", "name_prefix", "self_name", "lstrip", "if", "name", "in", "app", "blueprints", "bp_desc", "this", "if", "app", "blueprints", "name", "is", "self", "else", "a", "different", "existing_at", "f", "name", "if", "self_name", "name", "else", "raise", "valueerror", "f", "the", "name", "self_name", "is", "already", "registered", "for", "f", "bp_desc", "blueprint", "existing_at", "use", "name", "to", "f", "provide", "a", "unique", "name", "first_bp_registration", "not", "any", "bp", "is", "self", "for", "bp", "in", "app", "blueprints", "values", "first_name_registration", "name", "not", "in", "app", "blueprints", "app", "blueprints", "name", "self", "self", "_got_registered_once", "true", "state", "self", "make_setup_state", "app", "options", "first_bp_registration", "if", "self", "has_static_folder", "state", "add_url_rule", "f", "self", "static_url_path", "path", "filename", "view_func", "self", "send_static_file", "endpoint", "static", "merge", "blueprint", "data", "into", "parent", "if", "first_bp_registration", "or", "first_name_registration", "def", "extend", "bp_dict", "parent_dict", "for", "key", "values", "in", "bp_dict", "items", "key", "name", "if", "key", "is", "none", "else", "f", "name", "key", "parent_dict", "key", "extend", "values", "for", "key", "value", "in", "self", "error_handler_spec", "items", "key", "name", "if", "key", "is", "none", "else", "f", "name", "key", "value", "defaultdict", "dict", "code", "exc_class", "func", "for", "exc_class", "func", "in", "code_values", "items", "for", "code", "code_values", "in", "value", "items", "app", "error_handler_spec", "key", "value", "for", "endpoint", "func", "in", "self", "view_functions", "items", "app", "view_functions", "endpoint", "func", "extend", "self", "before_request_funcs", "app", "before_request_funcs", "extend", "self", "after_request_funcs", "app", "after_request_funcs", "extend", "self", "teardown_request_funcs", "app", "teardown_request_funcs", "extend", "self", "url_default_functions", "app", "url_default_functions", "extend", "self", "url_value_preprocessors", "app", "url_value_preprocessors", "extend", "self", "template_context_processors", "app", "template_context_processors", "for", "deferred", "in", "self", "deferred_functions", "deferred", "state", "cli_resolved_group", "options", "get", "cli_group", "self", "cli_group", "if", "self", "cli", "commands", "if", "cli_resolved_group", "is", "none", "app", "cli", "commands", "update", "self", "cli", "commands", "elif", "cli_resolved_group", "is", "_sentinel", "self", "cli", "name", "name", "app", "cli", "add_command", "self", "cli", "else", "self", "cli", "name", "cli_resolved_group", "app", "cli", "add_command", "self", "cli", "for", "blueprint", "bp_options", "in", "self", "_blueprints", "bp_options", "bp_options", "copy", "bp_url_prefix", "bp_options", "get", "url_prefix", "bp_subdomain", "bp_options", "get", "subdomain", "if", "bp_subdomain", "is", "none", "bp_subdomain", "blueprint", "subdomain", "if", "state", "subdomain", "is", "not", "none", "and", "bp_subdomain", "is", "not", "none", "bp_options", "subdomain", "bp_subdomain", "state", "subdomain", "elif", "bp_subdomain", "is", "not", "none", "bp_options", "subdomain", "bp_subdomain", "elif", "state", "subdomain", "is", "not", "none", "bp_options", "subdomain", "state", "subdomain", "if", "bp_url_prefix", "is", "none", "bp_url_prefix", "blueprint", "url_prefix", "if", "state", "url_prefix", "is", "not", "none", "and", "bp_url_prefix", "is", "not", "none", "bp_options", "url_prefix", "state", "url_prefix", "rstrip", "bp_url_prefix", "lstrip", "elif", "bp_url_prefix", "is", "not", "none", "bp_options", "url_prefix", "bp_url_prefix", "elif", "state", "url_prefix", "is", "not", "none", "bp_options", "url_prefix", "state", "url_prefix", "bp_options", "name_prefix", "name", "blueprint", "register", "app", "bp_options"], "doc_len": 527}
{"doc_id": "src/flask/blueprints.py::Blueprint.add_url_rule", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "add_url_rule", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[ft.RouteCallable] = None,\n        provide_automatic_options: t.Optional[bool] = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a URL rule with the blueprint. See :meth:`.Flask.add_url_rule` for\n        full documentation.\n\n        The URL rule is prefixed with the blueprint's URL prefix. The endpoint name,\n        used with :func:`url_for`, is prefixed with the blueprint's name.\n        \"\"\"\n        if endpoint and \".\" in endpoint:\n            raise ValueError(\"'endpoint' may not contain a dot '.' character.\")\n\n        if view_func and hasattr(view_func, \"__name__\") and \".\" in view_func.__name__:\n            raise ValueError(\"'view_func' name may not contain a dot '.' character.\")\n\n        self.record(\n            lambda s: s.add_url_rule(\n                rule,\n                endpoint,\n                view_func,\n                provide_automatic_options=provide_automatic_options,\n                **options,\n            )\n        )\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "add_url_rule", "self", "rule", "str", "endpoint", "t", "optional", "str", "none", "view_func", "t", "optional", "ft", "routecallable", "none", "provide_automatic_options", "t", "optional", "bool", "none", "options", "t", "any", "none", "register", "a", "url", "rule", "with", "the", "blueprint", "see", "meth", "flask", "add_url_rule", "for", "full", "documentation", "the", "url", "rule", "is", "prefixed", "with", "the", "blueprint", "s", "url", "prefix", "the", "endpoint", "name", "used", "with", "func", "url_for", "is", "prefixed", "with", "the", "blueprint", "s", "name", "if", "endpoint", "and", "in", "endpoint", "raise", "valueerror", "endpoint", "may", "not", "contain", "a", "dot", "character", "if", "view_func", "and", "hasattr", "view_func", "__name__", "and", "in", "view_func", "__name__", "raise", "valueerror", "view_func", "name", "may", "not", "contain", "a", "dot", "character", "self", "record", "lambda", "s", "s", "add_url_rule", "rule", "endpoint", "view_func", "provide_automatic_options", "provide_automatic_options", "options"], "doc_len": 115}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_template_filter", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_template_filter", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_template_filter(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_filter], T_template_filter]:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_filter) -> T_template_filter:\n            self.add_app_template_filter(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_template_filter", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_filter", "t_template_filter", "register", "a", "template", "filter", "available", "in", "any", "template", "rendered", "by", "the", "application", "equivalent", "to", "meth", "flask", "template_filter", "param", "name", "the", "optional", "name", "of", "the", "filter", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_filter", "t_template_filter", "self", "add_app_template_filter", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 63}
{"doc_id": "src/flask/blueprints.py::Blueprint.add_app_template_filter", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "add_app_template_filter", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def add_app_template_filter(\n        self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a template filter, available in any template rendered by the\n        application. Works like the :meth:`app_template_filter` decorator. Equivalent to\n        :meth:`.Flask.add_template_filter`.\n\n        :param name: the optional name of the filter, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.filters[name or f.__name__] = f\n\n        self.record_once(register_template)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "add_app_template_filter", "self", "f", "ft", "templatefiltercallable", "name", "t", "optional", "str", "none", "none", "register", "a", "template", "filter", "available", "in", "any", "template", "rendered", "by", "the", "application", "works", "like", "the", "meth", "app_template_filter", "decorator", "equivalent", "to", "meth", "flask", "add_template_filter", "param", "name", "the", "optional", "name", "of", "the", "filter", "otherwise", "the", "function", "name", "will", "be", "used", "def", "register_template", "state", "blueprintsetupstate", "none", "state", "app", "jinja_env", "filters", "name", "or", "f", "__name__", "f", "self", "record_once", "register_template"], "doc_len": 72}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_template_test", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_template_test", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_template_test(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_test], T_template_test]:\n        \"\"\"Register a template test, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_test`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_test) -> T_template_test:\n            self.add_app_template_test(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_template_test", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_test", "t_template_test", "register", "a", "template", "test", "available", "in", "any", "template", "rendered", "by", "the", "application", "equivalent", "to", "meth", "flask", "template_test", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "test", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_test", "t_template_test", "self", "add_app_template_test", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 66}
{"doc_id": "src/flask/blueprints.py::Blueprint.add_app_template_test", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "add_app_template_test", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def add_app_template_test(\n        self, f: ft.TemplateTestCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a template test, available in any template rendered by the\n        application. Works like the :meth:`app_template_test` decorator. Equivalent to\n        :meth:`.Flask.add_template_test`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the test, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.tests[name or f.__name__] = f\n\n        self.record_once(register_template)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "add_app_template_test", "self", "f", "ft", "templatetestcallable", "name", "t", "optional", "str", "none", "none", "register", "a", "template", "test", "available", "in", "any", "template", "rendered", "by", "the", "application", "works", "like", "the", "meth", "app_template_test", "decorator", "equivalent", "to", "meth", "flask", "add_template_test", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "test", "otherwise", "the", "function", "name", "will", "be", "used", "def", "register_template", "state", "blueprintsetupstate", "none", "state", "app", "jinja_env", "tests", "name", "or", "f", "__name__", "f", "self", "record_once", "register_template"], "doc_len": 75}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_template_global", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_template_global", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_template_global(\n        self, name: t.Optional[str] = None\n    ) -> t.Callable[[T_template_global], T_template_global]:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Equivalent to :meth:`.Flask.template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def decorator(f: T_template_global) -> T_template_global:\n            self.add_app_template_global(f, name=name)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_template_global", "self", "name", "t", "optional", "str", "none", "t", "callable", "t_template_global", "t_template_global", "register", "a", "template", "global", "available", "in", "any", "template", "rendered", "by", "the", "application", "equivalent", "to", "meth", "flask", "template_global", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "global", "otherwise", "the", "function", "name", "will", "be", "used", "def", "decorator", "f", "t_template_global", "t_template_global", "self", "add_app_template_global", "f", "name", "name", "return", "f", "return", "decorator"], "doc_len": 66}
{"doc_id": "src/flask/blueprints.py::Blueprint.add_app_template_global", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "add_app_template_global", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def add_app_template_global(\n        self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None\n    ) -> None:\n        \"\"\"Register a template global, available in any template rendered by the\n        application. Works like the :meth:`app_template_global` decorator. Equivalent to\n        :meth:`.Flask.add_template_global`.\n\n        .. versionadded:: 0.10\n\n        :param name: the optional name of the global, otherwise the\n                     function name will be used.\n        \"\"\"\n\n        def register_template(state: BlueprintSetupState) -> None:\n            state.app.jinja_env.globals[name or f.__name__] = f\n\n        self.record_once(register_template)\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "add_app_template_global", "self", "f", "ft", "templateglobalcallable", "name", "t", "optional", "str", "none", "none", "register", "a", "template", "global", "available", "in", "any", "template", "rendered", "by", "the", "application", "works", "like", "the", "meth", "app_template_global", "decorator", "equivalent", "to", "meth", "flask", "add_template_global", "versionadded", "0", "10", "param", "name", "the", "optional", "name", "of", "the", "global", "otherwise", "the", "function", "name", "will", "be", "used", "def", "register_template", "state", "blueprintsetupstate", "none", "state", "app", "jinja_env", "globals", "name", "or", "f", "__name__", "f", "self", "record_once", "register_template"], "doc_len": 75}
{"doc_id": "src/flask/blueprints.py::Blueprint.before_app_request", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "before_app_request", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def before_app_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Like :meth:`before_request`, but before every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.before_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "before_app_request", "self", "f", "t_before_request", "t_before_request", "like", "meth", "before_request", "but", "before", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "before_request", "self", "record_once", "lambda", "s", "s", "app", "before_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 43}
{"doc_id": "src/flask/blueprints.py::Blueprint.after_app_request", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "after_app_request", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def after_app_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Like :meth:`after_request`, but after every request, not only those handled\n        by the blueprint. Equivalent to :meth:`.Flask.after_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "after_app_request", "self", "f", "t_after_request", "t_after_request", "like", "meth", "after_request", "but", "after", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "after_request", "self", "record_once", "lambda", "s", "s", "app", "after_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 43}
{"doc_id": "src/flask/blueprints.py::Blueprint.teardown_app_request", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "teardown_app_request", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def teardown_app_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Like :meth:`teardown_request`, but after every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.teardown_request`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "teardown_app_request", "self", "f", "t_teardown", "t_teardown", "like", "meth", "teardown_request", "but", "after", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "teardown_request", "self", "record_once", "lambda", "s", "s", "app", "teardown_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 43}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_context_processor", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_context_processor", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_context_processor(\n        self, f: T_template_context_processor\n    ) -> T_template_context_processor:\n        \"\"\"Like :meth:`context_processor`, but for templates rendered by every view, not\n        only by the blueprint. Equivalent to :meth:`.Flask.context_processor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.template_context_processors.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_context_processor", "self", "f", "t_template_context_processor", "t_template_context_processor", "like", "meth", "context_processor", "but", "for", "templates", "rendered", "by", "every", "view", "not", "only", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "context_processor", "self", "record_once", "lambda", "s", "s", "app", "template_context_processors", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 44}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_errorhandler", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_errorhandler", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_errorhandler(\n        self, code: t.Union[t.Type[Exception], int]\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Like :meth:`errorhandler`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.errorhandler`.\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_errorhandler", "self", "code", "t", "union", "t", "type", "exception", "int", "t", "callable", "t_error_handler", "t_error_handler", "like", "meth", "errorhandler", "but", "for", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "errorhandler", "def", "decorator", "f", "t_error_handler", "t_error_handler", "self", "record_once", "lambda", "s", "s", "app", "errorhandler", "code", "f", "return", "f", "return", "decorator"], "doc_len": 56}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_url_value_preprocessor", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_url_value_preprocessor", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_url_value_preprocessor(\n        self, f: T_url_value_preprocessor\n    ) -> T_url_value_preprocessor:\n        \"\"\"Like :meth:`url_value_preprocessor`, but for every request, not only those\n        handled by the blueprint. Equivalent to :meth:`.Flask.url_value_preprocessor`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_url_value_preprocessor", "self", "f", "t_url_value_preprocessor", "t_url_value_preprocessor", "like", "meth", "url_value_preprocessor", "but", "for", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "url_value_preprocessor", "self", "record_once", "lambda", "s", "s", "app", "url_value_preprocessors", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 43}
{"doc_id": "src/flask/blueprints.py::Blueprint.app_url_defaults", "file_path": "src/flask/blueprints.py", "class_name": "Blueprint", "func_name": "app_url_defaults", "text": "文件路径: src/flask/blueprints.py, 类名: Blueprint\n    def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Like :meth:`url_defaults`, but for every request, not only those handled by\n        the blueprint. Equivalent to :meth:`.Flask.url_defaults`.\n        \"\"\"\n        self.record_once(\n            lambda s: s.app.url_default_functions.setdefault(None, []).append(f)\n        )\n        return f\n", "tokens": ["src", "flask", "blueprints", "py", "blueprint", "def", "app_url_defaults", "self", "f", "t_url_defaults", "t_url_defaults", "like", "meth", "url_defaults", "but", "for", "every", "request", "not", "only", "those", "handled", "by", "the", "blueprint", "equivalent", "to", "meth", "flask", "url_defaults", "self", "record_once", "lambda", "s", "s", "app", "url_default_functions", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 43}
{"doc_id": "src/flask/cli.py::find_best_app", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "find_best_app", "text": "文件路径: src/flask/cli.py\ndef find_best_app(module):\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError as e:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n\n                raise NoAppException(\n                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                    \" but could not call it without arguments. Use\"\n                    f\" '{module.__name__}:{attr_name}(args)'\"\n                    \" to specify arguments.\"\n                ) from e\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n        \" to specify one.\"\n    )\n", "tokens": ["src", "flask", "cli", "py", "def", "find_best_app", "module", "given", "a", "module", "instance", "this", "tries", "to", "find", "the", "best", "possible", "application", "in", "the", "module", "or", "raises", "an", "exception", "from", "import", "flask", "search", "for", "the", "most", "common", "names", "first", "for", "attr_name", "in", "app", "application", "app", "getattr", "module", "attr_name", "none", "if", "isinstance", "app", "flask", "return", "app", "otherwise", "find", "the", "only", "object", "that", "is", "a", "flask", "instance", "matches", "v", "for", "v", "in", "module", "__dict__", "values", "if", "isinstance", "v", "flask", "if", "len", "matches", "1", "return", "matches", "0", "elif", "len", "matches", "1", "raise", "noappexception", "detected", "multiple", "flask", "applications", "in", "module", "f", "module", "__name__", "use", "module", "__name__", "name", "to", "specify", "the", "correct", "one", "search", "for", "app", "factory", "functions", "for", "attr_name", "in", "create_app", "make_app", "app_factory", "getattr", "module", "attr_name", "none", "if", "inspect", "isfunction", "app_factory", "try", "app", "app_factory", "if", "isinstance", "app", "flask", "return", "app", "except", "typeerror", "as", "e", "if", "not", "_called_with_wrong_args", "app_factory", "raise", "raise", "noappexception", "f", "detected", "factory", "attr_name", "in", "module", "module", "__name__", "but", "could", "not", "call", "it", "without", "arguments", "use", "f", "module", "__name__", "attr_name", "args", "to", "specify", "arguments", "from", "e", "raise", "noappexception", "failed", "to", "find", "flask", "application", "or", "factory", "in", "module", "f", "module", "__name__", "use", "module", "__name__", "name", "to", "specify", "one"], "doc_len": 191}
{"doc_id": "src/flask/cli.py::_called_with_wrong_args", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_called_with_wrong_args", "text": "文件路径: src/flask/cli.py\ndef _called_with_wrong_args(f):\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb\n", "tokens": ["src", "flask", "cli", "py", "def", "_called_with_wrong_args", "f", "check", "whether", "calling", "a", "function", "raised", "a", "typeerror", "because", "the", "call", "failed", "or", "because", "something", "in", "the", "factory", "raised", "the", "error", "param", "f", "the", "function", "that", "was", "called", "return", "true", "if", "the", "call", "failed", "tb", "sys", "exc_info", "2", "try", "while", "tb", "is", "not", "none", "if", "tb", "tb_frame", "f_code", "is", "f", "__code__", "in", "the", "function", "it", "was", "called", "successfully", "return", "false", "tb", "tb", "tb_next", "didn", "t", "reach", "the", "function", "return", "true", "finally", "delete", "tb", "to", "break", "a", "circular", "reference", "https", "docs", "python", "org", "2", "library", "sys", "html", "sys", "exc_info", "del", "tb"], "doc_len": 97}
{"doc_id": "src/flask/cli.py::find_app_by_string", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "find_app_by_string", "text": "文件路径: src/flask/cli.py\ndef find_app_by_string(module, app_name):\n    \"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"\n    from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        ) from None\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = []\n        kwargs = {}\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {kw.arg: ast.literal_eval(kw.value) for kw in expr.keywords}\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            ) from None\n    else:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(\n            f\"Failed to find attribute {name!r} in {module.__name__!r}.\"\n        ) from e\n\n    # If the attribute is a function, call it with any args and kwargs\n    # to get the real application.\n    if inspect.isfunction(attr):\n        try:\n            app = attr(*args, **kwargs)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                f\"The factory {app_name!r} in module\"\n                f\" {module.__name__!r} could not be called with the\"\n                \" specified arguments.\"\n            ) from e\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        \"A valid Flask application was not obtained from\"\n        f\" '{module.__name__}:{app_name}'.\"\n    )\n", "tokens": ["src", "flask", "cli", "py", "def", "find_app_by_string", "module", "app_name", "check", "if", "the", "given", "string", "is", "a", "variable", "name", "or", "a", "function", "call", "a", "function", "to", "get", "the", "app", "instance", "or", "return", "the", "variable", "directly", "from", "import", "flask", "parse", "app_name", "as", "a", "single", "expression", "to", "determine", "if", "it", "s", "a", "valid", "attribute", "name", "or", "function", "call", "try", "expr", "ast", "parse", "app_name", "strip", "mode", "eval", "body", "except", "syntaxerror", "raise", "noappexception", "f", "failed", "to", "parse", "app_name", "r", "as", "an", "attribute", "name", "or", "function", "call", "from", "none", "if", "isinstance", "expr", "ast", "name", "name", "expr", "id", "args", "kwargs", "elif", "isinstance", "expr", "ast", "call", "ensure", "the", "function", "name", "is", "an", "attribute", "name", "only", "if", "not", "isinstance", "expr", "func", "ast", "name", "raise", "noappexception", "f", "function", "reference", "must", "be", "a", "simple", "name", "app_name", "r", "name", "expr", "func", "id", "parse", "the", "positional", "and", "keyword", "arguments", "as", "literals", "try", "args", "ast", "literal_eval", "arg", "for", "arg", "in", "expr", "args", "kwargs", "kw", "arg", "ast", "literal_eval", "kw", "value", "for", "kw", "in", "expr", "keywords", "except", "valueerror", "literal_eval", "gives", "cryptic", "error", "messages", "show", "a", "generic", "message", "with", "the", "full", "expression", "instead", "raise", "noappexception", "f", "failed", "to", "parse", "arguments", "as", "literal", "values", "app_name", "r", "from", "none", "else", "raise", "noappexception", "f", "failed", "to", "parse", "app_name", "r", "as", "an", "attribute", "name", "or", "function", "call", "try", "attr", "getattr", "module", "name", "except", "attributeerror", "as", "e", "raise", "noappexception", "f", "failed", "to", "find", "attribute", "name", "r", "in", "module", "__name__", "r", "from", "e", "if", "the", "attribute", "is", "a", "function", "call", "it", "with", "any", "args", "and", "kwargs", "to", "get", "the", "real", "application", "if", "inspect", "isfunction", "attr", "try", "app", "attr", "args", "kwargs", "except", "typeerror", "as", "e", "if", "not", "_called_with_wrong_args", "attr", "raise", "raise", "noappexception", "f", "the", "factory", "app_name", "r", "in", "module", "f", "module", "__name__", "r", "could", "not", "be", "called", "with", "the", "specified", "arguments", "from", "e", "else", "app", "attr", "if", "isinstance", "app", "flask", "return", "app", "raise", "noappexception", "a", "valid", "flask", "application", "was", "not", "obtained", "from", "f", "module", "__name__", "app_name"], "doc_len": 311}
{"doc_id": "src/flask/cli.py::prepare_import", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "prepare_import", "text": "文件路径: src/flask/cli.py\ndef prepare_import(path):\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])\n", "tokens": ["src", "flask", "cli", "py", "def", "prepare_import", "path", "given", "a", "filename", "this", "will", "try", "to", "calculate", "the", "python", "path", "add", "it", "to", "the", "search", "path", "and", "return", "the", "actual", "module", "name", "that", "is", "expected", "path", "os", "path", "realpath", "path", "fname", "ext", "os", "path", "splitext", "path", "if", "ext", "py", "path", "fname", "if", "os", "path", "basename", "path", "__init__", "path", "os", "path", "dirname", "path", "module_name", "move", "up", "until", "outside", "package", "structure", "no", "__init__", "py", "while", "true", "path", "name", "os", "path", "split", "path", "module_name", "append", "name", "if", "not", "os", "path", "exists", "os", "path", "join", "path", "__init__", "py", "break", "if", "sys", "path", "0", "path", "sys", "path", "insert", "0", "path", "return", "join", "module_name", "1"], "doc_len": 107}
{"doc_id": "src/flask/cli.py::locate_app", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "locate_app", "text": "文件路径: src/flask/cli.py\ndef locate_app(module_name, app_name, raise_if_not_found=True):\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)\n", "tokens": ["src", "flask", "cli", "py", "def", "locate_app", "module_name", "app_name", "raise_if_not_found", "true", "try", "__import__", "module_name", "except", "importerror", "reraise", "the", "importerror", "if", "it", "occurred", "within", "the", "imported", "module", "determine", "this", "by", "checking", "whether", "the", "trace", "has", "a", "depth", "1", "if", "sys", "exc_info", "2", "tb_next", "raise", "noappexception", "f", "while", "importing", "module_name", "r", "an", "importerror", "was", "f", "raised", "n", "n", "traceback", "format_exc", "from", "none", "elif", "raise_if_not_found", "raise", "noappexception", "f", "could", "not", "import", "module_name", "r", "from", "none", "else", "return", "module", "sys", "modules", "module_name", "if", "app_name", "is", "none", "return", "find_best_app", "module", "else", "return", "find_app_by_string", "module", "app_name"], "doc_len": 89}
{"doc_id": "src/flask/cli.py::get_version", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "get_version", "text": "文件路径: src/flask/cli.py\ndef get_version(ctx, param, value):\n    if not value or ctx.resilient_parsing:\n        return\n\n    import werkzeug\n    from . import __version__\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {__version__}\\n\"\n        f\"Werkzeug {werkzeug.__version__}\",\n        color=ctx.color,\n    )\n    ctx.exit()\n", "tokens": ["src", "flask", "cli", "py", "def", "get_version", "ctx", "param", "value", "if", "not", "value", "or", "ctx", "resilient_parsing", "return", "import", "werkzeug", "from", "import", "__version__", "click", "echo", "f", "python", "platform", "python_version", "n", "f", "flask", "__version__", "n", "f", "werkzeug", "werkzeug", "__version__", "color", "ctx", "color", "ctx", "exit"], "doc_len": 41}
{"doc_id": "src/flask/cli.py::ScriptInfo.__init__", "file_path": "src/flask/cli.py", "class_name": "ScriptInfo", "func_name": "__init__", "text": "文件路径: src/flask/cli.py, 类名: ScriptInfo\n    def __init__(\n        self,\n        app_import_path: str | None = None,\n        create_app: t.Callable[..., Flask] | None = None,\n        set_debug_flag: bool = True,\n    ) -> None:\n        #: Optionally the import path for the Flask application.\n        self.app_import_path = app_import_path\n        #: Optionally a function that is passed the script info to create\n        #: the instance of the application.\n        self.create_app = create_app\n        #: A dictionary with arbitrary data that can be associated with\n        #: this script info.\n        self.data: t.Dict[t.Any, t.Any] = {}\n        self.set_debug_flag = set_debug_flag\n        self._loaded_app: Flask | None = None\n", "tokens": ["src", "flask", "cli", "py", "scriptinfo", "def", "__init__", "self", "app_import_path", "str", "none", "none", "create_app", "t", "callable", "flask", "none", "none", "set_debug_flag", "bool", "true", "none", "optionally", "the", "import", "path", "for", "the", "flask", "application", "self", "app_import_path", "app_import_path", "optionally", "a", "function", "that", "is", "passed", "the", "script", "info", "to", "create", "the", "instance", "of", "the", "application", "self", "create_app", "create_app", "a", "dictionary", "with", "arbitrary", "data", "that", "can", "be", "associated", "with", "this", "script", "info", "self", "data", "t", "dict", "t", "any", "t", "any", "self", "set_debug_flag", "set_debug_flag", "self", "_loaded_app", "flask", "none", "none"], "doc_len": 81}
{"doc_id": "src/flask/cli.py::ScriptInfo.load_app", "file_path": "src/flask/cli.py", "class_name": "ScriptInfo", "func_name": "load_app", "text": "文件路径: src/flask/cli.py, 类名: ScriptInfo\n    def load_app(self) -> Flask:\n        \"\"\"Loads the Flask app (if not yet loaded) and returns it.  Calling\n        this multiple times will just result in the already loaded app to\n        be returned.\n        \"\"\"\n        if self._loaded_app is not None:\n            return self._loaded_app\n\n        if self.create_app is not None:\n            app = self.create_app()\n        else:\n            if self.app_import_path:\n                path, name = (\n                    re.split(r\":(?![\\\\/])\", self.app_import_path, 1) + [None]\n                )[:2]\n                import_name = prepare_import(path)\n                app = locate_app(import_name, name)\n            else:\n                for path in (\"wsgi.py\", \"app.py\"):\n                    import_name = prepare_import(path)\n                    app = locate_app(import_name, None, raise_if_not_found=False)\n\n                    if app:\n                        break\n\n        if not app:\n            raise NoAppException(\n                \"Could not locate a Flask application. Use the\"\n                \" 'flask --app' option, 'FLASK_APP' environment\"\n                \" variable, or a 'wsgi.py' or 'app.py' file in the\"\n                \" current directory.\"\n            )\n\n        if self.set_debug_flag:\n            # Update the app's debug flag through the descriptor so that\n            # other values repopulate as well.\n            app.debug = get_debug_flag()\n\n        self._loaded_app = app\n        return app\n", "tokens": ["src", "flask", "cli", "py", "scriptinfo", "def", "load_app", "self", "flask", "loads", "the", "flask", "app", "if", "not", "yet", "loaded", "and", "returns", "it", "calling", "this", "multiple", "times", "will", "just", "result", "in", "the", "already", "loaded", "app", "to", "be", "returned", "if", "self", "_loaded_app", "is", "not", "none", "return", "self", "_loaded_app", "if", "self", "create_app", "is", "not", "none", "app", "self", "create_app", "else", "if", "self", "app_import_path", "path", "name", "re", "split", "r", "self", "app_import_path", "1", "none", "2", "import_name", "prepare_import", "path", "app", "locate_app", "import_name", "name", "else", "for", "path", "in", "wsgi", "py", "app", "py", "import_name", "prepare_import", "path", "app", "locate_app", "import_name", "none", "raise_if_not_found", "false", "if", "app", "break", "if", "not", "app", "raise", "noappexception", "could", "not", "locate", "a", "flask", "application", "use", "the", "flask", "app", "option", "flask_app", "environment", "variable", "or", "a", "wsgi", "py", "or", "app", "py", "file", "in", "the", "current", "directory", "if", "self", "set_debug_flag", "update", "the", "app", "s", "debug", "flag", "through", "the", "descriptor", "so", "that", "other", "values", "repopulate", "as", "well", "app", "debug", "get_debug_flag", "self", "_loaded_app", "app", "return", "app"], "doc_len": 152}
{"doc_id": "src/flask/cli.py::with_appcontext", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "with_appcontext", "text": "文件路径: src/flask/cli.py\ndef with_appcontext(f):\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.\n\n    Custom commands (and their options) registered under ``app.cli`` or\n    ``blueprint.cli`` will always have an app context available, this\n    decorator is not required in that case.\n\n    .. versionchanged:: 2.2\n        The app context is active for subcommands as well as the\n        decorated callback. The app context is always available to\n        ``app.cli`` command and parameter callbacks.\n    \"\"\"\n\n    @click.pass_context\n    def decorator(__ctx, *args, **kwargs):\n        if not current_app:\n            app = __ctx.ensure_object(ScriptInfo).load_app()\n            __ctx.with_resource(app.app_context())\n\n        return __ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)\n", "tokens": ["src", "flask", "cli", "py", "def", "with_appcontext", "f", "wraps", "a", "callback", "so", "that", "it", "s", "guaranteed", "to", "be", "executed", "with", "the", "script", "s", "application", "context", "custom", "commands", "and", "their", "options", "registered", "under", "app", "cli", "or", "blueprint", "cli", "will", "always", "have", "an", "app", "context", "available", "this", "decorator", "is", "not", "required", "in", "that", "case", "versionchanged", "2", "2", "the", "app", "context", "is", "active", "for", "subcommands", "as", "well", "as", "the", "decorated", "callback", "the", "app", "context", "is", "always", "available", "to", "app", "cli", "command", "and", "parameter", "callbacks", "click", "pass_context", "def", "decorator", "__ctx", "args", "kwargs", "if", "not", "current_app", "app", "__ctx", "ensure_object", "scriptinfo", "load_app", "__ctx", "with_resource", "app", "app_context", "return", "__ctx", "invoke", "f", "args", "kwargs", "return", "update_wrapper", "decorator", "f"], "doc_len": 109}
{"doc_id": "src/flask/cli.py::AppGroup.command", "file_path": "src/flask/cli.py", "class_name": "AppGroup", "func_name": "command", "text": "文件路径: src/flask/cli.py, 类名: AppGroup\n    def command(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it wraps callbacks in :func:`with_appcontext`\n        unless it's disabled by passing ``with_appcontext=False``.\n        \"\"\"\n        wrap_for_ctx = kwargs.pop(\"with_appcontext\", True)\n\n        def decorator(f):\n            if wrap_for_ctx:\n                f = with_appcontext(f)\n            return click.Group.command(self, *args, **kwargs)(f)\n\n        return decorator\n", "tokens": ["src", "flask", "cli", "py", "appgroup", "def", "command", "self", "args", "kwargs", "this", "works", "exactly", "like", "the", "method", "of", "the", "same", "name", "on", "a", "regular", "class", "click", "group", "but", "it", "wraps", "callbacks", "in", "func", "with_appcontext", "unless", "it", "s", "disabled", "by", "passing", "with_appcontext", "false", "wrap_for_ctx", "kwargs", "pop", "with_appcontext", "true", "def", "decorator", "f", "if", "wrap_for_ctx", "f", "with_appcontext", "f", "return", "click", "group", "command", "self", "args", "kwargs", "f", "return", "decorator"], "doc_len": 64}
{"doc_id": "src/flask/cli.py::AppGroup.group", "file_path": "src/flask/cli.py", "class_name": "AppGroup", "func_name": "group", "text": "文件路径: src/flask/cli.py, 类名: AppGroup\n    def group(self, *args, **kwargs):\n        \"\"\"This works exactly like the method of the same name on a regular\n        :class:`click.Group` but it defaults the group class to\n        :class:`AppGroup`.\n        \"\"\"\n        kwargs.setdefault(\"cls\", AppGroup)\n        return click.Group.group(self, *args, **kwargs)\n", "tokens": ["src", "flask", "cli", "py", "appgroup", "def", "group", "self", "args", "kwargs", "this", "works", "exactly", "like", "the", "method", "of", "the", "same", "name", "on", "a", "regular", "class", "click", "group", "but", "it", "defaults", "the", "group", "class", "to", "class", "appgroup", "kwargs", "setdefault", "cls", "appgroup", "return", "click", "group", "group", "self", "args", "kwargs"], "doc_len": 46}
{"doc_id": "src/flask/cli.py::_set_app", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_set_app", "text": "文件路径: src/flask/cli.py\ndef _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value\n", "tokens": ["src", "flask", "cli", "py", "def", "_set_app", "ctx", "click", "context", "param", "click", "option", "value", "str", "none", "str", "none", "if", "value", "is", "none", "return", "none", "info", "ctx", "ensure_object", "scriptinfo", "info", "app_import_path", "value", "return", "value"], "doc_len": 32}
{"doc_id": "src/flask/cli.py::_set_debug", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_set_debug", "text": "文件路径: src/flask/cli.py\ndef _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value\n", "tokens": ["src", "flask", "cli", "py", "def", "_set_debug", "ctx", "click", "context", "param", "click", "option", "value", "bool", "bool", "none", "if", "the", "flag", "isn", "t", "provided", "it", "will", "default", "to", "false", "don", "t", "use", "that", "let", "debug", "be", "set", "by", "env", "in", "that", "case", "source", "ctx", "get_parameter_source", "param", "name", "type", "ignore", "arg", "type", "if", "source", "is", "not", "none", "and", "source", "in", "parametersource", "default", "parametersource", "default_map", "return", "none", "set", "with", "env", "var", "instead", "of", "scriptinfo", "load", "so", "that", "it", "can", "be", "accessed", "early", "during", "a", "factory", "function", "os", "environ", "flask_debug", "1", "if", "value", "else", "0", "return", "value"], "doc_len": 92}
{"doc_id": "src/flask/cli.py::_env_file_callback", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_env_file_callback", "text": "文件路径: src/flask/cli.py\ndef _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    if value is None:\n        return None\n\n    import importlib\n\n    try:\n        importlib.import_module(\"dotenv\")\n    except ImportError:\n        raise click.BadParameter(\n            \"python-dotenv must be installed to load an env file.\",\n            ctx=ctx,\n            param=param,\n        ) from None\n\n    # Don't check FLASK_SKIP_DOTENV, that only disables automatically\n    # loading .env and .flaskenv files.\n    load_dotenv(value)\n    return value\n", "tokens": ["src", "flask", "cli", "py", "def", "_env_file_callback", "ctx", "click", "context", "param", "click", "option", "value", "str", "none", "str", "none", "if", "value", "is", "none", "return", "none", "import", "importlib", "try", "importlib", "import_module", "dotenv", "except", "importerror", "raise", "click", "badparameter", "python", "dotenv", "must", "be", "installed", "to", "load", "an", "env", "file", "ctx", "ctx", "param", "param", "from", "none", "don", "t", "check", "flask_skip_dotenv", "that", "only", "disables", "automatically", "loading", "env", "and", "flaskenv", "files", "load_dotenv", "value", "return", "value"], "doc_len": 67}
{"doc_id": "src/flask/cli.py::FlaskGroup.__init__", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "__init__", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def __init__(\n        self,\n        add_default_commands: bool = True,\n        create_app: t.Callable[..., Flask] | None = None,\n        add_version_option: bool = True,\n        load_dotenv: bool = True,\n        set_debug_flag: bool = True,\n        **extra: t.Any,\n    ) -> None:\n        params = list(extra.pop(\"params\", None) or ())\n        # Processing is done with option callbacks instead of a group\n        # callback. This allows users to make a custom group callback\n        # without losing the behavior. --env-file must come first so\n        # that it is eagerly evaluated before --app.\n        params.extend((_env_file_option, _app_option, _debug_option))\n\n        if add_version_option:\n            params.append(version_option)\n\n        if \"context_settings\" not in extra:\n            extra[\"context_settings\"] = {}\n\n        extra[\"context_settings\"].setdefault(\"auto_envvar_prefix\", \"FLASK\")\n\n        super().__init__(params=params, **extra)\n\n        self.create_app = create_app\n        self.load_dotenv = load_dotenv\n        self.set_debug_flag = set_debug_flag\n\n        if add_default_commands:\n            self.add_command(run_command)\n            self.add_command(shell_command)\n            self.add_command(routes_command)\n\n        self._loaded_plugin_commands = False\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "__init__", "self", "add_default_commands", "bool", "true", "create_app", "t", "callable", "flask", "none", "none", "add_version_option", "bool", "true", "load_dotenv", "bool", "true", "set_debug_flag", "bool", "true", "extra", "t", "any", "none", "params", "list", "extra", "pop", "params", "none", "or", "processing", "is", "done", "with", "option", "callbacks", "instead", "of", "a", "group", "callback", "this", "allows", "users", "to", "make", "a", "custom", "group", "callback", "without", "losing", "the", "behavior", "env", "file", "must", "come", "first", "so", "that", "it", "is", "eagerly", "evaluated", "before", "app", "params", "extend", "_env_file_option", "_app_option", "_debug_option", "if", "add_version_option", "params", "append", "version_option", "if", "context_settings", "not", "in", "extra", "extra", "context_settings", "extra", "context_settings", "setdefault", "auto_envvar_prefix", "flask", "super", "__init__", "params", "params", "extra", "self", "create_app", "create_app", "self", "load_dotenv", "load_dotenv", "self", "set_debug_flag", "set_debug_flag", "if", "add_default_commands", "self", "add_command", "run_command", "self", "add_command", "shell_command", "self", "add_command", "routes_command", "self", "_loaded_plugin_commands", "false"], "doc_len": 124}
{"doc_id": "src/flask/cli.py::FlaskGroup._load_plugin_commands", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "_load_plugin_commands", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def _load_plugin_commands(self):\n        if self._loaded_plugin_commands:\n            return\n\n        if sys.version_info >= (3, 10):\n            from importlib import metadata\n        else:\n            # Use a backport on Python < 3.10. We technically have\n            # importlib.metadata on 3.8+, but the API changed in 3.10,\n            # so use the backport for consistency.\n            import importlib_metadata as metadata\n\n        for ep in metadata.entry_points(group=\"flask.commands\"):\n            self.add_command(ep.load(), ep.name)\n\n        self._loaded_plugin_commands = True\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "_load_plugin_commands", "self", "if", "self", "_loaded_plugin_commands", "return", "if", "sys", "version_info", "3", "10", "from", "importlib", "import", "metadata", "else", "use", "a", "backport", "on", "python", "3", "10", "we", "technically", "have", "importlib", "metadata", "on", "3", "8", "but", "the", "api", "changed", "in", "3", "10", "so", "use", "the", "backport", "for", "consistency", "import", "importlib_metadata", "as", "metadata", "for", "ep", "in", "metadata", "entry_points", "group", "flask", "commands", "self", "add_command", "ep", "load", "ep", "name", "self", "_loaded_plugin_commands", "true"], "doc_len": 71}
{"doc_id": "src/flask/cli.py::FlaskGroup.get_command", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "get_command", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def get_command(self, ctx, name):\n        self._load_plugin_commands()\n        # Look up built-in and plugin commands, which should be\n        # available even if the app fails to load.\n        rv = super().get_command(ctx, name)\n\n        if rv is not None:\n            return rv\n\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Look up commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            app = info.load_app()\n        except NoAppException as e:\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n            return None\n\n        # Push an app context for the loaded app unless it is already\n        # active somehow. This makes the context available to parameter\n        # and command callbacks without needing @with_appcontext.\n        if not current_app or current_app._get_current_object() is not app:\n            ctx.with_resource(app.app_context())\n\n        return app.cli.get_command(ctx, name)\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "get_command", "self", "ctx", "name", "self", "_load_plugin_commands", "look", "up", "built", "in", "and", "plugin", "commands", "which", "should", "be", "available", "even", "if", "the", "app", "fails", "to", "load", "rv", "super", "get_command", "ctx", "name", "if", "rv", "is", "not", "none", "return", "rv", "info", "ctx", "ensure_object", "scriptinfo", "look", "up", "commands", "provided", "by", "the", "app", "showing", "an", "error", "and", "continuing", "if", "the", "app", "couldn", "t", "be", "loaded", "try", "app", "info", "load_app", "except", "noappexception", "as", "e", "click", "secho", "f", "error", "e", "format_message", "n", "err", "true", "fg", "red", "return", "none", "push", "an", "app", "context", "for", "the", "loaded", "app", "unless", "it", "is", "already", "active", "somehow", "this", "makes", "the", "context", "available", "to", "parameter", "and", "command", "callbacks", "without", "needing", "with_appcontext", "if", "not", "current_app", "or", "current_app", "_get_current_object", "is", "not", "app", "ctx", "with_resource", "app", "app_context", "return", "app", "cli", "get_command", "ctx", "name"], "doc_len": 132}
{"doc_id": "src/flask/cli.py::FlaskGroup.list_commands", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "list_commands", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def list_commands(self, ctx):\n        self._load_plugin_commands()\n        # Start with the built-in and plugin commands.\n        rv = set(super().list_commands(ctx))\n        info = ctx.ensure_object(ScriptInfo)\n\n        # Add commands provided by the app, showing an error and\n        # continuing if the app couldn't be loaded.\n        try:\n            rv.update(info.load_app().cli.list_commands(ctx))\n        except NoAppException as e:\n            # When an app couldn't be loaded, show the error message\n            # without the traceback.\n            click.secho(f\"Error: {e.format_message()}\\n\", err=True, fg=\"red\")\n        except Exception:\n            # When any other errors occurred during loading, show the\n            # full traceback.\n            click.secho(f\"{traceback.format_exc()}\\n\", err=True, fg=\"red\")\n\n        return sorted(rv)\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "list_commands", "self", "ctx", "self", "_load_plugin_commands", "start", "with", "the", "built", "in", "and", "plugin", "commands", "rv", "set", "super", "list_commands", "ctx", "info", "ctx", "ensure_object", "scriptinfo", "add", "commands", "provided", "by", "the", "app", "showing", "an", "error", "and", "continuing", "if", "the", "app", "couldn", "t", "be", "loaded", "try", "rv", "update", "info", "load_app", "cli", "list_commands", "ctx", "except", "noappexception", "as", "e", "when", "an", "app", "couldn", "t", "be", "loaded", "show", "the", "error", "message", "without", "the", "traceback", "click", "secho", "f", "error", "e", "format_message", "n", "err", "true", "fg", "red", "except", "exception", "when", "any", "other", "errors", "occurred", "during", "loading", "show", "the", "full", "traceback", "click", "secho", "f", "traceback", "format_exc", "n", "err", "true", "fg", "red", "return", "sorted", "rv"], "doc_len": 109}
{"doc_id": "src/flask/cli.py::FlaskGroup.make_context", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "make_context", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def make_context(\n        self,\n        info_name: str | None,\n        args: list[str],\n        parent: click.Context | None = None,\n        **extra: t.Any,\n    ) -> click.Context:\n        # Set a flag to tell app.run to become a no-op. If app.run was\n        # not in a __name__ == __main__ guard, it would start the server\n        # when importing, blocking whatever command is being called.\n        os.environ[\"FLASK_RUN_FROM_CLI\"] = \"true\"\n\n        # Attempt to load .env and .flask env files. The --env-file\n        # option can cause another file to be loaded.\n        if get_load_dotenv(self.load_dotenv):\n            load_dotenv()\n\n        if \"obj\" not in extra and \"obj\" not in self.context_settings:\n            extra[\"obj\"] = ScriptInfo(\n                create_app=self.create_app, set_debug_flag=self.set_debug_flag\n            )\n\n        return super().make_context(info_name, args, parent=parent, **extra)\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "make_context", "self", "info_name", "str", "none", "args", "list", "str", "parent", "click", "context", "none", "none", "extra", "t", "any", "click", "context", "set", "a", "flag", "to", "tell", "app", "run", "to", "become", "a", "no", "op", "if", "app", "run", "was", "not", "in", "a", "__name__", "__main__", "guard", "it", "would", "start", "the", "server", "when", "importing", "blocking", "whatever", "command", "is", "being", "called", "os", "environ", "flask_run_from_cli", "true", "attempt", "to", "load", "env", "and", "flask", "env", "files", "the", "env", "file", "option", "can", "cause", "another", "file", "to", "be", "loaded", "if", "get_load_dotenv", "self", "load_dotenv", "load_dotenv", "if", "obj", "not", "in", "extra", "and", "obj", "not", "in", "self", "context_settings", "extra", "obj", "scriptinfo", "create_app", "self", "create_app", "set_debug_flag", "self", "set_debug_flag", "return", "super", "make_context", "info_name", "args", "parent", "parent", "extra"], "doc_len": 115}
{"doc_id": "src/flask/cli.py::FlaskGroup.parse_args", "file_path": "src/flask/cli.py", "class_name": "FlaskGroup", "func_name": "parse_args", "text": "文件路径: src/flask/cli.py, 类名: FlaskGroup\n    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:\n        if not args and self.no_args_is_help:\n            # Attempt to load --env-file and --app early in case they\n            # were given as env vars. Otherwise no_args_is_help will not\n            # see commands from app.cli.\n            _env_file_option.handle_parse_result(ctx, {}, [])\n            _app_option.handle_parse_result(ctx, {}, [])\n\n        return super().parse_args(ctx, args)\n", "tokens": ["src", "flask", "cli", "py", "flaskgroup", "def", "parse_args", "self", "ctx", "click", "context", "args", "list", "str", "list", "str", "if", "not", "args", "and", "self", "no_args_is_help", "attempt", "to", "load", "env", "file", "and", "app", "early", "in", "case", "they", "were", "given", "as", "env", "vars", "otherwise", "no_args_is_help", "will", "not", "see", "commands", "from", "app", "cli", "_env_file_option", "handle_parse_result", "ctx", "_app_option", "handle_parse_result", "ctx", "return", "super", "parse_args", "ctx", "args"], "doc_len": 58}
{"doc_id": "src/flask/cli.py::_path_is_ancestor", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_path_is_ancestor", "text": "文件路径: src/flask/cli.py\ndef _path_is_ancestor(path, other):\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other\n", "tokens": ["src", "flask", "cli", "py", "def", "_path_is_ancestor", "path", "other", "take", "other", "and", "remove", "the", "length", "of", "path", "from", "it", "then", "join", "it", "to", "path", "if", "it", "is", "the", "original", "value", "path", "is", "an", "ancestor", "of", "other", "return", "os", "path", "join", "path", "other", "len", "path", "lstrip", "os", "sep", "other"], "doc_len": 47}
{"doc_id": "src/flask/cli.py::load_dotenv", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "load_dotenv", "text": "文件路径: src/flask/cli.py\ndef load_dotenv(path: str | os.PathLike | None = None) -> bool:\n    \"\"\"Load \"dotenv\" files in order of precedence to set environment variables.\n\n    If an env var is already set it is not overwritten, so earlier files in the\n    list are preferred over later files.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location instead of searching.\n    :return: ``True`` if a file was loaded.\n\n    .. versionchanged:: 2.0\n        The current directory is not changed to the location of the\n        loaded file.\n\n    .. versionchanged:: 2.0\n        When loading the env files, set the default encoding to UTF-8.\n\n    .. versionchanged:: 1.1.0\n        Returns ``False`` when python-dotenv is not installed, or when\n        the given path isn't a file.\n\n    .. versionadded:: 1.0\n    \"\"\"\n    try:\n        import dotenv\n    except ImportError:\n        if path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\n            click.secho(\n                \" * Tip: There are .env or .flaskenv files present.\"\n                ' Do \"pip install python-dotenv\" to use them.',\n                fg=\"yellow\",\n                err=True,\n            )\n\n        return False\n\n    # Always return after attempting to load a given path, don't load\n    # the default files.\n    if path is not None:\n        if os.path.isfile(path):\n            return dotenv.load_dotenv(path, encoding=\"utf-8\")\n\n        return False\n\n    loaded = False\n\n    for name in (\".env\", \".flaskenv\"):\n        path = dotenv.find_dotenv(name, usecwd=True)\n\n        if not path:\n            continue\n\n        dotenv.load_dotenv(path, encoding=\"utf-8\")\n        loaded = True\n\n    return loaded  # True if at least one file was located and loaded.\n", "tokens": ["src", "flask", "cli", "py", "def", "load_dotenv", "path", "str", "os", "pathlike", "none", "none", "bool", "load", "dotenv", "files", "in", "order", "of", "precedence", "to", "set", "environment", "variables", "if", "an", "env", "var", "is", "already", "set", "it", "is", "not", "overwritten", "so", "earlier", "files", "in", "the", "list", "are", "preferred", "over", "later", "files", "this", "is", "a", "no", "op", "if", "python", "dotenv", "_", "is", "not", "installed", "_python", "dotenv", "https", "github", "com", "theskumar", "python", "dotenv", "readme", "param", "path", "load", "the", "file", "at", "this", "location", "instead", "of", "searching", "return", "true", "if", "a", "file", "was", "loaded", "versionchanged", "2", "0", "the", "current", "directory", "is", "not", "changed", "to", "the", "location", "of", "the", "loaded", "file", "versionchanged", "2", "0", "when", "loading", "the", "env", "files", "set", "the", "default", "encoding", "to", "utf", "8", "versionchanged", "1", "1", "0", "returns", "false", "when", "python", "dotenv", "is", "not", "installed", "or", "when", "the", "given", "path", "isn", "t", "a", "file", "versionadded", "1", "0", "try", "import", "dotenv", "except", "importerror", "if", "path", "or", "os", "path", "isfile", "env", "or", "os", "path", "isfile", "flaskenv", "click", "secho", "tip", "there", "are", "env", "or", "flaskenv", "files", "present", "do", "pip", "install", "python", "dotenv", "to", "use", "them", "fg", "yellow", "err", "true", "return", "false", "always", "return", "after", "attempting", "to", "load", "a", "given", "path", "don", "t", "load", "the", "default", "files", "if", "path", "is", "not", "none", "if", "os", "path", "isfile", "path", "return", "dotenv", "load_dotenv", "path", "encoding", "utf", "8", "return", "false", "loaded", "false", "for", "name", "in", "env", "flaskenv", "path", "dotenv", "find_dotenv", "name", "usecwd", "true", "if", "not", "path", "continue", "dotenv", "load_dotenv", "path", "encoding", "utf", "8", "loaded", "true", "return", "loaded", "true", "if", "at", "least", "one", "file", "was", "located", "and", "loaded"], "doc_len": 252}
{"doc_id": "src/flask/cli.py::show_server_banner", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "show_server_banner", "text": "文件路径: src/flask/cli.py\ndef show_server_banner(debug, app_import_path):\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if is_running_from_reloader():\n        return\n\n    if app_import_path is not None:\n        click.echo(f\" * Serving Flask app '{app_import_path}'\")\n\n    if debug is not None:\n        click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")\n", "tokens": ["src", "flask", "cli", "py", "def", "show_server_banner", "debug", "app_import_path", "show", "extra", "startup", "messages", "the", "first", "time", "the", "server", "is", "run", "ignoring", "the", "reloader", "if", "is_running_from_reloader", "return", "if", "app_import_path", "is", "not", "none", "click", "echo", "f", "serving", "flask", "app", "app_import_path", "if", "debug", "is", "not", "none", "click", "echo", "f", "debug", "mode", "on", "if", "debug", "else", "off"], "doc_len": 52}
{"doc_id": "src/flask/cli.py::CertParamType.__init__", "file_path": "src/flask/cli.py", "class_name": "CertParamType", "func_name": "__init__", "text": "文件路径: src/flask/cli.py, 类名: CertParamType\n    def __init__(self):\n        self.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)\n", "tokens": ["src", "flask", "cli", "py", "certparamtype", "def", "__init__", "self", "self", "path_type", "click", "path", "exists", "true", "dir_okay", "false", "resolve_path", "true"], "doc_len": 18}
{"doc_id": "src/flask/cli.py::CertParamType.convert", "file_path": "src/flask/cli.py", "class_name": "CertParamType", "func_name": "convert", "text": "文件路径: src/flask/cli.py, 类名: CertParamType\n    def convert(self, value, param, ctx):\n        try:\n            import ssl\n        except ImportError:\n            raise click.BadParameter(\n                'Using \"--cert\" requires Python to be compiled with SSL support.',\n                ctx,\n                param,\n            ) from None\n\n        try:\n            return self.path_type(value, param, ctx)\n        except click.BadParameter:\n            value = click.STRING(value, param, ctx).lower()\n\n            if value == \"adhoc\":\n                try:\n                    import cryptography  # noqa: F401\n                except ImportError:\n                    raise click.BadParameter(\n                        \"Using ad-hoc certificates requires the cryptography library.\",\n                        ctx,\n                        param,\n                    ) from None\n\n                return value\n\n            obj = import_string(value, silent=True)\n\n            if isinstance(obj, ssl.SSLContext):\n                return obj\n\n            raise\n", "tokens": ["src", "flask", "cli", "py", "certparamtype", "def", "convert", "self", "value", "param", "ctx", "try", "import", "ssl", "except", "importerror", "raise", "click", "badparameter", "using", "cert", "requires", "python", "to", "be", "compiled", "with", "ssl", "support", "ctx", "param", "from", "none", "try", "return", "self", "path_type", "value", "param", "ctx", "except", "click", "badparameter", "value", "click", "string", "value", "param", "ctx", "lower", "if", "value", "adhoc", "try", "import", "cryptography", "noqa", "f401", "except", "importerror", "raise", "click", "badparameter", "using", "ad", "hoc", "certificates", "requires", "the", "cryptography", "library", "ctx", "param", "from", "none", "return", "value", "obj", "import_string", "value", "silent", "true", "if", "isinstance", "obj", "ssl", "sslcontext", "return", "obj", "raise"], "doc_len": 90}
{"doc_id": "src/flask/cli.py::_validate_key", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "_validate_key", "text": "文件路径: src/flask/cli.py\ndef _validate_key(ctx, param, value):\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key is not used.', ctx, param\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value\n", "tokens": ["src", "flask", "cli", "py", "def", "_validate_key", "ctx", "param", "value", "the", "key", "option", "must", "be", "specified", "when", "cert", "is", "a", "file", "modifies", "the", "cert", "param", "to", "be", "a", "cert", "key", "pair", "if", "needed", "cert", "ctx", "params", "get", "cert", "is_adhoc", "cert", "adhoc", "try", "import", "ssl", "except", "importerror", "is_context", "false", "else", "is_context", "isinstance", "cert", "ssl", "sslcontext", "if", "value", "is", "not", "none", "if", "is_adhoc", "raise", "click", "badparameter", "when", "cert", "is", "adhoc", "key", "is", "not", "used", "ctx", "param", "if", "is_context", "raise", "click", "badparameter", "when", "cert", "is", "an", "sslcontext", "object", "key", "is", "not", "used", "ctx", "param", "if", "not", "cert", "raise", "click", "badparameter", "cert", "must", "also", "be", "specified", "ctx", "param", "ctx", "params", "cert", "cert", "value", "else", "if", "cert", "and", "not", "is_adhoc", "or", "is_context", "raise", "click", "badparameter", "required", "when", "using", "cert", "ctx", "param", "return", "value"], "doc_len": 127}
{"doc_id": "src/flask/cli.py::SeparatedPathType.convert", "file_path": "src/flask/cli.py", "class_name": "SeparatedPathType", "func_name": "convert", "text": "文件路径: src/flask/cli.py, 类名: SeparatedPathType\n    def convert(self, value, param, ctx):\n        items = self.split_envvar_value(value)\n        super_convert = super().convert\n        return [super_convert(item, param, ctx) for item in items]\n", "tokens": ["src", "flask", "cli", "py", "separatedpathtype", "def", "convert", "self", "value", "param", "ctx", "items", "self", "split_envvar_value", "value", "super_convert", "super", "convert", "return", "super_convert", "item", "param", "ctx", "for", "item", "in", "items"], "doc_len": 27}
{"doc_id": "src/flask/cli.py::run_command", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "run_command", "text": "文件路径: src/flask/cli.py\ndef run_command(\n    info,\n    host,\n    port,\n    reload,\n    debugger,\n    with_threads,\n    cert,\n    extra_files,\n    exclude_patterns,\n):\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app = info.load_app()\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(environ, start_response):\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )\n", "tokens": ["src", "flask", "cli", "py", "def", "run_command", "info", "host", "port", "reload", "debugger", "with_threads", "cert", "extra_files", "exclude_patterns", "run", "a", "local", "development", "server", "this", "server", "is", "for", "development", "purposes", "only", "it", "does", "not", "provide", "the", "stability", "security", "or", "performance", "of", "production", "wsgi", "servers", "the", "reloader", "and", "debugger", "are", "enabled", "by", "default", "with", "the", "debug", "option", "try", "app", "info", "load_app", "except", "exception", "as", "e", "if", "is_running_from_reloader", "when", "reloading", "print", "out", "the", "error", "immediately", "but", "raise", "it", "later", "so", "the", "debugger", "or", "server", "can", "handle", "it", "traceback", "print_exc", "err", "e", "def", "app", "environ", "start_response", "raise", "err", "from", "none", "else", "when", "not", "reloading", "raise", "the", "error", "immediately", "so", "the", "command", "fails", "raise", "e", "from", "none", "debug", "get_debug_flag", "if", "reload", "is", "none", "reload", "debug", "if", "debugger", "is", "none", "debugger", "debug", "show_server_banner", "debug", "info", "app_import_path", "run_simple", "host", "port", "app", "use_reloader", "reload", "use_debugger", "debugger", "threaded", "with_threads", "ssl_context", "cert", "extra_files", "extra_files", "exclude_patterns", "exclude_patterns"], "doc_len": 143}
{"doc_id": "src/flask/cli.py::shell_command", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "shell_command", "text": "文件路径: src/flask/cli.py\ndef shell_command() -> None:\n    \"\"\"Run an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to its configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n\n    banner = (\n        f\"Python {sys.version} on {sys.platform}\\n\"\n        f\"App: {current_app.import_name}\\n\"\n        f\"Instance: {current_app.instance_path}\"\n    )\n    ctx: dict = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get(\"PYTHONSTARTUP\")\n    if startup and os.path.isfile(startup):\n        with open(startup) as f:\n            eval(compile(f.read(), startup, \"exec\"), ctx)\n\n    ctx.update(current_app.make_shell_context())\n\n    # Site, customize, or startup script can set a hook to call when\n    # entering interactive mode. The default one sets up readline with\n    # tab and history completion.\n    interactive_hook = getattr(sys, \"__interactivehook__\", None)\n\n    if interactive_hook is not None:\n        try:\n            import readline\n            from rlcompleter import Completer\n        except ImportError:\n            pass\n        else:\n            # rlcompleter uses __main__.__dict__ by default, which is\n            # flask.__main__. Use the shell context instead.\n            readline.set_completer(Completer(ctx).complete)\n\n        interactive_hook()\n\n    code.interact(banner=banner, local=ctx)\n", "tokens": ["src", "flask", "cli", "py", "def", "shell_command", "none", "run", "an", "interactive", "python", "shell", "in", "the", "context", "of", "a", "given", "flask", "application", "the", "application", "will", "populate", "the", "default", "namespace", "of", "this", "shell", "according", "to", "its", "configuration", "this", "is", "useful", "for", "executing", "small", "snippets", "of", "management", "code", "without", "having", "to", "manually", "configure", "the", "application", "import", "code", "banner", "f", "python", "sys", "version", "on", "sys", "platform", "n", "f", "app", "current_app", "import_name", "n", "f", "instance", "current_app", "instance_path", "ctx", "dict", "support", "the", "regular", "python", "interpreter", "startup", "script", "if", "someone", "is", "using", "it", "startup", "os", "environ", "get", "pythonstartup", "if", "startup", "and", "os", "path", "isfile", "startup", "with", "open", "startup", "as", "f", "eval", "compile", "f", "read", "startup", "exec", "ctx", "ctx", "update", "current_app", "make_shell_context", "site", "customize", "or", "startup", "script", "can", "set", "a", "hook", "to", "call", "when", "entering", "interactive", "mode", "the", "default", "one", "sets", "up", "readline", "with", "tab", "and", "history", "completion", "interactive_hook", "getattr", "sys", "__interactivehook__", "none", "if", "interactive_hook", "is", "not", "none", "try", "import", "readline", "from", "rlcompleter", "import", "completer", "except", "importerror", "pass", "else", "rlcompleter", "uses", "__main__", "__dict__", "by", "default", "which", "is", "flask", "__main__", "use", "the", "shell", "context", "instead", "readline", "set_completer", "completer", "ctx", "complete", "interactive_hook", "code", "interact", "banner", "banner", "local", "ctx"], "doc_len": 187}
{"doc_id": "src/flask/cli.py::routes_command", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "routes_command", "text": "文件路径: src/flask/cli.py\ndef routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n\n    rules = list(current_app.url_map.iter_rules())\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set(() if all_methods else (\"HEAD\", \"OPTIONS\"))\n\n    if sort in (\"endpoint\", \"rule\"):\n        rules = sorted(rules, key=attrgetter(sort))\n    elif sort == \"methods\":\n        rules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore\n\n    rule_methods = [\n        \", \".join(sorted(rule.methods - ignored_methods))  # type: ignore\n        for rule in rules\n    ]\n\n    headers = (\"Endpoint\", \"Methods\", \"Rule\")\n    widths = (\n        max(len(rule.endpoint) for rule in rules),\n        max(len(methods) for methods in rule_methods),\n        max(len(rule.rule) for rule in rules),\n    )\n    widths = [max(len(h), w) for h, w in zip(headers, widths)]\n    row = \"{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}\".format(*widths)\n\n    click.echo(row.format(*headers).strip())\n    click.echo(row.format(*(\"-\" * width for width in widths)))\n\n    for rule, methods in zip(rules, rule_methods):\n        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())\n", "tokens": ["src", "flask", "cli", "py", "def", "routes_command", "sort", "str", "all_methods", "bool", "none", "show", "all", "registered", "routes", "with", "endpoints", "and", "methods", "rules", "list", "current_app", "url_map", "iter_rules", "if", "not", "rules", "click", "echo", "no", "routes", "were", "registered", "return", "ignored_methods", "set", "if", "all_methods", "else", "head", "options", "if", "sort", "in", "endpoint", "rule", "rules", "sorted", "rules", "key", "attrgetter", "sort", "elif", "sort", "methods", "rules", "sorted", "rules", "key", "lambda", "rule", "sorted", "rule", "methods", "type", "ignore", "rule_methods", "join", "sorted", "rule", "methods", "ignored_methods", "type", "ignore", "for", "rule", "in", "rules", "headers", "endpoint", "methods", "rule", "widths", "max", "len", "rule", "endpoint", "for", "rule", "in", "rules", "max", "len", "methods", "for", "methods", "in", "rule_methods", "max", "len", "rule", "rule", "for", "rule", "in", "rules", "widths", "max", "len", "h", "w", "for", "h", "w", "in", "zip", "headers", "widths", "row", "0", "0", "1", "1", "2", "2", "format", "widths", "click", "echo", "row", "format", "headers", "strip", "click", "echo", "row", "format", "width", "for", "width", "in", "widths", "for", "rule", "methods", "in", "zip", "rules", "rule_methods", "click", "echo", "row", "format", "rule", "endpoint", "methods", "rule", "rule", "rstrip"], "doc_len": 159}
{"doc_id": "src/flask/cli.py::main", "file_path": "src/flask/cli.py", "class_name": null, "func_name": "main", "text": "文件路径: src/flask/cli.py\ndef main() -> None:\n    cli.main()\n", "tokens": ["src", "flask", "cli", "py", "def", "main", "none", "cli", "main"], "doc_len": 9}
{"doc_id": "src/flask/config.py::ConfigAttribute.__init__", "file_path": "src/flask/config.py", "class_name": "ConfigAttribute", "func_name": "__init__", "text": "文件路径: src/flask/config.py, 类名: ConfigAttribute\n    def __init__(self, name: str, get_converter: t.Optional[t.Callable] = None) -> None:\n        self.__name__ = name\n        self.get_converter = get_converter\n", "tokens": ["src", "flask", "config", "py", "configattribute", "def", "__init__", "self", "name", "str", "get_converter", "t", "optional", "t", "callable", "none", "none", "self", "__name__", "name", "self", "get_converter", "get_converter"], "doc_len": 23}
{"doc_id": "src/flask/config.py::ConfigAttribute.__get__", "file_path": "src/flask/config.py", "class_name": "ConfigAttribute", "func_name": "__get__", "text": "文件路径: src/flask/config.py, 类名: ConfigAttribute\n    def __get__(self, obj: t.Any, owner: t.Any = None) -> t.Any:\n        if obj is None:\n            return self\n        rv = obj.config[self.__name__]\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n        return rv\n", "tokens": ["src", "flask", "config", "py", "configattribute", "def", "__get__", "self", "obj", "t", "any", "owner", "t", "any", "none", "t", "any", "if", "obj", "is", "none", "return", "self", "rv", "obj", "config", "self", "__name__", "if", "self", "get_converter", "is", "not", "none", "rv", "self", "get_converter", "rv", "return", "rv"], "doc_len": 40}
{"doc_id": "src/flask/config.py::ConfigAttribute.__set__", "file_path": "src/flask/config.py", "class_name": "ConfigAttribute", "func_name": "__set__", "text": "文件路径: src/flask/config.py, 类名: ConfigAttribute\n    def __set__(self, obj: t.Any, value: t.Any) -> None:\n        obj.config[self.__name__] = value\n", "tokens": ["src", "flask", "config", "py", "configattribute", "def", "__set__", "self", "obj", "t", "any", "value", "t", "any", "none", "obj", "config", "self", "__name__", "value"], "doc_len": 20}
{"doc_id": "src/flask/config.py::Config.__init__", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "__init__", "text": "文件路径: src/flask/config.py, 类名: Config\n    def __init__(self, root_path: str, defaults: t.Optional[dict] = None) -> None:\n        super().__init__(defaults or {})\n        self.root_path = root_path\n", "tokens": ["src", "flask", "config", "py", "config", "def", "__init__", "self", "root_path", "str", "defaults", "t", "optional", "dict", "none", "none", "super", "__init__", "defaults", "or", "self", "root_path", "root_path"], "doc_len": 23}
{"doc_id": "src/flask/config.py::Config.from_envvar", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_envvar", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_envvar", "self", "variable_name", "str", "silent", "bool", "false", "bool", "loads", "a", "configuration", "from", "an", "environment", "variable", "pointing", "to", "a", "configuration", "file", "this", "is", "basically", "just", "a", "shortcut", "with", "nicer", "error", "messages", "for", "this", "line", "of", "code", "app", "config", "from_pyfile", "os", "environ", "yourapplication_settings", "param", "variable_name", "name", "of", "the", "environment", "variable", "param", "silent", "set", "to", "true", "if", "you", "want", "silent", "failure", "for", "missing", "files", "return", "true", "if", "the", "file", "was", "loaded", "successfully", "rv", "os", "environ", "get", "variable_name", "if", "not", "rv", "if", "silent", "return", "false", "raise", "runtimeerror", "f", "the", "environment", "variable", "variable_name", "r", "is", "not", "set", "and", "as", "such", "configuration", "could", "not", "be", "loaded", "set", "this", "variable", "and", "make", "it", "point", "to", "a", "configuration", "file", "return", "self", "from_pyfile", "rv", "silent", "silent"], "doc_len": 123}
{"doc_id": "src/flask/config.py::Config.from_prefixed_env", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_prefixed_env", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_prefixed_env(\n        self, prefix: str = \"FLASK\", *, loads: t.Callable[[str], t.Any] = json.loads\n    ) -> bool:\n        \"\"\"Load any environment variables that start with ``FLASK_``,\n        dropping the prefix from the env key for the config key. Values\n        are passed through a loading function to attempt to convert them\n        to more specific types than strings.\n\n        Keys are loaded in :func:`sorted` order.\n\n        The default loading function attempts to parse values as any\n        valid JSON type, including dicts and lists.\n\n        Specific items in nested dicts can be set by separating the\n        keys with double underscores (``__``). If an intermediate key\n        doesn't exist, it will be initialized to an empty dict.\n\n        :param prefix: Load env vars that start with this prefix,\n            separated with an underscore (``_``).\n        :param loads: Pass each string value to this function and use\n            the returned value as the config value. If any error is\n            raised it is ignored and the value remains a string. The\n            default is :func:`json.loads`.\n\n        .. versionadded:: 2.1\n        \"\"\"\n        prefix = f\"{prefix}_\"\n        len_prefix = len(prefix)\n\n        for key in sorted(os.environ):\n            if not key.startswith(prefix):\n                continue\n\n            value = os.environ[key]\n\n            try:\n                value = loads(value)\n            except Exception:\n                # Keep the value as a string if loading failed.\n                pass\n\n            # Change to key.removeprefix(prefix) on Python >= 3.9.\n            key = key[len_prefix:]\n\n            if \"__\" not in key:\n                # A non-nested key, set directly.\n                self[key] = value\n                continue\n\n            # Traverse nested dictionaries with keys separated by \"__\".\n            current = self\n            *parts, tail = key.split(\"__\")\n\n            for part in parts:\n                # If an intermediate dict does not exist, create it.\n                if part not in current:\n                    current[part] = {}\n\n                current = current[part]\n\n            current[tail] = value\n\n        return True\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_prefixed_env", "self", "prefix", "str", "flask", "loads", "t", "callable", "str", "t", "any", "json", "loads", "bool", "load", "any", "environment", "variables", "that", "start", "with", "flask_", "dropping", "the", "prefix", "from", "the", "env", "key", "for", "the", "config", "key", "values", "are", "passed", "through", "a", "loading", "function", "to", "attempt", "to", "convert", "them", "to", "more", "specific", "types", "than", "strings", "keys", "are", "loaded", "in", "func", "sorted", "order", "the", "default", "loading", "function", "attempts", "to", "parse", "values", "as", "any", "valid", "json", "type", "including", "dicts", "and", "lists", "specific", "items", "in", "nested", "dicts", "can", "be", "set", "by", "separating", "the", "keys", "with", "double", "underscores", "__", "if", "an", "intermediate", "key", "doesn", "t", "exist", "it", "will", "be", "initialized", "to", "an", "empty", "dict", "param", "prefix", "load", "env", "vars", "that", "start", "with", "this", "prefix", "separated", "with", "an", "underscore", "_", "param", "loads", "pass", "each", "string", "value", "to", "this", "function", "and", "use", "the", "returned", "value", "as", "the", "config", "value", "if", "any", "error", "is", "raised", "it", "is", "ignored", "and", "the", "value", "remains", "a", "string", "the", "default", "is", "func", "json", "loads", "versionadded", "2", "1", "prefix", "f", "prefix", "_", "len_prefix", "len", "prefix", "for", "key", "in", "sorted", "os", "environ", "if", "not", "key", "startswith", "prefix", "continue", "value", "os", "environ", "key", "try", "value", "loads", "value", "except", "exception", "keep", "the", "value", "as", "a", "string", "if", "loading", "failed", "pass", "change", "to", "key", "removeprefix", "prefix", "on", "python", "3", "9", "key", "key", "len_prefix", "if", "__", "not", "in", "key", "a", "non", "nested", "key", "set", "directly", "self", "key", "value", "continue", "traverse", "nested", "dictionaries", "with", "keys", "separated", "by", "__", "current", "self", "parts", "tail", "key", "split", "__", "for", "part", "in", "parts", "if", "an", "intermediate", "dict", "does", "not", "exist", "create", "it", "if", "part", "not", "in", "current", "current", "part", "current", "current", "part", "current", "tail", "value", "return", "true"], "doc_len": 277}
{"doc_id": "src/flask/config.py::Config.from_pyfile", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_pyfile", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_pyfile(self, filename: str, silent: bool = False) -> bool:\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_pyfile", "self", "filename", "str", "silent", "bool", "false", "bool", "updates", "the", "values", "in", "the", "config", "from", "a", "python", "file", "this", "function", "behaves", "as", "if", "the", "file", "was", "imported", "as", "module", "with", "the", "meth", "from_object", "function", "param", "filename", "the", "filename", "of", "the", "config", "this", "can", "either", "be", "an", "absolute", "filename", "or", "a", "filename", "relative", "to", "the", "root", "path", "param", "silent", "set", "to", "true", "if", "you", "want", "silent", "failure", "for", "missing", "files", "return", "true", "if", "the", "file", "was", "loaded", "successfully", "versionadded", "0", "7", "silent", "parameter", "filename", "os", "path", "join", "self", "root_path", "filename", "d", "types", "moduletype", "config", "d", "__file__", "filename", "try", "with", "open", "filename", "mode", "rb", "as", "config_file", "exec", "compile", "config_file", "read", "filename", "exec", "d", "__dict__", "except", "oserror", "as", "e", "if", "silent", "and", "e", "errno", "in", "errno", "enoent", "errno", "eisdir", "errno", "enotdir", "return", "false", "e", "strerror", "f", "unable", "to", "load", "configuration", "file", "e", "strerror", "raise", "self", "from_object", "d", "return", "true"], "doc_len": 152}
{"doc_id": "src/flask/config.py::Config.from_object", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_object", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_object(self, obj: t.Union[object, str]) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_object", "self", "obj", "t", "union", "object", "str", "none", "updates", "the", "values", "from", "the", "given", "object", "an", "object", "can", "be", "of", "one", "of", "the", "following", "two", "types", "a", "string", "in", "this", "case", "the", "object", "with", "that", "name", "will", "be", "imported", "an", "actual", "object", "reference", "that", "object", "is", "used", "directly", "objects", "are", "usually", "either", "modules", "or", "classes", "meth", "from_object", "loads", "only", "the", "uppercase", "attributes", "of", "the", "module", "class", "a", "dict", "object", "will", "not", "work", "with", "meth", "from_object", "because", "the", "keys", "of", "a", "dict", "are", "not", "attributes", "of", "the", "dict", "class", "example", "of", "module", "based", "configuration", "app", "config", "from_object", "yourapplication", "default_config", "from", "yourapplication", "import", "default_config", "app", "config", "from_object", "default_config", "nothing", "is", "done", "to", "the", "object", "before", "loading", "if", "the", "object", "is", "a", "class", "and", "has", "property", "attributes", "it", "needs", "to", "be", "instantiated", "before", "being", "passed", "to", "this", "method", "you", "should", "not", "use", "this", "function", "to", "load", "the", "actual", "configuration", "but", "rather", "configuration", "defaults", "the", "actual", "config", "should", "be", "loaded", "with", "meth", "from_pyfile", "and", "ideally", "from", "a", "location", "not", "within", "the", "package", "because", "the", "package", "might", "be", "installed", "system", "wide", "see", "ref", "config", "dev", "prod", "for", "an", "example", "of", "class", "based", "configuration", "using", "meth", "from_object", "param", "obj", "an", "import", "name", "or", "object", "if", "isinstance", "obj", "str", "obj", "import_string", "obj", "for", "key", "in", "dir", "obj", "if", "key", "isupper", "self", "key", "getattr", "obj", "key"], "doc_len": 224}
{"doc_id": "src/flask/config.py::Config.from_file", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_file", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_file(\n        self,\n        filename: str,\n        load: t.Callable[[t.IO[t.Any]], t.Mapping],\n        silent: bool = False,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import toml\n            app.config.from_file(\"config.toml\", load=toml.load)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename) as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_file", "self", "filename", "str", "load", "t", "callable", "t", "io", "t", "any", "t", "mapping", "silent", "bool", "false", "bool", "update", "the", "values", "in", "the", "config", "from", "a", "file", "that", "is", "loaded", "using", "the", "load", "parameter", "the", "loaded", "data", "is", "passed", "to", "the", "meth", "from_mapping", "method", "code", "block", "python", "import", "json", "app", "config", "from_file", "config", "json", "load", "json", "load", "import", "toml", "app", "config", "from_file", "config", "toml", "load", "toml", "load", "param", "filename", "the", "path", "to", "the", "data", "file", "this", "can", "be", "an", "absolute", "path", "or", "relative", "to", "the", "config", "root", "path", "param", "load", "a", "callable", "that", "takes", "a", "file", "handle", "and", "returns", "a", "mapping", "of", "loaded", "data", "from", "the", "file", "type", "load", "callable", "reader", "mapping", "where", "reader", "implements", "a", "read", "method", "param", "silent", "ignore", "the", "file", "if", "it", "doesn", "t", "exist", "return", "true", "if", "the", "file", "was", "loaded", "successfully", "versionadded", "2", "0", "filename", "os", "path", "join", "self", "root_path", "filename", "try", "with", "open", "filename", "as", "f", "obj", "load", "f", "except", "oserror", "as", "e", "if", "silent", "and", "e", "errno", "in", "errno", "enoent", "errno", "eisdir", "return", "false", "e", "strerror", "f", "unable", "to", "load", "configuration", "file", "e", "strerror", "raise", "return", "self", "from_mapping", "obj"], "doc_len": 191}
{"doc_id": "src/flask/config.py::Config.from_mapping", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "from_mapping", "text": "文件路径: src/flask/config.py, 类名: Config\n    def from_mapping(\n        self, mapping: t.Optional[t.Mapping[str, t.Any]] = None, **kwargs: t.Any\n    ) -> bool:\n        \"\"\"Updates the config like :meth:`update` ignoring items with\n        non-upper keys.\n\n        :return: Always returns ``True``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        mappings: t.Dict[str, t.Any] = {}\n        if mapping is not None:\n            mappings.update(mapping)\n        mappings.update(kwargs)\n        for key, value in mappings.items():\n            if key.isupper():\n                self[key] = value\n        return True\n", "tokens": ["src", "flask", "config", "py", "config", "def", "from_mapping", "self", "mapping", "t", "optional", "t", "mapping", "str", "t", "any", "none", "kwargs", "t", "any", "bool", "updates", "the", "config", "like", "meth", "update", "ignoring", "items", "with", "non", "upper", "keys", "return", "always", "returns", "true", "versionadded", "0", "11", "mappings", "t", "dict", "str", "t", "any", "if", "mapping", "is", "not", "none", "mappings", "update", "mapping", "mappings", "update", "kwargs", "for", "key", "value", "in", "mappings", "items", "if", "key", "isupper", "self", "key", "value", "return", "true"], "doc_len": 71}
{"doc_id": "src/flask/config.py::Config.get_namespace", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "get_namespace", "text": "文件路径: src/flask/config.py, 类名: Config\n    def get_namespace(\n        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n    ) -> t.Dict[str, t.Any]:\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in self.items():\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv\n", "tokens": ["src", "flask", "config", "py", "config", "def", "get_namespace", "self", "namespace", "str", "lowercase", "bool", "true", "trim_namespace", "bool", "true", "t", "dict", "str", "t", "any", "returns", "a", "dictionary", "containing", "a", "subset", "of", "configuration", "options", "that", "match", "the", "specified", "namespace", "prefix", "example", "usage", "app", "config", "image_store_type", "fs", "app", "config", "image_store_path", "var", "app", "images", "app", "config", "image_store_base_url", "http", "img", "website", "com", "image_store_config", "app", "config", "get_namespace", "image_store_", "the", "resulting", "dictionary", "image_store_config", "would", "look", "like", "type", "fs", "path", "var", "app", "images", "base_url", "http", "img", "website", "com", "this", "is", "often", "useful", "when", "configuration", "options", "map", "directly", "to", "keyword", "arguments", "in", "functions", "or", "class", "constructors", "param", "namespace", "a", "configuration", "namespace", "param", "lowercase", "a", "flag", "indicating", "if", "the", "keys", "of", "the", "resulting", "dictionary", "should", "be", "lowercase", "param", "trim_namespace", "a", "flag", "indicating", "if", "the", "keys", "of", "the", "resulting", "dictionary", "should", "not", "include", "the", "namespace", "versionadded", "0", "11", "rv", "for", "k", "v", "in", "self", "items", "if", "not", "k", "startswith", "namespace", "continue", "if", "trim_namespace", "key", "k", "len", "namespace", "else", "key", "k", "if", "lowercase", "key", "key", "lower", "rv", "key", "v", "return", "rv"], "doc_len": 167}
{"doc_id": "src/flask/config.py::Config.__repr__", "file_path": "src/flask/config.py", "class_name": "Config", "func_name": "__repr__", "text": "文件路径: src/flask/config.py, 类名: Config\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {dict.__repr__(self)}>\"\n", "tokens": ["src", "flask", "config", "py", "config", "def", "__repr__", "self", "str", "return", "f", "type", "self", "__name__", "dict", "__repr__", "self"], "doc_len": 17}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__getattr__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__getattr__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __getattr__(self, name: str) -> t.Any:\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__getattr__", "self", "name", "str", "t", "any", "try", "return", "self", "__dict__", "name", "except", "keyerror", "raise", "attributeerror", "name", "from", "none"], "doc_len": 24}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__setattr__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__setattr__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __setattr__(self, name: str, value: t.Any) -> None:\n        self.__dict__[name] = value\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__setattr__", "self", "name", "str", "value", "t", "any", "none", "self", "__dict__", "name", "value"], "doc_len": 18}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__delattr__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__delattr__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __delattr__(self, name: str) -> None:\n        try:\n            del self.__dict__[name]\n        except KeyError:\n            raise AttributeError(name) from None\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__delattr__", "self", "name", "str", "none", "try", "del", "self", "__dict__", "name", "except", "keyerror", "raise", "attributeerror", "name", "from", "none"], "doc_len": 23}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.get", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "get", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def get(self, name: str, default: t.Optional[t.Any] = None) -> t.Any:\n        \"\"\"Get an attribute by name, or a default value. Like\n        :meth:`dict.get`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to return if the attribute is not present.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        return self.__dict__.get(name, default)\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "get", "self", "name", "str", "default", "t", "optional", "t", "any", "none", "t", "any", "get", "an", "attribute", "by", "name", "or", "a", "default", "value", "like", "meth", "dict", "get", "param", "name", "name", "of", "attribute", "to", "get", "param", "default", "value", "to", "return", "if", "the", "attribute", "is", "not", "present", "versionadded", "0", "10", "return", "self", "__dict__", "get", "name", "default"], "doc_len": 58}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.pop", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "pop", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def pop(self, name: str, default: t.Any = _sentinel) -> t.Any:\n        \"\"\"Get and remove an attribute by name. Like :meth:`dict.pop`.\n\n        :param name: Name of attribute to pop.\n        :param default: Value to return if the attribute is not present,\n            instead of raising a ``KeyError``.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        if default is _sentinel:\n            return self.__dict__.pop(name)\n        else:\n            return self.__dict__.pop(name, default)\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "pop", "self", "name", "str", "default", "t", "any", "_sentinel", "t", "any", "get", "and", "remove", "an", "attribute", "by", "name", "like", "meth", "dict", "pop", "param", "name", "name", "of", "attribute", "to", "pop", "param", "default", "value", "to", "return", "if", "the", "attribute", "is", "not", "present", "instead", "of", "raising", "a", "keyerror", "versionadded", "0", "11", "if", "default", "is", "_sentinel", "return", "self", "__dict__", "pop", "name", "else", "return", "self", "__dict__", "pop", "name", "default"], "doc_len": 69}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.setdefault", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "setdefault", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def setdefault(self, name: str, default: t.Any = None) -> t.Any:\n        \"\"\"Get the value of an attribute if it is present, otherwise\n        set and return a default value. Like :meth:`dict.setdefault`.\n\n        :param name: Name of attribute to get.\n        :param default: Value to set and return if the attribute is not\n            present.\n\n        .. versionadded:: 0.11\n        \"\"\"\n        return self.__dict__.setdefault(name, default)\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "setdefault", "self", "name", "str", "default", "t", "any", "none", "t", "any", "get", "the", "value", "of", "an", "attribute", "if", "it", "is", "present", "otherwise", "set", "and", "return", "a", "default", "value", "like", "meth", "dict", "setdefault", "param", "name", "name", "of", "attribute", "to", "get", "param", "default", "value", "to", "set", "and", "return", "if", "the", "attribute", "is", "not", "present", "versionadded", "0", "11", "return", "self", "__dict__", "setdefault", "name", "default"], "doc_len": 66}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__contains__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__contains__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __contains__(self, item: str) -> bool:\n        return item in self.__dict__\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__contains__", "self", "item", "str", "bool", "return", "item", "in", "self", "__dict__"], "doc_len": 16}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__iter__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__iter__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __iter__(self) -> t.Iterator[str]:\n        return iter(self.__dict__)\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__iter__", "self", "t", "iterator", "str", "return", "iter", "self", "__dict__"], "doc_len": 15}
{"doc_id": "src/flask/ctx.py::_AppCtxGlobals.__repr__", "file_path": "src/flask/ctx.py", "class_name": "_AppCtxGlobals", "func_name": "__repr__", "text": "文件路径: src/flask/ctx.py, 类名: _AppCtxGlobals\n    def __repr__(self) -> str:\n        ctx = _cv_app.get(None)\n        if ctx is not None:\n            return f\"<flask.g of '{ctx.app.name}'>\"\n        return object.__repr__(self)\n", "tokens": ["src", "flask", "ctx", "py", "_appctxglobals", "def", "__repr__", "self", "str", "ctx", "_cv_app", "get", "none", "if", "ctx", "is", "not", "none", "return", "f", "flask", "g", "of", "ctx", "app", "name", "return", "object", "__repr__", "self"], "doc_len": 30}
{"doc_id": "src/flask/ctx.py::after_this_request", "file_path": "src/flask/ctx.py", "class_name": null, "func_name": "after_this_request", "text": "文件路径: src/flask/ctx.py\ndef after_this_request(f: ft.AfterRequestCallable) -> ft.AfterRequestCallable:\n    \"\"\"Executes a function after this request.  This is useful to modify\n    response objects.  The function is passed the response object and has\n    to return the same or a new one.\n\n    Example::\n\n        @app.route('/')\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers['X-Foo'] = 'Parachute'\n                return response\n            return 'Hello World!'\n\n    This is more useful if a function other than the view function wants to\n    modify a response.  For instance think of a decorator that wants to add\n    some headers without converting the return value into a response object.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f\n", "tokens": ["src", "flask", "ctx", "py", "def", "after_this_request", "f", "ft", "afterrequestcallable", "ft", "afterrequestcallable", "executes", "a", "function", "after", "this", "request", "this", "is", "useful", "to", "modify", "response", "objects", "the", "function", "is", "passed", "the", "response", "object", "and", "has", "to", "return", "the", "same", "or", "a", "new", "one", "example", "app", "route", "def", "index", "after_this_request", "def", "add_header", "response", "response", "headers", "x", "foo", "parachute", "return", "response", "return", "hello", "world", "this", "is", "more", "useful", "if", "a", "function", "other", "than", "the", "view", "function", "wants", "to", "modify", "a", "response", "for", "instance", "think", "of", "a", "decorator", "that", "wants", "to", "add", "some", "headers", "without", "converting", "the", "return", "value", "into", "a", "response", "object", "versionadded", "0", "9", "ctx", "_cv_request", "get", "none", "if", "ctx", "is", "none", "raise", "runtimeerror", "after_this_request", "can", "only", "be", "used", "when", "a", "request", "context", "is", "active", "such", "as", "in", "a", "view", "function", "ctx", "_after_request_functions", "append", "f", "return", "f"], "doc_len": 134}
{"doc_id": "src/flask/ctx.py::copy_current_request_context", "file_path": "src/flask/ctx.py", "class_name": null, "func_name": "copy_current_request_context", "text": "文件路径: src/flask/ctx.py\ndef copy_current_request_context(f: t.Callable) -> t.Callable:\n    \"\"\"A helper function that decorates a function to retain the current\n    request context.  This is useful when working with greenlets.  The moment\n    the function is decorated a copy of the request context is created and\n    then pushed when the function is called.  The current session is also\n    included in the copied request context.\n\n    Example::\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_request.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args, **kwargs):\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)\n", "tokens": ["src", "flask", "ctx", "py", "def", "copy_current_request_context", "f", "t", "callable", "t", "callable", "a", "helper", "function", "that", "decorates", "a", "function", "to", "retain", "the", "current", "request", "context", "this", "is", "useful", "when", "working", "with", "greenlets", "the", "moment", "the", "function", "is", "decorated", "a", "copy", "of", "the", "request", "context", "is", "created", "and", "then", "pushed", "when", "the", "function", "is", "called", "the", "current", "session", "is", "also", "included", "in", "the", "copied", "request", "context", "example", "import", "gevent", "from", "flask", "import", "copy_current_request_context", "app", "route", "def", "index", "copy_current_request_context", "def", "do_some_work", "do", "some", "work", "here", "it", "can", "access", "flask", "request", "or", "flask", "session", "like", "you", "would", "otherwise", "in", "the", "view", "function", "gevent", "spawn", "do_some_work", "return", "regular", "response", "versionadded", "0", "10", "ctx", "_cv_request", "get", "none", "if", "ctx", "is", "none", "raise", "runtimeerror", "copy_current_request_context", "can", "only", "be", "used", "when", "a", "request", "context", "is", "active", "such", "as", "in", "a", "view", "function", "ctx", "ctx", "copy", "def", "wrapper", "args", "kwargs", "with", "ctx", "return", "ctx", "app", "ensure_sync", "f", "args", "kwargs", "return", "update_wrapper", "wrapper", "f"], "doc_len": 154}
{"doc_id": "src/flask/ctx.py::has_request_context", "file_path": "src/flask/ctx.py", "class_name": null, "func_name": "has_request_context", "text": "文件路径: src/flask/ctx.py\ndef has_request_context() -> bool:\n    \"\"\"If you have code that wants to test if a request context is there or\n    not this function can be used.  For instance, you may want to take advantage\n    of request information if the request object is available, but fail\n    silently if it is unavailable.\n\n    ::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and has_request_context():\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    Alternatively you can also just test any of the context bound objects\n    (such as :class:`request` or :class:`g`) for truthness::\n\n        class User(db.Model):\n\n            def __init__(self, username, remote_addr=None):\n                self.username = username\n                if remote_addr is None and request:\n                    remote_addr = request.remote_addr\n                self.remote_addr = remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return _cv_request.get(None) is not None\n", "tokens": ["src", "flask", "ctx", "py", "def", "has_request_context", "bool", "if", "you", "have", "code", "that", "wants", "to", "test", "if", "a", "request", "context", "is", "there", "or", "not", "this", "function", "can", "be", "used", "for", "instance", "you", "may", "want", "to", "take", "advantage", "of", "request", "information", "if", "the", "request", "object", "is", "available", "but", "fail", "silently", "if", "it", "is", "unavailable", "class", "user", "db", "model", "def", "__init__", "self", "username", "remote_addr", "none", "self", "username", "username", "if", "remote_addr", "is", "none", "and", "has_request_context", "remote_addr", "request", "remote_addr", "self", "remote_addr", "remote_addr", "alternatively", "you", "can", "also", "just", "test", "any", "of", "the", "context", "bound", "objects", "such", "as", "class", "request", "or", "class", "g", "for", "truthness", "class", "user", "db", "model", "def", "__init__", "self", "username", "remote_addr", "none", "self", "username", "username", "if", "remote_addr", "is", "none", "and", "request", "remote_addr", "request", "remote_addr", "self", "remote_addr", "remote_addr", "versionadded", "0", "7", "return", "_cv_request", "get", "none", "is", "not", "none"], "doc_len": 133}
{"doc_id": "src/flask/ctx.py::has_app_context", "file_path": "src/flask/ctx.py", "class_name": null, "func_name": "has_app_context", "text": "文件路径: src/flask/ctx.py\ndef has_app_context() -> bool:\n    \"\"\"Works like :func:`has_request_context` but for the application\n    context.  You can also just do a boolean check on the\n    :data:`current_app` object instead.\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None\n", "tokens": ["src", "flask", "ctx", "py", "def", "has_app_context", "bool", "works", "like", "func", "has_request_context", "but", "for", "the", "application", "context", "you", "can", "also", "just", "do", "a", "boolean", "check", "on", "the", "data", "current_app", "object", "instead", "versionadded", "0", "9", "return", "_cv_app", "get", "none", "is", "not", "none"], "doc_len": 40}
{"doc_id": "src/flask/ctx.py::AppContext.__init__", "file_path": "src/flask/ctx.py", "class_name": "AppContext", "func_name": "__init__", "text": "文件路径: src/flask/ctx.py, 类名: AppContext\n    def __init__(self, app: \"Flask\") -> None:\n        self.app = app\n        self.url_adapter = app.create_url_adapter(None)\n        self.g: _AppCtxGlobals = app.app_ctx_globals_class()\n        self._cv_tokens: t.List[contextvars.Token] = []\n", "tokens": ["src", "flask", "ctx", "py", "appcontext", "def", "__init__", "self", "app", "flask", "none", "self", "app", "app", "self", "url_adapter", "app", "create_url_adapter", "none", "self", "g", "_appctxglobals", "app", "app_ctx_globals_class", "self", "_cv_tokens", "t", "list", "contextvars", "token"], "doc_len": 30}
{"doc_id": "src/flask/ctx.py::AppContext.push", "file_path": "src/flask/ctx.py", "class_name": "AppContext", "func_name": "push", "text": "文件路径: src/flask/ctx.py, 类名: AppContext\n    def push(self) -> None:\n        \"\"\"Binds the app context to the current context.\"\"\"\n        self._cv_tokens.append(_cv_app.set(self))\n        appcontext_pushed.send(self.app)\n", "tokens": ["src", "flask", "ctx", "py", "appcontext", "def", "push", "self", "none", "binds", "the", "app", "context", "to", "the", "current", "context", "self", "_cv_tokens", "append", "_cv_app", "set", "self", "appcontext_pushed", "send", "self", "app"], "doc_len": 27}
{"doc_id": "src/flask/ctx.py::AppContext.pop", "file_path": "src/flask/ctx.py", "class_name": "AppContext", "func_name": "pop", "text": "文件路径: src/flask/ctx.py, 类名: AppContext\n    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the app context.\"\"\"\n        try:\n            if len(self._cv_tokens) == 1:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_appcontext(exc)\n        finally:\n            ctx = _cv_app.get()\n            _cv_app.reset(self._cv_tokens.pop())\n\n        if ctx is not self:\n            raise AssertionError(\n                f\"Popped wrong app context. ({ctx!r} instead of {self!r})\"\n            )\n\n        appcontext_popped.send(self.app)\n", "tokens": ["src", "flask", "ctx", "py", "appcontext", "def", "pop", "self", "exc", "t", "optional", "baseexception", "_sentinel", "none", "type", "ignore", "pops", "the", "app", "context", "try", "if", "len", "self", "_cv_tokens", "1", "if", "exc", "is", "_sentinel", "exc", "sys", "exc_info", "1", "self", "app", "do_teardown_appcontext", "exc", "finally", "ctx", "_cv_app", "get", "_cv_app", "reset", "self", "_cv_tokens", "pop", "if", "ctx", "is", "not", "self", "raise", "assertionerror", "f", "popped", "wrong", "app", "context", "ctx", "r", "instead", "of", "self", "r", "appcontext_popped", "send", "self", "app"], "doc_len": 69}
{"doc_id": "src/flask/ctx.py::AppContext.__enter__", "file_path": "src/flask/ctx.py", "class_name": "AppContext", "func_name": "__enter__", "text": "文件路径: src/flask/ctx.py, 类名: AppContext\n    def __enter__(self) -> \"AppContext\":\n        self.push()\n        return self\n", "tokens": ["src", "flask", "ctx", "py", "appcontext", "def", "__enter__", "self", "appcontext", "self", "push", "return", "self"], "doc_len": 13}
{"doc_id": "src/flask/ctx.py::AppContext.__exit__", "file_path": "src/flask/ctx.py", "class_name": "AppContext", "func_name": "__exit__", "text": "文件路径: src/flask/ctx.py, 类名: AppContext\n    def __exit__(\n        self,\n        exc_type: t.Optional[type],\n        exc_value: t.Optional[BaseException],\n        tb: t.Optional[TracebackType],\n    ) -> None:\n        self.pop(exc_value)\n", "tokens": ["src", "flask", "ctx", "py", "appcontext", "def", "__exit__", "self", "exc_type", "t", "optional", "type", "exc_value", "t", "optional", "baseexception", "tb", "t", "optional", "tracebacktype", "none", "self", "pop", "exc_value"], "doc_len": 24}
{"doc_id": "src/flask/ctx.py::RequestContext.__init__", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "__init__", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def __init__(\n        self,\n        app: \"Flask\",\n        environ: dict,\n        request: t.Optional[\"Request\"] = None,\n        session: t.Optional[\"SessionMixin\"] = None,\n    ) -> None:\n        self.app = app\n        if request is None:\n            request = app.request_class(environ)\n            request.json_module = app.json\n        self.request: Request = request\n        self.url_adapter = None\n        try:\n            self.url_adapter = app.create_url_adapter(self.request)\n        except HTTPException as e:\n            self.request.routing_exception = e\n        self.flashes: t.Optional[t.List[t.Tuple[str, str]]] = None\n        self.session: t.Optional[\"SessionMixin\"] = session\n        # Functions that should be executed after the request on the response\n        # object.  These will be called before the regular \"after_request\"\n        # functions.\n        self._after_request_functions: t.List[ft.AfterRequestCallable] = []\n\n        self._cv_tokens: t.List[t.Tuple[contextvars.Token, t.Optional[AppContext]]] = []\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "__init__", "self", "app", "flask", "environ", "dict", "request", "t", "optional", "request", "none", "session", "t", "optional", "sessionmixin", "none", "none", "self", "app", "app", "if", "request", "is", "none", "request", "app", "request_class", "environ", "request", "json_module", "app", "json", "self", "request", "request", "request", "self", "url_adapter", "none", "try", "self", "url_adapter", "app", "create_url_adapter", "self", "request", "except", "httpexception", "as", "e", "self", "request", "routing_exception", "e", "self", "flashes", "t", "optional", "t", "list", "t", "tuple", "str", "str", "none", "self", "session", "t", "optional", "sessionmixin", "session", "functions", "that", "should", "be", "executed", "after", "the", "request", "on", "the", "response", "object", "these", "will", "be", "called", "before", "the", "regular", "after_request", "functions", "self", "_after_request_functions", "t", "list", "ft", "afterrequestcallable", "self", "_cv_tokens", "t", "list", "t", "tuple", "contextvars", "token", "t", "optional", "appcontext"], "doc_len": 115}
{"doc_id": "src/flask/ctx.py::RequestContext.copy", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "copy", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def copy(self) -> \"RequestContext\":\n        \"\"\"Creates a copy of this request context with the same request object.\n        This can be used to move a request context to a different greenlet.\n        Because the actual request object is the same this cannot be used to\n        move a request context to a different thread unless access to the\n        request object is locked.\n\n        .. versionadded:: 0.10\n\n        .. versionchanged:: 1.1\n           The current session object is used instead of reloading the original\n           data. This prevents `flask.session` pointing to an out-of-date object.\n        \"\"\"\n        return self.__class__(\n            self.app,\n            environ=self.request.environ,\n            request=self.request,\n            session=self.session,\n        )\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "copy", "self", "requestcontext", "creates", "a", "copy", "of", "this", "request", "context", "with", "the", "same", "request", "object", "this", "can", "be", "used", "to", "move", "a", "request", "context", "to", "a", "different", "greenlet", "because", "the", "actual", "request", "object", "is", "the", "same", "this", "cannot", "be", "used", "to", "move", "a", "request", "context", "to", "a", "different", "thread", "unless", "access", "to", "the", "request", "object", "is", "locked", "versionadded", "0", "10", "versionchanged", "1", "1", "the", "current", "session", "object", "is", "used", "instead", "of", "reloading", "the", "original", "data", "this", "prevents", "flask", "session", "pointing", "to", "an", "out", "of", "date", "object", "return", "self", "__class__", "self", "app", "environ", "self", "request", "environ", "request", "self", "request", "session", "self", "session"], "doc_len": 107}
{"doc_id": "src/flask/ctx.py::RequestContext.match_request", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "match_request", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def match_request(self) -> None:\n        \"\"\"Can be overridden by a subclass to hook into the matching\n        of the request.\n        \"\"\"\n        try:\n            result = self.url_adapter.match(return_rule=True)  # type: ignore\n            self.request.url_rule, self.request.view_args = result  # type: ignore\n        except HTTPException as e:\n            self.request.routing_exception = e\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "match_request", "self", "none", "can", "be", "overridden", "by", "a", "subclass", "to", "hook", "into", "the", "matching", "of", "the", "request", "try", "result", "self", "url_adapter", "match", "return_rule", "true", "type", "ignore", "self", "request", "url_rule", "self", "request", "view_args", "result", "type", "ignore", "except", "httpexception", "as", "e", "self", "request", "routing_exception", "e"], "doc_len": 49}
{"doc_id": "src/flask/ctx.py::RequestContext.push", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "push", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def push(self) -> None:\n        # Before we push the request context we have to ensure that there\n        # is an application context.\n        app_ctx = _cv_app.get(None)\n\n        if app_ctx is None or app_ctx.app is not self.app:\n            app_ctx = self.app.app_context()\n            app_ctx.push()\n        else:\n            app_ctx = None\n\n        self._cv_tokens.append((_cv_request.set(self), app_ctx))\n\n        # Open the session at the moment that the request context is available.\n        # This allows a custom open_session method to use the request context.\n        # Only open a new session if this is the first time the request was\n        # pushed, otherwise stream_with_context loses the session.\n        if self.session is None:\n            session_interface = self.app.session_interface\n            self.session = session_interface.open_session(self.app, self.request)\n\n            if self.session is None:\n                self.session = session_interface.make_null_session(self.app)\n\n        # Match the request URL after loading the session, so that the\n        # session is available in custom URL converters.\n        if self.url_adapter is not None:\n            self.match_request()\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "push", "self", "none", "before", "we", "push", "the", "request", "context", "we", "have", "to", "ensure", "that", "there", "is", "an", "application", "context", "app_ctx", "_cv_app", "get", "none", "if", "app_ctx", "is", "none", "or", "app_ctx", "app", "is", "not", "self", "app", "app_ctx", "self", "app", "app_context", "app_ctx", "push", "else", "app_ctx", "none", "self", "_cv_tokens", "append", "_cv_request", "set", "self", "app_ctx", "open", "the", "session", "at", "the", "moment", "that", "the", "request", "context", "is", "available", "this", "allows", "a", "custom", "open_session", "method", "to", "use", "the", "request", "context", "only", "open", "a", "new", "session", "if", "this", "is", "the", "first", "time", "the", "request", "was", "pushed", "otherwise", "stream_with_context", "loses", "the", "session", "if", "self", "session", "is", "none", "session_interface", "self", "app", "session_interface", "self", "session", "session_interface", "open_session", "self", "app", "self", "request", "if", "self", "session", "is", "none", "self", "session", "session_interface", "make_null_session", "self", "app", "match", "the", "request", "url", "after", "loading", "the", "session", "so", "that", "the", "session", "is", "available", "in", "custom", "url", "converters", "if", "self", "url_adapter", "is", "not", "none", "self", "match_request"], "doc_len": 153}
{"doc_id": "src/flask/ctx.py::RequestContext.pop", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "pop", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore\n        \"\"\"Pops the request context and unbinds it by doing that.  This will\n        also trigger the execution of functions registered by the\n        :meth:`~flask.Flask.teardown_request` decorator.\n\n        .. versionchanged:: 0.9\n           Added the `exc` argument.\n        \"\"\"\n        clear_request = len(self._cv_tokens) == 1\n\n        try:\n            if clear_request:\n                if exc is _sentinel:\n                    exc = sys.exc_info()[1]\n                self.app.do_teardown_request(exc)\n\n                request_close = getattr(self.request, \"close\", None)\n                if request_close is not None:\n                    request_close()\n        finally:\n            ctx = _cv_request.get()\n            token, app_ctx = self._cv_tokens.pop()\n            _cv_request.reset(token)\n\n            # get rid of circular dependencies at the end of the request\n            # so that we don't require the GC to be active.\n            if clear_request:\n                ctx.request.environ[\"werkzeug.request\"] = None\n\n            if app_ctx is not None:\n                app_ctx.pop(exc)\n\n            if ctx is not self:\n                raise AssertionError(\n                    f\"Popped wrong request context. ({ctx!r} instead of {self!r})\"\n                )\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "pop", "self", "exc", "t", "optional", "baseexception", "_sentinel", "none", "type", "ignore", "pops", "the", "request", "context", "and", "unbinds", "it", "by", "doing", "that", "this", "will", "also", "trigger", "the", "execution", "of", "functions", "registered", "by", "the", "meth", "flask", "flask", "teardown_request", "decorator", "versionchanged", "0", "9", "added", "the", "exc", "argument", "clear_request", "len", "self", "_cv_tokens", "1", "try", "if", "clear_request", "if", "exc", "is", "_sentinel", "exc", "sys", "exc_info", "1", "self", "app", "do_teardown_request", "exc", "request_close", "getattr", "self", "request", "close", "none", "if", "request_close", "is", "not", "none", "request_close", "finally", "ctx", "_cv_request", "get", "token", "app_ctx", "self", "_cv_tokens", "pop", "_cv_request", "reset", "token", "get", "rid", "of", "circular", "dependencies", "at", "the", "end", "of", "the", "request", "so", "that", "we", "don", "t", "require", "the", "gc", "to", "be", "active", "if", "clear_request", "ctx", "request", "environ", "werkzeug", "request", "none", "if", "app_ctx", "is", "not", "none", "app_ctx", "pop", "exc", "if", "ctx", "is", "not", "self", "raise", "assertionerror", "f", "popped", "wrong", "request", "context", "ctx", "r", "instead", "of", "self", "r"], "doc_len": 149}
{"doc_id": "src/flask/ctx.py::RequestContext.__enter__", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "__enter__", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def __enter__(self) -> \"RequestContext\":\n        self.push()\n        return self\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "__enter__", "self", "requestcontext", "self", "push", "return", "self"], "doc_len": 13}
{"doc_id": "src/flask/ctx.py::RequestContext.__exit__", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "__exit__", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def __exit__(\n        self,\n        exc_type: t.Optional[type],\n        exc_value: t.Optional[BaseException],\n        tb: t.Optional[TracebackType],\n    ) -> None:\n        self.pop(exc_value)\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "__exit__", "self", "exc_type", "t", "optional", "type", "exc_value", "t", "optional", "baseexception", "tb", "t", "optional", "tracebacktype", "none", "self", "pop", "exc_value"], "doc_len": 24}
{"doc_id": "src/flask/ctx.py::RequestContext.__repr__", "file_path": "src/flask/ctx.py", "class_name": "RequestContext", "func_name": "__repr__", "text": "文件路径: src/flask/ctx.py, 类名: RequestContext\n    def __repr__(self) -> str:\n        return (\n            f\"<{type(self).__name__} {self.request.url!r}\"\n            f\" [{self.request.method}] of {self.app.name}>\"\n        )\n", "tokens": ["src", "flask", "ctx", "py", "requestcontext", "def", "__repr__", "self", "str", "return", "f", "type", "self", "__name__", "self", "request", "url", "r", "f", "self", "request", "method", "of", "self", "app", "name"], "doc_len": 26}
{"doc_id": "src/flask/debughelpers.py::DebugFilesKeyError.__init__", "file_path": "src/flask/debughelpers.py", "class_name": "DebugFilesKeyError", "func_name": "__init__", "text": "文件路径: src/flask/debughelpers.py, 类名: DebugFilesKeyError\n    def __init__(self, request, key):\n        form_matches = request.form.getlist(key)\n        buf = [\n            f\"You tried to access the file {key!r} in the request.files\"\n            \" dictionary but it does not exist. The mimetype for the\"\n            f\" request is {request.mimetype!r} instead of\"\n            \" 'multipart/form-data' which means that no file contents\"\n            \" were transmitted. To fix this error you should provide\"\n            ' enctype=\"multipart/form-data\" in your form.'\n        ]\n        if form_matches:\n            names = \", \".join(repr(x) for x in form_matches)\n            buf.append(\n                \"\\n\\nThe browser instead transmitted some file names. \"\n                f\"This was submitted: {names}\"\n            )\n        self.msg = \"\".join(buf)\n", "tokens": ["src", "flask", "debughelpers", "py", "debugfileskeyerror", "def", "__init__", "self", "request", "key", "form_matches", "request", "form", "getlist", "key", "buf", "f", "you", "tried", "to", "access", "the", "file", "key", "r", "in", "the", "request", "files", "dictionary", "but", "it", "does", "not", "exist", "the", "mimetype", "for", "the", "f", "request", "is", "request", "mimetype", "r", "instead", "of", "multipart", "form", "data", "which", "means", "that", "no", "file", "contents", "were", "transmitted", "to", "fix", "this", "error", "you", "should", "provide", "enctype", "multipart", "form", "data", "in", "your", "form", "if", "form_matches", "names", "join", "repr", "x", "for", "x", "in", "form_matches", "buf", "append", "n", "nthe", "browser", "instead", "transmitted", "some", "file", "names", "f", "this", "was", "submitted", "names", "self", "msg", "join", "buf"], "doc_len": 101}
{"doc_id": "src/flask/debughelpers.py::DebugFilesKeyError.__str__", "file_path": "src/flask/debughelpers.py", "class_name": "DebugFilesKeyError", "func_name": "__str__", "text": "文件路径: src/flask/debughelpers.py, 类名: DebugFilesKeyError\n    def __str__(self):\n        return self.msg\n", "tokens": ["src", "flask", "debughelpers", "py", "debugfileskeyerror", "def", "__str__", "self", "return", "self", "msg"], "doc_len": 11}
{"doc_id": "src/flask/debughelpers.py::FormDataRoutingRedirect.__init__", "file_path": "src/flask/debughelpers.py", "class_name": "FormDataRoutingRedirect", "func_name": "__init__", "text": "文件路径: src/flask/debughelpers.py, 类名: FormDataRoutingRedirect\n    def __init__(self, request):\n        exc = request.routing_exception\n        buf = [\n            f\"A request was sent to '{request.url}', but routing issued\"\n            f\" a redirect to the canonical URL '{exc.new_url}'.\"\n        ]\n\n        if f\"{request.base_url}/\" == exc.new_url.partition(\"?\")[0]:\n            buf.append(\n                \" The URL was defined with a trailing slash. Flask\"\n                \" will redirect to the URL with a trailing slash if it\"\n                \" was accessed without one.\"\n            )\n\n        buf.append(\n            \" Send requests to the canonical URL, or use 307 or 308 for\"\n            \" routing redirects. Otherwise, browsers will drop form\"\n            \" data.\\n\\n\"\n            \"This exception is only raised in debug mode.\"\n        )\n        super().__init__(\"\".join(buf))\n", "tokens": ["src", "flask", "debughelpers", "py", "formdataroutingredirect", "def", "__init__", "self", "request", "exc", "request", "routing_exception", "buf", "f", "a", "request", "was", "sent", "to", "request", "url", "but", "routing", "issued", "f", "a", "redirect", "to", "the", "canonical", "url", "exc", "new_url", "if", "f", "request", "base_url", "exc", "new_url", "partition", "0", "buf", "append", "the", "url", "was", "defined", "with", "a", "trailing", "slash", "flask", "will", "redirect", "to", "the", "url", "with", "a", "trailing", "slash", "if", "it", "was", "accessed", "without", "one", "buf", "append", "send", "requests", "to", "the", "canonical", "url", "or", "use", "307", "or", "308", "for", "routing", "redirects", "otherwise", "browsers", "will", "drop", "form", "data", "n", "n", "this", "exception", "is", "only", "raised", "in", "debug", "mode", "super", "__init__", "join", "buf"], "doc_len": 103}
{"doc_id": "src/flask/debughelpers.py::attach_enctype_error_multidict", "file_path": "src/flask/debughelpers.py", "class_name": null, "func_name": "attach_enctype_error_multidict", "text": "文件路径: src/flask/debughelpers.py\ndef attach_enctype_error_multidict(request):\n    \"\"\"Patch ``request.files.__getitem__`` to raise a descriptive error\n    about ``enctype=multipart/form-data``.\n\n    :param request: The request to patch.\n    :meta private:\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):\n        def __getitem__(self, key):\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls\n", "tokens": ["src", "flask", "debughelpers", "py", "def", "attach_enctype_error_multidict", "request", "patch", "request", "files", "__getitem__", "to", "raise", "a", "descriptive", "error", "about", "enctype", "multipart", "form", "data", "param", "request", "the", "request", "to", "patch", "meta", "private", "oldcls", "request", "files", "__class__", "class", "newcls", "oldcls", "def", "__getitem__", "self", "key", "try", "return", "super", "__getitem__", "key", "except", "keyerror", "as", "e", "if", "key", "not", "in", "request", "form", "raise", "raise", "debugfileskeyerror", "request", "key", "with_traceback", "e", "__traceback__", "from", "none", "newcls", "__name__", "oldcls", "__name__", "newcls", "__module__", "oldcls", "__module__", "request", "files", "__class__", "newcls"], "doc_len": 77}
{"doc_id": "src/flask/debughelpers.py::_dump_loader_info", "file_path": "src/flask/debughelpers.py", "class_name": null, "func_name": "_dump_loader_info", "text": "文件路径: src/flask/debughelpers.py\ndef _dump_loader_info(loader) -> t.Generator:\n    yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, str) for x in value):\n                continue\n            yield f\"{key}:\"\n            for item in value:\n                yield f\"  - {item}\"\n            continue\n        elif not isinstance(value, (str, int, float, bool)):\n            continue\n        yield f\"{key}: {value!r}\"\n", "tokens": ["src", "flask", "debughelpers", "py", "def", "_dump_loader_info", "loader", "t", "generator", "yield", "f", "class", "type", "loader", "__module__", "type", "loader", "__name__", "for", "key", "value", "in", "sorted", "loader", "__dict__", "items", "if", "key", "startswith", "_", "continue", "if", "isinstance", "value", "tuple", "list", "if", "not", "all", "isinstance", "x", "str", "for", "x", "in", "value", "continue", "yield", "f", "key", "for", "item", "in", "value", "yield", "f", "item", "continue", "elif", "not", "isinstance", "value", "str", "int", "float", "bool", "continue", "yield", "f", "key", "value", "r"], "doc_len": 72}
{"doc_id": "src/flask/debughelpers.py::explain_template_loading_attempts", "file_path": "src/flask/debughelpers.py", "class_name": null, "func_name": "explain_template_loading_attempts", "text": "文件路径: src/flask/debughelpers.py\ndef explain_template_loading_attempts(app: Flask, template, attempts) -> None:\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n    if request_ctx and request_ctx.request.blueprint is not None:\n        blueprint = request_ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, Flask):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))\n", "tokens": ["src", "flask", "debughelpers", "py", "def", "explain_template_loading_attempts", "app", "flask", "template", "attempts", "none", "this", "should", "help", "developers", "understand", "what", "failed", "info", "f", "locating", "template", "template", "r", "total_found", "0", "blueprint", "none", "if", "request_ctx", "and", "request_ctx", "request", "blueprint", "is", "not", "none", "blueprint", "request_ctx", "request", "blueprint", "for", "idx", "loader", "srcobj", "triple", "in", "enumerate", "attempts", "if", "isinstance", "srcobj", "flask", "src_info", "f", "application", "srcobj", "import_name", "r", "elif", "isinstance", "srcobj", "blueprint", "src_info", "f", "blueprint", "srcobj", "name", "r", "srcobj", "import_name", "else", "src_info", "repr", "srcobj", "info", "append", "f", "idx", "1", "5", "trying", "loader", "of", "src_info", "for", "line", "in", "_dump_loader_info", "loader", "info", "append", "f", "line", "if", "triple", "is", "none", "detail", "no", "match", "else", "detail", "f", "found", "triple", "1", "or", "string", "r", "total_found", "1", "info", "append", "f", "detail", "seems_fishy", "false", "if", "total_found", "0", "info", "append", "error", "the", "template", "could", "not", "be", "found", "seems_fishy", "true", "elif", "total_found", "1", "info", "append", "warning", "multiple", "loaders", "returned", "a", "match", "for", "the", "template", "seems_fishy", "true", "if", "blueprint", "is", "not", "none", "and", "seems_fishy", "info", "append", "the", "template", "was", "looked", "up", "from", "an", "endpoint", "that", "belongs", "f", "to", "the", "blueprint", "blueprint", "r", "info", "append", "maybe", "you", "did", "not", "place", "a", "template", "in", "the", "right", "folder", "info", "append", "see", "https", "flask", "palletsprojects", "com", "blueprints", "templates", "app", "logger", "info", "n", "join", "info"], "doc_len": 201}
{"doc_id": "src/flask/globals.py::_FakeStack.__init__", "file_path": "src/flask/globals.py", "class_name": "_FakeStack", "func_name": "__init__", "text": "文件路径: src/flask/globals.py, 类名: _FakeStack\n    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:\n        self.name = name\n        self.cv = cv\n", "tokens": ["src", "flask", "globals", "py", "_fakestack", "def", "__init__", "self", "name", "str", "cv", "contextvar", "t", "any", "none", "self", "name", "name", "self", "cv", "cv"], "doc_len": 21}
{"doc_id": "src/flask/globals.py::_FakeStack.top", "file_path": "src/flask/globals.py", "class_name": "_FakeStack", "func_name": "top", "text": "文件路径: src/flask/globals.py, 类名: _FakeStack\n    def top(self) -> t.Optional[t.Any]:\n        import warnings\n\n        warnings.warn(\n            f\"'_{self.name}_ctx_stack' is deprecated and will be removed in Flask 2.4.\"\n            f\" Use 'g' to store data, or '{self.name}_ctx' to access the current\"\n            \" context.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.cv.get(None)\n", "tokens": ["src", "flask", "globals", "py", "_fakestack", "def", "top", "self", "t", "optional", "t", "any", "import", "warnings", "warnings", "warn", "f", "_", "self", "name", "_ctx_stack", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "f", "use", "g", "to", "store", "data", "or", "self", "name", "_ctx", "to", "access", "the", "current", "context", "deprecationwarning", "stacklevel", "2", "return", "self", "cv", "get", "none"], "doc_len": 54}
{"doc_id": "src/flask/globals.py::__getattr__", "file_path": "src/flask/globals.py", "class_name": null, "func_name": "__getattr__", "text": "文件路径: src/flask/globals.py\ndef __getattr__(name: str) -> t.Any:\n    if name == \"_app_ctx_stack\":\n        import warnings\n\n        warnings.warn(\n            \"'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return __app_ctx_stack\n\n    if name == \"_request_ctx_stack\":\n        import warnings\n\n        warnings.warn(\n            \"'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return __request_ctx_stack\n\n    raise AttributeError(name)\n", "tokens": ["src", "flask", "globals", "py", "def", "__getattr__", "name", "str", "t", "any", "if", "name", "_app_ctx_stack", "import", "warnings", "warnings", "warn", "_app_ctx_stack", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "deprecationwarning", "stacklevel", "2", "return", "__app_ctx_stack", "if", "name", "_request_ctx_stack", "import", "warnings", "warnings", "warn", "_request_ctx_stack", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "deprecationwarning", "stacklevel", "2", "return", "__request_ctx_stack", "raise", "attributeerror", "name"], "doc_len": 59}
{"doc_id": "src/flask/helpers.py::get_debug_flag", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "get_debug_flag", "text": "文件路径: src/flask/helpers.py\ndef get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})\n", "tokens": ["src", "flask", "helpers", "py", "def", "get_debug_flag", "bool", "get", "whether", "debug", "mode", "should", "be", "enabled", "for", "the", "app", "indicated", "by", "the", "envvar", "flask_debug", "environment", "variable", "the", "default", "is", "false", "val", "os", "environ", "get", "flask_debug", "return", "bool", "val", "and", "val", "lower", "not", "in", "0", "false", "no"], "doc_len": 44}
{"doc_id": "src/flask/helpers.py::get_load_dotenv", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "get_load_dotenv", "text": "文件路径: src/flask/helpers.py\ndef get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")\n", "tokens": ["src", "flask", "helpers", "py", "def", "get_load_dotenv", "default", "bool", "true", "bool", "get", "whether", "the", "user", "has", "disabled", "loading", "default", "dotenv", "files", "by", "setting", "envvar", "flask_skip_dotenv", "the", "default", "is", "true", "load", "the", "files", "param", "default", "what", "to", "return", "if", "the", "env", "var", "isn", "t", "set", "val", "os", "environ", "get", "flask_skip_dotenv", "if", "not", "val", "return", "default", "return", "val", "lower", "in", "0", "false", "no"], "doc_len": 60}
{"doc_id": "src/flask/helpers.py::stream_with_context", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "stream_with_context", "text": "文件路径: src/flask/helpers.py\ndef stream_with_context(\n    generator_or_function: t.Union[\n        t.Iterator[t.AnyStr], t.Callable[..., t.Iterator[t.AnyStr]]\n    ]\n) -> t.Iterator[t.AnyStr]:\n    \"\"\"Request contexts disappear when the response is started on the server.\n    This is done for efficiency reasons and to make it less likely to encounter\n    memory leaks with badly written WSGI middlewares.  The downside is that if\n    you are using streamed responses, the generator cannot access request bound\n    information any more.\n\n    This function however can help you keep the context around for longer::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(generate())\n\n    Alternatively it can also be used around a specific generator::\n\n        from flask import stream_with_context, request, Response\n\n        @app.route('/stream')\n        def streamed_response():\n            def generate():\n                yield 'Hello '\n                yield request.args['name']\n                yield '!'\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore\n\n    def generator() -> t.Generator:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we're\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we're still running the cleanup logic.  Generators\n            # don't need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g\n", "tokens": ["src", "flask", "helpers", "py", "def", "stream_with_context", "generator_or_function", "t", "union", "t", "iterator", "t", "anystr", "t", "callable", "t", "iterator", "t", "anystr", "t", "iterator", "t", "anystr", "request", "contexts", "disappear", "when", "the", "response", "is", "started", "on", "the", "server", "this", "is", "done", "for", "efficiency", "reasons", "and", "to", "make", "it", "less", "likely", "to", "encounter", "memory", "leaks", "with", "badly", "written", "wsgi", "middlewares", "the", "downside", "is", "that", "if", "you", "are", "using", "streamed", "responses", "the", "generator", "cannot", "access", "request", "bound", "information", "any", "more", "this", "function", "however", "can", "help", "you", "keep", "the", "context", "around", "for", "longer", "from", "flask", "import", "stream_with_context", "request", "response", "app", "route", "stream", "def", "streamed_response", "stream_with_context", "def", "generate", "yield", "hello", "yield", "request", "args", "name", "yield", "return", "response", "generate", "alternatively", "it", "can", "also", "be", "used", "around", "a", "specific", "generator", "from", "flask", "import", "stream_with_context", "request", "response", "app", "route", "stream", "def", "streamed_response", "def", "generate", "yield", "hello", "yield", "request", "args", "name", "yield", "return", "response", "stream_with_context", "generate", "versionadded", "0", "9", "try", "gen", "iter", "generator_or_function", "type", "ignore", "except", "typeerror", "def", "decorator", "args", "t", "any", "kwargs", "t", "any", "t", "any", "gen", "generator_or_function", "args", "kwargs", "type", "ignore", "return", "stream_with_context", "gen", "return", "update_wrapper", "decorator", "generator_or_function", "type", "ignore", "def", "generator", "t", "generator", "ctx", "_cv_request", "get", "none", "if", "ctx", "is", "none", "raise", "runtimeerror", "stream_with_context", "can", "only", "be", "used", "when", "a", "request", "context", "is", "active", "such", "as", "in", "a", "view", "function", "with", "ctx", "dummy", "sentinel", "has", "to", "be", "inside", "the", "context", "block", "or", "we", "re", "not", "actually", "keeping", "the", "context", "around", "yield", "none", "the", "try", "finally", "is", "here", "so", "that", "if", "someone", "passes", "a", "wsgi", "level", "iterator", "in", "we", "re", "still", "running", "the", "cleanup", "logic", "generators", "don", "t", "need", "that", "because", "they", "are", "closed", "on", "their", "destruction", "automatically", "try", "yield", "from", "gen", "finally", "if", "hasattr", "gen", "close", "gen", "close", "the", "trick", "is", "to", "start", "the", "generator", "then", "the", "code", "execution", "runs", "until", "the", "first", "dummy", "none", "is", "yielded", "at", "which", "point", "the", "context", "was", "already", "pushed", "this", "item", "is", "discarded", "then", "when", "the", "iteration", "continues", "the", "real", "generator", "is", "executed", "wrapped_g", "generator", "next", "wrapped_g", "return", "wrapped_g"], "doc_len": 326}
{"doc_id": "src/flask/helpers.py::make_response", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "make_response", "text": "文件路径: src/flask/helpers.py\ndef make_response(*args: t.Any) -> \"Response\":\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the following things:\n\n    -   if no arguments are passed, it creates a new response argument\n    -   if one argument is passed, :meth:`flask.Flask.make_response`\n        is invoked with it.\n    -   if more than one argument is passed, the arguments are passed\n        to the :meth:`flask.Flask.make_response` function as tuple.\n\n    .. versionadded:: 0.6\n    \"\"\"\n    if not args:\n        return current_app.response_class()\n    if len(args) == 1:\n        args = args[0]\n    return current_app.make_response(args)  # type: ignore\n", "tokens": ["src", "flask", "helpers", "py", "def", "make_response", "args", "t", "any", "response", "sometimes", "it", "is", "necessary", "to", "set", "additional", "headers", "in", "a", "view", "because", "views", "do", "not", "have", "to", "return", "response", "objects", "but", "can", "return", "a", "value", "that", "is", "converted", "into", "a", "response", "object", "by", "flask", "itself", "it", "becomes", "tricky", "to", "add", "headers", "to", "it", "this", "function", "can", "be", "called", "instead", "of", "using", "a", "return", "and", "you", "will", "get", "a", "response", "object", "which", "you", "can", "use", "to", "attach", "headers", "if", "view", "looked", "like", "this", "and", "you", "want", "to", "add", "a", "new", "header", "def", "index", "return", "render_template", "index", "html", "foo", "42", "you", "can", "now", "do", "something", "like", "this", "def", "index", "response", "make_response", "render_template", "index", "html", "foo", "42", "response", "headers", "x", "parachutes", "parachutes", "are", "cool", "return", "response", "this", "function", "accepts", "the", "very", "same", "arguments", "you", "can", "return", "from", "a", "view", "function", "this", "for", "example", "creates", "a", "response", "with", "a", "404", "error", "code", "response", "make_response", "render_template", "not_found", "html", "404", "the", "other", "use", "case", "of", "this", "function", "is", "to", "force", "the", "return", "value", "of", "a", "view", "function", "into", "a", "response", "which", "is", "helpful", "with", "view", "decorators", "response", "make_response", "view_function", "response", "headers", "x", "parachutes", "parachutes", "are", "cool", "internally", "this", "function", "does", "the", "following", "things", "if", "no", "arguments", "are", "passed", "it", "creates", "a", "new", "response", "argument", "if", "one", "argument", "is", "passed", "meth", "flask", "flask", "make_response", "is", "invoked", "with", "it", "if", "more", "than", "one", "argument", "is", "passed", "the", "arguments", "are", "passed", "to", "the", "meth", "flask", "flask", "make_response", "function", "as", "tuple", "versionadded", "0", "6", "if", "not", "args", "return", "current_app", "response_class", "if", "len", "args", "1", "args", "args", "0", "return", "current_app", "make_response", "args", "type", "ignore"], "doc_len": 263}
{"doc_id": "src/flask/helpers.py::url_for", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "url_for", "text": "文件路径: src/flask/helpers.py\ndef url_for(\n    endpoint: str,\n    *,\n    _anchor: t.Optional[str] = None,\n    _method: t.Optional[str] = None,\n    _scheme: t.Optional[str] = None,\n    _external: t.Optional[bool] = None,\n    **values: t.Any,\n) -> str:\n    \"\"\"Generate a URL to the given endpoint with the given values.\n\n    This requires an active request or application context, and calls\n    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\n    for full documentation.\n\n    :param endpoint: The endpoint name associated with the URL to\n        generate. If this starts with a ``.``, the current blueprint\n        name (if any) will be used.\n    :param _anchor: If given, append this as ``#anchor`` to the URL.\n    :param _method: If given, generate the URL associated with this\n        method for the endpoint.\n    :param _scheme: If given, the URL will have this scheme if it is\n        external.\n    :param _external: If given, prefer the URL to be internal (False) or\n        require it to be external (True). External URLs include the\n        scheme and domain. When not in an active request, URLs are\n        external by default.\n    :param values: Values to use for the variable parts of the URL rule.\n        Unknown keys are appended as query string arguments, like\n        ``?a=b&c=d``.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.url_for``, allowing an app to override the\n        behavior.\n\n    .. versionchanged:: 0.10\n       The ``_scheme`` parameter was added.\n\n    .. versionchanged:: 0.9\n       The ``_anchor`` and ``_method`` parameters were added.\n\n    .. versionchanged:: 0.9\n       Calls ``app.handle_url_build_error`` on build errors.\n    \"\"\"\n    return current_app.url_for(\n        endpoint,\n        _anchor=_anchor,\n        _method=_method,\n        _scheme=_scheme,\n        _external=_external,\n        **values,\n    )\n", "tokens": ["src", "flask", "helpers", "py", "def", "url_for", "endpoint", "str", "_anchor", "t", "optional", "str", "none", "_method", "t", "optional", "str", "none", "_scheme", "t", "optional", "str", "none", "_external", "t", "optional", "bool", "none", "values", "t", "any", "str", "generate", "a", "url", "to", "the", "given", "endpoint", "with", "the", "given", "values", "this", "requires", "an", "active", "request", "or", "application", "context", "and", "calls", "meth", "current_app", "url_for", "flask", "flask", "url_for", "see", "that", "method", "for", "full", "documentation", "param", "endpoint", "the", "endpoint", "name", "associated", "with", "the", "url", "to", "generate", "if", "this", "starts", "with", "a", "the", "current", "blueprint", "name", "if", "any", "will", "be", "used", "param", "_anchor", "if", "given", "append", "this", "as", "anchor", "to", "the", "url", "param", "_method", "if", "given", "generate", "the", "url", "associated", "with", "this", "method", "for", "the", "endpoint", "param", "_scheme", "if", "given", "the", "url", "will", "have", "this", "scheme", "if", "it", "is", "external", "param", "_external", "if", "given", "prefer", "the", "url", "to", "be", "internal", "false", "or", "require", "it", "to", "be", "external", "true", "external", "urls", "include", "the", "scheme", "and", "domain", "when", "not", "in", "an", "active", "request", "urls", "are", "external", "by", "default", "param", "values", "values", "to", "use", "for", "the", "variable", "parts", "of", "the", "url", "rule", "unknown", "keys", "are", "appended", "as", "query", "string", "arguments", "like", "a", "b", "c", "d", "versionchanged", "2", "2", "calls", "current_app", "url_for", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "0", "10", "the", "_scheme", "parameter", "was", "added", "versionchanged", "0", "9", "the", "_anchor", "and", "_method", "parameters", "were", "added", "versionchanged", "0", "9", "calls", "app", "handle_url_build_error", "on", "build", "errors", "return", "current_app", "url_for", "endpoint", "_anchor", "_anchor", "_method", "_method", "_scheme", "_scheme", "_external", "_external", "values"], "doc_len": 244}
{"doc_id": "src/flask/helpers.py::redirect", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "redirect", "text": "文件路径: src/flask/helpers.py\ndef redirect(\n    location: str, code: int = 302, Response: t.Optional[t.Type[\"BaseResponse\"]] = None\n) -> \"BaseResponse\":\n    \"\"\"Create a redirect response object.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`~flask.Flask.redirect` method, otherwise it will use\n    :func:`werkzeug.utils.redirect`.\n\n    :param location: The URL to redirect to.\n    :param code: The status code for the redirect.\n    :param Response: The response class to use. Not used when\n        ``current_app`` is active, which uses ``app.response_class``.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.redirect`` if available instead of always\n        using Werkzeug's default ``redirect``.\n    \"\"\"\n    if current_app:\n        return current_app.redirect(location, code=code)\n\n    return _wz_redirect(location, code=code, Response=Response)\n", "tokens": ["src", "flask", "helpers", "py", "def", "redirect", "location", "str", "code", "int", "302", "response", "t", "optional", "t", "type", "baseresponse", "none", "baseresponse", "create", "a", "redirect", "response", "object", "if", "data", "flask", "current_app", "is", "available", "it", "will", "use", "its", "meth", "flask", "flask", "redirect", "method", "otherwise", "it", "will", "use", "func", "werkzeug", "utils", "redirect", "param", "location", "the", "url", "to", "redirect", "to", "param", "code", "the", "status", "code", "for", "the", "redirect", "param", "response", "the", "response", "class", "to", "use", "not", "used", "when", "current_app", "is", "active", "which", "uses", "app", "response_class", "versionadded", "2", "2", "calls", "current_app", "redirect", "if", "available", "instead", "of", "always", "using", "werkzeug", "s", "default", "redirect", "if", "current_app", "return", "current_app", "redirect", "location", "code", "code", "return", "_wz_redirect", "location", "code", "code", "response", "response"], "doc_len": 110}
{"doc_id": "src/flask/helpers.py::abort", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "abort", "text": "文件路径: src/flask/helpers.py\ndef abort(\n    code: t.Union[int, \"BaseResponse\"], *args: t.Any, **kwargs: t.Any\n) -> \"te.NoReturn\":\n    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n    status code.\n\n    If :data:`~flask.current_app` is available, it will call its\n    :attr:`~flask.Flask.aborter` object, otherwise it will use\n    :func:`werkzeug.exceptions.abort`.\n\n    :param code: The status code for the exception, which must be\n        registered in ``app.aborter``.\n    :param args: Passed to the exception.\n    :param kwargs: Passed to the exception.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.aborter`` if available instead of always\n        using Werkzeug's default ``abort``.\n    \"\"\"\n    if current_app:\n        current_app.aborter(code, *args, **kwargs)\n\n    _wz_abort(code, *args, **kwargs)\n", "tokens": ["src", "flask", "helpers", "py", "def", "abort", "code", "t", "union", "int", "baseresponse", "args", "t", "any", "kwargs", "t", "any", "te", "noreturn", "raise", "an", "exc", "werkzeug", "exceptions", "httpexception", "for", "the", "given", "status", "code", "if", "data", "flask", "current_app", "is", "available", "it", "will", "call", "its", "attr", "flask", "flask", "aborter", "object", "otherwise", "it", "will", "use", "func", "werkzeug", "exceptions", "abort", "param", "code", "the", "status", "code", "for", "the", "exception", "which", "must", "be", "registered", "in", "app", "aborter", "param", "args", "passed", "to", "the", "exception", "param", "kwargs", "passed", "to", "the", "exception", "versionadded", "2", "2", "calls", "current_app", "aborter", "if", "available", "instead", "of", "always", "using", "werkzeug", "s", "default", "abort", "if", "current_app", "current_app", "aborter", "code", "args", "kwargs", "_wz_abort", "code", "args", "kwargs"], "doc_len": 107}
{"doc_id": "src/flask/helpers.py::get_template_attribute", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "get_template_attribute", "text": "文件路径: src/flask/helpers.py\ndef get_template_attribute(template_name: str, attribute: str) -> t.Any:\n    \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n    invoke a macro from within Python code.  If you for example have a\n    template named :file:`_cider.html` with the following contents:\n\n    .. sourcecode:: html+jinja\n\n       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\n    You can access this from Python code like this::\n\n        hello = get_template_attribute('_cider.html', 'hello')\n        return hello('World')\n\n    .. versionadded:: 0.2\n\n    :param template_name: the name of the template\n    :param attribute: the name of the variable of macro to access\n    \"\"\"\n    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)\n", "tokens": ["src", "flask", "helpers", "py", "def", "get_template_attribute", "template_name", "str", "attribute", "str", "t", "any", "loads", "a", "macro", "or", "variable", "a", "template", "exports", "this", "can", "be", "used", "to", "invoke", "a", "macro", "from", "within", "python", "code", "if", "you", "for", "example", "have", "a", "template", "named", "file", "_cider", "html", "with", "the", "following", "contents", "sourcecode", "html", "jinja", "macro", "hello", "name", "hello", "name", "endmacro", "you", "can", "access", "this", "from", "python", "code", "like", "this", "hello", "get_template_attribute", "_cider", "html", "hello", "return", "hello", "world", "versionadded", "0", "2", "param", "template_name", "the", "name", "of", "the", "template", "param", "attribute", "the", "name", "of", "the", "variable", "of", "macro", "to", "access", "return", "getattr", "current_app", "jinja_env", "get_template", "template_name", "module", "attribute"], "doc_len": 102}
{"doc_id": "src/flask/helpers.py::flash", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "flash", "text": "文件路径: src/flask/helpers.py\ndef flash(message: str, category: str = \"message\") -> None:\n    \"\"\"Flashes a message to the next request.  In order to remove the\n    flashed message from the session and to display it to the user,\n    the template has to call :func:`get_flashed_messages`.\n\n    .. versionchanged:: 0.3\n       `category` parameter added.\n\n    :param message: the message to be flashed.\n    :param category: the category for the message.  The following values\n                     are recommended: ``'message'`` for any kind of message,\n                     ``'error'`` for errors, ``'info'`` for information\n                     messages and ``'warning'`` for warnings.  However any\n                     kind of string can be used as category.\n    \"\"\"\n    # Original implementation:\n    #\n    #     session.setdefault('_flashes', []).append((category, message))\n    #\n    # This assumed that changes made to mutable structures in the session are\n    # always in sync with the session object, which is not true for session\n    # implementations that use external storage for keeping their keys/values.\n    flashes = session.get(\"_flashes\", [])\n    flashes.append((category, message))\n    session[\"_flashes\"] = flashes\n    message_flashed.send(\n        current_app._get_current_object(),  # type: ignore\n        message=message,\n        category=category,\n    )\n", "tokens": ["src", "flask", "helpers", "py", "def", "flash", "message", "str", "category", "str", "message", "none", "flashes", "a", "message", "to", "the", "next", "request", "in", "order", "to", "remove", "the", "flashed", "message", "from", "the", "session", "and", "to", "display", "it", "to", "the", "user", "the", "template", "has", "to", "call", "func", "get_flashed_messages", "versionchanged", "0", "3", "category", "parameter", "added", "param", "message", "the", "message", "to", "be", "flashed", "param", "category", "the", "category", "for", "the", "message", "the", "following", "values", "are", "recommended", "message", "for", "any", "kind", "of", "message", "error", "for", "errors", "info", "for", "information", "messages", "and", "warning", "for", "warnings", "however", "any", "kind", "of", "string", "can", "be", "used", "as", "category", "original", "implementation", "session", "setdefault", "_flashes", "append", "category", "message", "this", "assumed", "that", "changes", "made", "to", "mutable", "structures", "in", "the", "session", "are", "always", "in", "sync", "with", "the", "session", "object", "which", "is", "not", "true", "for", "session", "implementations", "that", "use", "external", "storage", "for", "keeping", "their", "keys", "values", "flashes", "session", "get", "_flashes", "flashes", "append", "category", "message", "session", "_flashes", "flashes", "message_flashed", "send", "current_app", "_get_current_object", "type", "ignore", "message", "message", "category", "category"], "doc_len": 159}
{"doc_id": "src/flask/helpers.py::get_flashed_messages", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "get_flashed_messages", "text": "文件路径: src/flask/helpers.py\ndef get_flashed_messages(\n    with_categories: bool = False, category_filter: t.Iterable[str] = ()\n) -> t.Union[t.List[str], t.List[t.Tuple[str, str]]]:\n    \"\"\"Pulls all flashed messages from the session and returns them.\n    Further calls in the same request to the function will return\n    the same messages.  By default just the messages are returned,\n    but when `with_categories` is set to ``True``, the return value will\n    be a list of tuples in the form ``(category, message)`` instead.\n\n    Filter the flashed messages to one or more categories by providing those\n    categories in `category_filter`.  This allows rendering categories in\n    separate html blocks.  The `with_categories` and `category_filter`\n    arguments are distinct:\n\n    * `with_categories` controls whether categories are returned with message\n      text (``True`` gives a tuple, where ``False`` gives just the message text).\n    * `category_filter` filters the messages down to only those matching the\n      provided categories.\n\n    See :doc:`/patterns/flashing` for examples.\n\n    .. versionchanged:: 0.3\n       `with_categories` parameter added.\n\n    .. versionchanged:: 0.9\n        `category_filter` parameter added.\n\n    :param with_categories: set to ``True`` to also receive categories.\n    :param category_filter: filter of categories to limit return values.  Only\n                            categories in the list will be returned.\n    \"\"\"\n    flashes = request_ctx.flashes\n    if flashes is None:\n        flashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\n        request_ctx.flashes = flashes\n    if category_filter:\n        flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n    if not with_categories:\n        return [x[1] for x in flashes]\n    return flashes\n", "tokens": ["src", "flask", "helpers", "py", "def", "get_flashed_messages", "with_categories", "bool", "false", "category_filter", "t", "iterable", "str", "t", "union", "t", "list", "str", "t", "list", "t", "tuple", "str", "str", "pulls", "all", "flashed", "messages", "from", "the", "session", "and", "returns", "them", "further", "calls", "in", "the", "same", "request", "to", "the", "function", "will", "return", "the", "same", "messages", "by", "default", "just", "the", "messages", "are", "returned", "but", "when", "with_categories", "is", "set", "to", "true", "the", "return", "value", "will", "be", "a", "list", "of", "tuples", "in", "the", "form", "category", "message", "instead", "filter", "the", "flashed", "messages", "to", "one", "or", "more", "categories", "by", "providing", "those", "categories", "in", "category_filter", "this", "allows", "rendering", "categories", "in", "separate", "html", "blocks", "the", "with_categories", "and", "category_filter", "arguments", "are", "distinct", "with_categories", "controls", "whether", "categories", "are", "returned", "with", "message", "text", "true", "gives", "a", "tuple", "where", "false", "gives", "just", "the", "message", "text", "category_filter", "filters", "the", "messages", "down", "to", "only", "those", "matching", "the", "provided", "categories", "see", "doc", "patterns", "flashing", "for", "examples", "versionchanged", "0", "3", "with_categories", "parameter", "added", "versionchanged", "0", "9", "category_filter", "parameter", "added", "param", "with_categories", "set", "to", "true", "to", "also", "receive", "categories", "param", "category_filter", "filter", "of", "categories", "to", "limit", "return", "values", "only", "categories", "in", "the", "list", "will", "be", "returned", "flashes", "request_ctx", "flashes", "if", "flashes", "is", "none", "flashes", "session", "pop", "_flashes", "if", "_flashes", "in", "session", "else", "request_ctx", "flashes", "flashes", "if", "category_filter", "flashes", "list", "filter", "lambda", "f", "f", "0", "in", "category_filter", "flashes", "if", "not", "with_categories", "return", "x", "1", "for", "x", "in", "flashes", "return", "flashes"], "doc_len": 226}
{"doc_id": "src/flask/helpers.py::_prepare_send_file_kwargs", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "_prepare_send_file_kwargs", "text": "文件路径: src/flask/helpers.py\ndef _prepare_send_file_kwargs(**kwargs: t.Any) -> t.Dict[str, t.Any]:\n    if kwargs.get(\"max_age\") is None:\n        kwargs[\"max_age\"] = current_app.get_send_file_max_age\n\n    kwargs.update(\n        environ=request.environ,\n        use_x_sendfile=current_app.config[\"USE_X_SENDFILE\"],\n        response_class=current_app.response_class,\n        _root_path=current_app.root_path,  # type: ignore\n    )\n    return kwargs\n", "tokens": ["src", "flask", "helpers", "py", "def", "_prepare_send_file_kwargs", "kwargs", "t", "any", "t", "dict", "str", "t", "any", "if", "kwargs", "get", "max_age", "is", "none", "kwargs", "max_age", "current_app", "get_send_file_max_age", "kwargs", "update", "environ", "request", "environ", "use_x_sendfile", "current_app", "config", "use_x_sendfile", "response_class", "current_app", "response_class", "_root_path", "current_app", "root_path", "type", "ignore", "return", "kwargs"], "doc_len": 43}
{"doc_id": "src/flask/helpers.py::send_file", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "send_file", "text": "文件路径: src/flask/helpers.py\ndef send_file(\n    path_or_file: t.Union[os.PathLike, str, t.BinaryIO],\n    mimetype: t.Optional[str] = None,\n    as_attachment: bool = False,\n    download_name: t.Optional[str] = None,\n    conditional: bool = True,\n    etag: t.Union[bool, str] = True,\n    last_modified: t.Optional[t.Union[datetime, int, float]] = None,\n    max_age: t.Optional[\n        t.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]\n    ] = None,\n) -> \"Response\":\n    \"\"\"Send the contents of a file to the client.\n\n    The first argument can be a file path or a file-like object. Paths\n    are preferred in most cases because Werkzeug can manage the file and\n    get extra information from the path. Passing a file-like object\n    requires that the file is opened in binary mode, and is mostly\n    useful when building a file in memory with :class:`io.BytesIO`.\n\n    Never pass file paths provided by a user. The path is assumed to be\n    trusted, so a user could craft a path to access a file you didn't\n    intend. Use :func:`send_from_directory` to safely serve\n    user-requested paths from within a directory.\n\n    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n    ``USE_X_SENDFILE = True`` will tell the server to send the given\n    path, which is much more efficient than reading it in Python.\n\n    :param path_or_file: The path to the file to send, relative to the\n        current working directory if a relative path is given.\n        Alternatively, a file-like object opened in binary mode. Make\n        sure the file pointer is seeked to the start of the data.\n    :param mimetype: The MIME type to send for the file. If not\n        provided, it will try to detect it from the file name.\n    :param as_attachment: Indicate to a browser that it should offer to\n        save the file instead of displaying it.\n    :param download_name: The default name browsers will use when saving\n        the file. Defaults to the passed file name.\n    :param conditional: Enable conditional and range responses based on\n        request headers. Requires passing a file path and ``environ``.\n    :param etag: Calculate an ETag for the file, which requires passing\n        a file path. Can also be a string to use instead.\n    :param last_modified: The last modified time to send for the file,\n        in seconds. If not provided, it will try to detect it from the\n        file path.\n    :param max_age: How long the client should cache the file, in\n        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n        it will be ``no-cache`` to prefer conditional caching.\n\n    .. versionchanged:: 2.0\n        ``download_name`` replaces the ``attachment_filename``\n        parameter. If ``as_attachment=False``, it is passed with\n        ``Content-Disposition: inline`` instead.\n\n    .. versionchanged:: 2.0\n        ``max_age`` replaces the ``cache_timeout`` parameter.\n        ``conditional`` is enabled and ``max_age`` is not set by\n        default.\n\n    .. versionchanged:: 2.0\n        ``etag`` replaces the ``add_etags`` parameter. It can be a\n        string to use instead of generating one.\n\n    .. versionchanged:: 2.0\n        Passing a file-like object that inherits from\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n        than sending an empty file.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionchanged:: 1.1\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n    .. versionchanged:: 1.1\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n    .. versionchanged:: 1.0.3\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n        compatibility with WSGI servers.\n\n    .. versionchanged:: 1.0\n        UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n    .. versionchanged:: 0.12\n        The filename is no longer automatically inferred from file\n        objects. If you want to use automatic MIME and etag support,\n        pass a filename via ``filename_or_fp`` or\n        ``attachment_filename``.\n\n    .. versionchanged:: 0.12\n        ``attachment_filename`` is preferred over ``filename`` for MIME\n        detection.\n\n    .. versionchanged:: 0.9\n        ``cache_timeout`` defaults to\n        :meth:`Flask.get_send_file_max_age`.\n\n    .. versionchanged:: 0.7\n        MIME guessing and etag support for file-like objects was\n        deprecated because it was unreliable. Pass a filename if you are\n        able to, otherwise attach an etag yourself.\n\n    .. versionchanged:: 0.5\n        The ``add_etags``, ``cache_timeout`` and ``conditional``\n        parameters were added. The default behavior is to add etags.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return werkzeug.utils.send_file(  # type: ignore[return-value]\n        **_prepare_send_file_kwargs(\n            path_or_file=path_or_file,\n            environ=request.environ,\n            mimetype=mimetype,\n            as_attachment=as_attachment,\n            download_name=download_name,\n            conditional=conditional,\n            etag=etag,\n            last_modified=last_modified,\n            max_age=max_age,\n        )\n    )\n", "tokens": ["src", "flask", "helpers", "py", "def", "send_file", "path_or_file", "t", "union", "os", "pathlike", "str", "t", "binaryio", "mimetype", "t", "optional", "str", "none", "as_attachment", "bool", "false", "download_name", "t", "optional", "str", "none", "conditional", "bool", "true", "etag", "t", "union", "bool", "str", "true", "last_modified", "t", "optional", "t", "union", "datetime", "int", "float", "none", "max_age", "t", "optional", "t", "union", "int", "t", "callable", "t", "optional", "str", "t", "optional", "int", "none", "response", "send", "the", "contents", "of", "a", "file", "to", "the", "client", "the", "first", "argument", "can", "be", "a", "file", "path", "or", "a", "file", "like", "object", "paths", "are", "preferred", "in", "most", "cases", "because", "werkzeug", "can", "manage", "the", "file", "and", "get", "extra", "information", "from", "the", "path", "passing", "a", "file", "like", "object", "requires", "that", "the", "file", "is", "opened", "in", "binary", "mode", "and", "is", "mostly", "useful", "when", "building", "a", "file", "in", "memory", "with", "class", "io", "bytesio", "never", "pass", "file", "paths", "provided", "by", "a", "user", "the", "path", "is", "assumed", "to", "be", "trusted", "so", "a", "user", "could", "craft", "a", "path", "to", "access", "a", "file", "you", "didn", "t", "intend", "use", "func", "send_from_directory", "to", "safely", "serve", "user", "requested", "paths", "from", "within", "a", "directory", "if", "the", "wsgi", "server", "sets", "a", "file_wrapper", "in", "environ", "it", "is", "used", "otherwise", "werkzeug", "s", "built", "in", "wrapper", "is", "used", "alternatively", "if", "the", "http", "server", "supports", "x", "sendfile", "configuring", "flask", "with", "use_x_sendfile", "true", "will", "tell", "the", "server", "to", "send", "the", "given", "path", "which", "is", "much", "more", "efficient", "than", "reading", "it", "in", "python", "param", "path_or_file", "the", "path", "to", "the", "file", "to", "send", "relative", "to", "the", "current", "working", "directory", "if", "a", "relative", "path", "is", "given", "alternatively", "a", "file", "like", "object", "opened", "in", "binary", "mode", "make", "sure", "the", "file", "pointer", "is", "seeked", "to", "the", "start", "of", "the", "data", "param", "mimetype", "the", "mime", "type", "to", "send", "for", "the", "file", "if", "not", "provided", "it", "will", "try", "to", "detect", "it", "from", "the", "file", "name", "param", "as_attachment", "indicate", "to", "a", "browser", "that", "it", "should", "offer", "to", "save", "the", "file", "instead", "of", "displaying", "it", "param", "download_name", "the", "default", "name", "browsers", "will", "use", "when", "saving", "the", "file", "defaults", "to", "the", "passed", "file", "name", "param", "conditional", "enable", "conditional", "and", "range", "responses", "based", "on", "request", "headers", "requires", "passing", "a", "file", "path", "and", "environ", "param", "etag", "calculate", "an", "etag", "for", "the", "file", "which", "requires", "passing", "a", "file", "path", "can", "also", "be", "a", "string", "to", "use", "instead", "param", "last_modified", "the", "last", "modified", "time", "to", "send", "for", "the", "file", "in", "seconds", "if", "not", "provided", "it", "will", "try", "to", "detect", "it", "from", "the", "file", "path", "param", "max_age", "how", "long", "the", "client", "should", "cache", "the", "file", "in", "seconds", "if", "set", "cache", "control", "will", "be", "public", "otherwise", "it", "will", "be", "no", "cache", "to", "prefer", "conditional", "caching", "versionchanged", "2", "0", "download_name", "replaces", "the", "attachment_filename", "parameter", "if", "as_attachment", "false", "it", "is", "passed", "with", "content", "disposition", "inline", "instead", "versionchanged", "2", "0", "max_age", "replaces", "the", "cache_timeout", "parameter", "conditional", "is", "enabled", "and", "max_age", "is", "not", "set", "by", "default", "versionchanged", "2", "0", "etag", "replaces", "the", "add_etags", "parameter", "it", "can", "be", "a", "string", "to", "use", "instead", "of", "generating", "one", "versionchanged", "2", "0", "passing", "a", "file", "like", "object", "that", "inherits", "from", "class", "io", "textiobase", "will", "raise", "a", "exc", "valueerror", "rather", "than", "sending", "an", "empty", "file", "versionadded", "2", "0", "moved", "the", "implementation", "to", "werkzeug", "this", "is", "now", "a", "wrapper", "to", "pass", "some", "flask", "specific", "arguments", "versionchanged", "1", "1", "filename", "may", "be", "a", "class", "os", "pathlike", "object", "versionchanged", "1", "1", "passing", "a", "class", "io", "bytesio", "object", "supports", "range", "requests", "versionchanged", "1", "0", "3", "filenames", "are", "encoded", "with", "ascii", "instead", "of", "latin", "1", "for", "broader", "compatibility", "with", "wsgi", "servers", "versionchanged", "1", "0", "utf", "8", "filenames", "as", "specified", "in", "rfc", "2231", "are", "supported", "versionchanged", "0", "12", "the", "filename", "is", "no", "longer", "automatically", "inferred", "from", "file", "objects", "if", "you", "want", "to", "use", "automatic", "mime", "and", "etag", "support", "pass", "a", "filename", "via", "filename_or_fp", "or", "attachment_filename", "versionchanged", "0", "12", "attachment_filename", "is", "preferred", "over", "filename", "for", "mime", "detection", "versionchanged", "0", "9", "cache_timeout", "defaults", "to", "meth", "flask", "get_send_file_max_age", "versionchanged", "0", "7", "mime", "guessing", "and", "etag", "support", "for", "file", "like", "objects", "was", "deprecated", "because", "it", "was", "unreliable", "pass", "a", "filename", "if", "you", "are", "able", "to", "otherwise", "attach", "an", "etag", "yourself", "versionchanged", "0", "5", "the", "add_etags", "cache_timeout", "and", "conditional", "parameters", "were", "added", "the", "default", "behavior", "is", "to", "add", "etags", "versionadded", "0", "2", "return", "werkzeug", "utils", "send_file", "type", "ignore", "return", "value", "_prepare_send_file_kwargs", "path_or_file", "path_or_file", "environ", "request", "environ", "mimetype", "mimetype", "as_attachment", "as_attachment", "download_name", "download_name", "conditional", "conditional", "etag", "etag", "last_modified", "last_modified", "max_age", "max_age"], "doc_len": 707}
{"doc_id": "src/flask/helpers.py::send_from_directory", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "send_from_directory", "text": "文件路径: src/flask/helpers.py\ndef send_from_directory(\n    directory: t.Union[os.PathLike, str],\n    path: t.Union[os.PathLike, str],\n    **kwargs: t.Any,\n) -> \"Response\":\n    \"\"\"Send a file from within a directory using :func:`send_file`.\n\n    .. code-block:: python\n\n        @app.route(\"/uploads/<path:name>\")\n        def download_file(name):\n            return send_from_directory(\n                app.config['UPLOAD_FOLDER'], name, as_attachment=True\n            )\n\n    This is a secure way to serve files from a folder, such as static\n    files or uploads. Uses :func:`~werkzeug.security.safe_join` to\n    ensure the path coming from the client is not maliciously crafted to\n    point outside the specified directory.\n\n    If the final path does not point to an existing regular file,\n    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n    :param directory: The directory that ``path`` must be located under,\n        relative to the current application's root path.\n    :param path: The path to the file to send, relative to\n        ``directory``.\n    :param kwargs: Arguments to pass to :func:`send_file`.\n\n    .. versionchanged:: 2.0\n        ``path`` replaces the ``filename`` parameter.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionadded:: 0.5\n    \"\"\"\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory, path, **_prepare_send_file_kwargs(**kwargs)\n    )\n", "tokens": ["src", "flask", "helpers", "py", "def", "send_from_directory", "directory", "t", "union", "os", "pathlike", "str", "path", "t", "union", "os", "pathlike", "str", "kwargs", "t", "any", "response", "send", "a", "file", "from", "within", "a", "directory", "using", "func", "send_file", "code", "block", "python", "app", "route", "uploads", "path", "name", "def", "download_file", "name", "return", "send_from_directory", "app", "config", "upload_folder", "name", "as_attachment", "true", "this", "is", "a", "secure", "way", "to", "serve", "files", "from", "a", "folder", "such", "as", "static", "files", "or", "uploads", "uses", "func", "werkzeug", "security", "safe_join", "to", "ensure", "the", "path", "coming", "from", "the", "client", "is", "not", "maliciously", "crafted", "to", "point", "outside", "the", "specified", "directory", "if", "the", "final", "path", "does", "not", "point", "to", "an", "existing", "regular", "file", "raises", "a", "404", "exc", "werkzeug", "exceptions", "notfound", "error", "param", "directory", "the", "directory", "that", "path", "must", "be", "located", "under", "relative", "to", "the", "current", "application", "s", "root", "path", "param", "path", "the", "path", "to", "the", "file", "to", "send", "relative", "to", "directory", "param", "kwargs", "arguments", "to", "pass", "to", "func", "send_file", "versionchanged", "2", "0", "path", "replaces", "the", "filename", "parameter", "versionadded", "2", "0", "moved", "the", "implementation", "to", "werkzeug", "this", "is", "now", "a", "wrapper", "to", "pass", "some", "flask", "specific", "arguments", "versionadded", "0", "5", "return", "werkzeug", "utils", "send_from_directory", "type", "ignore", "return", "value", "directory", "path", "_prepare_send_file_kwargs", "kwargs"], "doc_len": 191}
{"doc_id": "src/flask/helpers.py::get_root_path", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "get_root_path", "text": "文件路径: src/flask/helpers.py\ndef get_root_path(import_name: str) -> str:\n    \"\"\"Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n\n    Not to be confused with the value returned by :func:`find_package`.\n\n    :meta private:\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    loader = pkgutil.get_loader(import_name)\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None or import_name == \"__main__\":\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))\n", "tokens": ["src", "flask", "helpers", "py", "def", "get_root_path", "import_name", "str", "str", "find", "the", "root", "path", "of", "a", "package", "or", "the", "path", "that", "contains", "a", "module", "if", "it", "cannot", "be", "found", "returns", "the", "current", "working", "directory", "not", "to", "be", "confused", "with", "the", "value", "returned", "by", "func", "find_package", "meta", "private", "module", "already", "imported", "and", "has", "a", "file", "attribute", "use", "that", "first", "mod", "sys", "modules", "get", "import_name", "if", "mod", "is", "not", "none", "and", "hasattr", "mod", "__file__", "and", "mod", "__file__", "is", "not", "none", "return", "os", "path", "dirname", "os", "path", "abspath", "mod", "__file__", "next", "attempt", "check", "the", "loader", "loader", "pkgutil", "get_loader", "import_name", "loader", "does", "not", "exist", "or", "we", "re", "referring", "to", "an", "unloaded", "main", "module", "or", "a", "main", "module", "without", "path", "interactive", "sessions", "go", "with", "the", "current", "working", "directory", "if", "loader", "is", "none", "or", "import_name", "__main__", "return", "os", "getcwd", "if", "hasattr", "loader", "get_filename", "filepath", "loader", "get_filename", "import_name", "else", "fall", "back", "to", "imports", "__import__", "import_name", "mod", "sys", "modules", "import_name", "filepath", "getattr", "mod", "__file__", "none", "if", "we", "don", "t", "have", "a", "file", "path", "it", "might", "be", "because", "it", "is", "a", "namespace", "package", "in", "this", "case", "pick", "the", "root", "path", "from", "the", "first", "module", "that", "is", "contained", "in", "the", "package", "if", "filepath", "is", "none", "raise", "runtimeerror", "no", "root", "path", "can", "be", "found", "for", "the", "provided", "module", "f", "import_name", "r", "this", "can", "happen", "because", "the", "module", "came", "from", "an", "import", "hook", "that", "does", "not", "provide", "file", "name", "information", "or", "because", "it", "s", "a", "namespace", "package", "in", "this", "case", "the", "root", "path", "needs", "to", "be", "explicitly", "provided", "filepath", "is", "import_name", "py", "for", "a", "module", "or", "__init__", "py", "for", "a", "package", "return", "os", "path", "dirname", "os", "path", "abspath", "filepath"], "doc_len": 266}
{"doc_id": "src/flask/helpers.py::locked_cached_property.__init__", "file_path": "src/flask/helpers.py", "class_name": "locked_cached_property", "func_name": "__init__", "text": "文件路径: src/flask/helpers.py, 类名: locked_cached_property\n    def __init__(\n        self,\n        fget: t.Callable[[t.Any], t.Any],\n        name: t.Optional[str] = None,\n        doc: t.Optional[str] = None,\n    ) -> None:\n        import warnings\n\n        warnings.warn(\n            \"'locked_cached_property' is deprecated and will be removed in Flask 2.4.\"\n            \" Use a lock inside the decorated function if locking is needed.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        super().__init__(fget, name=name, doc=doc)\n        self.lock = RLock()\n", "tokens": ["src", "flask", "helpers", "py", "locked_cached_property", "def", "__init__", "self", "fget", "t", "callable", "t", "any", "t", "any", "name", "t", "optional", "str", "none", "doc", "t", "optional", "str", "none", "none", "import", "warnings", "warnings", "warn", "locked_cached_property", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "use", "a", "lock", "inside", "the", "decorated", "function", "if", "locking", "is", "needed", "deprecationwarning", "stacklevel", "2", "super", "__init__", "fget", "name", "name", "doc", "doc", "self", "lock", "rlock"], "doc_len": 65}
{"doc_id": "src/flask/helpers.py::locked_cached_property.__get__", "file_path": "src/flask/helpers.py", "class_name": "locked_cached_property", "func_name": "__get__", "text": "文件路径: src/flask/helpers.py, 类名: locked_cached_property\n    def __get__(self, obj: object, type: type = None) -> t.Any:  # type: ignore\n        if obj is None:\n            return self\n\n        with self.lock:\n            return super().__get__(obj, type=type)\n", "tokens": ["src", "flask", "helpers", "py", "locked_cached_property", "def", "__get__", "self", "obj", "object", "type", "type", "none", "t", "any", "type", "ignore", "if", "obj", "is", "none", "return", "self", "with", "self", "lock", "return", "super", "__get__", "obj", "type", "type"], "doc_len": 32}
{"doc_id": "src/flask/helpers.py::locked_cached_property.__set__", "file_path": "src/flask/helpers.py", "class_name": "locked_cached_property", "func_name": "__set__", "text": "文件路径: src/flask/helpers.py, 类名: locked_cached_property\n    def __set__(self, obj: object, value: t.Any) -> None:\n        with self.lock:\n            super().__set__(obj, value)\n", "tokens": ["src", "flask", "helpers", "py", "locked_cached_property", "def", "__set__", "self", "obj", "object", "value", "t", "any", "none", "with", "self", "lock", "super", "__set__", "obj", "value"], "doc_len": 21}
{"doc_id": "src/flask/helpers.py::locked_cached_property.__delete__", "file_path": "src/flask/helpers.py", "class_name": "locked_cached_property", "func_name": "__delete__", "text": "文件路径: src/flask/helpers.py, 类名: locked_cached_property\n    def __delete__(self, obj: object) -> None:\n        with self.lock:\n            super().__delete__(obj)\n", "tokens": ["src", "flask", "helpers", "py", "locked_cached_property", "def", "__delete__", "self", "obj", "object", "none", "with", "self", "lock", "super", "__delete__", "obj"], "doc_len": 17}
{"doc_id": "src/flask/helpers.py::is_ip", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "is_ip", "text": "文件路径: src/flask/helpers.py\ndef is_ip(value: str) -> bool:\n    \"\"\"Determine if the given string is an IP address.\n\n    :param value: value to check\n    :type value: str\n\n    :return: True if string is an IP address\n    :rtype: bool\n    \"\"\"\n    for family in (socket.AF_INET, socket.AF_INET6):\n        try:\n            socket.inet_pton(family, value)\n        except OSError:\n            pass\n        else:\n            return True\n\n    return False\n", "tokens": ["src", "flask", "helpers", "py", "def", "is_ip", "value", "str", "bool", "determine", "if", "the", "given", "string", "is", "an", "ip", "address", "param", "value", "value", "to", "check", "type", "value", "str", "return", "true", "if", "string", "is", "an", "ip", "address", "rtype", "bool", "for", "family", "in", "socket", "af_inet", "socket", "af_inet6", "try", "socket", "inet_pton", "family", "value", "except", "oserror", "pass", "else", "return", "true", "return", "false"], "doc_len": 56}
{"doc_id": "src/flask/helpers.py::_split_blueprint_path", "file_path": "src/flask/helpers.py", "class_name": null, "func_name": "_split_blueprint_path", "text": "文件路径: src/flask/helpers.py\ndef _split_blueprint_path(name: str) -> t.List[str]:\n    out: t.List[str] = [name]\n\n    if \".\" in name:\n        out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n\n    return out\n", "tokens": ["src", "flask", "helpers", "py", "def", "_split_blueprint_path", "name", "str", "t", "list", "str", "out", "t", "list", "str", "name", "if", "in", "name", "out", "extend", "_split_blueprint_path", "name", "rpartition", "0", "return", "out"], "doc_len": 27}
{"doc_id": "src/flask/logging.py::wsgi_errors_stream", "file_path": "src/flask/logging.py", "class_name": null, "func_name": "wsgi_errors_stream", "text": "文件路径: src/flask/logging.py\ndef wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    return request.environ[\"wsgi.errors\"] if request else sys.stderr\n", "tokens": ["src", "flask", "logging", "py", "def", "wsgi_errors_stream", "t", "textio", "find", "the", "most", "appropriate", "error", "stream", "for", "the", "application", "if", "a", "request", "is", "active", "log", "to", "wsgi", "errors", "otherwise", "use", "sys", "stderr", "if", "you", "configure", "your", "own", "class", "logging", "streamhandler", "you", "may", "want", "to", "use", "this", "for", "the", "stream", "if", "you", "are", "using", "file", "or", "dict", "configuration", "and", "can", "t", "import", "this", "directly", "you", "can", "refer", "to", "it", "as", "ext", "flask", "logging", "wsgi_errors_stream", "return", "request", "environ", "wsgi", "errors", "if", "request", "else", "sys", "stderr"], "doc_len": 81}
{"doc_id": "src/flask/logging.py::has_level_handler", "file_path": "src/flask/logging.py", "class_name": null, "func_name": "has_level_handler", "text": "文件路径: src/flask/logging.py\ndef has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False\n", "tokens": ["src", "flask", "logging", "py", "def", "has_level_handler", "logger", "logging", "logger", "bool", "check", "if", "there", "is", "a", "handler", "in", "the", "logging", "chain", "that", "will", "handle", "the", "given", "logger", "s", "meth", "effective", "level", "logging", "logger", "geteffectivelevel", "level", "logger", "geteffectivelevel", "current", "logger", "while", "current", "if", "any", "handler", "level", "level", "for", "handler", "in", "current", "handlers", "return", "true", "if", "not", "current", "propagate", "break", "current", "current", "parent", "type", "ignore", "return", "false"], "doc_len": 64}
{"doc_id": "src/flask/logging.py::create_logger", "file_path": "src/flask/logging.py", "class_name": null, "func_name": "create_logger", "text": "文件路径: src/flask/logging.py\ndef create_logger(app: \"Flask\") -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n", "tokens": ["src", "flask", "logging", "py", "def", "create_logger", "app", "flask", "logging", "logger", "get", "the", "flask", "app", "s", "logger", "and", "configure", "it", "if", "needed", "the", "logger", "name", "will", "be", "the", "same", "as", "attr", "app", "import_name", "flask", "flask", "name", "when", "attr", "flask", "flask", "debug", "is", "enabled", "set", "the", "logger", "level", "to", "data", "logging", "debug", "if", "it", "is", "not", "set", "if", "there", "is", "no", "handler", "for", "the", "logger", "s", "effective", "level", "add", "a", "class", "logging", "streamhandler", "for", "func", "flask", "logging", "wsgi_errors_stream", "with", "a", "basic", "format", "logger", "logging", "getlogger", "app", "name", "if", "app", "debug", "and", "not", "logger", "level", "logger", "setlevel", "logging", "debug", "if", "not", "has_level_handler", "logger", "logger", "addhandler", "default_handler", "return", "logger"], "doc_len": 105}
{"doc_id": "src/flask/scaffold.py::setupmethod", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "setupmethod", "text": "文件路径: src/flask/scaffold.py\ndef setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))\n", "tokens": ["src", "flask", "scaffold", "py", "def", "setupmethod", "f", "f", "f", "f_name", "f", "__name__", "def", "wrapper_func", "self", "args", "t", "any", "kwargs", "t", "any", "t", "any", "self", "_check_setup_finished", "f_name", "return", "f", "self", "args", "kwargs", "return", "t", "cast", "f", "update_wrapper", "wrapper_func", "f"], "doc_len": 38}
{"doc_id": "src/flask/scaffold.py::Scaffold.__init__", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "__init__", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def __init__(\n        self,\n        import_name: str,\n        static_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n        static_url_path: t.Optional[str] = None,\n        template_folder: t.Optional[t.Union[str, os.PathLike]] = None,\n        root_path: t.Optional[str] = None,\n    ):\n        #: The name of the package or module that this object belongs\n        #: to. Do not change this once it is set by the constructor.\n        self.import_name = import_name\n\n        self.static_folder = static_folder  # type: ignore\n        self.static_url_path = static_url_path\n\n        #: The path to the templates folder, relative to\n        #: :attr:`root_path`, to add to the template loader. ``None`` if\n        #: templates should not be added.\n        self.template_folder = template_folder\n\n        if root_path is None:\n            root_path = get_root_path(self.import_name)\n\n        #: Absolute path to the package on the filesystem. Used to look\n        #: up resources contained in the package.\n        self.root_path = root_path\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        #: A dictionary mapping endpoint names to view functions.\n        #:\n        #: To register a view function, use the :meth:`route` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.view_functions: t.Dict[str, t.Callable] = {}\n\n        #: A data structure of registered error handlers, in the format\n        #: ``{scope: {code: {class: handler}}}``. The ``scope`` key is\n        #: the name of a blueprint the handlers are active for, or\n        #: ``None`` for all requests. The ``code`` key is the HTTP\n        #: status code for ``HTTPException``, or ``None`` for\n        #: other exceptions. The innermost dictionary maps exception\n        #: classes to handler functions.\n        #:\n        #: To register an error handler, use the :meth:`errorhandler`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.error_handler_spec: t.Dict[\n            ft.AppOrBlueprintKey,\n            t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ft.ErrorHandlerCallable]],\n        ] = defaultdict(lambda: defaultdict(dict))\n\n        #: A data structure of functions to call at the beginning of\n        #: each request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`before_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.before_request_funcs: t.Dict[\n            ft.AppOrBlueprintKey, t.List[ft.BeforeRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request, in the format ``{scope: [functions]}``. The\n        #: ``scope`` key is the name of a blueprint the functions are\n        #: active for, or ``None`` for all requests.\n        #:\n        #: To register a function, use the :meth:`after_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.after_request_funcs: t.Dict[\n            ft.AppOrBlueprintKey, t.List[ft.AfterRequestCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call at the end of each\n        #: request even if an exception is raised, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`teardown_request`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.teardown_request_funcs: t.Dict[\n            ft.AppOrBlueprintKey, t.List[ft.TeardownCallable]\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to pass extra context\n        #: values when rendering templates, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`context_processor`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.template_context_processors: t.Dict[\n            ft.AppOrBlueprintKey, t.List[ft.TemplateContextProcessorCallable]\n        ] = defaultdict(list, {None: [_default_template_ctx_processor]})\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments passed to the view function, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the\n        #: :meth:`url_value_preprocessor` decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_value_preprocessors: t.Dict[\n            ft.AppOrBlueprintKey,\n            t.List[ft.URLValuePreprocessorCallable],\n        ] = defaultdict(list)\n\n        #: A data structure of functions to call to modify the keyword\n        #: arguments when generating URLs, in the format\n        #: ``{scope: [functions]}``. The ``scope`` key is the name of a\n        #: blueprint the functions are active for, or ``None`` for all\n        #: requests.\n        #:\n        #: To register a function, use the :meth:`url_defaults`\n        #: decorator.\n        #:\n        #: This data structure is internal. It should not be modified\n        #: directly and its format may change at any time.\n        self.url_default_functions: t.Dict[\n            ft.AppOrBlueprintKey, t.List[ft.URLDefaultCallable]\n        ] = defaultdict(list)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "__init__", "self", "import_name", "str", "static_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "none", "static_url_path", "t", "optional", "str", "none", "template_folder", "t", "optional", "t", "union", "str", "os", "pathlike", "none", "root_path", "t", "optional", "str", "none", "the", "name", "of", "the", "package", "or", "module", "that", "this", "object", "belongs", "to", "do", "not", "change", "this", "once", "it", "is", "set", "by", "the", "constructor", "self", "import_name", "import_name", "self", "static_folder", "static_folder", "type", "ignore", "self", "static_url_path", "static_url_path", "the", "path", "to", "the", "templates", "folder", "relative", "to", "attr", "root_path", "to", "add", "to", "the", "template", "loader", "none", "if", "templates", "should", "not", "be", "added", "self", "template_folder", "template_folder", "if", "root_path", "is", "none", "root_path", "get_root_path", "self", "import_name", "absolute", "path", "to", "the", "package", "on", "the", "filesystem", "used", "to", "look", "up", "resources", "contained", "in", "the", "package", "self", "root_path", "root_path", "the", "click", "command", "group", "for", "registering", "cli", "commands", "for", "this", "object", "the", "commands", "are", "available", "from", "the", "flask", "command", "once", "the", "application", "has", "been", "discovered", "and", "blueprints", "have", "been", "registered", "self", "cli", "appgroup", "a", "dictionary", "mapping", "endpoint", "names", "to", "view", "functions", "to", "register", "a", "view", "function", "use", "the", "meth", "route", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "view_functions", "t", "dict", "str", "t", "callable", "a", "data", "structure", "of", "registered", "error", "handlers", "in", "the", "format", "scope", "code", "class", "handler", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "handlers", "are", "active", "for", "or", "none", "for", "all", "requests", "the", "code", "key", "is", "the", "http", "status", "code", "for", "httpexception", "or", "none", "for", "other", "exceptions", "the", "innermost", "dictionary", "maps", "exception", "classes", "to", "handler", "functions", "to", "register", "an", "error", "handler", "use", "the", "meth", "errorhandler", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "error_handler_spec", "t", "dict", "ft", "apporblueprintkey", "t", "dict", "t", "optional", "int", "t", "dict", "t", "type", "exception", "ft", "errorhandlercallable", "defaultdict", "lambda", "defaultdict", "dict", "a", "data", "structure", "of", "functions", "to", "call", "at", "the", "beginning", "of", "each", "request", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "before_request", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "before_request_funcs", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "beforerequestcallable", "defaultdict", "list", "a", "data", "structure", "of", "functions", "to", "call", "at", "the", "end", "of", "each", "request", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "after_request", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "after_request_funcs", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "afterrequestcallable", "defaultdict", "list", "a", "data", "structure", "of", "functions", "to", "call", "at", "the", "end", "of", "each", "request", "even", "if", "an", "exception", "is", "raised", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "teardown_request", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "teardown_request_funcs", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "teardowncallable", "defaultdict", "list", "a", "data", "structure", "of", "functions", "to", "call", "to", "pass", "extra", "context", "values", "when", "rendering", "templates", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "context_processor", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "template_context_processors", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "templatecontextprocessorcallable", "defaultdict", "list", "none", "_default_template_ctx_processor", "a", "data", "structure", "of", "functions", "to", "call", "to", "modify", "the", "keyword", "arguments", "passed", "to", "the", "view", "function", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "url_value_preprocessor", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "url_value_preprocessors", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "urlvaluepreprocessorcallable", "defaultdict", "list", "a", "data", "structure", "of", "functions", "to", "call", "to", "modify", "the", "keyword", "arguments", "when", "generating", "urls", "in", "the", "format", "scope", "functions", "the", "scope", "key", "is", "the", "name", "of", "a", "blueprint", "the", "functions", "are", "active", "for", "or", "none", "for", "all", "requests", "to", "register", "a", "function", "use", "the", "meth", "url_defaults", "decorator", "this", "data", "structure", "is", "internal", "it", "should", "not", "be", "modified", "directly", "and", "its", "format", "may", "change", "at", "any", "time", "self", "url_default_functions", "t", "dict", "ft", "apporblueprintkey", "t", "list", "ft", "urldefaultcallable", "defaultdict", "list"], "doc_len": 789}
{"doc_id": "src/flask/scaffold.py::Scaffold.__repr__", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "__repr__", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.name!r}>\"\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "__repr__", "self", "str", "return", "f", "type", "self", "__name__", "self", "name", "r"], "doc_len": 17}
{"doc_id": "src/flask/scaffold.py::Scaffold._check_setup_finished", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "_check_setup_finished", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def _check_setup_finished(self, f_name: str) -> None:\n        raise NotImplementedError\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "_check_setup_finished", "self", "f_name", "str", "none", "raise", "notimplementederror"], "doc_len": 13}
{"doc_id": "src/flask/scaffold.py::Scaffold.static_folder", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "static_folder", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def static_folder(self) -> t.Optional[str]:\n        \"\"\"The absolute path to the configured static folder. ``None``\n        if no static folder is set.\n        \"\"\"\n        if self._static_folder is not None:\n            return os.path.join(self.root_path, self._static_folder)\n        else:\n            return None\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "static_folder", "self", "t", "optional", "str", "the", "absolute", "path", "to", "the", "configured", "static", "folder", "none", "if", "no", "static", "folder", "is", "set", "if", "self", "_static_folder", "is", "not", "none", "return", "os", "path", "join", "self", "root_path", "self", "_static_folder", "else", "return", "none"], "doc_len": 43}
{"doc_id": "src/flask/scaffold.py::Scaffold.static_folder", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "static_folder", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def static_folder(self, value: t.Optional[t.Union[str, os.PathLike]]) -> None:\n        if value is not None:\n            value = os.fspath(value).rstrip(r\"\\/\")\n\n        self._static_folder = value\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "static_folder", "self", "value", "t", "optional", "t", "union", "str", "os", "pathlike", "none", "if", "value", "is", "not", "none", "value", "os", "fspath", "value", "rstrip", "r", "self", "_static_folder", "value"], "doc_len": 31}
{"doc_id": "src/flask/scaffold.py::Scaffold.has_static_folder", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "has_static_folder", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def has_static_folder(self) -> bool:\n        \"\"\"``True`` if :attr:`static_folder` is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        return self.static_folder is not None\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "has_static_folder", "self", "bool", "true", "if", "attr", "static_folder", "is", "set", "versionadded", "0", "5", "return", "self", "static_folder", "is", "not", "none"], "doc_len": 24}
{"doc_id": "src/flask/scaffold.py::Scaffold.static_url_path", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "static_url_path", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def static_url_path(self) -> t.Optional[str]:\n        \"\"\"The URL prefix that the static route will be accessible from.\n\n        If it was not configured during init, it is derived from\n        :attr:`static_folder`.\n        \"\"\"\n        if self._static_url_path is not None:\n            return self._static_url_path\n\n        if self.static_folder is not None:\n            basename = os.path.basename(self.static_folder)\n            return f\"/{basename}\".rstrip(\"/\")\n\n        return None\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "static_url_path", "self", "t", "optional", "str", "the", "url", "prefix", "that", "the", "static", "route", "will", "be", "accessible", "from", "if", "it", "was", "not", "configured", "during", "init", "it", "is", "derived", "from", "attr", "static_folder", "if", "self", "_static_url_path", "is", "not", "none", "return", "self", "_static_url_path", "if", "self", "static_folder", "is", "not", "none", "basename", "os", "path", "basename", "self", "static_folder", "return", "f", "basename", "rstrip", "return", "none"], "doc_len": 62}
{"doc_id": "src/flask/scaffold.py::Scaffold.static_url_path", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "static_url_path", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def static_url_path(self, value: t.Optional[str]) -> None:\n        if value is not None:\n            value = value.rstrip(\"/\")\n\n        self._static_url_path = value\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "static_url_path", "self", "value", "t", "optional", "str", "none", "if", "value", "is", "not", "none", "value", "value", "rstrip", "self", "_static_url_path", "value"], "doc_len": 24}
{"doc_id": "src/flask/scaffold.py::Scaffold.get_send_file_max_age", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "get_send_file_max_age", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def get_send_file_max_age(self, filename: t.Optional[str]) -> t.Optional[int]:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "get_send_file_max_age", "self", "filename", "t", "optional", "str", "t", "optional", "int", "used", "by", "func", "send_file", "to", "determine", "the", "max_age", "cache", "value", "for", "a", "given", "file", "path", "if", "it", "wasn", "t", "passed", "by", "default", "this", "returns", "data", "send_file_max_age_default", "from", "the", "configuration", "of", "data", "flask", "current_app", "this", "defaults", "to", "none", "which", "tells", "the", "browser", "to", "use", "conditional", "requests", "instead", "of", "a", "timed", "cache", "which", "is", "usually", "preferable", "versionchanged", "2", "0", "the", "default", "configuration", "is", "none", "instead", "of", "12", "hours", "versionadded", "0", "9", "value", "current_app", "config", "send_file_max_age_default", "if", "value", "is", "none", "return", "none", "if", "isinstance", "value", "timedelta", "return", "int", "value", "total_seconds", "return", "value"], "doc_len": 104}
{"doc_id": "src/flask/scaffold.py::Scaffold.send_static_file", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "send_static_file", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def send_static_file(self, filename: str) -> \"Response\":\n        \"\"\"The view function used to serve files from\n        :attr:`static_folder`. A route is automatically registered for\n        this view at :attr:`static_url_path` if :attr:`static_folder` is\n        set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if not self.has_static_folder:\n            raise RuntimeError(\"'static_folder' must be set to serve static_files.\")\n\n        # send_file only knows to call get_send_file_max_age on the app,\n        # call it here so it works for blueprints too.\n        max_age = self.get_send_file_max_age(filename)\n        return send_from_directory(\n            t.cast(str, self.static_folder), filename, max_age=max_age\n        )\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "send_static_file", "self", "filename", "str", "response", "the", "view", "function", "used", "to", "serve", "files", "from", "attr", "static_folder", "a", "route", "is", "automatically", "registered", "for", "this", "view", "at", "attr", "static_url_path", "if", "attr", "static_folder", "is", "set", "versionadded", "0", "5", "if", "not", "self", "has_static_folder", "raise", "runtimeerror", "static_folder", "must", "be", "set", "to", "serve", "static_files", "send_file", "only", "knows", "to", "call", "get_send_file_max_age", "on", "the", "app", "call", "it", "here", "so", "it", "works", "for", "blueprints", "too", "max_age", "self", "get_send_file_max_age", "filename", "return", "send_from_directory", "t", "cast", "str", "self", "static_folder", "filename", "max_age", "max_age"], "doc_len": 85}
{"doc_id": "src/flask/scaffold.py::Scaffold.jinja_loader", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "jinja_loader", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def jinja_loader(self) -> t.Optional[FileSystemLoader]:\n        \"\"\"The Jinja loader for this object's templates. By default this\n        is a class :class:`jinja2.loaders.FileSystemLoader` to\n        :attr:`template_folder` if it is set.\n\n        .. versionadded:: 0.5\n        \"\"\"\n        if self.template_folder is not None:\n            return FileSystemLoader(os.path.join(self.root_path, self.template_folder))\n        else:\n            return None\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "jinja_loader", "self", "t", "optional", "filesystemloader", "the", "jinja", "loader", "for", "this", "object", "s", "templates", "by", "default", "this", "is", "a", "class", "class", "jinja2", "loaders", "filesystemloader", "to", "attr", "template_folder", "if", "it", "is", "set", "versionadded", "0", "5", "if", "self", "template_folder", "is", "not", "none", "return", "filesystemloader", "os", "path", "join", "self", "root_path", "self", "template_folder", "else", "return", "none"], "doc_len": 57}
{"doc_id": "src/flask/scaffold.py::Scaffold.open_resource", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "open_resource", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def open_resource(self, resource: str, mode: str = \"rb\") -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for\n        reading.\n\n        For example, if the file ``schema.sql`` is next to the file\n        ``app.py`` where the ``Flask`` app is defined, it can be opened\n        with:\n\n        .. code-block:: python\n\n            with app.open_resource(\"schema.sql\") as f:\n                conn.executescript(f.read())\n\n        :param resource: Path to the resource relative to\n            :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is\n            supported, valid values are \"r\" (or \"rt\") and \"rb\".\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        return open(os.path.join(self.root_path, resource), mode)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "open_resource", "self", "resource", "str", "mode", "str", "rb", "t", "io", "t", "anystr", "open", "a", "resource", "file", "relative", "to", "attr", "root_path", "for", "reading", "for", "example", "if", "the", "file", "schema", "sql", "is", "next", "to", "the", "file", "app", "py", "where", "the", "flask", "app", "is", "defined", "it", "can", "be", "opened", "with", "code", "block", "python", "with", "app", "open_resource", "schema", "sql", "as", "f", "conn", "executescript", "f", "read", "param", "resource", "path", "to", "the", "resource", "relative", "to", "attr", "root_path", "param", "mode", "open", "the", "file", "in", "this", "mode", "only", "reading", "is", "supported", "valid", "values", "are", "r", "or", "rt", "and", "rb", "if", "mode", "not", "in", "r", "rt", "rb", "raise", "valueerror", "resources", "can", "only", "be", "opened", "for", "reading", "return", "open", "os", "path", "join", "self", "root_path", "resource", "mode"], "doc_len": 121}
{"doc_id": "src/flask/scaffold.py::Scaffold._method_route", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "_method_route", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def _method_route(\n        self,\n        method: str,\n        rule: str,\n        options: dict,\n    ) -> t.Callable[[T_route], T_route]:\n        if \"methods\" in options:\n            raise TypeError(\"Use the 'route' decorator to use the 'methods' argument.\")\n\n        return self.route(rule, methods=[method], **options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "_method_route", "self", "method", "str", "rule", "str", "options", "dict", "t", "callable", "t_route", "t_route", "if", "methods", "in", "options", "raise", "typeerror", "use", "the", "route", "decorator", "to", "use", "the", "methods", "argument", "return", "self", "route", "rule", "methods", "method", "options"], "doc_len": 40}
{"doc_id": "src/flask/scaffold.py::Scaffold.get", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "get", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def get(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"GET\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"GET\", rule, options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "get", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "shortcut", "for", "meth", "route", "with", "methods", "get", "versionadded", "2", "0", "return", "self", "_method_route", "get", "rule", "options"], "doc_len": 33}
{"doc_id": "src/flask/scaffold.py::Scaffold.post", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "post", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def post(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"POST\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"POST\", rule, options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "post", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "shortcut", "for", "meth", "route", "with", "methods", "post", "versionadded", "2", "0", "return", "self", "_method_route", "post", "rule", "options"], "doc_len": 33}
{"doc_id": "src/flask/scaffold.py::Scaffold.put", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "put", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def put(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PUT\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PUT\", rule, options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "put", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "shortcut", "for", "meth", "route", "with", "methods", "put", "versionadded", "2", "0", "return", "self", "_method_route", "put", "rule", "options"], "doc_len": 33}
{"doc_id": "src/flask/scaffold.py::Scaffold.delete", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "delete", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def delete(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"DELETE\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"DELETE\", rule, options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "delete", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "shortcut", "for", "meth", "route", "with", "methods", "delete", "versionadded", "2", "0", "return", "self", "_method_route", "delete", "rule", "options"], "doc_len": 33}
{"doc_id": "src/flask/scaffold.py::Scaffold.patch", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "patch", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def patch(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Shortcut for :meth:`route` with ``methods=[\"PATCH\"]``.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        return self._method_route(\"PATCH\", rule, options)\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "patch", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "shortcut", "for", "meth", "route", "with", "methods", "patch", "versionadded", "2", "0", "return", "self", "_method_route", "patch", "rule", "options"], "doc_len": 33}
{"doc_id": "src/flask/scaffold.py::Scaffold.route", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "route", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n        \"\"\"Decorate a view function to register it with the given URL\n        rule and options. Calls :meth:`add_url_rule`, which has more\n        details about the implementation.\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                return \"Hello, World!\"\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` and\n        ``OPTIONS`` are added automatically.\n\n        :param rule: The URL rule string.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n\n        def decorator(f: T_route) -> T_route:\n            endpoint = options.pop(\"endpoint\", None)\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "route", "self", "rule", "str", "options", "t", "any", "t", "callable", "t_route", "t_route", "decorate", "a", "view", "function", "to", "register", "it", "with", "the", "given", "url", "rule", "and", "options", "calls", "meth", "add_url_rule", "which", "has", "more", "details", "about", "the", "implementation", "code", "block", "python", "app", "route", "def", "index", "return", "hello", "world", "see", "ref", "url", "route", "registrations", "the", "endpoint", "name", "for", "the", "route", "defaults", "to", "the", "name", "of", "the", "view", "function", "if", "the", "endpoint", "parameter", "isn", "t", "passed", "the", "methods", "parameter", "defaults", "to", "get", "head", "and", "options", "are", "added", "automatically", "param", "rule", "the", "url", "rule", "string", "param", "options", "extra", "options", "passed", "to", "the", "class", "werkzeug", "routing", "rule", "object", "def", "decorator", "f", "t_route", "t_route", "endpoint", "options", "pop", "endpoint", "none", "self", "add_url_rule", "rule", "endpoint", "f", "options", "return", "f", "return", "decorator"], "doc_len": 127}
{"doc_id": "src/flask/scaffold.py::Scaffold.add_url_rule", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "add_url_rule", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: t.Optional[str] = None,\n        view_func: t.Optional[ft.RouteCallable] = None,\n        provide_automatic_options: t.Optional[bool] = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"Register a rule for routing incoming requests and building\n        URLs. The :meth:`route` decorator is a shortcut to call this\n        with the ``view_func`` argument. These are equivalent:\n\n        .. code-block:: python\n\n            @app.route(\"/\")\n            def index():\n                ...\n\n        .. code-block:: python\n\n            def index():\n                ...\n\n            app.add_url_rule(\"/\", view_func=index)\n\n        See :ref:`url-route-registrations`.\n\n        The endpoint name for the route defaults to the name of the view\n        function if the ``endpoint`` parameter isn't passed. An error\n        will be raised if a function has already been registered for the\n        endpoint.\n\n        The ``methods`` parameter defaults to ``[\"GET\"]``. ``HEAD`` is\n        always added automatically, and ``OPTIONS`` is added\n        automatically by default.\n\n        ``view_func`` does not necessarily need to be passed, but if the\n        rule should participate in routing an endpoint name must be\n        associated with a view function at some point with the\n        :meth:`endpoint` decorator.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/\", endpoint=\"index\")\n\n            @app.endpoint(\"index\")\n            def index():\n                ...\n\n        If ``view_func`` has a ``required_methods`` attribute, those\n        methods are added to the passed and automatic methods. If it\n        has a ``provide_automatic_methods`` attribute, it is used as the\n        default if the parameter is not passed.\n\n        :param rule: The URL rule string.\n        :param endpoint: The endpoint name to associate with the rule\n            and view function. Used when routing and building URLs.\n            Defaults to ``view_func.__name__``.\n        :param view_func: The view function to associate with the\n            endpoint name.\n        :param provide_automatic_options: Add the ``OPTIONS`` method and\n            respond to ``OPTIONS`` requests automatically.\n        :param options: Extra options passed to the\n            :class:`~werkzeug.routing.Rule` object.\n        \"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "add_url_rule", "self", "rule", "str", "endpoint", "t", "optional", "str", "none", "view_func", "t", "optional", "ft", "routecallable", "none", "provide_automatic_options", "t", "optional", "bool", "none", "options", "t", "any", "none", "register", "a", "rule", "for", "routing", "incoming", "requests", "and", "building", "urls", "the", "meth", "route", "decorator", "is", "a", "shortcut", "to", "call", "this", "with", "the", "view_func", "argument", "these", "are", "equivalent", "code", "block", "python", "app", "route", "def", "index", "code", "block", "python", "def", "index", "app", "add_url_rule", "view_func", "index", "see", "ref", "url", "route", "registrations", "the", "endpoint", "name", "for", "the", "route", "defaults", "to", "the", "name", "of", "the", "view", "function", "if", "the", "endpoint", "parameter", "isn", "t", "passed", "an", "error", "will", "be", "raised", "if", "a", "function", "has", "already", "been", "registered", "for", "the", "endpoint", "the", "methods", "parameter", "defaults", "to", "get", "head", "is", "always", "added", "automatically", "and", "options", "is", "added", "automatically", "by", "default", "view_func", "does", "not", "necessarily", "need", "to", "be", "passed", "but", "if", "the", "rule", "should", "participate", "in", "routing", "an", "endpoint", "name", "must", "be", "associated", "with", "a", "view", "function", "at", "some", "point", "with", "the", "meth", "endpoint", "decorator", "code", "block", "python", "app", "add_url_rule", "endpoint", "index", "app", "endpoint", "index", "def", "index", "if", "view_func", "has", "a", "required_methods", "attribute", "those", "methods", "are", "added", "to", "the", "passed", "and", "automatic", "methods", "if", "it", "has", "a", "provide_automatic_methods", "attribute", "it", "is", "used", "as", "the", "default", "if", "the", "parameter", "is", "not", "passed", "param", "rule", "the", "url", "rule", "string", "param", "endpoint", "the", "endpoint", "name", "to", "associate", "with", "the", "rule", "and", "view", "function", "used", "when", "routing", "and", "building", "urls", "defaults", "to", "view_func", "__name__", "param", "view_func", "the", "view", "function", "to", "associate", "with", "the", "endpoint", "name", "param", "provide_automatic_options", "add", "the", "options", "method", "and", "respond", "to", "options", "requests", "automatically", "param", "options", "extra", "options", "passed", "to", "the", "class", "werkzeug", "routing", "rule", "object", "raise", "notimplementederror"], "doc_len": 278}
{"doc_id": "src/flask/scaffold.py::Scaffold.endpoint", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "endpoint", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def endpoint(self, endpoint: str) -> t.Callable[[F], F]:\n        \"\"\"Decorate a view function to register it for the given\n        endpoint. Used if a rule is added without a ``view_func`` with\n        :meth:`add_url_rule`.\n\n        .. code-block:: python\n\n            app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n            @app.endpoint(\"example\")\n            def example():\n                ...\n\n        :param endpoint: The endpoint name to associate with the view\n            function.\n        \"\"\"\n\n        def decorator(f: F) -> F:\n            self.view_functions[endpoint] = f\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "endpoint", "self", "endpoint", "str", "t", "callable", "f", "f", "decorate", "a", "view", "function", "to", "register", "it", "for", "the", "given", "endpoint", "used", "if", "a", "rule", "is", "added", "without", "a", "view_func", "with", "meth", "add_url_rule", "code", "block", "python", "app", "add_url_rule", "ex", "endpoint", "example", "app", "endpoint", "example", "def", "example", "param", "endpoint", "the", "endpoint", "name", "to", "associate", "with", "the", "view", "function", "def", "decorator", "f", "f", "f", "self", "view_functions", "endpoint", "f", "return", "f", "return", "decorator"], "doc_len": 74}
{"doc_id": "src/flask/scaffold.py::Scaffold.before_request", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "before_request", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def before_request(self, f: T_before_request) -> T_before_request:\n        \"\"\"Register a function to run before each request.\n\n        For example, this can be used to open a database connection, or\n        to load the logged in user from the session.\n\n        .. code-block:: python\n\n            @app.before_request\n            def load_user():\n                if \"user_id\" in session:\n                    g.user = db.session.get(session[\"user_id\"])\n\n        The function will be called without any arguments. If it returns\n        a non-``None`` value, the value is handled as if it was the\n        return value from the view, and further request handling is\n        stopped.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes before every request. When used on a blueprint, this executes before\n        every request that the blueprint handles. To register with a blueprint and\n        execute before every request, use :meth:`.Blueprint.before_app_request`.\n        \"\"\"\n        self.before_request_funcs.setdefault(None, []).append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "before_request", "self", "f", "t_before_request", "t_before_request", "register", "a", "function", "to", "run", "before", "each", "request", "for", "example", "this", "can", "be", "used", "to", "open", "a", "database", "connection", "or", "to", "load", "the", "logged", "in", "user", "from", "the", "session", "code", "block", "python", "app", "before_request", "def", "load_user", "if", "user_id", "in", "session", "g", "user", "db", "session", "get", "session", "user_id", "the", "function", "will", "be", "called", "without", "any", "arguments", "if", "it", "returns", "a", "non", "none", "value", "the", "value", "is", "handled", "as", "if", "it", "was", "the", "return", "value", "from", "the", "view", "and", "further", "request", "handling", "is", "stopped", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "executes", "before", "every", "request", "when", "used", "on", "a", "blueprint", "this", "executes", "before", "every", "request", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "execute", "before", "every", "request", "use", "meth", "blueprint", "before_app_request", "self", "before_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 148}
{"doc_id": "src/flask/scaffold.py::Scaffold.after_request", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "after_request", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def after_request(self, f: T_after_request) -> T_after_request:\n        \"\"\"Register a function to run after each request to this object.\n\n        The function is called with the response object, and must return\n        a response object. This allows the functions to modify or\n        replace the response before it is sent.\n\n        If a function raises an exception, any remaining\n        ``after_request`` functions will not be called. Therefore, this\n        should not be used for actions that must execute, such as to\n        close resources. Use :meth:`teardown_request` for that.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.after_app_request`.\n        \"\"\"\n        self.after_request_funcs.setdefault(None, []).append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "after_request", "self", "f", "t_after_request", "t_after_request", "register", "a", "function", "to", "run", "after", "each", "request", "to", "this", "object", "the", "function", "is", "called", "with", "the", "response", "object", "and", "must", "return", "a", "response", "object", "this", "allows", "the", "functions", "to", "modify", "or", "replace", "the", "response", "before", "it", "is", "sent", "if", "a", "function", "raises", "an", "exception", "any", "remaining", "after_request", "functions", "will", "not", "be", "called", "therefore", "this", "should", "not", "be", "used", "for", "actions", "that", "must", "execute", "such", "as", "to", "close", "resources", "use", "meth", "teardown_request", "for", "that", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "executes", "after", "every", "request", "when", "used", "on", "a", "blueprint", "this", "executes", "after", "every", "request", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "execute", "after", "every", "request", "use", "meth", "blueprint", "after_app_request", "self", "after_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 140}
{"doc_id": "src/flask/scaffold.py::Scaffold.teardown_request", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "teardown_request", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def teardown_request(self, f: T_teardown) -> T_teardown:\n        \"\"\"Register a function to be called when the request context is\n        popped. Typically this happens at the end of each request, but\n        contexts may be pushed manually as well during testing.\n\n        .. code-block:: python\n\n            with app.test_request_context():\n                ...\n\n        When the ``with`` block exits (or ``ctx.pop()`` is called), the\n        teardown functions are called just before the request context is\n        made inactive.\n\n        When a teardown function was called because of an unhandled\n        exception it will be passed an error object. If an\n        :meth:`errorhandler` is registered, it will handle the exception\n        and the teardown will not receive it.\n\n        Teardown functions must avoid raising exceptions. If they\n        execute code that might fail they must surround that code with a\n        ``try``/``except`` block and log any errors.\n\n        The return values of teardown functions are ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        executes after every request. When used on a blueprint, this executes after\n        every request that the blueprint handles. To register with a blueprint and\n        execute after every request, use :meth:`.Blueprint.teardown_app_request`.\n        \"\"\"\n        self.teardown_request_funcs.setdefault(None, []).append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "teardown_request", "self", "f", "t_teardown", "t_teardown", "register", "a", "function", "to", "be", "called", "when", "the", "request", "context", "is", "popped", "typically", "this", "happens", "at", "the", "end", "of", "each", "request", "but", "contexts", "may", "be", "pushed", "manually", "as", "well", "during", "testing", "code", "block", "python", "with", "app", "test_request_context", "when", "the", "with", "block", "exits", "or", "ctx", "pop", "is", "called", "the", "teardown", "functions", "are", "called", "just", "before", "the", "request", "context", "is", "made", "inactive", "when", "a", "teardown", "function", "was", "called", "because", "of", "an", "unhandled", "exception", "it", "will", "be", "passed", "an", "error", "object", "if", "an", "meth", "errorhandler", "is", "registered", "it", "will", "handle", "the", "exception", "and", "the", "teardown", "will", "not", "receive", "it", "teardown", "functions", "must", "avoid", "raising", "exceptions", "if", "they", "execute", "code", "that", "might", "fail", "they", "must", "surround", "that", "code", "with", "a", "try", "except", "block", "and", "log", "any", "errors", "the", "return", "values", "of", "teardown", "functions", "are", "ignored", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "executes", "after", "every", "request", "when", "used", "on", "a", "blueprint", "this", "executes", "after", "every", "request", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "execute", "after", "every", "request", "use", "meth", "blueprint", "teardown_app_request", "self", "teardown_request_funcs", "setdefault", "none", "append", "f", "return", "f"], "doc_len": 197}
{"doc_id": "src/flask/scaffold.py::Scaffold.context_processor", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "context_processor", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def context_processor(\n        self,\n        f: T_template_context_processor,\n    ) -> T_template_context_processor:\n        \"\"\"Registers a template context processor function. These functions run before\n        rendering a template. The keys of the returned dict are added as variables\n        available in the template.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every rendered template. When used on a blueprint, this is called\n        for templates rendered from the blueprint's views. To register with a blueprint\n        and affect every template, use :meth:`.Blueprint.app_context_processor`.\n        \"\"\"\n        self.template_context_processors[None].append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "context_processor", "self", "f", "t_template_context_processor", "t_template_context_processor", "registers", "a", "template", "context", "processor", "function", "these", "functions", "run", "before", "rendering", "a", "template", "the", "keys", "of", "the", "returned", "dict", "are", "added", "as", "variables", "available", "in", "the", "template", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "is", "called", "for", "every", "rendered", "template", "when", "used", "on", "a", "blueprint", "this", "is", "called", "for", "templates", "rendered", "from", "the", "blueprint", "s", "views", "to", "register", "with", "a", "blueprint", "and", "affect", "every", "template", "use", "meth", "blueprint", "app_context_processor", "self", "template_context_processors", "none", "append", "f", "return", "f"], "doc_len": 95}
{"doc_id": "src/flask/scaffold.py::Scaffold.url_value_preprocessor", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "url_value_preprocessor", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def url_value_preprocessor(\n        self,\n        f: T_url_value_preprocessor,\n    ) -> T_url_value_preprocessor:\n        \"\"\"Register a URL value preprocessor function for all view\n        functions in the application. These functions will be called before the\n        :meth:`before_request` functions.\n\n        The function can modify the values captured from the matched url before\n        they are passed to the view. For example, this can be used to pop a\n        common language code value and place it in ``g`` rather than pass it to\n        every view.\n\n        The function is passed the endpoint name and values dict. The return\n        value is ignored.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_value_preprocessor`.\n        \"\"\"\n        self.url_value_preprocessors[None].append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "url_value_preprocessor", "self", "f", "t_url_value_preprocessor", "t_url_value_preprocessor", "register", "a", "url", "value", "preprocessor", "function", "for", "all", "view", "functions", "in", "the", "application", "these", "functions", "will", "be", "called", "before", "the", "meth", "before_request", "functions", "the", "function", "can", "modify", "the", "values", "captured", "from", "the", "matched", "url", "before", "they", "are", "passed", "to", "the", "view", "for", "example", "this", "can", "be", "used", "to", "pop", "a", "common", "language", "code", "value", "and", "place", "it", "in", "g", "rather", "than", "pass", "it", "to", "every", "view", "the", "function", "is", "passed", "the", "endpoint", "name", "and", "values", "dict", "the", "return", "value", "is", "ignored", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "is", "called", "for", "every", "request", "when", "used", "on", "a", "blueprint", "this", "is", "called", "for", "requests", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "affect", "every", "request", "use", "meth", "blueprint", "app_url_value_preprocessor", "self", "url_value_preprocessors", "none", "append", "f", "return", "f"], "doc_len": 146}
{"doc_id": "src/flask/scaffold.py::Scaffold.url_defaults", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "url_defaults", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def url_defaults(self, f: T_url_defaults) -> T_url_defaults:\n        \"\"\"Callback function for URL defaults for all view functions of the\n        application.  It's called with the endpoint and values and should\n        update the values passed in place.\n\n        This is available on both app and blueprint objects. When used on an app, this\n        is called for every request. When used on a blueprint, this is called for\n        requests that the blueprint handles. To register with a blueprint and affect\n        every request, use :meth:`.Blueprint.app_url_defaults`.\n        \"\"\"\n        self.url_default_functions[None].append(f)\n        return f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "url_defaults", "self", "f", "t_url_defaults", "t_url_defaults", "callback", "function", "for", "url", "defaults", "for", "all", "view", "functions", "of", "the", "application", "it", "s", "called", "with", "the", "endpoint", "and", "values", "and", "should", "update", "the", "values", "passed", "in", "place", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "is", "called", "for", "every", "request", "when", "used", "on", "a", "blueprint", "this", "is", "called", "for", "requests", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "affect", "every", "request", "use", "meth", "blueprint", "app_url_defaults", "self", "url_default_functions", "none", "append", "f", "return", "f"], "doc_len": 93}
{"doc_id": "src/flask/scaffold.py::Scaffold.errorhandler", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "errorhandler", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def errorhandler(\n        self, code_or_exception: t.Union[t.Type[Exception], int]\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n        \"\"\"Register a function to handle errors by code or exception class.\n\n        A decorator that is used to register a function given an\n        error code.  Example::\n\n            @app.errorhandler(404)\n            def page_not_found(error):\n                return 'This page does not exist', 404\n\n        You can also register handlers for arbitrary exceptions::\n\n            @app.errorhandler(DatabaseError)\n            def special_exception_handler(error):\n                return 'Database connection failed', 500\n\n        This is available on both app and blueprint objects. When used on an app, this\n        can handle errors from every request. When used on a blueprint, this can handle\n        errors from requests that the blueprint handles. To register with a blueprint\n        and affect every request, use :meth:`.Blueprint.app_errorhandler`.\n\n        .. versionadded:: 0.7\n            Use :meth:`register_error_handler` instead of modifying\n            :attr:`error_handler_spec` directly, for application wide error\n            handlers.\n\n        .. versionadded:: 0.7\n           One can now additionally also register custom exception types\n           that do not necessarily have to be a subclass of the\n           :class:`~werkzeug.exceptions.HTTPException` class.\n\n        :param code_or_exception: the code as integer for the handler, or\n                                  an arbitrary exception\n        \"\"\"\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            self.register_error_handler(code_or_exception, f)\n            return f\n\n        return decorator\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "errorhandler", "self", "code_or_exception", "t", "union", "t", "type", "exception", "int", "t", "callable", "t_error_handler", "t_error_handler", "register", "a", "function", "to", "handle", "errors", "by", "code", "or", "exception", "class", "a", "decorator", "that", "is", "used", "to", "register", "a", "function", "given", "an", "error", "code", "example", "app", "errorhandler", "404", "def", "page_not_found", "error", "return", "this", "page", "does", "not", "exist", "404", "you", "can", "also", "register", "handlers", "for", "arbitrary", "exceptions", "app", "errorhandler", "databaseerror", "def", "special_exception_handler", "error", "return", "database", "connection", "failed", "500", "this", "is", "available", "on", "both", "app", "and", "blueprint", "objects", "when", "used", "on", "an", "app", "this", "can", "handle", "errors", "from", "every", "request", "when", "used", "on", "a", "blueprint", "this", "can", "handle", "errors", "from", "requests", "that", "the", "blueprint", "handles", "to", "register", "with", "a", "blueprint", "and", "affect", "every", "request", "use", "meth", "blueprint", "app_errorhandler", "versionadded", "0", "7", "use", "meth", "register_error_handler", "instead", "of", "modifying", "attr", "error_handler_spec", "directly", "for", "application", "wide", "error", "handlers", "versionadded", "0", "7", "one", "can", "now", "additionally", "also", "register", "custom", "exception", "types", "that", "do", "not", "necessarily", "have", "to", "be", "a", "subclass", "of", "the", "class", "werkzeug", "exceptions", "httpexception", "class", "param", "code_or_exception", "the", "code", "as", "integer", "for", "the", "handler", "or", "an", "arbitrary", "exception", "def", "decorator", "f", "t_error_handler", "t_error_handler", "self", "register_error_handler", "code_or_exception", "f", "return", "f", "return", "decorator"], "doc_len": 196}
{"doc_id": "src/flask/scaffold.py::Scaffold.register_error_handler", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "register_error_handler", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def register_error_handler(\n        self,\n        code_or_exception: t.Union[t.Type[Exception], int],\n        f: ft.ErrorHandlerCallable,\n    ) -> None:\n        \"\"\"Alternative error attach function to the :meth:`errorhandler`\n        decorator that is more straightforward to use for non decorator\n        usage.\n\n        .. versionadded:: 0.7\n        \"\"\"\n        exc_class, code = self._get_exc_class_and_code(code_or_exception)\n        self.error_handler_spec[None][code][exc_class] = f\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "register_error_handler", "self", "code_or_exception", "t", "union", "t", "type", "exception", "int", "f", "ft", "errorhandlercallable", "none", "alternative", "error", "attach", "function", "to", "the", "meth", "errorhandler", "decorator", "that", "is", "more", "straightforward", "to", "use", "for", "non", "decorator", "usage", "versionadded", "0", "7", "exc_class", "code", "self", "_get_exc_class_and_code", "code_or_exception", "self", "error_handler_spec", "none", "code", "exc_class", "f"], "doc_len": 52}
{"doc_id": "src/flask/scaffold.py::Scaffold._get_exc_class_and_code", "file_path": "src/flask/scaffold.py", "class_name": "Scaffold", "func_name": "_get_exc_class_and_code", "text": "文件路径: src/flask/scaffold.py, 类名: Scaffold\n    def _get_exc_class_and_code(\n        exc_class_or_code: t.Union[t.Type[Exception], int]\n    ) -> t.Tuple[t.Type[Exception], t.Optional[int]]:\n        \"\"\"Get the exception class being handled. For HTTP status codes\n        or ``HTTPException`` subclasses, return both the exception and\n        status code.\n\n        :param exc_class_or_code: Any exception class, or an HTTP status\n            code as an integer.\n        \"\"\"\n        exc_class: t.Type[Exception]\n\n        if isinstance(exc_class_or_code, int):\n            try:\n                exc_class = default_exceptions[exc_class_or_code]\n            except KeyError:\n                raise ValueError(\n                    f\"'{exc_class_or_code}' is not a recognized HTTP\"\n                    \" error code. Use a subclass of HTTPException with\"\n                    \" that code instead.\"\n                ) from None\n        else:\n            exc_class = exc_class_or_code\n\n        if isinstance(exc_class, Exception):\n            raise TypeError(\n                f\"{exc_class!r} is an instance, not a class. Handlers\"\n                \" can only be registered for Exception classes or HTTP\"\n                \" error codes.\"\n            )\n\n        if not issubclass(exc_class, Exception):\n            raise ValueError(\n                f\"'{exc_class.__name__}' is not a subclass of Exception.\"\n                \" Handlers can only be registered for Exception classes\"\n                \" or HTTP error codes.\"\n            )\n\n        if issubclass(exc_class, HTTPException):\n            return exc_class, exc_class.code\n        else:\n            return exc_class, None\n", "tokens": ["src", "flask", "scaffold", "py", "scaffold", "def", "_get_exc_class_and_code", "exc_class_or_code", "t", "union", "t", "type", "exception", "int", "t", "tuple", "t", "type", "exception", "t", "optional", "int", "get", "the", "exception", "class", "being", "handled", "for", "http", "status", "codes", "or", "httpexception", "subclasses", "return", "both", "the", "exception", "and", "status", "code", "param", "exc_class_or_code", "any", "exception", "class", "or", "an", "http", "status", "code", "as", "an", "integer", "exc_class", "t", "type", "exception", "if", "isinstance", "exc_class_or_code", "int", "try", "exc_class", "default_exceptions", "exc_class_or_code", "except", "keyerror", "raise", "valueerror", "f", "exc_class_or_code", "is", "not", "a", "recognized", "http", "error", "code", "use", "a", "subclass", "of", "httpexception", "with", "that", "code", "instead", "from", "none", "else", "exc_class", "exc_class_or_code", "if", "isinstance", "exc_class", "exception", "raise", "typeerror", "f", "exc_class", "r", "is", "an", "instance", "not", "a", "class", "handlers", "can", "only", "be", "registered", "for", "exception", "classes", "or", "http", "error", "codes", "if", "not", "issubclass", "exc_class", "exception", "raise", "valueerror", "f", "exc_class", "__name__", "is", "not", "a", "subclass", "of", "exception", "handlers", "can", "only", "be", "registered", "for", "exception", "classes", "or", "http", "error", "codes", "if", "issubclass", "exc_class", "httpexception", "return", "exc_class", "exc_class", "code", "else", "return", "exc_class", "none"], "doc_len": 161}
{"doc_id": "src/flask/scaffold.py::_endpoint_from_view_func", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "_endpoint_from_view_func", "text": "文件路径: src/flask/scaffold.py\ndef _endpoint_from_view_func(view_func: t.Callable) -> str:\n    \"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"\n    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__\n", "tokens": ["src", "flask", "scaffold", "py", "def", "_endpoint_from_view_func", "view_func", "t", "callable", "str", "internal", "helper", "that", "returns", "the", "default", "endpoint", "for", "a", "given", "function", "this", "always", "is", "the", "function", "name", "assert", "view_func", "is", "not", "none", "expected", "view", "func", "if", "endpoint", "is", "not", "provided", "return", "view_func", "__name__"], "doc_len": 43}
{"doc_id": "src/flask/scaffold.py::_matching_loader_thinks_module_is_package", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "_matching_loader_thinks_module_is_package", "text": "文件路径: src/flask/scaffold.py\ndef _matching_loader_thinks_module_is_package(loader, mod_name):\n    \"\"\"Attempt to figure out if the given name is a package or a module.\n\n    :param: loader: The loader that handled the name.\n    :param mod_name: The name of the package or module.\n    \"\"\"\n    # Use loader.is_package if it's available.\n    if hasattr(loader, \"is_package\"):\n        return loader.is_package(mod_name)\n\n    cls = type(loader)\n\n    # NamespaceLoader doesn't implement is_package, but all names it\n    # loads must be packages.\n    if cls.__module__ == \"_frozen_importlib\" and cls.__name__ == \"NamespaceLoader\":\n        return True\n\n    # Otherwise we need to fail with an error that explains what went\n    # wrong.\n    raise AttributeError(\n        f\"'{cls.__name__}.is_package()' must be implemented for PEP 302\"\n        f\" import hooks.\"\n    )\n", "tokens": ["src", "flask", "scaffold", "py", "def", "_matching_loader_thinks_module_is_package", "loader", "mod_name", "attempt", "to", "figure", "out", "if", "the", "given", "name", "is", "a", "package", "or", "a", "module", "param", "loader", "the", "loader", "that", "handled", "the", "name", "param", "mod_name", "the", "name", "of", "the", "package", "or", "module", "use", "loader", "is_package", "if", "it", "s", "available", "if", "hasattr", "loader", "is_package", "return", "loader", "is_package", "mod_name", "cls", "type", "loader", "namespaceloader", "doesn", "t", "implement", "is_package", "but", "all", "names", "it", "loads", "must", "be", "packages", "if", "cls", "__module__", "_frozen_importlib", "and", "cls", "__name__", "namespaceloader", "return", "true", "otherwise", "we", "need", "to", "fail", "with", "an", "error", "that", "explains", "what", "went", "wrong", "raise", "attributeerror", "f", "cls", "__name__", "is_package", "must", "be", "implemented", "for", "pep", "302", "f", "import", "hooks"], "doc_len": 108}
{"doc_id": "src/flask/scaffold.py::_path_is_relative_to", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "_path_is_relative_to", "text": "文件路径: src/flask/scaffold.py\ndef _path_is_relative_to(path: pathlib.PurePath, base: str) -> bool:\n    # Path.is_relative_to doesn't exist until Python 3.9\n    try:\n        path.relative_to(base)\n        return True\n    except ValueError:\n        return False\n", "tokens": ["src", "flask", "scaffold", "py", "def", "_path_is_relative_to", "path", "pathlib", "purepath", "base", "str", "bool", "path", "is_relative_to", "doesn", "t", "exist", "until", "python", "3", "9", "try", "path", "relative_to", "base", "return", "true", "except", "valueerror", "return", "false"], "doc_len": 31}
{"doc_id": "src/flask/scaffold.py::_find_package_path", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "_find_package_path", "text": "文件路径: src/flask/scaffold.py\ndef _find_package_path(import_name):\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    # ImportError: the machinery told us it does not exist\n    # ValueError:\n    #    - the module name was invalid\n    #    - the module name is __main__\n    #    - *we* raised `ValueError` due to `root_spec` being `None`\n    except (ImportError, ValueError):\n        pass  # handled below\n    else:\n        # namespace package\n        if root_spec.origin in {\"namespace\", None}:\n            package_spec = importlib.util.find_spec(import_name)\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_locations = (\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if _path_is_relative_to(package_path, location)\n                )\n            else:\n                # Pick the first path.\n                search_locations = iter(root_spec.submodule_search_locations)\n            return os.path.dirname(next(search_locations))\n        # a package (with __init__.py)\n        elif root_spec.submodule_search_locations:\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n        # just a normal module\n        else:\n            return os.path.dirname(root_spec.origin)\n\n    # we were unable to find the `package_path` using PEP 451 loaders\n    loader = pkgutil.get_loader(root_mod_name)\n\n    if loader is None or root_mod_name == \"__main__\":\n        # import name is not found, or interactive/main module\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filename = loader.get_filename(root_mod_name)\n    elif hasattr(loader, \"archive\"):\n        # zipimporter's loader.archive points to the .egg or .zip file.\n        filename = loader.archive\n    else:\n        # At least one loader is missing both get_filename and archive:\n        # Google App Engine's HardenedModulesHook, use __file__.\n        filename = importlib.import_module(root_mod_name).__file__\n\n    package_path = os.path.abspath(os.path.dirname(filename))\n\n    # If the imported name is a package, filename is currently pointing\n    # to the root of the package, need to get the current directory.\n    if _matching_loader_thinks_module_is_package(loader, root_mod_name):\n        package_path = os.path.dirname(package_path)\n\n    return package_path\n", "tokens": ["src", "flask", "scaffold", "py", "def", "_find_package_path", "import_name", "find", "the", "path", "that", "contains", "the", "package", "or", "module", "root_mod_name", "_", "_", "import_name", "partition", "try", "root_spec", "importlib", "util", "find_spec", "root_mod_name", "if", "root_spec", "is", "none", "raise", "valueerror", "not", "found", "importerror", "the", "machinery", "told", "us", "it", "does", "not", "exist", "valueerror", "the", "module", "name", "was", "invalid", "the", "module", "name", "is", "__main__", "we", "raised", "valueerror", "due", "to", "root_spec", "being", "none", "except", "importerror", "valueerror", "pass", "handled", "below", "else", "namespace", "package", "if", "root_spec", "origin", "in", "namespace", "none", "package_spec", "importlib", "util", "find_spec", "import_name", "if", "package_spec", "is", "not", "none", "and", "package_spec", "submodule_search_locations", "pick", "the", "path", "in", "the", "namespace", "that", "contains", "the", "submodule", "package_path", "pathlib", "path", "os", "path", "commonpath", "package_spec", "submodule_search_locations", "search_locations", "location", "for", "location", "in", "root_spec", "submodule_search_locations", "if", "_path_is_relative_to", "package_path", "location", "else", "pick", "the", "first", "path", "search_locations", "iter", "root_spec", "submodule_search_locations", "return", "os", "path", "dirname", "next", "search_locations", "a", "package", "with", "__init__", "py", "elif", "root_spec", "submodule_search_locations", "return", "os", "path", "dirname", "os", "path", "dirname", "root_spec", "origin", "just", "a", "normal", "module", "else", "return", "os", "path", "dirname", "root_spec", "origin", "we", "were", "unable", "to", "find", "the", "package_path", "using", "pep", "451", "loaders", "loader", "pkgutil", "get_loader", "root_mod_name", "if", "loader", "is", "none", "or", "root_mod_name", "__main__", "import", "name", "is", "not", "found", "or", "interactive", "main", "module", "return", "os", "getcwd", "if", "hasattr", "loader", "get_filename", "filename", "loader", "get_filename", "root_mod_name", "elif", "hasattr", "loader", "archive", "zipimporter", "s", "loader", "archive", "points", "to", "the", "egg", "or", "zip", "file", "filename", "loader", "archive", "else", "at", "least", "one", "loader", "is", "missing", "both", "get_filename", "and", "archive", "google", "app", "engine", "s", "hardenedmoduleshook", "use", "__file__", "filename", "importlib", "import_module", "root_mod_name", "__file__", "package_path", "os", "path", "abspath", "os", "path", "dirname", "filename", "if", "the", "imported", "name", "is", "a", "package", "filename", "is", "currently", "pointing", "to", "the", "root", "of", "the", "package", "need", "to", "get", "the", "current", "directory", "if", "_matching_loader_thinks_module_is_package", "loader", "root_mod_name", "package_path", "os", "path", "dirname", "package_path", "return", "package_path"], "doc_len": 288}
{"doc_id": "src/flask/scaffold.py::find_package", "file_path": "src/flask/scaffold.py", "class_name": null, "func_name": "find_package", "text": "文件路径: src/flask/scaffold.py\ndef find_package(import_name: str):\n    \"\"\"Find the prefix that a package is installed under, and the path\n    that it would be imported from.\n\n    The prefix is the directory containing the standard directory\n    hierarchy (lib, bin, etc.). If the package is not installed to the\n    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n    ``None`` is returned.\n\n    The path is the entry in :attr:`sys.path` that contains the package\n    for import. If the package is not installed, it's assumed that the\n    package was imported from the current working directory.\n    \"\"\"\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if _path_is_relative_to(pathlib.PurePath(package_path), py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == \"lib\":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == \"lib\":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path\n", "tokens": ["src", "flask", "scaffold", "py", "def", "find_package", "import_name", "str", "find", "the", "prefix", "that", "a", "package", "is", "installed", "under", "and", "the", "path", "that", "it", "would", "be", "imported", "from", "the", "prefix", "is", "the", "directory", "containing", "the", "standard", "directory", "hierarchy", "lib", "bin", "etc", "if", "the", "package", "is", "not", "installed", "to", "the", "system", "attr", "sys", "prefix", "or", "a", "virtualenv", "site", "packages", "none", "is", "returned", "the", "path", "is", "the", "entry", "in", "attr", "sys", "path", "that", "contains", "the", "package", "for", "import", "if", "the", "package", "is", "not", "installed", "it", "s", "assumed", "that", "the", "package", "was", "imported", "from", "the", "current", "working", "directory", "package_path", "_find_package_path", "import_name", "py_prefix", "os", "path", "abspath", "sys", "prefix", "installed", "to", "the", "system", "if", "_path_is_relative_to", "pathlib", "purepath", "package_path", "py_prefix", "return", "py_prefix", "package_path", "site_parent", "site_folder", "os", "path", "split", "package_path", "installed", "to", "a", "virtualenv", "if", "site_folder", "lower", "site", "packages", "parent", "folder", "os", "path", "split", "site_parent", "windows", "prefix", "lib", "site", "packages", "if", "folder", "lower", "lib", "return", "parent", "package_path", "unix", "prefix", "lib", "pythonx", "y", "site", "packages", "if", "os", "path", "basename", "parent", "lower", "lib", "return", "os", "path", "dirname", "parent", "package_path", "something", "else", "prefix", "site", "packages", "return", "site_parent", "package_path", "not", "installed", "return", "none", "package_path"], "doc_len": 181}
{"doc_id": "src/flask/sessions.py::SessionMixin.permanent", "file_path": "src/flask/sessions.py", "class_name": "SessionMixin", "func_name": "permanent", "text": "文件路径: src/flask/sessions.py, 类名: SessionMixin\n    def permanent(self) -> bool:\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)\n", "tokens": ["src", "flask", "sessions", "py", "sessionmixin", "def", "permanent", "self", "bool", "this", "reflects", "the", "_permanent", "key", "in", "the", "dict", "return", "self", "get", "_permanent", "false"], "doc_len": 22}
{"doc_id": "src/flask/sessions.py::SessionMixin.permanent", "file_path": "src/flask/sessions.py", "class_name": "SessionMixin", "func_name": "permanent", "text": "文件路径: src/flask/sessions.py, 类名: SessionMixin\n    def permanent(self, value: bool) -> None:\n        self[\"_permanent\"] = bool(value)\n", "tokens": ["src", "flask", "sessions", "py", "sessionmixin", "def", "permanent", "self", "value", "bool", "none", "self", "_permanent", "bool", "value"], "doc_len": 15}
{"doc_id": "src/flask/sessions.py::SecureCookieSession.__init__", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSession", "func_name": "__init__", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSession\n    def __init__(self, initial: t.Any = None) -> None:\n        def on_update(self) -> None:\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesession", "def", "__init__", "self", "initial", "t", "any", "none", "none", "def", "on_update", "self", "none", "self", "modified", "true", "self", "accessed", "true", "super", "__init__", "initial", "on_update"], "doc_len": 27}
{"doc_id": "src/flask/sessions.py::SecureCookieSession.__getitem__", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSession", "func_name": "__getitem__", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSession\n    def __getitem__(self, key: str) -> t.Any:\n        self.accessed = True\n        return super().__getitem__(key)\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesession", "def", "__getitem__", "self", "key", "str", "t", "any", "self", "accessed", "true", "return", "super", "__getitem__", "key"], "doc_len": 19}
{"doc_id": "src/flask/sessions.py::SecureCookieSession.get", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSession", "func_name": "get", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSession\n    def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesession", "def", "get", "self", "key", "str", "default", "t", "any", "none", "t", "any", "self", "accessed", "true", "return", "super", "get", "key", "default"], "doc_len": 24}
{"doc_id": "src/flask/sessions.py::SecureCookieSession.setdefault", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSession", "func_name": "setdefault", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSession\n    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesession", "def", "setdefault", "self", "key", "str", "default", "t", "any", "none", "t", "any", "self", "accessed", "true", "return", "super", "setdefault", "key", "default"], "doc_len": 24}
{"doc_id": "src/flask/sessions.py::NullSession._fail", "file_path": "src/flask/sessions.py", "class_name": "NullSession", "func_name": "_fail", "text": "文件路径: src/flask/sessions.py, 类名: NullSession\n    def _fail(self, *args: t.Any, **kwargs: t.Any) -> \"te.NoReturn\":\n        raise RuntimeError(\n            \"The session is unavailable because no secret \"\n            \"key was set.  Set the secret_key on the \"\n            \"application to something unique and secret.\"\n        )\n", "tokens": ["src", "flask", "sessions", "py", "nullsession", "def", "_fail", "self", "args", "t", "any", "kwargs", "t", "any", "te", "noreturn", "raise", "runtimeerror", "the", "session", "is", "unavailable", "because", "no", "secret", "key", "was", "set", "set", "the", "secret_key", "on", "the", "application", "to", "something", "unique", "and", "secret"], "doc_len": 39}
{"doc_id": "src/flask/sessions.py::SessionInterface.make_null_session", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "make_null_session", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def make_null_session(self, app: \"Flask\") -> NullSession:\n        \"\"\"Creates a null session which acts as a replacement object if the\n        real session support could not be loaded due to a configuration\n        error.  This mainly aids the user experience because the job of the\n        null session is to still support lookup without complaining but\n        modifications are answered with a helpful error message of what\n        failed.\n\n        This creates an instance of :attr:`null_session_class` by default.\n        \"\"\"\n        return self.null_session_class()\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "make_null_session", "self", "app", "flask", "nullsession", "creates", "a", "null", "session", "which", "acts", "as", "a", "replacement", "object", "if", "the", "real", "session", "support", "could", "not", "be", "loaded", "due", "to", "a", "configuration", "error", "this", "mainly", "aids", "the", "user", "experience", "because", "the", "job", "of", "the", "null", "session", "is", "to", "still", "support", "lookup", "without", "complaining", "but", "modifications", "are", "answered", "with", "a", "helpful", "error", "message", "of", "what", "failed", "this", "creates", "an", "instance", "of", "attr", "null_session_class", "by", "default", "return", "self", "null_session_class"], "doc_len": 79}
{"doc_id": "src/flask/sessions.py::SessionInterface.is_null_session", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "is_null_session", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def is_null_session(self, obj: object) -> bool:\n        \"\"\"Checks if a given object is a null session.  Null sessions are\n        not asked to be saved.\n\n        This checks if the object is an instance of :attr:`null_session_class`\n        by default.\n        \"\"\"\n        return isinstance(obj, self.null_session_class)\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "is_null_session", "self", "obj", "object", "bool", "checks", "if", "a", "given", "object", "is", "a", "null", "session", "null", "sessions", "are", "not", "asked", "to", "be", "saved", "this", "checks", "if", "the", "object", "is", "an", "instance", "of", "attr", "null_session_class", "by", "default", "return", "isinstance", "obj", "self", "null_session_class"], "doc_len": 46}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_name", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_name", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_name(self, app: \"Flask\") -> str:\n        \"\"\"The name of the session cookie. Uses``app.config[\"SESSION_COOKIE_NAME\"]``.\"\"\"\n        return app.config[\"SESSION_COOKIE_NAME\"]\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_name", "self", "app", "flask", "str", "the", "name", "of", "the", "session", "cookie", "uses", "app", "config", "session_cookie_name", "return", "app", "config", "session_cookie_name"], "doc_len": 25}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_domain", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_domain", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_domain(self, app: \"Flask\") -> t.Optional[str]:\n        \"\"\"Returns the domain that should be set for the session cookie.\n\n        Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise\n        falls back to detecting the domain based on ``SERVER_NAME``.\n\n        Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is\n        updated to avoid re-running the logic.\n        \"\"\"\n\n        rv = app.config[\"SESSION_COOKIE_DOMAIN\"]\n\n        # set explicitly, or cached from SERVER_NAME detection\n        # if False, return None\n        if rv is not None:\n            return rv if rv else None\n\n        rv = app.config[\"SERVER_NAME\"]\n\n        # server name not set, cache False to return none next time\n        if not rv:\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        # chop off the port which is usually not supported by browsers\n        # remove any leading '.' since we'll add that later\n        rv = rv.rsplit(\":\", 1)[0].lstrip(\".\")\n\n        if \".\" not in rv:\n            # Chrome doesn't allow names without a '.'. This should only\n            # come up with localhost. Hack around this by not setting\n            # the name, and show a warning.\n            warnings.warn(\n                f\"{rv!r} is not a valid cookie domain, it must contain\"\n                \" a '.'. Add an entry to your hosts file, for example\"\n                f\" '{rv}.localdomain', and use that instead.\"\n            )\n            app.config[\"SESSION_COOKIE_DOMAIN\"] = False\n            return None\n\n        ip = is_ip(rv)\n\n        if ip:\n            warnings.warn(\n                \"The session cookie domain is an IP address. This may not work\"\n                \" as intended in some browsers. Add an entry to your hosts\"\n                ' file, for example \"localhost.localdomain\", and use that'\n                \" instead.\"\n            )\n\n        # if this is not an ip and app is mounted at the root, allow subdomain\n        # matching by adding a '.' prefix\n        if self.get_cookie_path(app) == \"/\" and not ip:\n            rv = f\".{rv}\"\n\n        app.config[\"SESSION_COOKIE_DOMAIN\"] = rv\n        return rv\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_domain", "self", "app", "flask", "t", "optional", "str", "returns", "the", "domain", "that", "should", "be", "set", "for", "the", "session", "cookie", "uses", "session_cookie_domain", "if", "it", "is", "configured", "otherwise", "falls", "back", "to", "detecting", "the", "domain", "based", "on", "server_name", "once", "detected", "or", "if", "not", "set", "at", "all", "session_cookie_domain", "is", "updated", "to", "avoid", "re", "running", "the", "logic", "rv", "app", "config", "session_cookie_domain", "set", "explicitly", "or", "cached", "from", "server_name", "detection", "if", "false", "return", "none", "if", "rv", "is", "not", "none", "return", "rv", "if", "rv", "else", "none", "rv", "app", "config", "server_name", "server", "name", "not", "set", "cache", "false", "to", "return", "none", "next", "time", "if", "not", "rv", "app", "config", "session_cookie_domain", "false", "return", "none", "chop", "off", "the", "port", "which", "is", "usually", "not", "supported", "by", "browsers", "remove", "any", "leading", "since", "we", "ll", "add", "that", "later", "rv", "rv", "rsplit", "1", "0", "lstrip", "if", "not", "in", "rv", "chrome", "doesn", "t", "allow", "names", "without", "a", "this", "should", "only", "come", "up", "with", "localhost", "hack", "around", "this", "by", "not", "setting", "the", "name", "and", "show", "a", "warning", "warnings", "warn", "f", "rv", "r", "is", "not", "a", "valid", "cookie", "domain", "it", "must", "contain", "a", "add", "an", "entry", "to", "your", "hosts", "file", "for", "example", "f", "rv", "localdomain", "and", "use", "that", "instead", "app", "config", "session_cookie_domain", "false", "return", "none", "ip", "is_ip", "rv", "if", "ip", "warnings", "warn", "the", "session", "cookie", "domain", "is", "an", "ip", "address", "this", "may", "not", "work", "as", "intended", "in", "some", "browsers", "add", "an", "entry", "to", "your", "hosts", "file", "for", "example", "localhost", "localdomain", "and", "use", "that", "instead", "if", "this", "is", "not", "an", "ip", "and", "app", "is", "mounted", "at", "the", "root", "allow", "subdomain", "matching", "by", "adding", "a", "prefix", "if", "self", "get_cookie_path", "app", "and", "not", "ip", "rv", "f", "rv", "app", "config", "session_cookie_domain", "rv", "return", "rv"], "doc_len": 275}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_path", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_path", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_path(self, app: \"Flask\") -> str:\n        \"\"\"Returns the path for which the cookie should be valid.  The\n        default implementation uses the value from the ``SESSION_COOKIE_PATH``\n        config var if it's set, and falls back to ``APPLICATION_ROOT`` or\n        uses ``/`` if it's ``None``.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_PATH\"] or app.config[\"APPLICATION_ROOT\"]\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_path", "self", "app", "flask", "str", "returns", "the", "path", "for", "which", "the", "cookie", "should", "be", "valid", "the", "default", "implementation", "uses", "the", "value", "from", "the", "session_cookie_path", "config", "var", "if", "it", "s", "set", "and", "falls", "back", "to", "application_root", "or", "uses", "if", "it", "s", "none", "return", "app", "config", "session_cookie_path", "or", "app", "config", "application_root"], "doc_len": 55}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_httponly", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_httponly", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_httponly(self, app: \"Flask\") -> bool:\n        \"\"\"Returns True if the session cookie should be httponly.  This\n        currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``\n        config var.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_HTTPONLY\"]\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_httponly", "self", "app", "flask", "bool", "returns", "true", "if", "the", "session", "cookie", "should", "be", "httponly", "this", "currently", "just", "returns", "the", "value", "of", "the", "session_cookie_httponly", "config", "var", "return", "app", "config", "session_cookie_httponly"], "doc_len": 35}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_secure", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_secure", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_secure(self, app: \"Flask\") -> bool:\n        \"\"\"Returns True if the cookie should be secure.  This currently\n        just returns the value of the ``SESSION_COOKIE_SECURE`` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SECURE\"]\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_secure", "self", "app", "flask", "bool", "returns", "true", "if", "the", "cookie", "should", "be", "secure", "this", "currently", "just", "returns", "the", "value", "of", "the", "session_cookie_secure", "setting", "return", "app", "config", "session_cookie_secure"], "doc_len": 33}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_cookie_samesite", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_cookie_samesite", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_cookie_samesite(self, app: \"Flask\") -> str:\n        \"\"\"Return ``'Strict'`` or ``'Lax'`` if the cookie should use the\n        ``SameSite`` attribute. This currently just returns the value of\n        the :data:`SESSION_COOKIE_SAMESITE` setting.\n        \"\"\"\n        return app.config[\"SESSION_COOKIE_SAMESITE\"]\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_cookie_samesite", "self", "app", "flask", "str", "return", "strict", "or", "lax", "if", "the", "cookie", "should", "use", "the", "samesite", "attribute", "this", "currently", "just", "returns", "the", "value", "of", "the", "data", "session_cookie_samesite", "setting", "return", "app", "config", "session_cookie_samesite"], "doc_len": 38}
{"doc_id": "src/flask/sessions.py::SessionInterface.get_expiration_time", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "get_expiration_time", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def get_expiration_time(\n        self, app: \"Flask\", session: SessionMixin\n    ) -> t.Optional[datetime]:\n        \"\"\"A helper method that returns an expiration date for the session\n        or ``None`` if the session is linked to the browser session.  The\n        default implementation returns now + the permanent session\n        lifetime configured on the application.\n        \"\"\"\n        if session.permanent:\n            return datetime.now(timezone.utc) + app.permanent_session_lifetime\n        return None\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "get_expiration_time", "self", "app", "flask", "session", "sessionmixin", "t", "optional", "datetime", "a", "helper", "method", "that", "returns", "an", "expiration", "date", "for", "the", "session", "or", "none", "if", "the", "session", "is", "linked", "to", "the", "browser", "session", "the", "default", "implementation", "returns", "now", "the", "permanent", "session", "lifetime", "configured", "on", "the", "application", "if", "session", "permanent", "return", "datetime", "now", "timezone", "utc", "app", "permanent_session_lifetime", "return", "none"], "doc_len": 62}
{"doc_id": "src/flask/sessions.py::SessionInterface.should_set_cookie", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "should_set_cookie", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def should_set_cookie(self, app: \"Flask\", session: SessionMixin) -> bool:\n        \"\"\"Used by session backends to determine if a ``Set-Cookie`` header\n        should be set for this session cookie for this response. If the session\n        has been modified, the cookie is set. If the session is permanent and\n        the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is\n        always set.\n\n        This check is usually skipped if the session was deleted.\n\n        .. versionadded:: 0.11\n        \"\"\"\n\n        return session.modified or (\n            session.permanent and app.config[\"SESSION_REFRESH_EACH_REQUEST\"]\n        )\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "should_set_cookie", "self", "app", "flask", "session", "sessionmixin", "bool", "used", "by", "session", "backends", "to", "determine", "if", "a", "set", "cookie", "header", "should", "be", "set", "for", "this", "session", "cookie", "for", "this", "response", "if", "the", "session", "has", "been", "modified", "the", "cookie", "is", "set", "if", "the", "session", "is", "permanent", "and", "the", "session_refresh_each_request", "config", "is", "true", "the", "cookie", "is", "always", "set", "this", "check", "is", "usually", "skipped", "if", "the", "session", "was", "deleted", "versionadded", "0", "11", "return", "session", "modified", "or", "session", "permanent", "and", "app", "config", "session_refresh_each_request"], "doc_len": 83}
{"doc_id": "src/flask/sessions.py::SessionInterface.open_session", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "open_session", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def open_session(\n        self, app: \"Flask\", request: \"Request\"\n    ) -> t.Optional[SessionMixin]:\n        \"\"\"This is called at the beginning of each request, after\n        pushing the request context, before matching the URL.\n\n        This must return an object which implements a dictionary-like\n        interface as well as the :class:`SessionMixin` interface.\n\n        This will return ``None`` to indicate that loading failed in\n        some way that is not immediately an error. The request\n        context will fall back to using :meth:`make_null_session`\n        in this case.\n        \"\"\"\n        raise NotImplementedError()\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "open_session", "self", "app", "flask", "request", "request", "t", "optional", "sessionmixin", "this", "is", "called", "at", "the", "beginning", "of", "each", "request", "after", "pushing", "the", "request", "context", "before", "matching", "the", "url", "this", "must", "return", "an", "object", "which", "implements", "a", "dictionary", "like", "interface", "as", "well", "as", "the", "class", "sessionmixin", "interface", "this", "will", "return", "none", "to", "indicate", "that", "loading", "failed", "in", "some", "way", "that", "is", "not", "immediately", "an", "error", "the", "request", "context", "will", "fall", "back", "to", "using", "meth", "make_null_session", "in", "this", "case", "raise", "notimplementederror"], "doc_len": 84}
{"doc_id": "src/flask/sessions.py::SessionInterface.save_session", "file_path": "src/flask/sessions.py", "class_name": "SessionInterface", "func_name": "save_session", "text": "文件路径: src/flask/sessions.py, 类名: SessionInterface\n    def save_session(\n        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n    ) -> None:\n        \"\"\"This is called at the end of each request, after generating\n        a response, before removing the request context. It is skipped\n        if :meth:`is_null_session` returns ``True``.\n        \"\"\"\n        raise NotImplementedError()\n", "tokens": ["src", "flask", "sessions", "py", "sessioninterface", "def", "save_session", "self", "app", "flask", "session", "sessionmixin", "response", "response", "none", "this", "is", "called", "at", "the", "end", "of", "each", "request", "after", "generating", "a", "response", "before", "removing", "the", "request", "context", "it", "is", "skipped", "if", "meth", "is_null_session", "returns", "true", "raise", "notimplementederror"], "doc_len": 43}
{"doc_id": "src/flask/sessions.py::SecureCookieSessionInterface.get_signing_serializer", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSessionInterface", "func_name": "get_signing_serializer", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSessionInterface\n    def get_signing_serializer(\n        self, app: \"Flask\"\n    ) -> t.Optional[URLSafeTimedSerializer]:\n        if not app.secret_key:\n            return None\n        signer_kwargs = dict(\n            key_derivation=self.key_derivation, digest_method=self.digest_method\n        )\n        return URLSafeTimedSerializer(\n            app.secret_key,\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs=signer_kwargs,\n        )\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesessioninterface", "def", "get_signing_serializer", "self", "app", "flask", "t", "optional", "urlsafetimedserializer", "if", "not", "app", "secret_key", "return", "none", "signer_kwargs", "dict", "key_derivation", "self", "key_derivation", "digest_method", "self", "digest_method", "return", "urlsafetimedserializer", "app", "secret_key", "salt", "self", "salt", "serializer", "self", "serializer", "signer_kwargs", "signer_kwargs"], "doc_len": 39}
{"doc_id": "src/flask/sessions.py::SecureCookieSessionInterface.open_session", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSessionInterface", "func_name": "open_session", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSessionInterface\n    def open_session(\n        self, app: \"Flask\", request: \"Request\"\n    ) -> t.Optional[SecureCookieSession]:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesessioninterface", "def", "open_session", "self", "app", "flask", "request", "request", "t", "optional", "securecookiesession", "s", "self", "get_signing_serializer", "app", "if", "s", "is", "none", "return", "none", "val", "request", "cookies", "get", "self", "get_cookie_name", "app", "if", "not", "val", "return", "self", "session_class", "max_age", "int", "app", "permanent_session_lifetime", "total_seconds", "try", "data", "s", "loads", "val", "max_age", "max_age", "return", "self", "session_class", "data", "except", "badsignature", "return", "self", "session_class"], "doc_len": 59}
{"doc_id": "src/flask/sessions.py::SecureCookieSessionInterface.save_session", "file_path": "src/flask/sessions.py", "class_name": "SecureCookieSessionInterface", "func_name": "save_session", "text": "文件路径: src/flask/sessions.py, 类名: SecureCookieSessionInterface\n    def save_session(\n        self, app: \"Flask\", session: SessionMixin, response: \"Response\"\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n\n            return\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore\n        response.set_cookie(\n            name,\n            val,  # type: ignore\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            samesite=samesite,\n        )\n", "tokens": ["src", "flask", "sessions", "py", "securecookiesessioninterface", "def", "save_session", "self", "app", "flask", "session", "sessionmixin", "response", "response", "none", "name", "self", "get_cookie_name", "app", "domain", "self", "get_cookie_domain", "app", "path", "self", "get_cookie_path", "app", "secure", "self", "get_cookie_secure", "app", "samesite", "self", "get_cookie_samesite", "app", "httponly", "self", "get_cookie_httponly", "app", "if", "the", "session", "is", "modified", "to", "be", "empty", "remove", "the", "cookie", "if", "the", "session", "is", "empty", "return", "without", "setting", "the", "cookie", "if", "not", "session", "if", "session", "modified", "response", "delete_cookie", "name", "domain", "domain", "path", "path", "secure", "secure", "samesite", "samesite", "httponly", "httponly", "return", "add", "a", "vary", "cookie", "header", "if", "the", "session", "was", "accessed", "at", "all", "if", "session", "accessed", "response", "vary", "add", "cookie", "if", "not", "self", "should_set_cookie", "app", "session", "return", "expires", "self", "get_expiration_time", "app", "session", "val", "self", "get_signing_serializer", "app", "dumps", "dict", "session", "type", "ignore", "response", "set_cookie", "name", "val", "type", "ignore", "expires", "expires", "httponly", "httponly", "domain", "domain", "path", "path", "secure", "secure", "samesite", "samesite"], "doc_len": 138}
{"doc_id": "src/flask/templating.py::_default_template_ctx_processor", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "_default_template_ctx_processor", "text": "文件路径: src/flask/templating.py\ndef _default_template_ctx_processor() -> t.Dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    appctx = _cv_app.get(None)\n    reqctx = _cv_request.get(None)\n    rv: t.Dict[str, t.Any] = {}\n    if appctx is not None:\n        rv[\"g\"] = appctx.g\n    if reqctx is not None:\n        rv[\"request\"] = reqctx.request\n        rv[\"session\"] = reqctx.session\n    return rv\n", "tokens": ["src", "flask", "templating", "py", "def", "_default_template_ctx_processor", "t", "dict", "str", "t", "any", "default", "template", "context", "processor", "injects", "request", "session", "and", "g", "appctx", "_cv_app", "get", "none", "reqctx", "_cv_request", "get", "none", "rv", "t", "dict", "str", "t", "any", "if", "appctx", "is", "not", "none", "rv", "g", "appctx", "g", "if", "reqctx", "is", "not", "none", "rv", "request", "reqctx", "request", "rv", "session", "reqctx", "session", "return", "rv"], "doc_len": 58}
{"doc_id": "src/flask/templating.py::Environment.__init__", "file_path": "src/flask/templating.py", "class_name": "Environment", "func_name": "__init__", "text": "文件路径: src/flask/templating.py, 类名: Environment\n    def __init__(self, app: \"Flask\", **options: t.Any) -> None:\n        if \"loader\" not in options:\n            options[\"loader\"] = app.create_global_jinja_loader()\n        BaseEnvironment.__init__(self, **options)\n        self.app = app\n", "tokens": ["src", "flask", "templating", "py", "environment", "def", "__init__", "self", "app", "flask", "options", "t", "any", "none", "if", "loader", "not", "in", "options", "options", "loader", "app", "create_global_jinja_loader", "baseenvironment", "__init__", "self", "options", "self", "app", "app"], "doc_len": 30}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader.__init__", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "__init__", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def __init__(self, app: \"Flask\") -> None:\n        self.app = app\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "__init__", "self", "app", "flask", "none", "self", "app", "app"], "doc_len": 14}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader.get_source", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "get_source", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def get_source(  # type: ignore\n        self, environment: Environment, template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "get_source", "type", "ignore", "self", "environment", "environment", "template", "str", "t", "tuple", "str", "t", "optional", "str", "t", "optional", "t", "callable", "if", "self", "app", "config", "explain_template_loading", "return", "self", "_get_source_explained", "environment", "template", "return", "self", "_get_source_fast", "environment", "template"], "doc_len": 39}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader._get_source_explained", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "_get_source_explained", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def _get_source_explained(\n        self, environment: Environment, template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n        attempts = []\n        rv: t.Optional[t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]]\n        trv: t.Optional[\n            t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]\n        ] = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "_get_source_explained", "self", "environment", "environment", "template", "str", "t", "tuple", "str", "t", "optional", "str", "t", "optional", "t", "callable", "attempts", "rv", "t", "optional", "t", "tuple", "str", "t", "optional", "str", "t", "optional", "t", "callable", "bool", "trv", "t", "optional", "t", "tuple", "str", "t", "optional", "str", "t", "optional", "t", "callable", "bool", "none", "for", "srcobj", "loader", "in", "self", "_iter_loaders", "template", "try", "rv", "loader", "get_source", "environment", "template", "if", "trv", "is", "none", "trv", "rv", "except", "templatenotfound", "rv", "none", "attempts", "append", "loader", "srcobj", "rv", "from", "debughelpers", "import", "explain_template_loading_attempts", "explain_template_loading_attempts", "self", "app", "template", "attempts", "if", "trv", "is", "not", "none", "return", "trv", "raise", "templatenotfound", "template"], "doc_len": 99}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader._get_source_fast", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "_get_source_fast", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def _get_source_fast(\n        self, environment: Environment, template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:\n        for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "_get_source_fast", "self", "environment", "environment", "template", "str", "t", "tuple", "str", "t", "optional", "str", "t", "optional", "t", "callable", "for", "_srcobj", "loader", "in", "self", "_iter_loaders", "template", "try", "return", "loader", "get_source", "environment", "template", "except", "templatenotfound", "continue", "raise", "templatenotfound", "template"], "doc_len": 41}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader._iter_loaders", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "_iter_loaders", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def _iter_loaders(\n        self, template: str\n    ) -> t.Generator[t.Tuple[\"Scaffold\", BaseLoader], None, None]:\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "_iter_loaders", "self", "template", "str", "t", "generator", "t", "tuple", "scaffold", "baseloader", "none", "none", "loader", "self", "app", "jinja_loader", "if", "loader", "is", "not", "none", "yield", "self", "app", "loader", "for", "blueprint", "in", "self", "app", "iter_blueprints", "loader", "blueprint", "jinja_loader", "if", "loader", "is", "not", "none", "yield", "blueprint", "loader"], "doc_len": 48}
{"doc_id": "src/flask/templating.py::DispatchingJinjaLoader.list_templates", "file_path": "src/flask/templating.py", "class_name": "DispatchingJinjaLoader", "func_name": "list_templates", "text": "文件路径: src/flask/templating.py, 类名: DispatchingJinjaLoader\n    def list_templates(self) -> t.List[str]:\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)\n", "tokens": ["src", "flask", "templating", "py", "dispatchingjinjaloader", "def", "list_templates", "self", "t", "list", "str", "result", "set", "loader", "self", "app", "jinja_loader", "if", "loader", "is", "not", "none", "result", "update", "loader", "list_templates", "for", "blueprint", "in", "self", "app", "iter_blueprints", "loader", "blueprint", "jinja_loader", "if", "loader", "is", "not", "none", "for", "template", "in", "loader", "list_templates", "result", "add", "template", "return", "list", "result"], "doc_len": 51}
{"doc_id": "src/flask/templating.py::_render", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "_render", "text": "文件路径: src/flask/templating.py\ndef _render(app: \"Flask\", template: Template, context: t.Dict[str, t.Any]) -> str:\n    app.update_template_context(context)\n    before_render_template.send(app, template=template, context=context)\n    rv = template.render(context)\n    template_rendered.send(app, template=template, context=context)\n    return rv\n", "tokens": ["src", "flask", "templating", "py", "def", "_render", "app", "flask", "template", "template", "context", "t", "dict", "str", "t", "any", "str", "app", "update_template_context", "context", "before_render_template", "send", "app", "template", "template", "context", "context", "rv", "template", "render", "context", "template_rendered", "send", "app", "template", "template", "context", "context", "return", "rv"], "doc_len": 40}
{"doc_id": "src/flask/templating.py::render_template", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "render_template", "text": "文件路径: src/flask/templating.py\ndef render_template(\n    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n    **context: t.Any,\n) -> str:\n    \"\"\"Render a template by name with the given context.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.get_or_select_template(template_name_or_list)\n    return _render(app, template, context)\n", "tokens": ["src", "flask", "templating", "py", "def", "render_template", "template_name_or_list", "t", "union", "str", "template", "t", "list", "t", "union", "str", "template", "context", "t", "any", "str", "render", "a", "template", "by", "name", "with", "the", "given", "context", "param", "template_name_or_list", "the", "name", "of", "the", "template", "to", "render", "if", "a", "list", "is", "given", "the", "first", "name", "to", "exist", "will", "be", "rendered", "param", "context", "the", "variables", "to", "make", "available", "in", "the", "template", "app", "current_app", "_get_current_object", "type", "ignore", "attr", "defined", "template", "app", "jinja_env", "get_or_select_template", "template_name_or_list", "return", "_render", "app", "template", "context"], "doc_len": 79}
{"doc_id": "src/flask/templating.py::render_template_string", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "render_template_string", "text": "文件路径: src/flask/templating.py\ndef render_template_string(source: str, **context: t.Any) -> str:\n    \"\"\"Render a template from the given source string with the given\n    context.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.from_string(source)\n    return _render(app, template, context)\n", "tokens": ["src", "flask", "templating", "py", "def", "render_template_string", "source", "str", "context", "t", "any", "str", "render", "a", "template", "from", "the", "given", "source", "string", "with", "the", "given", "context", "param", "source", "the", "source", "code", "of", "the", "template", "to", "render", "param", "context", "the", "variables", "to", "make", "available", "in", "the", "template", "app", "current_app", "_get_current_object", "type", "ignore", "attr", "defined", "template", "app", "jinja_env", "from_string", "source", "return", "_render", "app", "template", "context"], "doc_len": 61}
{"doc_id": "src/flask/templating.py::_stream", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "_stream", "text": "文件路径: src/flask/templating.py\ndef _stream(\n    app: \"Flask\", template: Template, context: t.Dict[str, t.Any]\n) -> t.Iterator[str]:\n    app.update_template_context(context)\n    before_render_template.send(app, template=template, context=context)\n\n    def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(app, template=template, context=context)\n\n    rv = generate()\n\n    # If a request context is active, keep it while generating.\n    if request:\n        rv = stream_with_context(rv)\n\n    return rv\n", "tokens": ["src", "flask", "templating", "py", "def", "_stream", "app", "flask", "template", "template", "context", "t", "dict", "str", "t", "any", "t", "iterator", "str", "app", "update_template_context", "context", "before_render_template", "send", "app", "template", "template", "context", "context", "def", "generate", "t", "iterator", "str", "yield", "from", "template", "generate", "context", "template_rendered", "send", "app", "template", "template", "context", "context", "rv", "generate", "if", "a", "request", "context", "is", "active", "keep", "it", "while", "generating", "if", "request", "rv", "stream_with_context", "rv", "return", "rv"], "doc_len": 65}
{"doc_id": "src/flask/templating.py::stream_template", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "stream_template", "text": "文件路径: src/flask/templating.py\ndef stream_template(\n    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],\n    **context: t.Any,\n) -> t.Iterator[str]:\n    \"\"\"Render a template by name with the given context as a stream.\n    This returns an iterator of strings, which can be used as a\n    streaming response from a view.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.get_or_select_template(template_name_or_list)\n    return _stream(app, template, context)\n", "tokens": ["src", "flask", "templating", "py", "def", "stream_template", "template_name_or_list", "t", "union", "str", "template", "t", "list", "t", "union", "str", "template", "context", "t", "any", "t", "iterator", "str", "render", "a", "template", "by", "name", "with", "the", "given", "context", "as", "a", "stream", "this", "returns", "an", "iterator", "of", "strings", "which", "can", "be", "used", "as", "a", "streaming", "response", "from", "a", "view", "param", "template_name_or_list", "the", "name", "of", "the", "template", "to", "render", "if", "a", "list", "is", "given", "the", "first", "name", "to", "exist", "will", "be", "rendered", "param", "context", "the", "variables", "to", "make", "available", "in", "the", "template", "versionadded", "2", "2", "app", "current_app", "_get_current_object", "type", "ignore", "attr", "defined", "template", "app", "jinja_env", "get_or_select_template", "template_name_or_list", "return", "_stream", "app", "template", "context"], "doc_len": 104}
{"doc_id": "src/flask/templating.py::stream_template_string", "file_path": "src/flask/templating.py", "class_name": null, "func_name": "stream_template_string", "text": "文件路径: src/flask/templating.py\ndef stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:\n    \"\"\"Render a template from the given source string with the given\n    context as a stream. This returns an iterator of strings, which can\n    be used as a streaming response from a view.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.from_string(source)\n    return _stream(app, template, context)\n", "tokens": ["src", "flask", "templating", "py", "def", "stream_template_string", "source", "str", "context", "t", "any", "t", "iterator", "str", "render", "a", "template", "from", "the", "given", "source", "string", "with", "the", "given", "context", "as", "a", "stream", "this", "returns", "an", "iterator", "of", "strings", "which", "can", "be", "used", "as", "a", "streaming", "response", "from", "a", "view", "param", "source", "the", "source", "code", "of", "the", "template", "to", "render", "param", "context", "the", "variables", "to", "make", "available", "in", "the", "template", "versionadded", "2", "2", "app", "current_app", "_get_current_object", "type", "ignore", "attr", "defined", "template", "app", "jinja_env", "from_string", "source", "return", "_stream", "app", "template", "context"], "doc_len": 86}
{"doc_id": "src/flask/testing.py::EnvironBuilder.__init__", "file_path": "src/flask/testing.py", "class_name": "EnvironBuilder", "func_name": "__init__", "text": "文件路径: src/flask/testing.py, 类名: EnvironBuilder\n    def __init__(\n        self,\n        app: \"Flask\",\n        path: str = \"/\",\n        base_url: t.Optional[str] = None,\n        subdomain: t.Optional[str] = None,\n        url_scheme: t.Optional[str] = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(\n            subdomain or url_scheme\n        ), 'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = url_parse(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                sep = b\"?\" if isinstance(url.query, bytes) else \"?\"\n                path += sep + url.query\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n", "tokens": ["src", "flask", "testing", "py", "environbuilder", "def", "__init__", "self", "app", "flask", "path", "str", "base_url", "t", "optional", "str", "none", "subdomain", "t", "optional", "str", "none", "url_scheme", "t", "optional", "str", "none", "args", "t", "any", "kwargs", "t", "any", "none", "assert", "not", "base_url", "or", "subdomain", "or", "url_scheme", "or", "base_url", "is", "not", "none", "bool", "subdomain", "or", "url_scheme", "cannot", "pass", "subdomain", "or", "url_scheme", "with", "base_url", "if", "base_url", "is", "none", "http_host", "app", "config", "get", "server_name", "or", "localhost", "app_root", "app", "config", "application_root", "if", "subdomain", "http_host", "f", "subdomain", "http_host", "if", "url_scheme", "is", "none", "url_scheme", "app", "config", "preferred_url_scheme", "url", "url_parse", "path", "base_url", "f", "url", "scheme", "or", "url_scheme", "url", "netloc", "or", "http_host", "f", "app_root", "lstrip", "path", "url", "path", "if", "url", "query", "sep", "b", "if", "isinstance", "url", "query", "bytes", "else", "path", "sep", "url", "query", "self", "app", "app", "super", "__init__", "path", "base_url", "args", "kwargs"], "doc_len": 129}
{"doc_id": "src/flask/testing.py::EnvironBuilder.json_dumps", "file_path": "src/flask/testing.py", "class_name": "EnvironBuilder", "func_name": "json_dumps", "text": "文件路径: src/flask/testing.py, 类名: EnvironBuilder\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n", "tokens": ["src", "flask", "testing", "py", "environbuilder", "def", "json_dumps", "self", "obj", "t", "any", "kwargs", "t", "any", "str", "type", "ignore", "serialize", "obj", "to", "a", "json", "formatted", "string", "the", "serialization", "will", "be", "configured", "according", "to", "the", "config", "associated", "with", "this", "environbuilder", "s", "app", "return", "self", "app", "json", "dumps", "obj", "kwargs"], "doc_len": 46}
{"doc_id": "src/flask/testing.py::FlaskClient.__init__", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "__init__", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: t.List[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"werkzeug/{werkzeug.__version__}\",\n        }\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "__init__", "self", "args", "t", "any", "kwargs", "t", "any", "none", "super", "__init__", "args", "kwargs", "self", "preserve_context", "false", "self", "_new_contexts", "t", "list", "t", "contextmanager", "t", "any", "self", "_context_stack", "exitstack", "self", "environ_base", "remote_addr", "127", "0", "0", "1", "http_user_agent", "f", "werkzeug", "werkzeug", "__version__"], "doc_len": 45}
{"doc_id": "src/flask/testing.py::FlaskClient.session_transaction", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "session_transaction", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Generator[SessionMixin, None, None]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self.cookie_jar is None:\n            raise RuntimeError(\n                \"Session transactions only make sense with cookies enabled.\"\n            )\n        app = self.application\n        environ_overrides = kwargs.setdefault(\"environ_overrides\", {})\n        self.cookie_jar.inject_wsgi(environ_overrides)\n        outer_reqctx = _cv_request.get(None)\n        with app.test_request_context(*args, **kwargs) as c:\n            session_interface = app.session_interface\n            sess = session_interface.open_session(app, c.request)\n            if sess is None:\n                raise RuntimeError(\n                    \"Session backend did not open a session. Check the configuration\"\n                )\n\n            # Since we have to open a new request context for the session\n            # handling we want to make sure that we hide out own context\n            # from the caller.  By pushing the original request context\n            # (or None) on top of this and popping it we get exactly that\n            # behavior.  It's important to not use the push and pop\n            # methods of the actual request context object since that would\n            # mean that cleanup handlers are called\n            token = _cv_request.set(outer_reqctx)  # type: ignore[arg-type]\n            try:\n                yield sess\n            finally:\n                _cv_request.reset(token)\n\n            resp = app.response_class()\n            if not session_interface.is_null_session(sess):\n                session_interface.save_session(app, sess, resp)\n            headers = resp.get_wsgi_headers(c.request.environ)\n            self.cookie_jar.extract_wsgi(c.request.environ, headers)\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "session_transaction", "self", "args", "t", "any", "kwargs", "t", "any", "t", "generator", "sessionmixin", "none", "none", "when", "used", "in", "combination", "with", "a", "with", "statement", "this", "opens", "a", "session", "transaction", "this", "can", "be", "used", "to", "modify", "the", "session", "that", "the", "test", "client", "uses", "once", "the", "with", "block", "is", "left", "the", "session", "is", "stored", "back", "with", "client", "session_transaction", "as", "session", "session", "value", "42", "internally", "this", "is", "implemented", "by", "going", "through", "a", "temporary", "test", "request", "context", "and", "since", "session", "handling", "could", "depend", "on", "request", "variables", "this", "function", "accepts", "the", "same", "arguments", "as", "meth", "flask", "flask", "test_request_context", "which", "are", "directly", "passed", "through", "if", "self", "cookie_jar", "is", "none", "raise", "runtimeerror", "session", "transactions", "only", "make", "sense", "with", "cookies", "enabled", "app", "self", "application", "environ_overrides", "kwargs", "setdefault", "environ_overrides", "self", "cookie_jar", "inject_wsgi", "environ_overrides", "outer_reqctx", "_cv_request", "get", "none", "with", "app", "test_request_context", "args", "kwargs", "as", "c", "session_interface", "app", "session_interface", "sess", "session_interface", "open_session", "app", "c", "request", "if", "sess", "is", "none", "raise", "runtimeerror", "session", "backend", "did", "not", "open", "a", "session", "check", "the", "configuration", "since", "we", "have", "to", "open", "a", "new", "request", "context", "for", "the", "session", "handling", "we", "want", "to", "make", "sure", "that", "we", "hide", "out", "own", "context", "from", "the", "caller", "by", "pushing", "the", "original", "request", "context", "or", "none", "on", "top", "of", "this", "and", "popping", "it", "we", "get", "exactly", "that", "behavior", "it", "s", "important", "to", "not", "use", "the", "push", "and", "pop", "methods", "of", "the", "actual", "request", "context", "object", "since", "that", "would", "mean", "that", "cleanup", "handlers", "are", "called", "token", "_cv_request", "set", "outer_reqctx", "type", "ignore", "arg", "type", "try", "yield", "sess", "finally", "_cv_request", "reset", "token", "resp", "app", "response_class", "if", "not", "session_interface", "is_null_session", "sess", "session_interface", "save_session", "app", "sess", "resp", "headers", "resp", "get_wsgi_headers", "c", "request", "environ", "self", "cookie_jar", "extract_wsgi", "c", "request", "environ", "headers"], "doc_len": 277}
{"doc_id": "src/flask/testing.py::FlaskClient._copy_environ", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "_copy_environ", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def _copy_environ(self, other):\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "_copy_environ", "self", "other", "out", "self", "environ_base", "other", "if", "self", "preserve_context", "out", "werkzeug", "debug", "preserve_context", "self", "_new_contexts", "append", "return", "out"], "doc_len": 25}
{"doc_id": "src/flask/testing.py::FlaskClient._request_from_builder_args", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "_request_from_builder_args", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def _request_from_builder_args(self, args, kwargs):\n        kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n        builder = EnvironBuilder(self.application, *args, **kwargs)\n\n        try:\n            return builder.get_request()\n        finally:\n            builder.close()\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "_request_from_builder_args", "self", "args", "kwargs", "kwargs", "environ_base", "self", "_copy_environ", "kwargs", "get", "environ_base", "builder", "environbuilder", "self", "application", "args", "kwargs", "try", "return", "builder", "get_request", "finally", "builder", "close"], "doc_len": 30}
{"doc_id": "src/flask/testing.py::FlaskClient.open", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "open", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> \"TestResponse\":\n        if args and isinstance(\n            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n        ):\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                builder = copy(args[0])\n                builder.environ_base = self._copy_environ(builder.environ_base or {})\n                request = builder.get_request()\n            elif isinstance(args[0], dict):\n                request = EnvironBuilder.from_environ(\n                    args[0], app=self.application, environ_base=self._copy_environ({})\n                ).get_request()\n            else:\n                # isinstance(args[0], BaseRequest)\n                request = copy(args[0])\n                request.environ = self._copy_environ(request.environ)\n        else:\n            # request is None\n            request = self._request_from_builder_args(args, kwargs)\n\n        # Pop any previously preserved contexts. This prevents contexts\n        # from being preserved across redirects or multiple requests\n        # within a single block.\n        self._context_stack.close()\n\n        response = super().open(\n            request,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n        response.json_module = self.application.json  # type: ignore[assignment]\n\n        # Re-push contexts that were preserved during the request.\n        while self._new_contexts:\n            cm = self._new_contexts.pop()\n            self._context_stack.enter_context(cm)\n\n        return response\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "open", "self", "args", "t", "any", "buffered", "bool", "false", "follow_redirects", "bool", "false", "kwargs", "t", "any", "testresponse", "if", "args", "and", "isinstance", "args", "0", "werkzeug", "test", "environbuilder", "dict", "baserequest", "if", "isinstance", "args", "0", "werkzeug", "test", "environbuilder", "builder", "copy", "args", "0", "builder", "environ_base", "self", "_copy_environ", "builder", "environ_base", "or", "request", "builder", "get_request", "elif", "isinstance", "args", "0", "dict", "request", "environbuilder", "from_environ", "args", "0", "app", "self", "application", "environ_base", "self", "_copy_environ", "get_request", "else", "isinstance", "args", "0", "baserequest", "request", "copy", "args", "0", "request", "environ", "self", "_copy_environ", "request", "environ", "else", "request", "is", "none", "request", "self", "_request_from_builder_args", "args", "kwargs", "pop", "any", "previously", "preserved", "contexts", "this", "prevents", "contexts", "from", "being", "preserved", "across", "redirects", "or", "multiple", "requests", "within", "a", "single", "block", "self", "_context_stack", "close", "response", "super", "open", "request", "buffered", "buffered", "follow_redirects", "follow_redirects", "response", "json_module", "self", "application", "json", "type", "ignore", "assignment", "re", "push", "contexts", "that", "were", "preserved", "during", "the", "request", "while", "self", "_new_contexts", "cm", "self", "_new_contexts", "pop", "self", "_context_stack", "enter_context", "cm", "return", "response"], "doc_len": 155}
{"doc_id": "src/flask/testing.py::FlaskClient.__enter__", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "__enter__", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def __enter__(self) -> \"FlaskClient\":\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "__enter__", "self", "flaskclient", "if", "self", "preserve_context", "raise", "runtimeerror", "cannot", "nest", "client", "invocations", "self", "preserve_context", "true", "return", "self"], "doc_len": 23}
{"doc_id": "src/flask/testing.py::FlaskClient.__exit__", "file_path": "src/flask/testing.py", "class_name": "FlaskClient", "func_name": "__exit__", "text": "文件路径: src/flask/testing.py, 类名: FlaskClient\n    def __exit__(\n        self,\n        exc_type: t.Optional[type],\n        exc_value: t.Optional[BaseException],\n        tb: t.Optional[TracebackType],\n    ) -> None:\n        self.preserve_context = False\n        self._context_stack.close()\n", "tokens": ["src", "flask", "testing", "py", "flaskclient", "def", "__exit__", "self", "exc_type", "t", "optional", "type", "exc_value", "t", "optional", "baseexception", "tb", "t", "optional", "tracebacktype", "none", "self", "preserve_context", "false", "self", "_context_stack", "close"], "doc_len": 27}
{"doc_id": "src/flask/testing.py::FlaskCliRunner.__init__", "file_path": "src/flask/testing.py", "class_name": "FlaskCliRunner", "func_name": "__init__", "text": "文件路径: src/flask/testing.py, 类名: FlaskCliRunner\n    def __init__(self, app: \"Flask\", **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)\n", "tokens": ["src", "flask", "testing", "py", "flaskclirunner", "def", "__init__", "self", "app", "flask", "kwargs", "t", "any", "none", "self", "app", "app", "super", "__init__", "kwargs"], "doc_len": 20}
{"doc_id": "src/flask/testing.py::FlaskCliRunner.invoke", "file_path": "src/flask/testing.py", "class_name": "FlaskCliRunner", "func_name": "invoke", "text": "文件路径: src/flask/testing.py, 类名: FlaskCliRunner\n    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> t.Any:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli  # type: ignore\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)\n", "tokens": ["src", "flask", "testing", "py", "flaskclirunner", "def", "invoke", "type", "ignore", "self", "cli", "t", "any", "none", "args", "t", "any", "none", "kwargs", "t", "any", "t", "any", "invokes", "a", "cli", "command", "in", "an", "isolated", "environment", "see", "meth", "clirunner", "invoke", "click", "testing", "clirunner", "invoke", "for", "full", "method", "documentation", "see", "ref", "testing", "cli", "for", "examples", "if", "the", "obj", "argument", "is", "not", "given", "passes", "an", "instance", "of", "class", "flask", "cli", "scriptinfo", "that", "knows", "how", "to", "load", "the", "flask", "app", "being", "tested", "param", "cli", "command", "object", "to", "invoke", "default", "is", "the", "app", "s", "attr", "flask", "app", "flask", "cli", "group", "param", "args", "list", "of", "strings", "to", "invoke", "the", "command", "with", "return", "a", "class", "click", "testing", "result", "object", "if", "cli", "is", "none", "cli", "self", "app", "cli", "type", "ignore", "if", "obj", "not", "in", "kwargs", "kwargs", "obj", "scriptinfo", "create_app", "lambda", "self", "app", "return", "super", "invoke", "cli", "args", "kwargs"], "doc_len": 136}
{"doc_id": "src/flask/views.py::View.dispatch_request", "file_path": "src/flask/views.py", "class_name": "View", "func_name": "dispatch_request", "text": "文件路径: src/flask/views.py, 类名: View\n    def dispatch_request(self) -> ft.ResponseReturnValue:\n        \"\"\"The actual view function behavior. Subclasses must override\n        this and return a valid response. Any variables from the URL\n        rule are passed as keyword arguments.\n        \"\"\"\n        raise NotImplementedError()\n", "tokens": ["src", "flask", "views", "py", "view", "def", "dispatch_request", "self", "ft", "responsereturnvalue", "the", "actual", "view", "function", "behavior", "subclasses", "must", "override", "this", "and", "return", "a", "valid", "response", "any", "variables", "from", "the", "url", "rule", "are", "passed", "as", "keyword", "arguments", "raise", "notimplementederror"], "doc_len": 37}
{"doc_id": "src/flask/views.py::View.as_view", "file_path": "src/flask/views.py", "class_name": "View", "func_name": "as_view", "text": "文件路径: src/flask/views.py, 类名: View\n    def as_view(\n        cls, name: str, *class_args: t.Any, **class_kwargs: t.Any\n    ) -> ft.RouteCallable:\n        \"\"\"Convert the class into a view function that can be registered\n        for a route.\n\n        By default, the generated view will create a new instance of the\n        view class for every request and call its\n        :meth:`dispatch_request` method. If the view class sets\n        :attr:`init_every_request` to ``False``, the same instance will\n        be used for every request.\n\n        Except for ``name``, all other arguments passed to this method\n        are forwarded to the view class ``__init__`` method.\n\n        .. versionchanged:: 2.2\n            Added the ``init_every_request`` class attribute.\n        \"\"\"\n        if cls.init_every_request:\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                self = view.view_class(  # type: ignore[attr-defined]\n                    *class_args, **class_kwargs\n                )\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)\n\n        else:\n            self = cls(*class_args, **class_kwargs)\n\n            def view(**kwargs: t.Any) -> ft.ResponseReturnValue:\n                return current_app.ensure_sync(self.dispatch_request)(**kwargs)\n\n        if cls.decorators:\n            view.__name__ = name\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        # We attach the view class to the view function for two reasons:\n        # first of all it allows us to easily figure out what class-based\n        # view this thing came from, secondly it's also used for instantiating\n        # the view class so you can actually replace it with something else\n        # for testing purposes and debugging.\n        view.view_class = cls  # type: ignore\n        view.__name__ = name\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.methods = cls.methods  # type: ignore\n        view.provide_automatic_options = cls.provide_automatic_options  # type: ignore\n        return view\n", "tokens": ["src", "flask", "views", "py", "view", "def", "as_view", "cls", "name", "str", "class_args", "t", "any", "class_kwargs", "t", "any", "ft", "routecallable", "convert", "the", "class", "into", "a", "view", "function", "that", "can", "be", "registered", "for", "a", "route", "by", "default", "the", "generated", "view", "will", "create", "a", "new", "instance", "of", "the", "view", "class", "for", "every", "request", "and", "call", "its", "meth", "dispatch_request", "method", "if", "the", "view", "class", "sets", "attr", "init_every_request", "to", "false", "the", "same", "instance", "will", "be", "used", "for", "every", "request", "except", "for", "name", "all", "other", "arguments", "passed", "to", "this", "method", "are", "forwarded", "to", "the", "view", "class", "__init__", "method", "versionchanged", "2", "2", "added", "the", "init_every_request", "class", "attribute", "if", "cls", "init_every_request", "def", "view", "kwargs", "t", "any", "ft", "responsereturnvalue", "self", "view", "view_class", "type", "ignore", "attr", "defined", "class_args", "class_kwargs", "return", "current_app", "ensure_sync", "self", "dispatch_request", "kwargs", "else", "self", "cls", "class_args", "class_kwargs", "def", "view", "kwargs", "t", "any", "ft", "responsereturnvalue", "return", "current_app", "ensure_sync", "self", "dispatch_request", "kwargs", "if", "cls", "decorators", "view", "__name__", "name", "view", "__module__", "cls", "__module__", "for", "decorator", "in", "cls", "decorators", "view", "decorator", "view", "we", "attach", "the", "view", "class", "to", "the", "view", "function", "for", "two", "reasons", "first", "of", "all", "it", "allows", "us", "to", "easily", "figure", "out", "what", "class", "based", "view", "this", "thing", "came", "from", "secondly", "it", "s", "also", "used", "for", "instantiating", "the", "view", "class", "so", "you", "can", "actually", "replace", "it", "with", "something", "else", "for", "testing", "purposes", "and", "debugging", "view", "view_class", "cls", "type", "ignore", "view", "__name__", "name", "view", "__doc__", "cls", "__doc__", "view", "__module__", "cls", "__module__", "view", "methods", "cls", "methods", "type", "ignore", "view", "provide_automatic_options", "cls", "provide_automatic_options", "type", "ignore", "return", "view"], "doc_len": 244}
{"doc_id": "src/flask/views.py::MethodView.__init_subclass__", "file_path": "src/flask/views.py", "class_name": "MethodView", "func_name": "__init_subclass__", "text": "文件路径: src/flask/views.py, 类名: MethodView\n    def __init_subclass__(cls, **kwargs: t.Any) -> None:\n        super().__init_subclass__(**kwargs)\n\n        if \"methods\" not in cls.__dict__:\n            methods = set()\n\n            for base in cls.__bases__:\n                if getattr(base, \"methods\", None):\n                    methods.update(base.methods)  # type: ignore[attr-defined]\n\n            for key in http_method_funcs:\n                if hasattr(cls, key):\n                    methods.add(key.upper())\n\n            if methods:\n                cls.methods = methods\n", "tokens": ["src", "flask", "views", "py", "methodview", "def", "__init_subclass__", "cls", "kwargs", "t", "any", "none", "super", "__init_subclass__", "kwargs", "if", "methods", "not", "in", "cls", "__dict__", "methods", "set", "for", "base", "in", "cls", "__bases__", "if", "getattr", "base", "methods", "none", "methods", "update", "base", "methods", "type", "ignore", "attr", "defined", "for", "key", "in", "http_method_funcs", "if", "hasattr", "cls", "key", "methods", "add", "key", "upper", "if", "methods", "cls", "methods", "methods"], "doc_len": 58}
{"doc_id": "src/flask/views.py::MethodView.dispatch_request", "file_path": "src/flask/views.py", "class_name": "MethodView", "func_name": "dispatch_request", "text": "文件路径: src/flask/views.py, 类名: MethodView\n    def dispatch_request(self, **kwargs: t.Any) -> ft.ResponseReturnValue:\n        meth = getattr(self, request.method.lower(), None)\n\n        # If the request method is HEAD and we don't have a handler for it\n        # retry with GET.\n        if meth is None and request.method == \"HEAD\":\n            meth = getattr(self, \"get\", None)\n\n        assert meth is not None, f\"Unimplemented method {request.method!r}\"\n        return current_app.ensure_sync(meth)(**kwargs)\n", "tokens": ["src", "flask", "views", "py", "methodview", "def", "dispatch_request", "self", "kwargs", "t", "any", "ft", "responsereturnvalue", "meth", "getattr", "self", "request", "method", "lower", "none", "if", "the", "request", "method", "is", "head", "and", "we", "don", "t", "have", "a", "handler", "for", "it", "retry", "with", "get", "if", "meth", "is", "none", "and", "request", "method", "head", "meth", "getattr", "self", "get", "none", "assert", "meth", "is", "not", "none", "f", "unimplemented", "method", "request", "method", "r", "return", "current_app", "ensure_sync", "meth", "kwargs"], "doc_len": 67}
{"doc_id": "src/flask/wrappers.py::Request.max_content_length", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "max_content_length", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def max_content_length(self) -> t.Optional[int]:  # type: ignore\n        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"\n        if current_app:\n            return current_app.config[\"MAX_CONTENT_LENGTH\"]\n        else:\n            return None\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "max_content_length", "self", "t", "optional", "int", "type", "ignore", "read", "only", "view", "of", "the", "max_content_length", "config", "key", "if", "current_app", "return", "current_app", "config", "max_content_length", "else", "return", "none"], "doc_len": 30}
{"doc_id": "src/flask/wrappers.py::Request.endpoint", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "endpoint", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def endpoint(self) -> t.Optional[str]:\n        \"\"\"The endpoint that matched the request URL.\n\n        This will be ``None`` if matching failed or has not been\n        performed yet.\n\n        This in combination with :attr:`view_args` can be used to\n        reconstruct the same URL or a modified URL.\n        \"\"\"\n        if self.url_rule is not None:\n            return self.url_rule.endpoint\n\n        return None\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "endpoint", "self", "t", "optional", "str", "the", "endpoint", "that", "matched", "the", "request", "url", "this", "will", "be", "none", "if", "matching", "failed", "or", "has", "not", "been", "performed", "yet", "this", "in", "combination", "with", "attr", "view_args", "can", "be", "used", "to", "reconstruct", "the", "same", "url", "or", "a", "modified", "url", "if", "self", "url_rule", "is", "not", "none", "return", "self", "url_rule", "endpoint", "return", "none"], "doc_len": 61}
{"doc_id": "src/flask/wrappers.py::Request.blueprint", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "blueprint", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def blueprint(self) -> t.Optional[str]:\n        \"\"\"The registered name of the current blueprint.\n\n        This will be ``None`` if the endpoint is not part of a\n        blueprint, or if URL matching failed or has not been performed\n        yet.\n\n        This does not necessarily match the name the blueprint was\n        created with. It may have been nested, or registered with a\n        different name.\n        \"\"\"\n        endpoint = self.endpoint\n\n        if endpoint is not None and \".\" in endpoint:\n            return endpoint.rpartition(\".\")[0]\n\n        return None\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "blueprint", "self", "t", "optional", "str", "the", "registered", "name", "of", "the", "current", "blueprint", "this", "will", "be", "none", "if", "the", "endpoint", "is", "not", "part", "of", "a", "blueprint", "or", "if", "url", "matching", "failed", "or", "has", "not", "been", "performed", "yet", "this", "does", "not", "necessarily", "match", "the", "name", "the", "blueprint", "was", "created", "with", "it", "may", "have", "been", "nested", "or", "registered", "with", "a", "different", "name", "endpoint", "self", "endpoint", "if", "endpoint", "is", "not", "none", "and", "in", "endpoint", "return", "endpoint", "rpartition", "0", "return", "none"], "doc_len": 82}
{"doc_id": "src/flask/wrappers.py::Request.blueprints", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "blueprints", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def blueprints(self) -> t.List[str]:\n        \"\"\"The registered names of the current blueprint upwards through\n        parent blueprints.\n\n        This will be an empty list if there is no current blueprint, or\n        if URL matching failed.\n\n        .. versionadded:: 2.0.1\n        \"\"\"\n        name = self.blueprint\n\n        if name is None:\n            return []\n\n        return _split_blueprint_path(name)\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "blueprints", "self", "t", "list", "str", "the", "registered", "names", "of", "the", "current", "blueprint", "upwards", "through", "parent", "blueprints", "this", "will", "be", "an", "empty", "list", "if", "there", "is", "no", "current", "blueprint", "or", "if", "url", "matching", "failed", "versionadded", "2", "0", "1", "name", "self", "blueprint", "if", "name", "is", "none", "return", "return", "_split_blueprint_path", "name"], "doc_len": 54}
{"doc_id": "src/flask/wrappers.py::Request._load_form_data", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "_load_form_data", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def _load_form_data(self) -> None:\n        super()._load_form_data()\n\n        # In debug mode we're replacing the files multidict with an ad-hoc\n        # subclass that raises a different error for key errors.\n        if (\n            current_app\n            and current_app.debug\n            and self.mimetype != \"multipart/form-data\"\n            and not self.files\n        ):\n            from .debughelpers import attach_enctype_error_multidict\n\n            attach_enctype_error_multidict(self)\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "_load_form_data", "self", "none", "super", "_load_form_data", "in", "debug", "mode", "we", "re", "replacing", "the", "files", "multidict", "with", "an", "ad", "hoc", "subclass", "that", "raises", "a", "different", "error", "for", "key", "errors", "if", "current_app", "and", "current_app", "debug", "and", "self", "mimetype", "multipart", "form", "data", "and", "not", "self", "files", "from", "debughelpers", "import", "attach_enctype_error_multidict", "attach_enctype_error_multidict", "self"], "doc_len": 54}
{"doc_id": "src/flask/wrappers.py::Request.on_json_loading_failed", "file_path": "src/flask/wrappers.py", "class_name": "Request", "func_name": "on_json_loading_failed", "text": "文件路径: src/flask/wrappers.py, 类名: Request\n    def on_json_loading_failed(self, e: t.Optional[ValueError]) -> t.Any:\n        try:\n            return super().on_json_loading_failed(e)\n        except BadRequest as e:\n            if current_app and current_app.debug:\n                raise\n\n            raise BadRequest() from e\n", "tokens": ["src", "flask", "wrappers", "py", "request", "def", "on_json_loading_failed", "self", "e", "t", "optional", "valueerror", "t", "any", "try", "return", "super", "on_json_loading_failed", "e", "except", "badrequest", "as", "e", "if", "current_app", "and", "current_app", "debug", "raise", "raise", "badrequest", "from", "e"], "doc_len": 33}
{"doc_id": "src/flask/wrappers.py::Response.max_cookie_size", "file_path": "src/flask/wrappers.py", "class_name": "Response", "func_name": "max_cookie_size", "text": "文件路径: src/flask/wrappers.py, 类名: Response\n    def max_cookie_size(self) -> int:  # type: ignore\n        \"\"\"Read-only view of the :data:`MAX_COOKIE_SIZE` config key.\n\n        See :attr:`~werkzeug.wrappers.Response.max_cookie_size` in\n        Werkzeug's docs.\n        \"\"\"\n        if current_app:\n            return current_app.config[\"MAX_COOKIE_SIZE\"]\n\n        # return Werkzeug's default when not in an app context\n        return super().max_cookie_size\n", "tokens": ["src", "flask", "wrappers", "py", "response", "def", "max_cookie_size", "self", "int", "type", "ignore", "read", "only", "view", "of", "the", "data", "max_cookie_size", "config", "key", "see", "attr", "werkzeug", "wrappers", "response", "max_cookie_size", "in", "werkzeug", "s", "docs", "if", "current_app", "return", "current_app", "config", "max_cookie_size", "return", "werkzeug", "s", "default", "when", "not", "in", "an", "app", "context", "return", "super", "max_cookie_size"], "doc_len": 49}
{"doc_id": "src/flask/__init__.py::__getattr__", "file_path": "src/flask/__init__.py", "class_name": null, "func_name": "__getattr__", "text": "文件路径: src/flask/__init__.py\ndef __getattr__(name):\n    if name == \"_app_ctx_stack\":\n        import warnings\n        from .globals import __app_ctx_stack\n\n        warnings.warn(\n            \"'_app_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return __app_ctx_stack\n\n    if name == \"_request_ctx_stack\":\n        import warnings\n        from .globals import __request_ctx_stack\n\n        warnings.warn(\n            \"'_request_ctx_stack' is deprecated and will be removed in Flask 2.4.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return __request_ctx_stack\n\n    if name == \"escape\":\n        import warnings\n        from markupsafe import escape\n\n        warnings.warn(\n            \"'flask.escape' is deprecated and will be removed in Flask 2.4. Import\"\n            \" 'markupsafe.escape' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return escape\n\n    if name == \"escape\":\n        import warnings\n        from markupsafe import Markup\n\n        warnings.warn(\n            \"'flask.Markup' is deprecated and will be removed in Flask 2.4. Import\"\n            \" 'markupsafe.Markup' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return Markup\n\n    raise AttributeError(name)\n", "tokens": ["src", "flask", "__init__", "py", "def", "__getattr__", "name", "if", "name", "_app_ctx_stack", "import", "warnings", "from", "globals", "import", "__app_ctx_stack", "warnings", "warn", "_app_ctx_stack", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "deprecationwarning", "stacklevel", "2", "return", "__app_ctx_stack", "if", "name", "_request_ctx_stack", "import", "warnings", "from", "globals", "import", "__request_ctx_stack", "warnings", "warn", "_request_ctx_stack", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "deprecationwarning", "stacklevel", "2", "return", "__request_ctx_stack", "if", "name", "escape", "import", "warnings", "from", "markupsafe", "import", "escape", "warnings", "warn", "flask", "escape", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "import", "markupsafe", "escape", "instead", "deprecationwarning", "stacklevel", "2", "return", "escape", "if", "name", "escape", "import", "warnings", "from", "markupsafe", "import", "markup", "warnings", "warn", "flask", "markup", "is", "deprecated", "and", "will", "be", "removed", "in", "flask", "2", "4", "import", "markupsafe", "markup", "instead", "deprecationwarning", "stacklevel", "2", "return", "markup", "raise", "attributeerror", "name"], "doc_len": 128}
{"doc_id": "src/flask/json/provider.py::JSONProvider.__init__", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "__init__", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def __init__(self, app: Flask) -> None:\n        self._app = weakref.proxy(app)\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "__init__", "self", "app", "flask", "none", "self", "_app", "weakref", "proxy", "app"], "doc_len": 17}
{"doc_id": "src/flask/json/provider.py::JSONProvider.dumps", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "dumps", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON.\n\n        :param obj: The data to serialize.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "dumps", "self", "obj", "t", "any", "kwargs", "t", "any", "str", "serialize", "data", "as", "json", "param", "obj", "the", "data", "to", "serialize", "param", "kwargs", "may", "be", "passed", "to", "the", "underlying", "json", "library", "raise", "notimplementederror"], "doc_len": 38}
{"doc_id": "src/flask/json/provider.py::JSONProvider.dump", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "dump", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n        \"\"\"Serialize data as JSON and write to a file.\n\n        :param obj: The data to serialize.\n        :param fp: A file opened for writing text. Should use the UTF-8\n            encoding to be valid JSON.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        fp.write(self.dumps(obj, **kwargs))\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "dump", "self", "obj", "t", "any", "fp", "t", "io", "str", "kwargs", "t", "any", "none", "serialize", "data", "as", "json", "and", "write", "to", "a", "file", "param", "obj", "the", "data", "to", "serialize", "param", "fp", "a", "file", "opened", "for", "writing", "text", "should", "use", "the", "utf", "8", "encoding", "to", "be", "valid", "json", "param", "kwargs", "may", "be", "passed", "to", "the", "underlying", "json", "library", "fp", "write", "self", "dumps", "obj", "kwargs"], "doc_len": 69}
{"doc_id": "src/flask/json/provider.py::JSONProvider.loads", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "loads", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "loads", "self", "s", "str", "bytes", "kwargs", "t", "any", "t", "any", "deserialize", "data", "as", "json", "param", "s", "text", "or", "utf", "8", "bytes", "param", "kwargs", "may", "be", "passed", "to", "the", "underlying", "json", "library", "raise", "notimplementederror"], "doc_len": 40}
{"doc_id": "src/flask/json/provider.py::JSONProvider.load", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "load", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON read from a file.\n\n        :param fp: A file opened for reading text or UTF-8 bytes.\n        :param kwargs: May be passed to the underlying JSON library.\n        \"\"\"\n        return self.loads(fp.read(), **kwargs)\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "load", "self", "fp", "t", "io", "t", "anystr", "kwargs", "t", "any", "t", "any", "deserialize", "data", "as", "json", "read", "from", "a", "file", "param", "fp", "a", "file", "opened", "for", "reading", "text", "or", "utf", "8", "bytes", "param", "kwargs", "may", "be", "passed", "to", "the", "underlying", "json", "library", "return", "self", "loads", "fp", "read", "kwargs"], "doc_len": 55}
{"doc_id": "src/flask/json/provider.py::JSONProvider._prepare_response_obj", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "_prepare_response_obj", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def _prepare_response_obj(\n        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n    ) -> t.Any:\n        if args and kwargs:\n            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n\n        if not args and not kwargs:\n            return None\n\n        if len(args) == 1:\n            return args[0]\n\n        return args or kwargs\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "_prepare_response_obj", "self", "args", "t", "tuple", "t", "any", "kwargs", "t", "dict", "str", "t", "any", "t", "any", "if", "args", "and", "kwargs", "raise", "typeerror", "app", "json", "response", "takes", "either", "args", "or", "kwargs", "not", "both", "if", "not", "args", "and", "not", "kwargs", "return", "none", "if", "len", "args", "1", "return", "args", "0", "return", "args", "or", "kwargs"], "doc_len": 57}
{"doc_id": "src/flask/json/provider.py::JSONProvider.response", "file_path": "src/flask/json/provider.py", "class_name": "JSONProvider", "func_name": "response", "text": "文件路径: src/flask/json/provider.py, 类名: JSONProvider\n    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with the ``application/json``\n        mimetype.\n\n        The :func:`~flask.json.jsonify` function calls this method for\n        the current application.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")\n", "tokens": ["src", "flask", "json", "provider", "py", "jsonprovider", "def", "response", "self", "args", "t", "any", "kwargs", "t", "any", "response", "serialize", "the", "given", "arguments", "as", "json", "and", "return", "a", "class", "flask", "response", "object", "with", "the", "application", "json", "mimetype", "the", "func", "flask", "json", "jsonify", "function", "calls", "this", "method", "for", "the", "current", "application", "either", "positional", "or", "keyword", "arguments", "can", "be", "given", "not", "both", "if", "no", "arguments", "are", "given", "none", "is", "serialized", "param", "args", "a", "single", "value", "to", "serialize", "or", "multiple", "values", "to", "treat", "as", "a", "list", "to", "serialize", "param", "kwargs", "treat", "as", "a", "dict", "to", "serialize", "obj", "self", "_prepare_response_obj", "args", "kwargs", "return", "self", "_app", "response_class", "self", "dumps", "obj", "mimetype", "application", "json"], "doc_len": 105}
{"doc_id": "src/flask/json/provider.py::_default", "file_path": "src/flask/json/provider.py", "class_name": null, "func_name": "_default", "text": "文件路径: src/flask/json/provider.py\ndef _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")\n", "tokens": ["src", "flask", "json", "provider", "py", "def", "_default", "o", "t", "any", "t", "any", "if", "isinstance", "o", "date", "return", "http_date", "o", "if", "isinstance", "o", "decimal", "decimal", "uuid", "uuid", "return", "str", "o", "if", "dataclasses", "and", "dataclasses", "is_dataclass", "o", "return", "dataclasses", "asdict", "o", "if", "hasattr", "o", "__html__", "return", "str", "o", "__html__", "raise", "typeerror", "f", "object", "of", "type", "type", "o", "__name__", "is", "not", "json", "serializable"], "doc_len": 60}
{"doc_id": "src/flask/json/provider.py::DefaultJSONProvider.dumps", "file_path": "src/flask/json/provider.py", "class_name": "DefaultJSONProvider", "func_name": "dumps", "text": "文件路径: src/flask/json/provider.py, 类名: DefaultJSONProvider\n    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize data as JSON to a string.\n\n        Keyword arguments are passed to :func:`json.dumps`. Sets some\n        parameter defaults from the :attr:`default`,\n        :attr:`ensure_ascii`, and :attr:`sort_keys` attributes.\n\n        :param obj: The data to serialize.\n        :param kwargs: Passed to :func:`json.dumps`.\n        \"\"\"\n        kwargs.setdefault(\"default\", self.default)\n        kwargs.setdefault(\"ensure_ascii\", self.ensure_ascii)\n        kwargs.setdefault(\"sort_keys\", self.sort_keys)\n        return json.dumps(obj, **kwargs)\n", "tokens": ["src", "flask", "json", "provider", "py", "defaultjsonprovider", "def", "dumps", "self", "obj", "t", "any", "kwargs", "t", "any", "str", "serialize", "data", "as", "json", "to", "a", "string", "keyword", "arguments", "are", "passed", "to", "func", "json", "dumps", "sets", "some", "parameter", "defaults", "from", "the", "attr", "default", "attr", "ensure_ascii", "and", "attr", "sort_keys", "attributes", "param", "obj", "the", "data", "to", "serialize", "param", "kwargs", "passed", "to", "func", "json", "dumps", "kwargs", "setdefault", "default", "self", "default", "kwargs", "setdefault", "ensure_ascii", "self", "ensure_ascii", "kwargs", "setdefault", "sort_keys", "self", "sort_keys", "return", "json", "dumps", "obj", "kwargs"], "doc_len": 78}
{"doc_id": "src/flask/json/provider.py::DefaultJSONProvider.loads", "file_path": "src/flask/json/provider.py", "class_name": "DefaultJSONProvider", "func_name": "loads", "text": "文件路径: src/flask/json/provider.py, 类名: DefaultJSONProvider\n    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n        \"\"\"Deserialize data as JSON from a string or bytes.\n\n        :param s: Text or UTF-8 bytes.\n        :param kwargs: Passed to :func:`json.loads`.\n        \"\"\"\n        return json.loads(s, **kwargs)\n", "tokens": ["src", "flask", "json", "provider", "py", "defaultjsonprovider", "def", "loads", "self", "s", "str", "bytes", "kwargs", "t", "any", "t", "any", "deserialize", "data", "as", "json", "from", "a", "string", "or", "bytes", "param", "s", "text", "or", "utf", "8", "bytes", "param", "kwargs", "passed", "to", "func", "json", "loads", "return", "json", "loads", "s", "kwargs"], "doc_len": 45}
{"doc_id": "src/flask/json/provider.py::DefaultJSONProvider.response", "file_path": "src/flask/json/provider.py", "class_name": "DefaultJSONProvider", "func_name": "response", "text": "文件路径: src/flask/json/provider.py, 类名: DefaultJSONProvider\n    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n        \"\"\"Serialize the given arguments as JSON, and return a\n        :class:`~flask.Response` object with it. The response mimetype\n        will be \"application/json\" and can be changed with\n        :attr:`mimetype`.\n\n        If :attr:`compact` is ``False`` or debug mode is enabled, the\n        output will be formatted to be easier to read.\n\n        Either positional or keyword arguments can be given, not both.\n        If no arguments are given, ``None`` is serialized.\n\n        :param args: A single value to serialize, or multiple values to\n            treat as a list to serialize.\n        :param kwargs: Treat as a dict to serialize.\n        \"\"\"\n        obj = self._prepare_response_obj(args, kwargs)\n        dump_args: t.Dict[str, t.Any] = {}\n\n        if (self.compact is None and self._app.debug) or self.compact is False:\n            dump_args.setdefault(\"indent\", 2)\n        else:\n            dump_args.setdefault(\"separators\", (\",\", \":\"))\n\n        return self._app.response_class(\n            f\"{self.dumps(obj, **dump_args)}\\n\", mimetype=self.mimetype\n        )\n", "tokens": ["src", "flask", "json", "provider", "py", "defaultjsonprovider", "def", "response", "self", "args", "t", "any", "kwargs", "t", "any", "response", "serialize", "the", "given", "arguments", "as", "json", "and", "return", "a", "class", "flask", "response", "object", "with", "it", "the", "response", "mimetype", "will", "be", "application", "json", "and", "can", "be", "changed", "with", "attr", "mimetype", "if", "attr", "compact", "is", "false", "or", "debug", "mode", "is", "enabled", "the", "output", "will", "be", "formatted", "to", "be", "easier", "to", "read", "either", "positional", "or", "keyword", "arguments", "can", "be", "given", "not", "both", "if", "no", "arguments", "are", "given", "none", "is", "serialized", "param", "args", "a", "single", "value", "to", "serialize", "or", "multiple", "values", "to", "treat", "as", "a", "list", "to", "serialize", "param", "kwargs", "treat", "as", "a", "dict", "to", "serialize", "obj", "self", "_prepare_response_obj", "args", "kwargs", "dump_args", "t", "dict", "str", "t", "any", "if", "self", "compact", "is", "none", "and", "self", "_app", "debug", "or", "self", "compact", "is", "false", "dump_args", "setdefault", "indent", "2", "else", "dump_args", "setdefault", "separators", "return", "self", "_app", "response_class", "f", "self", "dumps", "obj", "dump_args", "n", "mimetype", "self", "mimetype"], "doc_len": 154}
{"doc_id": "src/flask/json/tag.py::JSONTag.__init__", "file_path": "src/flask/json/tag.py", "class_name": "JSONTag", "func_name": "__init__", "text": "文件路径: src/flask/json/tag.py, 类名: JSONTag\n    def __init__(self, serializer: \"TaggedJSONSerializer\") -> None:\n        \"\"\"Create a tagger for the given serializer.\"\"\"\n        self.serializer = serializer\n", "tokens": ["src", "flask", "json", "tag", "py", "jsontag", "def", "__init__", "self", "serializer", "taggedjsonserializer", "none", "create", "a", "tagger", "for", "the", "given", "serializer", "self", "serializer", "serializer"], "doc_len": 22}
{"doc_id": "src/flask/json/tag.py::JSONTag.check", "file_path": "src/flask/json/tag.py", "class_name": "JSONTag", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: JSONTag\n    def check(self, value: t.Any) -> bool:\n        \"\"\"Check if the given value should be tagged by this tag.\"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "json", "tag", "py", "jsontag", "def", "check", "self", "value", "t", "any", "bool", "check", "if", "the", "given", "value", "should", "be", "tagged", "by", "this", "tag", "raise", "notimplementederror"], "doc_len": 26}
{"doc_id": "src/flask/json/tag.py::JSONTag.to_json", "file_path": "src/flask/json/tag.py", "class_name": "JSONTag", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: JSONTag\n    def to_json(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the Python object to an object that is a valid JSON type.\n        The tag will be added later.\"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "json", "tag", "py", "jsontag", "def", "to_json", "self", "value", "t", "any", "t", "any", "convert", "the", "python", "object", "to", "an", "object", "that", "is", "a", "valid", "json", "type", "the", "tag", "will", "be", "added", "later", "raise", "notimplementederror"], "doc_len": 35}
{"doc_id": "src/flask/json/tag.py::JSONTag.to_python", "file_path": "src/flask/json/tag.py", "class_name": "JSONTag", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: JSONTag\n    def to_python(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the JSON representation back to the correct type. The tag\n        will already be removed.\"\"\"\n        raise NotImplementedError\n", "tokens": ["src", "flask", "json", "tag", "py", "jsontag", "def", "to_python", "self", "value", "t", "any", "t", "any", "convert", "the", "json", "representation", "back", "to", "the", "correct", "type", "the", "tag", "will", "already", "be", "removed", "raise", "notimplementederror"], "doc_len": 31}
{"doc_id": "src/flask/json/tag.py::JSONTag.tag", "file_path": "src/flask/json/tag.py", "class_name": "JSONTag", "func_name": "tag", "text": "文件路径: src/flask/json/tag.py, 类名: JSONTag\n    def tag(self, value: t.Any) -> t.Any:\n        \"\"\"Convert the value to a valid JSON type and add the tag structure\n        around it.\"\"\"\n        return {self.key: self.to_json(value)}\n", "tokens": ["src", "flask", "json", "tag", "py", "jsontag", "def", "tag", "self", "value", "t", "any", "t", "any", "convert", "the", "value", "to", "a", "valid", "json", "type", "and", "add", "the", "tag", "structure", "around", "it", "return", "self", "key", "self", "to_json", "value"], "doc_len": 35}
{"doc_id": "src/flask/json/tag.py::TagDict.check", "file_path": "src/flask/json/tag.py", "class_name": "TagDict", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagDict\n    def check(self, value: t.Any) -> bool:\n        return (\n            isinstance(value, dict)\n            and len(value) == 1\n            and next(iter(value)) in self.serializer.tags\n        )\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdict", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "dict", "and", "len", "value", "1", "and", "next", "iter", "value", "in", "self", "serializer", "tags"], "doc_len": 29}
{"doc_id": "src/flask/json/tag.py::TagDict.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagDict", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagDict\n    def to_json(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {f\"{key}__\": self.serializer.tag(value[key])}\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdict", "def", "to_json", "self", "value", "t", "any", "t", "any", "key", "next", "iter", "value", "return", "f", "key", "__", "self", "serializer", "tag", "value", "key"], "doc_len": 27}
{"doc_id": "src/flask/json/tag.py::TagDict.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagDict", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagDict\n    def to_python(self, value: t.Any) -> t.Any:\n        key = next(iter(value))\n        return {key[:-2]: value[key]}\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdict", "def", "to_python", "self", "value", "t", "any", "t", "any", "key", "next", "iter", "value", "return", "key", "2", "value", "key"], "doc_len": 23}
{"doc_id": "src/flask/json/tag.py::PassDict.check", "file_path": "src/flask/json/tag.py", "class_name": "PassDict", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: PassDict\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, dict)\n", "tokens": ["src", "flask", "json", "tag", "py", "passdict", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "dict"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::PassDict.to_json", "file_path": "src/flask/json/tag.py", "class_name": "PassDict", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: PassDict\n    def to_json(self, value: t.Any) -> t.Any:\n        # JSON objects may only have string keys, so don't bother tagging the\n        # key here.\n        return {k: self.serializer.tag(v) for k, v in value.items()}\n", "tokens": ["src", "flask", "json", "tag", "py", "passdict", "def", "to_json", "self", "value", "t", "any", "t", "any", "json", "objects", "may", "only", "have", "string", "keys", "so", "don", "t", "bother", "tagging", "the", "key", "here", "return", "k", "self", "serializer", "tag", "v", "for", "k", "v", "in", "value", "items"], "doc_len": 41}
{"doc_id": "src/flask/json/tag.py::TagTuple.check", "file_path": "src/flask/json/tag.py", "class_name": "TagTuple", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagTuple\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, tuple)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagtuple", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "tuple"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagTuple.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagTuple", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagTuple\n    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "tokens": ["src", "flask", "json", "tag", "py", "tagtuple", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "self", "serializer", "tag", "item", "for", "item", "in", "value"], "doc_len": 23}
{"doc_id": "src/flask/json/tag.py::TagTuple.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagTuple", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagTuple\n    def to_python(self, value: t.Any) -> t.Any:\n        return tuple(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagtuple", "def", "to_python", "self", "value", "t", "any", "t", "any", "return", "tuple", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::PassList.check", "file_path": "src/flask/json/tag.py", "class_name": "PassList", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: PassList\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, list)\n", "tokens": ["src", "flask", "json", "tag", "py", "passlist", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "list"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::PassList.to_json", "file_path": "src/flask/json/tag.py", "class_name": "PassList", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: PassList\n    def to_json(self, value: t.Any) -> t.Any:\n        return [self.serializer.tag(item) for item in value]\n", "tokens": ["src", "flask", "json", "tag", "py", "passlist", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "self", "serializer", "tag", "item", "for", "item", "in", "value"], "doc_len": 23}
{"doc_id": "src/flask/json/tag.py::TagBytes.check", "file_path": "src/flask/json/tag.py", "class_name": "TagBytes", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagBytes\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, bytes)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagbytes", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "bytes"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagBytes.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagBytes", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagBytes\n    def to_json(self, value: t.Any) -> t.Any:\n        return b64encode(value).decode(\"ascii\")\n", "tokens": ["src", "flask", "json", "tag", "py", "tagbytes", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "b64encode", "value", "decode", "ascii"], "doc_len": 19}
{"doc_id": "src/flask/json/tag.py::TagBytes.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagBytes", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagBytes\n    def to_python(self, value: t.Any) -> t.Any:\n        return b64decode(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagbytes", "def", "to_python", "self", "value", "t", "any", "t", "any", "return", "b64decode", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagMarkup.check", "file_path": "src/flask/json/tag.py", "class_name": "TagMarkup", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagMarkup\n    def check(self, value: t.Any) -> bool:\n        return callable(getattr(value, \"__html__\", None))\n", "tokens": ["src", "flask", "json", "tag", "py", "tagmarkup", "def", "check", "self", "value", "t", "any", "bool", "return", "callable", "getattr", "value", "__html__", "none"], "doc_len": 19}
{"doc_id": "src/flask/json/tag.py::TagMarkup.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagMarkup", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagMarkup\n    def to_json(self, value: t.Any) -> t.Any:\n        return str(value.__html__())\n", "tokens": ["src", "flask", "json", "tag", "py", "tagmarkup", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "str", "value", "__html__"], "doc_len": 18}
{"doc_id": "src/flask/json/tag.py::TagMarkup.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagMarkup", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagMarkup\n    def to_python(self, value: t.Any) -> t.Any:\n        return Markup(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagmarkup", "def", "to_python", "self", "value", "t", "any", "t", "any", "return", "markup", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagUUID.check", "file_path": "src/flask/json/tag.py", "class_name": "TagUUID", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagUUID\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, UUID)\n", "tokens": ["src", "flask", "json", "tag", "py", "taguuid", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "uuid"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagUUID.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagUUID", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagUUID\n    def to_json(self, value: t.Any) -> t.Any:\n        return value.hex\n", "tokens": ["src", "flask", "json", "tag", "py", "taguuid", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "value", "hex"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagUUID.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagUUID", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagUUID\n    def to_python(self, value: t.Any) -> t.Any:\n        return UUID(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "taguuid", "def", "to_python", "self", "value", "t", "any", "t", "any", "return", "uuid", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagDateTime.check", "file_path": "src/flask/json/tag.py", "class_name": "TagDateTime", "func_name": "check", "text": "文件路径: src/flask/json/tag.py, 类名: TagDateTime\n    def check(self, value: t.Any) -> bool:\n        return isinstance(value, datetime)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdatetime", "def", "check", "self", "value", "t", "any", "bool", "return", "isinstance", "value", "datetime"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagDateTime.to_json", "file_path": "src/flask/json/tag.py", "class_name": "TagDateTime", "func_name": "to_json", "text": "文件路径: src/flask/json/tag.py, 类名: TagDateTime\n    def to_json(self, value: t.Any) -> t.Any:\n        return http_date(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdatetime", "def", "to_json", "self", "value", "t", "any", "t", "any", "return", "http_date", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TagDateTime.to_python", "file_path": "src/flask/json/tag.py", "class_name": "TagDateTime", "func_name": "to_python", "text": "文件路径: src/flask/json/tag.py, 类名: TagDateTime\n    def to_python(self, value: t.Any) -> t.Any:\n        return parse_date(value)\n", "tokens": ["src", "flask", "json", "tag", "py", "tagdatetime", "def", "to_python", "self", "value", "t", "any", "t", "any", "return", "parse_date", "value"], "doc_len": 17}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.__init__", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "__init__", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def __init__(self) -> None:\n        self.tags: t.Dict[str, JSONTag] = {}\n        self.order: t.List[JSONTag] = []\n\n        for cls in self.default_tags:\n            self.register(cls)\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "__init__", "self", "none", "self", "tags", "t", "dict", "str", "jsontag", "self", "order", "t", "list", "jsontag", "for", "cls", "in", "self", "default_tags", "self", "register", "cls"], "doc_len": 29}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.register", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "register", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def register(\n        self,\n        tag_class: t.Type[JSONTag],\n        force: bool = False,\n        index: t.Optional[int] = None,\n    ) -> None:\n        \"\"\"Register a new tag with this serializer.\n\n        :param tag_class: tag class to register. Will be instantiated with this\n            serializer instance.\n        :param force: overwrite an existing tag. If false (default), a\n            :exc:`KeyError` is raised.\n        :param index: index to insert the new tag in the tag order. Useful when\n            the new tag is a special case of an existing tag. If ``None``\n            (default), the tag is appended to the end of the order.\n\n        :raise KeyError: if the tag key is already registered and ``force`` is\n            not true.\n        \"\"\"\n        tag = tag_class(self)\n        key = tag.key\n\n        if key is not None:\n            if not force and key in self.tags:\n                raise KeyError(f\"Tag '{key}' is already registered.\")\n\n            self.tags[key] = tag\n\n        if index is None:\n            self.order.append(tag)\n        else:\n            self.order.insert(index, tag)\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "register", "self", "tag_class", "t", "type", "jsontag", "force", "bool", "false", "index", "t", "optional", "int", "none", "none", "register", "a", "new", "tag", "with", "this", "serializer", "param", "tag_class", "tag", "class", "to", "register", "will", "be", "instantiated", "with", "this", "serializer", "instance", "param", "force", "overwrite", "an", "existing", "tag", "if", "false", "default", "a", "exc", "keyerror", "is", "raised", "param", "index", "index", "to", "insert", "the", "new", "tag", "in", "the", "tag", "order", "useful", "when", "the", "new", "tag", "is", "a", "special", "case", "of", "an", "existing", "tag", "if", "none", "default", "the", "tag", "is", "appended", "to", "the", "end", "of", "the", "order", "raise", "keyerror", "if", "the", "tag", "key", "is", "already", "registered", "and", "force", "is", "not", "true", "tag", "tag_class", "self", "key", "tag", "key", "if", "key", "is", "not", "none", "if", "not", "force", "and", "key", "in", "self", "tags", "raise", "keyerror", "f", "tag", "key", "is", "already", "registered", "self", "tags", "key", "tag", "if", "index", "is", "none", "self", "order", "append", "tag", "else", "self", "order", "insert", "index", "tag"], "doc_len": 153}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.tag", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "tag", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def tag(self, value: t.Any) -> t.Dict[str, t.Any]:\n        \"\"\"Convert a value to a tagged representation if necessary.\"\"\"\n        for tag in self.order:\n            if tag.check(value):\n                return tag.tag(value)\n\n        return value\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "tag", "self", "value", "t", "any", "t", "dict", "str", "t", "any", "convert", "a", "value", "to", "a", "tagged", "representation", "if", "necessary", "for", "tag", "in", "self", "order", "if", "tag", "check", "value", "return", "tag", "tag", "value", "return", "value"], "doc_len": 41}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.untag", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "untag", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def untag(self, value: t.Dict[str, t.Any]) -> t.Any:\n        \"\"\"Convert a tagged representation back to the original type.\"\"\"\n        if len(value) != 1:\n            return value\n\n        key = next(iter(value))\n\n        if key not in self.tags:\n            return value\n\n        return self.tags[key].to_python(value[key])\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "untag", "self", "value", "t", "dict", "str", "t", "any", "t", "any", "convert", "a", "tagged", "representation", "back", "to", "the", "original", "type", "if", "len", "value", "1", "return", "value", "key", "next", "iter", "value", "if", "key", "not", "in", "self", "tags", "return", "value", "return", "self", "tags", "key", "to_python", "value", "key"], "doc_len": 51}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.dumps", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "dumps", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def dumps(self, value: t.Any) -> str:\n        \"\"\"Tag the value and dump it to a compact JSON string.\"\"\"\n        return dumps(self.tag(value), separators=(\",\", \":\"))\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "dumps", "self", "value", "t", "any", "str", "tag", "the", "value", "and", "dump", "it", "to", "a", "compact", "json", "string", "return", "dumps", "self", "tag", "value", "separators"], "doc_len": 30}
{"doc_id": "src/flask/json/tag.py::TaggedJSONSerializer.loads", "file_path": "src/flask/json/tag.py", "class_name": "TaggedJSONSerializer", "func_name": "loads", "text": "文件路径: src/flask/json/tag.py, 类名: TaggedJSONSerializer\n    def loads(self, value: str) -> t.Any:\n        \"\"\"Load data from a JSON string and deserialized any tagged objects.\"\"\"\n        return loads(value, object_hook=self.untag)\n", "tokens": ["src", "flask", "json", "tag", "py", "taggedjsonserializer", "def", "loads", "self", "value", "str", "t", "any", "load", "data", "from", "a", "json", "string", "and", "deserialized", "any", "tagged", "objects", "return", "loads", "value", "object_hook", "self", "untag"], "doc_len": 30}
{"doc_id": "src/flask/json/__init__.py::dumps", "file_path": "src/flask/json/__init__.py", "class_name": null, "func_name": "dumps", "text": "文件路径: src/flask/json/__init__.py\ndef dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)\n", "tokens": ["src", "flask", "json", "__init__", "py", "def", "dumps", "obj", "t", "any", "kwargs", "t", "any", "str", "serialize", "data", "as", "json", "if", "data", "flask", "current_app", "is", "available", "it", "will", "use", "its", "meth", "app", "json", "dumps", "flask", "json", "provider", "jsonprovider", "dumps", "method", "otherwise", "it", "will", "use", "func", "json", "dumps", "param", "obj", "the", "data", "to", "serialize", "param", "kwargs", "arguments", "passed", "to", "the", "dumps", "implementation", "versionchanged", "2", "3", "the", "app", "parameter", "was", "removed", "versionchanged", "2", "2", "calls", "current_app", "json", "dumps", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "2", "0", "2", "class", "decimal", "decimal", "is", "supported", "by", "converting", "to", "a", "string", "versionchanged", "2", "0", "encoding", "will", "be", "removed", "in", "flask", "2", "1", "versionchanged", "1", "0", "3", "app", "can", "be", "passed", "directly", "rather", "than", "requiring", "an", "app", "context", "for", "configuration", "if", "current_app", "return", "current_app", "json", "dumps", "obj", "kwargs", "kwargs", "setdefault", "default", "_default", "return", "_json", "dumps", "obj", "kwargs"], "doc_len": 140}
{"doc_id": "src/flask/json/__init__.py::dump", "file_path": "src/flask/json/__init__.py", "class_name": null, "func_name": "dump", "text": "文件路径: src/flask/json/__init__.py\ndef dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)\n", "tokens": ["src", "flask", "json", "__init__", "py", "def", "dump", "obj", "t", "any", "fp", "t", "io", "str", "kwargs", "t", "any", "none", "serialize", "data", "as", "json", "and", "write", "to", "a", "file", "if", "data", "flask", "current_app", "is", "available", "it", "will", "use", "its", "meth", "app", "json", "dump", "flask", "json", "provider", "jsonprovider", "dump", "method", "otherwise", "it", "will", "use", "func", "json", "dump", "param", "obj", "the", "data", "to", "serialize", "param", "fp", "a", "file", "opened", "for", "writing", "text", "should", "use", "the", "utf", "8", "encoding", "to", "be", "valid", "json", "param", "kwargs", "arguments", "passed", "to", "the", "dump", "implementation", "versionchanged", "2", "3", "the", "app", "parameter", "was", "removed", "versionchanged", "2", "2", "calls", "current_app", "json", "dump", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "2", "0", "writing", "to", "a", "binary", "file", "and", "the", "encoding", "argument", "will", "be", "removed", "in", "flask", "2", "1", "if", "current_app", "current_app", "json", "dump", "obj", "fp", "kwargs", "else", "kwargs", "setdefault", "default", "_default", "_json", "dump", "obj", "fp", "kwargs"], "doc_len": 145}
{"doc_id": "src/flask/json/__init__.py::loads", "file_path": "src/flask/json/__init__.py", "class_name": null, "func_name": "loads", "text": "文件路径: src/flask/json/__init__.py\ndef loads(s: str | bytes, **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n    method, otherwise it will use :func:`json.loads`.\n\n    :param s: Text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``loads`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.loads``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The data must be a\n        string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.loads(s, **kwargs)\n\n    return _json.loads(s, **kwargs)\n", "tokens": ["src", "flask", "json", "__init__", "py", "def", "loads", "s", "str", "bytes", "kwargs", "t", "any", "t", "any", "deserialize", "data", "as", "json", "if", "data", "flask", "current_app", "is", "available", "it", "will", "use", "its", "meth", "app", "json", "loads", "flask", "json", "provider", "jsonprovider", "loads", "method", "otherwise", "it", "will", "use", "func", "json", "loads", "param", "s", "text", "or", "utf", "8", "bytes", "param", "kwargs", "arguments", "passed", "to", "the", "loads", "implementation", "versionchanged", "2", "3", "the", "app", "parameter", "was", "removed", "versionchanged", "2", "2", "calls", "current_app", "json", "loads", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "2", "0", "encoding", "will", "be", "removed", "in", "flask", "2", "1", "the", "data", "must", "be", "a", "string", "or", "utf", "8", "bytes", "versionchanged", "1", "0", "3", "app", "can", "be", "passed", "directly", "rather", "than", "requiring", "an", "app", "context", "for", "configuration", "if", "current_app", "return", "current_app", "json", "loads", "s", "kwargs", "return", "_json", "loads", "s", "kwargs"], "doc_len": 134}
{"doc_id": "src/flask/json/__init__.py::load", "file_path": "src/flask/json/__init__.py", "class_name": null, "func_name": "load", "text": "文件路径: src/flask/json/__init__.py\ndef load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON read from a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n    method, otherwise it will use :func:`json.load`.\n\n    :param fp: A file opened for reading text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``load`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.load``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.2\n        The ``app`` parameter will be removed in Flask 2.3.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The file must be text\n        mode, or binary mode with UTF-8 bytes.\n    \"\"\"\n    if current_app:\n        return current_app.json.load(fp, **kwargs)\n\n    return _json.load(fp, **kwargs)\n", "tokens": ["src", "flask", "json", "__init__", "py", "def", "load", "fp", "t", "io", "t", "anystr", "kwargs", "t", "any", "t", "any", "deserialize", "data", "as", "json", "read", "from", "a", "file", "if", "data", "flask", "current_app", "is", "available", "it", "will", "use", "its", "meth", "app", "json", "load", "flask", "json", "provider", "jsonprovider", "load", "method", "otherwise", "it", "will", "use", "func", "json", "load", "param", "fp", "a", "file", "opened", "for", "reading", "text", "or", "utf", "8", "bytes", "param", "kwargs", "arguments", "passed", "to", "the", "load", "implementation", "versionchanged", "2", "3", "the", "app", "parameter", "was", "removed", "versionchanged", "2", "2", "calls", "current_app", "json", "load", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "2", "2", "the", "app", "parameter", "will", "be", "removed", "in", "flask", "2", "3", "versionchanged", "2", "0", "encoding", "will", "be", "removed", "in", "flask", "2", "1", "the", "file", "must", "be", "text", "mode", "or", "binary", "mode", "with", "utf", "8", "bytes", "if", "current_app", "return", "current_app", "json", "load", "fp", "kwargs", "return", "_json", "load", "fp", "kwargs"], "doc_len": 144}
{"doc_id": "src/flask/json/__init__.py::jsonify", "file_path": "src/flask/json/__init__.py", "class_name": null, "func_name": "jsonify", "text": "文件路径: src/flask/json/__init__.py\ndef jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    \"\"\"Serialize the given arguments as JSON, and return a\n    :class:`~flask.Response` object with the ``application/json``\n    mimetype. A dict or list returned from a view will be converted to a\n    JSON response automatically without needing to call this.\n\n    This requires an active request or application context, and calls\n    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\n    In debug mode, the output is formatted with indentation to make it\n    easier to read. This may also be controlled by the provider.\n\n    Either positional or keyword arguments can be given, not both.\n    If no arguments are given, ``None`` is serialized.\n\n    :param args: A single value to serialize, or multiple values to\n        treat as a list to serialize.\n    :param kwargs: Treat as a dict to serialize.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.response``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This was a\n        security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return current_app.json.response(*args, **kwargs)\n", "tokens": ["src", "flask", "json", "__init__", "py", "def", "jsonify", "args", "t", "any", "kwargs", "t", "any", "response", "serialize", "the", "given", "arguments", "as", "json", "and", "return", "a", "class", "flask", "response", "object", "with", "the", "application", "json", "mimetype", "a", "dict", "or", "list", "returned", "from", "a", "view", "will", "be", "converted", "to", "a", "json", "response", "automatically", "without", "needing", "to", "call", "this", "this", "requires", "an", "active", "request", "or", "application", "context", "and", "calls", "meth", "app", "json", "response", "flask", "json", "provider", "jsonprovider", "response", "in", "debug", "mode", "the", "output", "is", "formatted", "with", "indentation", "to", "make", "it", "easier", "to", "read", "this", "may", "also", "be", "controlled", "by", "the", "provider", "either", "positional", "or", "keyword", "arguments", "can", "be", "given", "not", "both", "if", "no", "arguments", "are", "given", "none", "is", "serialized", "param", "args", "a", "single", "value", "to", "serialize", "or", "multiple", "values", "to", "treat", "as", "a", "list", "to", "serialize", "param", "kwargs", "treat", "as", "a", "dict", "to", "serialize", "versionchanged", "2", "2", "calls", "current_app", "json", "response", "allowing", "an", "app", "to", "override", "the", "behavior", "versionchanged", "2", "0", "2", "class", "decimal", "decimal", "is", "supported", "by", "converting", "to", "a", "string", "versionchanged", "0", "11", "added", "support", "for", "serializing", "top", "level", "arrays", "this", "was", "a", "security", "risk", "in", "ancient", "browsers", "see", "ref", "security", "json", "versionadded", "0", "2", "return", "current_app", "json", "response", "args", "kwargs"], "doc_len": 197}
{"doc_id": "tests/conftest.py::_standard_os_environ", "file_path": "tests/conftest.py", "class_name": null, "func_name": "_standard_os_environ", "text": "文件路径: tests/conftest.py\ndef _standard_os_environ():\n    \"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"\n    mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, \"FLASK_ENV_FILE\", monkeypatch.notset),\n        (os.environ, \"FLASK_APP\", monkeypatch.notset),\n        (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n        (os.environ, \"FLASK_RUN_FROM_CLI\", monkeypatch.notset),\n        (os.environ, \"WERKZEUG_RUN_MAIN\", monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()\n", "tokens": ["tests", "conftest", "py", "def", "_standard_os_environ", "set", "up", "os", "environ", "at", "the", "start", "of", "the", "test", "session", "to", "have", "standard", "values", "returns", "a", "list", "of", "operations", "that", "is", "used", "by", "func", "_reset_os_environ", "after", "each", "test", "mp", "monkeypatch", "monkeypatch", "out", "os", "environ", "flask_env_file", "monkeypatch", "notset", "os", "environ", "flask_app", "monkeypatch", "notset", "os", "environ", "flask_debug", "monkeypatch", "notset", "os", "environ", "flask_run_from_cli", "monkeypatch", "notset", "os", "environ", "werkzeug_run_main", "monkeypatch", "notset", "for", "_", "key", "value", "in", "out", "if", "value", "is", "monkeypatch", "notset", "mp", "delenv", "key", "false", "else", "mp", "setenv", "key", "value", "yield", "out", "mp", "undo"], "doc_len": 87}
{"doc_id": "tests/conftest.py::_reset_os_environ", "file_path": "tests/conftest.py", "class_name": null, "func_name": "_reset_os_environ", "text": "文件路径: tests/conftest.py\ndef _reset_os_environ(monkeypatch, _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)\n", "tokens": ["tests", "conftest", "py", "def", "_reset_os_environ", "monkeypatch", "_standard_os_environ", "reset", "os", "environ", "to", "the", "standard", "environ", "after", "each", "test", "in", "case", "a", "test", "changed", "something", "without", "cleaning", "up", "monkeypatch", "_setitem", "extend", "_standard_os_environ"], "doc_len": 30}
{"doc_id": "tests/conftest.py::app", "file_path": "tests/conftest.py", "class_name": null, "func_name": "app", "text": "文件路径: tests/conftest.py\ndef app():\n    app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY=\"test key\",\n    )\n    return app\n", "tokens": ["tests", "conftest", "py", "def", "app", "app", "flask", "flask_test", "root_path", "os", "path", "dirname", "__file__", "app", "config", "update", "testing", "true", "secret_key", "test", "key", "return", "app"], "doc_len": 23}
{"doc_id": "tests/conftest.py::app_ctx", "file_path": "tests/conftest.py", "class_name": null, "func_name": "app_ctx", "text": "文件路径: tests/conftest.py\ndef app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx\n", "tokens": ["tests", "conftest", "py", "def", "app_ctx", "app", "with", "app", "app_context", "as", "ctx", "yield", "ctx"], "doc_len": 13}
{"doc_id": "tests/conftest.py::req_ctx", "file_path": "tests/conftest.py", "class_name": null, "func_name": "req_ctx", "text": "文件路径: tests/conftest.py\ndef req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n", "tokens": ["tests", "conftest", "py", "def", "req_ctx", "app", "with", "app", "test_request_context", "as", "ctx", "yield", "ctx"], "doc_len": 13}
{"doc_id": "tests/conftest.py::client", "file_path": "tests/conftest.py", "class_name": null, "func_name": "client", "text": "文件路径: tests/conftest.py\ndef client(app):\n    return app.test_client()\n", "tokens": ["tests", "conftest", "py", "def", "client", "app", "return", "app", "test_client"], "doc_len": 9}
{"doc_id": "tests/conftest.py::test_apps", "file_path": "tests/conftest.py", "class_name": null, "func_name": "test_apps", "text": "文件路径: tests/conftest.py\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for key in sys.modules.keys() - original_modules:\n        sys.modules.pop(key)\n", "tokens": ["tests", "conftest", "py", "def", "test_apps", "monkeypatch", "monkeypatch", "syspath_prepend", "os", "path", "join", "os", "path", "dirname", "__file__", "test_apps", "original_modules", "set", "sys", "modules", "keys", "yield", "remove", "any", "imports", "cached", "during", "the", "test", "otherwise", "import", "app", "will", "work", "in", "the", "next", "test", "even", "though", "it", "s", "no", "longer", "on", "the", "path", "for", "key", "in", "sys", "modules", "keys", "original_modules", "sys", "modules", "pop", "key"], "doc_len": 58}
{"doc_id": "tests/conftest.py::leak_detector", "file_path": "tests/conftest.py", "class_name": null, "func_name": "leak_detector", "text": "文件路径: tests/conftest.py\ndef leak_detector():\n    yield\n\n    # make sure we're not leaking a request context since we are\n    # testing flask internally in debug mode in a few cases\n    leaks = []\n    while request_ctx:\n        leaks.append(request_ctx._get_current_object())\n        request_ctx.pop()\n\n    assert leaks == []\n", "tokens": ["tests", "conftest", "py", "def", "leak_detector", "yield", "make", "sure", "we", "re", "not", "leaking", "a", "request", "context", "since", "we", "are", "testing", "flask", "internally", "in", "debug", "mode", "in", "a", "few", "cases", "leaks", "while", "request_ctx", "leaks", "append", "request_ctx", "_get_current_object", "request_ctx", "pop", "assert", "leaks"], "doc_len": 39}
{"doc_id": "tests/conftest.py::limit_loader", "file_path": "tests/conftest.py", "class_name": null, "func_name": "limit_loader", "text": "文件路径: tests/conftest.py\ndef limit_loader(request, monkeypatch):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n\n    This fixture will run the testcase twice, once with and once without the\n    limitation/mock.\n    \"\"\"\n    if not request.param:\n        return\n\n    class LimitedLoader:\n        def __init__(self, loader):\n            self.loader = loader\n\n        def __getattr__(self, name):\n            if name in {\"archive\", \"get_filename\"}:\n                raise AttributeError(f\"Mocking a loader which does not have {name!r}.\")\n            return getattr(self.loader, name)\n\n    old_get_loader = pkgutil.get_loader\n\n    def get_loader(*args, **kwargs):\n        return LimitedLoader(old_get_loader(*args, **kwargs))\n\n    monkeypatch.setattr(pkgutil, \"get_loader\", get_loader)\n", "tokens": ["tests", "conftest", "py", "def", "limit_loader", "request", "monkeypatch", "patch", "pkgutil", "get_loader", "to", "give", "loader", "without", "get_filename", "or", "archive", "this", "provides", "for", "tests", "where", "a", "system", "has", "custom", "loaders", "e", "g", "google", "app", "engine", "s", "hardenedmoduleshook", "which", "have", "neither", "the", "get_filename", "method", "nor", "the", "archive", "attribute", "this", "fixture", "will", "run", "the", "testcase", "twice", "once", "with", "and", "once", "without", "the", "limitation", "mock", "if", "not", "request", "param", "return", "class", "limitedloader", "def", "__init__", "self", "loader", "self", "loader", "loader", "def", "__getattr__", "self", "name", "if", "name", "in", "archive", "get_filename", "raise", "attributeerror", "f", "mocking", "a", "loader", "which", "does", "not", "have", "name", "r", "return", "getattr", "self", "loader", "name", "old_get_loader", "pkgutil", "get_loader", "def", "get_loader", "args", "kwargs", "return", "limitedloader", "old_get_loader", "args", "kwargs", "monkeypatch", "setattr", "pkgutil", "get_loader", "get_loader"], "doc_len": 116}
{"doc_id": "tests/conftest.py::modules_tmpdir", "file_path": "tests/conftest.py", "class_name": null, "func_name": "modules_tmpdir", "text": "文件路径: tests/conftest.py\ndef modules_tmpdir(tmpdir, monkeypatch):\n    \"\"\"A tmpdir added to sys.path.\"\"\"\n    rv = tmpdir.mkdir(\"modules_tmpdir\")\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n", "tokens": ["tests", "conftest", "py", "def", "modules_tmpdir", "tmpdir", "monkeypatch", "a", "tmpdir", "added", "to", "sys", "path", "rv", "tmpdir", "mkdir", "modules_tmpdir", "monkeypatch", "syspath_prepend", "str", "rv", "return", "rv"], "doc_len": 23}
{"doc_id": "tests/conftest.py::modules_tmpdir_prefix", "file_path": "tests/conftest.py", "class_name": null, "func_name": "modules_tmpdir_prefix", "text": "文件路径: tests/conftest.py\ndef modules_tmpdir_prefix(modules_tmpdir, monkeypatch):\n    monkeypatch.setattr(sys, \"prefix\", str(modules_tmpdir))\n    return modules_tmpdir\n", "tokens": ["tests", "conftest", "py", "def", "modules_tmpdir_prefix", "modules_tmpdir", "monkeypatch", "monkeypatch", "setattr", "sys", "prefix", "str", "modules_tmpdir", "return", "modules_tmpdir"], "doc_len": 15}
{"doc_id": "tests/conftest.py::site_packages", "file_path": "tests/conftest.py", "class_name": null, "func_name": "site_packages", "text": "文件路径: tests/conftest.py\ndef site_packages(modules_tmpdir, monkeypatch):\n    \"\"\"Create a fake site-packages.\"\"\"\n    rv = (\n        modules_tmpdir.mkdir(\"lib\")\n        .mkdir(f\"python{sys.version_info.major}.{sys.version_info.minor}\")\n        .mkdir(\"site-packages\")\n    )\n    monkeypatch.syspath_prepend(str(rv))\n    return rv\n", "tokens": ["tests", "conftest", "py", "def", "site_packages", "modules_tmpdir", "monkeypatch", "create", "a", "fake", "site", "packages", "rv", "modules_tmpdir", "mkdir", "lib", "mkdir", "f", "python", "sys", "version_info", "major", "sys", "version_info", "minor", "mkdir", "site", "packages", "monkeypatch", "syspath_prepend", "str", "rv", "return", "rv"], "doc_len": 34}
{"doc_id": "tests/conftest.py::install_egg", "file_path": "tests/conftest.py", "class_name": null, "func_name": "install_egg", "text": "文件路径: tests/conftest.py\ndef install_egg(modules_tmpdir, monkeypatch):\n    \"\"\"Generate egg from package name inside base and put the egg into\n    sys.path.\"\"\"\n\n    def inner(name, base=modules_tmpdir):\n        base.join(name).ensure_dir()\n        base.join(name).join(\"__init__.py\").ensure()\n\n        egg_setup = base.join(\"setup.py\")\n        egg_setup.write(\n            textwrap.dedent(\n                f\"\"\"\n                from setuptools import setup\n                setup(\n                    name=\"{name}\",\n                    version=\"1.0\",\n                    packages=[\"site_egg\"],\n                    zip_safe=True,\n                )\n                \"\"\"\n            )\n        )\n\n        import subprocess\n\n        subprocess.check_call(\n            [sys.executable, \"setup.py\", \"bdist_egg\"], cwd=str(modules_tmpdir)\n        )\n        (egg_path,) = modules_tmpdir.join(\"dist/\").listdir()\n        monkeypatch.syspath_prepend(str(egg_path))\n        return egg_path\n\n    return inner\n", "tokens": ["tests", "conftest", "py", "def", "install_egg", "modules_tmpdir", "monkeypatch", "generate", "egg", "from", "package", "name", "inside", "base", "and", "put", "the", "egg", "into", "sys", "path", "def", "inner", "name", "base", "modules_tmpdir", "base", "join", "name", "ensure_dir", "base", "join", "name", "join", "__init__", "py", "ensure", "egg_setup", "base", "join", "setup", "py", "egg_setup", "write", "textwrap", "dedent", "f", "from", "setuptools", "import", "setup", "setup", "name", "name", "version", "1", "0", "packages", "site_egg", "zip_safe", "true", "import", "subprocess", "subprocess", "check_call", "sys", "executable", "setup", "py", "bdist_egg", "cwd", "str", "modules_tmpdir", "egg_path", "modules_tmpdir", "join", "dist", "listdir", "monkeypatch", "syspath_prepend", "str", "egg_path", "return", "egg_path", "return", "inner"], "doc_len": 86}
{"doc_id": "tests/conftest.py::purge_module", "file_path": "tests/conftest.py", "class_name": null, "func_name": "purge_module", "text": "文件路径: tests/conftest.py\ndef purge_module(request):\n    def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n\n    return inner\n", "tokens": ["tests", "conftest", "py", "def", "purge_module", "request", "def", "inner", "name", "request", "addfinalizer", "lambda", "sys", "modules", "pop", "name", "none", "return", "inner"], "doc_len": 19}
{"doc_id": "tests/test_appctx.py::test_basic_url_generation", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_basic_url_generation", "text": "文件路径: tests/test_appctx.py\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n", "tokens": ["tests", "test_appctx", "py", "def", "test_basic_url_generation", "app", "app", "config", "server_name", "localhost", "app", "config", "preferred_url_scheme", "https", "app", "route", "def", "index", "pass", "with", "app", "app_context", "rv", "flask", "url_for", "index", "assert", "rv", "https", "localhost"], "doc_len": 30}
{"doc_id": "tests/test_appctx.py::test_url_generation_requires_server_name", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_url_generation_requires_server_name", "text": "文件路径: tests/test_appctx.py\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n", "tokens": ["tests", "test_appctx", "py", "def", "test_url_generation_requires_server_name", "app", "with", "app", "app_context", "with", "pytest", "raises", "runtimeerror", "flask", "url_for", "index"], "doc_len": 16}
{"doc_id": "tests/test_appctx.py::test_url_generation_without_context_fails", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_url_generation_without_context_fails", "text": "文件路径: tests/test_appctx.py\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n", "tokens": ["tests", "test_appctx", "py", "def", "test_url_generation_without_context_fails", "with", "pytest", "raises", "runtimeerror", "flask", "url_for", "index"], "doc_len": 12}
{"doc_id": "tests/test_appctx.py::test_request_context_means_app_context", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_request_context_means_app_context", "text": "文件路径: tests/test_appctx.py\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n", "tokens": ["tests", "test_appctx", "py", "def", "test_request_context_means_app_context", "app", "with", "app", "test_request_context", "assert", "flask", "current_app", "_get_current_object", "is", "app", "assert", "not", "flask", "current_app"], "doc_len": 19}
{"doc_id": "tests/test_appctx.py::test_app_context_provides_current_app", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_context_provides_current_app", "text": "文件路径: tests/test_appctx.py\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_context_provides_current_app", "app", "with", "app", "app_context", "assert", "flask", "current_app", "_get_current_object", "is", "app", "assert", "not", "flask", "current_app"], "doc_len": 19}
{"doc_id": "tests/test_appctx.py::test_app_tearing_down", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_tearing_down", "text": "文件路径: tests/test_appctx.py\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_tearing_down", "app", "cleanup_stuff", "app", "teardown_appcontext", "def", "cleanup", "exception", "cleanup_stuff", "append", "exception", "with", "app", "app_context", "pass", "assert", "cleanup_stuff", "none"], "doc_len": 22}
{"doc_id": "tests/test_appctx.py::test_app_tearing_down_with_previous_exception", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_tearing_down_with_previous_exception", "text": "文件路径: tests/test_appctx.py\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_tearing_down_with_previous_exception", "app", "cleanup_stuff", "app", "teardown_appcontext", "def", "cleanup", "exception", "cleanup_stuff", "append", "exception", "try", "raise", "exception", "dummy", "except", "exception", "pass", "with", "app", "app_context", "pass", "assert", "cleanup_stuff", "none"], "doc_len": 29}
{"doc_id": "tests/test_appctx.py::test_app_tearing_down_with_handled_exception_by_except_block", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_tearing_down_with_handled_exception_by_except_block", "text": "文件路径: tests/test_appctx.py\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_tearing_down_with_handled_exception_by_except_block", "app", "cleanup_stuff", "app", "teardown_appcontext", "def", "cleanup", "exception", "cleanup_stuff", "append", "exception", "with", "app", "app_context", "try", "raise", "exception", "dummy", "except", "exception", "pass", "assert", "cleanup_stuff", "none"], "doc_len": 28}
{"doc_id": "tests/test_appctx.py::test_app_tearing_down_with_handled_exception_by_app_handler", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_tearing_down_with_handled_exception_by_app_handler", "text": "文件路径: tests/test_appctx.py\ndef test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_tearing_down_with_handled_exception_by_app_handler", "app", "client", "app", "config", "propagate_exceptions", "true", "cleanup_stuff", "app", "teardown_appcontext", "def", "cleanup", "exception", "cleanup_stuff", "append", "exception", "app", "route", "def", "index", "raise", "exception", "dummy", "app", "errorhandler", "exception", "def", "handler", "f", "return", "flask", "jsonify", "str", "f", "with", "app", "app_context", "client", "get", "assert", "cleanup_stuff", "none"], "doc_len": 46}
{"doc_id": "tests/test_appctx.py::test_app_tearing_down_with_unhandled_exception", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_tearing_down_with_unhandled_exception", "text": "文件路径: tests/test_appctx.py\ndef test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_tearing_down_with_unhandled_exception", "app", "client", "app", "config", "propagate_exceptions", "true", "cleanup_stuff", "app", "teardown_appcontext", "def", "cleanup", "exception", "cleanup_stuff", "append", "exception", "app", "route", "def", "index", "raise", "valueerror", "dummy", "with", "pytest", "raises", "valueerror", "match", "dummy", "with", "app", "app_context", "client", "get", "assert", "len", "cleanup_stuff", "1", "assert", "isinstance", "cleanup_stuff", "0", "valueerror", "assert", "str", "cleanup_stuff", "0", "dummy"], "doc_len": 52}
{"doc_id": "tests/test_appctx.py::test_app_ctx_globals_methods", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_app_ctx_globals_methods", "text": "文件路径: tests/test_appctx.py\ndef test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n", "tokens": ["tests", "test_appctx", "py", "def", "test_app_ctx_globals_methods", "app", "app_ctx", "get", "assert", "flask", "g", "get", "foo", "is", "none", "assert", "flask", "g", "get", "foo", "bar", "bar", "__contains__", "assert", "foo", "not", "in", "flask", "g", "flask", "g", "foo", "bar", "assert", "foo", "in", "flask", "g", "setdefault", "flask", "g", "setdefault", "bar", "the", "cake", "is", "a", "lie", "flask", "g", "setdefault", "bar", "hello", "world", "assert", "flask", "g", "bar", "the", "cake", "is", "a", "lie", "pop", "assert", "flask", "g", "pop", "bar", "the", "cake", "is", "a", "lie", "with", "pytest", "raises", "keyerror", "flask", "g", "pop", "bar", "assert", "flask", "g", "pop", "bar", "more", "cake", "more", "cake", "__iter__", "assert", "list", "flask", "g", "foo", "__repr__", "assert", "repr", "flask", "g", "flask", "g", "of", "flask_test"], "doc_len": 106}
{"doc_id": "tests/test_appctx.py::test_custom_app_ctx_globals_class", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_custom_app_ctx_globals_class", "text": "文件路径: tests/test_appctx.py\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n", "tokens": ["tests", "test_appctx", "py", "def", "test_custom_app_ctx_globals_class", "app", "class", "customrequestglobals", "def", "__init__", "self", "self", "spam", "eggs", "app", "app_ctx_globals_class", "customrequestglobals", "with", "app", "app_context", "assert", "flask", "render_template_string", "g", "spam", "eggs"], "doc_len": 26}
{"doc_id": "tests/test_appctx.py::test_context_refcounts", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_context_refcounts", "text": "文件路径: tests/test_appctx.py\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n", "tokens": ["tests", "test_appctx", "py", "def", "test_context_refcounts", "app", "client", "called", "app", "teardown_request", "def", "teardown_req", "error", "none", "called", "append", "request", "app", "teardown_appcontext", "def", "teardown_app", "error", "none", "called", "append", "app", "app", "route", "def", "index", "with", "app_ctx", "with", "request_ctx", "pass", "assert", "flask", "request", "environ", "werkzeug", "request", "is", "not", "none", "return", "res", "client", "get", "assert", "res", "status_code", "200", "assert", "res", "data", "b", "assert", "called", "request", "app"], "doc_len": 60}
{"doc_id": "tests/test_appctx.py::test_clean_pop", "file_path": "tests/test_appctx.py", "class_name": null, "func_name": "test_clean_pop", "text": "文件路径: tests/test_appctx.py\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        1 / 0\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    try:\n        with app.test_request_context():\n            called.append(flask.current_app.name)\n    except ZeroDivisionError:\n        pass\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n", "tokens": ["tests", "test_appctx", "py", "def", "test_clean_pop", "app", "app", "testing", "false", "called", "app", "teardown_request", "def", "teardown_req", "error", "none", "1", "0", "app", "teardown_appcontext", "def", "teardown_app", "error", "none", "called", "append", "teardown", "try", "with", "app", "test_request_context", "called", "append", "flask", "current_app", "name", "except", "zerodivisionerror", "pass", "assert", "called", "flask_test", "teardown", "assert", "not", "flask", "current_app"], "doc_len": 47}
{"doc_id": "tests/test_async.py::AsyncView.dispatch_request", "file_path": "tests/test_async.py", "class_name": "AsyncView", "func_name": "dispatch_request", "text": "文件路径: tests/test_async.py, 类名: AsyncView\n    async def dispatch_request(self):\n        await asyncio.sleep(0)\n        return request.method\n", "tokens": ["tests", "test_async", "py", "asyncview", "async", "def", "dispatch_request", "self", "await", "asyncio", "sleep", "0", "return", "request", "method"], "doc_len": 15}
{"doc_id": "tests/test_async.py::AsyncMethodView.get", "file_path": "tests/test_async.py", "class_name": "AsyncMethodView", "func_name": "get", "text": "文件路径: tests/test_async.py, 类名: AsyncMethodView\n    async def get(self):\n        await asyncio.sleep(0)\n        return \"GET\"\n", "tokens": ["tests", "test_async", "py", "asyncmethodview", "async", "def", "get", "self", "await", "asyncio", "sleep", "0", "return", "get"], "doc_len": 14}
{"doc_id": "tests/test_async.py::AsyncMethodView.post", "file_path": "tests/test_async.py", "class_name": "AsyncMethodView", "func_name": "post", "text": "文件路径: tests/test_async.py, 类名: AsyncMethodView\n    async def post(self):\n        await asyncio.sleep(0)\n        return \"POST\"\n", "tokens": ["tests", "test_async", "py", "asyncmethodview", "async", "def", "post", "self", "await", "asyncio", "sleep", "0", "return", "post"], "doc_len": 14}
{"doc_id": "tests/test_async.py::_async_app", "file_path": "tests/test_async.py", "class_name": null, "func_name": "_async_app", "text": "文件路径: tests/test_async.py\ndef _async_app():\n    app = Flask(__name__)\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    @app.route(\"/home\", methods=[\"GET\", \"POST\"])\n    async def index():\n        await asyncio.sleep(0)\n        return request.method\n\n    @app.errorhandler(AppError)\n    async def handle(_):\n        return \"\", 412\n\n    @app.route(\"/error\")\n    async def error():\n        raise AppError()\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def bp_index():\n        await asyncio.sleep(0)\n        return request.method\n\n    @blueprint.errorhandler(BlueprintError)\n    async def bp_handle(_):\n        return \"\", 412\n\n    @blueprint.route(\"/error\")\n    async def bp_error():\n        raise BlueprintError()\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    app.add_url_rule(\"/view\", view_func=AsyncView.as_view(\"view\"))\n    app.add_url_rule(\"/methodview\", view_func=AsyncMethodView.as_view(\"methodview\"))\n\n    return app\n", "tokens": ["tests", "test_async", "py", "def", "_async_app", "app", "flask", "__name__", "app", "route", "methods", "get", "post", "app", "route", "home", "methods", "get", "post", "async", "def", "index", "await", "asyncio", "sleep", "0", "return", "request", "method", "app", "errorhandler", "apperror", "async", "def", "handle", "_", "return", "412", "app", "route", "error", "async", "def", "error", "raise", "apperror", "blueprint", "blueprint", "bp", "__name__", "blueprint", "route", "methods", "get", "post", "async", "def", "bp_index", "await", "asyncio", "sleep", "0", "return", "request", "method", "blueprint", "errorhandler", "blueprinterror", "async", "def", "bp_handle", "_", "return", "412", "blueprint", "route", "error", "async", "def", "bp_error", "raise", "blueprinterror", "app", "register_blueprint", "blueprint", "url_prefix", "bp", "app", "add_url_rule", "view", "view_func", "asyncview", "as_view", "view", "app", "add_url_rule", "methodview", "view_func", "asyncmethodview", "as_view", "methodview", "return", "app"], "doc_len": 103}
{"doc_id": "tests/test_async.py::test_async_route", "file_path": "tests/test_async.py", "class_name": null, "func_name": "test_async_route", "text": "文件路径: tests/test_async.py\ndef test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()\n", "tokens": ["tests", "test_async", "py", "def", "test_async_route", "path", "async_app", "test_client", "async_app", "test_client", "response", "test_client", "get", "path", "assert", "b", "get", "in", "response", "get_data", "response", "test_client", "post", "path", "assert", "b", "post", "in", "response", "get_data"], "doc_len": 30}
{"doc_id": "tests/test_async.py::test_async_error_handler", "file_path": "tests/test_async.py", "class_name": null, "func_name": "test_async_error_handler", "text": "文件路径: tests/test_async.py\ndef test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412\n", "tokens": ["tests", "test_async", "py", "def", "test_async_error_handler", "path", "async_app", "test_client", "async_app", "test_client", "response", "test_client", "get", "path", "assert", "response", "status_code", "412"], "doc_len": 18}
{"doc_id": "tests/test_async.py::test_async_before_after_request", "file_path": "tests/test_async.py", "class_name": null, "func_name": "test_async_before_after_request", "text": "文件路径: tests/test_async.py\ndef test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called\n", "tokens": ["tests", "test_async", "py", "def", "test_async_before_after_request", "app_before_called", "false", "app_after_called", "false", "bp_before_called", "false", "bp_after_called", "false", "app", "flask", "__name__", "app", "route", "def", "index", "return", "app", "before_request", "async", "def", "before", "nonlocal", "app_before_called", "app_before_called", "true", "app", "after_request", "async", "def", "after", "response", "nonlocal", "app_after_called", "app_after_called", "true", "return", "response", "blueprint", "blueprint", "bp", "__name__", "blueprint", "route", "def", "bp_index", "return", "blueprint", "before_request", "async", "def", "bp_before", "nonlocal", "bp_before_called", "bp_before_called", "true", "blueprint", "after_request", "async", "def", "bp_after", "response", "nonlocal", "bp_after_called", "bp_after_called", "true", "return", "response", "app", "register_blueprint", "blueprint", "url_prefix", "bp", "test_client", "app", "test_client", "test_client", "get", "assert", "app_before_called", "assert", "app_after_called", "test_client", "get", "bp", "assert", "bp_before_called", "assert", "bp_after_called"], "doc_len": 93}
{"doc_id": "tests/test_basic.py::test_options_work", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_options_work", "text": "文件路径: tests/test_basic.py\ndef test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_options_work", "app", "client", "app", "route", "methods", "get", "post", "def", "index", "return", "hello", "world", "rv", "client", "open", "method", "options", "assert", "sorted", "rv", "allow", "get", "head", "options", "post", "assert", "rv", "data", "b"], "doc_len": 34}
{"doc_id": "tests/test_basic.py::test_options_on_multiple_rules", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_options_on_multiple_rules", "text": "文件路径: tests/test_basic.py\ndef test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]\n", "tokens": ["tests", "test_basic", "py", "def", "test_options_on_multiple_rules", "app", "client", "app", "route", "methods", "get", "post", "def", "index", "return", "hello", "world", "app", "route", "methods", "put", "def", "index_put", "return", "aha", "rv", "client", "open", "method", "options", "assert", "sorted", "rv", "allow", "get", "head", "options", "post", "put"], "doc_len": 39}
{"doc_id": "tests/test_basic.py::test_method_route", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_method_route", "text": "文件路径: tests/test_basic.py\ndef test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_method_route", "app", "client", "method", "method_route", "getattr", "app", "method", "client_method", "getattr", "client", "method", "method_route", "def", "hello", "return", "hello", "assert", "client_method", "data", "b", "hello"], "doc_len": 26}
{"doc_id": "tests/test_basic.py::test_method_route_no_methods", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_method_route_no_methods", "text": "文件路径: tests/test_basic.py\ndef test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])\n", "tokens": ["tests", "test_basic", "py", "def", "test_method_route_no_methods", "app", "with", "pytest", "raises", "typeerror", "app", "get", "methods", "get", "post"], "doc_len": 15}
{"doc_id": "tests/test_basic.py::test_provide_automatic_options_attr", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_provide_automatic_options_attr", "text": "文件路径: tests/test_basic.py\ndef test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n", "tokens": ["tests", "test_basic", "py", "def", "test_provide_automatic_options_attr", "app", "flask", "flask", "__name__", "def", "index", "return", "hello", "world", "index", "provide_automatic_options", "false", "app", "route", "index", "rv", "app", "test_client", "open", "method", "options", "assert", "rv", "status_code", "405", "app", "flask", "flask", "__name__", "def", "index2", "return", "hello", "world", "index2", "provide_automatic_options", "true", "app", "route", "methods", "options", "index2", "rv", "app", "test_client", "open", "method", "options", "assert", "sorted", "rv", "allow", "options"], "doc_len": 58}
{"doc_id": "tests/test_basic.py::test_provide_automatic_options_kwarg", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_provide_automatic_options_kwarg", "text": "文件路径: tests/test_basic.py\ndef test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n", "tokens": ["tests", "test_basic", "py", "def", "test_provide_automatic_options_kwarg", "app", "client", "def", "index", "return", "flask", "request", "method", "def", "more", "return", "flask", "request", "method", "app", "add_url_rule", "view_func", "index", "provide_automatic_options", "false", "app", "add_url_rule", "more", "view_func", "more", "methods", "get", "post", "provide_automatic_options", "false", "assert", "client", "get", "data", "b", "get", "rv", "client", "post", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "rv", "client", "open", "method", "options", "assert", "rv", "status_code", "405", "rv", "client", "head", "assert", "rv", "status_code", "200", "assert", "not", "rv", "data", "head", "truncates", "assert", "client", "post", "more", "data", "b", "post", "assert", "client", "get", "more", "data", "b", "get", "rv", "client", "delete", "more", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "post", "rv", "client", "open", "more", "method", "options", "assert", "rv", "status_code", "405"], "doc_len": 115}
{"doc_id": "tests/test_basic.py::test_request_dispatching", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_request_dispatching", "text": "文件路径: tests/test_basic.py\ndef test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n", "tokens": ["tests", "test_basic", "py", "def", "test_request_dispatching", "app", "client", "app", "route", "def", "index", "return", "flask", "request", "method", "app", "route", "more", "methods", "get", "post", "def", "more", "return", "flask", "request", "method", "assert", "client", "get", "data", "b", "get", "rv", "client", "post", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "options", "rv", "client", "head", "assert", "rv", "status_code", "200", "assert", "not", "rv", "data", "head", "truncates", "assert", "client", "post", "more", "data", "b", "post", "assert", "client", "get", "more", "data", "b", "get", "rv", "client", "delete", "more", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "options", "post"], "doc_len": 90}
{"doc_id": "tests/test_basic.py::test_disallow_string_for_allowed_methods", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_disallow_string_for_allowed_methods", "text": "文件路径: tests/test_basic.py\ndef test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_disallow_string_for_allowed_methods", "app", "with", "pytest", "raises", "typeerror", "app", "add_url_rule", "methods", "get", "post", "endpoint", "test"], "doc_len": 17}
{"doc_id": "tests/test_basic.py::test_url_mapping", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_url_mapping", "text": "文件路径: tests/test_basic.py\ndef test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_url_mapping", "app", "client", "random_uuid4", "7eb41166", "9ebf", "4d26", "b771", "ea3f54f8b383", "def", "index", "return", "flask", "request", "method", "def", "more", "return", "flask", "request", "method", "def", "options", "return", "random_uuid4", "app", "add_url_rule", "index", "index", "app", "add_url_rule", "more", "more", "more", "methods", "get", "post", "issue", "1288", "test", "that", "automatic", "options", "are", "not", "added", "when", "non", "uppercase", "options", "in", "methods", "app", "add_url_rule", "options", "options", "options", "methods", "options", "assert", "client", "get", "data", "b", "get", "rv", "client", "post", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "options", "rv", "client", "head", "assert", "rv", "status_code", "200", "assert", "not", "rv", "data", "head", "truncates", "assert", "client", "post", "more", "data", "b", "post", "assert", "client", "get", "more", "data", "b", "get", "rv", "client", "delete", "more", "assert", "rv", "status_code", "405", "assert", "sorted", "rv", "allow", "get", "head", "options", "post", "rv", "client", "open", "options", "method", "options", "assert", "rv", "status_code", "200", "assert", "random_uuid4", "in", "rv", "data", "decode", "utf", "8"], "doc_len": 144}
{"doc_id": "tests/test_basic.py::test_werkzeug_routing", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_werkzeug_routing", "text": "文件路径: tests/test_basic.py\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_werkzeug_routing", "app", "client", "from", "werkzeug", "routing", "import", "submount", "rule", "app", "url_map", "add", "submount", "foo", "rule", "bar", "endpoint", "bar", "rule", "endpoint", "index", "def", "bar", "return", "bar", "def", "index", "return", "index", "app", "view_functions", "bar", "bar", "app", "view_functions", "index", "index", "assert", "client", "get", "foo", "data", "b", "index", "assert", "client", "get", "foo", "bar", "data", "b", "bar"], "doc_len": 56}
{"doc_id": "tests/test_basic.py::test_endpoint_decorator", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_endpoint_decorator", "text": "文件路径: tests/test_basic.py\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Submount, Rule\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_endpoint_decorator", "app", "client", "from", "werkzeug", "routing", "import", "submount", "rule", "app", "url_map", "add", "submount", "foo", "rule", "bar", "endpoint", "bar", "rule", "endpoint", "index", "app", "endpoint", "bar", "def", "bar", "return", "bar", "app", "endpoint", "index", "def", "index", "return", "index", "assert", "client", "get", "foo", "data", "b", "index", "assert", "client", "get", "foo", "bar", "data", "b", "bar"], "doc_len": 54}
{"doc_id": "tests/test_basic.py::test_session", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session", "text": "文件路径: tests/test_basic.py\ndef test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_session", "app", "client", "app", "route", "set", "methods", "post", "def", "set", "assert", "not", "flask", "session", "accessed", "assert", "not", "flask", "session", "modified", "flask", "session", "value", "flask", "request", "form", "value", "assert", "flask", "session", "accessed", "assert", "flask", "session", "modified", "return", "value", "set", "app", "route", "get", "def", "get", "assert", "not", "flask", "session", "accessed", "assert", "not", "flask", "session", "modified", "v", "flask", "session", "get", "value", "none", "assert", "flask", "session", "accessed", "assert", "not", "flask", "session", "modified", "return", "v", "assert", "client", "post", "set", "data", "value", "42", "data", "b", "value", "set", "assert", "client", "get", "get", "data", "b", "42"], "doc_len": 92}
{"doc_id": "tests/test_basic.py::test_session_using_server_name", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_server_name", "text": "文件路径: tests/test_basic.py\ndef test_session_using_server_name(app, client):\n    app.config.update(SERVER_NAME=\"example.com\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_server_name", "app", "client", "app", "config", "update", "server_name", "example", "com", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "rv", "client", "get", "http", "example", "com", "assert", "domain", "example", "com", "in", "rv", "headers", "set", "cookie", "lower", "assert", "httponly", "in", "rv", "headers", "set", "cookie", "lower"], "doc_len": 48}
{"doc_id": "tests/test_basic.py::test_session_using_server_name_and_port", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_server_name_and_port", "text": "文件路径: tests/test_basic.py\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"domain=.example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_server_name_and_port", "app", "client", "app", "config", "update", "server_name", "example", "com", "8080", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "rv", "client", "get", "http", "example", "com", "8080", "assert", "domain", "example", "com", "in", "rv", "headers", "set", "cookie", "lower", "assert", "httponly", "in", "rv", "headers", "set", "cookie", "lower"], "doc_len": 50}
{"doc_id": "tests/test_basic.py::test_session_using_server_name_port_and_path", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_server_name_port_and_path", "text": "文件路径: tests/test_basic.py\ndef test_session_using_server_name_port_and_path(app, client):\n    app.config.update(SERVER_NAME=\"example.com:8080\", APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"domain=example.com\" in rv.headers[\"set-cookie\"].lower()\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()\n    assert \"httponly\" in rv.headers[\"set-cookie\"].lower()\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_server_name_port_and_path", "app", "client", "app", "config", "update", "server_name", "example", "com", "8080", "application_root", "foo", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "rv", "client", "get", "http", "example", "com", "8080", "foo", "assert", "domain", "example", "com", "in", "rv", "headers", "set", "cookie", "lower", "assert", "path", "foo", "in", "rv", "headers", "set", "cookie", "lower", "assert", "httponly", "in", "rv", "headers", "set", "cookie", "lower"], "doc_len": 62}
{"doc_id": "tests/test_basic.py::test_session_using_application_root", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_application_root", "text": "文件路径: tests/test_basic.py\ndef test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_application_root", "app", "client", "class", "prefixpathmiddleware", "def", "__init__", "self", "app", "prefix", "self", "app", "app", "self", "prefix", "prefix", "def", "__call__", "self", "environ", "start_response", "environ", "script_name", "self", "prefix", "return", "self", "app", "environ", "start_response", "app", "wsgi_app", "prefixpathmiddleware", "app", "wsgi_app", "bar", "app", "config", "update", "application_root", "bar", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "rv", "client", "get", "http", "example", "com", "8080", "assert", "path", "bar", "in", "rv", "headers", "set", "cookie", "lower"], "doc_len": 72}
{"doc_id": "tests/test_basic.py::test_session_using_session_settings", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_session_settings", "text": "文件路径: tests/test_basic.py\ndef test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    assert \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_session_settings", "app", "client", "app", "config", "update", "server_name", "www", "example", "com", "8080", "application_root", "test", "session_cookie_domain", "example", "com", "session_cookie_httponly", "false", "session_cookie_secure", "true", "session_cookie_samesite", "lax", "session_cookie_path", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "app", "route", "clear", "def", "clear", "flask", "session", "pop", "testing", "none", "return", "goodbye", "world", "rv", "client", "get", "http", "www", "example", "com", "8080", "test", "cookie", "rv", "headers", "set", "cookie", "lower", "assert", "domain", "example", "com", "in", "cookie", "assert", "path", "in", "cookie", "assert", "secure", "in", "cookie", "assert", "httponly", "not", "in", "cookie", "assert", "samesite", "in", "cookie", "rv", "client", "get", "clear", "http", "www", "example", "com", "8080", "test", "cookie", "rv", "headers", "set", "cookie", "lower", "assert", "session", "in", "cookie", "assert", "domain", "example", "com", "in", "cookie", "assert", "path", "in", "cookie", "assert", "secure", "in", "cookie", "assert", "samesite", "in", "cookie"], "doc_len": 127}
{"doc_id": "tests/test_basic.py::test_session_using_samesite_attribute", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_using_samesite_attribute", "text": "文件路径: tests/test_basic.py\ndef test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_using_samesite_attribute", "app", "client", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "hello", "world", "app", "config", "update", "session_cookie_samesite", "invalid", "with", "pytest", "raises", "valueerror", "client", "get", "app", "config", "update", "session_cookie_samesite", "none", "rv", "client", "get", "cookie", "rv", "headers", "set", "cookie", "lower", "assert", "samesite", "not", "in", "cookie", "app", "config", "update", "session_cookie_samesite", "strict", "rv", "client", "get", "cookie", "rv", "headers", "set", "cookie", "lower", "assert", "samesite", "strict", "in", "cookie", "app", "config", "update", "session_cookie_samesite", "lax", "rv", "client", "get", "cookie", "rv", "headers", "set", "cookie", "lower", "assert", "samesite", "lax", "in", "cookie"], "doc_len": 86}
{"doc_id": "tests/test_basic.py::test_session_localhost_warning", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_localhost_warning", "text": "文件路径: tests/test_basic.py\ndef test_session_localhost_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"localhost:5000\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"/\", \"http://localhost:5000/\")\n    assert \"domain\" not in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"'localhost' is not a valid cookie domain\" in str(w.message)\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_localhost_warning", "recwarn", "app", "client", "app", "config", "update", "server_name", "localhost", "5000", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "testing", "rv", "client", "get", "http", "localhost", "5000", "assert", "domain", "not", "in", "rv", "headers", "set", "cookie", "lower", "w", "recwarn", "pop", "userwarning", "assert", "localhost", "is", "not", "a", "valid", "cookie", "domain", "in", "str", "w", "message"], "doc_len": 55}
{"doc_id": "tests/test_basic.py::test_session_ip_warning", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_ip_warning", "text": "文件路径: tests/test_basic.py\ndef test_session_ip_warning(recwarn, app, client):\n    app.config.update(SERVER_NAME=\"127.0.0.1:5000\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"testing\"\n\n    rv = client.get(\"/\", \"http://127.0.0.1:5000/\")\n    assert \"domain=127.0.0.1\" in rv.headers[\"set-cookie\"].lower()\n    w = recwarn.pop(UserWarning)\n    assert \"cookie domain is an IP\" in str(w.message)\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_ip_warning", "recwarn", "app", "client", "app", "config", "update", "server_name", "127", "0", "0", "1", "5000", "app", "route", "def", "index", "flask", "session", "testing", "42", "return", "testing", "rv", "client", "get", "http", "127", "0", "0", "1", "5000", "assert", "domain", "127", "0", "0", "1", "in", "rv", "headers", "set", "cookie", "lower", "w", "recwarn", "pop", "userwarning", "assert", "cookie", "domain", "is", "an", "ip", "in", "str", "w", "message"], "doc_len": 62}
{"doc_id": "tests/test_basic.py::test_missing_session", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_missing_session", "text": "文件路径: tests/test_basic.py\ndef test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_missing_session", "app", "app", "secret_key", "none", "def", "expect_exception", "f", "args", "kwargs", "e", "pytest", "raises", "runtimeerror", "f", "args", "kwargs", "assert", "e", "value", "args", "and", "session", "is", "unavailable", "in", "e", "value", "args", "0", "with", "app", "test_request_context", "assert", "flask", "session", "get", "missing_key", "is", "none", "expect_exception", "flask", "session", "__setitem__", "foo", "42", "expect_exception", "flask", "session", "pop", "foo"], "doc_len": 55}
{"doc_id": "tests/test_basic.py::test_session_expiration", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_expiration", "text": "文件路径: tests/test_basic.py\ndef test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_expiration", "app", "client", "permanent", "true", "app", "route", "def", "index", "flask", "session", "test", "42", "flask", "session", "permanent", "permanent", "return", "app", "route", "test", "def", "test", "return", "str", "flask", "session", "permanent", "rv", "client", "get", "assert", "set", "cookie", "in", "rv", "headers", "match", "re", "search", "r", "i", "bexpires", "rv", "headers", "set", "cookie", "expires", "parse_date", "match", "group", "expected", "datetime", "now", "timezone", "utc", "app", "permanent_session_lifetime", "assert", "expires", "year", "expected", "year", "assert", "expires", "month", "expected", "month", "assert", "expires", "day", "expected", "day", "rv", "client", "get", "test", "assert", "rv", "data", "b", "true", "permanent", "false", "rv", "client", "get", "assert", "set", "cookie", "in", "rv", "headers", "match", "re", "search", "r", "bexpires", "rv", "headers", "set", "cookie", "assert", "match", "is", "none"], "doc_len": 110}
{"doc_id": "tests/test_basic.py::test_session_stored_last", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_stored_last", "text": "文件路径: tests/test_basic.py\ndef test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_stored_last", "app", "client", "app", "after_request", "def", "modify_session", "response", "flask", "session", "foo", "42", "return", "response", "app", "route", "def", "dump_session_contents", "return", "repr", "flask", "session", "get", "foo", "assert", "client", "get", "data", "b", "none", "assert", "client", "get", "data", "b", "42"], "doc_len": 40}
{"doc_id": "tests/test_basic.py::test_session_special_types", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_special_types", "text": "文件路径: tests/test_basic.py\ndef test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) == bytes\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) == Markup\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_special_types", "app", "client", "now", "datetime", "now", "timezone", "utc", "replace", "microsecond", "0", "the_uuid", "uuid", "uuid4", "app", "route", "def", "dump_session_contents", "flask", "session", "t", "1", "2", "3", "flask", "session", "b", "b", "xff", "flask", "session", "m", "markup", "html", "flask", "session", "u", "the_uuid", "flask", "session", "d", "now", "flask", "session", "t_tag", "t", "not", "a", "tuple", "flask", "session", "di_t_tag", "t__", "not", "a", "tuple", "flask", "session", "di_tag", "di", "not", "a", "dict", "return", "204", "with", "client", "client", "get", "s", "flask", "session", "assert", "s", "t", "1", "2", "3", "assert", "type", "s", "b", "bytes", "assert", "s", "b", "b", "xff", "assert", "type", "s", "m", "markup", "assert", "s", "m", "markup", "html", "assert", "s", "u", "the_uuid", "assert", "s", "d", "now", "assert", "s", "t_tag", "t", "not", "a", "tuple", "assert", "s", "di_t_tag", "t__", "not", "a", "tuple", "assert", "s", "di_tag", "di", "not", "a", "dict"], "doc_len": 131}
{"doc_id": "tests/test_basic.py::test_session_cookie_setting", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_cookie_setting", "text": "文件路径: tests/test_basic.py\ndef test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_cookie_setting", "app", "is_permanent", "true", "app", "route", "bump", "def", "bump", "rv", "flask", "session", "foo", "flask", "session", "get", "foo", "0", "1", "flask", "session", "permanent", "is_permanent", "return", "str", "rv", "app", "route", "read", "def", "read", "return", "str", "flask", "session", "get", "foo", "0", "def", "run_test", "expect_header", "with", "app", "test_client", "as", "c", "assert", "c", "get", "bump", "data", "b", "1", "assert", "c", "get", "bump", "data", "b", "2", "assert", "c", "get", "bump", "data", "b", "3", "rv", "c", "get", "read", "set_cookie", "rv", "headers", "get", "set", "cookie", "assert", "set_cookie", "is", "not", "none", "expect_header", "assert", "rv", "data", "b", "3", "is_permanent", "true", "app", "config", "session_refresh_each_request", "true", "run_test", "expect_header", "true", "is_permanent", "true", "app", "config", "session_refresh_each_request", "false", "run_test", "expect_header", "false", "is_permanent", "false", "app", "config", "session_refresh_each_request", "true", "run_test", "expect_header", "false", "is_permanent", "false", "app", "config", "session_refresh_each_request", "false", "run_test", "expect_header", "false"], "doc_len": 128}
{"doc_id": "tests/test_basic.py::test_session_vary_cookie", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_session_vary_cookie", "text": "文件路径: tests/test_basic.py\ndef test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)\n", "tokens": ["tests", "test_basic", "py", "def", "test_session_vary_cookie", "app", "client", "app", "route", "set", "def", "set_session", "flask", "session", "test", "test", "return", "app", "route", "get", "def", "get", "return", "flask", "session", "get", "test", "app", "route", "getitem", "def", "getitem", "return", "flask", "session", "test", "app", "route", "setdefault", "def", "setdefault", "return", "flask", "session", "setdefault", "test", "default", "app", "route", "vary", "cookie", "header", "set", "def", "vary_cookie_header_set", "response", "flask", "response", "response", "vary", "add", "cookie", "flask", "session", "test", "test", "return", "response", "app", "route", "vary", "header", "set", "def", "vary_header_set", "response", "flask", "response", "response", "vary", "update", "accept", "encoding", "accept", "language", "flask", "session", "test", "test", "return", "response", "app", "route", "no", "vary", "header", "def", "no_vary_header", "return", "def", "expect", "path", "header_value", "cookie", "rv", "client", "get", "path", "if", "header_value", "the", "vary", "key", "should", "exist", "in", "the", "headers", "only", "once", "assert", "len", "rv", "headers", "get_all", "vary", "1", "assert", "rv", "headers", "vary", "header_value", "else", "assert", "vary", "not", "in", "rv", "headers", "expect", "set", "expect", "get", "expect", "getitem", "expect", "setdefault", "expect", "vary", "cookie", "header", "set", "expect", "vary", "header", "set", "accept", "encoding", "accept", "language", "cookie", "expect", "no", "vary", "header", "none"], "doc_len": 166}
{"doc_id": "tests/test_basic.py::test_flashes", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_flashes", "text": "文件路径: tests/test_basic.py\ndef test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]\n", "tokens": ["tests", "test_basic", "py", "def", "test_flashes", "app", "req_ctx", "assert", "not", "flask", "session", "modified", "flask", "flash", "zap", "flask", "session", "modified", "false", "flask", "flash", "zip", "assert", "flask", "session", "modified", "assert", "list", "flask", "get_flashed_messages", "zap", "zip"], "doc_len": 32}
{"doc_id": "tests/test_basic.py::test_extended_flashing", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_extended_flashing", "text": "文件路径: tests/test_basic.py\ndef test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_extended_flashing", "app", "be", "sure", "app", "testing", "true", "below", "else", "tests", "can", "fail", "silently", "specifically", "if", "app", "testing", "is", "not", "set", "to", "true", "the", "assertionerrors", "in", "the", "view", "functions", "will", "cause", "a", "500", "response", "to", "the", "test", "client", "instead", "of", "propagating", "exceptions", "app", "route", "def", "index", "flask", "flash", "hello", "world", "flask", "flash", "hello", "world", "error", "flask", "flash", "markup", "em", "testing", "em", "warning", "return", "app", "route", "test", "def", "test", "messages", "flask", "get_flashed_messages", "assert", "list", "messages", "hello", "world", "hello", "world", "markup", "em", "testing", "em", "return", "app", "route", "test_with_categories", "def", "test_with_categories", "messages", "flask", "get_flashed_messages", "with_categories", "true", "assert", "len", "messages", "3", "assert", "list", "messages", "message", "hello", "world", "error", "hello", "world", "warning", "markup", "em", "testing", "em", "return", "app", "route", "test_filter", "def", "test_filter", "messages", "flask", "get_flashed_messages", "category_filter", "message", "with_categories", "true", "assert", "list", "messages", "message", "hello", "world", "return", "app", "route", "test_filters", "def", "test_filters", "messages", "flask", "get_flashed_messages", "category_filter", "message", "warning", "with_categories", "true", "assert", "list", "messages", "message", "hello", "world", "warning", "markup", "em", "testing", "em", "return", "app", "route", "test_filters_without_returning_categories", "def", "test_filters2", "messages", "flask", "get_flashed_messages", "category_filter", "message", "warning", "assert", "len", "messages", "2", "assert", "messages", "0", "hello", "world", "assert", "messages", "1", "markup", "em", "testing", "em", "return", "create", "new", "test", "client", "on", "each", "test", "to", "clean", "flashed", "messages", "client", "app", "test_client", "client", "get", "client", "get", "test_with_categories", "client", "app", "test_client", "client", "get", "client", "get", "test_filter", "client", "app", "test_client", "client", "get", "client", "get", "test_filters", "client", "app", "test_client", "client", "get", "client", "get", "test_filters_without_returning_categories"], "doc_len": 230}
{"doc_id": "tests/test_basic.py::test_request_processing", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_request_processing", "text": "文件路径: tests/test_basic.py\ndef test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_request_processing", "app", "client", "evts", "app", "before_request", "def", "before_request", "evts", "append", "before", "app", "after_request", "def", "after_request", "response", "response", "data", "b", "after", "evts", "append", "after", "return", "response", "app", "route", "def", "index", "assert", "before", "in", "evts", "assert", "after", "not", "in", "evts", "return", "request", "assert", "after", "not", "in", "evts", "rv", "client", "get", "data", "assert", "after", "in", "evts", "assert", "rv", "b", "request", "after"], "doc_len": 62}
{"doc_id": "tests/test_basic.py::test_request_preprocessing_early_return", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_request_preprocessing_early_return", "text": "文件路径: tests/test_basic.py\ndef test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]\n", "tokens": ["tests", "test_basic", "py", "def", "test_request_preprocessing_early_return", "app", "client", "evts", "app", "before_request", "def", "before_request1", "evts", "append", "1", "app", "before_request", "def", "before_request2", "evts", "append", "2", "return", "hello", "app", "before_request", "def", "before_request3", "evts", "append", "3", "return", "bye", "app", "route", "def", "index", "evts", "append", "index", "return", "damnit", "rv", "client", "get", "data", "strip", "assert", "rv", "b", "hello", "assert", "evts", "1", "2"], "doc_len": 55}
{"doc_id": "tests/test_basic.py::test_after_request_processing", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_after_request_processing", "text": "文件路径: tests/test_basic.py\ndef test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_after_request_processing", "app", "client", "app", "route", "def", "index", "flask", "after_this_request", "def", "foo", "response", "response", "headers", "x", "foo", "a", "header", "return", "response", "return", "test", "resp", "client", "get", "assert", "resp", "status_code", "200", "assert", "resp", "headers", "x", "foo", "a", "header"], "doc_len": 40}
{"doc_id": "tests/test_basic.py::test_teardown_request_handler", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_teardown_request_handler", "text": "文件路径: tests/test_basic.py\ndef test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n", "tokens": ["tests", "test_basic", "py", "def", "test_teardown_request_handler", "app", "client", "called", "app", "teardown_request", "def", "teardown_request", "exc", "called", "append", "true", "return", "ignored", "app", "route", "def", "root", "return", "response", "rv", "client", "get", "assert", "rv", "status_code", "200", "assert", "b", "response", "in", "rv", "data", "assert", "len", "called", "1"], "doc_len": 41}
{"doc_id": "tests/test_basic.py::test_teardown_request_handler_debug_mode", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_teardown_request_handler_debug_mode", "text": "文件路径: tests/test_basic.py\ndef test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1\n", "tokens": ["tests", "test_basic", "py", "def", "test_teardown_request_handler_debug_mode", "app", "client", "called", "app", "teardown_request", "def", "teardown_request", "exc", "called", "append", "true", "return", "ignored", "app", "route", "def", "root", "return", "response", "rv", "client", "get", "assert", "rv", "status_code", "200", "assert", "b", "response", "in", "rv", "data", "assert", "len", "called", "1"], "doc_len": 41}
{"doc_id": "tests/test_basic.py::test_teardown_request_handler_error", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_teardown_request_handler_error", "text": "文件路径: tests/test_basic.py\ndef test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) == ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        1 // 0\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2\n", "tokens": ["tests", "test_basic", "py", "def", "test_teardown_request_handler_error", "app", "client", "called", "app", "testing", "false", "app", "teardown_request", "def", "teardown_request1", "exc", "assert", "type", "exc", "zerodivisionerror", "called", "append", "true", "this", "raises", "a", "new", "error", "and", "blows", "away", "sys", "exc_info", "so", "we", "can", "test", "that", "all", "teardown_requests", "get", "passed", "the", "same", "original", "exception", "try", "raise", "typeerror", "except", "exception", "pass", "app", "teardown_request", "def", "teardown_request2", "exc", "assert", "type", "exc", "zerodivisionerror", "called", "append", "true", "this", "raises", "a", "new", "error", "and", "blows", "away", "sys", "exc_info", "so", "we", "can", "test", "that", "all", "teardown_requests", "get", "passed", "the", "same", "original", "exception", "try", "raise", "typeerror", "except", "exception", "pass", "app", "route", "def", "fails", "1", "0", "rv", "client", "get", "assert", "rv", "status_code", "500", "assert", "b", "internal", "server", "error", "in", "rv", "data", "assert", "len", "called", "2"], "doc_len": 118}
{"doc_id": "tests/test_basic.py::test_before_after_request_order", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_before_after_request_order", "text": "文件路径: tests/test_basic.py\ndef test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]\n", "tokens": ["tests", "test_basic", "py", "def", "test_before_after_request_order", "app", "client", "called", "app", "before_request", "def", "before1", "called", "append", "1", "app", "before_request", "def", "before2", "called", "append", "2", "app", "after_request", "def", "after1", "response", "called", "append", "4", "return", "response", "app", "after_request", "def", "after2", "response", "called", "append", "3", "return", "response", "app", "teardown_request", "def", "finish1", "exc", "called", "append", "6", "app", "teardown_request", "def", "finish2", "exc", "called", "append", "5", "app", "route", "def", "index", "return", "42", "rv", "client", "get", "assert", "rv", "data", "b", "42", "assert", "called", "1", "2", "3", "4", "5", "6"], "doc_len": 80}
{"doc_id": "tests/test_basic.py::test_error_handling", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_error_handling", "text": "文件路径: tests/test_basic.py\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        1 // 0\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n", "tokens": ["tests", "test_basic", "py", "def", "test_error_handling", "app", "client", "app", "testing", "false", "app", "errorhandler", "404", "def", "not_found", "e", "return", "not", "found", "404", "app", "errorhandler", "500", "def", "internal_server_error", "e", "return", "internal", "server", "error", "500", "app", "errorhandler", "forbidden", "def", "forbidden", "e", "return", "forbidden", "403", "app", "route", "def", "index", "flask", "abort", "404", "app", "route", "error", "def", "error", "1", "0", "app", "route", "forbidden", "def", "error2", "flask", "abort", "403", "rv", "client", "get", "assert", "rv", "status_code", "404", "assert", "rv", "data", "b", "not", "found", "rv", "client", "get", "error", "assert", "rv", "status_code", "500", "assert", "b", "internal", "server", "error", "rv", "data", "rv", "client", "get", "forbidden", "assert", "rv", "status_code", "403", "assert", "b", "forbidden", "rv", "data"], "doc_len": 103}
{"doc_id": "tests/test_basic.py::test_error_handling_processing", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_error_handling_processing", "text": "文件路径: tests/test_basic.py\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        1 // 0\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_error_handling_processing", "app", "client", "app", "testing", "false", "app", "errorhandler", "500", "def", "internal_server_error", "e", "return", "internal", "server", "error", "500", "app", "route", "def", "broken_func", "1", "0", "app", "after_request", "def", "after_request", "resp", "resp", "mimetype", "text", "x", "special", "return", "resp", "resp", "client", "get", "assert", "resp", "mimetype", "text", "x", "special", "assert", "resp", "data", "b", "internal", "server", "error"], "doc_len": 55}
{"doc_id": "tests/test_basic.py::test_baseexception_error_handling", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_baseexception_error_handling", "text": "文件路径: tests/test_basic.py\ndef test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_baseexception_error_handling", "app", "client", "app", "testing", "false", "app", "route", "def", "broken_func", "raise", "keyboardinterrupt", "with", "pytest", "raises", "keyboardinterrupt", "client", "get"], "doc_len": 22}
{"doc_id": "tests/test_basic.py::test_before_request_and_routing_errors", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_before_request_and_routing_errors", "text": "文件路径: tests/test_basic.py\ndef test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_before_request_and_routing_errors", "app", "client", "app", "before_request", "def", "attach_something", "flask", "g", "something", "value", "app", "errorhandler", "404", "def", "return_something", "error", "return", "flask", "g", "something", "404", "rv", "client", "get", "assert", "rv", "status_code", "404", "assert", "rv", "data", "b", "value"], "doc_len": 38}
{"doc_id": "tests/test_basic.py::test_user_error_handling", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_user_error_handling", "text": "文件路径: tests/test_basic.py\ndef test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_user_error_handling", "app", "client", "class", "myexception", "exception", "pass", "app", "errorhandler", "myexception", "def", "handle_my_exception", "e", "assert", "isinstance", "e", "myexception", "return", "42", "app", "route", "def", "index", "raise", "myexception", "assert", "client", "get", "data", "b", "42"], "doc_len": 35}
{"doc_id": "tests/test_basic.py::test_http_error_subclass_handling", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_http_error_subclass_handling", "text": "文件路径: tests/test_basic.py\ndef test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_http_error_subclass_handling", "app", "client", "class", "forbiddensubclass", "forbidden", "pass", "app", "errorhandler", "forbiddensubclass", "def", "handle_forbidden_subclass", "e", "assert", "isinstance", "e", "forbiddensubclass", "return", "banana", "app", "errorhandler", "403", "def", "handle_403", "e", "assert", "not", "isinstance", "e", "forbiddensubclass", "assert", "isinstance", "e", "forbidden", "return", "apple", "app", "route", "1", "def", "index1", "raise", "forbiddensubclass", "app", "route", "2", "def", "index2", "flask", "abort", "403", "app", "route", "3", "def", "index3", "raise", "forbidden", "assert", "client", "get", "1", "data", "b", "banana", "assert", "client", "get", "2", "data", "b", "apple", "assert", "client", "get", "3", "data", "b", "apple"], "doc_len": 83}
{"doc_id": "tests/test_basic.py::test_errorhandler_precedence", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_errorhandler_precedence", "text": "文件路径: tests/test_basic.py\ndef test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_errorhandler_precedence", "app", "client", "class", "e1", "exception", "pass", "class", "e2", "exception", "pass", "class", "e3", "e1", "e2", "pass", "app", "errorhandler", "e2", "def", "handle_e2", "e", "return", "e2", "app", "errorhandler", "exception", "def", "handle_exception", "e", "return", "exception", "app", "route", "e1", "def", "raise_e1", "raise", "e1", "app", "route", "e3", "def", "raise_e3", "raise", "e3", "rv", "client", "get", "e1", "assert", "rv", "data", "b", "exception", "rv", "client", "get", "e3", "assert", "rv", "data", "b", "e2"], "doc_len": 68}
{"doc_id": "tests/test_basic.py::test_trap_bad_request_key_error", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_trap_bad_request_key_error", "text": "文件路径: tests/test_basic.py\ndef test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_trap_bad_request_key_error", "app", "client", "debug", "trap", "expect_key", "expect_abort", "app", "config", "debug", "debug", "app", "config", "trap_bad_request_errors", "trap", "app", "route", "key", "def", "fail", "flask", "request", "form", "missing_key", "app", "route", "abort", "def", "allow_abort", "flask", "abort", "400", "if", "expect_key", "rv", "client", "get", "key", "assert", "rv", "status_code", "400", "assert", "b", "missing_key", "not", "in", "rv", "data", "else", "with", "pytest", "raises", "keyerror", "as", "exc_info", "client", "get", "key", "assert", "exc_info", "errisinstance", "badrequest", "assert", "missing_key", "in", "exc_info", "value", "get_description", "if", "expect_abort", "rv", "client", "get", "abort", "assert", "rv", "status_code", "400", "else", "with", "pytest", "raises", "badrequest", "client", "get", "abort"], "doc_len": 91}
{"doc_id": "tests/test_basic.py::test_trapping_of_all_http_exceptions", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_trapping_of_all_http_exceptions", "text": "文件路径: tests/test_basic.py\ndef test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_trapping_of_all_http_exceptions", "app", "client", "app", "config", "trap_http_exceptions", "true", "app", "route", "fail", "def", "fail", "flask", "abort", "404", "with", "pytest", "raises", "notfound", "client", "get", "fail"], "doc_len": 26}
{"doc_id": "tests/test_basic.py::test_error_handler_after_processor_error", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_error_handler_after_processor_error", "text": "文件路径: tests/test_basic.py\ndef test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            1 // 0\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            1 // 0\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_error_handler_after_processor_error", "app", "client", "app", "testing", "false", "app", "before_request", "def", "before_request", "if", "_trigger", "before", "1", "0", "app", "after_request", "def", "after_request", "response", "if", "_trigger", "after", "1", "0", "return", "response", "app", "route", "def", "index", "return", "foo", "app", "errorhandler", "500", "def", "internal_server_error", "e", "return", "hello", "server", "error", "500", "for", "_trigger", "in", "before", "after", "rv", "client", "get", "assert", "rv", "status_code", "500", "assert", "rv", "data", "b", "hello", "server", "error"], "doc_len": 67}
{"doc_id": "tests/test_basic.py::test_enctype_debug_helper", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_enctype_debug_helper", "text": "文件路径: tests/test_basic.py\ndef test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)\n", "tokens": ["tests", "test_basic", "py", "def", "test_enctype_debug_helper", "app", "client", "from", "flask", "debughelpers", "import", "debugfileskeyerror", "app", "debug", "true", "app", "route", "fail", "methods", "post", "def", "index", "return", "flask", "request", "files", "foo", "filename", "with", "pytest", "raises", "debugfileskeyerror", "as", "e", "client", "post", "fail", "data", "foo", "index", "txt", "assert", "no", "file", "contents", "were", "transmitted", "in", "str", "e", "value", "assert", "this", "was", "submitted", "index", "txt", "in", "str", "e", "value"], "doc_len": 61}
{"doc_id": "tests/test_basic.py::test_response_types", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_response_types", "text": "文件路径: tests/test_basic.py\ndef test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"Hällo Wörld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"Hällo Wörld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"Hällo Wörld\".encode()\n    assert client.get(\"/bytes\").data == \"Hällo Wörld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201\n", "tokens": ["tests", "test_basic", "py", "def", "test_response_types", "app", "client", "app", "route", "text", "def", "from_text", "return", "h", "llo", "w", "rld", "app", "route", "bytes", "def", "from_bytes", "return", "h", "llo", "w", "rld", "encode", "app", "route", "full_tuple", "def", "from_full_tuple", "return", "meh", "400", "x", "foo", "testing", "content", "type", "text", "plain", "charset", "utf", "8", "app", "route", "text_headers", "def", "from_text_headers", "return", "hello", "x", "foo", "test", "content", "type", "text", "plain", "charset", "utf", "8", "app", "route", "text_status", "def", "from_text_status", "return", "hi", "status", "400", "app", "route", "response_headers", "def", "from_response_headers", "return", "flask", "response", "hello", "world", "404", "content", "type", "text", "html", "x", "foo", "baz", "content", "type", "text", "plain", "x", "foo", "bar", "x", "bar", "foo", "app", "route", "response_status", "def", "from_response_status", "return", "app", "response_class", "hello", "world", "400", "500", "app", "route", "wsgi", "def", "from_wsgi", "return", "notfound", "app", "route", "dict", "def", "from_dict", "return", "foo", "bar", "201", "app", "route", "list", "def", "from_list", "return", "foo", "bar", "201", "assert", "client", "get", "text", "data", "h", "llo", "w", "rld", "encode", "assert", "client", "get", "bytes", "data", "h", "llo", "w", "rld", "encode", "rv", "client", "get", "full_tuple", "assert", "rv", "data", "b", "meh", "assert", "rv", "headers", "x", "foo", "testing", "assert", "rv", "status_code", "400", "assert", "rv", "mimetype", "text", "plain", "rv", "client", "get", "text_headers", "assert", "rv", "data", "b", "hello", "assert", "rv", "headers", "x", "foo", "test", "assert", "rv", "status_code", "200", "assert", "rv", "mimetype", "text", "plain", "rv", "client", "get", "text_status", "assert", "rv", "data", "b", "hi", "status", "assert", "rv", "status_code", "400", "assert", "rv", "mimetype", "text", "html", "rv", "client", "get", "response_headers", "assert", "rv", "data", "b", "hello", "world", "assert", "rv", "content_type", "text", "plain", "assert", "rv", "headers", "getlist", "x", "foo", "bar", "assert", "rv", "headers", "x", "bar", "foo", "assert", "rv", "status_code", "404", "rv", "client", "get", "response_status", "assert", "rv", "data", "b", "hello", "world", "assert", "rv", "status_code", "500", "rv", "client", "get", "wsgi", "assert", "b", "not", "found", "in", "rv", "data", "assert", "rv", "status_code", "404", "rv", "client", "get", "dict", "assert", "rv", "json", "foo", "bar", "assert", "rv", "status_code", "201", "rv", "client", "get", "list", "assert", "rv", "json", "foo", "bar", "assert", "rv", "status_code", "201"], "doc_len": 311}
{"doc_id": "tests/test_basic.py::test_response_type_errors", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_response_type_errors", "text": "文件路径: tests/test_basic.py\ndef test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_response_type_errors", "app", "flask", "flask", "__name__", "app", "testing", "true", "app", "route", "none", "def", "from_none", "pass", "app", "route", "small_tuple", "def", "from_small_tuple", "return", "hello", "app", "route", "large_tuple", "def", "from_large_tuple", "return", "hello", "234", "x", "foo", "bar", "app", "route", "bad_type", "def", "from_bad_type", "return", "true", "app", "route", "bad_wsgi", "def", "from_bad_wsgi", "return", "lambda", "none", "c", "app", "test_client", "with", "pytest", "raises", "typeerror", "as", "e", "c", "get", "none", "assert", "returned", "none", "in", "str", "e", "value", "assert", "from_none", "in", "str", "e", "value", "with", "pytest", "raises", "typeerror", "as", "e", "c", "get", "small_tuple", "assert", "tuple", "must", "have", "the", "form", "in", "str", "e", "value", "with", "pytest", "raises", "typeerror", "c", "get", "large_tuple", "with", "pytest", "raises", "typeerror", "as", "e", "c", "get", "bad_type", "assert", "it", "was", "a", "bool", "in", "str", "e", "value", "with", "pytest", "raises", "typeerror", "c", "get", "bad_wsgi"], "doc_len": 127}
{"doc_id": "tests/test_basic.py::test_make_response", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_make_response", "text": "文件路径: tests/test_basic.py\ndef test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(c for c in \"Hello\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Hello\"\n    assert rv.mimetype == \"text/html\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_make_response", "app", "req_ctx", "rv", "flask", "make_response", "assert", "rv", "status_code", "200", "assert", "rv", "data", "b", "assert", "rv", "mimetype", "text", "html", "rv", "flask", "make_response", "awesome", "assert", "rv", "status_code", "200", "assert", "rv", "data", "b", "awesome", "assert", "rv", "mimetype", "text", "html", "rv", "flask", "make_response", "w00t", "404", "assert", "rv", "status_code", "404", "assert", "rv", "data", "b", "w00t", "assert", "rv", "mimetype", "text", "html", "rv", "flask", "make_response", "c", "for", "c", "in", "hello", "assert", "rv", "status_code", "200", "assert", "rv", "data", "b", "hello", "assert", "rv", "mimetype", "text", "html"], "doc_len": 82}
{"doc_id": "tests/test_basic.py::test_make_response_with_response_instance", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_make_response_with_response_instance", "text": "文件路径: tests/test_basic.py\ndef test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_make_response_with_response_instance", "app", "req_ctx", "rv", "flask", "make_response", "flask", "jsonify", "msg", "w00t", "400", "assert", "rv", "status_code", "400", "assert", "rv", "data", "b", "msg", "w00t", "n", "assert", "rv", "mimetype", "application", "json", "rv", "flask", "make_response", "flask", "response", "400", "assert", "rv", "status_code", "400", "assert", "rv", "data", "b", "assert", "rv", "mimetype", "text", "html", "rv", "flask", "make_response", "flask", "response", "headers", "content", "type", "text", "html", "400", "x", "foo", "bar", "assert", "rv", "status_code", "400", "assert", "rv", "headers", "content", "type", "text", "html", "assert", "rv", "headers", "x", "foo", "bar"], "doc_len": 81}
{"doc_id": "tests/test_basic.py::test_jsonify_no_prettyprint", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_jsonify_no_prettyprint", "text": "文件路径: tests/test_basic.py\ndef test_jsonify_no_prettyprint(app, compact):\n    app.json.compact = compact\n    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n    data = rv.data.strip()\n    assert (b\" \" not in data) is compact\n    assert (b\"\\n\" not in data) is compact\n", "tokens": ["tests", "test_basic", "py", "def", "test_jsonify_no_prettyprint", "app", "compact", "app", "json", "compact", "compact", "rv", "app", "json", "response", "msg", "submsg", "w00t", "msg2", "foobar", "data", "rv", "data", "strip", "assert", "b", "not", "in", "data", "is", "compact", "assert", "b", "n", "not", "in", "data", "is", "compact"], "doc_len": 39}
{"doc_id": "tests/test_basic.py::test_jsonify_mimetype", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_jsonify_mimetype", "text": "文件路径: tests/test_basic.py\ndef test_jsonify_mimetype(app, req_ctx):\n    app.json.mimetype = \"application/vnd.api+json\"\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application/vnd.api+json\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_jsonify_mimetype", "app", "req_ctx", "app", "json", "mimetype", "application", "vnd", "api", "json", "msg", "msg", "submsg", "w00t", "rv", "flask", "make_response", "flask", "jsonify", "msg", "200", "assert", "rv", "mimetype", "application", "vnd", "api", "json"], "doc_len": 32}
{"doc_id": "tests/test_basic.py::test_json_dump_dataclass", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_json_dump_dataclass", "text": "文件路径: tests/test_basic.py\ndef test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}\n", "tokens": ["tests", "test_basic", "py", "def", "test_json_dump_dataclass", "app", "req_ctx", "from", "dataclasses", "import", "make_dataclass", "data", "make_dataclass", "data", "name", "str", "value", "app", "json", "dumps", "data", "flask", "value", "app", "json", "loads", "value", "assert", "value", "name", "flask"], "doc_len": 31}
{"doc_id": "tests/test_basic.py::test_jsonify_args_and_kwargs_check", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_jsonify_args_and_kwargs_check", "text": "文件路径: tests/test_basic.py\ndef test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"args or kwargs\" in str(e.value)\n", "tokens": ["tests", "test_basic", "py", "def", "test_jsonify_args_and_kwargs_check", "app", "req_ctx", "with", "pytest", "raises", "typeerror", "as", "e", "flask", "jsonify", "fake", "args", "kwargs", "fake", "assert", "args", "or", "kwargs", "in", "str", "e", "value"], "doc_len": 27}
{"doc_id": "tests/test_basic.py::test_url_generation", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_url_generation", "text": "文件路径: tests/test_basic.py\ndef test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )\n", "tokens": ["tests", "test_basic", "py", "def", "test_url_generation", "app", "req_ctx", "app", "route", "hello", "name", "methods", "post", "def", "hello", "pass", "assert", "flask", "url_for", "hello", "name", "test", "x", "hello", "test", "20x", "assert", "flask", "url_for", "hello", "name", "test", "x", "_external", "true", "http", "localhost", "hello", "test", "20x"], "doc_len": 40}
{"doc_id": "tests/test_basic.py::test_build_error_handler", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_build_error_handler", "text": "文件路径: tests/test_basic.py\ndef test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_build_error_handler", "app", "test", "base", "case", "a", "url", "which", "results", "in", "a", "builderror", "with", "app", "test_request_context", "pytest", "raises", "builderror", "flask", "url_for", "spam", "verify", "the", "error", "is", "re", "raised", "if", "not", "the", "current", "exception", "try", "with", "app", "test_request_context", "flask", "url_for", "spam", "except", "builderror", "as", "err", "error", "err", "try", "raise", "runtimeerror", "test", "case", "where", "builderror", "is", "not", "current", "except", "runtimeerror", "pytest", "raises", "builderror", "app", "handle_url_build_error", "error", "spam", "test", "a", "custom", "handler", "def", "handler", "error", "endpoint", "values", "just", "a", "test", "return", "test_handler", "app", "url_build_error_handlers", "append", "handler", "with", "app", "test_request_context", "assert", "flask", "url_for", "spam", "test_handler"], "doc_len": 94}
{"doc_id": "tests/test_basic.py::test_build_error_handler_reraise", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_build_error_handler_reraise", "text": "文件路径: tests/test_basic.py\ndef test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_build_error_handler_reraise", "app", "test", "a", "custom", "handler", "which", "reraises", "the", "builderror", "def", "handler_raises_build_error", "error", "endpoint", "values", "raise", "error", "app", "url_build_error_handlers", "append", "handler_raises_build_error", "with", "app", "test_request_context", "pytest", "raises", "builderror", "flask", "url_for", "not", "existing"], "doc_len": 35}
{"doc_id": "tests/test_basic.py::test_url_for_passes_special_values_to_build_error_handler", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_url_for_passes_special_values_to_build_error_handler", "text": "文件路径: tests/test_basic.py\ndef test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")\n", "tokens": ["tests", "test_basic", "py", "def", "test_url_for_passes_special_values_to_build_error_handler", "app", "app", "url_build_error_handlers", "append", "def", "handler", "error", "endpoint", "values", "assert", "values", "_external", "false", "_anchor", "none", "_method", "none", "_scheme", "none", "return", "handled", "with", "app", "test_request_context", "flask", "url_for"], "doc_len": 31}
{"doc_id": "tests/test_basic.py::test_static_files", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_files", "text": "文件路径: tests/test_basic.py\ndef test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_files", "app", "client", "rv", "client", "get", "static", "index", "html", "assert", "rv", "status_code", "200", "assert", "rv", "data", "strip", "b", "h1", "hello", "world", "h1", "with", "app", "test_request_context", "assert", "flask", "url_for", "static", "filename", "index", "html", "static", "index", "html", "rv", "close"], "doc_len": 41}
{"doc_id": "tests/test_basic.py::test_static_url_path", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_url_path", "text": "文件路径: tests/test_basic.py\ndef test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_url_path", "app", "flask", "flask", "__name__", "static_url_path", "foo", "app", "testing", "true", "rv", "app", "test_client", "get", "foo", "index", "html", "assert", "rv", "status_code", "200", "rv", "close", "with", "app", "test_request_context", "assert", "flask", "url_for", "static", "filename", "index", "html", "foo", "index", "html"], "doc_len": 40}
{"doc_id": "tests/test_basic.py::test_static_url_path_with_ending_slash", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_url_path_with_ending_slash", "text": "文件路径: tests/test_basic.py\ndef test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_url_path_with_ending_slash", "app", "flask", "flask", "__name__", "static_url_path", "foo", "app", "testing", "true", "rv", "app", "test_client", "get", "foo", "index", "html", "assert", "rv", "status_code", "200", "rv", "close", "with", "app", "test_request_context", "assert", "flask", "url_for", "static", "filename", "index", "html", "foo", "index", "html"], "doc_len": 40}
{"doc_id": "tests/test_basic.py::test_static_url_empty_path", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_url_empty_path", "text": "文件路径: tests/test_basic.py\ndef test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_url_empty_path", "app", "app", "flask", "flask", "__name__", "static_folder", "static_url_path", "rv", "app", "test_client", "open", "static", "index", "html", "method", "get", "assert", "rv", "status_code", "200", "rv", "close"], "doc_len": 27}
{"doc_id": "tests/test_basic.py::test_static_url_empty_path_default", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_url_empty_path_default", "text": "文件路径: tests/test_basic.py\ndef test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_url_empty_path_default", "app", "app", "flask", "flask", "__name__", "static_folder", "rv", "app", "test_client", "open", "static", "index", "html", "method", "get", "assert", "rv", "status_code", "200", "rv", "close"], "doc_len": 26}
{"doc_id": "tests/test_basic.py::test_static_folder_with_pathlib_path", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_folder_with_pathlib_path", "text": "文件路径: tests/test_basic.py\ndef test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_folder_with_pathlib_path", "app", "from", "pathlib", "import", "path", "app", "flask", "flask", "__name__", "static_folder", "path", "static", "rv", "app", "test_client", "open", "static", "index", "html", "method", "get", "assert", "rv", "status_code", "200", "rv", "close"], "doc_len": 32}
{"doc_id": "tests/test_basic.py::test_static_folder_with_ending_slash", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_folder_with_ending_slash", "text": "文件路径: tests/test_basic.py\ndef test_static_folder_with_ending_slash():\n    app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_folder_with_ending_slash", "app", "flask", "flask", "__name__", "static_folder", "static", "app", "route", "path", "path", "def", "catch_all", "path", "return", "path", "rv", "app", "test_client", "get", "catch", "all", "assert", "rv", "data", "b", "catch", "all"], "doc_len": 32}
{"doc_id": "tests/test_basic.py::test_static_route_with_host_matching", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_static_route_with_host_matching", "text": "文件路径: tests/test_basic.py\ndef test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)\n", "tokens": ["tests", "test_basic", "py", "def", "test_static_route_with_host_matching", "app", "flask", "flask", "__name__", "host_matching", "true", "static_host", "example", "com", "c", "app", "test_client", "rv", "c", "get", "http", "example", "com", "static", "index", "html", "assert", "rv", "status_code", "200", "rv", "close", "with", "app", "test_request_context", "rv", "flask", "url_for", "static", "filename", "index", "html", "_external", "true", "assert", "rv", "http", "example", "com", "static", "index", "html", "providing", "static_host", "without", "host_matching", "true", "should", "error", "with", "pytest", "raises", "assertionerror", "flask", "flask", "__name__", "static_host", "example", "com", "providing", "host_matching", "true", "with", "static_folder", "but", "without", "static_host", "should", "error", "with", "pytest", "raises", "assertionerror", "flask", "flask", "__name__", "host_matching", "true", "providing", "host_matching", "true", "without", "static_host", "but", "with", "static_folder", "none", "should", "not", "error", "flask", "flask", "__name__", "host_matching", "true", "static_folder", "none"], "doc_len": 107}
{"doc_id": "tests/test_basic.py::test_request_locals", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_request_locals", "text": "文件路径: tests/test_basic.py\ndef test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g\n", "tokens": ["tests", "test_basic", "py", "def", "test_request_locals", "assert", "repr", "flask", "g", "localproxy", "unbound", "assert", "not", "flask", "g"], "doc_len": 15}
{"doc_id": "tests/test_basic.py::test_server_name_subdomain", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_server_name_subdomain", "text": "文件路径: tests/test_basic.py\ndef test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_server_name_subdomain", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "client", "app", "test_client", "app", "route", "def", "index", "return", "default", "app", "route", "subdomain", "foo", "def", "subdomain", "return", "subdomain", "app", "config", "server_name", "dev", "local", "5000", "rv", "client", "get", "assert", "rv", "data", "b", "default", "rv", "client", "get", "http", "dev", "local", "5000", "assert", "rv", "data", "b", "default", "rv", "client", "get", "https", "dev", "local", "5000", "assert", "rv", "data", "b", "default", "app", "config", "server_name", "dev", "local", "443", "rv", "client", "get", "https", "dev", "local", "werkzeug", "1", "0", "fixes", "matching", "https", "scheme", "with", "443", "port", "if", "rv", "status_code", "404", "assert", "rv", "data", "b", "default", "app", "config", "server_name", "dev", "local", "rv", "client", "get", "https", "dev", "local", "assert", "rv", "data", "b", "default", "suppress", "werkzeug", "0", "15", "warning", "about", "name", "mismatch", "with", "warnings", "catch_warnings", "warnings", "filterwarnings", "ignore", "current", "server", "name", "userwarning", "flask", "app", "rv", "client", "get", "http", "foo", "localhost", "assert", "rv", "status_code", "404", "rv", "client", "get", "http", "foo", "dev", "local", "assert", "rv", "data", "b", "subdomain"], "doc_len": 155}
{"doc_id": "tests/test_basic.py::test_exception_propagation", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_exception_propagation", "text": "文件路径: tests/test_basic.py\ndef test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        1 // 0\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500\n", "tokens": ["tests", "test_basic", "py", "def", "test_exception_propagation", "app", "client", "key", "app", "testing", "false", "app", "route", "def", "index", "1", "0", "if", "key", "is", "not", "none", "app", "config", "key", "true", "with", "pytest", "raises", "zerodivisionerror", "client", "get", "else", "assert", "client", "get", "status_code", "500"], "doc_len": 38}
{"doc_id": "tests/test_basic.py::test_werkzeug_passthrough_errors", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_werkzeug_passthrough_errors", "text": "文件路径: tests/test_basic.py\ndef test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)\n", "tokens": ["tests", "test_basic", "py", "def", "test_werkzeug_passthrough_errors", "monkeypatch", "debug", "use_debugger", "use_reloader", "propagate_exceptions", "app", "rv", "mocks", "werkzeug", "serving", "run_simple", "method", "def", "run_simple_mock", "args", "kwargs", "rv", "passthrough_errors", "kwargs", "get", "passthrough_errors", "monkeypatch", "setattr", "werkzeug", "serving", "run_simple", "run_simple_mock", "app", "config", "propagate_exceptions", "propagate_exceptions", "app", "run", "debug", "debug", "use_debugger", "use_debugger", "use_reloader", "use_reloader"], "doc_len": 44}
{"doc_id": "tests/test_basic.py::test_max_content_length", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_max_content_length", "text": "文件路径: tests/test_basic.py\ndef test_max_content_length(app, client):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 64\n\n    @app.before_request\n    def always_first():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.route(\"/accept\", methods=[\"POST\"])\n    def accept_file():\n        flask.request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/accept\", data={\"myfile\": \"foo\" * 100})\n    assert rv.data == b\"42\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_max_content_length", "app", "client", "app", "config", "max_content_length", "64", "app", "before_request", "def", "always_first", "flask", "request", "form", "myfile", "assertionerror", "app", "route", "accept", "methods", "post", "def", "accept_file", "flask", "request", "form", "myfile", "assertionerror", "app", "errorhandler", "413", "def", "catcher", "error", "return", "42", "rv", "client", "post", "accept", "data", "myfile", "foo", "100", "assert", "rv", "data", "b", "42"], "doc_len": 53}
{"doc_id": "tests/test_basic.py::test_url_processors", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_url_processors", "text": "文件路径: tests/test_basic.py\ndef test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_url_processors", "app", "client", "app", "url_defaults", "def", "add_language_code", "endpoint", "values", "if", "flask", "g", "lang_code", "is", "not", "none", "and", "app", "url_map", "is_endpoint_expecting", "endpoint", "lang_code", "values", "setdefault", "lang_code", "flask", "g", "lang_code", "app", "url_value_preprocessor", "def", "pull_lang_code", "endpoint", "values", "flask", "g", "lang_code", "values", "pop", "lang_code", "none", "app", "route", "lang_code", "def", "index", "return", "flask", "url_for", "about", "app", "route", "lang_code", "about", "def", "about", "return", "flask", "url_for", "something_else", "app", "route", "foo", "def", "something_else", "return", "flask", "url_for", "about", "lang_code", "en", "assert", "client", "get", "de", "data", "b", "de", "about", "assert", "client", "get", "de", "about", "data", "b", "foo", "assert", "client", "get", "foo", "data", "b", "en", "about"], "doc_len": 99}
{"doc_id": "tests/test_basic.py::test_inject_blueprint_url_defaults", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_inject_blueprint_url_defaults", "text": "文件路径: tests/test_basic.py\ndef test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected\n", "tokens": ["tests", "test_basic", "py", "def", "test_inject_blueprint_url_defaults", "app", "bp", "flask", "blueprint", "foo", "__name__", "template_folder", "template", "bp", "url_defaults", "def", "bp_defaults", "endpoint", "values", "values", "page", "login", "bp", "route", "page", "def", "view", "page", "pass", "app", "register_blueprint", "bp", "values", "dict", "app", "inject_url_defaults", "foo", "view", "values", "expected", "dict", "page", "login", "assert", "values", "expected", "with", "app", "test_request_context", "somepage", "url", "flask", "url_for", "foo", "view", "expected", "login", "assert", "url", "expected"], "doc_len": 60}
{"doc_id": "tests/test_basic.py::test_nonascii_pathinfo", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_nonascii_pathinfo", "text": "文件路径: tests/test_basic.py\ndef test_nonascii_pathinfo(app, client):\n    @app.route(\"/киртест\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/киртест\")\n    assert rv.data == b\"Hello World!\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_nonascii_pathinfo", "app", "client", "app", "route", "def", "index", "return", "hello", "world", "rv", "client", "get", "assert", "rv", "data", "b", "hello", "world"], "doc_len": 23}
{"doc_id": "tests/test_basic.py::test_no_setup_after_first_request", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_no_setup_after_first_request", "text": "文件路径: tests/test_basic.py\ndef test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)\n", "tokens": ["tests", "test_basic", "py", "def", "test_no_setup_after_first_request", "app", "client", "app", "debug", "true", "app", "route", "def", "index", "return", "awesome", "assert", "client", "get", "data", "b", "awesome", "with", "pytest", "raises", "assertionerror", "as", "exc_info", "app", "add_url_rule", "foo", "endpoint", "late", "assert", "setup", "method", "add_url_rule", "in", "str", "exc_info", "value"], "doc_len": 41}
{"doc_id": "tests/test_basic.py::test_routing_redirect_debugging", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_routing_redirect_debugging", "text": "文件路径: tests/test_basic.py\ndef test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)\n", "tokens": ["tests", "test_basic", "py", "def", "test_routing_redirect_debugging", "monkeypatch", "app", "client", "app", "config", "debug", "true", "app", "route", "user", "methods", "get", "post", "def", "user", "return", "flask", "request", "form", "status", "default", "redirect", "code", "preserves", "form", "data", "rv", "client", "post", "user", "data", "status", "success", "follow_redirects", "true", "assert", "rv", "data", "b", "success", "301", "and", "302", "raise", "error", "monkeypatch", "setattr", "requestredirect", "code", "301", "with", "client", "pytest", "raises", "assertionerror", "as", "exc_info", "client", "post", "user", "data", "status", "error", "follow_redirects", "true", "assert", "canonical", "url", "http", "localhost", "user", "in", "str", "exc_info", "value"], "doc_len": 80}
{"doc_id": "tests/test_basic.py::test_route_decorator_custom_endpoint", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_route_decorator_custom_endpoint", "text": "文件路径: tests/test_basic.py\ndef test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_route_decorator_custom_endpoint", "app", "client", "app", "debug", "true", "app", "route", "foo", "def", "foo", "return", "flask", "request", "endpoint", "app", "route", "bar", "endpoint", "bar", "def", "for_bar", "return", "flask", "request", "endpoint", "app", "route", "bar", "123", "endpoint", "123", "def", "for_bar_foo", "return", "flask", "request", "endpoint", "with", "app", "test_request_context", "assert", "flask", "url_for", "foo", "foo", "assert", "flask", "url_for", "bar", "bar", "assert", "flask", "url_for", "123", "bar", "123", "assert", "client", "get", "foo", "data", "b", "foo", "assert", "client", "get", "bar", "data", "b", "bar", "assert", "client", "get", "bar", "123", "data", "b", "123"], "doc_len": 83}
{"doc_id": "tests/test_basic.py::test_get_method_on_g", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_get_method_on_g", "text": "文件路径: tests/test_basic.py\ndef test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42\n", "tokens": ["tests", "test_basic", "py", "def", "test_get_method_on_g", "app_ctx", "assert", "flask", "g", "get", "x", "is", "none", "assert", "flask", "g", "get", "x", "11", "11", "flask", "g", "x", "42", "assert", "flask", "g", "get", "x", "42", "assert", "flask", "g", "x", "42"], "doc_len": 35}
{"doc_id": "tests/test_basic.py::test_g_iteration_protocol", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_g_iteration_protocol", "text": "文件路径: tests/test_basic.py\ndef test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]\n", "tokens": ["tests", "test_basic", "py", "def", "test_g_iteration_protocol", "app_ctx", "flask", "g", "foo", "23", "flask", "g", "bar", "42", "assert", "foo", "in", "flask", "g", "assert", "foos", "not", "in", "flask", "g", "assert", "sorted", "flask", "g", "bar", "foo"], "doc_len": 31}
{"doc_id": "tests/test_basic.py::test_subdomain_basic_support", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_subdomain_basic_support", "text": "文件路径: tests/test_basic.py\ndef test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_subdomain_basic_support", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "app", "config", "server_name", "localhost", "localdomain", "client", "app", "test_client", "app", "route", "def", "normal_index", "return", "normal", "index", "app", "route", "subdomain", "test", "def", "test_index", "return", "test", "index", "rv", "client", "get", "http", "localhost", "localdomain", "assert", "rv", "data", "b", "normal", "index", "rv", "client", "get", "http", "test", "localhost", "localdomain", "assert", "rv", "data", "b", "test", "index"], "doc_len": 60}
{"doc_id": "tests/test_basic.py::test_subdomain_matching", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_subdomain_matching", "text": "文件路径: tests/test_basic.py\ndef test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_subdomain_matching", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "client", "app", "test_client", "app", "config", "server_name", "localhost", "localdomain", "app", "route", "subdomain", "user", "def", "index", "user", "return", "f", "index", "for", "user", "rv", "client", "get", "http", "mitsuhiko", "localhost", "localdomain", "assert", "rv", "data", "b", "index", "for", "mitsuhiko"], "doc_len": 45}
{"doc_id": "tests/test_basic.py::test_subdomain_matching_with_ports", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_subdomain_matching_with_ports", "text": "文件路径: tests/test_basic.py\ndef test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_subdomain_matching_with_ports", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "app", "config", "server_name", "localhost", "localdomain", "3000", "client", "app", "test_client", "app", "route", "subdomain", "user", "def", "index", "user", "return", "f", "index", "for", "user", "rv", "client", "get", "http", "mitsuhiko", "localhost", "localdomain", "3000", "assert", "rv", "data", "b", "index", "for", "mitsuhiko"], "doc_len": 47}
{"doc_id": "tests/test_basic.py::test_subdomain_matching_other_name", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_subdomain_matching_other_name", "text": "文件路径: tests/test_basic.py\ndef test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204\n", "tokens": ["tests", "test_basic", "py", "def", "test_subdomain_matching_other_name", "matching", "app", "flask", "flask", "__name__", "subdomain_matching", "matching", "app", "config", "server_name", "localhost", "localdomain", "3000", "client", "app", "test_client", "app", "route", "def", "index", "return", "204", "suppress", "werkzeug", "0", "15", "warning", "about", "name", "mismatch", "with", "warnings", "catch_warnings", "warnings", "filterwarnings", "ignore", "current", "server", "name", "userwarning", "flask", "app", "ip", "address", "can", "t", "match", "name", "rv", "client", "get", "http", "127", "0", "0", "1", "3000", "assert", "rv", "status_code", "404", "if", "matching", "else", "204", "allow", "all", "subdomains", "if", "matching", "is", "disabled", "rv", "client", "get", "http", "www", "localhost", "localdomain", "3000", "assert", "rv", "status_code", "404", "if", "matching", "else", "204"], "doc_len": 93}
{"doc_id": "tests/test_basic.py::test_multi_route_rules", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_multi_route_rules", "text": "文件路径: tests/test_basic.py\ndef test_multi_route_rules(app, client):\n    @app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_multi_route_rules", "app", "client", "app", "route", "app", "route", "test", "def", "index", "test", "a", "return", "test", "rv", "client", "open", "assert", "rv", "data", "b", "a", "rv", "client", "open", "b", "assert", "rv", "data", "b", "b"], "doc_len": 35}
{"doc_id": "tests/test_basic.py::test_multi_route_class_views", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_multi_route_class_views", "text": "文件路径: tests/test_basic.py\ndef test_multi_route_class_views(app, client):\n    class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_multi_route_class_views", "app", "client", "class", "view", "def", "__init__", "self", "app", "app", "add_url_rule", "index", "self", "index", "app", "add_url_rule", "test", "index", "self", "index", "def", "index", "self", "test", "a", "return", "test", "_", "view", "app", "rv", "client", "open", "assert", "rv", "data", "b", "a", "rv", "client", "open", "b", "assert", "rv", "data", "b", "b"], "doc_len": 51}
{"doc_id": "tests/test_basic.py::test_run_defaults", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_run_defaults", "text": "文件路径: tests/test_basic.py\ndef test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_run_defaults", "monkeypatch", "app", "rv", "mocks", "werkzeug", "serving", "run_simple", "method", "def", "run_simple_mock", "args", "kwargs", "rv", "result", "running", "monkeypatch", "setattr", "werkzeug", "serving", "run_simple", "run_simple_mock", "app", "run", "assert", "rv", "result", "running"], "doc_len": 32}
{"doc_id": "tests/test_basic.py::test_run_server_port", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_run_server_port", "text": "文件路径: tests/test_basic.py\ndef test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = f\"running on {hostname}:{port} ...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == f\"running on {hostname}:{port} ...\"\n", "tokens": ["tests", "test_basic", "py", "def", "test_run_server_port", "monkeypatch", "app", "rv", "mocks", "werkzeug", "serving", "run_simple", "method", "def", "run_simple_mock", "hostname", "port", "application", "args", "kwargs", "rv", "result", "f", "running", "on", "hostname", "port", "monkeypatch", "setattr", "werkzeug", "serving", "run_simple", "run_simple_mock", "hostname", "port", "localhost", "8000", "app", "run", "hostname", "port", "debug", "true", "assert", "rv", "result", "f", "running", "on", "hostname", "port"], "doc_len": 51}
{"doc_id": "tests/test_basic.py::test_run_from_config", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_run_from_config", "text": "文件路径: tests/test_basic.py\ndef test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)\n", "tokens": ["tests", "test_basic", "py", "def", "test_run_from_config", "monkeypatch", "host", "port", "server_name", "expect_host", "expect_port", "app", "def", "run_simple_mock", "hostname", "port", "args", "kwargs", "assert", "hostname", "expect_host", "assert", "port", "expect_port", "monkeypatch", "setattr", "werkzeug", "serving", "run_simple", "run_simple_mock", "app", "config", "server_name", "server_name", "app", "run", "host", "port"], "doc_len": 38}
{"doc_id": "tests/test_basic.py::test_max_cookie_size", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_max_cookie_size", "text": "文件路径: tests/test_basic.py\ndef test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0\n", "tokens": ["tests", "test_basic", "py", "def", "test_max_cookie_size", "app", "client", "recwarn", "app", "config", "max_cookie_size", "100", "outside", "app", "context", "default", "to", "werkzeug", "static", "value", "which", "is", "also", "the", "default", "config", "response", "flask", "response", "default", "flask", "flask", "default_config", "max_cookie_size", "assert", "response", "max_cookie_size", "default", "inside", "app", "context", "use", "app", "config", "with", "app", "app_context", "assert", "flask", "response", "max_cookie_size", "100", "app", "route", "def", "index", "r", "flask", "response", "status", "204", "r", "set_cookie", "foo", "bar", "100", "return", "r", "client", "get", "assert", "len", "recwarn", "1", "w", "recwarn", "pop", "assert", "cookie", "is", "too", "large", "in", "str", "w", "message", "app", "config", "max_cookie_size", "0", "client", "get", "assert", "len", "recwarn", "0"], "doc_len": 96}
{"doc_id": "tests/test_basic.py::test_app_freed_on_zero_refcount", "file_path": "tests/test_basic.py", "class_name": null, "func_name": "test_app_freed_on_zero_refcount", "text": "文件路径: tests/test_basic.py\ndef test_app_freed_on_zero_refcount():\n    # A Flask instance should not create a reference cycle that prevents CPython\n    # from freeing it when all external references to it are released (see #3761).\n    gc.disable()\n    try:\n        app = flask.Flask(__name__)\n        assert app.view_functions[\"static\"]\n        weak = weakref.ref(app)\n        assert weak() is not None\n        del app\n        assert weak() is None\n    finally:\n        gc.enable()\n", "tokens": ["tests", "test_basic", "py", "def", "test_app_freed_on_zero_refcount", "a", "flask", "instance", "should", "not", "create", "a", "reference", "cycle", "that", "prevents", "cpython", "from", "freeing", "it", "when", "all", "external", "references", "to", "it", "are", "released", "see", "3761", "gc", "disable", "try", "app", "flask", "flask", "__name__", "assert", "app", "view_functions", "static", "weak", "weakref", "ref", "app", "assert", "weak", "is", "not", "none", "del", "app", "assert", "weak", "is", "none", "finally", "gc", "enable"], "doc_len": 59}
{"doc_id": "tests/test_blueprints.py::test_blueprint_specific_error_handling", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_specific_error_handling", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_specific_error_handling", "app", "client", "frontend", "flask", "blueprint", "frontend", "__name__", "backend", "flask", "blueprint", "backend", "__name__", "sideend", "flask", "blueprint", "sideend", "__name__", "frontend", "errorhandler", "403", "def", "frontend_forbidden", "e", "return", "frontend", "says", "no", "403", "frontend", "route", "frontend", "no", "def", "frontend_no", "flask", "abort", "403", "backend", "errorhandler", "403", "def", "backend_forbidden", "e", "return", "backend", "says", "no", "403", "backend", "route", "backend", "no", "def", "backend_no", "flask", "abort", "403", "sideend", "route", "what", "is", "a", "sideend", "def", "sideend_no", "flask", "abort", "403", "app", "register_blueprint", "frontend", "app", "register_blueprint", "backend", "app", "register_blueprint", "sideend", "app", "errorhandler", "403", "def", "app_forbidden", "e", "return", "application", "itself", "says", "no", "403", "assert", "client", "get", "frontend", "no", "data", "b", "frontend", "says", "no", "assert", "client", "get", "backend", "no", "data", "b", "backend", "says", "no", "assert", "client", "get", "what", "is", "a", "sideend", "data", "b", "application", "itself", "says", "no"], "doc_len": 127}
{"doc_id": "tests/test_blueprints.py::test_blueprint_specific_user_error_handling", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_specific_user_error_handling", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_specific_user_error_handling", "app", "client", "class", "mydecoratorexception", "exception", "pass", "class", "myfunctionexception", "exception", "pass", "blue", "flask", "blueprint", "blue", "__name__", "blue", "errorhandler", "mydecoratorexception", "def", "my_decorator_exception_handler", "e", "assert", "isinstance", "e", "mydecoratorexception", "return", "boom", "def", "my_function_exception_handler", "e", "assert", "isinstance", "e", "myfunctionexception", "return", "bam", "blue", "register_error_handler", "myfunctionexception", "my_function_exception_handler", "blue", "route", "decorator", "def", "blue_deco_test", "raise", "mydecoratorexception", "blue", "route", "function", "def", "blue_func_test", "raise", "myfunctionexception", "app", "register_blueprint", "blue", "assert", "client", "get", "decorator", "data", "b", "boom", "assert", "client", "get", "function", "data", "b", "bam"], "doc_len": 76}
{"doc_id": "tests/test_blueprints.py::test_blueprint_app_error_handling", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_app_error_handling", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_app_error_handling", "app", "client", "errors", "flask", "blueprint", "errors", "__name__", "errors", "app_errorhandler", "403", "def", "forbidden_handler", "e", "return", "you", "shall", "not", "pass", "403", "app", "route", "forbidden", "def", "app_forbidden", "flask", "abort", "403", "forbidden_bp", "flask", "blueprint", "forbidden_bp", "__name__", "forbidden_bp", "route", "nope", "def", "bp_forbidden", "flask", "abort", "403", "app", "register_blueprint", "errors", "app", "register_blueprint", "forbidden_bp", "assert", "client", "get", "forbidden", "data", "b", "you", "shall", "not", "pass", "assert", "client", "get", "nope", "data", "b", "you", "shall", "not", "pass"], "doc_len": 71}
{"doc_id": "tests/test_blueprints.py::test_blueprint_prefix_slash", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_prefix_slash", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_prefix_slash", "app", "client", "prefix", "rule", "url", "bp", "flask", "blueprint", "test", "__name__", "url_prefix", "prefix", "bp", "route", "rule", "def", "index", "return", "204", "app", "register_blueprint", "bp", "assert", "client", "get", "url", "status_code", "204"], "doc_len": 33}
{"doc_id": "tests/test_blueprints.py::test_blueprint_url_defaults", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_url_defaults", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_url_defaults", "app", "client", "bp", "flask", "blueprint", "test", "__name__", "bp", "route", "foo", "defaults", "baz", "42", "def", "foo", "bar", "baz", "return", "f", "bar", "baz", "d", "bp", "route", "bar", "def", "bar", "bar", "return", "str", "bar", "app", "register_blueprint", "bp", "url_prefix", "1", "url_defaults", "bar", "23", "app", "register_blueprint", "bp", "name", "test2", "url_prefix", "2", "url_defaults", "bar", "19", "assert", "client", "get", "1", "foo", "data", "b", "23", "42", "assert", "client", "get", "2", "foo", "data", "b", "19", "42", "assert", "client", "get", "1", "bar", "data", "b", "23", "assert", "client", "get", "2", "bar", "data", "b", "19"], "doc_len": 88}
{"doc_id": "tests/test_blueprints.py::test_blueprint_url_processors", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_url_processors", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_url_processors", "app", "client", "bp", "flask", "blueprint", "frontend", "__name__", "url_prefix", "lang_code", "bp", "url_defaults", "def", "add_language_code", "endpoint", "values", "values", "setdefault", "lang_code", "flask", "g", "lang_code", "bp", "url_value_preprocessor", "def", "pull_lang_code", "endpoint", "values", "flask", "g", "lang_code", "values", "pop", "lang_code", "bp", "route", "def", "index", "return", "flask", "url_for", "about", "bp", "route", "about", "def", "about", "return", "flask", "url_for", "index", "app", "register_blueprint", "bp", "assert", "client", "get", "de", "data", "b", "de", "about", "assert", "client", "get", "de", "about", "data", "b", "de"], "doc_len": 74}
{"doc_id": "tests/test_blueprints.py::test_templates_and_static", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_templates_and_static", "text": "文件路径: tests/test_blueprints.py\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_templates_and_static", "test_apps", "from", "blueprintapp", "import", "app", "client", "app", "test_client", "rv", "client", "get", "assert", "rv", "data", "b", "hello", "from", "the", "frontend", "rv", "client", "get", "admin", "assert", "rv", "data", "b", "hello", "from", "the", "admin", "rv", "client", "get", "admin", "index2", "assert", "rv", "data", "b", "hello", "from", "the", "admin", "rv", "client", "get", "admin", "static", "test", "txt", "assert", "rv", "data", "strip", "b", "admin", "file", "rv", "close", "rv", "client", "get", "admin", "static", "css", "test", "css", "assert", "rv", "data", "strip", "b", "nested", "file", "rv", "close", "try", "finally", "in", "case", "other", "tests", "use", "this", "app", "for", "blueprint", "tests", "max_age_default", "app", "config", "send_file_max_age_default", "try", "expected_max_age", "3600", "if", "app", "config", "send_file_max_age_default", "expected_max_age", "expected_max_age", "7200", "app", "config", "send_file_max_age_default", "expected_max_age", "rv", "client", "get", "admin", "static", "css", "test", "css", "cc", "parse_cache_control_header", "rv", "headers", "cache", "control", "assert", "cc", "max_age", "expected_max_age", "rv", "close", "finally", "app", "config", "send_file_max_age_default", "max_age_default", "with", "app", "test_request_context", "assert", "flask", "url_for", "admin", "static", "filename", "test", "txt", "admin", "static", "test", "txt", "with", "app", "test_request_context", "with", "pytest", "raises", "templatenotfound", "as", "e", "flask", "render_template", "missing", "html", "assert", "e", "value", "name", "missing", "html", "with", "flask", "flask", "__name__", "test_request_context", "assert", "flask", "render_template", "nested", "nested", "txt", "i", "m", "nested"], "doc_len": 185}
{"doc_id": "tests/test_blueprints.py::test_default_static_max_age", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_default_static_max_age", "text": "文件路径: tests/test_blueprints.py\ndef test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_default_static_max_age", "app", "class", "myblueprint", "flask", "blueprint", "def", "get_send_file_max_age", "self", "filename", "return", "100", "blueprint", "myblueprint", "blueprint", "__name__", "static_folder", "static", "app", "register_blueprint", "blueprint", "try", "finally", "in", "case", "other", "tests", "use", "this", "app", "for", "blueprint", "tests", "max_age_default", "app", "config", "send_file_max_age_default", "try", "with", "app", "test_request_context", "unexpected_max_age", "3600", "if", "app", "config", "send_file_max_age_default", "unexpected_max_age", "unexpected_max_age", "7200", "app", "config", "send_file_max_age_default", "unexpected_max_age", "rv", "blueprint", "send_static_file", "index", "html", "cc", "parse_cache_control_header", "rv", "headers", "cache", "control", "assert", "cc", "max_age", "100", "rv", "close", "finally", "app", "config", "send_file_max_age_default", "max_age_default"], "doc_len": 80}
{"doc_id": "tests/test_blueprints.py::test_templates_list", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_templates_list", "text": "文件路径: tests/test_blueprints.py\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_templates_list", "test_apps", "from", "blueprintapp", "import", "app", "templates", "sorted", "app", "jinja_env", "list_templates", "assert", "templates", "admin", "index", "html", "frontend", "index", "html"], "doc_len": 23}
{"doc_id": "tests/test_blueprints.py::test_dotted_name_not_allowed", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_dotted_name_not_allowed", "text": "文件路径: tests/test_blueprints.py\ndef test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_dotted_name_not_allowed", "app", "client", "with", "pytest", "raises", "valueerror", "flask", "blueprint", "app", "ui", "__name__"], "doc_len": 16}
{"doc_id": "tests/test_blueprints.py::test_dotted_names_from_app", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_dotted_names_from_app", "text": "文件路径: tests/test_blueprints.py\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_dotted_names_from_app", "app", "client", "test", "flask", "blueprint", "test", "__name__", "app", "route", "def", "app_index", "return", "flask", "url_for", "test", "index", "test", "route", "test", "def", "index", "return", "flask", "url_for", "app_index", "app", "register_blueprint", "test", "rv", "client", "get", "assert", "rv", "data", "b", "test"], "doc_len": 41}
{"doc_id": "tests/test_blueprints.py::test_empty_url_defaults", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_empty_url_defaults", "text": "文件路径: tests/test_blueprints.py\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_empty_url_defaults", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "route", "defaults", "page", "1", "bp", "route", "page", "int", "page", "def", "something", "page", "return", "str", "page", "app", "register_blueprint", "bp", "assert", "client", "get", "data", "b", "1", "assert", "client", "get", "page", "2", "data", "b", "2"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_route_decorator_custom_endpoint", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_route_decorator_custom_endpoint", "text": "文件路径: tests/test_blueprints.py\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_route_decorator_custom_endpoint", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "route", "foo", "def", "foo", "return", "flask", "request", "endpoint", "bp", "route", "bar", "endpoint", "bar", "def", "foo_bar", "return", "flask", "request", "endpoint", "bp", "route", "bar", "123", "endpoint", "123", "def", "foo_bar_foo", "return", "flask", "request", "endpoint", "bp", "route", "bar", "foo", "def", "bar_foo", "return", "flask", "request", "endpoint", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "request", "endpoint", "assert", "client", "get", "data", "b", "index", "assert", "client", "get", "py", "foo", "data", "b", "bp", "foo", "assert", "client", "get", "py", "bar", "data", "b", "bp", "bar", "assert", "client", "get", "py", "bar", "123", "data", "b", "bp", "123", "assert", "client", "get", "py", "bar", "foo", "data", "b", "bp", "bar_foo"], "doc_len": 111}
{"doc_id": "tests/test_blueprints.py::test_route_decorator_custom_endpoint_with_dots", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_route_decorator_custom_endpoint_with_dots", "text": "文件路径: tests/test_blueprints.py\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_route_decorator_custom_endpoint_with_dots", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "with", "pytest", "raises", "valueerror", "bp", "route", "endpoint", "a", "b", "lambda", "with", "pytest", "raises", "valueerror", "bp", "add_url_rule", "endpoint", "a", "b", "def", "view", "return", "view", "__name__", "a", "b", "with", "pytest", "raises", "valueerror", "bp", "add_url_rule", "view_func", "view"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_endpoint_decorator", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_endpoint_decorator", "text": "文件路径: tests/test_blueprints.py\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_endpoint_decorator", "app", "client", "from", "werkzeug", "routing", "import", "rule", "app", "url_map", "add", "rule", "foo", "endpoint", "bar", "bp", "flask", "blueprint", "bp", "__name__", "bp", "endpoint", "bar", "def", "foobar", "return", "flask", "request", "endpoint", "app", "register_blueprint", "bp", "url_prefix", "bp_prefix", "assert", "client", "get", "foo", "data", "b", "bar", "assert", "client", "get", "bp_prefix", "bar", "status_code", "404"], "doc_len": 52}
{"doc_id": "tests/test_blueprints.py::test_template_filter", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_filter", "text": "文件路径: tests/test_blueprints.py\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_filter", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_filter", "def", "my_reverse", "s", "return", "s", "1", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "my_reverse", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "my_reverse", "my_reverse", "assert", "app", "jinja_env", "filters", "my_reverse", "abcd", "dcba"], "doc_len": 44}
{"doc_id": "tests/test_blueprints.py::test_add_template_filter", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_filter", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_filter", "app", "bp", "flask", "blueprint", "bp", "__name__", "def", "my_reverse", "s", "return", "s", "1", "bp", "add_app_template_filter", "my_reverse", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "my_reverse", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "my_reverse", "my_reverse", "assert", "app", "jinja_env", "filters", "my_reverse", "abcd", "dcba"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_template_filter_with_name", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_filter_with_name", "text": "文件路径: tests/test_blueprints.py\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_filter_with_name", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_filter", "strrev", "def", "my_reverse", "s", "return", "s", "1", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "strrev", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "strrev", "my_reverse", "assert", "app", "jinja_env", "filters", "strrev", "abcd", "dcba"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_add_template_filter_with_name", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_filter_with_name", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_filter_with_name", "app", "bp", "flask", "blueprint", "bp", "__name__", "def", "my_reverse", "s", "return", "s", "1", "bp", "add_app_template_filter", "my_reverse", "strrev", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "strrev", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "strrev", "my_reverse", "assert", "app", "jinja_env", "filters", "strrev", "abcd", "dcba"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_template_filter_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_filter_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_filter_with_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_filter", "def", "super_reverse", "s", "return", "s", "1", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 44}
{"doc_id": "tests/test_blueprints.py::test_template_filter_after_route_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_filter_after_route_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_filter_after_route_with_template", "app", "client", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_filter", "def", "super_reverse", "s", "return", "s", "1", "app", "register_blueprint", "bp", "url_prefix", "py", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 44}
{"doc_id": "tests/test_blueprints.py::test_add_template_filter_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_filter_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_filter_with_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "def", "super_reverse", "s", "return", "s", "1", "bp", "add_app_template_filter", "super_reverse", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_template_filter_with_name_and_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_filter_with_name_and_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_filter_with_name_and_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_filter", "super_reverse", "def", "my_reverse", "s", "return", "s", "1", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_add_template_filter_with_name_and_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_filter_with_name_and_template", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_filter_with_name_and_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "def", "my_reverse", "s", "return", "s", "1", "bp", "add_app_template_filter", "my_reverse", "super_reverse", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_template_test", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_test", "text": "文件路径: tests/test_blueprints.py\ndef test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_test", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_test", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "is_boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "is_boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "is_boolean", "false"], "doc_len": 44}
{"doc_id": "tests/test_blueprints.py::test_add_template_test", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_test", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_test", "app", "bp", "flask", "blueprint", "bp", "__name__", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "bp", "add_app_template_test", "is_boolean", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "is_boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "is_boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "is_boolean", "false"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_template_test_with_name", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_test_with_name", "text": "文件路径: tests/test_blueprints.py\ndef test_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_test_with_name", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_test", "boolean", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 45}
{"doc_id": "tests/test_blueprints.py::test_add_template_test_with_name", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_test_with_name", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_test_with_name", "app", "bp", "flask", "blueprint", "bp", "__name__", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "bp", "add_app_template_test", "is_boolean", "boolean", "app", "register_blueprint", "bp", "url_prefix", "py", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_template_test_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_test_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_test_with_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_test", "def", "boolean", "value", "return", "isinstance", "value", "bool", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_template_test_after_route_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_test_after_route_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_test_after_route_with_template", "app", "client", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_test", "def", "boolean", "value", "return", "isinstance", "value", "bool", "app", "register_blueprint", "bp", "url_prefix", "py", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 46}
{"doc_id": "tests/test_blueprints.py::test_add_template_test_with_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_test_with_template", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_test_with_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "def", "boolean", "value", "return", "isinstance", "value", "bool", "bp", "add_app_template_test", "boolean", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 47}
{"doc_id": "tests/test_blueprints.py::test_template_test_with_name_and_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_test_with_name_and_template", "text": "文件路径: tests/test_blueprints.py\ndef test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_test_with_name_and_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_test", "boolean", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 47}
{"doc_id": "tests/test_blueprints.py::test_add_template_test_with_name_and_template", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_add_template_test_with_name_and_template", "text": "文件路径: tests/test_blueprints.py\ndef test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_add_template_test_with_name_and_template", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "bp", "add_app_template_test", "is_boolean", "boolean", "app", "register_blueprint", "bp", "url_prefix", "py", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 48}
{"doc_id": "tests/test_blueprints.py::test_context_processing", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_context_processing", "text": "文件路径: tests/test_blueprints.py\ndef test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    template_string = lambda: flask.render_template_string(  # noqa: E731\n        \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n        \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n    )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_context_processing", "app", "client", "answer_bp", "flask", "blueprint", "answer_bp", "__name__", "template_string", "lambda", "flask", "render_template_string", "noqa", "e731", "if", "notanswer", "notanswer", "is", "not", "the", "answer", "endif", "if", "answer", "answer", "is", "the", "answer", "endif", "app", "global", "context", "processor", "answer_bp", "app_context_processor", "def", "not_answer_context_processor", "return", "notanswer", "43", "blueprint", "local", "context", "processor", "answer_bp", "context_processor", "def", "answer_context_processor", "return", "answer", "42", "setup", "endpoints", "for", "testing", "answer_bp", "route", "bp", "def", "bp_page", "return", "template_string", "app", "route", "def", "app_page", "return", "template_string", "register", "the", "blueprint", "app", "register_blueprint", "answer_bp", "app_page_bytes", "client", "get", "data", "answer_page_bytes", "client", "get", "bp", "data", "assert", "b", "43", "in", "app_page_bytes", "assert", "b", "42", "not", "in", "app_page_bytes", "assert", "b", "42", "in", "answer_page_bytes", "assert", "b", "43", "in", "answer_page_bytes"], "doc_len": 108}
{"doc_id": "tests/test_blueprints.py::test_template_global", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_template_global", "text": "文件路径: tests/test_blueprints.py\ndef test_template_global(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_template_global", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "app_template_global", "def", "get_answer", "return", "42", "make", "sure", "the", "function", "is", "not", "in", "the", "jinja_env", "already", "assert", "get_answer", "not", "in", "app", "jinja_env", "globals", "keys", "app", "register_blueprint", "bp", "tests", "assert", "get_answer", "in", "app", "jinja_env", "globals", "keys", "assert", "app", "jinja_env", "globals", "get_answer", "is", "get_answer", "assert", "app", "jinja_env", "globals", "get_answer", "42", "with", "app", "app_context", "rv", "flask", "render_template_string", "get_answer", "assert", "rv", "42"], "doc_len": 69}
{"doc_id": "tests/test_blueprints.py::test_request_processing", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_request_processing", "text": "文件路径: tests/test_blueprints.py\ndef test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_request_processing", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "evts", "bp", "before_request", "def", "before_bp", "evts", "append", "before", "bp", "after_request", "def", "after_bp", "response", "response", "data", "b", "after", "evts", "append", "after", "return", "response", "bp", "teardown_request", "def", "teardown_bp", "exc", "evts", "append", "teardown", "setup", "routes", "for", "testing", "bp", "route", "bp", "def", "bp_endpoint", "return", "request", "app", "register_blueprint", "bp", "assert", "evts", "rv", "client", "get", "bp", "assert", "rv", "data", "b", "request", "after", "assert", "evts", "before", "after", "teardown"], "doc_len": 73}
{"doc_id": "tests/test_blueprints.py::test_app_request_processing", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_app_request_processing", "text": "文件路径: tests/test_blueprints.py\ndef test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_app_request_processing", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "evts", "bp", "before_app_request", "def", "before_app", "evts", "append", "before", "bp", "after_app_request", "def", "after_app", "response", "response", "data", "b", "after", "evts", "append", "after", "return", "response", "bp", "teardown_app_request", "def", "teardown_app", "exc", "evts", "append", "teardown", "app", "register_blueprint", "bp", "setup", "routes", "for", "testing", "app", "route", "def", "bp_endpoint", "return", "request", "before", "first", "request", "assert", "evts", "first", "request", "resp", "client", "get", "data", "assert", "resp", "b", "request", "after", "assert", "evts", "before", "after", "teardown", "second", "request", "resp", "client", "get", "data", "assert", "resp", "b", "request", "after", "assert", "evts", "before", "after", "teardown", "2"], "doc_len": 93}
{"doc_id": "tests/test_blueprints.py::test_app_url_processors", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_app_url_processors", "text": "文件路径: tests/test_blueprints.py\ndef test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_app_url_processors", "app", "client", "bp", "flask", "blueprint", "bp", "__name__", "register", "app", "wide", "url", "defaults", "and", "preprocessor", "on", "blueprint", "bp", "app_url_defaults", "def", "add_language_code", "endpoint", "values", "values", "setdefault", "lang_code", "flask", "g", "lang_code", "bp", "app_url_value_preprocessor", "def", "pull_lang_code", "endpoint", "values", "flask", "g", "lang_code", "values", "pop", "lang_code", "register", "route", "rules", "at", "the", "app", "level", "app", "route", "lang_code", "def", "index", "return", "flask", "url_for", "about", "app", "route", "lang_code", "about", "def", "about", "return", "flask", "url_for", "index", "app", "register_blueprint", "bp", "assert", "client", "get", "de", "data", "b", "de", "about", "assert", "client", "get", "de", "about", "data", "b", "de"], "doc_len": 90}
{"doc_id": "tests/test_blueprints.py::test_nested_blueprint", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_nested_blueprint", "text": "文件路径: tests/test_blueprints.py\ndef test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_nested_blueprint", "app", "client", "parent", "flask", "blueprint", "parent", "__name__", "child", "flask", "blueprint", "child", "__name__", "grandchild", "flask", "blueprint", "grandchild", "__name__", "parent", "errorhandler", "403", "def", "forbidden", "e", "return", "parent", "no", "403", "parent", "route", "def", "parent_index", "return", "parent", "yes", "parent", "route", "no", "def", "parent_no", "flask", "abort", "403", "child", "route", "def", "child_index", "return", "child", "yes", "child", "route", "no", "def", "child_no", "flask", "abort", "403", "grandchild", "errorhandler", "403", "def", "grandchild_forbidden", "e", "return", "grandchild", "no", "403", "grandchild", "route", "def", "grandchild_index", "return", "grandchild", "yes", "grandchild", "route", "no", "def", "grandchild_no", "flask", "abort", "403", "child", "register_blueprint", "grandchild", "url_prefix", "grandchild", "parent", "register_blueprint", "child", "url_prefix", "child", "app", "register_blueprint", "parent", "url_prefix", "parent", "assert", "client", "get", "parent", "data", "b", "parent", "yes", "assert", "client", "get", "parent", "child", "data", "b", "child", "yes", "assert", "client", "get", "parent", "child", "grandchild", "data", "b", "grandchild", "yes", "assert", "client", "get", "parent", "no", "data", "b", "parent", "no", "assert", "client", "get", "parent", "child", "no", "data", "b", "parent", "no", "assert", "client", "get", "parent", "child", "grandchild", "no", "data", "b", "grandchild", "no"], "doc_len": 159}
{"doc_id": "tests/test_blueprints.py::test_nested_callback_order", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_nested_callback_order", "text": "文件路径: tests/test_blueprints.py\ndef test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_nested_callback_order", "app", "client", "parent", "flask", "blueprint", "parent", "__name__", "child", "flask", "blueprint", "child", "__name__", "app", "before_request", "def", "app_before1", "flask", "g", "setdefault", "seen", "append", "app_1", "app", "teardown_request", "def", "app_teardown1", "e", "none", "assert", "flask", "g", "seen", "pop", "app_1", "app", "before_request", "def", "app_before2", "flask", "g", "setdefault", "seen", "append", "app_2", "app", "teardown_request", "def", "app_teardown2", "e", "none", "assert", "flask", "g", "seen", "pop", "app_2", "app", "context_processor", "def", "app_ctx", "return", "dict", "key", "app", "parent", "before_request", "def", "parent_before1", "flask", "g", "setdefault", "seen", "append", "parent_1", "parent", "teardown_request", "def", "parent_teardown1", "e", "none", "assert", "flask", "g", "seen", "pop", "parent_1", "parent", "before_request", "def", "parent_before2", "flask", "g", "setdefault", "seen", "append", "parent_2", "parent", "teardown_request", "def", "parent_teardown2", "e", "none", "assert", "flask", "g", "seen", "pop", "parent_2", "parent", "context_processor", "def", "parent_ctx", "return", "dict", "key", "parent", "child", "before_request", "def", "child_before1", "flask", "g", "setdefault", "seen", "append", "child_1", "child", "teardown_request", "def", "child_teardown1", "e", "none", "assert", "flask", "g", "seen", "pop", "child_1", "child", "before_request", "def", "child_before2", "flask", "g", "setdefault", "seen", "append", "child_2", "child", "teardown_request", "def", "child_teardown2", "e", "none", "assert", "flask", "g", "seen", "pop", "child_2", "child", "context_processor", "def", "child_ctx", "return", "dict", "key", "child", "child", "route", "a", "def", "a", "return", "join", "flask", "g", "seen", "child", "route", "b", "def", "b", "return", "flask", "render_template_string", "key", "parent", "register_blueprint", "child", "app", "register_blueprint", "parent", "assert", "client", "get", "a", "data", "b", "app_1", "app_2", "parent_1", "parent_2", "child_1", "child_2", "assert", "client", "get", "b", "data", "b", "child"], "doc_len": 217}
{"doc_id": "tests/test_blueprints.py::test_nesting_url_prefixes", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_nesting_url_prefixes", "text": "文件路径: tests/test_blueprints.py\ndef test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_nesting_url_prefixes", "parent_init", "child_init", "parent_registration", "child_registration", "app", "client", "none", "parent", "flask", "blueprint", "parent", "__name__", "url_prefix", "parent_init", "child", "flask", "blueprint", "child", "__name__", "url_prefix", "child_init", "child", "route", "def", "index", "return", "index", "parent", "register_blueprint", "child", "url_prefix", "child_registration", "app", "register_blueprint", "parent", "url_prefix", "parent_registration", "response", "client", "get", "parent", "child", "assert", "response", "status_code", "200"], "doc_len": 51}
{"doc_id": "tests/test_blueprints.py::test_nesting_subdomains", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_nesting_subdomains", "text": "文件路径: tests/test_blueprints.py\ndef test_nesting_subdomains(app, client) -> None:\n    subdomain = \"api\"\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=subdomain)\n\n    client.allow_subdomain_redirects = True\n\n    domain_name = \"domain.tld\"\n    app.config[\"SERVER_NAME\"] = domain_name\n    response = client.get(\"/child/\", base_url=\"http://api.\" + domain_name)\n\n    assert response.status_code == 200\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_nesting_subdomains", "app", "client", "none", "subdomain", "api", "parent", "flask", "blueprint", "parent", "__name__", "child", "flask", "blueprint", "child", "__name__", "child", "route", "child", "def", "index", "return", "child", "parent", "register_blueprint", "child", "app", "register_blueprint", "parent", "subdomain", "subdomain", "client", "allow_subdomain_redirects", "true", "domain_name", "domain", "tld", "app", "config", "server_name", "domain_name", "response", "client", "get", "child", "base_url", "http", "api", "domain_name", "assert", "response", "status_code", "200"], "doc_len": 57}
{"doc_id": "tests/test_blueprints.py::test_child_and_parent_subdomain", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_child_and_parent_subdomain", "text": "文件路径: tests/test_blueprints.py\ndef test_child_and_parent_subdomain(app, client) -> None:\n    child_subdomain = \"api\"\n    parent_subdomain = \"parent\"\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=child_subdomain)\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=parent_subdomain)\n\n    client.allow_subdomain_redirects = True\n\n    domain_name = \"domain.tld\"\n    app.config[\"SERVER_NAME\"] = domain_name\n    response = client.get(\n        \"/\", base_url=f\"http://{child_subdomain}.{parent_subdomain}.{domain_name}\"\n    )\n\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=f\"http://{parent_subdomain}.{domain_name}\")\n\n    assert response.status_code == 404\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_child_and_parent_subdomain", "app", "client", "none", "child_subdomain", "api", "parent_subdomain", "parent", "parent", "flask", "blueprint", "parent", "__name__", "child", "flask", "blueprint", "child", "__name__", "subdomain", "child_subdomain", "child", "route", "def", "index", "return", "child", "parent", "register_blueprint", "child", "app", "register_blueprint", "parent", "subdomain", "parent_subdomain", "client", "allow_subdomain_redirects", "true", "domain_name", "domain", "tld", "app", "config", "server_name", "domain_name", "response", "client", "get", "base_url", "f", "http", "child_subdomain", "parent_subdomain", "domain_name", "assert", "response", "status_code", "200", "response", "client", "get", "base_url", "f", "http", "parent_subdomain", "domain_name", "assert", "response", "status_code", "404"], "doc_len": 73}
{"doc_id": "tests/test_blueprints.py::test_unique_blueprint_names", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_unique_blueprint_names", "text": "文件路径: tests/test_blueprints.py\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_unique_blueprint_names", "app", "client", "none", "bp", "flask", "blueprint", "bp", "__name__", "bp2", "flask", "blueprint", "bp", "__name__", "app", "register_blueprint", "bp", "with", "pytest", "raises", "valueerror", "app", "register_blueprint", "bp", "same", "bp", "same", "name", "error", "app", "register_blueprint", "bp", "name", "again", "same", "bp", "different", "name", "ok", "with", "pytest", "raises", "valueerror", "app", "register_blueprint", "bp2", "different", "bp", "same", "name", "error", "app", "register_blueprint", "bp2", "name", "alt", "different", "bp", "different", "name", "ok"], "doc_len": 65}
{"doc_id": "tests/test_blueprints.py::test_self_registration", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_self_registration", "text": "文件路径: tests/test_blueprints.py\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_self_registration", "app", "client", "none", "bp", "flask", "blueprint", "bp", "__name__", "with", "pytest", "raises", "valueerror", "bp", "register_blueprint", "bp"], "doc_len": 20}
{"doc_id": "tests/test_blueprints.py::test_blueprint_renaming", "file_path": "tests/test_blueprints.py", "class_name": null, "func_name": "test_blueprint_renaming", "text": "文件路径: tests/test_blueprints.py\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n", "tokens": ["tests", "test_blueprints", "py", "def", "test_blueprint_renaming", "app", "client", "none", "bp", "flask", "blueprint", "bp", "__name__", "bp2", "flask", "blueprint", "bp2", "__name__", "bp", "get", "def", "index", "return", "flask", "request", "endpoint", "bp", "get", "error", "def", "error", "flask", "abort", "403", "bp", "errorhandler", "403", "def", "forbidden", "_", "exception", "return", "error", "403", "bp2", "get", "def", "index2", "return", "flask", "request", "endpoint", "bp", "register_blueprint", "bp2", "url_prefix", "a", "name", "sub", "app", "register_blueprint", "bp", "url_prefix", "a", "app", "register_blueprint", "bp", "url_prefix", "b", "name", "alt", "assert", "client", "get", "a", "data", "b", "bp", "index", "assert", "client", "get", "b", "data", "b", "alt", "index", "assert", "client", "get", "a", "a", "data", "b", "bp", "sub", "index2", "assert", "client", "get", "b", "a", "data", "b", "alt", "sub", "index2", "assert", "client", "get", "a", "error", "data", "b", "error", "assert", "client", "get", "b", "error", "data", "b", "error"], "doc_len": 123}
{"doc_id": "tests/test_cli.py::runner", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "runner", "text": "文件路径: tests/test_cli.py\ndef runner():\n    return CliRunner()\n", "tokens": ["tests", "test_cli", "py", "def", "runner", "return", "clirunner"], "doc_len": 7}
{"doc_id": "tests/test_cli.py::test_cli_name", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_cli_name", "text": "文件路径: tests/test_cli.py\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name\n", "tokens": ["tests", "test_cli", "py", "def", "test_cli_name", "test_apps", "make", "sure", "the", "cli", "object", "s", "name", "is", "the", "app", "s", "name", "and", "not", "the", "app", "itself", "from", "cliapp", "app", "import", "testapp", "assert", "testapp", "cli", "name", "testapp", "name"], "doc_len": 34}
{"doc_id": "tests/test_cli.py::test_find_best_app", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_find_best_app", "text": "文件路径: tests/test_cli.py\ndef test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)\n", "tokens": ["tests", "test_cli", "py", "def", "test_find_best_app", "test_apps", "class", "module", "app", "flask", "appname", "assert", "find_best_app", "module", "module", "app", "class", "module", "application", "flask", "appname", "assert", "find_best_app", "module", "module", "application", "class", "module", "myapp", "flask", "appname", "assert", "find_best_app", "module", "module", "myapp", "class", "module", "staticmethod", "def", "create_app", "return", "flask", "appname", "app", "find_best_app", "module", "assert", "isinstance", "app", "flask", "assert", "app", "name", "appname", "class", "module", "staticmethod", "def", "create_app", "kwargs", "return", "flask", "appname", "app", "find_best_app", "module", "assert", "isinstance", "app", "flask", "assert", "app", "name", "appname", "class", "module", "staticmethod", "def", "make_app", "return", "flask", "appname", "app", "find_best_app", "module", "assert", "isinstance", "app", "flask", "assert", "app", "name", "appname", "class", "module", "myapp", "flask", "appname1", "staticmethod", "def", "create_app", "return", "flask", "appname2", "assert", "find_best_app", "module", "module", "myapp", "class", "module", "myapp", "flask", "appname1", "staticmethod", "def", "create_app", "return", "flask", "appname2", "assert", "find_best_app", "module", "module", "myapp", "class", "module", "pass", "pytest", "raises", "noappexception", "find_best_app", "module", "class", "module", "myapp1", "flask", "appname1", "myapp2", "flask", "appname2", "pytest", "raises", "noappexception", "find_best_app", "module", "class", "module", "staticmethod", "def", "create_app", "foo", "bar", "return", "flask", "appname2", "pytest", "raises", "noappexception", "find_best_app", "module", "class", "module", "staticmethod", "def", "create_app", "raise", "typeerror", "bad", "bad", "factory", "pytest", "raises", "typeerror", "find_best_app", "module"], "doc_len": 177}
{"doc_id": "tests/test_cli.py::test_prepare_import", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_prepare_import", "text": "文件路径: tests/test_cli.py\ndef test_prepare_import(request, value, path, result):\n    \"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"\n    original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == str(path)\n", "tokens": ["tests", "test_cli", "py", "def", "test_prepare_import", "request", "value", "path", "result", "expect", "the", "correct", "path", "to", "be", "set", "and", "the", "correct", "import", "and", "app", "names", "to", "be", "returned", "func", "prepare_exec_for_file", "has", "a", "side", "effect", "where", "the", "parent", "directory", "of", "the", "given", "import", "is", "added", "to", "data", "sys", "path", "this", "is", "reset", "after", "the", "test", "runs", "original_path", "sys", "path", "def", "reset_path", "sys", "path", "original_path", "request", "addfinalizer", "reset_path", "assert", "prepare_import", "value", "result", "assert", "sys", "path", "0", "str", "path"], "doc_len": 74}
{"doc_id": "tests/test_cli.py::test_locate_app", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_locate_app", "text": "文件路径: tests/test_cli.py\ndef test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result\n", "tokens": ["tests", "test_cli", "py", "def", "test_locate_app", "test_apps", "iname", "aname", "result", "assert", "locate_app", "iname", "aname", "name", "result"], "doc_len": 15}
{"doc_id": "tests/test_cli.py::test_locate_app_raises", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_locate_app_raises", "text": "文件路径: tests/test_cli.py\ndef test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)\n", "tokens": ["tests", "test_cli", "py", "def", "test_locate_app_raises", "test_apps", "iname", "aname", "with", "pytest", "raises", "noappexception", "locate_app", "iname", "aname"], "doc_len": 15}
{"doc_id": "tests/test_cli.py::test_locate_app_suppress_raise", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_locate_app_suppress_raise", "text": "文件路径: tests/test_cli.py\ndef test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)\n", "tokens": ["tests", "test_cli", "py", "def", "test_locate_app_suppress_raise", "test_apps", "app", "locate_app", "notanapp", "py", "none", "raise_if_not_found", "false", "assert", "app", "is", "none", "only", "direct", "import", "error", "is", "suppressed", "with", "pytest", "raises", "noappexception", "locate_app", "cliapp", "importerrorapp", "none", "raise_if_not_found", "false"], "doc_len": 33}
{"doc_id": "tests/test_cli.py::test_get_version", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_get_version", "text": "文件路径: tests/test_cli.py\ndef test_get_version(test_apps, capsys):\n    from flask import __version__ as flask_version\n    from werkzeug import __version__ as werkzeug_version\n    from platform import python_version\n\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {python_version()}\" in out\n    assert f\"Flask {flask_version}\" in out\n    assert f\"Werkzeug {werkzeug_version}\" in out\n", "tokens": ["tests", "test_cli", "py", "def", "test_get_version", "test_apps", "capsys", "from", "flask", "import", "__version__", "as", "flask_version", "from", "werkzeug", "import", "__version__", "as", "werkzeug_version", "from", "platform", "import", "python_version", "class", "mockctx", "resilient_parsing", "false", "color", "none", "def", "exit", "self", "return", "ctx", "mockctx", "get_version", "ctx", "none", "test", "out", "err", "capsys", "readouterr", "assert", "f", "python", "python_version", "in", "out", "assert", "f", "flask", "flask_version", "in", "out", "assert", "f", "werkzeug", "werkzeug_version", "in", "out"], "doc_len": 61}
{"doc_id": "tests/test_cli.py::test_scriptinfo", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_scriptinfo", "text": "文件路径: tests/test_cli.py\ndef test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_scriptinfo", "test_apps", "monkeypatch", "obj", "scriptinfo", "app_import_path", "cliapp", "app", "testapp", "app", "obj", "load_app", "assert", "app", "name", "testapp", "assert", "obj", "load_app", "is", "app", "import", "app", "with", "module", "s", "absolute", "path", "cli_app_path", "str", "test_path", "cliapp", "app", "py", "obj", "scriptinfo", "app_import_path", "cli_app_path", "app", "obj", "load_app", "assert", "app", "name", "testapp", "assert", "obj", "load_app", "is", "app", "obj", "scriptinfo", "app_import_path", "f", "cli_app_path", "testapp", "app", "obj", "load_app", "assert", "app", "name", "testapp", "assert", "obj", "load_app", "is", "app", "def", "create_app", "return", "flask", "createapp", "obj", "scriptinfo", "create_app", "create_app", "app", "obj", "load_app", "assert", "app", "name", "createapp", "assert", "obj", "load_app", "is", "app", "obj", "scriptinfo", "pytest", "raises", "noappexception", "obj", "load_app", "import", "app", "from", "wsgi", "py", "in", "current", "directory", "monkeypatch", "chdir", "test_path", "helloworld", "obj", "scriptinfo", "app", "obj", "load_app", "assert", "app", "name", "hello", "import", "app", "from", "app", "py", "in", "current", "directory", "monkeypatch", "chdir", "test_path", "cliapp", "obj", "scriptinfo", "app", "obj", "load_app", "assert", "app", "name", "testapp"], "doc_len": 142}
{"doc_id": "tests/test_cli.py::test_app_cli_has_app_context", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_app_cli_has_app_context", "text": "文件路径: tests/test_cli.py\ndef test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)\n", "tokens": ["tests", "test_cli", "py", "def", "test_app_cli_has_app_context", "app", "runner", "def", "_param_cb", "ctx", "param", "value", "current_app", "should", "be", "available", "in", "parameter", "callbacks", "return", "bool", "current_app", "app", "cli", "command", "click", "argument", "value", "callback", "_param_cb", "def", "check", "value", "app", "click", "get_current_context", "obj", "load_app", "the", "loaded", "app", "should", "be", "the", "same", "as", "current_app", "same_app", "current_app", "_get_current_object", "is", "app", "return", "same_app", "value", "cli", "flaskgroup", "create_app", "lambda", "app", "result", "runner", "invoke", "cli", "check", "x", "standalone_mode", "false", "assert", "result", "return_value", "true", "true"], "doc_len": 73}
{"doc_id": "tests/test_cli.py::test_with_appcontext", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_with_appcontext", "text": "文件路径: tests/test_cli.py\ndef test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_with_appcontext", "runner", "click", "command", "with_appcontext", "def", "testcmd", "click", "echo", "current_app", "name", "obj", "scriptinfo", "create_app", "lambda", "flask", "testapp", "result", "runner", "invoke", "testcmd", "obj", "obj", "assert", "result", "exit_code", "0", "assert", "result", "output", "testapp", "n"], "doc_len": 36}
{"doc_id": "tests/test_cli.py::test_appgroup_app_context", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_appgroup_app_context", "text": "文件路径: tests/test_cli.py\ndef test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_appgroup_app_context", "runner", "click", "group", "cls", "appgroup", "def", "cli", "pass", "cli", "command", "def", "test", "click", "echo", "current_app", "name", "cli", "group", "def", "subgroup", "pass", "subgroup", "command", "def", "test2", "click", "echo", "current_app", "name", "obj", "scriptinfo", "create_app", "lambda", "flask", "testappgroup", "result", "runner", "invoke", "cli", "test", "obj", "obj", "assert", "result", "exit_code", "0", "assert", "result", "output", "testappgroup", "n", "result", "runner", "invoke", "cli", "subgroup", "test2", "obj", "obj", "assert", "result", "exit_code", "0", "assert", "result", "output", "testappgroup", "n"], "doc_len": 73}
{"doc_id": "tests/test_cli.py::test_flaskgroup_app_context", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_flaskgroup_app_context", "text": "文件路径: tests/test_cli.py\ndef test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_flaskgroup_app_context", "runner", "def", "create_app", "return", "flask", "flaskgroup", "click", "group", "cls", "flaskgroup", "create_app", "create_app", "def", "cli", "params", "pass", "cli", "command", "def", "test", "click", "echo", "current_app", "name", "result", "runner", "invoke", "cli", "test", "assert", "result", "exit_code", "0", "assert", "result", "output", "flaskgroup", "n"], "doc_len": 43}
{"doc_id": "tests/test_cli.py::test_flaskgroup_debug", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_flaskgroup_debug", "text": "文件路径: tests/test_cli.py\ndef test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_flaskgroup_debug", "runner", "set_debug_flag", "def", "create_app", "app", "flask", "flaskgroup", "app", "debug", "true", "return", "app", "click", "group", "cls", "flaskgroup", "create_app", "create_app", "set_debug_flag", "set_debug_flag", "def", "cli", "params", "pass", "cli", "command", "def", "test", "click", "echo", "str", "current_app", "debug", "result", "runner", "invoke", "cli", "test", "assert", "result", "exit_code", "0", "assert", "result", "output", "f", "not", "set_debug_flag", "n"], "doc_len": 54}
{"doc_id": "tests/test_cli.py::test_flaskgroup_nested", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_flaskgroup_nested", "text": "文件路径: tests/test_cli.py\ndef test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_flaskgroup_nested", "app", "runner", "cli", "click", "group", "cli", "flask_group", "flaskgroup", "name", "flask", "create_app", "lambda", "app", "cli", "add_command", "flask_group", "flask_group", "command", "def", "show", "click", "echo", "current_app", "name", "result", "runner", "invoke", "cli", "flask", "show", "assert", "result", "output", "flask_test", "n"], "doc_len": 40}
{"doc_id": "tests/test_cli.py::test_no_command_echo_loading_error", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_no_command_echo_loading_error", "text": "文件路径: tests/test_cli.py\ndef test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr\n", "tokens": ["tests", "test_cli", "py", "def", "test_no_command_echo_loading_error", "from", "flask", "cli", "import", "cli", "runner", "clirunner", "mix_stderr", "false", "result", "runner", "invoke", "cli", "missing", "assert", "result", "exit_code", "2", "assert", "flask_app", "in", "result", "stderr", "assert", "usage", "in", "result", "stderr"], "doc_len": 33}
{"doc_id": "tests/test_cli.py::test_help_echo_loading_error", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_help_echo_loading_error", "text": "文件路径: tests/test_cli.py\ndef test_help_echo_loading_error():\n    from flask.cli import cli\n\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout\n", "tokens": ["tests", "test_cli", "py", "def", "test_help_echo_loading_error", "from", "flask", "cli", "import", "cli", "runner", "clirunner", "mix_stderr", "false", "result", "runner", "invoke", "cli", "help", "assert", "result", "exit_code", "0", "assert", "flask_app", "in", "result", "stderr", "assert", "usage", "in", "result", "stdout"], "doc_len": 33}
{"doc_id": "tests/test_cli.py::test_help_echo_exception", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_help_echo_exception", "text": "文件路径: tests/test_cli.py\ndef test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n    runner = CliRunner(mix_stderr=False)\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout\n", "tokens": ["tests", "test_cli", "py", "def", "test_help_echo_exception", "def", "create_app", "raise", "exception", "oh", "no", "cli", "flaskgroup", "create_app", "create_app", "runner", "clirunner", "mix_stderr", "false", "result", "runner", "invoke", "cli", "help", "assert", "result", "exit_code", "0", "assert", "exception", "oh", "no", "in", "result", "stderr", "assert", "usage", "in", "result", "stdout"], "doc_len": 40}
{"doc_id": "tests/test_cli.py::TestRoutes.app", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "app", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def app(self):\n        app = Flask(__name__)\n        app.testing = True\n\n        @app.route(\"/get_post/<int:x>/<int:y>\", methods=[\"GET\", \"POST\"])\n        def yyy_get_post(x, y):\n            pass\n\n        @app.route(\"/zzz_post\", methods=[\"POST\"])\n        def aaa_post():\n            pass\n\n        return app\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "app", "self", "app", "flask", "__name__", "app", "testing", "true", "app", "route", "get_post", "int", "x", "int", "y", "methods", "get", "post", "def", "yyy_get_post", "x", "y", "pass", "app", "route", "zzz_post", "methods", "post", "def", "aaa_post", "pass", "return", "app"], "doc_len": 38}
{"doc_id": "tests/test_cli.py::TestRoutes.invoke", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "invoke", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "invoke", "self", "app", "runner", "cli", "flaskgroup", "create_app", "lambda", "app", "return", "partial", "runner", "invoke", "cli"], "doc_len": 19}
{"doc_id": "tests/test_cli.py::TestRoutes.invoke_no_routes", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "invoke_no_routes", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def invoke_no_routes(self, runner):\n        def create_app():\n            app = Flask(__name__, static_folder=None)\n            app.testing = True\n\n            return app\n\n        cli = FlaskGroup(create_app=create_app)\n        return partial(runner.invoke, cli)\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "invoke_no_routes", "self", "runner", "def", "create_app", "app", "flask", "__name__", "static_folder", "none", "app", "testing", "true", "return", "app", "cli", "flaskgroup", "create_app", "create_app", "return", "partial", "runner", "invoke", "cli"], "doc_len": 29}
{"doc_id": "tests/test_cli.py::TestRoutes.expect_order", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "expect_order", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:]):\n            # do this instead of startswith for nicer pytest output\n            assert line[: len(expect)] == expect\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "expect_order", "self", "order", "output", "skip", "the", "header", "and", "match", "the", "start", "of", "each", "row", "for", "expect", "line", "in", "zip", "order", "output", "splitlines", "2", "do", "this", "instead", "of", "startswith", "for", "nicer", "pytest", "output", "assert", "line", "len", "expect", "expect"], "doc_len": 42}
{"doc_id": "tests/test_cli.py::TestRoutes.test_simple", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "test_simple", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "test_simple", "self", "invoke", "result", "invoke", "routes", "assert", "result", "exit_code", "0", "self", "expect_order", "aaa_post", "static", "yyy_get_post", "result", "output"], "doc_len": 22}
{"doc_id": "tests/test_cli.py::TestRoutes.test_sort", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "test_sort", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "test_sort", "self", "app", "invoke", "default_output", "invoke", "routes", "output", "endpoint_output", "invoke", "routes", "s", "endpoint", "output", "assert", "default_output", "endpoint_output", "self", "expect_order", "static", "yyy_get_post", "aaa_post", "invoke", "routes", "s", "methods", "output", "self", "expect_order", "yyy_get_post", "static", "aaa_post", "invoke", "routes", "s", "rule", "output", "match_order", "r", "endpoint", "for", "r", "in", "app", "url_map", "iter_rules", "self", "expect_order", "match_order", "invoke", "routes", "s", "match", "output"], "doc_len": 59}
{"doc_id": "tests/test_cli.py::TestRoutes.test_all_methods", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "test_all_methods", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "test_all_methods", "self", "invoke", "output", "invoke", "routes", "output", "assert", "get", "head", "options", "post", "not", "in", "output", "output", "invoke", "routes", "all", "methods", "output", "assert", "get", "head", "options", "post", "in", "output"], "doc_len": 33}
{"doc_id": "tests/test_cli.py::TestRoutes.test_no_routes", "file_path": "tests/test_cli.py", "class_name": "TestRoutes", "func_name": "test_no_routes", "text": "文件路径: tests/test_cli.py, 类名: TestRoutes\n    def test_no_routes(self, invoke_no_routes):\n        result = invoke_no_routes([\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output\n", "tokens": ["tests", "test_cli", "py", "testroutes", "def", "test_no_routes", "self", "invoke_no_routes", "result", "invoke_no_routes", "routes", "assert", "result", "exit_code", "0", "assert", "no", "routes", "were", "registered", "in", "result", "output"], "doc_len": 23}
{"doc_id": "tests/test_cli.py::dotenv_not_available", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "dotenv_not_available", "text": "文件路径: tests/test_cli.py\ndef dotenv_not_available():\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        return True\n\n    return False\n", "tokens": ["tests", "test_cli", "py", "def", "dotenv_not_available", "try", "import", "dotenv", "noqa", "f401", "except", "importerror", "return", "true", "return", "false"], "doc_len": 16}
{"doc_id": "tests/test_cli.py::test_load_dotenv", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_load_dotenv", "text": "文件路径: tests/test_cli.py\ndef test_load_dotenv(monkeypatch):\n    # can't use monkeypatch.delitem since the keys don't exist yet\n    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(test_path)\n    assert load_dotenv()\n    assert Path.cwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n    # test env file encoding\n    assert os.environ[\"HAM\"] == \"火腿\"\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\")\n", "tokens": ["tests", "test_cli", "py", "def", "test_load_dotenv", "monkeypatch", "can", "t", "use", "monkeypatch", "delitem", "since", "the", "keys", "don", "t", "exist", "yet", "for", "item", "in", "foo", "bar", "spam", "ham", "monkeypatch", "_setitem", "append", "os", "environ", "item", "notset", "monkeypatch", "setenv", "eggs", "3", "monkeypatch", "chdir", "test_path", "assert", "load_dotenv", "assert", "path", "cwd", "test_path", "flaskenv", "doesn", "t", "overwrite", "env", "assert", "os", "environ", "foo", "env", "set", "only", "in", "flaskenv", "assert", "os", "environ", "bar", "bar", "set", "only", "in", "env", "assert", "os", "environ", "spam", "1", "set", "manually", "files", "don", "t", "overwrite", "assert", "os", "environ", "eggs", "3", "test", "env", "file", "encoding", "assert", "os", "environ", "ham", "non", "existent", "file", "should", "not", "load", "assert", "not", "load_dotenv", "non", "existent", "file"], "doc_len": 104}
{"doc_id": "tests/test_cli.py::test_dotenv_path", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_dotenv_path", "text": "文件路径: tests/test_cli.py\ndef test_dotenv_path(monkeypatch):\n    for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    load_dotenv(test_path / \".flaskenv\")\n    assert Path.cwd() == cwd\n    assert \"FOO\" in os.environ\n", "tokens": ["tests", "test_cli", "py", "def", "test_dotenv_path", "monkeypatch", "for", "item", "in", "foo", "bar", "eggs", "monkeypatch", "_setitem", "append", "os", "environ", "item", "notset", "load_dotenv", "test_path", "flaskenv", "assert", "path", "cwd", "cwd", "assert", "foo", "in", "os", "environ"], "doc_len": 31}
{"doc_id": "tests/test_cli.py::test_dotenv_optional", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_dotenv_optional", "text": "文件路径: tests/test_cli.py\ndef test_dotenv_optional(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ\n", "tokens": ["tests", "test_cli", "py", "def", "test_dotenv_optional", "monkeypatch", "monkeypatch", "setitem", "sys", "modules", "dotenv", "none", "monkeypatch", "chdir", "test_path", "load_dotenv", "assert", "foo", "not", "in", "os", "environ"], "doc_len": 22}
{"doc_id": "tests/test_cli.py::test_disable_dotenv_from_env", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_disable_dotenv_from_env", "text": "文件路径: tests/test_cli.py\ndef test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ\n", "tokens": ["tests", "test_cli", "py", "def", "test_disable_dotenv_from_env", "monkeypatch", "runner", "monkeypatch", "chdir", "test_path", "monkeypatch", "setitem", "os", "environ", "flask_skip_dotenv", "1", "runner", "invoke", "flaskgroup", "assert", "foo", "not", "in", "os", "environ"], "doc_len": 25}
{"doc_id": "tests/test_cli.py::test_run_cert_path", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_run_cert_path", "text": "文件路径: tests/test_cli.py\ndef test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n", "tokens": ["tests", "test_cli", "py", "def", "test_run_cert_path", "no", "key", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "__file__", "no", "cert", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "key", "__file__", "cert", "specified", "first", "ctx", "run_command", "make_context", "run", "cert", "__file__", "key", "__file__", "assert", "ctx", "params", "cert", "__file__", "__file__", "key", "specified", "first", "ctx", "run_command", "make_context", "run", "key", "__file__", "cert", "__file__", "assert", "ctx", "params", "cert", "__file__", "__file__"], "doc_len": 63}
{"doc_id": "tests/test_cli.py::test_run_cert_adhoc", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_run_cert_adhoc", "text": "文件路径: tests/test_cli.py\ndef test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\n", "tokens": ["tests", "test_cli", "py", "def", "test_run_cert_adhoc", "monkeypatch", "monkeypatch", "setitem", "sys", "modules", "cryptography", "none", "cryptography", "not", "installed", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "adhoc", "cryptography", "installed", "monkeypatch", "setitem", "sys", "modules", "cryptography", "types", "moduletype", "cryptography", "ctx", "run_command", "make_context", "run", "cert", "adhoc", "assert", "ctx", "params", "cert", "adhoc", "no", "key", "with", "adhoc", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "adhoc", "key", "__file__"], "doc_len": 62}
{"doc_id": "tests/test_cli.py::test_run_cert_import", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_run_cert_import", "text": "文件路径: tests/test_cli.py\ndef test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])\n", "tokens": ["tests", "test_cli", "py", "def", "test_run_cert_import", "monkeypatch", "monkeypatch", "setitem", "sys", "modules", "not_here", "none", "importerror", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "not_here", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "flask", "sslcontext", "ssl_context", "ssl", "sslcontext", "ssl", "protocol_tls_server", "monkeypatch", "setitem", "sys", "modules", "ssl_context", "ssl_context", "ctx", "run_command", "make_context", "run", "cert", "ssl_context", "assert", "ctx", "params", "cert", "is", "ssl_context", "no", "key", "with", "sslcontext", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "ssl_context", "key", "__file__"], "doc_len": 73}
{"doc_id": "tests/test_cli.py::test_run_cert_no_ssl", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_run_cert_no_ssl", "text": "文件路径: tests/test_cli.py\ndef test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n", "tokens": ["tests", "test_cli", "py", "def", "test_run_cert_no_ssl", "monkeypatch", "monkeypatch", "setitem", "sys", "modules", "ssl", "none", "with", "pytest", "raises", "click", "badparameter", "run_command", "make_context", "run", "cert", "not_here"], "doc_len": 22}
{"doc_id": "tests/test_cli.py::test_cli_blueprints", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_cli_blueprints", "text": "文件路径: tests/test_cli.py\ndef test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output\n", "tokens": ["tests", "test_cli", "py", "def", "test_cli_blueprints", "app", "test", "blueprint", "commands", "register", "correctly", "to", "the", "application", "custom", "blueprint", "custom", "__name__", "cli_group", "customized", "nested", "blueprint", "nested", "__name__", "merged", "blueprint", "merged", "__name__", "cli_group", "none", "late", "blueprint", "late", "__name__", "custom", "cli", "command", "custom", "def", "custom_command", "click", "echo", "custom_result", "nested", "cli", "command", "nested", "def", "nested_command", "click", "echo", "nested_result", "merged", "cli", "command", "merged", "def", "merged_command", "click", "echo", "merged_result", "late", "cli", "command", "late", "def", "late_command", "click", "echo", "late_result", "app", "register_blueprint", "custom", "app", "register_blueprint", "nested", "app", "register_blueprint", "merged", "app", "register_blueprint", "late", "cli_group", "late_registration", "app_runner", "app", "test_cli_runner", "result", "app_runner", "invoke", "args", "customized", "custom", "assert", "custom_result", "in", "result", "output", "result", "app_runner", "invoke", "args", "nested", "nested", "assert", "nested_result", "in", "result", "output", "result", "app_runner", "invoke", "args", "merged", "assert", "merged_result", "in", "result", "output", "result", "app_runner", "invoke", "args", "late_registration", "late", "assert", "late_result", "in", "result", "output"], "doc_len": 130}
{"doc_id": "tests/test_cli.py::test_cli_empty", "file_path": "tests/test_cli.py", "class_name": null, "func_name": "test_cli_empty", "text": "文件路径: tests/test_cli.py\ndef test_cli_empty(app):\n    \"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"\n    bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"\n", "tokens": ["tests", "test_cli", "py", "def", "test_cli_empty", "app", "if", "a", "blueprint", "s", "cli", "group", "is", "empty", "do", "not", "register", "it", "bp", "blueprint", "blue", "__name__", "cli_group", "blue", "app", "register_blueprint", "bp", "result", "app", "test_cli_runner", "invoke", "args", "blue", "help", "assert", "result", "exit_code", "2", "f", "unexpected", "success", "n", "n", "result", "output"], "doc_len": 45}
{"doc_id": "tests/test_config.py::common_object_test", "file_path": "tests/test_config.py", "class_name": null, "func_name": "common_object_test", "text": "文件路径: tests/test_config.py\ndef common_object_test(app):\n    assert app.secret_key == \"config\"\n    assert app.config[\"TEST_KEY\"] == \"foo\"\n    assert \"TestConfig\" not in app.config\n", "tokens": ["tests", "test_config", "py", "def", "common_object_test", "app", "assert", "app", "secret_key", "config", "assert", "app", "config", "test_key", "foo", "assert", "testconfig", "not", "in", "app", "config"], "doc_len": 21}
{"doc_id": "tests/test_config.py::test_config_from_pyfile", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_pyfile", "text": "文件路径: tests/test_config.py\ndef test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_pyfile", "app", "flask", "flask", "__name__", "app", "config", "from_pyfile", "f", "__file__", "rsplit", "1", "0", "py", "common_object_test", "app"], "doc_len": 20}
{"doc_id": "tests/test_config.py::test_config_from_object", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_object", "text": "文件路径: tests/test_config.py\ndef test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_object", "app", "flask", "flask", "__name__", "app", "config", "from_object", "__name__", "common_object_test", "app"], "doc_len": 15}
{"doc_id": "tests/test_config.py::test_config_from_file", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_file", "text": "文件路径: tests/test_config.py\ndef test_config_from_file():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_file", "app", "flask", "flask", "__name__", "current_dir", "os", "path", "dirname", "os", "path", "abspath", "__file__", "app", "config", "from_file", "os", "path", "join", "current_dir", "static", "config", "json", "json", "load", "common_object_test", "app"], "doc_len": 31}
{"doc_id": "tests/test_config.py::test_from_prefixed_env", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_from_prefixed_env", "text": "文件路径: tests/test_config.py\ndef test_from_prefixed_env(monkeypatch):\n    monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n    monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n    monkeypatch.setenv(\"FLASK_INT\", \"1\")\n    monkeypatch.setenv(\"FLASK_FLOAT\", \"1.2\")\n    monkeypatch.setenv(\"FLASK_LIST\", \"[1, 2]\")\n    monkeypatch.setenv(\"FLASK_DICT\", '{\"k\": \"v\"}')\n    monkeypatch.setenv(\"NOT_FLASK_OTHER\", \"other\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env()\n\n    assert app.config[\"STRING\"] == \"value\"\n    assert app.config[\"BOOL\"] is True\n    assert app.config[\"INT\"] == 1\n    assert app.config[\"FLOAT\"] == 1.2\n    assert app.config[\"LIST\"] == [1, 2]\n    assert app.config[\"DICT\"] == {\"k\": \"v\"}\n    assert \"OTHER\" not in app.config\n", "tokens": ["tests", "test_config", "py", "def", "test_from_prefixed_env", "monkeypatch", "monkeypatch", "setenv", "flask_string", "value", "monkeypatch", "setenv", "flask_bool", "true", "monkeypatch", "setenv", "flask_int", "1", "monkeypatch", "setenv", "flask_float", "1", "2", "monkeypatch", "setenv", "flask_list", "1", "2", "monkeypatch", "setenv", "flask_dict", "k", "v", "monkeypatch", "setenv", "not_flask_other", "other", "app", "flask", "flask", "__name__", "app", "config", "from_prefixed_env", "assert", "app", "config", "string", "value", "assert", "app", "config", "bool", "is", "true", "assert", "app", "config", "int", "1", "assert", "app", "config", "float", "1", "2", "assert", "app", "config", "list", "1", "2", "assert", "app", "config", "dict", "k", "v", "assert", "other", "not", "in", "app", "config"], "doc_len": 84}
{"doc_id": "tests/test_config.py::test_from_prefixed_env_custom_prefix", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_from_prefixed_env_custom_prefix", "text": "文件路径: tests/test_config.py\ndef test_from_prefixed_env_custom_prefix(monkeypatch):\n    monkeypatch.setenv(\"FLASK_A\", \"a\")\n    monkeypatch.setenv(\"NOT_FLASK_A\", \"b\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env(\"NOT_FLASK\")\n\n    assert app.config[\"A\"] == \"b\"\n", "tokens": ["tests", "test_config", "py", "def", "test_from_prefixed_env_custom_prefix", "monkeypatch", "monkeypatch", "setenv", "flask_a", "a", "monkeypatch", "setenv", "not_flask_a", "b", "app", "flask", "flask", "__name__", "app", "config", "from_prefixed_env", "not_flask", "assert", "app", "config", "a", "b"], "doc_len": 27}
{"doc_id": "tests/test_config.py::test_from_prefixed_env_nested", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_from_prefixed_env_nested", "text": "文件路径: tests/test_config.py\ndef test_from_prefixed_env_nested(monkeypatch):\n    monkeypatch.setenv(\"FLASK_EXIST__ok\", \"other\")\n    monkeypatch.setenv(\"FLASK_EXIST__inner__ik\", \"2\")\n    monkeypatch.setenv(\"FLASK_EXIST__new__more\", '{\"k\": false}')\n    monkeypatch.setenv(\"FLASK_NEW__K\", \"v\")\n\n    app = flask.Flask(__name__)\n    app.config[\"EXIST\"] = {\"ok\": \"value\", \"flag\": True, \"inner\": {\"ik\": 1}}\n    app.config.from_prefixed_env()\n\n    if os.name != \"nt\":\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 2},\n            \"new\": {\"more\": {\"k\": False}},\n        }\n    else:\n        # Windows env var keys are always uppercase.\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"value\",\n            \"OK\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 1},\n            \"INNER\": {\"IK\": 2},\n            \"NEW\": {\"MORE\": {\"k\": False}},\n        }\n\n    assert app.config[\"NEW\"] == {\"K\": \"v\"}\n", "tokens": ["tests", "test_config", "py", "def", "test_from_prefixed_env_nested", "monkeypatch", "monkeypatch", "setenv", "flask_exist__ok", "other", "monkeypatch", "setenv", "flask_exist__inner__ik", "2", "monkeypatch", "setenv", "flask_exist__new__more", "k", "false", "monkeypatch", "setenv", "flask_new__k", "v", "app", "flask", "flask", "__name__", "app", "config", "exist", "ok", "value", "flag", "true", "inner", "ik", "1", "app", "config", "from_prefixed_env", "if", "os", "name", "nt", "assert", "app", "config", "exist", "ok", "other", "flag", "true", "inner", "ik", "2", "new", "more", "k", "false", "else", "windows", "env", "var", "keys", "are", "always", "uppercase", "assert", "app", "config", "exist", "ok", "value", "ok", "other", "flag", "true", "inner", "ik", "1", "inner", "ik", "2", "new", "more", "k", "false", "assert", "app", "config", "new", "k", "v"], "doc_len": 93}
{"doc_id": "tests/test_config.py::test_config_from_mapping", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_mapping", "text": "文件路径: tests/test_config.py\ndef test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_mapping", "app", "flask", "flask", "__name__", "app", "config", "from_mapping", "secret_key", "config", "test_key", "foo", "common_object_test", "app", "app", "flask", "flask", "__name__", "app", "config", "from_mapping", "secret_key", "config", "test_key", "foo", "common_object_test", "app", "app", "flask", "flask", "__name__", "app", "config", "from_mapping", "secret_key", "config", "test_key", "foo", "common_object_test", "app", "app", "flask", "flask", "__name__", "app", "config", "from_mapping", "secret_key", "config", "test_key", "foo", "skip_key", "skip", "common_object_test", "app", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "typeerror", "app", "config", "from_mapping"], "doc_len": 70}
{"doc_id": "tests/test_config.py::test_config_from_class", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_class", "text": "文件路径: tests/test_config.py\ndef test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_class", "class", "base", "test_key", "foo", "class", "test", "base", "secret_key", "config", "app", "flask", "flask", "__name__", "app", "config", "from_object", "test", "common_object_test", "app"], "doc_len": 24}
{"doc_id": "tests/test_config.py::test_config_from_envvar", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_envvar", "text": "文件路径: tests/test_config.py\ndef test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_envvar", "monkeypatch", "monkeypatch", "setattr", "os", "environ", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "runtimeerror", "as", "e", "app", "config", "from_envvar", "foo_settings", "assert", "foo_settings", "is", "not", "set", "in", "str", "e", "value", "assert", "not", "app", "config", "from_envvar", "foo_settings", "silent", "true", "monkeypatch", "setattr", "os", "environ", "foo_settings", "f", "__file__", "rsplit", "1", "0", "py", "assert", "app", "config", "from_envvar", "foo_settings", "common_object_test", "app"], "doc_len": 59}
{"doc_id": "tests/test_config.py::test_config_from_envvar_missing", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_from_envvar_missing", "text": "文件路径: tests/test_config.py\ndef test_config_from_envvar_missing(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_from_envvar_missing", "monkeypatch", "monkeypatch", "setattr", "os", "environ", "foo_settings", "missing", "cfg", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "ioerror", "as", "e", "app", "config", "from_envvar", "foo_settings", "msg", "str", "e", "value", "assert", "msg", "startswith", "errno", "2", "unable", "to", "load", "configuration", "file", "no", "such", "file", "or", "directory", "assert", "msg", "endswith", "missing", "cfg", "assert", "not", "app", "config", "from_envvar", "foo_settings", "silent", "true"], "doc_len": 59}
{"doc_id": "tests/test_config.py::test_config_missing", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_missing", "text": "文件路径: tests/test_config.py\ndef test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_missing", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "ioerror", "as", "e", "app", "config", "from_pyfile", "missing", "cfg", "msg", "str", "e", "value", "assert", "msg", "startswith", "errno", "2", "unable", "to", "load", "configuration", "file", "no", "such", "file", "or", "directory", "assert", "msg", "endswith", "missing", "cfg", "assert", "not", "app", "config", "from_pyfile", "missing", "cfg", "silent", "true"], "doc_len": 53}
{"doc_id": "tests/test_config.py::test_config_missing_file", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_config_missing_file", "text": "文件路径: tests/test_config.py\ndef test_config_missing_file():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)\n", "tokens": ["tests", "test_config", "py", "def", "test_config_missing_file", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "ioerror", "as", "e", "app", "config", "from_file", "missing", "json", "load", "json", "load", "msg", "str", "e", "value", "assert", "msg", "startswith", "errno", "2", "unable", "to", "load", "configuration", "file", "no", "such", "file", "or", "directory", "assert", "msg", "endswith", "missing", "json", "assert", "not", "app", "config", "from_file", "missing", "json", "load", "json", "load", "silent", "true"], "doc_len": 59}
{"doc_id": "tests/test_config.py::test_custom_config_class", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_custom_config_class", "text": "文件路径: tests/test_config.py\ndef test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)\n", "tokens": ["tests", "test_config", "py", "def", "test_custom_config_class", "class", "config", "flask", "config", "pass", "class", "flask", "flask", "flask", "config_class", "config", "app", "flask", "__name__", "assert", "isinstance", "app", "config", "config", "app", "config", "from_object", "__name__", "common_object_test", "app"], "doc_len": 30}
{"doc_id": "tests/test_config.py::test_session_lifetime", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_session_lifetime", "text": "文件路径: tests/test_config.py\ndef test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config[\"PERMANENT_SESSION_LIFETIME\"] = 42\n    assert app.permanent_session_lifetime.seconds == 42\n", "tokens": ["tests", "test_config", "py", "def", "test_session_lifetime", "app", "flask", "flask", "__name__", "app", "config", "permanent_session_lifetime", "42", "assert", "app", "permanent_session_lifetime", "seconds", "42"], "doc_len": 18}
{"doc_id": "tests/test_config.py::test_get_namespace", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_get_namespace", "text": "文件路径: tests/test_config.py\ndef test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]\n", "tokens": ["tests", "test_config", "py", "def", "test_get_namespace", "app", "flask", "flask", "__name__", "app", "config", "foo_option_1", "foo", "option", "1", "app", "config", "foo_option_2", "foo", "option", "2", "app", "config", "bar_stuff_1", "bar", "stuff", "1", "app", "config", "bar_stuff_2", "bar", "stuff", "2", "foo_options", "app", "config", "get_namespace", "foo_", "assert", "2", "len", "foo_options", "assert", "foo", "option", "1", "foo_options", "option_1", "assert", "foo", "option", "2", "foo_options", "option_2", "bar_options", "app", "config", "get_namespace", "bar_", "lowercase", "false", "assert", "2", "len", "bar_options", "assert", "bar", "stuff", "1", "bar_options", "stuff_1", "assert", "bar", "stuff", "2", "bar_options", "stuff_2", "foo_options", "app", "config", "get_namespace", "foo_", "trim_namespace", "false", "assert", "2", "len", "foo_options", "assert", "foo", "option", "1", "foo_options", "foo_option_1", "assert", "foo", "option", "2", "foo_options", "foo_option_2", "bar_options", "app", "config", "get_namespace", "bar_", "lowercase", "false", "trim_namespace", "false", "assert", "2", "len", "bar_options", "assert", "bar", "stuff", "1", "bar_options", "bar_stuff_1", "assert", "bar", "stuff", "2", "bar_options", "bar_stuff_2"], "doc_len": 125}
{"doc_id": "tests/test_config.py::test_from_pyfile_weird_encoding", "file_path": "tests/test_config.py", "class_name": null, "func_name": "test_from_pyfile_weird_encoding", "text": "文件路径: tests/test_config.py\ndef test_from_pyfile_weird_encoding(tmpdir, encoding):\n    f = tmpdir.join(\"my_config.py\")\n    f.write_binary(\n        textwrap.dedent(\n            f\"\"\"\n            # -*- coding: {encoding} -*-\n            TEST_VALUE = \"föö\"\n            \"\"\"\n        ).encode(encoding)\n    )\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(str(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"föö\"\n", "tokens": ["tests", "test_config", "py", "def", "test_from_pyfile_weird_encoding", "tmpdir", "encoding", "f", "tmpdir", "join", "my_config", "py", "f", "write_binary", "textwrap", "dedent", "f", "coding", "encoding", "test_value", "f", "encode", "encoding", "app", "flask", "flask", "__name__", "app", "config", "from_pyfile", "str", "f", "value", "app", "config", "test_value", "assert", "value", "f"], "doc_len": 39}
{"doc_id": "tests/test_converters.py::test_custom_converters", "file_path": "tests/test_converters.py", "class_name": null, "func_name": "test_custom_converters", "text": "文件路径: tests/test_converters.py\ndef test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"\n", "tokens": ["tests", "test_converters", "py", "def", "test_custom_converters", "app", "client", "class", "listconverter", "baseconverter", "def", "to_python", "self", "value", "return", "value", "split", "def", "to_url", "self", "value", "base_to_url", "super", "to_url", "return", "join", "base_to_url", "x", "for", "x", "in", "value", "app", "url_map", "converters", "list", "listconverter", "app", "route", "list", "args", "def", "index", "args", "return", "join", "args", "assert", "client", "get", "1", "2", "3", "data", "b", "1", "2", "3", "with", "app", "test_request_context", "assert", "url_for", "index", "args", "4", "5", "6", "4", "5", "6"], "doc_len": 71}
{"doc_id": "tests/test_converters.py::test_context_available", "file_path": "tests/test_converters.py", "class_name": null, "func_name": "test_context_available", "text": "文件路径: tests/test_converters.py\ndef test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"\n", "tokens": ["tests", "test_converters", "py", "def", "test_context_available", "app", "client", "class", "contextconverter", "baseconverter", "def", "to_python", "self", "value", "assert", "request", "is", "not", "none", "assert", "session", "is", "not", "none", "return", "value", "app", "url_map", "converters", "ctx", "contextconverter", "app", "get", "ctx", "name", "def", "index", "name", "return", "name", "assert", "client", "get", "admin", "data", "b", "admin"], "doc_len": 47}
{"doc_id": "tests/test_helpers.py::FakePath.__init__", "file_path": "tests/test_helpers.py", "class_name": "FakePath", "func_name": "__init__", "text": "文件路径: tests/test_helpers.py, 类名: FakePath\n    def __init__(self, path):\n        self.path = path\n", "tokens": ["tests", "test_helpers", "py", "fakepath", "def", "__init__", "self", "path", "self", "path", "path"], "doc_len": 11}
{"doc_id": "tests/test_helpers.py::FakePath.__fspath__", "file_path": "tests/test_helpers.py", "class_name": "FakePath", "func_name": "__fspath__", "text": "文件路径: tests/test_helpers.py, 类名: FakePath\n    def __fspath__(self):\n        return self.path\n", "tokens": ["tests", "test_helpers", "py", "fakepath", "def", "__fspath__", "self", "return", "self", "path"], "doc_len": 10}
{"doc_id": "tests/test_helpers.py::PyBytesIO.__init__", "file_path": "tests/test_helpers.py", "class_name": "PyBytesIO", "func_name": "__init__", "text": "文件路径: tests/test_helpers.py, 类名: PyBytesIO\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n", "tokens": ["tests", "test_helpers", "py", "pybytesio", "def", "__init__", "self", "args", "kwargs", "self", "_io", "io", "bytesio", "args", "kwargs"], "doc_len": 15}
{"doc_id": "tests/test_helpers.py::PyBytesIO.__getattr__", "file_path": "tests/test_helpers.py", "class_name": "PyBytesIO", "func_name": "__getattr__", "text": "文件路径: tests/test_helpers.py, 类名: PyBytesIO\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n", "tokens": ["tests", "test_helpers", "py", "pybytesio", "def", "__getattr__", "self", "name", "return", "getattr", "self", "_io", "name"], "doc_len": 13}
{"doc_id": "tests/test_helpers.py::TestSendfile.test_send_file", "file_path": "tests/test_helpers.py", "class_name": "TestSendfile", "func_name": "test_send_file", "text": "文件路径: tests/test_helpers.py, 类名: TestSendfile\n    def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()\n", "tokens": ["tests", "test_helpers", "py", "testsendfile", "def", "test_send_file", "self", "app", "req_ctx", "rv", "flask", "send_file", "static", "index", "html", "assert", "rv", "direct_passthrough", "assert", "rv", "mimetype", "text", "html", "with", "app", "open_resource", "static", "index", "html", "as", "f", "rv", "direct_passthrough", "false", "assert", "rv", "data", "f", "read", "rv", "close"], "doc_len": 41}
{"doc_id": "tests/test_helpers.py::TestSendfile.test_static_file", "file_path": "tests/test_helpers.py", "class_name": "TestSendfile", "func_name": "test_static_file", "text": "文件路径: tests/test_helpers.py, 类名: TestSendfile\n    def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n", "tokens": ["tests", "test_helpers", "py", "testsendfile", "def", "test_static_file", "self", "app", "req_ctx", "default", "max_age", "is", "none", "test", "with", "static", "file", "handler", "rv", "app", "send_static_file", "index", "html", "assert", "rv", "cache_control", "max_age", "is", "none", "rv", "close", "test", "with", "direct", "use", "of", "send_file", "rv", "flask", "send_file", "static", "index", "html", "assert", "rv", "cache_control", "max_age", "is", "none", "rv", "close", "app", "config", "send_file_max_age_default", "3600", "test", "with", "static", "file", "handler", "rv", "app", "send_static_file", "index", "html", "assert", "rv", "cache_control", "max_age", "3600", "rv", "close", "test", "with", "direct", "use", "of", "send_file", "rv", "flask", "send_file", "static", "index", "html", "assert", "rv", "cache_control", "max_age", "3600", "rv", "close", "test", "with", "pathlib", "path", "rv", "app", "send_static_file", "fakepath", "index", "html", "assert", "rv", "cache_control", "max_age", "3600", "rv", "close", "class", "staticfileapp", "flask", "flask", "def", "get_send_file_max_age", "self", "filename", "return", "10", "app", "staticfileapp", "__name__", "with", "app", "test_request_context", "test", "with", "static", "file", "handler", "rv", "app", "send_static_file", "index", "html", "assert", "rv", "cache_control", "max_age", "10", "rv", "close", "test", "with", "direct", "use", "of", "send_file", "rv", "flask", "send_file", "static", "index", "html", "assert", "rv", "cache_control", "max_age", "10", "rv", "close"], "doc_len": 160}
{"doc_id": "tests/test_helpers.py::TestSendfile.test_send_from_directory", "file_path": "tests/test_helpers.py", "class_name": "TestSendfile", "func_name": "test_send_from_directory", "text": "文件路径: tests/test_helpers.py, 类名: TestSendfile\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n", "tokens": ["tests", "test_helpers", "py", "testsendfile", "def", "test_send_from_directory", "self", "app", "req_ctx", "app", "root_path", "os", "path", "join", "os", "path", "dirname", "__file__", "test_apps", "subdomaintestmodule", "rv", "flask", "send_from_directory", "static", "hello", "txt", "rv", "direct_passthrough", "false", "assert", "rv", "data", "strip", "b", "hello", "subdomain", "rv", "close"], "doc_len": 38}
{"doc_id": "tests/test_helpers.py::TestUrlFor.test_url_for_with_anchor", "file_path": "tests/test_helpers.py", "class_name": "TestUrlFor", "func_name": "test_url_for_with_anchor", "text": "文件路径: tests/test_helpers.py, 类名: TestUrlFor\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"\n", "tokens": ["tests", "test_helpers", "py", "testurlfor", "def", "test_url_for_with_anchor", "self", "app", "req_ctx", "app", "route", "def", "index", "return", "42", "assert", "flask", "url_for", "index", "_anchor", "x", "y", "x", "20y"], "doc_len": 24}
{"doc_id": "tests/test_helpers.py::TestUrlFor.test_url_for_with_scheme", "file_path": "tests/test_helpers.py", "class_name": "TestUrlFor", "func_name": "test_url_for_with_scheme", "text": "文件路径: tests/test_helpers.py, 类名: TestUrlFor\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n", "tokens": ["tests", "test_helpers", "py", "testurlfor", "def", "test_url_for_with_scheme", "self", "app", "req_ctx", "app", "route", "def", "index", "return", "42", "assert", "flask", "url_for", "index", "_external", "true", "_scheme", "https", "https", "localhost"], "doc_len": 25}
{"doc_id": "tests/test_helpers.py::TestUrlFor.test_url_for_with_scheme_not_external", "file_path": "tests/test_helpers.py", "class_name": "TestUrlFor", "func_name": "test_url_for_with_scheme_not_external", "text": "文件路径: tests/test_helpers.py, 类名: TestUrlFor\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)\n", "tokens": ["tests", "test_helpers", "py", "testurlfor", "def", "test_url_for_with_scheme_not_external", "self", "app", "req_ctx", "app", "add_url_rule", "endpoint", "index", "implicit", "external", "with", "scheme", "url", "flask", "url_for", "index", "_scheme", "https", "assert", "url", "https", "localhost", "error", "when", "external", "false", "with", "scheme", "with", "pytest", "raises", "valueerror", "flask", "url_for", "index", "_scheme", "https", "_external", "false"], "doc_len": 44}
{"doc_id": "tests/test_helpers.py::TestUrlFor.test_url_for_with_alternating_schemes", "file_path": "tests/test_helpers.py", "class_name": "TestUrlFor", "func_name": "test_url_for_with_alternating_schemes", "text": "文件路径: tests/test_helpers.py, 类名: TestUrlFor\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n", "tokens": ["tests", "test_helpers", "py", "testurlfor", "def", "test_url_for_with_alternating_schemes", "self", "app", "req_ctx", "app", "route", "def", "index", "return", "42", "assert", "flask", "url_for", "index", "_external", "true", "http", "localhost", "assert", "flask", "url_for", "index", "_external", "true", "_scheme", "https", "https", "localhost", "assert", "flask", "url_for", "index", "_external", "true", "http", "localhost"], "doc_len": 41}
{"doc_id": "tests/test_helpers.py::TestUrlFor.test_url_with_method", "file_path": "tests/test_helpers.py", "class_name": "TestUrlFor", "func_name": "test_url_with_method", "text": "文件路径: tests/test_helpers.py, 类名: TestUrlFor\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"\n", "tokens": ["tests", "test_helpers", "py", "testurlfor", "def", "test_url_with_method", "self", "app", "req_ctx", "from", "flask", "views", "import", "methodview", "class", "myview", "methodview", "def", "get", "self", "id", "none", "if", "id", "is", "none", "return", "list", "return", "f", "get", "id", "d", "def", "post", "self", "return", "create", "myview", "myview", "as_view", "myview", "app", "add_url_rule", "myview", "methods", "get", "view_func", "myview", "app", "add_url_rule", "myview", "int", "id", "methods", "get", "view_func", "myview", "app", "add_url_rule", "myview", "create", "methods", "post", "view_func", "myview", "assert", "flask", "url_for", "myview", "_method", "get", "myview", "assert", "flask", "url_for", "myview", "id", "42", "_method", "get", "myview", "42", "assert", "flask", "url_for", "myview", "_method", "post", "myview", "create"], "doc_len": 91}
{"doc_id": "tests/test_helpers.py::test_redirect_no_app", "file_path": "tests/test_helpers.py", "class_name": null, "func_name": "test_redirect_no_app", "text": "文件路径: tests/test_helpers.py\ndef test_redirect_no_app():\n    response = flask.redirect(\"https://localhost\", 307)\n    assert response.location == \"https://localhost\"\n    assert response.status_code == 307\n", "tokens": ["tests", "test_helpers", "py", "def", "test_redirect_no_app", "response", "flask", "redirect", "https", "localhost", "307", "assert", "response", "location", "https", "localhost", "assert", "response", "status_code", "307"], "doc_len": 20}
{"doc_id": "tests/test_helpers.py::test_redirect_with_app", "file_path": "tests/test_helpers.py", "class_name": null, "func_name": "test_redirect_with_app", "text": "文件路径: tests/test_helpers.py\ndef test_redirect_with_app(app):\n    def redirect(location, code=302):\n        raise ValueError\n\n    app.redirect = redirect\n\n    with app.app_context(), pytest.raises(ValueError):\n        flask.redirect(\"other\")\n", "tokens": ["tests", "test_helpers", "py", "def", "test_redirect_with_app", "app", "def", "redirect", "location", "code", "302", "raise", "valueerror", "app", "redirect", "redirect", "with", "app", "app_context", "pytest", "raises", "valueerror", "flask", "redirect", "other"], "doc_len": 25}
{"doc_id": "tests/test_helpers.py::test_abort_no_app", "file_path": "tests/test_helpers.py", "class_name": null, "func_name": "test_abort_no_app", "text": "文件路径: tests/test_helpers.py\ndef test_abort_no_app():\n    with pytest.raises(werkzeug.exceptions.Unauthorized):\n        flask.abort(401)\n\n    with pytest.raises(LookupError):\n        flask.abort(900)\n", "tokens": ["tests", "test_helpers", "py", "def", "test_abort_no_app", "with", "pytest", "raises", "werkzeug", "exceptions", "unauthorized", "flask", "abort", "401", "with", "pytest", "raises", "lookuperror", "flask", "abort", "900"], "doc_len": 21}
{"doc_id": "tests/test_helpers.py::test_app_aborter_class", "file_path": "tests/test_helpers.py", "class_name": null, "func_name": "test_app_aborter_class", "text": "文件路径: tests/test_helpers.py\ndef test_app_aborter_class():\n    class MyAborter(werkzeug.exceptions.Aborter):\n        pass\n\n    class MyFlask(flask.Flask):\n        aborter_class = MyAborter\n\n    app = MyFlask(__name__)\n    assert isinstance(app.aborter, MyAborter)\n", "tokens": ["tests", "test_helpers", "py", "def", "test_app_aborter_class", "class", "myaborter", "werkzeug", "exceptions", "aborter", "pass", "class", "myflask", "flask", "flask", "aborter_class", "myaborter", "app", "myflask", "__name__", "assert", "isinstance", "app", "aborter", "myaborter"], "doc_len": 25}
{"doc_id": "tests/test_helpers.py::test_abort_with_app", "file_path": "tests/test_helpers.py", "class_name": null, "func_name": "test_abort_with_app", "text": "文件路径: tests/test_helpers.py\ndef test_abort_with_app(app):\n    class My900Error(werkzeug.exceptions.HTTPException):\n        code = 900\n\n    app.aborter.mapping[900] = My900Error\n\n    with app.app_context(), pytest.raises(My900Error):\n        flask.abort(900)\n", "tokens": ["tests", "test_helpers", "py", "def", "test_abort_with_app", "app", "class", "my900error", "werkzeug", "exceptions", "httpexception", "code", "900", "app", "aborter", "mapping", "900", "my900error", "with", "app", "app_context", "pytest", "raises", "my900error", "flask", "abort", "900"], "doc_len": 27}
{"doc_id": "tests/test_helpers.py::TestNoImports.test_name_with_import_error", "file_path": "tests/test_helpers.py", "class_name": "TestNoImports", "func_name": "test_name_with_import_error", "text": "文件路径: tests/test_helpers.py, 类名: TestNoImports\n    def test_name_with_import_error(self, modules_tmpdir):\n        modules_tmpdir.join(\"importerror.py\").write(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n", "tokens": ["tests", "test_helpers", "py", "testnoimports", "def", "test_name_with_import_error", "self", "modules_tmpdir", "modules_tmpdir", "join", "importerror", "py", "write", "raise", "notimplementederror", "try", "flask", "flask", "importerror", "except", "notimplementederror", "assertionerror", "flask", "import_name", "is", "importing", "import_name"], "doc_len": 27}
{"doc_id": "tests/test_helpers.py::TestStreaming.test_streaming_with_context", "file_path": "tests/test_helpers.py", "class_name": "TestStreaming", "func_name": "test_streaming_with_context", "text": "文件路径: tests/test_helpers.py, 类名: TestStreaming\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n", "tokens": ["tests", "test_helpers", "py", "teststreaming", "def", "test_streaming_with_context", "self", "app", "client", "app", "route", "def", "index", "def", "generate", "yield", "hello", "yield", "flask", "request", "args", "name", "yield", "return", "flask", "response", "flask", "stream_with_context", "generate", "rv", "client", "get", "name", "world", "assert", "rv", "data", "b", "hello", "world"], "doc_len": 40}
{"doc_id": "tests/test_helpers.py::TestStreaming.test_streaming_with_context_as_decorator", "file_path": "tests/test_helpers.py", "class_name": "TestStreaming", "func_name": "test_streaming_with_context_as_decorator", "text": "文件路径: tests/test_helpers.py, 类名: TestStreaming\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n", "tokens": ["tests", "test_helpers", "py", "teststreaming", "def", "test_streaming_with_context_as_decorator", "self", "app", "client", "app", "route", "def", "index", "flask", "stream_with_context", "def", "generate", "hello", "yield", "hello", "yield", "flask", "request", "args", "name", "yield", "return", "flask", "response", "generate", "hello", "rv", "client", "get", "name", "world", "assert", "rv", "data", "b", "hello", "world"], "doc_len": 42}
{"doc_id": "tests/test_helpers.py::TestStreaming.test_streaming_with_context_and_custom_close", "file_path": "tests/test_helpers.py", "class_name": "TestStreaming", "func_name": "test_streaming_with_context_and_custom_close", "text": "文件路径: tests/test_helpers.py, 类名: TestStreaming\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n", "tokens": ["tests", "test_helpers", "py", "teststreaming", "def", "test_streaming_with_context_and_custom_close", "self", "app", "client", "called", "class", "wrapper", "def", "__init__", "self", "gen", "self", "_gen", "gen", "def", "__iter__", "self", "return", "self", "def", "close", "self", "called", "append", "42", "def", "__next__", "self", "return", "next", "self", "_gen", "next", "__next__", "app", "route", "def", "index", "def", "generate", "yield", "hello", "yield", "flask", "request", "args", "name", "yield", "return", "flask", "response", "flask", "stream_with_context", "wrapper", "generate", "rv", "client", "get", "name", "world", "assert", "rv", "data", "b", "hello", "world", "assert", "called", "42"], "doc_len": 74}
{"doc_id": "tests/test_helpers.py::TestStreaming.test_stream_keeps_session", "file_path": "tests/test_helpers.py", "class_name": "TestStreaming", "func_name": "test_stream_keeps_session", "text": "文件路径: tests/test_helpers.py, 类名: TestStreaming\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"\n", "tokens": ["tests", "test_helpers", "py", "teststreaming", "def", "test_stream_keeps_session", "self", "app", "client", "app", "route", "def", "index", "flask", "session", "test", "flask", "flask", "stream_with_context", "def", "gen", "yield", "flask", "session", "test", "return", "flask", "response", "gen", "rv", "client", "get", "assert", "rv", "data", "b", "flask"], "doc_len": 37}
{"doc_id": "tests/test_helpers.py::TestHelpers.test_get_debug_flag", "file_path": "tests/test_helpers.py", "class_name": "TestHelpers", "func_name": "test_get_debug_flag", "text": "文件路径: tests/test_helpers.py, 类名: TestHelpers\n    def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect\n", "tokens": ["tests", "test_helpers", "py", "testhelpers", "def", "test_get_debug_flag", "self", "monkeypatch", "debug", "expect", "monkeypatch", "setenv", "flask_debug", "debug", "assert", "get_debug_flag", "expect"], "doc_len": 17}
{"doc_id": "tests/test_helpers.py::TestHelpers.test_make_response", "file_path": "tests/test_helpers.py", "class_name": "TestHelpers", "func_name": "test_make_response", "text": "文件路径: tests/test_helpers.py, 类名: TestHelpers\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"\n", "tokens": ["tests", "test_helpers", "py", "testhelpers", "def", "test_make_response", "self", "app", "flask", "flask", "__name__", "with", "app", "test_request_context", "rv", "flask", "helpers", "make_response", "assert", "rv", "status_code", "200", "assert", "rv", "mimetype", "text", "html", "rv", "flask", "helpers", "make_response", "hello", "assert", "rv", "status_code", "200", "assert", "rv", "data", "b", "hello", "assert", "rv", "mimetype", "text", "html"], "doc_len": 46}
{"doc_id": "tests/test_helpers.py::TestHelpers.test_open_resource", "file_path": "tests/test_helpers.py", "class_name": "TestHelpers", "func_name": "test_open_resource", "text": "文件路径: tests/test_helpers.py, 类名: TestHelpers\n    def test_open_resource(self, mode):\n        app = flask.Flask(__name__)\n\n        with app.open_resource(\"static/index.html\", mode) as f:\n            assert \"<h1>Hello World!</h1>\" in str(f.read())\n", "tokens": ["tests", "test_helpers", "py", "testhelpers", "def", "test_open_resource", "self", "mode", "app", "flask", "flask", "__name__", "with", "app", "open_resource", "static", "index", "html", "mode", "as", "f", "assert", "h1", "hello", "world", "h1", "in", "str", "f", "read"], "doc_len": 30}
{"doc_id": "tests/test_helpers.py::TestHelpers.test_open_resource_exceptions", "file_path": "tests/test_helpers.py", "class_name": "TestHelpers", "func_name": "test_open_resource_exceptions", "text": "文件路径: tests/test_helpers.py, 类名: TestHelpers\n    def test_open_resource_exceptions(self, mode):\n        app = flask.Flask(__name__)\n\n        with pytest.raises(ValueError):\n            app.open_resource(\"static/index.html\", mode)\n", "tokens": ["tests", "test_helpers", "py", "testhelpers", "def", "test_open_resource_exceptions", "self", "mode", "app", "flask", "flask", "__name__", "with", "pytest", "raises", "valueerror", "app", "open_resource", "static", "index", "html", "mode"], "doc_len": 22}
{"doc_id": "tests/test_instance_config.py::test_explicit_instance_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_explicit_instance_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_explicit_instance_paths(modules_tmpdir):\n    with pytest.raises(ValueError) as excinfo:\n        flask.Flask(__name__, instance_path=\"instance\")\n    assert \"must be absolute\" in str(excinfo.value)\n\n    app = flask.Flask(__name__, instance_path=str(modules_tmpdir))\n    assert app.instance_path == str(modules_tmpdir)\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_explicit_instance_paths", "modules_tmpdir", "with", "pytest", "raises", "valueerror", "as", "excinfo", "flask", "flask", "__name__", "instance_path", "instance", "assert", "must", "be", "absolute", "in", "str", "excinfo", "value", "app", "flask", "flask", "__name__", "instance_path", "str", "modules_tmpdir", "assert", "app", "instance_path", "str", "modules_tmpdir"], "doc_len": 37}
{"doc_id": "tests/test_instance_config.py::test_uninstalled_module_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_uninstalled_module_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_uninstalled_module_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.join(\"config_module_app.py\").write(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == str(modules_tmpdir.join(\"instance\"))\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_uninstalled_module_paths", "modules_tmpdir", "purge_module", "app", "modules_tmpdir", "join", "config_module_app", "py", "write", "import", "os", "n", "import", "flask", "n", "here", "os", "path", "abspath", "os", "path", "dirname", "__file__", "n", "app", "flask", "flask", "__name__", "n", "purge_module", "config_module_app", "from", "config_module_app", "import", "app", "assert", "app", "instance_path", "str", "modules_tmpdir", "join", "instance"], "doc_len": 46}
{"doc_id": "tests/test_instance_config.py::test_uninstalled_package_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_uninstalled_package_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_uninstalled_package_paths(modules_tmpdir, purge_module):\n    app = modules_tmpdir.mkdir(\"config_package_app\")\n    init = app.join(\"__init__.py\")\n    init.write(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == str(modules_tmpdir.join(\"instance\"))\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_uninstalled_package_paths", "modules_tmpdir", "purge_module", "app", "modules_tmpdir", "mkdir", "config_package_app", "init", "app", "join", "__init__", "py", "init", "write", "import", "os", "n", "import", "flask", "n", "here", "os", "path", "abspath", "os", "path", "dirname", "__file__", "n", "app", "flask", "flask", "__name__", "n", "purge_module", "config_package_app", "from", "config_package_app", "import", "app", "assert", "app", "instance_path", "str", "modules_tmpdir", "join", "instance"], "doc_len": 51}
{"doc_id": "tests/test_instance_config.py::test_uninstalled_namespace_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_uninstalled_namespace_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_uninstalled_namespace_paths(tmpdir, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmpdir.join(f\"project-{package}\")\n        monkeypatch.syspath_prepend(str(project))\n        project.join(\"namespace\").join(package).join(\"__init__.py\").write(\n            \"import flask\\napp = flask.Flask(__name__)\\n\", ensure=True\n        )\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == str(project2.join(\"instance\"))\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_uninstalled_namespace_paths", "tmpdir", "monkeypatch", "purge_module", "def", "create_namespace", "package", "project", "tmpdir", "join", "f", "project", "package", "monkeypatch", "syspath_prepend", "str", "project", "project", "join", "namespace", "join", "package", "join", "__init__", "py", "write", "import", "flask", "napp", "flask", "flask", "__name__", "n", "ensure", "true", "return", "project", "_", "create_namespace", "package1", "project2", "create_namespace", "package2", "purge_module", "namespace", "package2", "purge_module", "namespace", "from", "namespace", "package2", "import", "app", "assert", "app", "instance_path", "str", "project2", "join", "instance"], "doc_len": 64}
{"doc_id": "tests/test_instance_config.py::test_installed_module_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_installed_module_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_installed_module_paths(\n    modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages, limit_loader\n):\n    site_packages.join(\"site_app.py\").write(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == modules_tmpdir.join(\"var\").join(\"site_app-instance\")\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_installed_module_paths", "modules_tmpdir", "modules_tmpdir_prefix", "purge_module", "site_packages", "limit_loader", "site_packages", "join", "site_app", "py", "write", "import", "flask", "napp", "flask", "flask", "__name__", "n", "purge_module", "site_app", "from", "site_app", "import", "app", "assert", "app", "instance_path", "modules_tmpdir", "join", "var", "join", "site_app", "instance"], "doc_len": 37}
{"doc_id": "tests/test_instance_config.py::test_installed_package_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_installed_package_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_installed_package_paths(\n    limit_loader, modules_tmpdir, modules_tmpdir_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmpdir.mkdir(\"path\")\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path.mkdir(\"installed_package\")\n    init = app.join(\"__init__.py\")\n    init.write(\"import flask\\napp = flask.Flask(__name__)\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == modules_tmpdir.join(\"var\").join(\n        \"installed_package-instance\"\n    )\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_installed_package_paths", "limit_loader", "modules_tmpdir", "modules_tmpdir_prefix", "purge_module", "monkeypatch", "installed_path", "modules_tmpdir", "mkdir", "path", "monkeypatch", "syspath_prepend", "installed_path", "app", "installed_path", "mkdir", "installed_package", "init", "app", "join", "__init__", "py", "init", "write", "import", "flask", "napp", "flask", "flask", "__name__", "purge_module", "installed_package", "from", "installed_package", "import", "app", "assert", "app", "instance_path", "modules_tmpdir", "join", "var", "join", "installed_package", "instance"], "doc_len": 49}
{"doc_id": "tests/test_instance_config.py::test_prefix_package_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_prefix_package_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_prefix_package_paths(\n    limit_loader, modules_tmpdir, modules_tmpdir_prefix, purge_module, site_packages\n):\n    app = site_packages.mkdir(\"site_package\")\n    init = app.join(\"__init__.py\")\n    init.write(\"import flask\\napp = flask.Flask(__name__)\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == modules_tmpdir.join(\"var\").join(\n        \"site_package-instance\"\n    )\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_prefix_package_paths", "limit_loader", "modules_tmpdir", "modules_tmpdir_prefix", "purge_module", "site_packages", "app", "site_packages", "mkdir", "site_package", "init", "app", "join", "__init__", "py", "init", "write", "import", "flask", "napp", "flask", "flask", "__name__", "purge_module", "site_package", "import", "site_package", "assert", "site_package", "app", "instance_path", "modules_tmpdir", "join", "var", "join", "site_package", "instance"], "doc_len": 41}
{"doc_id": "tests/test_instance_config.py::test_egg_installed_paths", "file_path": "tests/test_instance_config.py", "class_name": null, "func_name": "test_egg_installed_paths", "text": "文件路径: tests/test_instance_config.py\ndef test_egg_installed_paths(install_egg, modules_tmpdir, modules_tmpdir_prefix):\n    modules_tmpdir.mkdir(\"site_egg\").join(\"__init__.py\").write(\n        \"import flask\\n\\napp = flask.Flask(__name__)\"\n    )\n    install_egg(\"site_egg\")\n    try:\n        import site_egg\n\n        assert site_egg.app.instance_path == str(\n            modules_tmpdir.join(\"var/\").join(\"site_egg-instance\")\n        )\n    finally:\n        if \"site_egg\" in sys.modules:\n            del sys.modules[\"site_egg\"]\n", "tokens": ["tests", "test_instance_config", "py", "def", "test_egg_installed_paths", "install_egg", "modules_tmpdir", "modules_tmpdir_prefix", "modules_tmpdir", "mkdir", "site_egg", "join", "__init__", "py", "write", "import", "flask", "n", "napp", "flask", "flask", "__name__", "install_egg", "site_egg", "try", "import", "site_egg", "assert", "site_egg", "app", "instance_path", "str", "modules_tmpdir", "join", "var", "join", "site_egg", "instance", "finally", "if", "site_egg", "in", "sys", "modules", "del", "sys", "modules", "site_egg"], "doc_len": 48}
{"doc_id": "tests/test_json.py::test_bad_request_debug_message", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_bad_request_debug_message", "text": "文件路径: tests/test_json.py\ndef test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug\n", "tokens": ["tests", "test_json", "py", "def", "test_bad_request_debug_message", "app", "client", "debug", "app", "config", "debug", "debug", "app", "config", "trap_bad_request_errors", "false", "app", "route", "json", "methods", "post", "def", "post_json", "flask", "request", "get_json", "return", "none", "rv", "client", "post", "json", "data", "none", "content_type", "application", "json", "assert", "rv", "status_code", "400", "contains", "b", "failed", "to", "decode", "json", "object", "in", "rv", "data", "assert", "contains", "debug"], "doc_len": 54}
{"doc_id": "tests/test_json.py::test_json_bad_requests", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_bad_requests", "text": "文件路径: tests/test_json.py\ndef test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400\n", "tokens": ["tests", "test_json", "py", "def", "test_json_bad_requests", "app", "client", "app", "route", "json", "methods", "post", "def", "return_json", "return", "flask", "jsonify", "foo", "str", "flask", "request", "get_json", "rv", "client", "post", "json", "data", "malformed", "content_type", "application", "json", "assert", "rv", "status_code", "400"], "doc_len": 35}
{"doc_id": "tests/test_json.py::test_json_custom_mimetypes", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_custom_mimetypes", "text": "文件路径: tests/test_json.py\ndef test_json_custom_mimetypes(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.request.get_json()\n\n    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n    assert rv.data == b\"foo\"\n", "tokens": ["tests", "test_json", "py", "def", "test_json_custom_mimetypes", "app", "client", "app", "route", "json", "methods", "post", "def", "return_json", "return", "flask", "request", "get_json", "rv", "client", "post", "json", "data", "foo", "content_type", "application", "x", "json", "assert", "rv", "data", "b", "foo"], "doc_len": 33}
{"doc_id": "tests/test_json.py::test_json_as_unicode", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_as_unicode", "text": "文件路径: tests/test_json.py\ndef test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected\n", "tokens": ["tests", "test_json", "py", "def", "test_json_as_unicode", "test_value", "expected", "app", "app_ctx", "app", "json", "ensure_ascii", "test_value", "rv", "app", "json", "dumps", "n", "snowman", "assert", "rv", "expected"], "doc_len": 22}
{"doc_id": "tests/test_json.py::test_json_dump_to_file", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_dump_to_file", "text": "文件路径: tests/test_json.py\ndef test_json_dump_to_file(app, app_ctx):\n    test_data = {\"name\": \"Flask\"}\n    out = io.StringIO()\n\n    flask.json.dump(test_data, out)\n    out.seek(0)\n    rv = flask.json.load(out)\n    assert rv == test_data\n", "tokens": ["tests", "test_json", "py", "def", "test_json_dump_to_file", "app", "app_ctx", "test_data", "name", "flask", "out", "io", "stringio", "flask", "json", "dump", "test_data", "out", "out", "seek", "0", "rv", "flask", "json", "load", "out", "assert", "rv", "test_data"], "doc_len": 29}
{"doc_id": "tests/test_json.py::test_jsonify_basic_types", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_basic_types", "text": "文件路径: tests/test_json.py\ndef test_jsonify_basic_types(test_value, app, client):\n    url = \"/jsonify_basic_types\"\n    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n    rv = client.get(url)\n    assert rv.mimetype == \"application/json\"\n    assert flask.json.loads(rv.data) == test_value\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_basic_types", "test_value", "app", "client", "url", "jsonify_basic_types", "app", "add_url_rule", "url", "url", "lambda", "x", "test_value", "flask", "jsonify", "x", "rv", "client", "get", "url", "assert", "rv", "mimetype", "application", "json", "assert", "flask", "json", "loads", "rv", "data", "test_value"], "doc_len": 36}
{"doc_id": "tests/test_json.py::test_jsonify_dicts", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_dicts", "text": "文件路径: tests/test_json.py\ndef test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_dicts", "app", "client", "d", "a", "0", "b", "23", "c", "3", "14", "d", "t", "e", "hi", "f", "true", "g", "false", "h", "test", "list", "10", "false", "i", "test", "dict", "app", "route", "kw", "def", "return_kwargs", "return", "flask", "jsonify", "d", "app", "route", "dict", "def", "return_dict", "return", "flask", "jsonify", "d", "for", "url", "in", "kw", "dict", "rv", "client", "get", "url", "assert", "rv", "mimetype", "application", "json", "assert", "flask", "json", "loads", "rv", "data", "d"], "doc_len": 70}
{"doc_id": "tests/test_json.py::test_jsonify_arrays", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_arrays", "text": "文件路径: tests/test_json.py\ndef test_jsonify_arrays(app, client):\n    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n    a_list = [\n        0,\n        42,\n        3.14,\n        \"t\",\n        \"hello\",\n        True,\n        False,\n        [\"test list\", 2, False],\n        {\"test\": \"dict\"},\n    ]\n\n    @app.route(\"/args_unpack\")\n    def return_args_unpack():\n        return flask.jsonify(*a_list)\n\n    @app.route(\"/array\")\n    def return_array():\n        return flask.jsonify(a_list)\n\n    for url in \"/args_unpack\", \"/array\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == a_list\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_arrays", "app", "client", "test", "jsonify", "of", "lists", "and", "args", "unpacking", "a_list", "0", "42", "3", "14", "t", "hello", "true", "false", "test", "list", "2", "false", "test", "dict", "app", "route", "args_unpack", "def", "return_args_unpack", "return", "flask", "jsonify", "a_list", "app", "route", "array", "def", "return_array", "return", "flask", "jsonify", "a_list", "for", "url", "in", "args_unpack", "array", "rv", "client", "get", "url", "assert", "rv", "mimetype", "application", "json", "assert", "flask", "json", "loads", "rv", "data", "a_list"], "doc_len": 68}
{"doc_id": "tests/test_json.py::test_jsonify_datetime", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_datetime", "text": "文件路径: tests/test_json.py\ndef test_jsonify_datetime(app, client, value):\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(value=value)\n\n    r = client.get()\n    assert r.json[\"value\"] == http_date(value)\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_datetime", "app", "client", "value", "app", "route", "def", "index", "return", "flask", "jsonify", "value", "value", "r", "client", "get", "assert", "r", "json", "value", "http_date", "value"], "doc_len": 26}
{"doc_id": "tests/test_json.py::FixedOffset.__init__", "file_path": "tests/test_json.py", "class_name": "FixedOffset", "func_name": "__init__", "text": "文件路径: tests/test_json.py, 类名: FixedOffset\n    def __init__(self, hours, name):\n        self.__offset = datetime.timedelta(hours=hours)\n        self.__name = name\n", "tokens": ["tests", "test_json", "py", "fixedoffset", "def", "__init__", "self", "hours", "name", "self", "__offset", "datetime", "timedelta", "hours", "hours", "self", "__name", "name"], "doc_len": 18}
{"doc_id": "tests/test_json.py::FixedOffset.utcoffset", "file_path": "tests/test_json.py", "class_name": "FixedOffset", "func_name": "utcoffset", "text": "文件路径: tests/test_json.py, 类名: FixedOffset\n    def utcoffset(self, dt):\n        return self.__offset\n", "tokens": ["tests", "test_json", "py", "fixedoffset", "def", "utcoffset", "self", "dt", "return", "self", "__offset"], "doc_len": 11}
{"doc_id": "tests/test_json.py::FixedOffset.tzname", "file_path": "tests/test_json.py", "class_name": "FixedOffset", "func_name": "tzname", "text": "文件路径: tests/test_json.py, 类名: FixedOffset\n    def tzname(self, dt):\n        return self.__name\n", "tokens": ["tests", "test_json", "py", "fixedoffset", "def", "tzname", "self", "dt", "return", "self", "__name"], "doc_len": 11}
{"doc_id": "tests/test_json.py::FixedOffset.dst", "file_path": "tests/test_json.py", "class_name": "FixedOffset", "func_name": "dst", "text": "文件路径: tests/test_json.py, 类名: FixedOffset\n    def dst(self, dt):\n        return datetime.timedelta()\n", "tokens": ["tests", "test_json", "py", "fixedoffset", "def", "dst", "self", "dt", "return", "datetime", "timedelta"], "doc_len": 11}
{"doc_id": "tests/test_json.py::test_jsonify_aware_datetimes", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_aware_datetimes", "text": "文件路径: tests/test_json.py\ndef test_jsonify_aware_datetimes(tz):\n    \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n    tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n    gmt = FixedOffset(hours=0, name=\"GMT\")\n    expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n    assert flask.json.dumps(dt) == expected\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_aware_datetimes", "tz", "test", "if", "aware", "datetime", "datetime", "objects", "are", "converted", "into", "gmt", "tzinfo", "fixedoffset", "hours", "tz", "1", "name", "tz", "0", "dt", "datetime", "datetime", "2017", "1", "1", "12", "34", "56", "tzinfo", "tzinfo", "gmt", "fixedoffset", "hours", "0", "name", "gmt", "expected", "dt", "astimezone", "gmt", "strftime", "a", "d", "b", "y", "h", "m", "s", "z", "assert", "flask", "json", "dumps", "dt", "expected"], "doc_len": 60}
{"doc_id": "tests/test_json.py::test_jsonify_uuid_types", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_jsonify_uuid_types", "text": "文件路径: tests/test_json.py\ndef test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xDE\\xAD\\xBE\\xEF\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid\n", "tokens": ["tests", "test_json", "py", "def", "test_jsonify_uuid_types", "app", "client", "test", "jsonify", "with", "uuid", "uuid", "types", "test_uuid", "uuid", "uuid", "bytes", "b", "xde", "xad", "xbe", "xef", "4", "url", "uuid_test", "app", "add_url_rule", "url", "url", "lambda", "flask", "jsonify", "x", "test_uuid", "rv", "client", "get", "url", "rv_x", "flask", "json", "loads", "rv", "data", "x", "assert", "rv_x", "str", "test_uuid", "rv_uuid", "uuid", "uuid", "rv_x", "assert", "rv_uuid", "test_uuid"], "doc_len": 56}
{"doc_id": "tests/test_json.py::test_json_decimal", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_decimal", "text": "文件路径: tests/test_json.py\ndef test_json_decimal():\n    rv = flask.json.dumps(decimal.Decimal(\"0.003\"))\n    assert rv == '\"0.003\"'\n", "tokens": ["tests", "test_json", "py", "def", "test_json_decimal", "rv", "flask", "json", "dumps", "decimal", "decimal", "0", "003", "assert", "rv", "0", "003"], "doc_len": 17}
{"doc_id": "tests/test_json.py::test_json_attr", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_attr", "text": "文件路径: tests/test_json.py\ndef test_json_attr(app, client):\n    @app.route(\"/add\", methods=[\"POST\"])\n    def add():\n        json = flask.request.get_json()\n        return str(json[\"a\"] + json[\"b\"])\n\n    rv = client.post(\n        \"/add\",\n        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b\"3\"\n", "tokens": ["tests", "test_json", "py", "def", "test_json_attr", "app", "client", "app", "route", "add", "methods", "post", "def", "add", "json", "flask", "request", "get_json", "return", "str", "json", "a", "json", "b", "rv", "client", "post", "add", "data", "flask", "json", "dumps", "a", "1", "b", "2", "content_type", "application", "json", "assert", "rv", "data", "b", "3"], "doc_len": 44}
{"doc_id": "tests/test_json.py::test_tojson_filter", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_tojson_filter", "text": "文件路径: tests/test_json.py\ndef test_tojson_filter(app, req_ctx):\n    # The tojson filter is tested in Jinja, this confirms that it's\n    # using Flask's dumps.\n    rv = flask.render_template_string(\n        \"const data = {{ data|tojson }};\",\n        data={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n    )\n    assert rv == (\n        'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n        ' \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'\n    )\n", "tokens": ["tests", "test_json", "py", "def", "test_tojson_filter", "app", "req_ctx", "the", "tojson", "filter", "is", "tested", "in", "jinja", "this", "confirms", "that", "it", "s", "using", "flask", "s", "dumps", "rv", "flask", "render_template_string", "const", "data", "data", "tojson", "data", "name", "script", "time", "datetime", "datetime", "2021", "2", "1", "7", "15", "assert", "rv", "const", "data", "name", "u003c", "script", "u003e", "time", "mon", "01", "feb", "2021", "07", "15", "00", "gmt"], "doc_len": 58}
{"doc_id": "tests/test_json.py::test_json_customization", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_customization", "text": "文件路径: tests/test_json.py\ndef test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'\n", "tokens": ["tests", "test_json", "py", "def", "test_json_customization", "app", "client", "class", "x", "noqa", "b903", "for", "python2", "compatibility", "def", "__init__", "self", "val", "self", "val", "val", "def", "default", "o", "if", "isinstance", "o", "x", "return", "f", "o", "val", "return", "defaultjsonprovider", "default", "o", "class", "customprovider", "defaultjsonprovider", "def", "object_hook", "self", "obj", "if", "len", "obj", "1", "and", "_foo", "in", "obj", "return", "x", "obj", "_foo", "return", "obj", "def", "loads", "self", "s", "kwargs", "kwargs", "setdefault", "object_hook", "self", "object_hook", "return", "super", "loads", "s", "kwargs", "app", "json", "customprovider", "app", "app", "json", "default", "default", "app", "route", "methods", "post", "def", "index", "return", "flask", "json", "dumps", "flask", "request", "get_json", "x", "rv", "client", "post", "data", "flask", "json", "dumps", "x", "_foo", "42", "content_type", "application", "json", "assert", "rv", "data", "b", "42"], "doc_len": 112}
{"doc_id": "tests/test_json.py::_has_encoding", "file_path": "tests/test_json.py", "class_name": null, "func_name": "_has_encoding", "text": "文件路径: tests/test_json.py\ndef _has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False\n", "tokens": ["tests", "test_json", "py", "def", "_has_encoding", "name", "try", "import", "codecs", "codecs", "lookup", "name", "return", "true", "except", "lookuperror", "return", "false"], "doc_len": 18}
{"doc_id": "tests/test_json.py::test_modified_url_encoding", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_modified_url_encoding", "text": "文件路径: tests/test_json.py\ndef test_modified_url_encoding(app, client):\n    class ModifiedRequest(flask.Request):\n        url_charset = \"euc-kr\"\n\n    app.request_class = ModifiedRequest\n    app.url_map.charset = \"euc-kr\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.args[\"foo\"]\n\n    rv = client.get(\"/\", query_string={\"foo\": \"정상처리\"}, charset=\"euc-kr\")\n    assert rv.status_code == 200\n    assert rv.get_data(as_text=True) == \"정상처리\"\n", "tokens": ["tests", "test_json", "py", "def", "test_modified_url_encoding", "app", "client", "class", "modifiedrequest", "flask", "request", "url_charset", "euc", "kr", "app", "request_class", "modifiedrequest", "app", "url_map", "charset", "euc", "kr", "app", "route", "def", "index", "return", "flask", "request", "args", "foo", "rv", "client", "get", "query_string", "foo", "charset", "euc", "kr", "assert", "rv", "status_code", "200", "assert", "rv", "get_data", "as_text", "true"], "doc_len": 48}
{"doc_id": "tests/test_json.py::test_json_key_sorting", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_json_key_sorting", "text": "文件路径: tests/test_json.py\ndef test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str\n", "tokens": ["tests", "test_json", "py", "def", "test_json_key_sorting", "app", "client", "app", "debug", "true", "assert", "app", "json", "sort_keys", "d", "dict", "fromkeys", "range", "20", "foo", "app", "route", "def", "index", "return", "flask", "jsonify", "values", "d", "rv", "client", "get", "lines", "x", "strip", "for", "x", "in", "rv", "data", "strip", "decode", "utf", "8", "splitlines", "sorted_by_str", "values", "0", "foo", "1", "foo", "10", "foo", "11", "foo", "12", "foo", "13", "foo", "14", "foo", "15", "foo", "16", "foo", "17", "foo", "18", "foo", "19", "foo", "2", "foo", "3", "foo", "4", "foo", "5", "foo", "6", "foo", "7", "foo", "8", "foo", "9", "foo", "sorted_by_int", "values", "0", "foo", "1", "foo", "2", "foo", "3", "foo", "4", "foo", "5", "foo", "6", "foo", "7", "foo", "8", "foo", "9", "foo", "10", "foo", "11", "foo", "12", "foo", "13", "foo", "14", "foo", "15", "foo", "16", "foo", "17", "foo", "18", "foo", "19", "foo", "try", "assert", "lines", "sorted_by_int", "except", "assertionerror", "assert", "lines", "sorted_by_str"], "doc_len": 138}
{"doc_id": "tests/test_json.py::test_html_method", "file_path": "tests/test_json.py", "class_name": null, "func_name": "test_html_method", "text": "文件路径: tests/test_json.py\ndef test_html_method():\n    class ObjectWithHTML:\n        def __html__(self):\n            return \"<p>test</p>\"\n\n    result = json.dumps(ObjectWithHTML())\n    assert result == '\"<p>test</p>\"'\n", "tokens": ["tests", "test_json", "py", "def", "test_html_method", "class", "objectwithhtml", "def", "__html__", "self", "return", "p", "test", "p", "result", "json", "dumps", "objectwithhtml", "assert", "result", "p", "test", "p"], "doc_len": 23}
{"doc_id": "tests/test_json_tag.py::test_dump_load_unchanged", "file_path": "tests/test_json_tag.py", "class_name": null, "func_name": "test_dump_load_unchanged", "text": "文件路径: tests/test_json_tag.py\ndef test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data\n", "tokens": ["tests", "test_json_tag", "py", "def", "test_dump_load_unchanged", "data", "s", "taggedjsonserializer", "assert", "s", "loads", "s", "dumps", "data", "data"], "doc_len": 15}
{"doc_id": "tests/test_json_tag.py::test_duplicate_tag", "file_path": "tests/test_json_tag.py", "class_name": null, "func_name": "test_duplicate_tag", "text": "文件路径: tests/test_json_tag.py\ndef test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)\n", "tokens": ["tests", "test_json_tag", "py", "def", "test_duplicate_tag", "class", "tagdict", "jsontag", "key", "d", "s", "taggedjsonserializer", "pytest", "raises", "keyerror", "s", "register", "tagdict", "s", "register", "tagdict", "force", "true", "index", "0", "assert", "isinstance", "s", "tags", "d", "tagdict", "assert", "isinstance", "s", "order", "0", "tagdict"], "doc_len": 37}
{"doc_id": "tests/test_json_tag.py::test_custom_tag", "file_path": "tests/test_json_tag.py", "class_name": null, "func_name": "test_custom_tag", "text": "文件路径: tests/test_json_tag.py\ndef test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"\n", "tokens": ["tests", "test_json_tag", "py", "def", "test_custom_tag", "class", "foo", "noqa", "b903", "for", "python2", "compatibility", "def", "__init__", "self", "data", "self", "data", "data", "class", "tagfoo", "jsontag", "__slots__", "key", "f", "def", "check", "self", "value", "return", "isinstance", "value", "foo", "def", "to_json", "self", "value", "return", "self", "serializer", "tag", "value", "data", "def", "to_python", "self", "value", "return", "foo", "value", "s", "taggedjsonserializer", "s", "register", "tagfoo", "assert", "s", "loads", "s", "dumps", "foo", "bar", "data", "bar"], "doc_len": 64}
{"doc_id": "tests/test_json_tag.py::test_tag_interface", "file_path": "tests/test_json_tag.py", "class_name": null, "func_name": "test_tag_interface", "text": "文件路径: tests/test_json_tag.py\ndef test_tag_interface():\n    t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)\n", "tokens": ["tests", "test_json_tag", "py", "def", "test_tag_interface", "t", "jsontag", "none", "pytest", "raises", "notimplementederror", "t", "check", "none", "pytest", "raises", "notimplementederror", "t", "to_json", "none", "pytest", "raises", "notimplementederror", "t", "to_python", "none"], "doc_len": 26}
{"doc_id": "tests/test_json_tag.py::test_tag_order", "file_path": "tests/test_json_tag.py", "class_name": null, "func_name": "test_tag_order", "text": "文件路径: tests/test_json_tag.py\ndef test_tag_order():\n    class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)\n", "tokens": ["tests", "test_json_tag", "py", "def", "test_tag_order", "class", "tag1", "jsontag", "key", "1", "class", "tag2", "jsontag", "key", "2", "s", "taggedjsonserializer", "s", "register", "tag1", "index", "1", "assert", "isinstance", "s", "order", "2", "tag1", "s", "register", "tag2", "index", "none", "assert", "isinstance", "s", "order", "1", "tag2"], "doc_len": 39}
{"doc_id": "tests/test_logging.py::reset_logging", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "reset_logging", "text": "文件路径: tests/test_logging.py\ndef reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")\n", "tokens": ["tests", "test_logging", "py", "def", "reset_logging", "pytestconfig", "root_handlers", "logging", "root", "handlers", "logging", "root", "handlers", "root_level", "logging", "root", "level", "logger", "logging", "getlogger", "flask_test", "logger", "handlers", "logger", "setlevel", "logging", "notset", "logging_plugin", "pytestconfig", "pluginmanager", "unregister", "name", "logging", "plugin", "yield", "logging", "root", "handlers", "root_handlers", "logging", "root", "setlevel", "root_level", "logger", "handlers", "logger", "setlevel", "logging", "notset", "if", "logging_plugin", "pytestconfig", "pluginmanager", "register", "logging_plugin", "logging", "plugin"], "doc_len": 57}
{"doc_id": "tests/test_logging.py::test_logger", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_logger", "text": "文件路径: tests/test_logging.py\ndef test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]\n", "tokens": ["tests", "test_logging", "py", "def", "test_logger", "app", "assert", "app", "logger", "name", "flask_test", "assert", "app", "logger", "level", "logging", "notset", "assert", "app", "logger", "handlers", "default_handler"], "doc_len": 22}
{"doc_id": "tests/test_logging.py::test_logger_debug", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_logger_debug", "text": "文件路径: tests/test_logging.py\ndef test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]\n", "tokens": ["tests", "test_logging", "py", "def", "test_logger_debug", "app", "app", "debug", "true", "assert", "app", "logger", "level", "logging", "debug", "assert", "app", "logger", "handlers", "default_handler"], "doc_len": 20}
{"doc_id": "tests/test_logging.py::test_existing_handler", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_existing_handler", "text": "文件路径: tests/test_logging.py\ndef test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers\n", "tokens": ["tests", "test_logging", "py", "def", "test_existing_handler", "app", "logging", "root", "addhandler", "logging", "streamhandler", "assert", "app", "logger", "level", "logging", "notset", "assert", "not", "app", "logger", "handlers"], "doc_len": 22}
{"doc_id": "tests/test_logging.py::test_wsgi_errors_stream", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_wsgi_errors_stream", "text": "文件路径: tests/test_logging.py\ndef test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream\n", "tokens": ["tests", "test_logging", "py", "def", "test_wsgi_errors_stream", "app", "client", "app", "route", "def", "index", "app", "logger", "error", "test", "return", "stream", "stringio", "client", "get", "errors_stream", "stream", "assert", "error", "in", "test_logging", "test", "in", "stream", "getvalue", "assert", "wsgi_errors_stream", "_get_current_object", "is", "sys", "stderr", "with", "app", "test_request_context", "errors_stream", "stream", "assert", "wsgi_errors_stream", "_get_current_object", "is", "stream"], "doc_len": 46}
{"doc_id": "tests/test_logging.py::test_has_level_handler", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_has_level_handler", "text": "文件路径: tests/test_logging.py\ndef test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)\n", "tokens": ["tests", "test_logging", "py", "def", "test_has_level_handler", "logger", "logging", "getlogger", "flask", "app", "assert", "not", "has_level_handler", "logger", "handler", "logging", "streamhandler", "logging", "root", "addhandler", "handler", "assert", "has_level_handler", "logger", "logger", "propagate", "false", "assert", "not", "has_level_handler", "logger", "logger", "propagate", "true", "handler", "setlevel", "logging", "error", "assert", "not", "has_level_handler", "logger"], "doc_len": 42}
{"doc_id": "tests/test_logging.py::test_log_view_exception", "file_path": "tests/test_logging.py", "class_name": null, "func_name": "test_log_view_exception", "text": "文件路径: tests/test_logging.py\ndef test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err\n", "tokens": ["tests", "test_logging", "py", "def", "test_log_view_exception", "app", "client", "app", "route", "def", "index", "raise", "exception", "test", "app", "testing", "false", "stream", "stringio", "rv", "client", "get", "errors_stream", "stream", "assert", "rv", "status_code", "500", "assert", "rv", "data", "err", "stream", "getvalue", "assert", "exception", "on", "get", "in", "err", "assert", "exception", "test", "in", "err"], "doc_len": 45}
{"doc_id": "tests/test_regression.py::test_aborting", "file_path": "tests/test_regression.py", "class_name": null, "func_name": "test_aborting", "text": "文件路径: tests/test_regression.py\ndef test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"\n", "tokens": ["tests", "test_regression", "py", "def", "test_aborting", "app", "class", "foo", "exception", "whatever", "42", "app", "errorhandler", "foo", "def", "handle_foo", "e", "return", "str", "e", "whatever", "app", "route", "def", "index", "raise", "flask", "abort", "flask", "redirect", "flask", "url_for", "test", "app", "route", "test", "def", "test", "raise", "foo", "with", "app", "test_client", "as", "c", "rv", "c", "get", "location_parts", "rv", "headers", "location", "rpartition", "if", "location_parts", "0", "for", "older", "werkzeug", "that", "used", "absolute", "redirects", "assert", "location_parts", "0", "http", "localhost", "assert", "location_parts", "2", "test", "rv", "c", "get", "test", "assert", "rv", "data", "b", "42"], "doc_len": 81}
{"doc_id": "tests/test_reqctx.py::test_teardown_on_pop", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_teardown_on_pop", "text": "文件路径: tests/test_reqctx.py\ndef test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_teardown_on_pop", "app", "buffer", "app", "teardown_request", "def", "end_of_request", "exception", "buffer", "append", "exception", "ctx", "app", "test_request_context", "ctx", "push", "assert", "buffer", "ctx", "pop", "assert", "buffer", "none"], "doc_len": 27}
{"doc_id": "tests/test_reqctx.py::test_teardown_with_previous_exception", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_teardown_with_previous_exception", "text": "文件路径: tests/test_reqctx.py\ndef test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_teardown_with_previous_exception", "app", "buffer", "app", "teardown_request", "def", "end_of_request", "exception", "buffer", "append", "exception", "try", "raise", "exception", "dummy", "except", "exception", "pass", "with", "app", "test_request_context", "assert", "buffer", "assert", "buffer", "none"], "doc_len": 30}
{"doc_id": "tests/test_reqctx.py::test_teardown_with_handled_exception", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_teardown_with_handled_exception", "text": "文件路径: tests/test_reqctx.py\ndef test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_teardown_with_handled_exception", "app", "buffer", "app", "teardown_request", "def", "end_of_request", "exception", "buffer", "append", "exception", "with", "app", "test_request_context", "assert", "buffer", "try", "raise", "exception", "dummy", "except", "exception", "pass", "assert", "buffer", "none"], "doc_len": 30}
{"doc_id": "tests/test_reqctx.py::test_proper_test_request_context", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_proper_test_request_context", "text": "文件路径: tests/test_reqctx.py\ndef test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_proper_test_request_context", "app", "app", "config", "update", "server_name", "localhost", "localdomain", "5000", "app", "route", "def", "index", "return", "none", "app", "route", "subdomain", "foo", "def", "sub", "return", "none", "with", "app", "test_request_context", "assert", "flask", "url_for", "index", "_external", "true", "http", "localhost", "localdomain", "5000", "with", "app", "test_request_context", "assert", "flask", "url_for", "sub", "_external", "true", "http", "foo", "localhost", "localdomain", "5000", "suppress", "werkzeug", "0", "15", "warning", "about", "name", "mismatch", "with", "warnings", "catch_warnings", "warnings", "filterwarnings", "ignore", "current", "server", "name", "userwarning", "flask", "app", "with", "app", "test_request_context", "environ_overrides", "http_host", "localhost", "pass", "app", "config", "update", "server_name", "localhost", "with", "app", "test_request_context", "environ_overrides", "server_name", "localhost", "pass", "app", "config", "update", "server_name", "localhost", "80", "with", "app", "test_request_context", "environ_overrides", "server_name", "localhost", "80", "pass"], "doc_len": 107}
{"doc_id": "tests/test_reqctx.py::test_context_binding", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_context_binding", "text": "文件路径: tests/test_reqctx.py\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_context_binding", "app", "app", "route", "def", "index", "return", "f", "hello", "flask", "request", "args", "name", "app", "route", "meh", "def", "meh", "return", "flask", "request", "url", "with", "app", "test_request_context", "name", "world", "assert", "index", "hello", "world", "with", "app", "test_request_context", "meh", "assert", "meh", "http", "localhost", "meh", "assert", "not", "flask", "request"], "doc_len": 48}
{"doc_id": "tests/test_reqctx.py::test_context_test", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_context_test", "text": "文件路径: tests/test_reqctx.py\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_context_test", "app", "assert", "not", "flask", "request", "assert", "not", "flask", "has_request_context", "ctx", "app", "test_request_context", "ctx", "push", "try", "assert", "flask", "request", "assert", "flask", "has_request_context", "finally", "ctx", "pop"], "doc_len": 29}
{"doc_id": "tests/test_reqctx.py::test_manual_context_binding", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_manual_context_binding", "text": "文件路径: tests/test_reqctx.py\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_manual_context_binding", "app", "app", "route", "def", "index", "return", "f", "hello", "flask", "request", "args", "name", "ctx", "app", "test_request_context", "name", "world", "ctx", "push", "assert", "index", "hello", "world", "ctx", "pop", "with", "pytest", "raises", "runtimeerror", "index"], "doc_len": 35}
{"doc_id": "tests/test_reqctx.py::TestGreenletContextCopying.test_greenlet_context_copying", "file_path": "tests/test_reqctx.py", "class_name": "TestGreenletContextCopying", "func_name": "test_greenlet_context_copying", "text": "文件路径: tests/test_reqctx.py, 类名: TestGreenletContextCopying\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            reqctx = request_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with reqctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "tokens": ["tests", "test_reqctx", "py", "testgreenletcontextcopying", "def", "test_greenlet_context_copying", "self", "app", "client", "greenlets", "app", "route", "def", "index", "flask", "session", "fizz", "buzz", "reqctx", "request_ctx", "copy", "def", "g", "assert", "not", "flask", "request", "assert", "not", "flask", "current_app", "with", "reqctx", "assert", "flask", "request", "assert", "flask", "current_app", "app", "assert", "flask", "request", "path", "assert", "flask", "request", "args", "foo", "bar", "assert", "flask", "session", "get", "fizz", "buzz", "assert", "not", "flask", "request", "return", "42", "greenlets", "append", "greenlet", "g", "return", "hello", "world", "rv", "client", "get", "foo", "bar", "assert", "rv", "data", "b", "hello", "world", "result", "greenlets", "0", "run", "assert", "result", "42"], "doc_len": 87}
{"doc_id": "tests/test_reqctx.py::TestGreenletContextCopying.test_greenlet_context_copying_api", "file_path": "tests/test_reqctx.py", "class_name": "TestGreenletContextCopying", "func_name": "test_greenlet_context_copying_api", "text": "文件路径: tests/test_reqctx.py, 类名: TestGreenletContextCopying\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n", "tokens": ["tests", "test_reqctx", "py", "testgreenletcontextcopying", "def", "test_greenlet_context_copying_api", "self", "app", "client", "greenlets", "app", "route", "def", "index", "flask", "session", "fizz", "buzz", "flask", "copy_current_request_context", "def", "g", "assert", "flask", "request", "assert", "flask", "current_app", "app", "assert", "flask", "request", "path", "assert", "flask", "request", "args", "foo", "bar", "assert", "flask", "session", "get", "fizz", "buzz", "return", "42", "greenlets", "append", "greenlet", "g", "return", "hello", "world", "rv", "client", "get", "foo", "bar", "assert", "rv", "data", "b", "hello", "world", "result", "greenlets", "0", "run", "assert", "result", "42"], "doc_len": 72}
{"doc_id": "tests/test_reqctx.py::test_session_error_pops_context", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_session_error_pops_context", "text": "文件路径: tests/test_reqctx.py\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_session_error_pops_context", "class", "sessionerror", "exception", "pass", "class", "failingsessioninterface", "sessioninterface", "def", "open_session", "self", "app", "request", "raise", "sessionerror", "class", "customflask", "flask", "flask", "session_interface", "failingsessioninterface", "app", "customflask", "__name__", "app", "route", "def", "index", "shouldn", "t", "get", "here", "assertionerror", "response", "app", "test_client", "get", "assert", "response", "status_code", "500", "assert", "not", "flask", "request", "assert", "not", "flask", "current_app"], "doc_len": 53}
{"doc_id": "tests/test_reqctx.py::test_session_dynamic_cookie_name", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_session_dynamic_cookie_name", "text": "文件路径: tests/test_reqctx.py\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_session_dynamic_cookie_name", "this", "session", "interface", "will", "use", "a", "cookie", "with", "a", "different", "name", "if", "the", "requested", "url", "ends", "with", "the", "string", "dynamic_cookie", "class", "pathawaresessioninterface", "securecookiesessioninterface", "def", "get_cookie_name", "self", "app", "if", "flask", "request", "url", "endswith", "dynamic_cookie", "return", "dynamic_cookie_name", "else", "return", "super", "get_cookie_name", "app", "class", "customflask", "flask", "flask", "session_interface", "pathawaresessioninterface", "app", "customflask", "__name__", "app", "secret_key", "secret_key", "app", "route", "set", "methods", "post", "def", "set", "flask", "session", "value", "flask", "request", "form", "value", "return", "value", "set", "app", "route", "get", "def", "get", "v", "flask", "session", "get", "value", "none", "return", "v", "app", "route", "set_dynamic_cookie", "methods", "post", "def", "set_dynamic_cookie", "flask", "session", "value", "flask", "request", "form", "value", "return", "value", "set", "app", "route", "get_dynamic_cookie", "def", "get_dynamic_cookie", "v", "flask", "session", "get", "value", "none", "return", "v", "test_client", "app", "test_client", "first", "set", "the", "cookie", "in", "both", "set", "urls", "but", "each", "with", "a", "different", "value", "assert", "test_client", "post", "set", "data", "value", "42", "data", "b", "value", "set", "assert", "test_client", "post", "set_dynamic_cookie", "data", "value", "616", "data", "b", "value", "set", "now", "check", "that", "the", "relevant", "values", "come", "back", "meaning", "that", "different", "cookies", "are", "being", "used", "for", "the", "urls", "that", "end", "with", "dynamic", "cookie", "assert", "test_client", "get", "get", "data", "b", "42", "assert", "test_client", "get", "get_dynamic_cookie", "data", "b", "616"], "doc_len": 193}
{"doc_id": "tests/test_reqctx.py::test_bad_environ_raises_bad_request", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_bad_environ_raises_bad_request", "text": "文件路径: tests/test_reqctx.py\ndef test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n    assert response.status_code == 400\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_bad_environ_raises_bad_request", "app", "flask", "flask", "__name__", "from", "flask", "testing", "import", "environbuilder", "builder", "environbuilder", "app", "environ", "builder", "get_environ", "use", "a", "non", "printable", "character", "in", "the", "host", "this", "is", "key", "to", "this", "test", "environ", "http_host", "x8a", "with", "app", "request_context", "environ", "response", "app", "full_dispatch_request", "assert", "response", "status_code", "400"], "doc_len": 48}
{"doc_id": "tests/test_reqctx.py::test_environ_for_valid_idna_completes", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_environ_for_valid_idna_completes", "text": "文件路径: tests/test_reqctx.py\ndef test_environ_for_valid_idna_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"ąśźäüжŠßя.com\"\n\n    with app.request_context(environ):\n        response = app.full_dispatch_request()\n\n    assert response.status_code == 200\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_environ_for_valid_idna_completes", "app", "flask", "flask", "__name__", "app", "route", "def", "index", "return", "hello", "world", "from", "flask", "testing", "import", "environbuilder", "builder", "environbuilder", "app", "environ", "builder", "get_environ", "these", "characters", "are", "all", "idna", "compatible", "environ", "http_host", "com", "with", "app", "request_context", "environ", "response", "app", "full_dispatch_request", "assert", "response", "status_code", "200"], "doc_len": 47}
{"doc_id": "tests/test_reqctx.py::test_normal_environ_completes", "file_path": "tests/test_reqctx.py", "class_name": null, "func_name": "test_normal_environ_completes", "text": "文件路径: tests/test_reqctx.py\ndef test_normal_environ_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200\n", "tokens": ["tests", "test_reqctx", "py", "def", "test_normal_environ_completes", "app", "flask", "flask", "__name__", "app", "route", "def", "index", "return", "hello", "world", "response", "app", "test_client", "get", "headers", "host", "xn", "on", "0ia", "com", "assert", "response", "status_code", "200"], "doc_len": 30}
{"doc_id": "tests/test_session_interface.py::test_open_session_with_endpoint", "file_path": "tests/test_session_interface.py", "class_name": null, "func_name": "test_open_session_with_endpoint", "text": "文件路径: tests/test_session_interface.py\ndef test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            request_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200\n", "tokens": ["tests", "test_session_interface", "py", "def", "test_open_session_with_endpoint", "if", "request", "endpoint", "or", "other", "url", "matching", "behavior", "is", "needed", "while", "loading", "the", "session", "requestcontext", "match_request", "can", "be", "called", "manually", "class", "mysessioninterface", "sessioninterface", "def", "save_session", "self", "app", "session", "response", "pass", "def", "open_session", "self", "app", "request", "request_ctx", "match_request", "assert", "request", "endpoint", "is", "not", "none", "app", "flask", "flask", "__name__", "app", "session_interface", "mysessioninterface", "app", "get", "def", "index", "return", "hello", "world", "response", "app", "test_client", "get", "assert", "response", "status_code", "200"], "doc_len": 70}
{"doc_id": "tests/test_signals.py::test_template_rendered", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_template_rendered", "text": "文件路径: tests/test_signals.py\ndef test_template_rendered(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_template_rendered", "app", "client", "app", "route", "def", "index", "return", "flask", "render_template", "simple_template", "html", "whiskey", "42", "recorded", "def", "record", "sender", "template", "context", "recorded", "append", "template", "context", "flask", "template_rendered", "connect", "record", "app", "try", "client", "get", "assert", "len", "recorded", "1", "template", "context", "recorded", "0", "assert", "template", "name", "simple_template", "html", "assert", "context", "whiskey", "42", "finally", "flask", "template_rendered", "disconnect", "record", "app"], "doc_len": 59}
{"doc_id": "tests/test_signals.py::test_before_render_template", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_before_render_template", "text": "文件路径: tests/test_signals.py\ndef test_before_render_template():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context[\"whiskey\"] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_before_render_template", "app", "flask", "flask", "__name__", "app", "route", "def", "index", "return", "flask", "render_template", "simple_template", "html", "whiskey", "42", "recorded", "def", "record", "sender", "template", "context", "context", "whiskey", "43", "recorded", "append", "template", "context", "flask", "before_render_template", "connect", "record", "app", "try", "rv", "app", "test_client", "get", "assert", "len", "recorded", "1", "template", "context", "recorded", "0", "assert", "template", "name", "simple_template", "html", "assert", "context", "whiskey", "43", "assert", "rv", "data", "b", "h1", "43", "h1", "finally", "flask", "before_render_template", "disconnect", "record", "app"], "doc_len": 73}
{"doc_id": "tests/test_signals.py::test_request_signals", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_request_signals", "text": "文件路径: tests/test_signals.py\ndef test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_request_signals", "app", "flask", "flask", "__name__", "calls", "def", "before_request_signal", "sender", "calls", "append", "before", "signal", "def", "after_request_signal", "sender", "response", "assert", "response", "data", "b", "stuff", "calls", "append", "after", "signal", "app", "before_request", "def", "before_request_handler", "calls", "append", "before", "handler", "app", "after_request", "def", "after_request_handler", "response", "calls", "append", "after", "handler", "response", "data", "stuff", "return", "response", "app", "route", "def", "index", "calls", "append", "handler", "return", "ignored", "anyway", "flask", "request_started", "connect", "before_request_signal", "app", "flask", "request_finished", "connect", "after_request_signal", "app", "try", "rv", "app", "test_client", "get", "assert", "rv", "data", "b", "stuff", "assert", "calls", "before", "signal", "before", "handler", "handler", "after", "handler", "after", "signal", "finally", "flask", "request_started", "disconnect", "before_request_signal", "app", "flask", "request_finished", "disconnect", "after_request_signal", "app"], "doc_len": 104}
{"doc_id": "tests/test_signals.py::test_request_exception_signal", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_request_exception_signal", "text": "文件路径: tests/test_signals.py\ndef test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        1 // 0\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_request_exception_signal", "app", "flask", "flask", "__name__", "recorded", "app", "route", "def", "index", "1", "0", "def", "record", "sender", "exception", "recorded", "append", "exception", "flask", "got_request_exception", "connect", "record", "app", "try", "assert", "app", "test_client", "get", "status_code", "500", "assert", "len", "recorded", "1", "assert", "isinstance", "recorded", "0", "zerodivisionerror", "finally", "flask", "got_request_exception", "disconnect", "record", "app"], "doc_len": 50}
{"doc_id": "tests/test_signals.py::test_appcontext_signals", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_appcontext_signals", "text": "文件路径: tests/test_signals.py\ndef test_appcontext_signals(app, client):\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.data == b\"Hello\"\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_appcontext_signals", "app", "client", "recorded", "def", "record_push", "sender", "kwargs", "recorded", "append", "push", "def", "record_pop", "sender", "kwargs", "recorded", "append", "pop", "app", "route", "def", "index", "return", "hello", "flask", "appcontext_pushed", "connect", "record_push", "app", "flask", "appcontext_popped", "connect", "record_pop", "app", "try", "rv", "client", "get", "assert", "rv", "data", "b", "hello", "assert", "recorded", "push", "pop", "finally", "flask", "appcontext_pushed", "disconnect", "record_push", "app", "flask", "appcontext_popped", "disconnect", "record_pop", "app"], "doc_len": 62}
{"doc_id": "tests/test_signals.py::test_flash_signal", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_flash_signal", "text": "文件路径: tests/test_signals.py\ndef test_flash_signal(app):\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_flash_signal", "app", "app", "route", "def", "index", "flask", "flash", "this", "is", "a", "flash", "message", "category", "notice", "return", "flask", "redirect", "other", "recorded", "def", "record", "sender", "message", "category", "recorded", "append", "message", "category", "flask", "message_flashed", "connect", "record", "app", "try", "client", "app", "test_client", "with", "client", "session_transaction", "client", "get", "assert", "len", "recorded", "1", "message", "category", "recorded", "0", "assert", "message", "this", "is", "a", "flash", "message", "assert", "category", "notice", "finally", "flask", "message_flashed", "disconnect", "record", "app"], "doc_len": 71}
{"doc_id": "tests/test_signals.py::test_appcontext_tearing_down_signal", "file_path": "tests/test_signals.py", "class_name": null, "func_name": "test_appcontext_tearing_down_signal", "text": "文件路径: tests/test_signals.py\ndef test_appcontext_tearing_down_signal(app, client):\n    app.testing = False\n    recorded = []\n\n    def record_teardown(sender, exc):\n        recorded.append(exc)\n\n    @app.route(\"/\")\n    def index():\n        1 // 0\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)\n", "tokens": ["tests", "test_signals", "py", "def", "test_appcontext_tearing_down_signal", "app", "client", "app", "testing", "false", "recorded", "def", "record_teardown", "sender", "exc", "recorded", "append", "exc", "app", "route", "def", "index", "1", "0", "flask", "appcontext_tearing_down", "connect", "record_teardown", "app", "try", "rv", "client", "get", "assert", "rv", "status_code", "500", "assert", "len", "recorded", "1", "assert", "isinstance", "recorded", "0", "zerodivisionerror", "finally", "flask", "appcontext_tearing_down", "disconnect", "record_teardown", "app"], "doc_len": 52}
{"doc_id": "tests/test_subclassing.py::test_suppressed_exception_logging", "file_path": "tests/test_subclassing.py", "class_name": null, "func_name": "test_suppressed_exception_logging", "text": "文件路径: tests/test_subclassing.py\ndef test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()\n", "tokens": ["tests", "test_subclassing", "py", "def", "test_suppressed_exception_logging", "class", "suppressedflask", "flask", "flask", "def", "log_exception", "self", "exc_info", "pass", "out", "stringio", "app", "suppressedflask", "__name__", "app", "route", "def", "index", "raise", "exception", "test", "rv", "app", "test_client", "get", "errors_stream", "out", "assert", "rv", "status_code", "500", "assert", "b", "internal", "server", "error", "in", "rv", "data", "assert", "not", "out", "getvalue"], "doc_len": 48}
{"doc_id": "tests/test_templating.py::test_context_processing", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_context_processing", "text": "文件路径: tests/test_templating.py\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_context_processing", "app", "client", "app", "context_processor", "def", "context_processor", "return", "injected_value", "42", "app", "route", "def", "index", "return", "flask", "render_template", "context_template", "html", "value", "23", "rv", "client", "get", "assert", "rv", "data", "b", "p", "23", "42"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_original_win", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_original_win", "text": "文件路径: tests/test_templating.py\ndef test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_original_win", "app", "client", "app", "route", "def", "index", "return", "flask", "render_template_string", "config", "config", "42", "rv", "client", "get", "assert", "rv", "data", "b", "42"], "doc_len": 25}
{"doc_id": "tests/test_templating.py::test_simple_stream", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_simple_stream", "text": "文件路径: tests/test_templating.py\ndef test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_simple_stream", "app", "client", "app", "route", "def", "index", "return", "flask", "stream_template_string", "config", "config", "42", "rv", "client", "get", "assert", "rv", "data", "b", "42"], "doc_len": 25}
{"doc_id": "tests/test_templating.py::test_request_less_rendering", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_request_less_rendering", "text": "文件路径: tests/test_templating.py\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_request_less_rendering", "app", "app_ctx", "app", "config", "world_name", "special", "world", "app", "context_processor", "def", "context_processor", "return", "dict", "foo", "42", "rv", "flask", "render_template_string", "hello", "config", "world_name", "foo", "assert", "rv", "hello", "special", "world", "42"], "doc_len": 33}
{"doc_id": "tests/test_templating.py::test_standard_context", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_standard_context", "text": "文件路径: tests/test_templating.py\ndef test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n", "tokens": ["tests", "test_templating", "py", "def", "test_standard_context", "app", "client", "app", "route", "def", "index", "flask", "g", "foo", "23", "flask", "session", "test", "aha", "return", "flask", "render_template_string", "request", "args", "foo", "g", "foo", "config", "debug", "session", "test", "rv", "client", "get", "foo", "42", "assert", "rv", "data", "split", "b", "42", "b", "23", "b", "false", "b", "aha"], "doc_len": 48}
{"doc_id": "tests/test_templating.py::test_escaping", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_escaping", "text": "文件路径: tests/test_templating.py\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n", "tokens": ["tests", "test_templating", "py", "def", "test_escaping", "app", "client", "text", "p", "hello", "world", "app", "route", "def", "index", "return", "flask", "render_template", "escaping_template", "html", "text", "text", "html", "markup", "text", "lines", "client", "get", "data", "splitlines", "assert", "lines", "b", "lt", "p", "gt", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "lt", "p", "gt", "hello", "world", "b", "p", "hello", "world"], "doc_len": 60}
{"doc_id": "tests/test_templating.py::test_no_escaping", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_no_escaping", "text": "文件路径: tests/test_templating.py\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n", "tokens": ["tests", "test_templating", "py", "def", "test_no_escaping", "app", "client", "text", "p", "hello", "world", "app", "route", "def", "index", "return", "flask", "render_template", "non_escaping_template", "txt", "text", "text", "html", "markup", "text", "lines", "client", "get", "data", "splitlines", "assert", "lines", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "lt", "p", "gt", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world", "b", "p", "hello", "world"], "doc_len": 66}
{"doc_id": "tests/test_templating.py::test_escaping_without_template_filename", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_escaping_without_template_filename", "text": "文件路径: tests/test_templating.py\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_escaping_without_template_filename", "app", "client", "req_ctx", "assert", "flask", "render_template_string", "foo", "foo", "test", "lt", "test", "gt", "assert", "flask", "render_template", "mail", "txt", "foo", "test", "test", "mail"], "doc_len": 26}
{"doc_id": "tests/test_templating.py::test_macros", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_macros", "text": "文件路径: tests/test_templating.py\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_macros", "app", "req_ctx", "macro", "flask", "get_template_attribute", "_macro", "html", "hello", "assert", "macro", "world", "hello", "world"], "doc_len": 18}
{"doc_id": "tests/test_templating.py::test_template_filter", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_filter", "text": "文件路径: tests/test_templating.py\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_filter", "app", "app", "template_filter", "def", "my_reverse", "s", "return", "s", "1", "assert", "my_reverse", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "my_reverse", "my_reverse", "assert", "app", "jinja_env", "filters", "my_reverse", "abcd", "dcba"], "doc_len": 34}
{"doc_id": "tests/test_templating.py::test_add_template_filter", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_filter", "text": "文件路径: tests/test_templating.py\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_filter", "app", "def", "my_reverse", "s", "return", "s", "1", "app", "add_template_filter", "my_reverse", "assert", "my_reverse", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "my_reverse", "my_reverse", "assert", "app", "jinja_env", "filters", "my_reverse", "abcd", "dcba"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_template_filter_with_name", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_filter_with_name", "text": "文件路径: tests/test_templating.py\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_filter_with_name", "app", "app", "template_filter", "strrev", "def", "my_reverse", "s", "return", "s", "1", "assert", "strrev", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "strrev", "my_reverse", "assert", "app", "jinja_env", "filters", "strrev", "abcd", "dcba"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_add_template_filter_with_name", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_filter_with_name", "text": "文件路径: tests/test_templating.py\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_filter_with_name", "app", "def", "my_reverse", "s", "return", "s", "1", "app", "add_template_filter", "my_reverse", "strrev", "assert", "strrev", "in", "app", "jinja_env", "filters", "keys", "assert", "app", "jinja_env", "filters", "strrev", "my_reverse", "assert", "app", "jinja_env", "filters", "strrev", "abcd", "dcba"], "doc_len": 36}
{"doc_id": "tests/test_templating.py::test_template_filter_with_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_filter_with_template", "text": "文件路径: tests/test_templating.py\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_filter_with_template", "app", "client", "app", "template_filter", "def", "super_reverse", "s", "return", "s", "1", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 34}
{"doc_id": "tests/test_templating.py::test_add_template_filter_with_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_filter_with_template", "text": "文件路径: tests/test_templating.py\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_filter_with_template", "app", "client", "def", "super_reverse", "s", "return", "s", "1", "app", "add_template_filter", "super_reverse", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_template_filter_with_name_and_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_filter_with_name_and_template", "text": "文件路径: tests/test_templating.py\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_filter_with_name_and_template", "app", "client", "app", "template_filter", "super_reverse", "def", "my_reverse", "s", "return", "s", "1", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_add_template_filter_with_name_and_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_filter_with_name_and_template", "text": "文件路径: tests/test_templating.py\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_filter_with_name_and_template", "app", "client", "def", "my_reverse", "s", "return", "s", "1", "app", "add_template_filter", "my_reverse", "super_reverse", "app", "route", "def", "index", "return", "flask", "render_template", "template_filter", "html", "value", "abcd", "rv", "client", "get", "assert", "rv", "data", "b", "dcba"], "doc_len": 36}
{"doc_id": "tests/test_templating.py::test_template_test", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_test", "text": "文件路径: tests/test_templating.py\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_test", "app", "app", "template_test", "def", "boolean", "value", "return", "isinstance", "value", "bool", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 34}
{"doc_id": "tests/test_templating.py::test_add_template_test", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_test", "text": "文件路径: tests/test_templating.py\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_test", "app", "def", "boolean", "value", "return", "isinstance", "value", "bool", "app", "add_template_test", "boolean", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_template_test_with_name", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_test_with_name", "text": "文件路径: tests/test_templating.py\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_test_with_name", "app", "app", "template_test", "boolean", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 35}
{"doc_id": "tests/test_templating.py::test_add_template_test_with_name", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_test_with_name", "text": "文件路径: tests/test_templating.py\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_test_with_name", "app", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "add_template_test", "is_boolean", "boolean", "assert", "boolean", "in", "app", "jinja_env", "tests", "keys", "assert", "app", "jinja_env", "tests", "boolean", "is_boolean", "assert", "app", "jinja_env", "tests", "boolean", "false"], "doc_len": 36}
{"doc_id": "tests/test_templating.py::test_template_test_with_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_test_with_template", "text": "文件路径: tests/test_templating.py\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_test_with_template", "app", "client", "app", "template_test", "def", "boolean", "value", "return", "isinstance", "value", "bool", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 36}
{"doc_id": "tests/test_templating.py::test_add_template_test_with_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_test_with_template", "text": "文件路径: tests/test_templating.py\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_test_with_template", "app", "client", "def", "boolean", "value", "return", "isinstance", "value", "bool", "app", "add_template_test", "boolean", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 37}
{"doc_id": "tests/test_templating.py::test_template_test_with_name_and_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_test_with_name_and_template", "text": "文件路径: tests/test_templating.py\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_test_with_name_and_template", "app", "client", "app", "template_test", "boolean", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 37}
{"doc_id": "tests/test_templating.py::test_add_template_test_with_name_and_template", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_test_with_name_and_template", "text": "文件路径: tests/test_templating.py\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_test_with_name_and_template", "app", "client", "def", "is_boolean", "value", "return", "isinstance", "value", "bool", "app", "add_template_test", "is_boolean", "boolean", "app", "route", "def", "index", "return", "flask", "render_template", "template_test", "html", "value", "false", "rv", "client", "get", "assert", "b", "success", "in", "rv", "data"], "doc_len": 38}
{"doc_id": "tests/test_templating.py::test_add_template_global", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_add_template_global", "text": "文件路径: tests/test_templating.py\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_add_template_global", "app", "app_ctx", "app", "template_global", "def", "get_stuff", "return", "42", "assert", "get_stuff", "in", "app", "jinja_env", "globals", "keys", "assert", "app", "jinja_env", "globals", "get_stuff", "get_stuff", "assert", "app", "jinja_env", "globals", "get_stuff", "42", "rv", "flask", "render_template_string", "get_stuff", "assert", "rv", "42"], "doc_len": 39}
{"doc_id": "tests/test_templating.py::test_custom_template_loader", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_custom_template_loader", "text": "文件路径: tests/test_templating.py\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_custom_template_loader", "client", "class", "myflask", "flask", "flask", "def", "create_global_jinja_loader", "self", "from", "jinja2", "import", "dictloader", "return", "dictloader", "index", "html", "hello", "custom", "world", "app", "myflask", "__name__", "app", "route", "def", "index", "return", "flask", "render_template", "index", "html", "c", "app", "test_client", "rv", "c", "get", "assert", "rv", "data", "b", "hello", "custom", "world"], "doc_len": 49}
{"doc_id": "tests/test_templating.py::test_iterable_loader", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_iterable_loader", "text": "文件路径: tests/test_templating.py\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"\n", "tokens": ["tests", "test_templating", "py", "def", "test_iterable_loader", "app", "client", "app", "context_processor", "def", "context_processor", "return", "whiskey", "jameson", "app", "route", "def", "index", "return", "flask", "render_template", "no_template", "xml", "should", "skip", "this", "one", "simple_template", "html", "should", "render", "this", "context_template", "html", "value", "23", "rv", "client", "get", "assert", "rv", "data", "b", "h1", "jameson", "h1"], "doc_len": 46}
{"doc_id": "tests/test_templating.py::test_templates_auto_reload", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_templates_auto_reload", "text": "文件路径: tests/test_templating.py\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n", "tokens": ["tests", "test_templating", "py", "def", "test_templates_auto_reload", "app", "debug", "is", "false", "config", "option", "is", "none", "assert", "app", "debug", "is", "false", "assert", "app", "config", "templates_auto_reload", "is", "none", "assert", "app", "jinja_env", "auto_reload", "is", "false", "debug", "is", "false", "config", "option", "is", "false", "app", "flask", "flask", "__name__", "app", "config", "templates_auto_reload", "false", "assert", "app", "debug", "is", "false", "assert", "app", "jinja_env", "auto_reload", "is", "false", "debug", "is", "false", "config", "option", "is", "true", "app", "flask", "flask", "__name__", "app", "config", "templates_auto_reload", "true", "assert", "app", "debug", "is", "false", "assert", "app", "jinja_env", "auto_reload", "is", "true", "debug", "is", "true", "config", "option", "is", "none", "app", "flask", "flask", "__name__", "app", "config", "debug", "true", "assert", "app", "config", "templates_auto_reload", "is", "none", "assert", "app", "jinja_env", "auto_reload", "is", "true", "debug", "is", "true", "config", "option", "is", "false", "app", "flask", "flask", "__name__", "app", "config", "debug", "true", "app", "config", "templates_auto_reload", "false", "assert", "app", "jinja_env", "auto_reload", "is", "false", "debug", "is", "true", "config", "option", "is", "true", "app", "flask", "flask", "__name__", "app", "config", "debug", "true", "app", "config", "templates_auto_reload", "true", "assert", "app", "jinja_env", "auto_reload", "is", "true"], "doc_len": 159}
{"doc_id": "tests/test_templating.py::test_templates_auto_reload_debug_run", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_templates_auto_reload_debug_run", "text": "文件路径: tests/test_templating.py\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.jinja_env.auto_reload\n", "tokens": ["tests", "test_templating", "py", "def", "test_templates_auto_reload_debug_run", "app", "monkeypatch", "def", "run_simple_mock", "args", "kwargs", "pass", "monkeypatch", "setattr", "werkzeug", "serving", "run_simple", "run_simple_mock", "app", "run", "assert", "not", "app", "jinja_env", "auto_reload", "app", "run", "debug", "true", "assert", "app", "jinja_env", "auto_reload"], "doc_len": 33}
{"doc_id": "tests/test_templating.py::test_template_loader_debugging", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_template_loader_debugging", "text": "文件路径: tests/test_templating.py\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n", "tokens": ["tests", "test_templating", "py", "def", "test_template_loader_debugging", "test_apps", "monkeypatch", "from", "blueprintapp", "import", "app", "called", "class", "_testhandler", "logging", "handler", "def", "handle", "self", "record", "called", "append", "true", "text", "str", "record", "msg", "assert", "1", "trying", "loader", "of", "application", "blueprintapp", "in", "text", "assert", "2", "trying", "loader", "of", "blueprint", "admin", "blueprintapp", "apps", "admin", "in", "text", "assert", "trying", "loader", "of", "blueprint", "frontend", "blueprintapp", "apps", "frontend", "in", "text", "assert", "error", "the", "template", "could", "not", "be", "found", "in", "text", "assert", "looked", "up", "from", "an", "endpoint", "that", "belongs", "to", "the", "blueprint", "frontend", "in", "text", "assert", "see", "https", "flask", "palletsprojects", "com", "blueprints", "templates", "in", "text", "with", "app", "test_client", "as", "c", "monkeypatch", "setitem", "app", "config", "explain_template_loading", "true", "monkeypatch", "setattr", "logging", "getlogger", "blueprintapp", "handlers", "_testhandler", "with", "pytest", "raises", "templatenotfound", "as", "excinfo", "c", "get", "missing", "assert", "missing_template", "html", "in", "str", "excinfo", "value", "assert", "len", "called", "1"], "doc_len": 131}
{"doc_id": "tests/test_templating.py::test_custom_jinja_env", "file_path": "tests/test_templating.py", "class_name": null, "func_name": "test_custom_jinja_env", "text": "文件路径: tests/test_templating.py\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n", "tokens": ["tests", "test_templating", "py", "def", "test_custom_jinja_env", "class", "customenvironment", "flask", "templating", "environment", "pass", "class", "customflask", "flask", "flask", "jinja_environment", "customenvironment", "app", "customflask", "__name__", "assert", "isinstance", "app", "jinja_env", "customenvironment"], "doc_len": 25}
{"doc_id": "tests/test_testing.py::test_environ_defaults_from_config", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_environ_defaults_from_config", "text": "文件路径: tests/test_testing.py\ndef test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_environ_defaults_from_config", "app", "client", "app", "config", "server_name", "example", "com", "1234", "app", "config", "application_root", "foo", "app", "route", "def", "index", "return", "flask", "request", "url", "ctx", "app", "test_request_context", "assert", "ctx", "request", "url", "http", "example", "com", "1234", "foo", "rv", "client", "get", "assert", "rv", "data", "b", "http", "example", "com", "1234", "foo"], "doc_len": 49}
{"doc_id": "tests/test_testing.py::test_environ_defaults", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_environ_defaults", "text": "文件路径: tests/test_testing.py\ndef test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_environ_defaults", "app", "client", "app_ctx", "req_ctx", "app", "route", "def", "index", "return", "flask", "request", "url", "ctx", "app", "test_request_context", "assert", "ctx", "request", "url", "http", "localhost", "with", "client", "rv", "client", "get", "assert", "rv", "data", "b", "http", "localhost"], "doc_len": 37}
{"doc_id": "tests/test_testing.py::test_environ_base_default", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_environ_base_default", "text": "文件路径: tests/test_testing.py\ndef test_environ_base_default(app, client, app_ctx):\n    @app.route(\"/\")\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"127.0.0.1\"\n    assert flask.g.user_agent == f\"werkzeug/{werkzeug.__version__}\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_environ_base_default", "app", "client", "app_ctx", "app", "route", "def", "index", "flask", "g", "user_agent", "flask", "request", "headers", "user", "agent", "return", "flask", "request", "remote_addr", "rv", "client", "get", "assert", "rv", "data", "b", "127", "0", "0", "1", "assert", "flask", "g", "user_agent", "f", "werkzeug", "werkzeug", "__version__"], "doc_len": 43}
{"doc_id": "tests/test_testing.py::test_environ_base_modified", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_environ_base_modified", "text": "文件路径: tests/test_testing.py\ndef test_environ_base_modified(app, client, app_ctx):\n    @app.route(\"/\")\n    def index():\n        flask.g.user_agent = flask.request.headers[\"User-Agent\"]\n        return flask.request.remote_addr\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"0.0.0.0\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"0.0.0.0\"\n    assert flask.g.user_agent == \"Foo\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"0.0.0.1\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Bar\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"0.0.0.1\"\n    assert flask.g.user_agent == \"Bar\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_environ_base_modified", "app", "client", "app_ctx", "app", "route", "def", "index", "flask", "g", "user_agent", "flask", "request", "headers", "user", "agent", "return", "flask", "request", "remote_addr", "client", "environ_base", "remote_addr", "0", "0", "0", "0", "client", "environ_base", "http_user_agent", "foo", "rv", "client", "get", "assert", "rv", "data", "b", "0", "0", "0", "0", "assert", "flask", "g", "user_agent", "foo", "client", "environ_base", "remote_addr", "0", "0", "0", "1", "client", "environ_base", "http_user_agent", "bar", "rv", "client", "get", "assert", "rv", "data", "b", "0", "0", "0", "1", "assert", "flask", "g", "user_agent", "bar"], "doc_len": 78}
{"doc_id": "tests/test_testing.py::test_client_open_environ", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_client_open_environ", "text": "文件路径: tests/test_testing.py\ndef test_client_open_environ(app, client, request):\n    @app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_client_open_environ", "app", "client", "request", "app", "route", "index", "def", "index", "return", "flask", "request", "remote_addr", "builder", "environbuilder", "app", "path", "index", "method", "get", "request", "addfinalizer", "builder", "close", "rv", "client", "open", "builder", "assert", "rv", "data", "b", "127", "0", "0", "1", "environ", "builder", "get_environ", "client", "environ_base", "remote_addr", "127", "0", "0", "2", "rv", "client", "open", "environ", "assert", "rv", "data", "b", "127", "0", "0", "2"], "doc_len": 62}
{"doc_id": "tests/test_testing.py::test_specify_url_scheme", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_specify_url_scheme", "text": "文件路径: tests/test_testing.py\ndef test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_specify_url_scheme", "app", "client", "app", "route", "def", "index", "return", "flask", "request", "url", "ctx", "app", "test_request_context", "url_scheme", "https", "assert", "ctx", "request", "url", "https", "localhost", "rv", "client", "get", "url_scheme", "https", "assert", "rv", "data", "b", "https", "localhost"], "doc_len": 37}
{"doc_id": "tests/test_testing.py::test_path_is_url", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_path_is_url", "text": "文件路径: tests/test_testing.py\ndef test_path_is_url(app):\n    eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_path_is_url", "app", "eb", "environbuilder", "app", "https", "example", "com", "assert", "eb", "url_scheme", "https", "assert", "eb", "host", "example", "com", "assert", "eb", "script_root", "assert", "eb", "path"], "doc_len": 27}
{"doc_id": "tests/test_testing.py::test_environbuilder_json_dumps", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_environbuilder_json_dumps", "text": "文件路径: tests/test_testing.py\ndef test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'\n", "tokens": ["tests", "test_testing", "py", "def", "test_environbuilder_json_dumps", "app", "environbuilder", "json_dumps", "takes", "settings", "from", "the", "app", "app", "json", "ensure_ascii", "false", "eb", "environbuilder", "app", "json", "u20ac", "assert", "eb", "input_stream", "read", "decode", "utf8", "u20ac"], "doc_len": 29}
{"doc_id": "tests/test_testing.py::test_blueprint_with_subdomain", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_blueprint_with_subdomain", "text": "文件路径: tests/test_testing.py\ndef test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_blueprint_with_subdomain", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "app", "config", "server_name", "example", "com", "1234", "app", "config", "application_root", "foo", "client", "app", "test_client", "bp", "flask", "blueprint", "company", "__name__", "subdomain", "xxx", "bp", "route", "def", "index", "return", "flask", "request", "url", "app", "register_blueprint", "bp", "ctx", "app", "test_request_context", "subdomain", "xxx", "assert", "ctx", "request", "url", "http", "xxx", "example", "com", "1234", "foo", "with", "ctx", "assert", "ctx", "request", "blueprint", "bp", "name", "rv", "client", "get", "subdomain", "xxx", "assert", "rv", "data", "b", "http", "xxx", "example", "com", "1234", "foo"], "doc_len": 80}
{"doc_id": "tests/test_testing.py::test_redirect_keep_session", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_redirect_keep_session", "text": "文件路径: tests/test_testing.py\ndef test_redirect_keep_session(app, client, app_ctx):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        if flask.request.method == \"POST\":\n            return flask.redirect(\"/getsession\")\n        flask.session[\"data\"] = \"foo\"\n        return \"index\"\n\n    @app.route(\"/getsession\")\n    def get_session():\n        return flask.session.get(\"data\", \"<missing>\")\n\n    with client:\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"<missing>\"\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"index\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.post(\"/\", data={}, follow_redirects=True)\n        assert rv.data == b\"foo\"\n        assert flask.session.get(\"data\") == \"foo\"\n\n        rv = client.get(\"/getsession\")\n        assert rv.data == b\"foo\"\n", "tokens": ["tests", "test_testing", "py", "def", "test_redirect_keep_session", "app", "client", "app_ctx", "app", "route", "methods", "get", "post", "def", "index", "if", "flask", "request", "method", "post", "return", "flask", "redirect", "getsession", "flask", "session", "data", "foo", "return", "index", "app", "route", "getsession", "def", "get_session", "return", "flask", "session", "get", "data", "missing", "with", "client", "rv", "client", "get", "getsession", "assert", "rv", "data", "b", "missing", "rv", "client", "get", "assert", "rv", "data", "b", "index", "assert", "flask", "session", "get", "data", "foo", "rv", "client", "post", "data", "follow_redirects", "true", "assert", "rv", "data", "b", "foo", "assert", "flask", "session", "get", "data", "foo", "rv", "client", "get", "getsession", "assert", "rv", "data", "b", "foo"], "doc_len": 92}
{"doc_id": "tests/test_testing.py::test_session_transactions", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_session_transactions", "text": "文件路径: tests/test_testing.py\ndef test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]\n", "tokens": ["tests", "test_testing", "py", "def", "test_session_transactions", "app", "client", "app", "route", "def", "index", "return", "str", "flask", "session", "foo", "with", "client", "with", "client", "session_transaction", "as", "sess", "assert", "len", "sess", "0", "sess", "foo", "42", "assert", "len", "sess", "1", "rv", "client", "get", "assert", "rv", "data", "b", "42", "with", "client", "session_transaction", "as", "sess", "assert", "len", "sess", "1", "assert", "sess", "foo", "42"], "doc_len": 55}
{"doc_id": "tests/test_testing.py::test_session_transactions_no_null_sessions", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_session_transactions_no_null_sessions", "text": "文件路径: tests/test_testing.py\ndef test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)\n", "tokens": ["tests", "test_testing", "py", "def", "test_session_transactions_no_null_sessions", "app", "flask", "flask", "__name__", "with", "app", "test_client", "as", "c", "with", "pytest", "raises", "runtimeerror", "as", "e", "with", "c", "session_transaction", "pass", "assert", "session", "backend", "did", "not", "open", "a", "session", "in", "str", "e", "value"], "doc_len": 36}
{"doc_id": "tests/test_testing.py::test_session_transactions_keep_context", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_session_transactions_keep_context", "text": "文件路径: tests/test_testing.py\ndef test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n", "tokens": ["tests", "test_testing", "py", "def", "test_session_transactions_keep_context", "app", "client", "req_ctx", "client", "get", "req", "flask", "request", "_get_current_object", "assert", "req", "is", "not", "none", "with", "client", "session_transaction", "assert", "req", "is", "flask", "request", "_get_current_object"], "doc_len": 28}
{"doc_id": "tests/test_testing.py::test_session_transaction_needs_cookies", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_session_transaction_needs_cookies", "text": "文件路径: tests/test_testing.py\ndef test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n    with pytest.raises(RuntimeError) as e:\n        with c.session_transaction():\n            pass\n    assert \"cookies\" in str(e.value)\n", "tokens": ["tests", "test_testing", "py", "def", "test_session_transaction_needs_cookies", "app", "c", "app", "test_client", "use_cookies", "false", "with", "pytest", "raises", "runtimeerror", "as", "e", "with", "c", "session_transaction", "pass", "assert", "cookies", "in", "str", "e", "value"], "doc_len": 27}
{"doc_id": "tests/test_testing.py::test_test_client_context_binding", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_test_client_context_binding", "text": "文件路径: tests/test_testing.py\ndef test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        1 // 0\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    try:\n        flask.g.value\n    except (AttributeError, RuntimeError):\n        pass\n    else:\n        raise AssertionError(\"some kind of exception expected\")\n", "tokens": ["tests", "test_testing", "py", "def", "test_test_client_context_binding", "app", "client", "app", "testing", "false", "app", "route", "def", "index", "flask", "g", "value", "42", "return", "hello", "world", "app", "route", "other", "def", "other", "1", "0", "with", "client", "resp", "client", "get", "assert", "flask", "g", "value", "42", "assert", "resp", "data", "b", "hello", "world", "assert", "resp", "status_code", "200", "resp", "client", "get", "other", "assert", "not", "hasattr", "flask", "g", "value", "assert", "b", "internal", "server", "error", "in", "resp", "data", "assert", "resp", "status_code", "500", "flask", "g", "value", "23", "try", "flask", "g", "value", "except", "attributeerror", "runtimeerror", "pass", "else", "raise", "assertionerror", "some", "kind", "of", "exception", "expected"], "doc_len": 90}
{"doc_id": "tests/test_testing.py::test_reuse_client", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_reuse_client", "text": "文件路径: tests/test_testing.py\ndef test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n", "tokens": ["tests", "test_testing", "py", "def", "test_reuse_client", "client", "c", "client", "with", "c", "assert", "client", "get", "status_code", "404", "with", "c", "assert", "client", "get", "status_code", "404"], "doc_len": 22}
{"doc_id": "tests/test_testing.py::test_full_url_request", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_full_url_request", "text": "文件路径: tests/test_testing.py\ndef test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args\n", "tokens": ["tests", "test_testing", "py", "def", "test_full_url_request", "app", "client", "app", "route", "action", "methods", "post", "def", "action", "return", "x", "with", "client", "rv", "client", "post", "http", "domain", "com", "action", "vodka", "42", "data", "gin", "43", "assert", "rv", "status_code", "200", "assert", "gin", "in", "flask", "request", "form", "assert", "vodka", "in", "flask", "request", "args"], "doc_len": 46}
{"doc_id": "tests/test_testing.py::test_json_request_and_response", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_json_request_and_response", "text": "文件路径: tests/test_testing.py\ndef test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data\n", "tokens": ["tests", "test_testing", "py", "def", "test_json_request_and_response", "app", "client", "app", "route", "echo", "methods", "post", "def", "echo", "return", "jsonify", "flask", "request", "get_json", "with", "client", "json_data", "drink", "gin", "1", "tonic", "true", "price", "10", "rv", "client", "post", "echo", "json", "json_data", "request", "should", "be", "in", "json", "assert", "flask", "request", "is_json", "assert", "flask", "request", "get_json", "json_data", "response", "should", "be", "in", "json", "assert", "rv", "status_code", "200", "assert", "rv", "is_json", "assert", "rv", "get_json", "json_data"], "doc_len": 65}
{"doc_id": "tests/test_testing.py::test_client_json_no_app_context", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_client_json_no_app_context", "text": "文件路径: tests/test_testing.py\ndef test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1\n", "tokens": ["tests", "test_testing", "py", "def", "test_client_json_no_app_context", "app", "client", "app", "route", "hello", "methods", "post", "def", "hello", "return", "f", "hello", "flask", "request", "json", "name", "class", "namespace", "count", "0", "def", "add", "self", "app", "self", "count", "1", "ns", "namespace", "with", "appcontext_popped", "connected_to", "ns", "add", "app", "rv", "client", "post", "hello", "json", "name", "flask", "assert", "rv", "get_data", "as_text", "true", "hello", "flask", "assert", "ns", "count", "1"], "doc_len": 58}
{"doc_id": "tests/test_testing.py::test_subdomain", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_subdomain", "text": "文件路径: tests/test_testing.py\ndef test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n", "tokens": ["tests", "test_testing", "py", "def", "test_subdomain", "app", "flask", "flask", "__name__", "subdomain_matching", "true", "app", "config", "server_name", "example", "com", "client", "app", "test_client", "app", "route", "subdomain", "company_id", "def", "view", "company_id", "return", "company_id", "with", "app", "test_request_context", "url", "flask", "url_for", "view", "company_id", "xxx", "with", "client", "response", "client", "get", "url", "assert", "200", "response", "status_code", "assert", "b", "xxx", "response", "data"], "doc_len": 52}
{"doc_id": "tests/test_testing.py::test_nosubdomain", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_nosubdomain", "text": "文件路径: tests/test_testing.py\ndef test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n", "tokens": ["tests", "test_testing", "py", "def", "test_nosubdomain", "app", "client", "app", "config", "server_name", "example", "com", "app", "route", "company_id", "def", "view", "company_id", "return", "company_id", "with", "app", "test_request_context", "url", "flask", "url_for", "view", "company_id", "xxx", "with", "client", "response", "client", "get", "url", "assert", "200", "response", "status_code", "assert", "b", "xxx", "response", "data"], "doc_len": 44}
{"doc_id": "tests/test_testing.py::test_cli_runner_class", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_cli_runner_class", "text": "文件路径: tests/test_testing.py\ndef test_cli_runner_class(app):\n    runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)\n", "tokens": ["tests", "test_testing", "py", "def", "test_cli_runner_class", "app", "runner", "app", "test_cli_runner", "assert", "isinstance", "runner", "flaskclirunner", "class", "subrunner", "flaskclirunner", "pass", "app", "test_cli_runner_class", "subrunner", "runner", "app", "test_cli_runner", "assert", "isinstance", "runner", "subrunner"], "doc_len": 27}
{"doc_id": "tests/test_testing.py::test_cli_invoke", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_cli_invoke", "text": "文件路径: tests/test_testing.py\ndef test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output\n", "tokens": ["tests", "test_testing", "py", "def", "test_cli_invoke", "app", "app", "cli", "command", "hello", "def", "hello_command", "click", "echo", "hello", "world", "runner", "app", "test_cli_runner", "invoke", "with", "command", "name", "result", "runner", "invoke", "args", "hello", "assert", "hello", "in", "result", "output", "invoke", "with", "command", "object", "result", "runner", "invoke", "hello_command", "assert", "hello", "in", "result", "output"], "doc_len": 46}
{"doc_id": "tests/test_testing.py::test_cli_custom_obj", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_cli_custom_obj", "text": "文件路径: tests/test_testing.py\ndef test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called\n", "tokens": ["tests", "test_testing", "py", "def", "test_cli_custom_obj", "app", "class", "ns", "called", "false", "def", "create_app", "ns", "called", "true", "return", "app", "app", "cli", "command", "hello", "def", "hello_command", "click", "echo", "hello", "world", "script_info", "scriptinfo", "create_app", "create_app", "runner", "app", "test_cli_runner", "runner", "invoke", "hello_command", "obj", "script_info", "assert", "ns", "called"], "doc_len": 42}
{"doc_id": "tests/test_testing.py::test_client_pop_all_preserved", "file_path": "tests/test_testing.py", "class_name": null, "func_name": "test_client_pop_all_preserved", "text": "文件路径: tests/test_testing.py\ndef test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx\n", "tokens": ["tests", "test_testing", "py", "def", "test_client_pop_all_preserved", "app", "req_ctx", "client", "app", "route", "def", "index", "stream_with_context", "pushes", "a", "third", "context", "preserved", "by", "response", "return", "flask", "stream_with_context", "hello", "req_ctx", "fixture", "pushed", "an", "initial", "context", "with", "client", "request", "pushes", "a", "second", "request", "context", "preserved", "by", "client", "rv", "client", "get", "close", "the", "response", "releasing", "the", "context", "held", "by", "stream_with_context", "rv", "close", "only", "req_ctx", "fixture", "should", "still", "be", "pushed", "assert", "_cv_request", "get", "none", "is", "req_ctx"], "doc_len": 68}
{"doc_id": "tests/test_user_error_handler.py::test_error_handler_no_match", "file_path": "tests/test_user_error_handler.py", "class_name": null, "func_name": "test_error_handler_no_match", "text": "文件路径: tests/test_user_error_handler.py\ndef test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"\n", "tokens": ["tests", "test_user_error_handler", "py", "def", "test_error_handler_no_match", "app", "client", "class", "customexception", "exception", "pass", "app", "errorhandler", "customexception", "def", "custom_exception_handler", "e", "assert", "isinstance", "e", "customexception", "return", "custom", "with", "pytest", "raises", "typeerror", "as", "exc_info", "app", "register_error_handler", "customexception", "none", "assert", "customexception", "is", "an", "instance", "not", "a", "class", "in", "str", "exc_info", "value", "with", "pytest", "raises", "valueerror", "as", "exc_info", "app", "register_error_handler", "list", "none", "assert", "list", "is", "not", "a", "subclass", "of", "exception", "in", "str", "exc_info", "value", "app", "errorhandler", "500", "def", "handle_500", "e", "assert", "isinstance", "e", "internalservererror", "if", "e", "original_exception", "is", "not", "none", "return", "f", "wrapped", "type", "e", "original_exception", "__name__", "return", "direct", "with", "pytest", "raises", "valueerror", "as", "exc_info", "app", "register_error_handler", "999", "none", "assert", "use", "a", "subclass", "of", "httpexception", "in", "str", "exc_info", "value", "app", "route", "custom", "def", "custom_test", "raise", "customexception", "app", "route", "keyerror", "def", "key_error", "raise", "keyerror", "app", "route", "abort", "def", "do_abort", "flask", "abort", "500", "app", "testing", "false", "assert", "client", "get", "custom", "data", "b", "custom", "assert", "client", "get", "keyerror", "data", "b", "wrapped", "keyerror", "assert", "client", "get", "abort", "data", "b", "direct"], "doc_len": 159}
{"doc_id": "tests/test_user_error_handler.py::test_error_handler_subclass", "file_path": "tests/test_user_error_handler.py", "class_name": null, "func_name": "test_error_handler_subclass", "text": "文件路径: tests/test_user_error_handler.py\ndef test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"\n", "tokens": ["tests", "test_user_error_handler", "py", "def", "test_error_handler_subclass", "app", "class", "parentexception", "exception", "pass", "class", "childexceptionunregistered", "parentexception", "pass", "class", "childexceptionregistered", "parentexception", "pass", "app", "errorhandler", "parentexception", "def", "parent_exception_handler", "e", "assert", "isinstance", "e", "parentexception", "return", "parent", "app", "errorhandler", "childexceptionregistered", "def", "child_exception_handler", "e", "assert", "isinstance", "e", "childexceptionregistered", "return", "child", "registered", "app", "route", "parent", "def", "parent_test", "raise", "parentexception", "app", "route", "child", "unregistered", "def", "unregistered_test", "raise", "childexceptionunregistered", "app", "route", "child", "registered", "def", "registered_test", "raise", "childexceptionregistered", "c", "app", "test_client", "assert", "c", "get", "parent", "data", "b", "parent", "assert", "c", "get", "child", "unregistered", "data", "b", "parent", "assert", "c", "get", "child", "registered", "data", "b", "child", "registered"], "doc_len": 93}
{"doc_id": "tests/test_user_error_handler.py::test_error_handler_http_subclass", "file_path": "tests/test_user_error_handler.py", "class_name": null, "func_name": "test_error_handler_http_subclass", "text": "文件路径: tests/test_user_error_handler.py\ndef test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"\n", "tokens": ["tests", "test_user_error_handler", "py", "def", "test_error_handler_http_subclass", "app", "class", "forbiddensubclassregistered", "forbidden", "pass", "class", "forbiddensubclassunregistered", "forbidden", "pass", "app", "errorhandler", "403", "def", "code_exception_handler", "e", "assert", "isinstance", "e", "forbidden", "return", "forbidden", "app", "errorhandler", "forbiddensubclassregistered", "def", "subclass_exception_handler", "e", "assert", "isinstance", "e", "forbiddensubclassregistered", "return", "forbidden", "registered", "app", "route", "forbidden", "def", "forbidden_test", "raise", "forbidden", "app", "route", "forbidden", "registered", "def", "registered_test", "raise", "forbiddensubclassregistered", "app", "route", "forbidden", "unregistered", "def", "unregistered_test", "raise", "forbiddensubclassunregistered", "c", "app", "test_client", "assert", "c", "get", "forbidden", "data", "b", "forbidden", "assert", "c", "get", "forbidden", "unregistered", "data", "b", "forbidden", "assert", "c", "get", "forbidden", "registered", "data", "b", "forbidden", "registered"], "doc_len": 89}
{"doc_id": "tests/test_user_error_handler.py::test_error_handler_blueprint", "file_path": "tests/test_user_error_handler.py", "class_name": null, "func_name": "test_error_handler_blueprint", "text": "文件路径: tests/test_user_error_handler.py\ndef test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"\n", "tokens": ["tests", "test_user_error_handler", "py", "def", "test_error_handler_blueprint", "app", "bp", "flask", "blueprint", "bp", "__name__", "bp", "errorhandler", "500", "def", "bp_exception_handler", "e", "return", "bp", "error", "bp", "route", "error", "def", "bp_test", "raise", "internalservererror", "app", "errorhandler", "500", "def", "app_exception_handler", "e", "return", "app", "error", "app", "route", "error", "def", "app_test", "raise", "internalservererror", "app", "register_blueprint", "bp", "url_prefix", "bp", "c", "app", "test_client", "assert", "c", "get", "error", "data", "b", "app", "error", "assert", "c", "get", "bp", "error", "data", "b", "bp", "error"], "doc_len": 68}
{"doc_id": "tests/test_user_error_handler.py::test_default_error_handler", "file_path": "tests/test_user_error_handler.py", "class_name": null, "func_name": "test_default_error_handler", "text": "文件路径: tests/test_user_error_handler.py\ndef test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"\n", "tokens": ["tests", "test_user_error_handler", "py", "def", "test_default_error_handler", "bp", "flask", "blueprint", "bp", "__name__", "bp", "errorhandler", "httpexception", "def", "bp_exception_handler", "e", "assert", "isinstance", "e", "httpexception", "assert", "isinstance", "e", "notfound", "return", "bp", "default", "bp", "errorhandler", "forbidden", "def", "bp_forbidden_handler", "e", "assert", "isinstance", "e", "forbidden", "return", "bp", "forbidden", "bp", "route", "undefined", "def", "bp_registered_test", "raise", "notfound", "bp", "route", "forbidden", "def", "bp_forbidden_test", "raise", "forbidden", "app", "flask", "flask", "__name__", "app", "errorhandler", "httpexception", "def", "catchall_exception_handler", "e", "assert", "isinstance", "e", "httpexception", "assert", "isinstance", "e", "notfound", "return", "default", "app", "errorhandler", "forbidden", "def", "catchall_forbidden_handler", "e", "assert", "isinstance", "e", "forbidden", "return", "forbidden", "app", "route", "forbidden", "def", "forbidden", "raise", "forbidden", "app", "route", "slash", "def", "slash", "return", "slash", "app", "register_blueprint", "bp", "url_prefix", "bp", "c", "app", "test_client", "assert", "c", "get", "bp", "undefined", "data", "b", "bp", "default", "assert", "c", "get", "bp", "forbidden", "data", "b", "bp", "forbidden", "assert", "c", "get", "undefined", "data", "b", "default", "assert", "c", "get", "forbidden", "data", "b", "forbidden", "don", "t", "handle", "requestredirect", "raised", "when", "adding", "slash", "assert", "c", "get", "slash", "follow_redirects", "true", "data", "b", "slash"], "doc_len": 157}
{"doc_id": "tests/test_user_error_handler.py::TestGenericHandlers.app", "file_path": "tests/test_user_error_handler.py", "class_name": "TestGenericHandlers", "func_name": "app", "text": "文件路径: tests/test_user_error_handler.py, 类名: TestGenericHandlers\n    def app(self, app):\n        @app.route(\"/custom\")\n        def do_custom():\n            raise self.Custom()\n\n        @app.route(\"/error\")\n        def do_error():\n            raise KeyError()\n\n        @app.route(\"/abort\")\n        def do_abort():\n            flask.abort(500)\n\n        @app.route(\"/raise\")\n        def do_raise():\n            raise InternalServerError()\n\n        app.config[\"PROPAGATE_EXCEPTIONS\"] = False\n        return app\n", "tokens": ["tests", "test_user_error_handler", "py", "testgenerichandlers", "def", "app", "self", "app", "app", "route", "custom", "def", "do_custom", "raise", "self", "custom", "app", "route", "error", "def", "do_error", "raise", "keyerror", "app", "route", "abort", "def", "do_abort", "flask", "abort", "500", "app", "route", "raise", "def", "do_raise", "raise", "internalservererror", "app", "config", "propagate_exceptions", "false", "return", "app"], "doc_len": 44}
{"doc_id": "tests/test_user_error_handler.py::TestGenericHandlers.report_error", "file_path": "tests/test_user_error_handler.py", "class_name": "TestGenericHandlers", "func_name": "report_error", "text": "文件路径: tests/test_user_error_handler.py, 类名: TestGenericHandlers\n    def report_error(self, e):\n        original = getattr(e, \"original_exception\", None)\n\n        if original is not None:\n            return f\"wrapped {type(original).__name__}\"\n\n        return f\"direct {type(e).__name__}\"\n", "tokens": ["tests", "test_user_error_handler", "py", "testgenerichandlers", "def", "report_error", "self", "e", "original", "getattr", "e", "original_exception", "none", "if", "original", "is", "not", "none", "return", "f", "wrapped", "type", "original", "__name__", "return", "f", "direct", "type", "e", "__name__"], "doc_len": 30}
{"doc_id": "tests/test_user_error_handler.py::TestGenericHandlers.test_handle_class_or_code", "file_path": "tests/test_user_error_handler.py", "class_name": "TestGenericHandlers", "func_name": "test_handle_class_or_code", "text": "文件路径: tests/test_user_error_handler.py, 类名: TestGenericHandlers\n    def test_handle_class_or_code(self, app, client, to_handle):\n        \"\"\"``InternalServerError`` and ``500`` are aliases, they should\n        have the same behavior. Both should only receive\n        ``InternalServerError``, which might wrap another error.\n        \"\"\"\n\n        @app.errorhandler(to_handle)\n        def handle_500(e):\n            assert isinstance(e, InternalServerError)\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"wrapped Custom\"\n        assert client.get(\"/error\").data == b\"wrapped KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/raise\").data == b\"direct InternalServerError\"\n", "tokens": ["tests", "test_user_error_handler", "py", "testgenerichandlers", "def", "test_handle_class_or_code", "self", "app", "client", "to_handle", "internalservererror", "and", "500", "are", "aliases", "they", "should", "have", "the", "same", "behavior", "both", "should", "only", "receive", "internalservererror", "which", "might", "wrap", "another", "error", "app", "errorhandler", "to_handle", "def", "handle_500", "e", "assert", "isinstance", "e", "internalservererror", "return", "self", "report_error", "e", "assert", "client", "get", "custom", "data", "b", "wrapped", "custom", "assert", "client", "get", "error", "data", "b", "wrapped", "keyerror", "assert", "client", "get", "abort", "data", "b", "direct", "internalservererror", "assert", "client", "get", "raise", "data", "b", "direct", "internalservererror"], "doc_len": 77}
{"doc_id": "tests/test_user_error_handler.py::TestGenericHandlers.test_handle_generic_http", "file_path": "tests/test_user_error_handler.py", "class_name": "TestGenericHandlers", "func_name": "test_handle_generic_http", "text": "文件路径: tests/test_user_error_handler.py, 类名: TestGenericHandlers\n    def test_handle_generic_http(self, app, client):\n        \"\"\"``HTTPException`` should only receive ``HTTPException``\n        subclasses. It will receive ``404`` routing exceptions.\n        \"\"\"\n\n        @app.errorhandler(HTTPException)\n        def handle_http(e):\n            assert isinstance(e, HTTPException)\n            return str(e.code)\n\n        assert client.get(\"/error\").data == b\"500\"\n        assert client.get(\"/abort\").data == b\"500\"\n        assert client.get(\"/not-found\").data == b\"404\"\n", "tokens": ["tests", "test_user_error_handler", "py", "testgenerichandlers", "def", "test_handle_generic_http", "self", "app", "client", "httpexception", "should", "only", "receive", "httpexception", "subclasses", "it", "will", "receive", "404", "routing", "exceptions", "app", "errorhandler", "httpexception", "def", "handle_http", "e", "assert", "isinstance", "e", "httpexception", "return", "str", "e", "code", "assert", "client", "get", "error", "data", "b", "500", "assert", "client", "get", "abort", "data", "b", "500", "assert", "client", "get", "not", "found", "data", "b", "404"], "doc_len": 57}
{"doc_id": "tests/test_user_error_handler.py::TestGenericHandlers.test_handle_generic", "file_path": "tests/test_user_error_handler.py", "class_name": "TestGenericHandlers", "func_name": "test_handle_generic", "text": "文件路径: tests/test_user_error_handler.py, 类名: TestGenericHandlers\n    def test_handle_generic(self, app, client):\n        \"\"\"Generic ``Exception`` will handle all exceptions directly,\n        including ``HTTPExceptions``.\n        \"\"\"\n\n        @app.errorhandler(Exception)\n        def handle_exception(e):\n            return self.report_error(e)\n\n        assert client.get(\"/custom\").data == b\"direct Custom\"\n        assert client.get(\"/error\").data == b\"direct KeyError\"\n        assert client.get(\"/abort\").data == b\"direct InternalServerError\"\n        assert client.get(\"/not-found\").data == b\"direct NotFound\"\n", "tokens": ["tests", "test_user_error_handler", "py", "testgenerichandlers", "def", "test_handle_generic", "self", "app", "client", "generic", "exception", "will", "handle", "all", "exceptions", "directly", "including", "httpexceptions", "app", "errorhandler", "exception", "def", "handle_exception", "e", "return", "self", "report_error", "e", "assert", "client", "get", "custom", "data", "b", "direct", "custom", "assert", "client", "get", "error", "data", "b", "direct", "keyerror", "assert", "client", "get", "abort", "data", "b", "direct", "internalservererror", "assert", "client", "get", "not", "found", "data", "b", "direct", "notfound"], "doc_len": 61}
{"doc_id": "tests/test_views.py::common_test", "file_path": "tests/test_views.py", "class_name": null, "func_name": "common_test", "text": "文件路径: tests/test_views.py\ndef common_test(app):\n    c = app.test_client()\n\n    assert c.get(\"/\").data == b\"GET\"\n    assert c.post(\"/\").data == b\"POST\"\n    assert c.put(\"/\").status_code == 405\n    meths = parse_set_header(c.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n", "tokens": ["tests", "test_views", "py", "def", "common_test", "app", "c", "app", "test_client", "assert", "c", "get", "data", "b", "get", "assert", "c", "post", "data", "b", "post", "assert", "c", "put", "status_code", "405", "meths", "parse_set_header", "c", "open", "method", "options", "headers", "allow", "assert", "sorted", "meths", "get", "head", "options", "post"], "doc_len": 41}
{"doc_id": "tests/test_views.py::test_basic_view", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_basic_view", "text": "文件路径: tests/test_views.py\ndef test_basic_view(app):\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)\n", "tokens": ["tests", "test_views", "py", "def", "test_basic_view", "app", "class", "index", "flask", "views", "view", "methods", "get", "post", "def", "dispatch_request", "self", "return", "flask", "request", "method", "app", "add_url_rule", "view_func", "index", "as_view", "index", "common_test", "app"], "doc_len": 29}
{"doc_id": "tests/test_views.py::test_method_based_view", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_method_based_view", "text": "文件路径: tests/test_views.py\ndef test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)\n", "tokens": ["tests", "test_views", "py", "def", "test_method_based_view", "app", "class", "index", "flask", "views", "methodview", "def", "get", "self", "return", "get", "def", "post", "self", "return", "post", "app", "add_url_rule", "view_func", "index", "as_view", "index", "common_test", "app"], "doc_len": 29}
{"doc_id": "tests/test_views.py::test_view_patching", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_view_patching", "text": "文件路径: tests/test_views.py\ndef test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            1 // 0\n\n        def post(self):\n            1 // 0\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)\n", "tokens": ["tests", "test_views", "py", "def", "test_view_patching", "app", "class", "index", "flask", "views", "methodview", "def", "get", "self", "1", "0", "def", "post", "self", "1", "0", "class", "other", "index", "def", "get", "self", "return", "get", "def", "post", "self", "return", "post", "view", "index", "as_view", "index", "view", "view_class", "other", "app", "add_url_rule", "view_func", "view", "common_test", "app"], "doc_len": 47}
{"doc_id": "tests/test_views.py::test_view_inheritance", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_view_inheritance", "text": "文件路径: tests/test_views.py\ndef test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n", "tokens": ["tests", "test_views", "py", "def", "test_view_inheritance", "app", "client", "class", "index", "flask", "views", "methodview", "def", "get", "self", "return", "get", "def", "post", "self", "return", "post", "class", "betterindex", "index", "def", "delete", "self", "return", "delete", "app", "add_url_rule", "view_func", "betterindex", "as_view", "index", "meths", "parse_set_header", "client", "open", "method", "options", "headers", "allow", "assert", "sorted", "meths", "delete", "get", "head", "options", "post"], "doc_len": 52}
{"doc_id": "tests/test_views.py::test_view_decorators", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_view_decorators", "text": "文件路径: tests/test_views.py\ndef test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"\n", "tokens": ["tests", "test_views", "py", "def", "test_view_decorators", "app", "client", "def", "add_x_parachute", "f", "def", "new_function", "args", "kwargs", "resp", "flask", "make_response", "f", "args", "kwargs", "resp", "headers", "x", "parachute", "awesome", "return", "resp", "return", "new_function", "class", "index", "flask", "views", "view", "decorators", "add_x_parachute", "def", "dispatch_request", "self", "return", "awesome", "app", "add_url_rule", "view_func", "index", "as_view", "index", "rv", "client", "get", "assert", "rv", "headers", "x", "parachute", "awesome", "assert", "rv", "data", "b", "awesome"], "doc_len": 61}
{"doc_id": "tests/test_views.py::test_view_provide_automatic_options_attr", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_view_provide_automatic_options_attr", "text": "文件路径: tests/test_views.py\ndef test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow\n", "tokens": ["tests", "test_views", "py", "def", "test_view_provide_automatic_options_attr", "app", "flask", "flask", "__name__", "class", "index1", "flask", "views", "view", "provide_automatic_options", "false", "def", "dispatch_request", "self", "return", "hello", "world", "app", "add_url_rule", "view_func", "index1", "as_view", "index", "c", "app", "test_client", "rv", "c", "open", "method", "options", "assert", "rv", "status_code", "405", "app", "flask", "flask", "__name__", "class", "index2", "flask", "views", "view", "methods", "options", "provide_automatic_options", "true", "def", "dispatch_request", "self", "return", "hello", "world", "app", "add_url_rule", "view_func", "index2", "as_view", "index", "c", "app", "test_client", "rv", "c", "open", "method", "options", "assert", "sorted", "rv", "allow", "options", "app", "flask", "flask", "__name__", "class", "index3", "flask", "views", "view", "def", "dispatch_request", "self", "return", "hello", "world", "app", "add_url_rule", "view_func", "index3", "as_view", "index", "c", "app", "test_client", "rv", "c", "open", "method", "options", "assert", "options", "in", "rv", "allow"], "doc_len": 112}
{"doc_id": "tests/test_views.py::test_implicit_head", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_implicit_head", "text": "文件路径: tests/test_views.py\ndef test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"\n", "tokens": ["tests", "test_views", "py", "def", "test_implicit_head", "app", "client", "class", "index", "flask", "views", "methodview", "def", "get", "self", "return", "flask", "response", "blub", "headers", "x", "method", "flask", "request", "method", "app", "add_url_rule", "view_func", "index", "as_view", "index", "rv", "client", "get", "assert", "rv", "data", "b", "blub", "assert", "rv", "headers", "x", "method", "get", "rv", "client", "head", "assert", "rv", "data", "b", "assert", "rv", "headers", "x", "method", "head"], "doc_len": 58}
{"doc_id": "tests/test_views.py::test_explicit_head", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_explicit_head", "text": "文件路径: tests/test_views.py\ndef test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"\n", "tokens": ["tests", "test_views", "py", "def", "test_explicit_head", "app", "client", "class", "index", "flask", "views", "methodview", "def", "get", "self", "return", "get", "def", "head", "self", "return", "flask", "response", "headers", "x", "method", "head", "app", "add_url_rule", "view_func", "index", "as_view", "index", "rv", "client", "get", "assert", "rv", "data", "b", "get", "rv", "client", "head", "assert", "rv", "data", "b", "assert", "rv", "headers", "x", "method", "head"], "doc_len": 54}
{"doc_id": "tests/test_views.py::test_endpoint_override", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_endpoint_override", "text": "文件路径: tests/test_views.py\ndef test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)\n", "tokens": ["tests", "test_views", "py", "def", "test_endpoint_override", "app", "app", "debug", "true", "class", "index", "flask", "views", "view", "methods", "get", "post", "def", "dispatch_request", "self", "return", "flask", "request", "method", "app", "add_url_rule", "view_func", "index", "as_view", "index", "with", "pytest", "raises", "assertionerror", "app", "add_url_rule", "view_func", "index", "as_view", "index", "but", "these", "tests", "should", "still", "pass", "we", "just", "log", "a", "warning", "common_test", "app"], "doc_len": 53}
{"doc_id": "tests/test_views.py::test_methods_var_inheritance", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_methods_var_inheritance", "text": "文件路径: tests/test_views.py\ndef test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}\n", "tokens": ["tests", "test_views", "py", "def", "test_methods_var_inheritance", "app", "client", "class", "baseview", "flask", "views", "methodview", "methods", "get", "propfind", "class", "childview", "baseview", "def", "get", "self", "return", "get", "def", "propfind", "self", "return", "propfind", "app", "add_url_rule", "view_func", "childview", "as_view", "index", "assert", "client", "get", "data", "b", "get", "assert", "client", "open", "method", "propfind", "data", "b", "propfind", "assert", "childview", "methods", "propfind", "get"], "doc_len": 53}
{"doc_id": "tests/test_views.py::test_multiple_inheritance", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_multiple_inheritance", "text": "文件路径: tests/test_views.py\ndef test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]\n", "tokens": ["tests", "test_views", "py", "def", "test_multiple_inheritance", "app", "client", "class", "getview", "flask", "views", "methodview", "def", "get", "self", "return", "get", "class", "deleteview", "flask", "views", "methodview", "def", "delete", "self", "return", "delete", "class", "getdeleteview", "getview", "deleteview", "pass", "app", "add_url_rule", "view_func", "getdeleteview", "as_view", "index", "assert", "client", "get", "data", "b", "get", "assert", "client", "delete", "data", "b", "delete", "assert", "sorted", "getdeleteview", "methods", "delete", "get"], "doc_len": 56}
{"doc_id": "tests/test_views.py::test_remove_method_from_parent", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_remove_method_from_parent", "text": "文件路径: tests/test_views.py\ndef test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]\n", "tokens": ["tests", "test_views", "py", "def", "test_remove_method_from_parent", "app", "client", "class", "getview", "flask", "views", "methodview", "def", "get", "self", "return", "get", "class", "otherview", "flask", "views", "methodview", "def", "post", "self", "return", "post", "class", "view", "getview", "otherview", "methods", "get", "app", "add_url_rule", "view_func", "view", "as_view", "index", "assert", "client", "get", "data", "b", "get", "assert", "client", "post", "status_code", "405", "assert", "sorted", "view", "methods", "get"], "doc_len": 55}
{"doc_id": "tests/test_views.py::test_init_once", "file_path": "tests/test_views.py", "class_name": null, "func_name": "test_init_once", "text": "文件路径: tests/test_views.py\ndef test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"\n", "tokens": ["tests", "test_views", "py", "def", "test_init_once", "app", "client", "n", "0", "class", "countinit", "flask", "views", "view", "init_every_request", "false", "def", "__init__", "self", "nonlocal", "n", "n", "1", "def", "dispatch_request", "self", "return", "str", "n", "app", "add_url_rule", "view_func", "countinit", "as_view", "index", "assert", "client", "get", "data", "b", "1", "assert", "client", "get", "data", "b", "1"], "doc_len": 47}
{"doc_id": "tests/test_apps/blueprintapp/apps/admin/__init__.py::index", "file_path": "tests/test_apps/blueprintapp/apps/admin/__init__.py", "class_name": null, "func_name": "index", "text": "文件路径: tests/test_apps/blueprintapp/apps/admin/__init__.py\ndef index():\n    return render_template(\"admin/index.html\")\n", "tokens": ["tests", "test_apps", "blueprintapp", "apps", "admin", "__init__", "py", "def", "index", "return", "render_template", "admin", "index", "html"], "doc_len": 14}
{"doc_id": "tests/test_apps/blueprintapp/apps/admin/__init__.py::index2", "file_path": "tests/test_apps/blueprintapp/apps/admin/__init__.py", "class_name": null, "func_name": "index2", "text": "文件路径: tests/test_apps/blueprintapp/apps/admin/__init__.py\ndef index2():\n    return render_template(\"./admin/index.html\")\n", "tokens": ["tests", "test_apps", "blueprintapp", "apps", "admin", "__init__", "py", "def", "index2", "return", "render_template", "admin", "index", "html"], "doc_len": 14}
{"doc_id": "tests/test_apps/blueprintapp/apps/frontend/__init__.py::index", "file_path": "tests/test_apps/blueprintapp/apps/frontend/__init__.py", "class_name": null, "func_name": "index", "text": "文件路径: tests/test_apps/blueprintapp/apps/frontend/__init__.py\ndef index():\n    return render_template(\"frontend/index.html\")\n", "tokens": ["tests", "test_apps", "blueprintapp", "apps", "frontend", "__init__", "py", "def", "index", "return", "render_template", "frontend", "index", "html"], "doc_len": 14}
{"doc_id": "tests/test_apps/blueprintapp/apps/frontend/__init__.py::missing_template", "file_path": "tests/test_apps/blueprintapp/apps/frontend/__init__.py", "class_name": null, "func_name": "missing_template", "text": "文件路径: tests/test_apps/blueprintapp/apps/frontend/__init__.py\ndef missing_template():\n    return render_template(\"missing_template.html\")\n", "tokens": ["tests", "test_apps", "blueprintapp", "apps", "frontend", "__init__", "py", "def", "missing_template", "return", "render_template", "missing_template", "html"], "doc_len": 13}
{"doc_id": "tests/test_apps/cliapp/factory.py::create_app", "file_path": "tests/test_apps/cliapp/factory.py", "class_name": null, "func_name": "create_app", "text": "文件路径: tests/test_apps/cliapp/factory.py\ndef create_app():\n    return Flask(\"app\")\n", "tokens": ["tests", "test_apps", "cliapp", "factory", "py", "def", "create_app", "return", "flask", "app"], "doc_len": 10}
{"doc_id": "tests/test_apps/cliapp/factory.py::create_app2", "file_path": "tests/test_apps/cliapp/factory.py", "class_name": null, "func_name": "create_app2", "text": "文件路径: tests/test_apps/cliapp/factory.py\ndef create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))\n", "tokens": ["tests", "test_apps", "cliapp", "factory", "py", "def", "create_app2", "foo", "bar", "return", "flask", "_", "join", "app2", "foo", "bar"], "doc_len": 16}
{"doc_id": "tests/test_apps/cliapp/factory.py::no_app", "file_path": "tests/test_apps/cliapp/factory.py", "class_name": null, "func_name": "no_app", "text": "文件路径: tests/test_apps/cliapp/factory.py\ndef no_app():\n    pass\n", "tokens": ["tests", "test_apps", "cliapp", "factory", "py", "def", "no_app", "pass"], "doc_len": 8}
{"doc_id": "tests/test_apps/helloworld/hello.py::hello", "file_path": "tests/test_apps/helloworld/hello.py", "class_name": null, "func_name": "hello", "text": "文件路径: tests/test_apps/helloworld/hello.py\ndef hello():\n    return \"Hello World!\"\n", "tokens": ["tests", "test_apps", "helloworld", "hello", "py", "def", "hello", "return", "hello", "world"], "doc_len": 10}
{"doc_id": "tests/typing/typing_app_decorators.py::after_sync", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "after_sync", "text": "文件路径: tests/typing/typing_app_decorators.py\ndef after_sync(response: Response) -> Response:\n    return Response()\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "def", "after_sync", "response", "response", "response", "return", "response"], "doc_len": 11}
{"doc_id": "tests/typing/typing_app_decorators.py::after_async", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "after_async", "text": "文件路径: tests/typing/typing_app_decorators.py\nasync def after_async(response: Response) -> Response:\n    return Response()\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "async", "def", "after_async", "response", "response", "response", "return", "response"], "doc_len": 12}
{"doc_id": "tests/typing/typing_app_decorators.py::before_sync", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "before_sync", "text": "文件路径: tests/typing/typing_app_decorators.py\ndef before_sync() -> None:\n    ...\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "def", "before_sync", "none"], "doc_len": 7}
{"doc_id": "tests/typing/typing_app_decorators.py::before_async", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "before_async", "text": "文件路径: tests/typing/typing_app_decorators.py\nasync def before_async() -> None:\n    ...\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "async", "def", "before_async", "none"], "doc_len": 8}
{"doc_id": "tests/typing/typing_app_decorators.py::teardown_sync", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "teardown_sync", "text": "文件路径: tests/typing/typing_app_decorators.py\ndef teardown_sync(exc: t.Optional[BaseException]) -> None:\n    ...\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "def", "teardown_sync", "exc", "t", "optional", "baseexception", "none"], "doc_len": 11}
{"doc_id": "tests/typing/typing_app_decorators.py::teardown_async", "file_path": "tests/typing/typing_app_decorators.py", "class_name": null, "func_name": "teardown_async", "text": "文件路径: tests/typing/typing_app_decorators.py\nasync def teardown_async(exc: t.Optional[BaseException]) -> None:\n    ...\n", "tokens": ["tests", "typing", "typing_app_decorators", "py", "async", "def", "teardown_async", "exc", "t", "optional", "baseexception", "none"], "doc_len": 12}
{"doc_id": "tests/typing/typing_error_handler.py::handle_400", "file_path": "tests/typing/typing_error_handler.py", "class_name": null, "func_name": "handle_400", "text": "文件路径: tests/typing/typing_error_handler.py\ndef handle_400(e: BadRequest) -> str:\n    return \"\"\n", "tokens": ["tests", "typing", "typing_error_handler", "py", "def", "handle_400", "e", "badrequest", "str", "return"], "doc_len": 10}
{"doc_id": "tests/typing/typing_error_handler.py::handle_custom", "file_path": "tests/typing/typing_error_handler.py", "class_name": null, "func_name": "handle_custom", "text": "文件路径: tests/typing/typing_error_handler.py\ndef handle_custom(e: ValueError) -> str:\n    return \"\"\n", "tokens": ["tests", "typing", "typing_error_handler", "py", "def", "handle_custom", "e", "valueerror", "str", "return"], "doc_len": 10}
{"doc_id": "tests/typing/typing_error_handler.py::handle_accept_base", "file_path": "tests/typing/typing_error_handler.py", "class_name": null, "func_name": "handle_accept_base", "text": "文件路径: tests/typing/typing_error_handler.py\ndef handle_accept_base(e: Exception) -> str:\n    return \"\"\n", "tokens": ["tests", "typing", "typing_error_handler", "py", "def", "handle_accept_base", "e", "exception", "str", "return"], "doc_len": 10}
{"doc_id": "tests/typing/typing_error_handler.py::handle_multiple", "file_path": "tests/typing/typing_error_handler.py", "class_name": null, "func_name": "handle_multiple", "text": "文件路径: tests/typing/typing_error_handler.py\ndef handle_multiple(e: BadRequest | NotFound) -> str:\n    return \"\"\n", "tokens": ["tests", "typing", "typing_error_handler", "py", "def", "handle_multiple", "e", "badrequest", "notfound", "str", "return"], "doc_len": 11}
{"doc_id": "tests/typing/typing_route.py::hello_str", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_str", "text": "文件路径: tests/typing/typing_route.py\ndef hello_str() -> str:\n    return \"<p>Hello, World!</p>\"\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_str", "str", "return", "p", "hello", "world", "p"], "doc_len": 12}
{"doc_id": "tests/typing/typing_route.py::hello_bytes", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_bytes", "text": "文件路径: tests/typing/typing_route.py\ndef hello_bytes() -> bytes:\n    return b\"<p>Hello, World!</p>\"\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_bytes", "bytes", "return", "b", "p", "hello", "world", "p"], "doc_len": 13}
{"doc_id": "tests/typing/typing_route.py::hello_json", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_json", "text": "文件路径: tests/typing/typing_route.py\ndef hello_json() -> Response:\n    return jsonify(\"Hello, World!\")\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_json", "response", "return", "jsonify", "hello", "world"], "doc_len": 11}
{"doc_id": "tests/typing/typing_route.py::hello_json_dict", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_json_dict", "text": "文件路径: tests/typing/typing_route.py\ndef hello_json_dict() -> t.Dict[str, t.Any]:\n    return {\"response\": \"Hello, World!\"}\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_json_dict", "t", "dict", "str", "t", "any", "return", "response", "hello", "world"], "doc_len": 15}
{"doc_id": "tests/typing/typing_route.py::hello_json_list", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_json_list", "text": "文件路径: tests/typing/typing_route.py\ndef hello_json_list() -> t.List[t.Any]:\n    return [{\"message\": \"Hello\"}, {\"message\": \"World\"}]\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_json_list", "t", "list", "t", "any", "return", "message", "hello", "message", "world"], "doc_len": 15}
{"doc_id": "tests/typing/typing_route.py::typed_dict", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "typed_dict", "text": "文件路径: tests/typing/typing_route.py\ndef typed_dict() -> StatusJSON:\n    return {\"status\": \"ok\"}\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "typed_dict", "statusjson", "return", "status", "ok"], "doc_len": 10}
{"doc_id": "tests/typing/typing_route.py::hello_generator", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_generator", "text": "文件路径: tests/typing/typing_route.py\ndef hello_generator() -> t.Generator[str, None, None]:\n    def show() -> t.Generator[str, None, None]:\n        for x in range(100):\n            yield f\"data:{x}\\n\\n\"\n\n    return show()\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_generator", "t", "generator", "str", "none", "none", "def", "show", "t", "generator", "str", "none", "none", "for", "x", "in", "range", "100", "yield", "f", "data", "x", "n", "n", "return", "show"], "doc_len": 31}
{"doc_id": "tests/typing/typing_route.py::hello_generator_expression", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_generator_expression", "text": "文件路径: tests/typing/typing_route.py\ndef hello_generator_expression() -> t.Iterator[bytes]:\n    return (f\"data:{x}\\n\\n\".encode() for x in range(100))\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_generator_expression", "t", "iterator", "bytes", "return", "f", "data", "x", "n", "n", "encode", "for", "x", "in", "range", "100"], "doc_len": 21}
{"doc_id": "tests/typing/typing_route.py::hello_iterator", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "hello_iterator", "text": "文件路径: tests/typing/typing_route.py\ndef hello_iterator() -> t.Iterator[str]:\n    return iter([f\"data:{x}\\n\\n\" for x in range(100)])\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "hello_iterator", "t", "iterator", "str", "return", "iter", "f", "data", "x", "n", "n", "for", "x", "in", "range", "100"], "doc_len": 21}
{"doc_id": "tests/typing/typing_route.py::tuple_status", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "tuple_status", "text": "文件路径: tests/typing/typing_route.py\ndef tuple_status(code: int = 200) -> tuple[str, int]:\n    return \"hello\", code\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "tuple_status", "code", "int", "200", "tuple", "str", "int", "return", "hello", "code"], "doc_len": 15}
{"doc_id": "tests/typing/typing_route.py::tuple_status_enum", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "tuple_status_enum", "text": "文件路径: tests/typing/typing_route.py\ndef tuple_status_enum() -> tuple[str, int]:\n    return \"hello\", HTTPStatus.OK\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "tuple_status_enum", "tuple", "str", "int", "return", "hello", "httpstatus", "ok"], "doc_len": 13}
{"doc_id": "tests/typing/typing_route.py::tuple_headers", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "tuple_headers", "text": "文件路径: tests/typing/typing_route.py\ndef tuple_headers() -> tuple[str, dict[str, str]]:\n    return \"Hello, World!\", {\"Content-Type\": \"text/plain\"}\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "tuple_headers", "tuple", "str", "dict", "str", "str", "return", "hello", "world", "content", "type", "text", "plain"], "doc_len": 18}
{"doc_id": "tests/typing/typing_route.py::return_template", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "return_template", "text": "文件路径: tests/typing/typing_route.py\ndef return_template(name: str | None = None) -> str:\n    return render_template(\"index.html\", name=name)\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "return_template", "name", "str", "none", "none", "str", "return", "render_template", "index", "html", "name", "name"], "doc_len": 17}
{"doc_id": "tests/typing/typing_route.py::return_template_stream", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "return_template_stream", "text": "文件路径: tests/typing/typing_route.py\ndef return_template_stream() -> t.Iterator[str]:\n    return stream_template(\"index.html\", name=\"Hello\")\n", "tokens": ["tests", "typing", "typing_route", "py", "def", "return_template_stream", "t", "iterator", "str", "return", "stream_template", "index", "html", "name", "hello"], "doc_len": 15}
{"doc_id": "tests/typing/typing_route.py::async_route", "file_path": "tests/typing/typing_route.py", "class_name": null, "func_name": "async_route", "text": "文件路径: tests/typing/typing_route.py\nasync def async_route() -> str:\n    return \"Hello\"\n", "tokens": ["tests", "typing", "typing_route", "py", "async", "def", "async_route", "str", "return", "hello"], "doc_len": 10}
{"doc_id": "tests/typing/typing_route.py::RenderTemplateView.__init__", "file_path": "tests/typing/typing_route.py", "class_name": "RenderTemplateView", "func_name": "__init__", "text": "文件路径: tests/typing/typing_route.py, 类名: RenderTemplateView\n    def __init__(self: RenderTemplateView, template_name: str) -> None:\n        self.template_name = template_name\n", "tokens": ["tests", "typing", "typing_route", "py", "rendertemplateview", "def", "__init__", "self", "rendertemplateview", "template_name", "str", "none", "self", "template_name", "template_name"], "doc_len": 15}
{"doc_id": "tests/typing/typing_route.py::RenderTemplateView.dispatch_request", "file_path": "tests/typing/typing_route.py", "class_name": "RenderTemplateView", "func_name": "dispatch_request", "text": "文件路径: tests/typing/typing_route.py, 类名: RenderTemplateView\n    def dispatch_request(self: RenderTemplateView) -> str:\n        return render_template(self.template_name)\n", "tokens": ["tests", "typing", "typing_route", "py", "rendertemplateview", "def", "dispatch_request", "self", "rendertemplateview", "str", "return", "render_template", "self", "template_name"], "doc_len": 14}
